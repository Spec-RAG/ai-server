{"id": "sha256:36a53a6af9a30ee0adecb749291aac1e06d92fdf205627f278c0f385c30569b7", "content": "This chapter covers Spring Data's Ahead of Time (AOT) optimizations that build upon {spring-framework-docs}/core/aot.html[Spring's Ahead of Time Optimizations].\n\n[[aot.bestpractices]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/aot.adoc", "title": "Ahead of Time Optimizations", "heading": "Ahead of Time Optimizations", "heading_level": 1, "file_order": 0, "section_index": 0, "content_hash": "36a53a6af9a30ee0adecb749291aac1e06d92fdf205627f278c0f385c30569b7", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/aot.adoc"}}
{"id": "sha256:9f45a007b47c4a66f9e5969e40acf99e1de2def3e77401757082c82796e02f6e", "content": "During application startup, Spring scans the classpath for domain classes for early processing of entities.\nBy annotating your domain types with Spring Data-specific `@Table`, `@Document` or `@Entity` annotations you can aid initial entity scanning and ensure that those types are registered with `ManagedTypes` for Runtime Hints.\nClasspath scanning is not possible in native image arrangements and so Spring has to use `ManagedTypes` for the initial entity set.\n\n[[aot.hints]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/aot.adoc", "title": "Ahead of Time Optimizations", "heading": "Annotate your Domain Types", "heading_level": 3, "file_order": 0, "section_index": 1, "content_hash": "9f45a007b47c4a66f9e5969e40acf99e1de2def3e77401757082c82796e02f6e", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/aot.adoc"}}
{"id": "sha256:e2109d75db02108fa9e04e5b5d7a63f5c38b687c7ba40c7cf31a0f435efe557c", "content": "Running an application as a native image requires additional information compared to a regular JVM runtime.\nSpring Data contributes {spring-framework-docs}/core/aot.html#aot.hints[Runtime Hints] during AOT processing for native image usage.\nThese are in particular hints for:\n\n* Auditing\n* `ManagedTypes` to capture the outcome of class-path scans\n* Repositories\n** Reflection hints for entities, return types, and Spring Data annotations\n** Repository fragments\n** Querydsl `Q` classes\n** Kotlin Coroutine support\n* Web support (Jackson Hints for `PagedModel`)\n\n[[aot.repositories]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/aot.adoc", "title": "Ahead of Time Optimizations", "heading": "Runtime Hints", "heading_level": 2, "file_order": 0, "section_index": 2, "content_hash": "e2109d75db02108fa9e04e5b5d7a63f5c38b687c7ba40c7cf31a0f435efe557c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/aot.adoc"}}
{"id": "sha256:2ef46ee0ce1d353ea88c84e18aa8ab1831f94418e6feb604ddc2ffc16975bd8c", "content": "AOT Repositories are an extension to AOT processing by pre-generating eligible query method implementations.\nQuery methods are opaque to developers regarding their underlying queries being executed in a query method call.\nAOT repositories contribute query method implementations based on derived, annotated, and named queries that are known at build-time.\nThis optimization moves query method processing from runtime to build-time, which can lead to a significant performance improvement as query methods do not need to be analyzed reflectively upon each application start.\n\nThe resulting AOT repository fragment follows the naming scheme of `<Repository FQCN>Impl__Aot` and is placed in the same package as the repository interface.\nYou can find all queries in their String form for generated repository query methods.\n\nNOTE: Consider AOT repository classes an internal optimization.\nDo not use them directly in your code as generation and implementation details may change in future releases.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/aot.adoc", "title": "Ahead of Time Optimizations", "heading": "Ahead of Time Repositories", "heading_level": 2, "file_order": 0, "section_index": 3, "content_hash": "2ef46ee0ce1d353ea88c84e18aa8ab1831f94418e6feb604ddc2ffc16975bd8c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/aot.adoc"}}
{"id": "sha256:844db782e72981e04dbd8f78ad56680e760559a9c83bbd0631b9836a9c026e4c", "content": "AOT is a mandatory step to transform a Spring application to a native executable, so it is automatically enabled when running in this mode.\nWhen AOT is enabled (either for native compilation or by setting `spring.aot.enabled=true`), AOT repositories are automatically enabled by default.\n\nYou can disable AOT repository generation entirely or only disable Cassandra AOT repositories:\n\n* Set the `spring.aot.repositories.enabled=false` property to disable generated repositories for all Spring Data modules.\n* Set the `spring.aot.cassandra.repositories.enabled=false` property to disable only C AOT repositories.\n\nAOT repositories contribute configuration changes to the actual repository bean registration to register the generated repository fragment.\n\nNOTE: When AOT optimizations are included, some decisions that have been taken at build-time are hard-coded in the application setup.\nFor instance, profiles that have been enabled at build-time are automatically enabled at runtime as well.\nAlso, the Spring Data module implementing a repository is fixed.\nChanging the implementation requires AOT re-processing.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/aot.adoc", "title": "Ahead of Time Optimizations", "heading": "Running with AOT Repositories", "heading_level": 3, "file_order": 0, "section_index": 4, "content_hash": "844db782e72981e04dbd8f78ad56680e760559a9c83bbd0631b9836a9c026e4c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/aot.adoc"}}
{"id": "sha256:b00f0478d11b00b87f64be01d066f159a3e16e7e8eb7ffda1ae43d6537e0e205", "content": "AOT repositories filter methods that are eligible for AOT processing.\nThese are typically all query methods that are not backed by an xref:repositories/custom-implementations.adoc[implementation fragment].\n\n**Supported Features**\n\n* Derived query methods, `@Query` and named query methods.\n* `Window`, `Slice`, `Stream`, and `Optional` return types\n* Sort query rewriting\n* Interface and DTO Projections\n* Value Expressions (Those require a bit of reflective information.\nMind that using Value Expressions requires expression parsing and contextual information to evaluate the expression)\n\n**Limitation**\n\n* Vector Search not yet supported\n\n**Excluded methods**\n\n* `CrudRepository` and other base interface methods as their implementation is provided by the base class respective fragments\n* Vector Search Methods\n\n[[aot.repositories.json]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/aot.adoc", "title": "Ahead of Time Optimizations", "heading": "Eligible Methods", "heading_level": 3, "file_order": 0, "section_index": 5, "content_hash": "b00f0478d11b00b87f64be01d066f159a3e16e7e8eb7ffda1ae43d6537e0e205", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/aot.adoc"}}
{"id": "sha256:9cba2f278178b0d5127db263c80ba9338b04197b28f45a6bebef6173435b8e16", "content": "AOT processing introspects query methods and collects metadata about repository queries.\nSpring Data Cassandra stores this metadata in JSON files that are named like the repository interface and stored next to it (i.e. within the same package).\nRepository JSON Metadata contains details about queries and fragments.\nAn example for the following repository is shown below:\n\n====\n[source,java]\n----\ninterface UserRepository extends CrudRepository<User, Integer> {\n\n List<User> findUserNoArgumentsBy(); <1>\n\n Slice<User> findSliceOfUsersByLastnameStartingWith(String lastname, Pageable page); <2>\n\n @Query(\"select * from User where emailAddress = :emailAddress\")\n User findAnnotatedQueryByEmailAddress(String emailAddress); <3>\n\n User findByEmailAddress(String emailAddress); <4>\n}\n----\n\n<1> Derived query without arguments.\n<2> Derived query using pagination.\n<3> Annotated query.\n<4> Named query.\n====\n\n[source,json]\n----\n{\n \"name\": \"com.acme.UserRepository\",\n \"module\": \"Cassandra\",\n \"type\": \"IMPERATIVE\",\n \"methods\": [\n {\n \"name\": \"findUserNoArgumentsBy\",\n \"signature\": \"public abstract java.util.List<com.acme.User> com.acme.UserRepository.findUserNoArgumentsBy()\",\n \"query\": {\n \"query\": \"select * from user\"\n }\n },\n {\n \"name\": \"findSliceOfUsersByLastnameStartingWith\",\n \"signature\": \"public abstract org.springframework.data.domain.Slice<com.acme.User> com.acme.UserRepository.findSliceOfUsersByLastnameStartingWith(java.lang.String,org.springframework.data.domain.Pageable)\",\n \"query\": {\n \"query\": \"select * from user where lastname like ?\"\n }\n },\n {\n \"name\": \"findAnnotatedQueryByEmailAddress\",\n \"signature\": \"public abstract com.acme.User com.acme.UserRepository.findAnnotatedQueryByEmailAddress(java.lang.String)\",\n \"query\": {\n \"query\": \"select * from user where emailaddress = ?\"\n }\n },\n {\n \"name\": \"findByEmailAddress\",\n \"signature\": \"public abstract com.acme.User com.acme.UserRepository.findByEmailAddress(java.lang.String)\",\n \"query\": {\n \"name\": \"User.findByEmailAddress\",\n \"query\": \"select * from user where emailaddress = ?\"\n }\n },\n {\n \"name\": \"count\",\n \"signature\": \"public abstract long org.springframework.data.repository.CrudRepository.count()\",\n \"fragment\": {\n \"fragment\": \"org.springframework.data.cassandra.repository.support.SimpleCassandraRepository\"\n }\n }\n ]\n}\n----\n\nQueries may contain the following fields:\n\n* `query`: Query descriptor if the method is a query method.\n** `query` the query used to obtain the query method results.\n** `name`: Name of the named query if the query is a named one.\n* `fragment`: Target fragment if the method call is delegated to a store (repository base class, functional fragment such as Querydsl) or user fragment.\nFragments are either described with just `fragment` if there is no further interface or as `interface` and `fragment` tuple in case there is an interface (such as Querydsl or user-declared fragment interface).\n\n[NOTE]\n.Normalized Query Form\n====\nStatic analysis of queries allows only a limited representation of runtime query behavior.\nQueries are represented in their normalized (pre-parsed and rewritten) form:\n\n* Value Expressions are replaced with bind markers.\n* Query Metadata does not reflect bind-value processing.\n`StartingWith`/`EndingWith` queries prepend/append the wildcard character `%` to the actual bind value.\n* Runtime Sort information cannot be incorporated in the query string itself as that detail is not known at build-time.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/aot.adoc", "title": "Ahead of Time Optimizations", "heading": "Repository Metadata", "heading_level": 2, "file_order": 0, "section_index": 6, "content_hash": "9cba2f278178b0d5127db263c80ba9338b04197b28f45a6bebef6173435b8e16", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/aot.adoc"}}
{"id": "sha256:3056ff79c9ea3fdb797c4550631ffcabe730d6321abf1b26116bfd7aeb97070a", "content": "[[cassandra.repositories.misc.cdi-integration]]\n\nInstances of the repository interfaces are usually created by a container, and the Spring container is the most natural choice when working with Spring Data.\nSpring Data for Apache Cassandra ships with a custom CDI extension that allows using the repository abstraction in CDI environments.\nThe extension is part of the JAR.To activate it, drop the Spring Data for Apache Cassandra JAR into your classpath.\nYou can now set up the infrastructure by implementing a CDI Producer for the\n`CassandraTemplate`, as the following examlpe shows:\n\n====\n[source,java]\n----\nclass CassandraTemplateProducer {\n\n\t@Produces\n\t@Singleton\n\tpublic CqlSession createSession() {\n\t\treturn CqlSession.builder().withKeyspace(\"my-keyspace\").build();\n\t}\n\n\t@Produces\n\t@ApplicationScoped\n\tpublic CassandraOperations createCassandraOperations(CqlSession session) {\n\n\t\tCassandraMappingContext mappingContext = new CassandraMappingContext();\n\t\tmappingContext.afterPropertiesSet();\n\n\t\tMappingCassandraConverter cassandraConverter = new MappingCassandraConverter(mappingContext);\n\t\tcassandraConverter.setUserTypeResolver(new SimpleUserTypeResolver(session));\n\t\tcassandraConverter.afterPropertiesSet();\n\n\t\treturn new CassandraAdminTemplate(session, cassandraConverter);\n\t}\n\n\tpublic void close(@Disposes CqlSession session) {\n\t\tsession.close();\n\t}\n}\n----\n====\n\nThe Spring Data for Apache Cassandra CDI extension picks up `CassandraOperations` as a CDI bean and creates a proxy for a Spring Data repository whenever a bean of a repository type is requested by the container.\nThus, obtaining an instance of a Spring Data repository is a matter of declaring an injected property, as the following example shows:\n\n====\n[source,java]\n----\nclass RepositoryClient {\n\n\t@Inject PersonRepository repository;\n\n\tpublic void businessMethod() {\n\t\tList<Person> people = repository.findAll();\n\t}\n}\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/cdi-integration.adoc", "title": "cdi-integration", "heading": "cdi-integration", "heading_level": 1, "file_order": 1, "section_index": 0, "content_hash": "3056ff79c9ea3fdb797c4550631ffcabe730d6321abf1b26116bfd7aeb97070a", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/cdi-integration.adoc"}}
{"id": "sha256:ccfca1d6968c0a589b325d506665bf6733803e89bfedf8c55be545d3657823fb", "content": "[[cassandra.repositories.queries]]\n\nNOTE: This chapter explains Cassandra-specific query methods.\nThis documentation uses imperative types.\nBy using reactive return types, the same semantics apply to reactive repositories as well.\n\nMost of the data access operations you usually trigger on a repository result in a query being executed against the Apache Cassandra database.\nDefining such a query is a matter of declaring a method on the repository interface.\nThe following example shows a number of such method declarations:\n\n.PersonRepository with query methods\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\ninterface PersonRepository extends CrudRepository<Person, String> {\n\n List<Person> findByLastname(String lastname); <1>\n\n Slice<Person> findByFirstname(String firstname, Pageable pageRequest); <2>\n\n Window<Person> findByFirstname(String firstname, CassandraScrollPosition pos, Limit limit); <3>\n\n List<Person> findByFirstname(String firstname, QueryOptions opts); <4>\n\n List<Person> findByFirstname(String firstname, Sort sort); <5>\n\n List<Person> findByFirstname(String firstname, Limit limit); <6>\n\n Person findByShippingAddress(Address address); <7>\n\n Person findFirstByShippingAddress(Address address); <8>\n\n Stream<Person> findAllBy(); <9>\n\n @AllowFiltering\n List<Person> findAllByAge(int age); <10>\n}\n----\n<1> The method shows a query for all people with the given `lastname`.\nThe query is derived from parsing the method name for constraints, which can be concatenated with `And`.\nThus, the method name results in a query expression of `SELECT * FROM person WHERE lastname = 'lastname'`.\n<2> Applies pagination to a query.\nYou can equip your method signature with a `Pageable` parameter and let the method return a `Slice` instance, and we automatically page the query accordingly.\n<3> Applies scrolling to a query.\nScrolling wraps Cassandra's `PagingState` into `CassandraScrollPosition` and allows dynamic limiting.\nYou can also use `findTop…` for a static limit.\n<4> Passing a `QueryOptions` object applies the query options to the resulting query before its execution.\n<5> Applies dynamic sorting to a query.\nYou can add a `Sort` parameter to your method signature, and Spring Data automatically applies ordering to the query.\n<6> Applies dynamic result limiting to a query.\nQuery results can be limited using `SELECT … LIMIT`.\n<7> Shows that you can query based on properties that are not a primitive type by using `Converter` instances registered in `CustomConversions`.\nThrows `IncorrectResultSizeDataAccessException` if more than one match is found.\n<8> Uses the `First` keyword to restrict the query to only the first result.\nUnlike the preceding method, this method does not throw an exception if more than one match is found.\n<9> Uses a Java 8 `Stream` to read and convert individual elements while iterating the stream.\n<10> Shows a query method annotated with `@AllowFiltering`, to allow server-side filtering.\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\ninterface ReactivePersonRepository extends ReactiveSortingRepository<Person, Long> {\n\n Flux<Person> findByFirstname(String firstname); <1>\n\n Flux<Person> findByFirstname(Publisher<String> firstname); <2>\n\n Mono<Person> findByFirstnameAndLastname(String firstname, String lastname); <3>\n\n Mono<Person> findFirstByFirstname(String firstname); <4>\n\n @AllowFiltering\n Flux<Person> findByAge(int age); <5>\n}\n----\n<1> A query for all people with the given `firstname`.\nThe query is derived by parsing the method name for constraints, which can be concatenated with `And` and `Or`.\nThus, the method name results in a query expression of `SELECT * FROM person WHERE firstname = :firstname`.\n<2> A query for all people with the given `firstname` once the `firstname` is emitted from the given `Publisher`.\n<3> Find a single entity for the given criteria.\nCompletes with `IncorrectResultSizeDataAccessException` on non-unique results.\n<4> Unlike the preceding query, the first entity is always emitted even if the query yields more result rows.\n<5> A query method annotated with `@AllowFiltering`, which allows server-side filtering.\n======\n\nNOTE: Querying non-primary key properties requires secondary indexes.\n\nThe following table shows short examples of the keywords that you can use in query methods:\n\n[cols=\"1,2,3\",options=\"header\"]\n.Supported keywords for query methods\n|===\n| Keyword\n| Sample\n| Logical result\n\n| `After`\n| `findByBirthdateAfter(Date date)`\n| `birthdate > date`\n\n| `GreaterThan`\n| `findByAgeGreaterThan(int age)`\n| `age > age`\n\n| `GreaterThanEqual`\n| `findByAgeGreaterThanEqual(int age)`\n| `age >= age`\n\n| `Before`\n| `findByBirthdateBefore(Date date)`\n| `birthdate < date`\n\n| `LessThan`\n| `findByAgeLessThan(int age)`\n| `age < age`\n\n| `LessThanEqual`\n| `findByAgeLessThanEqual(int age)`\n| `age <= age`\n\n| `Between`\n| `findByAgeBetween(int from, int to)` and `findByAgeBetween(Range<Integer> range)`\n| ``age > from AND age < to`` and\nlower / upper bounds (`>` / `>=` & `<` / `<=`) according to `Range`\n\n| `In`\n| `findByAgeIn(Collection ages)`\n| `age IN (ages...)`\n\n| `Like`, `StartingWith`, `EndingWith`\n| `findByFirstnameLike(String name)`\n| `firstname LIKE (name as like expression)`\n\n| `Containing` on String\n| `findByFirstnameContaining(String name)`\n| `firstname LIKE (name as like expression)`\n\n| `Containing` on Collection\n| `findByAddressesContaining(Address address)`\n| `addresses CONTAINING address`\n\n| `(No keyword)`\n| `findByFirstname(String name)`\n| `firstname = name`\n\n| `IsTrue`, `True`\n| `findByActiveIsTrue()`\n| `active = true`\n\n| `IsFalse`, `False`\n| `findByActiveIsFalse()`\n| `active = false`\n\n|===\n\n[[cassandra.repositories.queries.delete]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/query-methods.adoc", "title": "query-methods", "heading": "query-methods", "heading_level": 1, "file_order": 2, "section_index": 0, "content_hash": "ccfca1d6968c0a589b325d506665bf6733803e89bfedf8c55be545d3657823fb", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/query-methods.adoc"}}
{"id": "sha256:d0f8126debe2e81c00eeb207236cc34490b120430402cf08315c4c6060f85335", "content": "The keywords in the preceding table can be used in conjunction with `delete…By` to create queries that delete matching documents.\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\ninterface PersonRepository extends Repository<Person, String> {\n\n void deleteWithoutResultByLastname(String lastname);\n\n boolean deleteByLastname(String lastname);\n}\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\ninterface PersonRepository extends Repository<Person, String> {\n\n Mono<Void> deleteWithoutResultByLastname(String lastname);\n\n Mono<Boolean> deleteByLastname(String lastname);\n}\n----\n======\n\nDelete queries return whether the query was applied or terminate without returning a value using `void`.\n\n[[cassandra.repositories.queries.options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/query-methods.adoc", "title": "query-methods", "heading": "Repository Delete Queries", "heading_level": 2, "file_order": 2, "section_index": 1, "content_hash": "d0f8126debe2e81c00eeb207236cc34490b120430402cf08315c4c6060f85335", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/query-methods.adoc"}}
{"id": "sha256:fda251164a35088a9ee5c6b33b85fa2b161734916a962511d0663e0af7347937", "content": "You can specify query options for query methods by passing a `QueryOptions` object.\nThe options apply to the query before the actual query execution.\n`QueryOptions` is treated as a non-query parameter and is not considered to be a query parameter value.\nQuery options apply to derived and string `@Query` repository methods.\n\nTo statically set the consistency level, use the `@Consistency` annotation on query methods.\nThe declared consistency level is applied to the query each time it is executed.\nThe following example sets the consistency level to `ConsistencyLevel.LOCAL_ONE`:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\ninterface PersonRepository extends CrudRepository<Person, String> {\n\n @Consistency(ConsistencyLevel.LOCAL_ONE)\n List<Person> findByLastname(String lastname);\n\n List<Person> findByFirstname(String firstname, QueryOptions options);\n}\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\ninterface PersonRepository extends ReactiveCrudRepository<Person, String> {\n\n @Consistency(ConsistencyLevel.LOCAL_ONE)\n Flux<Person> findByLastname(String lastname);\n\n Flux<Person> findByFirstname(String firstname, QueryOptions options);\n}\n----\n======\n\nThe DataStax Cassandra documentation includes https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html[a good discussion of the available consistency levels].\n\nNOTE: You can control fetch size, consistency level, and retry policy defaults by configuring the following parameters on the CQL API instances: `CqlTemplate`, `AsyncCqlTemplate`, and `ReactiveCqlTemplate`.\nDefaults apply if the particular query option is not set.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/query-methods.adoc", "title": "query-methods", "heading": "Query Options", "heading_level": 3, "file_order": 2, "section_index": 2, "content_hash": "fda251164a35088a9ee5c6b33b85fa2b161734916a962511d0663e0af7347937", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/query-methods.adoc"}}
{"id": "sha256:8300d23b74880c1128a96fb5667ca5b9fe20003f977356580b2bf991eac9417e", "content": "[[cassandra.repositories]]\n\nTo access domain entities stored in Apache Cassandra, you can use Spring Data's sophisticated repository support, which significantly eases implementing DAOs.\nTo do so, create an interface for your repository, as the following example shows:\n\n.Sample Person entity\n====\n[source,java]\n----\n@Table\npublic class Person {\n\n @Id\n private String id;\n private String firstname;\n private String lastname;\n\n // … getters and setters omitted\n}\n----\n====\n\nNote that the entity has a property named `id` of type `String`.\nThe default conversion mechanism used in `MappingCassandraConverter` (which backs the repository support) regards properties named `id` as being the row ID.\n\nThe following example shows a repository definition to persist `Person` entities:\n\n.Basic repository interface to persist `Person` entities\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\ninterface PersonRepository extends CrudRepository<Person, String> {\n\n // additional custom finder methods go here\n}\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\ninterface PersonRepository extends ReactiveCrudRepository<Person, String> {\n\n // additional custom finder methods go here\n}\n----\n======\n\nRight now, the interface in the preceding example serves only typing purposes, but we add additional methods to it later.\n\nNext, in your Spring configuration, add the following (if you use Java for configuration):\n\nIf you want to use Java configuration, use the `@EnableCassandraRepositories` respective `@EnableReactiveCassandraRepositories` annotation.\nThe annotation carries the same attributes as the namespace element.\nIf no base package is configured, the infrastructure scans the package of the annotated configuration class.\nThe following example show how to the different configuration approaches:\n\n.Configuration for repositories\n[tabs]\n======\nImperative Java Configuration::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n@Configuration\n@EnableCassandraRepositories\nclass ApplicationConfig extends AbstractCassandraConfiguration {\n\n @Override\n protected String getKeyspaceName() {\n return \"keyspace\";\n }\n\n public String[] getEntityBasePackages() {\n return new String[] { \"com.oreilly.springdata.cassandra\" };\n }\n}\n----\n\nXML::\n+\n[source,xml,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:cassandra=\"http://www.springframework.org/schema/data/cassandra\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/data/cassandra\n https://www.springframework.org/schema/data/cassandra/spring-cassandra.xsd\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <cassandra:session port=\"9042\" keyspace-name=\"keyspaceName\"/>\n\n <cassandra:mapping\n entity-base-packages=\"com.acme.*.entities\">\n </cassandra:mapping>\n\n <cassandra:converter/>\n\n <cassandra:template/>\n\n <cassandra:repositories base-package=\"com.acme.*.entities\"/>\n</beans>\n----\n\nReactive Java Configuration::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"third\"]\n----\n@Configuration\n@EnableReactiveCassandraRepositories\nclass ApplicationConfig extends AbstractReactiveCassandraConfiguration {\n\n @Override\n protected String getKeyspaceName() {\n return \"keyspace\";\n }\n\n public String[] getEntityBasePackages() {\n return new String[] { \"com.oreilly.springdata.cassandra\" };\n }\n}\n----\n======\n\nThe `cassandra:repositories` namespace element causes the base packages to be scanned for interfaces that extend `CrudRepository` and create Spring beans for each one found.\nBy default, the repositories are wired with a `CassandraTemplate` Spring bean called `cassandraTemplate`, so you only need to configure\n`cassandra-template-ref` explicitly if you deviate from this convention.\n\nBecause our domain repository extends `CrudRepository` respective `ReactiveCrudRepository`, it provides you with basic CRUD operations.\nWorking with the repository instance is a matter of injecting the repository as a dependency into a client, as the following example does by autowiring `PersonRepository`:\n\n.Basic access to Person entities\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n@ExtendWith(SpringExtension.class)\nclass PersonRepositoryTests {\n\n @Autowired PersonRepository repository;\n\n @Test\n void readsPersonTableCorrectly() {\n\n List<Person> persons = repository.findAll();\n assertThat(persons.isEmpty()).isFalse();\n }\n}\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\npublic class PersonRepositoryTests {\n\n @Autowired ReactivePersonRepository repository;\n\n @Test\n public void sortsElementsCorrectly() {\n Flux<Person> people = repository.findAll(Sort.by(new Order(ASC, \"lastname\")));\n }\n}\n----\n======\n\nCassandra repositories support paging and sorting for paginated and sorted access to the entities.\nCassandra paging requires a paging state to forward-only navigate through pages.\nA `Slice` keeps track of the current paging state and allows for creation of a `Pageable` to request the next page.\nThe following example shows how to set up paging access to `Person` entities:\n\n.Paging access to `Person` entities\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n@ExtendWith(SpringExtension.class)\nclass PersonRepositoryTests {\n\n @Autowired PersonRepository repository;\n\n @Test\n void readsPagesCorrectly() {\n\n Slice<Person> firstBatch = repository.findAll(CassandraPageRequest.first(10));\n\n assertThat(firstBatch).hasSize(10);\n\n Slice<Person> nextBatch = repository.findAll(firstBatch.nextPageable());\n\n // …\n }\n}\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n@ExtendWith(SpringExtension.class)\nclass PersonRepositoryTests {\n\n @Autowired PersonRepository repository;\n\n @Test\n void readsPagesCorrectly() {\n\n Mono<Slice<Person>> firstBatch = repository.findAll(CassandraPageRequest.first(10));\n\n Mono<Slice<Person>> nextBatch = firstBatch.flatMap(it -> repository.findAll(it.nextPageable()));\n\n // …\n }\n}}\n----\n======\n\nNOTE: Cassandra repositories do not extend `PagingAndSortingRepository`, because classic paging patterns using limit/offset are not applicable to Cassandra.\n\nThe preceding example creates an application context with Spring's unit test support, which performs annotation-based dependency injection into the test class.\nInside the test cases (the test methods), we use the repository to query the data store.\nWe invoke the repository query method that requests all `Person` instances.\n\n[[cassandra.repositories.reactive]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/repositories.adoc", "title": "repositories", "heading": "repositories", "heading_level": 1, "file_order": 3, "section_index": 0, "content_hash": "8300d23b74880c1128a96fb5667ca5b9fe20003f977356580b2bf991eac9417e", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/repositories.adoc"}}
{"id": "sha256:611a9b5002a141f577ab86e59a4fb93289464829c883631ca4b1498c60a572c6", "content": "Spring Data's repository abstraction is a dynamic API that is mostly defined by you and your requirements as you declare query methods.\nReactive Cassandra repositories can be implemented by using either RxJava or Project Reactor wrapper types by extending from one of the library-specific repository interfaces:\n\n* `ReactiveCrudRepository`\n* `ReactiveSortingRepository`\n* `RxJava3CrudRepository`\n* `RxJava3SortingRepository`\n\nSpring Data converts reactive wrapper types behind the scenes so that you can stick to your favorite composition library.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/repositories.adoc", "title": "repositories", "heading": "Reactive Repositories", "heading_level": 2, "file_order": 3, "section_index": 1, "content_hash": "611a9b5002a141f577ab86e59a4fb93289464829c883631ca4b1498c60a572c6", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/repositories.adoc"}}
{"id": "sha256:45e5ad06c269454bccf41a2b68600278a29f7536ba70795fe23a4bc3fd935c80", "content": "[[vector-search]]\n= Vector Search\n\nWith the rise of Generative AI, Vector databases have gained strong traction in the world of databases.\nThese databases enable efficient storage and querying of high-dimensional vectors, making them well-suited for tasks such as semantic search, recommendation systems, and natural language understanding.\n\nVector search is a technique that retrieves semantically similar data by comparing vector representations (also known as embeddings) rather than relying on traditional exact-match queries.\nThis approach enables intelligent, context-aware applications that go beyond keyword-based retrieval.\n\nIn the context of Spring Data, vector search opens new possibilities for building intelligent, context-aware applications, particularly in domains like natural language processing, recommendation systems, and generative AI.\nBy modelling vector-based querying using familiar repository abstractions, Spring Data allows developers to seamlessly integrate similarity-based vector-capable databases with the simplicity and consistency of the Spring Data programming model.\n\nifdef::vector-search-intro-include[]\ninclude::{vector-search-intro-include}[]\nendif::[]\n\n[[vector-search.model]]\n== Vector Model\n\nTo support vector search in a type-safe and idiomatic way, Spring Data introduces the following core abstractions:\n\n* <<vector-search.model.vector,`Vector`>>\n* <<vector-search.model.search-result,`SearchResults<T>` and `SearchResult<T>`>>\n* <<vector-search.model.scoring,`Score`, `Similarity` and Scoring Functions>>\n\n[[vector-search.model.vector]]\n=== `Vector`\n\nThe `Vector` type represents an n-dimensional numerical embedding, typically produced by embedding models.\nIn Spring Data, it is defined as a lightweight wrapper around an array of floating-point numbers, ensuring immutability and consistency.\nThis type can be used as an input for search queries or as a property on a domain entity to store the associated vector representation.\n\n====\n[source,java]\n----\nVector vector = Vector.of(0.23f, 0.11f, 0.77f);\n----\n====\n\nUsing `Vector` in your domain model removes the need to work with raw arrays or lists of numbers, providing a more type-safe and expressive way to handle vector data.\nThis abstraction also allows for easy integration with various vector databases and libraries.\nIt also allows for implementing vendor-specific optimizations such as binary or quantized vectors that do not map to a standard floating point (`float` and `double` as of https://en.wikipedia.org/wiki/IEEE_754[IEEE 754]) representation.\nA domain object can have a vector property, which can be used for similarity searches.\nConsider the following example:\n\nifdef::vector-search-model-include[]\ninclude::{vector-search-model-include}[]\nendif::[]\n\nNOTE: Associating a vector with a domain object results in the vector being loaded and stored as part of the entity lifecycle, which may introduce additional overhead on retrieval and persistence operations.\n\n[[vector-search.model.search-result]]\n=== Search Results\n\nThe `SearchResult<T>` type encapsulates the results of a vector similarity query.\nIt includes both the matched domain object and a relevance score that indicates how closely it matches the query vector.\nThis abstraction provides a structured way to handle result ranking and enables developers to easily work with both the data and its contextual relevance.\n\nifdef::vector-search-repository-include[]\ninclude::{vector-search-repository-include}[]\nendif::[]\n\nIn this example, the `searchByEmbeddingNearAndCountry` method returns a `SearchResults<Comment>` object, which contains a list of `SearchResult<Comment>` instances.\nEach result includes the matched `Comment` entity and its relevance score.\n\nRelevance score is a numerical value that indicates how closely the matched vector aligns with the query vector.\nDepending on whether a score represents distance or similarity a higher score can mean a closer match or a more distant one.\n\nThe scoring function used to calculate this score can vary based on the underlying database, index or input parameters.\n\n[[vector-search.model.scoring]]\n=== Score, Similarity, and Scoring Functions\n\nThe `Score` type holds a numerical value indicating the relevance of a search result.\nIt can be used to rank results based on their similarity to the query vector.\nThe `Score` type is typically a floating-point number, and its interpretation (higher is better or lower is better) depends on the specific similarity function used.\nScores are a by-product of vector search and are not required for a successful search operation.\nScore values are not part of a domain model and therefore represented best as out-of-band data.\n\nGenerally, a Score is computed by a `ScoringFunction`.\nThe actual scoring function used to calculate this score can depends on the underlying database and can be obtained from a search index or input parameters.\n\nSpring Data support declares constants for commonly used functions such as:\n\nEuclidean Distance:: Calculates the straight-line distance in n-dimensional space involving the square root of the sum of squared differences.\nCosine Similarity:: Measures the angle between two vectors by calculating the Dot product first and then normalizing its result by dividing by the product of their lengths.\nDot Product:: Computes the sum of element-wise multiplications.\n\nThe choice of similarity function can impact both the performance and semantics of the search and is often determined by the underlying database or index being used.\nSpring Data adopts to the database's native scoring function capabilities and whether the score can be used to limit results.\n\nifdef::vector-search-scoring-include[]\ninclude::{vector-search-scoring-include}[]\nendif::[]\n\n[[vector-search.methods]]\n== Vector Search Methods\n\nVector search methods are defined in repositories using the same conventions as standard Spring Data query methods.\nThese methods return `SearchResults<T>` and require a `Vector` parameter to define the query vector.\nThe actual implementation depends on the actual internals of the underlying data store and its capabilities around vector search.\n\nNOTE: If you are new to Spring Data repositories, make sure to familiarize yourself with the xref:repositories/core-concepts.adoc[basics of repository definitions and query methods].\n\nGenerally, you have the choice of declaring a search method using two approaches:\n\n* Query Derivation\n* Declaring a String-based Query\n\nVector Search methods must declare a `Vector` parameter to define the query vector.\n\n[[vector-search.method.derivation]]\n=== Derived Search Methods\n\nA derived search method uses the name of the method to derive the query.\nVector Search supports the following keywords to run a Vector search when declaring a search method:\n\n.Query predicate keywords\n[options=\"header\",cols=\"1,3\"]\n|===============\n|Logical keyword|Keyword expressions\n|`NEAR`|`Near`, `IsNear`\n|`WITHIN`|`Within`, `IsWithin`\n|===============\n\nifdef::vector-search-method-derived-include[]\ninclude::{vector-search-method-derived-include}[]\nendif::[]\n\nDerived search methods are typically easier to read and maintain, as they rely on the method name to express the query intent.\nHowever, a derived search method requires either to declare a `Score`, `Range<Score>` or `ScoreFunction` as second argument to the `Near`/`Within` keyword to limit search results by their score.\n\n[[vector-search.method.string]]\n=== Annotated Search Methods\n\nAnnotated methods provide full control over the query semantics and parameters.\nUnlike derived methods, they do not rely on method name conventions.\n\nifdef::vector-search-method-annotated-include[]\ninclude::{vector-search-method-annotated-include}[]\nendif::[]\n\nWith more control over the actual query, Spring Data can make fewer assumptions about the query and its parameters.\nFor example, `Similarity` normalization uses the native score function within the query to normalize the given similarity into a score predicate value and vice versa.\nIf an annotated query does not define e.g. the score, then the score value in the returned `SearchResult<T>` will be zero.\n\n[[vector-search.method.sorting]]\n=== Sorting\n\nCassandra Vector search results are ordered according to their score through the `ORDER BY embedding ANN OF [vector]` clause.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/repositories/vector-search.adoc", "title": "vector-search", "heading": "vector-search", "heading_level": 1, "file_order": 4, "section_index": 0, "content_hash": "45e5ad06c269454bccf41a2b68600278a29f7536ba70795fe23a4bc3fd935c80", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/repositories/vector-search.adoc"}}
{"id": "sha256:ef56542fc57925f6b5e1eebb8ae5455c3540186d619e7eb7da9fda8529bd1d7d", "content": "[[cassandra.auditing]]\n\nTo activate auditing functionality, create a configuration as the following example shows:\n\n.Activating auditing through configuration\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n@Configuration\n@EnableCassandraAuditing\nclass Config {\n\n @Bean\n public AuditorAware<AuditableUser> myAuditorProvider() {\n return new AuditorAwareImpl();\n }\n}\n----\n\nXML::\n+\n[source,xml,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:cassandra=\"http://www.springframework.org/schema/data/cassandra\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/data/cassandra\n https://www.springframework.org/schema/data/cassandra/spring-cassandra.xsd\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <cassandra:auditing mapping-context-ref=\"customMappingContext\" auditor-aware-ref=\"yourAuditorAwareImpl\"/>\n</beans>\n----\n======\n\nIf you expose a bean of type `AuditorAware` to the `ApplicationContext`, the auditing infrastructure picks it up automatically and uses it to determine the current user to be set on domain types.\nIf you have multiple implementations registered in the `ApplicationContext`, you can select the one to be used by explicitly setting the `auditorAwareRef` attribute of `@EnableCassandraAuditing`.\n\nTo enable auditing, leveraging a reactive programming model, use the `@EnableReactiveCassandraAuditing` annotation. +\nIf you expose a bean of type `ReactiveAuditorAware` to the `ApplicationContext`, the auditing infrastructure picks it up automatically and uses it to determine the current user to be set on domain types.\nIf you have multiple implementations registered in the `ApplicationContext`, you can select the one to be used by explicitly setting the `auditorAwareRef` attribute of `@EnableReactiveCassandraAuditing`.\n\n.Activating reactive auditing using JavaConfig\n====\n[source,java]\n----\n@Configuration\n@EnableReactiveCassandraAuditing\nclass Config {\n\n @Bean\n public ReactiveAuditorAware<AuditableUser> myAuditorProvider() {\n return new AuditorAwareImpl();\n }\n}\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/auditing.adoc", "title": "auditing", "heading": "auditing", "heading_level": 1, "file_order": 5, "section_index": 0, "content_hash": "ef56542fc57925f6b5e1eebb8ae5455c3540186d619e7eb7da9fda8529bd1d7d", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/auditing.adoc"}}
{"id": "sha256:e52b80df1509a784cb01834bcc551e32ddd5b573869b7e335fa77e01fbbff004", "content": "[[cassandra.connectors]]\n\nOne of the first tasks when using Apache Cassandra with Spring is to create a `com.datastax.oss.driver.api.core.CqlSession` object by using the Spring IoC container.\nYou can do so either by using Java-based bean metadata or by using XML-based bean metadata.\nThese are discussed in the following sections.\n\nNOTE: For those not familiar with how to configure the Spring container using Java-based bean metadata instead of XML-based metadata, see the high-level introduction in the reference docs\nlink:{springdocsurl}/core/beans/java.html[here]\nas well as the detailed documentation {springDocsUrl}/core/beans/java/instantiating-container.html[here].\n\n[[cassandra.cassandra-java-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/configuration.adoc", "title": "configuration", "heading": "configuration", "heading_level": 1, "file_order": 6, "section_index": 0, "content_hash": "e52b80df1509a784cb01834bcc551e32ddd5b573869b7e335fa77e01fbbff004", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/configuration.adoc"}}
{"id": "sha256:f08272d2867fdc9fdf4057f866347642971a343dcc7356e6f2736007e96f7e61", "content": "The following example shows how to use Java-based bean metadata to register an instance of a `com.datastax.oss.driver.api.core.CqlSession`:\n\n.Registering a `com.datastax.oss.driver.api.core.CqlSession` object by using Java-based bean metadata\n====\n[source,java]\n----\n@Configuration\npublic class AppConfig {\n\n\t/*\n\t * Use the standard Cassandra driver API to create a com.datastax.oss.driver.api.core.CqlSession instance.\n\t */\n\tpublic @Bean CqlSession session() {\n\t\treturn CqlSession.builder().withKeyspace(\"mykeyspace\").build();\n\t}\n}\n----\n====\n\nThis approach lets you use the standard `com.datastax.oss.driver.api.core.CqlSession` API that you may already know.\n\nAn alternative is to register an instance of `com.datastax.oss.driver.api.core.CqlSession` with the container by using Spring's `CqlSessionFactoryBean`.\nAs compared to instantiating a `com.datastax.oss.driver.api.core.CqlSession` instance directly, the `FactoryBean` approach has the added advantage of also providing the container with an `ExceptionTranslator` implementation that translates Cassandra exceptions to exceptions in Spring's portable `DataAccessException` hierarchy.\nThis hierarchy and the use of\n`@Repository` is described in {springDocsUrl}/data-access/dao.html[Spring's DAO support features].\n\nThe following example shows Java-based factory class usage:\n\n.Registering a com.datastax.oss.driver.api.core.CqlSession object by using Spring's `CqlSessionFactoryBean`:\n====\n[source,java]\n----\n@Configuration\npublic class FactoryBeanAppConfig {\n\n\t/*\n\t * Factory bean that creates the com.datastax.oss.driver.api.core.CqlSession instance\n\t */\n\t@Bean\n\tpublic CqlSessionFactoryBean session() {\n\n\t\tCqlSessionFactoryBean session = new CqlSessionFactoryBean();\n\t\tsession.setContactPoints(\"localhost\");\n\t\tsession.setKeyspaceName(\"mykeyspace\");\n\n\t\treturn session;\n\t}\n}\n----\n====\n\nUsing `CassandraTemplate` with object mapping and repository support requires a `CassandraTemplate`,\n`CassandraMappingContext`, `CassandraConverter`, and enabling repository support.\n\nThe following example shows how to register components to configure object mapping and repository support:\n\n.Registering components to configure object mapping and repository support\n====\n[source,java]\n----\n@Configuration\n@EnableCassandraRepositories(basePackages = { \"org.springframework.data.cassandra.example\" })\npublic class CassandraConfig {\n\n\t@Bean\n\tpublic CqlSessionFactoryBean session() {\n\n\t\tCqlSessionFactoryBean session = new CqlSessionFactoryBean();\n\t\tsession.setContactPoints(\"localhost\");\n\t\tsession.setKeyspaceName(\"mykeyspace\");\n\n\t\treturn session;\n\t}\n\n\t@Bean\n\tpublic SessionFactoryFactoryBean sessionFactory(CqlSession session, CassandraConverter converter) {\n\n\t\tSessionFactoryFactoryBean sessionFactory = new SessionFactoryFactoryBean();\n\t\tsessionFactory.setSession(session);\n\t\tsessionFactory.setConverter(converter);\n\t\tsessionFactory.setSchemaAction(SchemaAction.NONE);\n\n\t\treturn sessionFactory;\n\t}\n\n\t@Bean\n\tpublic CassandraMappingContext mappingContext() {\n\t\treturn new CassandraMappingContext();\n\t}\n\n\t@Bean\n\tpublic CassandraConverter converter(CqlSession cqlSession, CassandraMappingContext mappingContext) {\n\n\t\tMappingCassandraConverter cassandraConverter = new MappingCassandraConverter(mappingContext);\n\t\tcassandraConverter.setUserTypeResolver(new SimpleUserTypeResolver(cqlSession));\n\n\t\treturn cassandraConverter;\n\t}\n\n\t@Bean\n\tpublic CassandraOperations cassandraTemplate(SessionFactory sessionFactory, CassandraConverter converter) {\n\t\treturn new CassandraTemplate(sessionFactory, converter);\n\t}\n}\n----\n====\n\nCreating configuration classes that register Spring Data for Apache Cassandra components can be an exhausting challenge, so Spring Data for Apache Cassandra comes with a pre-built configuration support class.\nClasses that extend from\n`AbstractCassandraConfiguration` register beans for Spring Data for Apache Cassandra use.\n`AbstractCassandraConfiguration` lets you provide various configuration options, such as initial entities, default query options, pooling options, socket options, and many more. `AbstractCassandraConfiguration` also supports you with schema generation based on initial entities, if any are provided.\nExtending from\n`AbstractCassandraConfiguration` requires you to at least provide the keyspace name by implementing the `getKeyspaceName` method.\nThe following example shows how to register beans by using `AbstractCassandraConfiguration`:\n\n.Registering Spring Data for Apache Cassandra beans by using `AbstractCassandraConfiguration`\n====\n[source,java]\n----\n@Configuration\npublic class CassandraConfiguration extends AbstractCassandraConfiguration {\n\n\t/*\n\t * Provide a contact point to the configuration.\n\t */\n\t@Override\n\tpublic String getContactPoints() {\n\t\treturn \"localhost\";\n\t}\n\n\t/*\n\t * Provide a keyspace name to the configuration.\n\t */\n\t@Override\n\tpublic String getKeyspaceName() {\n\t\treturn \"mykeyspace\";\n\t}\n}\n----\n====\n\n`Abstract…Configuration` classes wire all the necessary beans for using Cassandra from your application.\nThe configuration assumes a single `CqlSession` and wires it through `SessionFactory` into the related components such as `CqlTemplate`.\nIf you want to customize the creation of the `CqlSession`, then you can provide a `SessionBuilderConfigurer` function to customize `CqlSessionBuilder`.\nThis is useful to provide e.g. a Cloud Connection Bundle for Astra.\n\n.Connecting to Astra through `AbstractCassandraConfiguration`\n====\n[source,java]\n----\n@Configuration\npublic class CustomizedCassandraConfiguration extends AbstractCassandraConfiguration {\n\n\t/*\n\t * Customize the CqlSession through CqlSessionBuilder.\n\t */\n\t@Override\n\tprotected SessionBuilderConfigurer getSessionBuilderConfigurer() {\n\n\t\tPath connectBundlePath = …;\n\n\t\treturn builder -> builder\n\t\t\t\t.withCloudSecureConnectBundle(Path.of(connectBundlePath));\n\t}\n\n\t/*\n\t * Provide a keyspace name to the configuration.\n\t */\n\t@Override\n\tpublic String getKeyspaceName() {\n\t\treturn \"mykeyspace\";\n\t}\n\n}\n----\n====\n\n[[cassandra-connectors.xmlconfig]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/configuration.adoc", "title": "configuration", "heading": "Registering a Session Instance by using Java-based Metadata", "heading_level": 2, "file_order": 6, "section_index": 1, "content_hash": "f08272d2867fdc9fdf4057f866347642971a343dcc7356e6f2736007e96f7e61", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/configuration.adoc"}}
{"id": "sha256:16ab834a8093ec8d27824d51b4dae05f338ceca7bae458fe9fd24e7a06395da7", "content": "This section describes how to configure Spring Data Cassandra with XML.\n\nWARNING: While we still support Namespace Configuration, we generally recommend using <<cassandra.cassandra-java-config,Java-based Configuration>>.\n\n[[cassandra-connectors.xmlconfig.ext_properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/configuration.adoc", "title": "configuration", "heading": "XML Configuration", "heading_level": 2, "file_order": 6, "section_index": 2, "content_hash": "16ab834a8093ec8d27824d51b4dae05f338ceca7bae458fe9fd24e7a06395da7", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/configuration.adoc"}}
{"id": "sha256:55144fe50bb2203e6d8626aa829503910ab60d23cdaee51793684742d53a472f", "content": "To externalize connection properties, you should first create a properties file that contains the information needed to connect to Cassandra. `contactpoints` and `keyspace` are the required fields.\n\nThe following example shows our properties file, called `cassandra.properties`:\n\n====\n[source]\n----\ncassandra.contactpoints=10.1.55.80:9042,10.1.55.81:9042\ncassandra.keyspace=showcase\n----\n====\n\nIn the next two examples, we use Spring to load these properties into the Spring context.\n\n[[registering-a-session-instance-by-using-xml-based-metadata]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/configuration.adoc", "title": "configuration", "heading": "Externalizing Connection Properties", "heading_level": 3, "file_order": 6, "section_index": 3, "content_hash": "55144fe50bb2203e6d8626aa829503910ab60d23cdaee51793684742d53a472f", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/configuration.adoc"}}
{"id": "sha256:916b8103db7867fa4be2d5c492e699b18059e7eed16b84b11f006212f11a13c7", "content": "While you can use Spring's traditional `<beans/>` XML namespace to register an instance of\n`com.datastax.oss.driver.api.core.CqlSession` with the container, the XML can be quite verbose, because it is general purpose.\nXML namespaces are a better alternative to configuring commonly used objects, such as the `CqlSession` instance.\nThe `cassandra` namespace let you create a `CqlSession` instance.\n\nThe following example shows how to configure the `cassandra` namespace:\n\n.XML schema to configure Cassandra by using the `cassandra` namespace\n====\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:cassandra=\"http://www.springframework.org/schema/data/cassandra\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/data/cassandra\n https://www.springframework.org/schema/data/cassandra/spring-cassandra.xsd\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <!-- Default bean name is 'cassandraSession' -->\n <cassandra:session contact-points=\"localhost\" port=\"9042\">\n <cassandra:keyspace action=\"CREATE_DROP\" name=\"mykeyspace\" />\n </cassandra:session>\n\n <cassandra:session-factory>\n <cassandra:script\n location=\"classpath:/org/springframework/data/cassandra/config/schema.cql\"/>\n </cassandra:session-factory>\n</beans>\n----\n====\n\nThe XML configuration elements for more advanced Cassandra configuration are shown below.\nThese elements all use default bean names to keep the configuration code clean and readable.\n\nWhile the preceding example shows how easy it is to configure Spring to connect to Cassandra, there are many other options.\nBasically, any option available with the DataStax Java Driver is also available in the Spring Data for Apache Cassandra configuration.\nThis includes but is not limited to authentication, load-balancing policies, retry policies, and pooling options.\nAll of the Spring Data for Apache Cassandra method names and XML elements are named exactly (or as close as possible) like the configuration options on the driver so that mapping any existing driver configuration should be straight forward.\nThe following example shows how to configure Spring Data components by using XML\n\n.Configuring Spring Data components by using XML\n====\n[source,xml]\n----\n\n<!-- Loads the properties into the Spring Context and uses them to fill\nin placeholders in the bean definitions -->\n<context:property-placeholder location=\"classpath:cassandra.properties\" />\n\n<!-- REQUIRED: The Cassandra Session -->\n<cassandra:session contact-points=\"${cassandra.contactpoints}\" keyspace-name=\"${cassandra.keyspace}\" />\n\n<!-- REQUIRED: The default Cassandra mapping context used by `CassandraConverter` -->\n<cassandra:mapping>\n <cassandra:user-type-resolver keyspace-name=\"${cassandra.keyspace}\" />\n</cassandra:mapping>\n\n<!-- REQUIRED: The default Cassandra converter used by `CassandraTemplate` -->\n<cassandra:converter />\n\n<!-- REQUIRED: The Cassandra template is the foundation of all Spring\nData Cassandra -->\n<cassandra:template id=\"cassandraTemplate\" />\n\n<!-- OPTIONAL: If you use Spring Data for Apache Cassandra repositories, add\nyour base packages to scan here -->\n<cassandra:repositories base-package=\"org.spring.cassandra.example.repo\" />\n\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/configuration.adoc", "title": "configuration", "heading": "Registering a Session Instance by using XML-based Metadata", "heading_level": 3, "file_order": 6, "section_index": 4, "content_hash": "916b8103db7867fa4be2d5c492e699b18059e7eed16b84b11f006212f11a13c7", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/configuration.adoc"}}
{"id": "sha256:ae318edf6a10b190f6c4b02b25c486fe4bf94446572ba1431144c277aba76d21", "content": "include::{commons}@data-commons::page$custom-conversions.adoc[]\n\n[[cassandra.custom-converters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/converters.adoc", "title": "converters", "heading": "converters", "heading_level": 1, "file_order": 7, "section_index": 0, "content_hash": "ae318edf6a10b190f6c4b02b25c486fe4bf94446572ba1431144c277aba76d21", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/converters.adoc"}}
{"id": "sha256:d3b09346c9ac0dfc893f9bc268121849291102dabae34212016246dbac8d1554", "content": "To have more fine-grained control over the mapping process, you can register Spring `Converters` with\n`CassandraConverter` implementations, such as `MappingCassandraConverter`.\n\n`MappingCassandraConverter` first checks to see whether any Spring `Converters` can handle a specific class before attempting to map the object itself.\nTo \"'hijack'\" the normal mapping strategies of the `MappingCassandraConverter` (perhaps for increased performance or other custom mapping needs), you need to create an implementation of the Spring `Converter` interface and register it with the `MappingCassandraConverter`.\n\n[[customconversions.writer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/converters.adoc", "title": "converters", "heading": "Overriding Default Mapping with Custom Converters", "heading_level": 2, "file_order": 7, "section_index": 1, "content_hash": "d3b09346c9ac0dfc893f9bc268121849291102dabae34212016246dbac8d1554", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/converters.adoc"}}
{"id": "sha256:5f99c5525f6e62e6200adfeb2d69a8168d5f25beae0deec4f02ceb8b67e4541b", "content": "You can combine converting and saving in a single process, basically using the converter to do the saving.\n\nThe following example uses a `Converter` to convert a `Person` object to a `java.lang.String`\nwith Jackson 2:\n\n[source,java]\n----\nclass PersonWriteConverter implements Converter<Person, String> {\n\n\tpublic String convert(Person source) {\n\n\t\ttry {\n\t\t\treturn new ObjectMapper().writeValueAsString(source);\n\t\t} catch (IOException e) {\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t}\n}\n----\n\n[[customconversions.reader]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/converters.adoc", "title": "converters", "heading": "Saving by Using a Registered Spring Converter", "heading_level": 3, "file_order": 7, "section_index": 2, "content_hash": "5f99c5525f6e62e6200adfeb2d69a8168d5f25beae0deec4f02ceb8b67e4541b", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/converters.adoc"}}
{"id": "sha256:46757eb67ad3f583bac8020c3c6c03b1db91c2e2616f84a5a2a37337eca18fa8", "content": "Similar to how you can combine saving and converting, you can also combine reading and converting.\n\nThe following example uses a `Converter` that converts a `java.lang.String` into a `Person` object with Jackson 2:\n\n[source,java]\n----\nclass PersonReadConverter implements Converter<String, Person> {\n\n\tpublic Person convert(String source) {\n\n\t\tif (StringUtils.hasText(source)) {\n\t\t\ttry {\n\t\t\t\treturn new ObjectMapper().readValue(source, Person.class);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new IllegalStateException(e);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n----\n\n[[customconversions.java]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/converters.adoc", "title": "converters", "heading": "Reading by Using a Spring Converter", "heading_level": 3, "file_order": 7, "section_index": 3, "content_hash": "46757eb67ad3f583bac8020c3c6c03b1db91c2e2616f84a5a2a37337eca18fa8", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/converters.adoc"}}
{"id": "sha256:e8f5429db4676ed82f55d4b0e2df72aa23026ad7442b654bd3fc04752f56b567", "content": "Spring Data for Apache Cassandra Java configuration provides a convenient way to register Spring `Converter` instances:\n`MappingCassandraConverter`.\nThe following configuration snippet shows how to manually register converters as well as configure `CustomConversions`:\n\n[source,java]\n----\n@Configuration\npublic class ConverterConfiguration extends AbstractCassandraConfiguration {\n\n\t@Override\n\tpublic CassandraCustomConversions customConversions() {\n\n\t\treturn CassandraCustomConversions.create(config -> {\n\t\t\tconfig.registerConverter(new PersonReadConverter()));\n\t\t\tconfig.registerConverter(new PersonWriteConverter()));\n\t\t});\n\t}\n\n\t// other methods omitted...\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/converters.adoc", "title": "converters", "heading": "Registering Spring Converters with `CassandraConverter`", "heading_level": 3, "file_order": 7, "section_index": 4, "content_hash": "e8f5429db4676ed82f55d4b0e2df72aa23026ad7442b654bd3fc04752f56b567", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/converters.adoc"}}
{"id": "sha256:d572af8855845b531b6baee9b4c2c0dad510c9656001a85dafed2f72e2cc09c5", "content": "[[cassandra.cql-template]]\n\nThe javadoc:org.springframework.data.cassandra.core.cql.CqlTemplate[] class (and its reactive variant javadoc:org.springframework.data.cassandra.core.cql.ReactiveCqlTemplate[]) is the central class in the core CQL package.\nIt handles the creation and release of resources.\nIt performs the basic tasks of the core CQL workflow, such as statement creation and execution, and leaves application code to provide CQL and extract results.\nThe `CqlTemplate` class executes CQL queries and update statements, performs iteration over `ResultSet` instances and extraction of returned parameter values.\nIt also catches CQL exceptions and translates them to the generic, more informative, exception hierarchy defined in the `org.springframework.dao` package.\n\nWhen you use the `CqlTemplate` for your code, you need only implement callback interfaces, which have a clearly defined contract.\nGiven a `CqlSession`, the javadoc:org.springframework.data.cassandra.core.cql.PreparedStatementCreator[] callback interface creates a xref:cassandra/prepared-statements.adoc#cassandra.template.prepared-statements.cql[prepared statement] with the provided CQL and any necessary parameter arguments.\nThe javadoc:org.springframework.data.cassandra.core.cql.RowCallbackHandler[] interface extracts values from each row of a `ResultSet`.\n\nThe javadoc:org.springframework.data.cassandra.core.cql.CqlTemplate[] can be used within a DAO implementation through direct instantiation with a javadoc:org.springframework.data.cassandra.SessionFactory[] reference or be configured in the Spring container and given to DAOs as a bean reference. `CqlTemplate` is a foundational building block for xref:cassandra/template.adoc[`CassandraTemplate`].\n\nAll CQL issued by this class is logged at the `DEBUG` level under the category corresponding to the fully-qualified class name of the template instance (typically `CqlTemplate`, but it may be different if you use a custom subclass of the `CqlTemplate` class).\n\nYou can control fetch size, consistency level, and retry policy defaults by configuring these parameters on the CQL API instances:\njavadoc:org.springframework.data.cassandra.core.cql.CqlTemplate[], javadoc:org.springframework.data.cassandra.core.cql.AsyncCqlTemplate[], and javadoc:org.springframework.data.cassandra.core.cql.ReactiveCqlTemplate[].\nDefaults apply if the particular query option is not set.\n\nNOTE: `CqlTemplate` comes in different execution model flavors.\nThe basic `CqlTemplate` uses a blocking execution model.\nYou can use `AsyncCqlTemplate` for asynchronous execution and synchronization with `CompletableFuture` instances or\n`ReactiveCqlTemplate` for reactive execution.\n\n[[cassandracql-template.examples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/cql-template.adoc", "title": "cql-template", "heading": "cql-template", "heading_level": 1, "file_order": 8, "section_index": 0, "content_hash": "d572af8855845b531b6baee9b4c2c0dad510c9656001a85dafed2f72e2cc09c5", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/cql-template.adoc"}}
{"id": "sha256:6589d5b774af3d4246b7534569cd0bb109da78a8a4a378243ea6a902f92b5b91", "content": "This section provides some examples of the `CqlTemplate` class in action.\nThese examples are not an exhaustive list of all functionality exposed by the `CqlTemplate`.\nSee the javadoc:org.springframework.data.cassandra.core.cql.CqlTemplate[Javadoc] for that.\n\n[[cassandra.cql-template.examples.query]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/cql-template.adoc", "title": "cql-template", "heading": "Examples of `CqlTemplate` Class Usage", "heading_level": 2, "file_order": 8, "section_index": 1, "content_hash": "6589d5b774af3d4246b7534569cd0bb109da78a8a4a378243ea6a902f92b5b91", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/cql-template.adoc"}}
{"id": "sha256:d3e0107baafd473c45e305e89237b550704fb1d98f20da26c3f3372bc9dd4402", "content": "The following query gets the number of rows in a table:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n\t\tint rowCount = cqlTemplate.queryForObject(\"SELECT COUNT(*) FROM t_actor\", Integer.class);\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\t\tMono<Integer> rowCount = reactiveCqlTemplate.queryForObject(\"SELECT COUNT(*) FROM t_actor\", Integer.class);\n----\n======\n\nThe following query uses a bind variable:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n\t\tint countOfActorsNamedJoe = cqlTemplate.queryForObject(\n\t\t\t\t\"SELECT COUNT(*) FROM t_actor WHERE first_name = ?\", Integer.class, \"Joe\");\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\t\tMono<Integer> countOfActorsNamedJoe = reactiveCqlTemplate.queryForObject(\n\t\t\t\"SELECT COUNT(*) FROM t_actor WHERE first_name = ?\", Integer.class, \"Joe\");\n----\n======\n\nThe following example queries for a `String`:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n\t\tString lastName = cqlTemplate.queryForObject(\n\t\t\t\t\"SELECT last_name FROM t_actor WHERE id = ?\",\n\t\t\t\tString.class, 1212L);\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\t\tMono<String> lastName = reactiveCqlTemplate.queryForObject(\n\t\t\t\"SELECT last_name FROM t_actor WHERE id = ?\",\n\t\t\tString.class, 1212L);\n----\n======\n\nThe following example queries and populates a single domain object:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n\t\tActor actor = cqlTemplate.queryForObject(\"SELECT first_name, last_name FROM t_actor WHERE id = ?\",\n\t\t\t\tnew RowMapper<Actor>() {\n\t\t\t\t\tpublic Actor mapRow(Row row, int rowNum) {\n\t\t\t\t\t\tActor actor = new Actor();\n\t\t\t\t\t\tactor.setFirstName(row.getString(\"first_name\"));\n\t\t\t\t\t\tactor.setLastName(row.getString(\"last_name\"));\n\t\t\t\t\t\treturn actor;\n\t\t\t\t\t}\n\t\t\t\t}, 1212L);\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\t\tMono<Actor> actor = reactiveCqlTemplate.queryForObject(\n\t\t\t\"SELECT first_name, last_name FROM t_actor WHERE id = ?\",\n\t\t\tnew RowMapper<Actor>() {\n\t\t\t\tpublic Actor mapRow(Row row, int rowNum) {\n\t\t\t\t\tActor actor = new Actor();\n\t\t\t\t\tactor.setFirstName(row.getString(\"first_name\"));\n\t\t\t\t\tactor.setLastName(row.getString(\"last_name\"));\n\t\t\t\t\treturn actor;\n\t\t\t\t}},\n\t\t\t1212L);\n----\n======\n\nThe following example queries and populates multiple domain objects:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n\t\tList<Actor> actors = cqlTemplate.query(\n\t\t\t\t\"SELECT first_name, last_name FROM t_actor\",\n\t\t\t\tnew RowMapper<Actor>() {\n\t\t\t\t\tpublic Actor mapRow(Row row, int rowNum) {\n\t\t\t\t\t\tActor actor = new Actor();\n\t\t\t\t\t\tactor.setFirstName(row.getString(\"first_name\"));\n\t\t\t\t\t\tactor.setLastName(row.getString(\"last_name\"));\n\t\t\t\t\t\treturn actor;\n\t\t\t\t\t}\n\t\t\t\t});\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\t\tFlux<Actor> actors = reactiveCqlTemplate.query(\n\t\t\"SELECT first_name, last_name FROM t_actor\",\n\t\t\tnew RowMapper<Actor>() {\n\t\t\t\tpublic Actor mapRow(Row row, int rowNum) {\n\t\t\t\t\tActor actor = new Actor();\n\t\t\t\t\tactor.setFirstName(row.getString(\"first_name\"));\n\t\t\t\t\tactor.setLastName(row.getString(\"last_name\"));\n\t\t\t\t\treturn actor;\n\t\t\t\t}\n\t\t});\n----\n======\n\nIf the last two snippets of code actually existed in the same application, it would make sense to remove the duplication present in the two `RowMapper` anonymous inner classes and extract them out into a single class (typically a `static` nested class) that can then be referenced by DAO methods.\n\nFor example, it might be better to write the last code snippet as follows:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n\tList<Actor> findAllActors() {\n\t\treturn cqlTemplate.query(\"SELECT first_name, last_name FROM t_actor\", ActorMapper.INSTANCE);\n\t}\n\n\tenum ActorMapper implements RowMapper<Actor> {\n\n\t\tINSTANCE;\n\n\t\tpublic Actor mapRow(Row row, int rowNum) {\n\t\t\tActor actor = new Actor();\n\t\t\tactor.setFirstName(row.getString(\"first_name\"));\n\t\t\tactor.setLastName(row.getString(\"last_name\"));\n\t\t\treturn actor;\n\t\t}\n\t}\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\tFlux<Actor> findAllActors() {\n\t\treturn reactiveCqlTemplate.query(\"SELECT first_name, last_name FROM t_actor\", ActorMapper.INSTANCE);\n\t}\n\n\tenum ActorMapper implements RowMapper<Actor> {\n\n\t\tINSTANCE;\n\n\t\tpublic Actor mapRow(Row row, int rowNum) {\n\t\t\tActor actor = new Actor();\n\t\t\tactor.setFirstName(row.getString(\"first_name\"));\n\t\t\tactor.setLastName(row.getString(\"last_name\"));\n\t\t\treturn actor;\n\t\t}\n\t}\n----\n======\n\n[[cassandra.cql-template.examples.update]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/cql-template.adoc", "title": "cql-template", "heading": "Querying (SELECT) with `CqlTemplate`", "heading_level": 3, "file_order": 8, "section_index": 2, "content_hash": "d3e0107baafd473c45e305e89237b550704fb1d98f20da26c3f3372bc9dd4402", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/cql-template.adoc"}}
{"id": "sha256:c1e45b2bd1d307cfdb97a08b2733a558dd91910b027f28d1e29a5dd0210bfd58", "content": "You can use the `execute(…)` method to perform `INSERT`, `UPDATE`, and `DELETE` operations.\nParameter values are usually provided as variable arguments or, alternatively, as an object array.\n\nThe following example shows how to perform an `INSERT` operation with `CqlTemplate`:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n\t\tcqlTemplate.execute(\n\t\t\t\t\"INSERT INTO t_actor (first_name, last_name) VALUES (?, ?)\",\n\t\t\t\t\"Leonor\", \"Watling\");\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\t\tMono<Boolean> applied = reactiveCqlTemplate.execute(\n\t\t\t\"INSERT INTO t_actor (first_name, last_name) VALUES (?, ?)\",\n\t\t\t\"Leonor\", \"Watling\");\n----\n======\n\nThe following example shows how to perform an `UPDATE` operation with `CqlTemplate`:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n\t\tcqlTemplate.execute(\n\t\t\t\t\"UPDATE t_actor SET last_name = ? WHERE id = ?\",\n\t\t\t\t\"Banjo\", 5276L);\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\t\tMono<Boolean> applied = reactiveCqlTemplate.execute(\n\t\t\t\"UPDATE t_actor SET last_name = ? WHERE id = ?\",\n\t\t\t\"Banjo\", 5276L);\n----\n======\n\nThe following example shows how to perform an `DELETE` operation with `CqlTemplate`:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n\t\tcqlTemplate.execute(\n\t\t\t\t\"DELETE FROM t_actor WHERE id = ?\",\n\t\t\t\t5276L);\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\t\tMono<Boolean> applied = reactiveCqlTemplate.execute(\n\t\t\t\"DELETE FROM actor WHERE id = ?\",\n\t\t\tactorId);\n----\n======\n\n[[cassandra.cql-template.examples.other]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/cql-template.adoc", "title": "cql-template", "heading": "`INSERT`, `UPDATE`, and `DELETE` with `CqlTemplate`", "heading_level": 3, "file_order": 8, "section_index": 3, "content_hash": "c1e45b2bd1d307cfdb97a08b2733a558dd91910b027f28d1e29a5dd0210bfd58", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/cql-template.adoc"}}
{"id": "sha256:093f8fb3d6c1c4c86772d139bb5f68f88bfaf776380a47c056888f83f81e0b1c", "content": "You can use the `execute(..)` method to execute any arbitrary CQL.\nAs a result, the method is often used for DDL statements.\nIt is heavily overloaded with variants that take callback interfaces, bind variable arrays, and so on.\n\nThe following example shows how to create and drop a table by using different API objects that are all passed to the `execute()` methods:\n\n====\n[source,java]\n----\n\t\tcqlTemplate.execute(\"CREATE TABLE test_table (id uuid primary key, event text)\");\n\n\t\tDropTableSpecification dropper = DropTableSpecification.dropTable(\"test_table\");\n\t\tString cql = DropTableCqlGenerator.toCql(dropper);\n\n\t\tcqlTemplate.execute(cql);\n----\n====\n\n[[cassandra.connections]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/cql-template.adoc", "title": "cql-template", "heading": "Other `CqlTemplate` operations", "heading_level": 3, "file_order": 8, "section_index": 4, "content_hash": "093f8fb3d6c1c4c86772d139bb5f68f88bfaf776380a47c056888f83f81e0b1c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/cql-template.adoc"}}
{"id": "sha256:7a515983695cd5afacdf08b5eb0f82db588f9c98e16e482dfcb7b7de8f77b021", "content": "Applications connect to Apache Cassandra by using `CqlSession` objects.\nA Cassandra `CqlSession` keeps track of multiple connections to the individual nodes and is designed to be a thread-safe, long-lived object.\nUsually, you can use a single `CqlSession` for the whole application.\n\nSpring acquires a Cassandra `CqlSession` through a `SessionFactory`. `SessionFactory` is part of Spring Data for Apache Cassandra and is a generalized connection factory.\nIt lets the container or framework hide connection handling and routing issues from the application code.\n\nThe following example shows how to configure a default `SessionFactory`:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\nCqlSession session = … // get a Cassandra Session\n\nCqlTemplate template = new CqlTemplate();\n\ntemplate.setSessionFactory(new DefaultSessionFactory(session));\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\nCqlSession session = … // get a Cassandra Session\n\nReactiveCqlTemplate template = new ReactiveCqlTemplate(new DefaultBridgedReactiveSession(session));\n----\n======\n\n`CqlTemplate` and other Template API implementations obtain a `CqlSession` for each operation.\nDue to their long-lived nature, sessions are not closed after invoking the desired operation.\nResponsibility for proper resource disposal lies with the container or framework that uses the session.\n\nYou can find various `SessionFactory` implementations within the `org.springframework.data.cassandra.core.cql.session`\npackage.\n\n[[exception-translation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/cql-template.adoc", "title": "cql-template", "heading": "Controlling Cassandra Connections", "heading_level": 2, "file_order": 8, "section_index": 5, "content_hash": "7a515983695cd5afacdf08b5eb0f82db588f9c98e16e482dfcb7b7de8f77b021", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/cql-template.adoc"}}
{"id": "sha256:fce955eddbd680faee7bf0d07a696b301bce6c9b7308e913cf83860a293179a2", "content": "The Spring Framework provides exception translation for a wide variety of database and mapping technologies.\nThis has traditionally been for JDBC and JPA.\nSpring Data for Apache Cassandra extends this feature to Apache Cassandra by providing an implementation of the `org.springframework.dao.support.PersistenceExceptionTranslator` interface.\n\nThe motivation behind mapping to Spring's {springDocsUrl}/data-access/dao.html#dao-exceptions[consistent data access exception hierarchy]\nis to let you write portable and descriptive exception handling code without resorting to coding against and handling specific Cassandra exceptions.\nAll of Spring's data access exceptions are inherited from the\n`DataAccessException` class, so you can be sure that you can catch all database-related exceptions within a single try-catch block.\n\n`ReactiveCqlTemplate` and `ReactiveCassandraTemplate` propagate exceptions as early as possible.\nExceptions that occur during the processing of the reactive sequence are emitted as error signals.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/cql-template.adoc", "title": "cql-template", "heading": "Exception Translation", "heading_level": 2, "file_order": 8, "section_index": 6, "content_hash": "fce955eddbd680faee7bf0d07a696b301bce6c9b7308e913cf83860a293179a2", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/cql-template.adoc"}}
{"id": "sha256:3db5423c33961c9dacacbdb1c64ea1802db4a97ba4ce02fad6ada2bf5f4b9e24", "content": "[[cassandra.mapping-usage.events]]\n\nThe Cassandra mapping framework has several built-in `org.springframework.context.ApplicationEvent` events that your application can respond to by registering special beans in the `ApplicationContext`.\nBeing based on Spring's application context event infrastructure lets other products, such as Spring Integration, easily receive these events as they are a well known eventing mechanism in Spring-based applications.\n\nTo intercept an object before it goes into the database, you can register a subclass of javadoc:org.springframework.data.cassandra.core.mapping.event.AbstractCassandraEventListener[] that overrides the `onBeforeSave(…)` method.\nWhen the event is dispatched, your listener is called and passed the domain object (which is a Java entity).\nEntity lifecycle events can be costly and you may notice a change in the performance profile when loading large result sets.\nYou can disable lifecycle events on the javadoc:org.springframework.data.cassandra.core.CassandraTemplate#setEntityLifecycleEventsEnabled(boolean)[Template API].\nThe following example uses the `onBeforeSave` method:\n\n====\n[source,java]\n----\nclass BeforeSaveListener extends AbstractCassandraEventListener<Person> {\n\t@Override\n\tpublic void onBeforeSave(BeforeSaveEvent<Person> event) {\n\t\t// … change values, delete them, whatever …\n\t}\n}\n----\n====\n\nDeclaring these beans in your Spring `ApplicationContext` will cause them to be invoked whenever the event is dispatched.\n\nThe javadoc:org.springframework.data.cassandra.core.mapping.event.AbstractCassandraEventListener[] has the following callback methods:\n\n* `onBeforeSave`: Called in `CassandraTemplate.insert(…)` and `.update(…)` operations before inserting or updating a row in the database but after creating the `Statement`.\n* `onAfterSave`: Called in `CassandraTemplate…insert(…)` and `.update(…)` operations after inserting or updating a row in the database.\n* `onBeforeDelete`: Called in `CassandraTemplate.delete(…)` operations before deleting row from the database.\n* `onAfterDelete`: Called in `CassandraTemplate.delete(…)` operations after deleting row from the database.\n* `onAfterLoad`: Called in the `CassandraTemplate.select(…)`, `.slice(…)`, and `.stream(…)` methods after each row is retrieved from the database.\n* `onAfterConvert`: Called in the `CassandraTemplate.select(…)`, `.slice(…)`, and `.stream(…)` methods after converting a row retrieved from the database to a POJO.\n\nNOTE: Lifecycle events are emitted only for root-level types.\nComplex types used as properties within an aggregate root are not subject to event publication.\n\ninclude::{commons}@data-commons::page$entity-callbacks.adoc[leveloffset=+1]\n\n[[cassandra.entity-callbacks]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/events.adoc", "title": "events", "heading": "events", "heading_level": 1, "file_order": 9, "section_index": 0, "content_hash": "3db5423c33961c9dacacbdb1c64ea1802db4a97ba4ce02fad6ada2bf5f4b9e24", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/events.adoc"}}
{"id": "sha256:cb0cd57350576ba421bf512067f68dff5836a5ab14852887bf2b2fa232f1a443", "content": "Spring Data for Apache Cassandra uses the `EntityCallback` API for its auditing support and reacts on the following callbacks.\n\n.Supported Entity Callbacks\n[%header,cols=\"4\"]\n|===\n| Callback\n| Method\n| Description\n| Order\n\n| `ReactiveBeforeConvertCallback`\n`BeforeConvertCallback`\n| `onBeforeConvert(T entity, CqlIdentifier tableName)`\n| Invoked before a domain object is converted to `Statement`.\nDomain objects can be updated to include the change in the `Statement`.\n| `Ordered.LOWEST_PRECEDENCE`\n\n| `ReactiveAuditingEntityCallback`\n`AuditingEntityCallback`\n| `onBeforeConvert(Object entity, CqlIdentifier tableName)`\n| Marks an auditable entity _created_ or _modified_\n| 100\n\n| `ReactiveBeforeSaveCallback`\n`BeforeSaveCallback`\n| `onBeforeSave(T entity, CqlIdentifier tableName, Statement statement)`\n| Invoked before a domain object is saved. +\nCan modify the target object after the `Statement` has been created. The provided statement contains all mapped entity information but changes to the domain object are not included in the `Statement`.\n| `Ordered.LOWEST_PRECEDENCE`\n\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/events.adoc", "title": "events", "heading": "Store-specific EntityCallbacks", "heading_level": 3, "file_order": 9, "section_index": 1, "content_hash": "cb0cd57350576ba421bf512067f68dff5836a5ab14852887bf2b2fa232f1a443", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/events.adoc"}}
{"id": "sha256:83ea074362d636397d8c6c433078f9b299c7feb9b363f3a33a01d18a1d6856d3", "content": "[[cassandra.getting-started]]\n\nSpring Data for Apache Cassandra requires Apache Cassandra 2.1 or later and Datastax Java Driver 4.0 or later.\nAn easy way to quickly set up and bootstrap a working environment is to create a Spring-based project in https://spring.io/tools[Spring Tools] or use https://start.spring.io/#!type=maven-project&dependencies=data-cassandra[start.spring.io].\n\n[[cassandra.examples-repo]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/getting-started.adoc", "title": "getting-started", "heading": "getting-started", "heading_level": 1, "file_order": 10, "section_index": 0, "content_hash": "83ea074362d636397d8c6c433078f9b299c7feb9b363f3a33a01d18a1d6856d3", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/getting-started.adoc"}}
{"id": "sha256:82d35d7940daf8d4dda3c07acd57bf51b9b12c3967496e50ca15a43af354d593", "content": "To get a feel for how the library works, you can download and play around with\nhttps://github.com/spring-projects/spring-data-examples[several examples].\n\n[[cassandra.hello-world]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/getting-started.adoc", "title": "getting-started", "heading": "Examples Repository", "heading_level": 2, "file_order": 10, "section_index": 1, "content_hash": "82d35d7940daf8d4dda3c07acd57bf51b9b12c3967496e50ca15a43af354d593", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/getting-started.adoc"}}
{"id": "sha256:f210351208d247bde2b485cbe07e64a3e2e4a1bf493b8a8bafe6eb89ab66f747", "content": "First, you need to set up a running Apache Cassandra server.\nSee the\nhttps://cassandra.apache.org/doc/latest/getting_started/index.html[Apache Cassandra Quick Start Guide]\nfor an explanation on how to start Apache Cassandra.\nOnce installed, starting Cassandra is typically a matter of executing the following command: `CASSANDRA_HOME/bin/cassandra -f`.\n\nTo create a Spring project in STS, go to File -> New -> Spring Template Project -> Simple Spring Utility Project and press Yes when prompted.\nThen enter a project and a package name, such as `org.spring.data.cassandra.example`.\n\nThen you can add the following dependency declaration to your pom.xml file's `dependencies` section.\n\n====\n[source,xml,subs=\"verbatim,attributes\"]\n----\n<dependencies>\n\n <dependency>\n <groupId>org.springframework.data</groupId>\n <artifactId>spring-data-cassandra</artifactId>\n <version>{version}</version>\n </dependency>\n\n</dependencies>\n----\n====\n\nAlso, you should change the version of Spring in the pom.xml file to be as follows:\n\n====\n[source,xml,subs=\"verbatim,attributes\"]\n----\n<spring.version>{springVersion}</spring.version>\n----\n====\n\nIf using a milestone release instead of a GA release, you also need to add the location of the Spring Milestone repository for Maven to your pom.xml file so that it is at the same level of your `<dependencies/>` element, as follows:\n\n[source,xml]\n----\n<repositories>\n <repository>\n <id>spring-milestone</id>\n <name>Spring Maven MILESTONE Repository</name>\n <url>https://repo.spring.io/milestone</url>\n </repository>\n</repositories>\n----\n\nThe repository is also https://repo.spring.io/milestone/org/springframework/data/[browseable here].\n\nYou can also browse all Spring repositories https://repo.spring.io/webapp/#/home[here].\n\nNow you can create a simple Java application that stores and reads a domain object to and from Cassandra.\n\nTo do so, first create a simple domain object class to persist, as the following example shows:\n\n====\n[source,java]\n----\npackage org.springframework.data.cassandra.example;\n\nimport org.springframework.data.cassandra.core.mapping.PrimaryKey;\nimport org.springframework.data.cassandra.core.mapping.Table;\n\n@Table\npublic class Person {\n\n\t@PrimaryKey private final String id;\n\n\tprivate final String name;\n\tprivate final int age;\n\n\tpublic Person(String id, String name, int age) {\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tprivate String getName() {\n\t\treturn name;\n\t}\n\n\tprivate int getAge() {\n\t\treturn age;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"{ @type = %1$s, id = %2$s, name = %3$s, age = %4$d }\", getClass().getName(), getId(),\n\t\t\t\tgetName(), getAge());\n\t}\n}\n----\n====\n\nNext, create the main application to run, as the following example shows:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\npackage org.springframework.data.cassandra.example;\n\nimport java.util.UUID;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.data.cassandra.core.CassandraOperations;\nimport org.springframework.data.cassandra.core.CassandraTemplate;\nimport org.springframework.data.cassandra.core.query.Criteria;\nimport org.springframework.data.cassandra.core.query.Query;\n\nimport com.datastax.oss.driver.api.core.CqlSession;\n\npublic class CassandraApplication {\n\n\tprivate static final Log LOG = LogFactory.getLog(CassandraApplication.class);\n\n\tprivate static Person newPerson(String name, int age) {\n\t\treturn new Person(UUID.randomUUID().toString(), name, age);\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tCqlSession cqlSession = CqlSession.builder().withKeyspace(\"mykeyspace\").build();\n\n\t\tCassandraOperations template = new CassandraTemplate(cqlSession);\n\n\t\tPerson jonDoe = template.insert(newPerson(\"Jon Doe\", 40));\n\n\t\tLOG.info(template.selectOne(Query.query(Criteria.where(\"id\").is(jonDoe.getId())), Person.class).getId());\n\n\t\ttemplate.truncate(Person.class);\n\t\tcqlSession.close();\n\t}\n\n}\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\npackage org.springframework.data.cassandra.example;\n\nimport reactor.core.publisher.Mono;\n\nimport java.util.UUID;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.data.cassandra.core.ReactiveCassandraOperations;\nimport org.springframework.data.cassandra.core.ReactiveCassandraTemplate;\nimport org.springframework.data.cassandra.core.cql.session.DefaultBridgedReactiveSession;\nimport org.springframework.data.cassandra.core.query.Criteria;\nimport org.springframework.data.cassandra.core.query.Query;\n\nimport com.datastax.oss.driver.api.core.CqlSession;\n\npublic class ReactiveCassandraApplication {\n\n\tprivate static final Log LOG = LogFactory.getLog(ReactiveCassandraApplication.class);\n\n\tprivate static Person newPerson(String name, int age) {\n\t\treturn new Person(UUID.randomUUID().toString(), name, age);\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tCqlSession cqlSession = CqlSession.builder().withKeyspace(\"mykeyspace\").build();\n\n\t\t ReactiveCassandraOperations template = new ReactiveCassandraTemplate(new DefaultBridgedReactiveSession(cqlSession));\n\n    Mono<Person> jonDoe = template.insert(newPerson(\"Jon Doe\", 40));\n\n    jonDoe.flatMap(it -> template.selectOne(Query.query(Criteria.where(\"id\").is(it.getId())), Person.class))\n\t\t\t\t.doOnNext(it -> LOG.info(it.toString()))\n        .then(template.truncate(Person.class))\n        .block();\n\n\t\tcqlSession.close();\n\t}\n\n}\n----\n======\n\nEven in this simple example, there are a few notable things to point out:\n\n* You can create an instance of javadoc:org.springframework.data.cassandra.core.CassandraTemplate[] (or javadoc:org.springframework.data.cassandra.core.ReactiveCassandraTemplate[] for reactive usage) with a Cassandra `CqlSession`.\n* You must annotate your POJO as a Cassandra `@Table` entity and also annotate the `@PrimaryKey`.\nOptionally, you can override these mapping names to match your Cassandra database table and column names.\n* You can either use raw CQL or the Driver `QueryBuilder` API to construct your queries.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/getting-started.adoc", "title": "getting-started", "heading": "Hello World", "heading_level": 2, "file_order": 10, "section_index": 2, "content_hash": "f210351208d247bde2b485cbe07e64a3e2e4a1bf493b8a8bafe6eb89ab66f747", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/getting-started.adoc"}}
{"id": "sha256:fb969ee682e5f573781be57a70f5a9a635b25ac568c153239b486a93731ce8de", "content": "[[cassandra.template.prepared-statements]]\n\nCQL statements that are executed multiple times can be prepared and stored in a `PreparedStatement` object to improve query performance.\nBoth, the driver and Cassandra maintain a mapping of `PreparedStatement` queries to their metadata.\nYou can use prepared statements through the following abstractions:\n\n* xref:cassandra/cql-template.adoc[`CqlTemplate`, `AsyncCqlTemplate`, or `ReactiveCqlTemplate`] through the choice of API\n* xref:cassandra/template.adoc[`CassandraTemplate`, `AsyncCassandraTemplate`, or `ReactiveCassandraTemplate`] by enabling prepared statements\n* xref:repositories.adoc[Cassandra repositories] as they are built on top of the Template API\n\n[[cassandra.template.prepared-statements.cql]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/prepared-statements.adoc", "title": "prepared-statements", "heading": "prepared-statements", "heading_level": 1, "file_order": 11, "section_index": 0, "content_hash": "fb969ee682e5f573781be57a70f5a9a635b25ac568c153239b486a93731ce8de", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/prepared-statements.adoc"}}
{"id": "sha256:93b1b6f0e556f3e69ceff70df5161e98d508fb47b2ebf47ee4189c3181eefe0a", "content": "The `CqlTemplate` class (and its asynchronous and reactive variants) offers various methods accepting static CQL, `Statement` objects and `PreparedStatementCreator`.\nMethods accepting static CQL without additional arguments typically run the CQL statement as-is without further processing.\nMethods accepting static CQL in combination with an arguments array (such as `execute(String cql, Object... args)` and `queryForRows(String cql, Object... args)`) use prepared statements.\nInternally, these methods create a `PreparedStatementCreator` and `PreparedStatementBinder` objects to prepare the statement and later on to bind values to the statement to run it.\nSpring Data Cassandra generally uses index-based parameter bindings for prepared statements.\n\nSince Cassandra Driver version 4, prepared statements are cached on the driver level which removes the need to keep track of prepared statements in the application.\n\nThe following example shows how to issue a query with a parametrized prepared statement:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n\t\tString lastName = cqlTemplate.queryForObject(\n\t\t\t\t\"SELECT last_name FROM t_actor WHERE id = ?\",\n\t\t\t\tString.class, 1212L);\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\t\tMono<String> lastName = reactiveCqlTemplate.queryForObject(\n\t\t\t\"SELECT last_name FROM t_actor WHERE id = ?\",\n\t\t\tString.class, 1212L);\n----\n======\n\nIn cases where you require more control over statement preparation and parameter binding (for example, using named binding parameters), you can fully control prepared statement creation and parameter binding by calling query methods with `PreparedStatementCreator` and `PreparedStatementBinder` arguments:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n\t\tList<String> lastNames = cqlTemplate.query(\n\t\t\t\tsession -> session.prepare(\"SELECT last_name FROM t_actor WHERE id = ?\"),\n\t\t\t\tps -> ps.bind(1212L),\n\t\t\t\t(row, rowNum) -> row.getString(0));\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\t\tFlux<String> lastNames = reactiveCqlTemplate.query(\n\t\t\t\tsession -> session.prepare(\"SELECT last_name FROM t_actor WHERE id = ?\"),\n\t\t\t\tps -> ps.bind(1212L),\n\t\t\t\t(row, rowNum) -> row.getString(0));\n----\n======\n\nSpring Data Cassandra ships with classes supporting that pattern in the `cql` package:\n\n* `SimplePreparedStatementCreator` - utility class to create a prepared statement.\n* `ArgumentPreparedStatementBinder` - utility class to bind arguments to a prepared statement.\n\n[[cassandra.template.prepared-statements.cassandra-template]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/prepared-statements.adoc", "title": "prepared-statements", "heading": "Using `CqlTemplate`", "heading_level": 2, "file_order": 11, "section_index": 1, "content_hash": "93b1b6f0e556f3e69ceff70df5161e98d508fb47b2ebf47ee4189c3181eefe0a", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/prepared-statements.adoc"}}
{"id": "sha256:105a7f4d32a5abb49890dd377de013697f95545adba7a3ac81c0a6083d041324", "content": "The `CassandraTemplate` class is built on top of `CqlTemplate` to provide a higher level of abstraction.\nThe use of prepared statements can be controlled directly on `CassandraTemplate` (and its asynchronous and reactive variants) by calling `setUsePreparedStatements(false)` respective `setUsePreparedStatements(true)`.\nNote that the use of prepared statements by `CassandraTemplate` is enabled by default.\n\nThe following example shows the use of methods that generate and that accept CQL:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n\t\ttemplate.setUsePreparedStatements(true);\n\n\t\tActor actorByQuery = template.selectOne(query(where(\"id\").is(42)), Actor.class);\n\n\t\tActor actorByStatement = template.selectOne(\n\t\t\t\tSimpleStatement.newInstance(\"SELECT id, name FROM actor WHERE id = ?\", 42),\n\t\t\t\tActor.class);\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n\t\ttemplate.setUsePreparedStatements(true);\n\n\t\tMono<Actor> actorByQuery = template.selectOne(query(where(\"id\").is(42)), Actor.class);\n\n\t\tMono<Actor> actorByStatement = template.selectOne(\n\t\t\t\tSimpleStatement.newInstance(\"SELECT id, name FROM actor WHERE id = ?\", 42),\n\t\t\t\tActor.class);\n----\n======\n\nCalling entity-bound methods such as `select(Query, Class<T>)` or `update(Query, Update, Class<T>)` build CQL statements themselves to perform the intended operations.\nSome `CassandraTemplate` methods (such as `select(Statement<?>, Class<T>)`) also accepts CQL `Statement` objects as part of their API.\n\nIt's possible to participate in prepared statements when calling methods accepting a `Statement` with a `SimpleStatement` object.\nThe template API extracts the query string and parameters (positional and named parameters) and uses these to prepare, bind, and run the statement.\nNon-``SimpleStatement`` objects cannot be used with prepared statements.\n\n[[cassandra.template.prepared-statements.caching]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/prepared-statements.adoc", "title": "prepared-statements", "heading": "Using `CassandraTemplate`", "heading_level": 3, "file_order": 11, "section_index": 2, "content_hash": "105a7f4d32a5abb49890dd377de013697f95545adba7a3ac81c0a6083d041324", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/prepared-statements.adoc"}}
{"id": "sha256:cf27da5247991f0a7265064291fa1d37b79edcf0498905bdcfb0f7b7f4daf86c", "content": "Since Cassandra driver 4.0, prepared statements are cached by the `CqlSession` cache so it is okay to prepare the same string twice.\nPrevious versions required caching of prepared statements outside of the driver.\nSee also the https://docs.datastax.com/en/developer/java-driver/latest/manual/core/statements/prepared/[Driver documentation on Prepared Statements] for further reference.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/prepared-statements.adoc", "title": "prepared-statements", "heading": "Caching Prepared Statements", "heading_level": 2, "file_order": 11, "section_index": 3, "content_hash": "cf27da5247991f0a7265064291fa1d37b79edcf0498905bdcfb0f7b7f4daf86c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/prepared-statements.adoc"}}
{"id": "sha256:9b9f9919dda0a5521cc741b2b9515c6052134cf88f34720ed370fc1cd9c05eac", "content": "[[cassandra.property-converters]]\n\nWhile xref:cassandra/converters.adoc[type-based conversion] already offers ways to influence the conversion and representation of certain types within the target store, it has limitations when only certain values or properties of a particular type should be considered for conversion.\nProperty-based converters allow configuring conversion rules on a per-property basis, either declaratively (via `@ValueConverter`) or programmatically (by registering a `PropertyValueConverter` for a specific property).\n\nA `PropertyValueConverter` can transform a given value into its store representation (write) and back (read) as the following listing shows.\nThe additional `ValueConversionContext` provides additional information, such as mapping metadata and direct `read` and `write` methods.\n\n.A simple `PropertyValueConverter`\n====\n[source,java]\n----\nclass ReversingValueConverter implements PropertyValueConverter<String, String, ValueConversionContext> {\n\n\t@Override\n\tpublic String read(String value, ValueConversionContext context) {\n\t\treturn reverse(value);\n\t}\n\n\t@Override\n\tpublic String write(String value, ValueConversionContext context) {\n\t\treturn reverse(value);\n\t}\n\n}\n----\n====\n\nYou can obtain `PropertyValueConverter` instances from `CustomConversions#getPropertyValueConverter(…)` by delegating to `PropertyValueConversions`, typically by using a `PropertyValueConverterFactory` to provide the actual converter.\nDepending on your application's needs, you can chain or decorate multiple instances of `PropertyValueConverterFactory` -- for example, to apply caching.\nBy default, Spring Data Cassandra uses a caching implementation that can serve types with a default constructor or enum values.\nA set of predefined factories is available through the factory methods in `PropertyValueConverterFactory`.\nYou can use `PropertyValueConverterFactory.beanFactoryAware(…)` to obtain a `PropertyValueConverter` instance from an `ApplicationContext`.\n\nYou can change the default behavior through `ConverterConfiguration`.\n\n[[cassandra.property-converters.declarative]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/property-converters.adoc", "title": "property-converters", "heading": "property-converters", "heading_level": 1, "file_order": 12, "section_index": 0, "content_hash": "9b9f9919dda0a5521cc741b2b9515c6052134cf88f34720ed370fc1cd9c05eac", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/property-converters.adoc"}}
{"id": "sha256:2e97e3f8745dba8dc35ecb94bf631adf4ca1ea083f0463a77bba8d7d007fb479", "content": "The most straight forward usage of a `PropertyValueConverter` is by annotating properties with the `@ValueConverter` annotation that defines the converter type:\n\n.Declarative PropertyValueConverter\n====\n[source,java]\n----\nclass Person {\n\n @ValueConverter(ReversingValueConverter.class)\n String ssn;\n}\n----\n====\n\n[[cassandra.property-converters.programmatic]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/property-converters.adoc", "title": "property-converters", "heading": "Declarative Value Converter", "heading_level": 2, "file_order": 12, "section_index": 1, "content_hash": "2e97e3f8745dba8dc35ecb94bf631adf4ca1ea083f0463a77bba8d7d007fb479", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/property-converters.adoc"}}
{"id": "sha256:8cecc16a3532b78ed1d1d781fa05ae822125b506925e8166f9d33df482fa1ec7", "content": "Programmatic registration registers `PropertyValueConverter` instances for properties within an entity model by using a `PropertyValueConverterRegistrar`, as the following example shows.\nThe difference between declarative registration and programmatic registration is that programmatic registration happens entirely outside the entity model.\nSuch an approach is useful if you cannot or do not want to annotate the entity model.\n\n.Programmatic PropertyValueConverter registration\n====\n[source,java]\n----\nPropertyValueConverterRegistrar registrar = new PropertyValueConverterRegistrar();\n\nregistrar.registerConverter(Address.class, \"street\", new PropertyValueConverter() { … }); <1>\n\nregistrar.registerConverter(Person.class, Person::getSsn()) <2>\n .writing(value -> encrypt(value))\n .reading(value -> decrypt(value));\n----\n\n<1> Register a converter for the field identified by its name.\n<2> Type safe variant that allows to register a converter and its conversion functions.\nThis method uses class proxies to determine the property.\nMake sure that neither the class nor the accessors are `final` as otherwise this approach doesn't work.\n====\n\nWARNING: Dot notation (such as `registerConverter(Person.class, \"address.street\", …)`) for nagivating across properties into nested objects is *not* supported when registering converters.\n\nWARNING: Schema derivation can only derive the column type from a registered converter if the converter is a `PropertyValueConverter` class.\nGenerics cannot be determined from lambdas and using a lambda will fall back to the property type.\n\nTIP: `CassandraValueConverter` offers a pre-typed `PropertyValueConverter` interface that uses `CassandraConversionContext`.\n\n[[cassandra.conversions.-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/property-converters.adoc", "title": "property-converters", "heading": "Programmatic Value Converter Registration", "heading_level": 2, "file_order": 12, "section_index": 2, "content_hash": "8cecc16a3532b78ed1d1d781fa05ae822125b506925e8166f9d33df482fa1ec7", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/property-converters.adoc"}}
{"id": "sha256:3c9269b88b8b07ec8821a97c7f66f11819c44ac0c305ec15b19a9c3dafecc2f5", "content": "By default, `CassandraCustomConversions` can handle declarative value converters, depending on the configured `PropertyValueConverterFactory`.\n`CassandraConverterConfigurationAdapter` helps you to set up programmatic value conversions or define the `PropertyValueConverterFactory` to be used or to register converters.\n\n.Configuration Sample\n====\n[source,java]\n----\nCassandraCustomConversions conversions = CassandraCustomConversions.create(adapter -> {\n adapter.registerConverter(…);\n adapter.configurePropertyConversions(registrar -> {\n registrar.registerConverter(Person.class, \"name\", String.class)\n .writing((from, ctx) -> …)\n .reading((from, ctx) -> …);\n });\n});\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/property-converters.adoc", "title": "property-converters", "heading": "CassandraCustomConversions configuration", "heading_level": 2, "file_order": 12, "section_index": 3, "content_hash": "3c9269b88b8b07ec8821a97c7f66f11819c44ac0c305ec15b19a9c3dafecc2f5", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/property-converters.adoc"}}
{"id": "sha256:d99513dd9d3b5553a38f9696b7533ac000b9e4c7fb90c121c4bbe60ac9effdc1", "content": "[[cassandra.reactive]]\n\nThe reactive Cassandra support contains a wide range of features:\n\n* Spring configuration support using Java-based `@Configuration` classes.\n* `ReactiveCqlTemplate` helper class that increases productivity by properly handling common Cassandra data access operations.\n* `ReactiveCassandraTemplate` helper class that increases productivity by using `ReactiveCassandraOperations` in a reactive manner.\nIt includes integrated object mapping between tables and POJOs.\n* Exception translation into Spring's portable {springDocsUrl}/data-access/dao.html#dao-exceptions[Data Access Exception Hierarchy].\n* Feature rich object mapping integrated with Spring's {springDocsUrl}/core/validation/convert.html[Conversion Service].\n* Java-based Query, Criteria, and Update DSLs.\n* Automatic implementation of `Repository` interfaces, including support for custom finder methods.\n\nFor most data-oriented tasks, you can use the `ReactiveCassandraTemplate` or the repository support, which use the rich object mapping functionality. `ReactiveCqlTemplate` is commonly used to increment counters or perform ad-hoc CRUD operations. `ReactiveCqlTemplate` also provides callback methods that make it easy to get low-level API objects, such as `com.datastax.oss.driver.api.core.CqlSession`, which let you communicate directly with Cassandra.\nSpring Data for Apache Cassandra uses consistent naming conventions on objects in various APIs to those found in the DataStax Java Driver so that they are immediately familiar and so that you can map your existing knowledge onto the Spring APIs.\n\nReactive usage is broken up into two phases: Composition and Execution.\n\nCalling repository methods lets you compose a reactive sequence by obtaining `Publisher` instances and applying operators.\nNo I/O happens until you subscribe.\nPassing the reactive sequence to a reactive execution infrastructure, such as {springDocsUrl}/web/webflux.html[Spring WebFlux]\nor https://vertx.io/docs/vertx-reactive-streams/java/[Vert.x]), subscribes to the publisher and initiate the actual execution.\nSee https://projectreactor.io/docs/core/release/reference/#reactive.subscribe[the Project reactor documentation] for more detail.\n\n[[cassandra.reactive.repositories.libraries]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/reactive-cassandra.adoc", "title": "reactive-cassandra", "heading": "reactive-cassandra", "heading_level": 1, "file_order": 13, "section_index": 0, "content_hash": "d99513dd9d3b5553a38f9696b7533ac000b9e4c7fb90c121c4bbe60ac9effdc1", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/reactive-cassandra.adoc"}}
{"id": "sha256:30dd121e905e054c32165ae367d6a14fa88f16ab5afd68f3cf24d327df68f812", "content": "The reactive space offers various reactive composition libraries.\nThe most common libraries are\nhttps://github.com/ReactiveX/RxJava[RxJava] and https://projectreactor.io/[Project Reactor].\n\nSpring Data for Apache Cassandra is built on top of the https://github.com/datastax/java-driver[DataStax Cassandra Driver].\nThe driver is not reactive but the asynchronous capabilities allow us to adopt and expose the `Publisher` APIs to provide maximum interoperability by relying on the https://www.reactive-streams.org/[Reactive Streams] initiative.\nStatic APIs, such as `ReactiveCassandraOperations`, are provided by using Project Reactor's `Flux` and `Mono` types.\nProject Reactor offers various adapters to convert reactive wrapper types (`Flux` to `Observable` and back), but conversion can easily clutter your code.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/reactive-cassandra.adoc", "title": "reactive-cassandra", "heading": "Reactive Composition Libraries", "heading_level": 2, "file_order": 13, "section_index": 1, "content_hash": "30dd121e905e054c32165ae367d6a14fa88f16ab5afd68f3cf24d327df68f812", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/reactive-cassandra.adoc"}}
{"id": "sha256:e65d792d1654771d8bfcb44b1e3a6fea7ddf24afdd57c852d881b537244d73d1", "content": "[[cassandra.schema-management]]\n\nApache Cassandra is a data store that requires a schema definition prior to any data interaction.\nSpring Data for Apache Cassandra can support you with schema creation.\n\n[[cql-specifications]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/schema-management.adoc", "title": "schema-management", "heading": "schema-management", "heading_level": 1, "file_order": 14, "section_index": 0, "content_hash": "e65d792d1654771d8bfcb44b1e3a6fea7ddf24afdd57c852d881b537244d73d1", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/schema-management.adoc"}}
{"id": "sha256:da07cdb6ab9ec886424c73760346e460c1f0a6217c986e2fdf3112c0dc531777", "content": "CQL specifications are an abstraction to represent CQL DDL actions such as table creations or keyspace drops.\nSpecifications are available for the following CQL object types:\n\n* Keyspace\n* Table\n* Index\n* User-defined Type\n\nNOTE: Variants of Cassandra can support Materialized Views, User-defined functions, roles and many more object types.\nSpring Data for Apache Cassandra provides only specifications for the above listed types.\n\nThese can be used to CREATE, ALTER, and DROP CQL objects through a fluent interface. `SpecificationBuilder` is the entry point to build such a specification.\nYou can use later on `CqlGenerator.toCql(…)` to easily render CQL from a specification.\n\nSee the following examples to create a specification for keyspace creation, table creation, and index creation.\n\n.Specifying a Cassandra keyspace\n====\n.Java\n[indent=0,source,java]\n----\n\t\tCqlSpecification createKeyspace = SpecificationBuilder.createKeyspace(\"my_keyspace\")\n\t\t\t\t.with(KeyspaceOption.REPLICATION, KeyspaceAttributes.newSimpleReplication())\n\t\t\t\t.with(KeyspaceOption.DURABLE_WRITES, true);\n\n\t\t// results in CREATE KEYSPACE my_keyspace WITH replication = {'class': 'SimpleStrategy', 'replication_factor': '1'} AND durable_writes = true\n\t\tString cql = CqlGenerator.toCql(createKeyspace);\n----\n====\n\n.Specifying a Cassandra table\n====\n.Java\n[indent=0,source,java]\n----\n\t\tCreateTableSpecification createTable = CreateTableSpecification.createTable(\"my_table\")\n\t\t\t\t.partitionKeyColumn(\"last_name\", DataTypes.TEXT)\n\t\t\t\t.partitionKeyColumn(\"first_name\", DataTypes.TEXT)\n\t\t\t\t.column(\"age\", DataTypes.INT);\n\n\t\t// results in CREATE TABLE my_table (last_name text, first_name text, age int, PRIMARY KEY(last_name, first_name))\n\t\tString cql = CqlGenerator.toCql(createTable);\n----\n====\n\n.Specifying a Cassandra index\n====\n.Java\n[indent=0,source,java]\n----\n\t\tCreateIndexSpecification spec = SpecificationBuilder.createIndex()\n\t\t\t\t.tableName(\"mytable\").keys().columnName(\"column\");\n\n\t\t// results in CREATE INDEX ON mytable (KEYS(column))\n\t\tString cql = CqlGenerator.toCql(createTable);\n----\n====\n\nYou can use specifications together with the configuration API to define keyspace creation and schema actions.\n\n[[keyspaces-and-lifecycle-scripts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/schema-management.adoc", "title": "schema-management", "heading": "CQL Specifications", "heading_level": 2, "file_order": 14, "section_index": 1, "content_hash": "da07cdb6ab9ec886424c73760346e460c1f0a6217c986e2fdf3112c0dc531777", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/schema-management.adoc"}}
{"id": "sha256:7e5dbde07b4311a98b19cf03b8e804075fbb37ff77cd1405d80f374d056cca64", "content": "The first thing to start with is a Cassandra keyspace.\nA keyspace is a logical grouping of tables that share the same replication factor and replication strategy.\nKeyspace management is located in the `CqlSession` configuration, which has the `KeyspaceSpecification` and startup and shutdown CQL script execution.\n\nDeclaring a keyspace with a specification allows creating and dropping of the Keyspace.\nIt derives CQL from the specification so that you need not write CQL yourself.\nThe following example specifies a Cassandra keyspace by using XML:\n\n.Specifying a Cassandra keyspace\n====\n.Java\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class CreateKeyspaceConfiguration extends AbstractCassandraConfiguration implements BeanClassLoaderAware {\n\n\t@Override\n\tprotected List<CreateKeyspaceSpecification> getKeyspaceCreations() {\n\n\t\tCreateKeyspaceSpecification specification = SpecificationBuilder.createKeyspace(\"my_keyspace\")\n\t\t\t\t.with(KeyspaceOption.DURABLE_WRITES, true)\n\t\t\t\t.withNetworkReplication(DataCenterReplication.of(\"foo\", 1), DataCenterReplication.of(\"bar\", 2));\n\n\t\treturn Arrays.asList(specification);\n\t}\n\n\t@Override\n\tprotected List<DropKeyspaceSpecification> getKeyspaceDrops() {\n\t\treturn Arrays.asList(DropKeyspaceSpecification.dropKeyspace(\"my_keyspace\"));\n\t}\n\n\t// ...\n}\n----\n\n.XML\n[source,xml,role=\"secondary\"]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:cassandra=\"http://www.springframework.org/schema/data/cassandra\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/data/cassandra\n https://www.springframework.org/schema/data/cassandra/spring-cassandra.xsd\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <cassandra:session>\n\n <cassandra:keyspace action=\"CREATE_DROP\" durable-writes=\"true\" name=\"my_keyspace\">\n <cassandra:replication class=\"NETWORK_TOPOLOGY_STRATEGY\">\n <cassandra:data-center name=\"foo\" replication-factor=\"1\" />\n <cassandra:data-center name=\"bar\" replication-factor=\"2\" />\n </cassandra:replication>\n </cassandra:keyspace>\n\n </cassandra:session>\n</beans>\n----\n====\n\nNOTE: Keyspace creation allows rapid bootstrapping without the need of external keyspace management.\nThis can be useful for certain scenarios but should be used with care.\nDropping a keyspace on application shutdown removes the keyspace and all data from the tables in the keyspace.\n\n[[cassandra.schema-management.initializing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/schema-management.adoc", "title": "schema-management", "heading": "Keyspaces and Lifecycle Scripts", "heading_level": 2, "file_order": 14, "section_index": 2, "content_hash": "7e5dbde07b4311a98b19cf03b8e804075fbb37ff77cd1405d80f374d056cca64", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/schema-management.adoc"}}
{"id": "sha256:3152c1296b88f5458a39a413c6f9db2678a28acb8a2dae40c4bf1b0dbf6d2743", "content": "The `org.springframework.data.cassandra.core.cql.session.init` package provides support for initializing an existing `SessionFactory`.\nYou may sometimes need to initialize a keyspace that runs on a server somewhere.\n\n[[cassandra.schema-management.initializing.config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/schema-management.adoc", "title": "schema-management", "heading": "Initializing a `SessionFactory`", "heading_level": 2, "file_order": 14, "section_index": 3, "content_hash": "3152c1296b88f5458a39a413c6f9db2678a28acb8a2dae40c4bf1b0dbf6d2743", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/schema-management.adoc"}}
{"id": "sha256:1d5d54e45ec6be84fd315273f461936440b97b513b2b984d82b059ffe9869005", "content": "You can provide arbitrary CQL that is executed on `CqlSession` initialization and shutdown in the configured keyspace, as the following Java configuration example shows:\n\n====\n.Java\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class KeyspacePopulatorConfiguration extends AbstractCassandraConfiguration {\n\n\t@Nullable\n\t@Override\n\tprotected KeyspacePopulator keyspacePopulator() {\n\t\treturn new ResourceKeyspacePopulator(new ClassPathResource(\"com/foo/cql/db-schema.cql\"),\n\t\t\t\tnew ClassPathResource(\"com/foo/cql/db-test-data.cql\"));\n\t}\n\n\t@Nullable\n\t@Override\n\tprotected KeyspacePopulator keyspaceCleaner() {\n\t\treturn new ResourceKeyspacePopulator(scriptOf(\"DROP TABLE my_table;\"));\n\t}\n\n\t// ...\n}\n----\n\n.XML\n[source,xml,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n<cassandra:initialize-keyspace session-factory-ref=\"cassandraSessionFactory\">\n <cassandra:script location=\"classpath:com/foo/cql/db-schema.cql\"/>\n <cassandra:script location=\"classpath:com/foo/cql/db-test-data.cql\"/>\n</cassandra:initialize-keyspace>\n----\n====\n\nThe preceding example runs the two specified scripts against the keyspace.\nThe first script creates a schema, and the second populates tables with a test data set.\nThe script locations can also be patterns with wildcards in the usual Ant style used for resources in Spring (for example, `classpath{asterisk}:/com/foo/{asterisk}{asterisk}/cql/{asterisk}-data.cql`).\nIf you use a pattern, the scripts are run in the lexical order of their URL or filename.\n\nThe default behavior of the keyspace initializer is to unconditionally run the provided scripts.\nThis may not always be what you want -- for instance, if you run the scripts against a keyspace that already has test data in it.\nThe likelihood of accidentally deleting data is reduced by following the common pattern (shown earlier) of creating the tables first and then inserting the data.\nThe first step fails if the tables already exist.\n\nHowever, to gain more control over the creation and deletion of existing data, the XML namespace provides a few additional options.\nThe first is a flag to switch the initialization on and off.\nYou can set this according to the environment (such as pulling a boolean value from system properties or from an environment bean).\nThe following example gets a value from a system property:\n\n====\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n<cassandra:initialize-keyspace session-factory-ref=\"cassandraSessionFactory\"\n enabled=\"#{systemProperties.INITIALIZE_KEYSPACE}\"> <1>\n <cassandra:script location=\"...\"/>\n</cassandra:initialize-database>\n----\n\n<1> Get the value for `enabled` from a system property called `INITIALIZE_KEYSPACE`.\n====\n\nThe second option to control what happens with existing data is to be more tolerant of failures.\nTo this end, you can control the ability of the initializer to ignore certain errors in the CQL it executes from the scripts, as the following example shows:\n\n====\n.Java\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class KeyspacePopulatorFailureConfiguration extends AbstractCassandraConfiguration {\n\n\t@Nullable\n\t@Override\n\tprotected KeyspacePopulator keyspacePopulator() {\n\n\t\tResourceKeyspacePopulator populator = new ResourceKeyspacePopulator(\n\t\t\t\tnew ClassPathResource(\"com/foo/cql/db-schema.cql\"));\n\n\t\tpopulator.setIgnoreFailedDrops(true);\n\n\t\treturn populator;\n\t}\n\n\t// ...\n}\n----\n\n.XML\n[source,xml,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n<cassandra:initialize-keyspace session-factory-ref=\"cassandraSessionFactory\" ignore-failures=\"DROPS\">\n <cassandra:script location=\"...\"/>\n</cassandra:initialize-database>\n----\n====\n\nIn the preceding example, we are saying that we expect that, sometimes, the scripts are run against an empty keyspace, and there are some `DROP` statements in the scripts that would, therefore, fail.\nSo failed CQL `DROP` statements will be ignored, but other failures will cause an exception.\nThis is useful if you don't want tu use support `DROP ... IF EXISTS` (or similar) but you want to unconditionally remove all test data before re-creating it.\nIn that case the first script is usually a set of `DROP` statements, followed by a set of `CREATE` statements.\n\nThe `ignore-failures` option can be set to `NONE` (the default), `DROPS` (ignore failed drops), or `ALL` (ignore all failures).\n\nEach statement should be separated by `;` or a new line if the `;` character is not present at all in the script.\nYou can control that globally or script by script, as the following example shows:\n\n====\n.Java\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class SessionFactoryInitializerConfiguration extends AbstractCassandraConfiguration {\n\n\t@Bean\n\tSessionFactoryInitializer sessionFactoryInitializer(SessionFactory sessionFactory) {\n\n\t\tSessionFactoryInitializer initializer = new SessionFactoryInitializer();\n\t\tinitializer.setSessionFactory(sessionFactory);\n\n\t\tResourceKeyspacePopulator populator1 = new ResourceKeyspacePopulator();\n\t\tpopulator1.setSeparator(\";\");\n\t\tpopulator1.setScripts(new ClassPathResource(\"com/myapp/cql/db-schema.cql\"));\n\n\t\tResourceKeyspacePopulator populator2 = new ResourceKeyspacePopulator();\n\t\tpopulator2.setSeparator(\"@@\");\n\t\tpopulator2.setScripts(new ClassPathResource(\"classpath:com/myapp/cql/db-test-data-1.cql\"), //\n\t\t\t\tnew ClassPathResource(\"classpath:com/myapp/cql/db-test-data-2.cql\"));\n\n\t\tinitializer.setKeyspacePopulator(new CompositeKeyspacePopulator(populator1, populator2));\n\n\t\treturn initializer;\n\t}\n\n\t// ...\n}\n----\n\n.XML\n[source,xml,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n<cassandra:initialize-keyspace session-factory-ref=\"cassandraSessionFactory\" separator=\"@@\">\n <cassandra:script location=\"classpath:com/myapp/cql/db-schema.cql\" separator=\";\"/>\n <cassandra:script location=\"classpath:com/myapp/cql/db-test-data-1.cql\"/>\n <cassandra:script location=\"classpath:com/myapp/cql/db-test-data-2.cql\"/>\n</cassandra:initialize-keyspace>\n----\n====\n\nIn this example, the two `test-data` scripts use `@@` as statement separator and only the `db-schema.cql` uses `;`.\nThis configuration specifies that the default separator is `@@` and overrides that default for the `db-schema` script.\n\nIf you need more control than you get from the XML namespace, you can use the `SessionFactoryInitializer` directly and define it as a component in your application.\n\n[[cassandra.schema-management.initializing.component]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/schema-management.adoc", "title": "schema-management", "heading": "Initializing a Keyspace", "heading_level": 3, "file_order": 14, "section_index": 4, "content_hash": "1d5d54e45ec6be84fd315273f461936440b97b513b2b984d82b059ffe9869005", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/schema-management.adoc"}}
{"id": "sha256:ba20096302cb66a7203668f99c8f704475352d6929dac7d8ff7299e2586dee1f", "content": "A large class of applications (those that do not use the database until after the Spring context has started) can use the database initializer with no further complications.\nIf your application is not one of those, you might need to read the rest of this section.\n\nThe database initializer depends on a `SessionFactory` instance and runs the scripts provided in its initialization callback (analogous to an `init-method` in an XML bean definition, a `@PostConstruct` method in a component, or the `afterPropertiesSet()` method in a component that implements `InitializingBean`).\nIf other beans depend on the same data source and use the session factory in an initialization callback, there might be a problem because the data has not yet been initialized.\nA common example of this is a cache that initializes eagerly and loads data from the database on application startup.\n\nTo get around this issue, you have two options: change your cache initialization strategy to a later phase or ensure that the keyspace initializer is initialized first.\n\nChanging your cache initialization strategy might be easy if the application is in your control and not otherwise.\nSome suggestions for how to implement this include:\n\n* Make the cache initialize lazily on first usage, which improves application startup time.\n* Have your cache or a separate component that initializes the cache implement `Lifecycle` or `SmartLifecycle`.\nWhen the application context starts, you can automatically start a `SmartLifecycle` by setting its `autoStartup` flag, and you can manually start a `Lifecycle` by calling `ConfigurableApplicationContext.start()` on the enclosing context.\n* Use a Spring `ApplicationEvent` or similar custom observer mechanism to trigger the cache initialization. `ContextRefreshedEvent` is always published by the context when it is ready for use (after all beans have been initialized), so that is often a useful hook (this is how the `SmartLifecycle` works by default).\n\nEnsuring that the keyspace initializer is initialized first can also be easy.\nSome suggestions on how to implement this include:\n\n* Rely on the default behavior of the Spring `BeanFactory`, which is that beans are initialized in registration order.\nYou can easily arrange that by adopting the common practice of a set of `<import/>` elements in XML configuration that order your application modules and ensuring that the database and database initialization are listed first.\n* Separate the `SessionFactory` and the business components that use it and control their startup order by putting them in separate `ApplicationContext` instances (for example, the parent context contains the `SessionFactory`, and the child context contains the business components).\nThis structure is common in Spring web applications but can be more generally applied.\n* Use the Schema management for xref:cassandra/schema-management.adoc#cassandra.schema-management.tables[Tables and User-defined Types] to initialize the keyspace using Spring Data Cassandra's built-in schema generator.\n\n[[cassandra.schema-management.tables]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/schema-management.adoc", "title": "schema-management", "heading": "Initialization of Other Components that Depend on the Keyspace", "heading_level": 4, "file_order": 14, "section_index": 5, "content_hash": "ba20096302cb66a7203668f99c8f704475352d6929dac7d8ff7299e2586dee1f", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/schema-management.adoc"}}
{"id": "sha256:646a9828e4d3be5f80a247dbc0d6a9b0293b0c277fe47119d69c598c63733d60", "content": "Spring Data for Apache Cassandra approaches data access with mapped entity classes that fit your data model.\nYou can use these entity classes to create Cassandra table specifications and user type definitions.\n\nSchema creation is tied to `CqlSession` initialization by `SchemaAction`.\nThe following actions are supported:\n\n* `SchemaAction.NONE`: No tables or types are created or dropped.\nThis is the default setting.\n* `SchemaAction.CREATE`: Create tables, indexes, and user-defined types from entities annotated with `@Table` and types annotated with `@UserDefinedType`.\nExisting tables or types cause an error if you tried to create the type.\n* `SchemaAction.CREATE_IF_NOT_EXISTS`: Like `SchemaAction.CREATE` but with `IF NOT EXISTS` applied.\nExisting tables or types do not cause any errors but may remain stale.\n* `SchemaAction.RECREATE`: Drops and recreates existing tables and types that are known to be used.\nTables and types that are not configured in the application are not dropped.\n* `SchemaAction.RECREATE_DROP_UNUSED`: Drops all tables and types and recreates only known tables and types.\n\nNOTE: `SchemaAction.RECREATE` and `SchemaAction.RECREATE_DROP_UNUSED` drop your tables and lose all data.\n`RECREATE_DROP_UNUSED` also drops tables and types that are not known to the application.\n\n[[enabling-tables-and-user-defined-types-for-schema-management]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/schema-management.adoc", "title": "schema-management", "heading": "Tables and User-defined Types", "heading_level": 2, "file_order": 14, "section_index": 6, "content_hash": "646a9828e4d3be5f80a247dbc0d6a9b0293b0c277fe47119d69c598c63733d60", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/schema-management.adoc"}}
{"id": "sha256:f3f15dedcca91f01b00fdffbcece0d83c4ce2aeb645d685882305f41ea84952a", "content": "xref:object-mapping.adoc#mapping.usage[Metadata-based Mapping] explains object mapping with conventions and annotations.\nTo prevent unwanted classes from being created as a table or a type, schema management is only active for entities annotated with `@Table` and user-defined types annotated with `@UserDefinedType`.\nEntities are discovered by scanning the classpath.\nEntity scanning requires one or more base packages.\nTuple-typed columns that use `TupleValue` do not provide any typing details.\nConsequently, you must annotate such column properties with `@CassandraType(type = TUPLE, typeArguments = …)`\nto specify the desired column type.\n\nThe following example shows how to specify entity base packages in XML configuration:\n\n.Specifying entity base packages\n====\n.Java\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class EntityBasePackagesConfiguration extends AbstractCassandraConfiguration {\n\n\t@Override\n\tpublic String[] getEntityBasePackages() {\n\t\treturn new String[] { \"com.foo\", \"com.bar\" };\n\t}\n\n\t// ...\n}\n----\n\n.XML\n[source,xml,role=\"secondary\"]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:cassandra=\"http://www.springframework.org/schema/data/cassandra\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/data/cassandra\n https://www.springframework.org/schema/data/cassandra/spring-cassandra.xsd\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <cassandra:mapping entity-base-packages=\"com.foo,com.bar\"/>\n</beans>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/schema-management.adoc", "title": "schema-management", "heading": "Enabling Tables and User-Defined Types for Schema Management", "heading_level": 3, "file_order": 14, "section_index": 7, "content_hash": "f3f15dedcca91f01b00fdffbcece0d83c4ce2aeb645d685882305f41ea84952a", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/schema-management.adoc"}}
{"id": "sha256:314dd409f003542a93283be1a4e125ab884077c2d99336fdc59127d9a74cd4c9", "content": "[[cassandra.template]]\n\nThe `CassandraTemplate` class (and its reactive variant `ReactiveCassandraTemplate`), located in the `org.springframework.data.cassandra` package, is the central class in Spring's Cassandra support and provides a rich feature set to interact with the database.\nThe template offers convenience operations to create, update, delete, and query Cassandra, and provides a mapping between your domain objects and rows in Cassandra tables.\n\nNOTE: Once configured, a template instance is thread-safe and can be reused across multiple instances.\n\nThe mapping between rows in Cassandra and application domain classes is done by delegating to an implementation of the `CassandraConverter` interface.\nSpring provides a default implementation, `MappingCassandraConverter`, but you can also write your own custom converter.\nSee the section on\nxref:object-mapping.adoc[Cassandra conversion] for more detailed information.\n\nThe `CassandraTemplate` class implements the `CassandraOperations` interface and its reactive variant `ReactiveCassandraTemplate` implements `ReactiveCassandraOperations`.\nIn as much as possible, the methods on `[Reactive]CassandraOperations` are named after methods available in Cassandra to make the API familiar to developers who are already familiar with Cassandra.\n\nFor example, you can find methods such as `select`, `insert`, `delete`, and `update`.\nThe design goal was to make it as easy as possible to transition between the use of the base Cassandra driver and `[Reactive]CassandraOperations`.\nA major difference between the two APIs is that `CassandraOperations` can be passed domain objects instead of CQL and query objects.\n\nNOTE: The preferred way to reference operations on a `[Reactive]CassandraTemplate` instance is through the\n`[Reactive]CassandraOperations` interface.\n\nThe default converter implementation used by `[Reactive]CassandraTemplate` is `MappingCassandraConverter`.\nWhile `MappingCassandraConverter` can use additional metadata to specify the mapping of objects to rows, it can also convert objects that contain no additional metadata by using some conventions for the mapping of fields and table names.\nThese conventions, as well as the use of mapping annotations, are explained in the xref:object-mapping.adoc[\"`Mapping`\" chapter].\n\nAnother central feature of `[Reactive]CassandraTemplate` is exception translation of exceptions thrown in the Cassandra Java driver into Spring's portable Data Access Exception hierarchy.\nSee the section on\nxref:cassandra/cql-template.adoc#exception-translation[exception translation] for more information.\n\nNOTE: The Template API has different execution model flavors.\nThe basic `CassandraTemplate` uses a blocking (imperative-synchronous) execution model.\nYou can use `AsyncCassandraTemplate` for asynchronous execution and synchronization with `CompletableFuture` instances or `ReactiveCassandraTemplate` for reactive execution.\n\n[[cassandra.template.instantiating]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "template", "heading_level": 1, "file_order": 15, "section_index": 0, "content_hash": "314dd409f003542a93283be1a4e125ab884077c2d99336fdc59127d9a74cd4c9", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:431c71e459badee779accf985dd75cea5b498c4eed47eacf32c81397a5164026", "content": "`CassandraTemplate` should always be configured as a Spring bean, although we show an example earlier where you can instantiate it directly.\nHowever, because we are assuming the context of making a Spring module, we assume the presence of the Spring container.\n\nThere are two ways to get a `CassandraTemplate`, depending on how you load you Spring `ApplicationContext`:\n\n* xref:cassandra/template.adoc#cassandra-template-autowiring[Autowiring]\n* xref:cassandra/template.adoc#cassandra-template-bean-lookup-applicationcontext[Bean Lookup with `ApplicationContext`]\n\n[float]\n[[cassandra-template-autowiring]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Instantiating `CassandraTemplate`", "heading_level": 2, "file_order": 15, "section_index": 1, "content_hash": "431c71e459badee779accf985dd75cea5b498c4eed47eacf32c81397a5164026", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:99a4e94e0a834835c0c77b08e68a1e1b88344753cc3512e929f973c4970d8c6b", "content": "You can autowire a `[Reactive]CassandraOperations` into your project, as the following example shows:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n@Autowired\nprivate CassandraOperations cassandraOperations;\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n@Autowired\nprivate ReactiveCassandraOperations reactiveCassandraOperations;\n----\n======\n\nAs with all Spring autowiring, this assumes there is only one bean of type `[Reactive]CassandraOperations` in the `ApplicationContext`.\nIf you have multiple `[Reactive]CassandraTemplate` beans (which is the case if you work with multiple keyspaces in the same project), then you can use the `@Qualifier` annotation to designate the bean you want to autowire.\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n@Autowired\n@Qualifier(\"keyspaceOneTemplateBeanId\")\nprivate CassandraOperations cassandraOperations;\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\n@Autowired\n@Qualifier(\"keyspaceOneTemplateBeanId\")\nprivate ReactiveCassandraOperations reactiveCassandraOperations;\n----\n======\n\n[float]\n[[cassandra-template-bean-lookup-applicationcontext]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Autowiring", "heading_level": 3, "file_order": 15, "section_index": 2, "content_hash": "99a4e94e0a834835c0c77b08e68a1e1b88344753cc3512e929f973c4970d8c6b", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:58aa8f52cabfe2c32233065407d535fba11bd60f06ceac25117e457566fe3340", "content": "You can also look up the `[Reactive]CassandraTemplate` bean from the `ApplicationContext`, as shown in the following example:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\nCassandraOperations cassandraOperations = applicationContext.getBean(\"cassandraTemplate\", CassandraOperations.class);\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\nReactiveCassandraOperations cassandraOperations = applicationContext.getBean(\"ReactiveCassandraOperations\", ReactiveCassandraOperations.class);\n----\n======\n\n[[cassandra.template.query]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Bean Lookup with `ApplicationContext`", "heading_level": 3, "file_order": 15, "section_index": 3, "content_hash": "58aa8f52cabfe2c32233065407d535fba11bd60f06ceac25117e457566fe3340", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:4218cfe69b563eb9a7904dd13195b7d952d3174a845d04e80cfc0d8ee9e06360", "content": "You can express your queries by using the `Query` and `Criteria` classes, which have method names that reflect the native Cassandra predicate operator names, such as `lt`, `lte`, `is`, and others.\n\nThe `Query` and `Criteria` classes follow a fluent API style so that you can easily chain together multiple method criteria and queries while having easy-to-understand code.\nStatic imports are used in Java when creating `Query`\nand `Criteria` instances to improve readability.\n\n[[cassandra.template.query.table]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Querying Rows", "heading_level": 2, "file_order": 15, "section_index": 4, "content_hash": "4218cfe69b563eb9a7904dd13195b7d952d3174a845d04e80cfc0d8ee9e06360", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:e9220344a173a16376c2207002b9849f59fcf6ab8e77b77894d8b17fde5c1770", "content": "In earlier sections, we saw how to retrieve a single object by using the `selectOneById` method on `[Reactive]CassandraTemplate`.\nDoing so returns a single domain object.\nWe can also query for a collection of rows to be returned as a list of domain objects.\nAssuming we have a number of `Person` objects with name and age values stored as rows in a table and that each person has an account balance, we can now run a query by using the following code:\n\n.Querying for rows using `[Reactive]CassandraTemplate`\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\nimport static org.springframework.data.cassandra.core.query.Criteria.where;\nimport static org.springframework.data.cassandra.core.query.Query.query;\n\n…\n\nList<Person> result = cassandraTemplate.select(query(where(\"age\").is(50))\n .and(where(\"balance\").gt(1000.00d)).withAllowFiltering(), Person.class);\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\nimport static org.springframework.data.cassandra.core.query.Criteria.where;\nimport static org.springframework.data.cassandra.core.query.Query.query;\n\n…\n\nFlux<Person> result = reactiveCassandraTemplate.select(query(where(\"age\").is(50))\n .and(where(\"balance\").gt(1000.00d)).withAllowFiltering(), Person.class);\n----\n======\n\nThe `select`, `selectOne`, and `stream` methods take a `Query` object as a parameter.\nThis object defines the criteria and options used to perform the query.\nThe criteria is specified by using a `Criteria` object that has a static factory method named `where` that instantiates a new `Criteria` object.\nWe recommend using a static import for `org.springframework.data.cassandra.core.query.Criteria.where` and `Query.query`, to make the query more readable.\n\nThis query should return a list of `Person` objects that meet the specified criteria.\nThe `Criteria` class has the following methods that correspond to the operators provided in Apache Cassandra:\n\n[[cassandra.template.query.criteria]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Querying Rows in a Table", "heading_level": 3, "file_order": 15, "section_index": 5, "content_hash": "e9220344a173a16376c2207002b9849f59fcf6ab8e77b77894d8b17fde5c1770", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:ed175eea70f507d24ef568db7f659ff45eb500165d7e7e535fd0160bae8a6b95", "content": "* `CriteriaDefinition` *gt* `(Object value)`: Creates a criterion by using the `>` operator.\n* `CriteriaDefinition` *gte* `(Object value)`: Creates a criterion by using the `>=` operator.\n* `CriteriaDefinition` *in* `(Object... values)`: Creates a criterion by using the `IN` operator for a varargs argument.\n* `CriteriaDefinition` *in* `(Collection<?> collection)`: Creates a criterion by using the `IN` operator using a collection.\n* `CriteriaDefinition` *is* `(Object value)`: Creates a criterion by using field matching (`column = value`).\n* `CriteriaDefinition` *lt* `(Object value)`: Creates a criterion by using the `<` operator.\n* `CriteriaDefinition` *lte* `(Object value)`: Creates a criterion by using the `<=` operator.\n* `CriteriaDefinition` *like* `(Object value)`: Creates a criterion by using the `LIKE` operator.\n* `CriteriaDefinition` *contains* `(Object value)`: Creates a criterion by using the `CONTAINS` operator.\n* `CriteriaDefinition` *containsKey* `(Object key)`: Creates a criterion by using the `CONTAINS KEY` operator.\n\n`Criteria` is immutable once created.\n\n[[cassandra.template.query.query-class]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Methods for the Criteria class", "heading_level": 4, "file_order": 15, "section_index": 6, "content_hash": "ed175eea70f507d24ef568db7f659ff45eb500165d7e7e535fd0160bae8a6b95", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:05f3bb909f21776d45753bac1e808f9258f5e188f5a5c6b62f4c0a10ab434687", "content": "The `Query` class has some additional methods that you can use to provide options for the query:\n\n* `Query` *by* `(CriteriaDefinition... criteria)`: Used to create a `Query` object.\n* `Query` *and* `(CriteriaDefinition criteria)`: Used to add additional criteria to the query.\n* `Query` *columns* `(Columns columns)`: Used to define columns to be included in the query results.\n* `Query` *limit* `(Limit limit)`: Used to limit the size of the returned results to the provided limit (used `SELECT` limiting).\n* `Query` *limit* `(long limit)`: Used to limit the size of the returned results to the provided limit (used `SELECT` limiting).\n* `Query` *pageRequest* `(Pageable pageRequest)`: Used to associate `Sort`, `PagingState`, and `fetchSize` with the query (used for paging).\n* `Query` *pagingState* `(CassandraScrollPosition pagingState)`: Used to associate a `CassandraScrollPosition` with the query (used for paging).\n* `Query` *pagingState* `(ByteBuffer pagingState)`: Used to associate a raw `ByteBuffer` with the query (used for paging).\n* `Query` *queryOptions* `(QueryOptions queryOptions)`: Used to associate `QueryOptions` with the query.\n* `Query` *sort* `(Sort sort)`: Used to provide a sort definition for the results.\n* `Query` *withAllowFiltering* `()`: Used to render `ALLOW FILTERING` queries.\n\n`Query` is immutable once created.\nInvoking methods creates new immutable (intermediate) `Query` objects.\n\n[[cassandra.template.query.rows]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Methods for the Query class", "heading_level": 3, "file_order": 15, "section_index": 7, "content_hash": "05f3bb909f21776d45753bac1e808f9258f5e188f5a5c6b62f4c0a10ab434687", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:f62814280236dc0fd63a7a99115a1131c2d59c33a3d71fe642d23e8eb1e92b7c", "content": "The `Query` class has the following methods that return rows:\n\n* `List<T>` *select* `(Query query, Class<T> entityClass)`: Query for a list of objects of type `T` from the table.\n* `T` *selectOne* `(Query query, Class<T> entityClass)`: Query for a single object of type `T` from the table.\n* `Slice<T>` *slice* `(Query query, Class<T> entityClass)`: Starts or continues paging by querying for a `Slice` of objects of type `T` from the table.\n* `Stream<T>` *stream* `(Query query, Class<T> entityClass)`: Query for a stream of objects of type `T` from the table.\n* `List<T>` *select* `(String cql, Class<T> entityClass)`: Ad-hoc query for a list of objects of type `T` from the table by providing a CQL statement.\n* `T` *selectOne* `(String cql, Class<T> entityClass)`: Ad-hoc query for a single object of type `T` from the table by providing a CQL statement.\n* `Stream<T>` *stream* `(String cql, Class<T> entityClass)`: Ad-hoc query for a stream of objects of type `T` from the table by providing a CQL statement.\n\nThe query methods must specify the target type `T` that is returned.\n\n[[cassandra.template.query.columns]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Methods for Querying for Rows", "heading_level": 3, "file_order": 15, "section_index": 8, "content_hash": "f62814280236dc0fd63a7a99115a1131c2d59c33a3d71fe642d23e8eb1e92b7c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:4e680df16930363c38580dca16335fa87b64bbb70cbe22148890927969286741", "content": "When not specifying `Query.colums(…)`, all columns are selected (`SELECT * FROM …`) to enable access to all available columns from entities through `@Value(…)` and when using open projections.\n\nIf you provide more information to a query (e.g. when using closed DTO or Interface projections through <<cassandra.template.query.fluent-template-api>>) then the column selection will be limited.\n\nYou can configure the default `ProjectionFunction` on `StatementFactory` for each `CassandraTemplate` instance to influence the default column selection:\n\n====\n[source,java]\n----\nCassandraTemplate template = …;\ntemplate.getStatementFactory().setProjectionFunction(ProjectionFunction.mappedProperties());\n----\n====\n\nExplicitly specifying columns through `ProjectionFunctions.mappedProperties()` will limit the selection to mapped properties of the entity type but its explicit nature will validate queries against the entity mapping when running the query and any undesired schema changes will become visible through exceptions.\nNote that any unmapped properties won't be available to `@Value(…)`.\n\nUsing explicit column selection through `Query.columns(…)` will bypass `Columns` computation from projection functions.\n\n[[cassandra.template.query.fluent-template-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Column Projection", "heading_level": 3, "file_order": 15, "section_index": 9, "content_hash": "4e680df16930363c38580dca16335fa87b64bbb70cbe22148890927969286741", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:22ffa8840b1acabc8bb06f2a43225af59e6693cb1b9a708d786885c820a48e6c", "content": "The `[Reactive]CassandraOperations` interface is one of the central components when it comes to more low-level interaction with Apache Cassandra.\nIt offers a wide range of methods.\nYou can find multiple overloads for every method.\nMost of them cover optional (nullable) parts of the API.\n\n`FluentCassandraOperations` and its reactive variant `ReactiveFluentCassandraOperations` provide a more narrow interface for common methods of `[Reactive]CassandraOperations`\nproviding a more readable, fluent API.\nThe entry points (`query(…)`, `insert(…)`, `update(…)`, and `delete(…)`) follow a natural naming scheme based on the operation to execute.\nMoving on from the entry point, the API is designed to offer only context-dependent methods that guide the developer towards a terminating method that invokes the actual `[Reactive]CassandraOperations`.\nThe following example shows the fluent API:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\nList<SWCharacter> all = ops.query(SWCharacter.class)\n .inTable(\"star_wars\") <1>\n .all();\n----\n<1> Skip this step if `SWCharacter` defines the table name with `@Table` or if using the class name as the table name is not a problem\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\nFlux<SWCharacter> all = ops.query(SWCharacter.class)\n .inTable(\"star_wars\") <1>\n .all();\n----\n<1> Skip this step if `SWCharacter` defines the table name with `@Table` or if using the class name as the table name is not a problem\n======\n\nIf a table in Cassandra holds entities of different types, such as a `Jedi` within a Table of `SWCharacters`, you can use different types to map the query result.\nYou can use `as(Class<?> targetType)` to map results to a different target type, while `query(Class<?> entityType)` still applies to the query and table name.\nThe following example uses the `query` and `as` methods:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\nList<Jedi> all = ops.query(SWCharacter.class) <1>\n .as(Jedi.class) <2>\n .matching(query(where(\"jedi\").is(true)))\n .all();\n----\n<1> The query fields are mapped against the `SWCharacter` type.\n<2> Resulting rows are mapped into `Jedi`.\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\nFlux<Jedi> all = ops.query(SWCharacter.class) <1>\n .as(Jedi.class) <2>\n .matching(query(where(\"jedi\").is(true)))\n .all();\n----\n<1> The query fields are mapped against the `SWCharacter` type.\n<2> Resulting rows are mapped into `Jedi`.\n======\n\nTIP: You can directly apply xref:repositories/projections.adoc[] to resulting documents by providing only the `interface` type through `as(Class<?>)`.\n\nThe terminating methods (`first()`, `one()`, `all()`, and `stream()`) handle switching between retrieving a single entity and retrieving multiple entities as `List` or `Stream` and similar operations.\n\nWARNING: The new fluent template API methods (that is, `query(…)`, `insert(…)`, `update(…)`, and `delete(…)`) use effectively thread-safe supporting objects to compose the CQL statement.\nHowever, it comes at the added cost of additional young-gen JVM heap overhead, since the design is based on final fields for the various CQL statement components and construction on mutation.\nYou should be careful when possibly inserting or deleting a large number of objects (such as inside a loop, for instance).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Fluent Template API", "heading_level": 3, "file_order": 15, "section_index": 10, "content_hash": "22ffa8840b1acabc8bb06f2a43225af59e6693cb1b9a708d786885c820a48e6c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:bdc095c5821ccaa4e0af56e30cc36067cc185b3c30f3772573fd2661d97aebe6", "content": "Projections are the foundation for querying data returned in a different form than the entity.\nWhile Cassandra's primary use-case follows a key-value model – storing what you retrieve – Vector search is different.\nRunning Vector search queries typically results in an aggregation or report-like result set.\nA typical query would return some form of content (such as a `text` column) along with its score (or distance) to the actual vector.\n\nConsider the following domain model:\n\n.Vector Search model\n====\n[source,java]\n----\n@Table\nclass Comments {\n\n\t@Id UUID id;\n\tString comment;\n\n\t@VectorType(dimensions = 5)\n\t@SaiIndexed Vector vector;\n}\n\nclass CommentSearch {\n\n\tString comment;\n\n\tfloat similarity;\n}\n----\n====\n\n`Comments` is the domain type defining a vector column and the `comment` column.\n\nRunning a Vector Search requires usage of `ANN` sorting and would typically define a similarity function to determine its distance from the given vector.\n\n.Using Vector Search\n====\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\nColumns columns = Columns.from(\"comment\") <1>\n .select(\"vector\", builder -> builder.similarity(vector)\n .cosine().as(\"similarity\")); <2>\n\nQuery query = Query.select(columns)\n .limit(3)\n .sort(VectorSort.ann(\"vector\", vector)); <3>\n\ntemplate.query(Comments.class)\n .as(CommentSearch.class) <4>\n .matching(query)\n .all();\n----\n\n<1> Select the columns to query.\n<2> Include a function call to `similarity_cosine(vector, […])`. `Columns.select(…)` uses a selector builder customizer to configure the actual selection.\nMake sure to declare an alias to map the result onto `CommentSearch.similarity` as result mapping uses column names.\n<3> Use the `VectorSort.ann(…)` to define the sort order in comparison to the given vector.\n<4> Define the target type to map the result to.\nThe `CommentSearch` type is result projection type defining columns that map the result.\n====\n\n[[cassandra-template.save-update-remove]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Vector Search Queries", "heading_level": 3, "file_order": 15, "section_index": 11, "content_hash": "bdc095c5821ccaa4e0af56e30cc36067cc185b3c30f3772573fd2661d97aebe6", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:6636a5737a44354c84b46af5e358cc1374255b6e06f23ec7630a080c4572c8e4", "content": "`[Reactive]CassandraTemplate` provides a simple way for you to save, update, and delete your domain objects and map those objects to tables managed in Cassandra.\n\n[[cassandra.template.type-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Saving, Updating, and Removing Rows", "heading_level": 2, "file_order": 15, "section_index": 12, "content_hash": "6636a5737a44354c84b46af5e358cc1374255b6e06f23ec7630a080c4572c8e4", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:b65ef1313eae844298c7afd5a259f9a2066affbb30b011eea7cc17718bbda5e2", "content": "Spring Data for Apache Cassandra relies on the DataStax Java driver's `CodecRegistry` to ensure type support.\nAs types are added or changed, the Spring Data for Apache Cassandra module continues to function without requiring changes.\nSee https://docs.datastax.com/en/cql/3.3/cql/cql_reference/cql_data_types_c.html[CQL data types]\nand \"`xref:object-mapping.adoc#mapping-conversion[Data Mapping and Type Conversion]`\" for the current type mapping matrix.\n\n[[cassandra.template.insert-update]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Type Mapping", "heading_level": 3, "file_order": 15, "section_index": 13, "content_hash": "b65ef1313eae844298c7afd5a259f9a2066affbb30b011eea7cc17718bbda5e2", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:ef4741fbb997bd665932b71b4342a6b944c0b12b971e384256da68a939ab27cb", "content": "`[Reactive]CassandraTemplate` has several convenient methods for saving and inserting your objects.\nTo have more fine-grained control over the conversion process, you can register Spring `Converter` instances with the `MappingCassandraConverter`\n(for example, `Converter<Row, Person>`).\n\nNOTE: The difference between insert and update operations is that `INSERT` operations do not insert `null` values.\n\nThe simple case of using the `INSERT` operation is to save a POJO.\nIn this case, the table name is determined by the simple class name (not the fully qualified class name).\nThe table to store the object can be overridden by using mapping metadata.\n\nWhen inserting or updating, the `id` property must be set.\nApache Cassandra has no means to generate an ID.\n\nThe following example uses the save operation and retrieves its contents:\n\n.Inserting and retrieving objects by using the `[Reactive]CassandraTemplate`\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\nimport static org.springframework.data.cassandra.core.query.Criteria.where;\nimport static org.springframework.data.cassandra.core.query.Query.query;\n…\n\nPerson bob = new Person(\"Bob\", 33);\ncassandraTemplate.insert(bob);\n\nPerson queriedBob = cassandraTemplate.selectOneById(query(where(\"age\").is(33)), Person.class);\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\nimport static org.springframework.data.cassandra.core.query.Criteria.where;\nimport static org.springframework.data.cassandra.core.query.Query.query;\n…\n\nPerson bob = new Person(\"Bob\", 33);\ncassandraTemplate.insert(bob);\n\nMono<Person> queriedBob = reactiveCassandraTemplate.selectOneById(query(where(\"age\").is(33)), Person.class);\n----\n======\n\nYou can use the following operations to insert and save:\n\n* `void` *insert* `(Object objectToSave)`: Inserts the object in an Apache Cassandra table.\n* `WriteResult` *insert* `(Object objectToSave, InsertOptions options)`: Inserts the object in an Apache Cassandra table and applies `InsertOptions`.\n\nYou can use the following update operations:\n\n* `void` *update* `(Object objectToSave)`: Updates the object in an Apache Cassandra table.\n* `WriteResult` *update* `(Object objectToSave, UpdateOptions options)`: Updates the object in an Apache Cassandra table and applies `UpdateOptions`.\n\nYou can also use the old fashioned way and write your own CQL statements, as the following example shows:\n\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\nString cql = \"INSERT INTO person (age, name) VALUES (39, 'Bob')\";\n\ncassandraTemplate().getCqlOperations().execute(cql);\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\nString cql = \"INSERT INTO person (age, name) VALUES (39, 'Bob')\";\n\nMono<Boolean> applied = reactiveCassandraTemplate.getReactiveCqlOperations().execute(cql);\n----\n======\n\nYou can also configure additional options such as TTL, consistency level, and lightweight transactions when using `InsertOptions` and `UpdateOptions`.\n\n[[cassandra.template.insert-update.table]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Methods for Inserting and Updating rows", "heading_level": 3, "file_order": 15, "section_index": 14, "content_hash": "ef4741fbb997bd665932b71b4342a6b944c0b12b971e384256da68a939ab27cb", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:49989f6a25a7d2c33cecd0fbadf40e14fd308b253e91c4a99da318486240559c", "content": "You can manage the table name that is used for operating on the tables in two ways.\nThe default table name is the simple class name changed to start with a lower-case letter.\nSo, an instance of the `com.example.Person` class would be stored in the `person` table.\nThe second way is to specify a table name in the `@Table` annotation.\n\n[[cassandra.template.batch]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Which Table Are My Rows Inserted into?", "heading_level": 4, "file_order": 15, "section_index": 15, "content_hash": "49989f6a25a7d2c33cecd0fbadf40e14fd308b253e91c4a99da318486240559c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:2fd4b379bf35926460ab7d91b61cde64d5f823012784cf6d1542a5f55cbdc75c", "content": "The Cassandra protocol supports inserting a collection of rows in one operation by using a batch.\n\nThe following methods in the `[Reactive]CassandraTemplate` interface support this functionality:\n\n* `batchOps`: Creates a new `[Reactive]CassandraBatchOperations` to populate the batch.\n\n`[Reactive]CassandraBatchOperations`\n\n* `insert`: Takes a single object, an array (var-args), or an `Iterable` of objects to insert.\n* `update`: Takes a single object, an array (var-args), or an `Iterable` of objects to update.\n* `delete`: Takes a single object, an array (var-args), or an `Iterable` of objects to delete.\n* `withTimestamp`: Applies a TTL to the batch.\n* `execute`: Executes the batch.\n\n[[cassandra.template.update]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Inserting, Updating, and Deleting Individual Objects in a Batch", "heading_level": 4, "file_order": 15, "section_index": 16, "content_hash": "2fd4b379bf35926460ab7d91b61cde64d5f823012784cf6d1542a5f55cbdc75c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:2701112db5f757be0d808b2ed466634ce9c2107ca4325031270e51b34fcc9aec", "content": "For updates, you can select to update a number of rows.\n\nThe following example shows updating a single account object by adding a one-time $50.00 bonus to the balance with the `+` assignment:\n\n.Updating rows using `[Reactive]CasandraTemplate`\n[tabs]\n======\nImperative::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\nimport static org.springframework.data.cassandra.core.query.Criteria.where;\nimport org.springframework.data.cassandra.core.query.Query;\nimport org.springframework.data.cassandra.core.query.Update;\n\n…\n\nboolean applied = cassandraTemplate.update(Query.query(where(\"id\").is(\"foo\")),\n Update.create().increment(\"balance\", 50.00), Account.class);\n----\n\nReactive::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\nimport static org.springframework.data.cassandra.core.query.Criteria.where;\nimport org.springframework.data.cassandra.core.query.Query;\nimport org.springframework.data.cassandra.core.query.Update;\n\n…\n\nMono<Boolean> wasApplied = reactiveCassandraTemplate.update(Query.query(where(\"id\").is(\"foo\")),\n Update.create().increment(\"balance\", 50.00), Account.class);\n----\n======\n\nIn addition to the `Query` discussed earlier, we provide the update definition by using an `Update` object.\nThe `Update` class has methods that match the update assignments available for Apache Cassandra.\n\nMost methods return the `Update` object to provide a fluent API for code styling purposes.\n\n[[cassandra.template.update.methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Updating Rows in a Table", "heading_level": 3, "file_order": 15, "section_index": 17, "content_hash": "2701112db5f757be0d808b2ed466634ce9c2107ca4325031270e51b34fcc9aec", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:29cabdc7e21ce4c0f1e3f5d6f71ea82c77acf409d2abec077beb2e465e83c7eb", "content": "The update method can update rows, as follows:\n\n* `boolean` *update* `(Query query, Update update, Class<?> entityClass)`: Updates a selection of objects in the Apache Cassandra table.\n\n[[cassandra.template.update.update]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Methods for Executing Updates for Rows", "heading_level": 4, "file_order": 15, "section_index": 18, "content_hash": "29cabdc7e21ce4c0f1e3f5d6f71ea82c77acf409d2abec077beb2e465e83c7eb", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:51d7e824d15d1c76e5e8762f41cfc9666ea58e12cbd24a345d91e13522abbf99", "content": "The `Update` class can be used with a little 'syntax sugar', as its methods are meant to be chained together.\nAlso, you can kick-start the creation of a new `Update` instance with the static method `public static Update update(String key, Object value)` and by using static imports.\n\nThe `Update` class has the following methods:\n\n* `AddToBuilder` *addTo* `(String columnName)` `AddToBuilder` entry-point:\n** Update `prepend(Object value)`: Prepends a collection value to the existing collection by using the `+` update assignment.\n ** Update `prependAll(Object... values)`: Prepends all collection values to the existing collection by using the `+` update assignment.\n** Update `append(Object value)`: Appends a collection value to the existing collection by using the `+` update assignment.\n ** Update `append(Object... values)`: Appends all collection values to the existing collection by using the `+` update assignment.\n** Update `entry(Object key, Object value)`: Adds a map entry by using the `+` update assignment.\n ** Update `addAll(Map<? extends Object, ? extends Object> map)`: Adds all map entries to the map by using the `+` update assignment.\n* `Update` *remove* `(String columnName, Object value)`: Removes the value from the collection by using the `-` update assignment.\n* `Update` *clear* `(String columnName)`: Clears the collection.\n* `Update` *increment* `(String columnName, Number delta)`: Updates by using the `+` update assignment.\n* `Update` *decrement* `(String columnName, Number delta)`: Updates by using the `-` update assignment.\n* `Update` *set* `(String columnName, Object value)`: Updates by using the `=` update assignment.\n* `SetBuilder` *set* `(String columnName)` `SetBuilder` entry-point:\n** Update `atIndex(int index).to(Object value)`: Sets a collection at the given index to a value using the `=` update assignment.\n** Update `atKey(String object).to(Object value)`: Sets a map entry at the given key to a value the `=` update assignment.\n\nThe following listing shows a few update examples:\n\n====\n[source]\n----\nUpdate.update(\"key\", \"Spring Data\")\n\nUpdate.empty().set(\"key\").atIndex(5).to(\"Spring Data\");\n\nUpdate.empty().addTo(\"key\").appendAll(\"Spring\", \"Data\");\n----\n====\n\nNote that `Update` is immutable once created.\nInvoking methods creates new immutable (intermediate) `Update` objects.\n\n[[cassandra.template.delete]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Methods for the Update class", "heading_level": 4, "file_order": 15, "section_index": 19, "content_hash": "51d7e824d15d1c76e5e8762f41cfc9666ea58e12cbd24a345d91e13522abbf99", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:6067a49fd9872cb7d055a34fe50f30f43927e2ab7244c33b90d4d087acf765eb", "content": "You can use the following overloaded methods to remove an object from the database:\n\n* `boolean` *delete* `(Query query, Class<?> entityClass)`: Deletes the objects selected by `Query`.\n* `T` *delete* `(T entity)`: Deletes the given object.\n* `T` *delete* `(T entity, QueryOptions queryOptions)`: Deletes the given object applying `QueryOptions`.\n* `boolean` *deleteById* `(Object id, Class<?> entityClass)`: Deletes the object using the given Id.\n\n[[cassandra.template.optimistic-locking]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Methods for Removing Rows", "heading_level": 3, "file_order": 15, "section_index": 20, "content_hash": "6067a49fd9872cb7d055a34fe50f30f43927e2ab7244c33b90d4d087acf765eb", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:b7b680e597f98d5d02c9243048bb830c14f7a7189d516aff3d2d1e35079bedb3", "content": "The `@Version` annotation provides syntax similar to that of JPA in the context of Cassandra and makes sure updates are only applied to rows with a matching version.\nOptimistic Locking leverages Cassandra's lightweight transactions to conditionally insert, update and delete rows.\nTherefore, `INSERT` statements are executed with the `IF NOT EXISTS` condition.\nFor updates and deletes, the actual value of the version property is added to the `UPDATE` condition in such a way that the modification does not have any effect if another operation altered the row in the meantime.\nIn that case, an `OptimisticLockingFailureException` is thrown.\nThe following example shows these features:\n\n====\n[source,java]\n----\n@Table\nclass Person {\n\n @Id String id;\n String firstname;\n String lastname;\n @Version Long version;\n}\n\nPerson daenerys = template.insert(new Person(\"Daenerys\")); <1>\n\nPerson tmp = template.findOne(query(where(\"id\").is(daenerys.getId())), Person.class); <2>\n\ndaenerys.setLastname(\"Targaryen\");\ntemplate.save(daenerys); <3>\n\ntemplate.save(tmp); // throws OptimisticLockingFailureException <4>\n----\n\n<1> Initially insert document. `version` is set to `0`.\n<2> Load the just inserted document. `version` is still `0`.\n<3> Update the document with `version = 0`.\nSet the `lastname` and bump `version` to `1`.\n<4> Try to update the previously loaded document that still has `version = 0`.\nThe operation fails with an `OptimisticLockingFailureException`, as the current `version` is `1`.\n====\n\nNOTE: Optimistic Locking is only supported with single-entity operations and not for batch operations.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/template.adoc", "title": "template", "heading": "Optimistic Locking", "heading_level": 3, "file_order": 15, "section_index": 21, "content_hash": "b7b680e597f98d5d02c9243048bb830c14f7a7189d516aff3d2d1e35079bedb3", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/template.adoc"}}
{"id": "sha256:4bf6e2b3d6a9fd17d38b8d9d536867e871cbb50c7dee51a9b7454cafcdf2b1af", "content": "include::{commons}@data-commons::page$value-expressions.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra/value-expressions.adoc", "title": "value-expressions", "heading": "value-expressions", "heading_level": 1, "file_order": 16, "section_index": 0, "content_hash": "4bf6e2b3d6a9fd17d38b8d9d536867e871cbb50c7dee51a9b7454cafcdf2b1af", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra/value-expressions.adoc"}}
{"id": "sha256:43cbd2549100ed63938f23081eadc0002eee8b9c544f083a434936d68ae31979", "content": "include::{commons}@data-commons::page$upgrade.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/commons/upgrade.adoc", "title": "upgrade", "heading": "upgrade", "heading_level": 1, "file_order": 17, "section_index": 0, "content_hash": "43cbd2549100ed63938f23081eadc0002eee8b9c544f083a434936d68ae31979", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/commons/upgrade.adoc"}}
{"id": "sha256:ba1405904aaa6e2349ad66b674e67a026aa319dafffb49414d028c62bf5eb0a3", "content": "include::{commons}@data-commons::page$kotlin/coroutines.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/kotlin/coroutines.adoc", "title": "coroutines", "heading": "coroutines", "heading_level": 1, "file_order": 18, "section_index": 0, "content_hash": "ba1405904aaa6e2349ad66b674e67a026aa319dafffb49414d028c62bf5eb0a3", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/kotlin/coroutines.adoc"}}
{"id": "sha256:cb7ece2703cef8290b7e73fa0bf898746d985df5d335b1cd63ba4a804b822b5d", "content": "include::{commons}@data-commons::page$kotlin/extensions.adoc[]\n\nTo retrieve a list of `SWCharacter` objects in Java, you would normally write the following:\n\n[source,java]\n----\nFlux<SWCharacter> characters = template.query(SWCharacter.class).inTable(\"star-wars\").all()\n----\n\nWith Kotlin and the Spring Data extensions, you can instead write the following:\n\n[source,kotlin]\n----\nval characters = template.query<SWCharacter>().inTable(\"star-wars\").all()\nval characters : Flux<SWCharacter> = template.query().inTable(\"star-wars\").all()\n----\n\nAs in Java, `characters` in Kotlin is strongly typed, but Kotlin's clever type inference allows for shorter syntax.\n\nSpring Data for Apache Cassandra provides the following extensions:\n\n* Reified generics support for `CassandraOperations` (including async and reactive variants), `CqlOperations` (including async and reactive variants)`FluentCassandraOperations`, `ReactiveFluentCassandraOperations`, `Criteria`, and `Query`.\n* xref:page$kotlin/coroutines.adoc[Coroutines] extensions for `ReactiveFluentCassandraOperations`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/kotlin/extensions.adoc", "title": "extensions", "heading": "extensions", "heading_level": 1, "file_order": 19, "section_index": 0, "content_hash": "cb7ece2703cef8290b7e73fa0bf898746d985df5d335b1cd63ba4a804b822b5d", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/kotlin/extensions.adoc"}}
{"id": "sha256:3890a18a8bd49eea65aed311989780538fe511ebfca5d4bdb8d8e0d6aff12dcf", "content": "include::{commons}@data-commons::page$kotlin/null-safety.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/kotlin/null-safety.adoc", "title": "null-safety", "heading": "null-safety", "heading_level": 1, "file_order": 20, "section_index": 0, "content_hash": "3890a18a8bd49eea65aed311989780538fe511ebfca5d4bdb8d8e0d6aff12dcf", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/kotlin/null-safety.adoc"}}
{"id": "sha256:ee72499ca213a700140c672a5fcd1bba0a99c05e613e5735b2529ccd54c12d17", "content": "include::{commons}@data-commons::page$kotlin/object-mapping.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/kotlin/object-mapping.adoc", "title": "object-mapping", "heading": "object-mapping", "heading_level": 1, "file_order": 21, "section_index": 0, "content_hash": "ee72499ca213a700140c672a5fcd1bba0a99c05e613e5735b2529ccd54c12d17", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/kotlin/object-mapping.adoc"}}
{"id": "sha256:1f6afc6d72333158d4bf66d1cf63e174d0e4613324cf34acbcec5e53ea8d8b24", "content": "include::{commons}@data-commons::page$kotlin/requirements.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/kotlin/requirements.adoc", "title": "requirements", "heading": "requirements", "heading_level": 1, "file_order": 22, "section_index": 0, "content_hash": "1f6afc6d72333158d4bf66d1cf63e174d0e4613324cf34acbcec5e53ea8d8b24", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/kotlin/requirements.adoc"}}
{"id": "sha256:b9ec4ea15e705b70b4b6118826dc77cc83132e3e9bcf9f55da900f8dcb97f109", "content": "[[cassandra.migration.1.x-to-2.x]]\n\nSpring Data for Apache Cassandra 2.0 introduces a set of breaking changes when upgrading from earlier versions:\n\n* Merged the `spring-cql` and `spring-data-cassandra` modules into a single module.\n* Separated asynchronous and synchronous operations in `CqlOperations` and `CassandraOperations`\ninto dedicated interfaces and templates.\n* Revised the `CqlTemplate` API to align with `JdbcTemplate`.\n* Removed the `CassandraOperations.selectBySimpleIds` method.\n* Used better names for `CassandraRepository`.\n* Removed SD Cassandra `ConsistencyLevel` and `RetryPolicy` types in favor of DataStax `ConsistencyLevel` and `RetryPolicy` types.\n* Refactored CQL specifications to value objects and configurators.\n* Refactored `QueryOptions` to be immutable objects.\n* Refactored `CassandraPersistentProperty` to single-column.\n\n[[deprecations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc", "title": "migration-guide-1.5-to-2.0", "heading": "migration-guide-1.5-to-2.0", "heading_level": 1, "file_order": 23, "section_index": 0, "content_hash": "b9ec4ea15e705b70b4b6118826dc77cc83132e3e9bcf9f55da900f8dcb97f109", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc"}}
{"id": "sha256:6b9c4a4c49416f7364cfdfae56404dfd746abdd362f1bc0874392f77d3b3ec96", "content": "* Deprecated `QueryOptionsBuilder.readTimeout(long, TimeUnit)` in favor of `QueryOptionsBuilder.readTimeout(Duration)`.\n* Deprecated `CustomConversions` in favor of `CassandraCustomConversions`.\n* Deprecated `BasicCassandraMappingContext` in favor of `CassandraMappingContext`.\n* Deprecated `o.s.d.c.core.cql.CachedPreparedStatementCreator` in favor of `o.s.d.c.core.cql.support.CachedPreparedStatementCreator`.\n* Deprecated `CqlTemplate.getSession()` in favor of `getSessionFactory()`.\n* Deprecated `CqlIdentifier.cqlId(…)` and `KeyspaceIdentifier.ksId(…)` in favor of the `.of(…)` methods.\n* Deprecated constructors of `QueryOptions` in favor of their builders.\n* Deprecated `TypedIdCassandraRepository` in favor of `CassandraRepository`\n\n[[merged-spring-cql-and-spring-data-cassandra-modules]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc", "title": "migration-guide-1.5-to-2.0", "heading": "Deprecations", "heading_level": 2, "file_order": 23, "section_index": 1, "content_hash": "6b9c4a4c49416f7364cfdfae56404dfd746abdd362f1bc0874392f77d3b3ec96", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc"}}
{"id": "sha256:5cf93bc895311190d86af7263b4e9a5f8e633258fc0426af0d017ce55f96c49b", "content": "Spring CQL and Spring Data Cassandra are now merged into a single module.\nThe standalone `spring-cql` module is no longer available.\nYou can find all types merged into `spring-data-cassandra`.\nThe following listing shows how to include `spring-data-cassandra` in your maven dependencies:\n\n====\n[source,xml,subs=\"verbatim,attributes\"]\n----\n<dependencies>\n\n <dependency>\n <groupId>org.springframework.data</groupId>\n <artifactId>spring-data-cassandra</artifactId>\n <version>{version}</version>\n </dependency>\n\n</dependencies>\n----\n====\n\nWith the merge, we merged all CQL packages into Spring Data Cassandra:\n\n* Moved `o.s.d.cql` into `o.s.d.cassandra.core.cql`.\n* Merged `o.s.d.cql` with `o.s.d.cassandra.config` and flattened the XML and Java subpackages.\n* Moved `CassandraExceptionTranslator` and `CqlExceptionTranslator` to `o.s.d.c.core.cql`.\n* Moved Cassandra exceptions `o.s.d.c.support.exception` to `o.s.d.cassandra`.\n* Moved `o.s.d.c.convert` to `o.s.d.c.core.convert` (affects converters).\n* Moved `o.s.d.c.mapping` to `o.s.d.c.core.mapping` (affects mapping annotations).\n* Moved `MapId` from `o.s.d.c.repository` to `o.s.d.c.core.mapping`.\n\n[[revised-cqltemplate/cassandratemplate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc", "title": "migration-guide-1.5-to-2.0", "heading": "Merged Spring CQL and Spring Data Cassandra Modules", "heading_level": 2, "file_order": 23, "section_index": 2, "content_hash": "5cf93bc895311190d86af7263b4e9a5f8e633258fc0426af0d017ce55f96c49b", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc"}}
{"id": "sha256:a877cbff22191ac94fe87f326f9785231dfd3a3c7450410f5cf160452e366ca6", "content": "We split `CqlTemplate` and `CassandraTemplate` in three ways:\n\n* `CassandraTemplate` is no longer a `CqlTemplate` but uses an instance that allows reuse and fine-grained control over fetch size, consistency levels, and retry policies.\nYou can obtain the `CqlOperations` through\n`CassandraTemplate.getCqlOperations()`.\nBecause of the change, dependency injection of `CqlTemplate` requires additional bean setup.\n* `CqlTemplate` now reflects basic CQL operations instead of mixing high-level and low-level API calls (such as `count(…)`\nversus `execute(…)`) and the reduced method set is aligned with Spring Frameworks's `JdbcTemplate` with its convenient callback interfaces.\n* Asynchronous methods are re-implemented on `AsyncCqlTemplate` and `AsyncCassandraTemplate` by using `ListenableFuture`.\nWe removed `Cancellable` and the various async callback listeners. `ListenableFuture` is a flexible approach and allows transition into a `CompletableFuture`.\n\n[[removed-cassandraoperations-selectbysimpleids]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc", "title": "migration-guide-1.5-to-2.0", "heading": "Revised `CqlTemplate`/`CassandraTemplate`", "heading_level": 2, "file_order": 23, "section_index": 3, "content_hash": "a877cbff22191ac94fe87f326f9785231dfd3a3c7450410f5cf160452e366ca6", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc"}}
{"id": "sha256:d38e9be5b344f6abba6229c8063a624bce97d55a2ef81132f1daf470279c5a6c", "content": "The method was removed because it did not support complex IDs.\nThe newly introduced query DSL allows mapped and complex id's for single column Id's, as the following example shows:\n\n====\n[source,java]\n----\ncassandraTemplate.select(Query.query(Criteria.where(\"id\").in(…)), Person.class)\n----\n====\n\n[[better-names-for-cassandrarepository]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc", "title": "migration-guide-1.5-to-2.0", "heading": "Removed `CassandraOperations.selectBySimpleIds()`", "heading_level": 2, "file_order": 23, "section_index": 4, "content_hash": "d38e9be5b344f6abba6229c8063a624bce97d55a2ef81132f1daf470279c5a6c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc"}}
{"id": "sha256:04a4fef4da6b825d0f3697c666bb413366a1c539d79a1ac694704ea150418c61", "content": "We renamed `CassandraRepository` and `TypedIdCassandraRepository` to align Spring Data Cassandra naming with other Spring Data modules:\n\n* Renamed `CassandraRepository` to `MapIdCassandraRepository`\n* Renamed `TypedIdCassandraRepository` to `CassandraRepository`\n* Introduced `TypedIdCassandraRepository`, extending `CassandraRepository` as a deprecated type to ease migration\n\n[[removed-sd-cassandra-consistencylevel-and-retrypolicy-types-in-favor-of-datastax-consistencylevel-and-retrypolicy-types]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc", "title": "migration-guide-1.5-to-2.0", "heading": "Better names for `CassandraRepository`", "heading_level": 2, "file_order": 23, "section_index": 5, "content_hash": "04a4fef4da6b825d0f3697c666bb413366a1c539d79a1ac694704ea150418c61", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc"}}
{"id": "sha256:d1e11b371ade64cc90c61d27271333eacb733feeb134808dca7efbc2a0891d85", "content": "Spring Data Cassandra `ConsistencyLevel` and `RetryPolicy` have been removed.\nPlease use the types provided by the DataStax driver.\n\nThe Spring Data Cassandra types restricted usage of available features provided in and allowed by the Cassandra native driver.\nAs a result, the Spring Data Cassandra's types required an update each time newer functionality was introduced by the driver.\n\n[[refactored-cql-specifications-to-value-objects-and-configurators]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc", "title": "migration-guide-1.5-to-2.0", "heading": "Removed SD Cassandra `ConsistencyLevel` and `RetryPolicy` types in favor of DataStax `ConsistencyLevel` and `RetryPolicy` types", "heading_level": 2, "file_order": 23, "section_index": 6, "content_hash": "d1e11b371ade64cc90c61d27271333eacb733feeb134808dca7efbc2a0891d85", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc"}}
{"id": "sha256:0a5e9ab3f1b3a1722fa52937b19a7cd23a4e041a7d3775f160bc71784f0f05ee", "content": "As much as possible, CQL specification types are now value types (such as `FieldSpecification`, `AlterColumnSpecification`), and objects are constructed by static factory methods.\nThis allows immutability for simple value objects.\nConfigurator objects (such as `AlterTableSpecification`) that operate on mandatory properties (such as a table name or keyspace name) are initially constructed through a a static factory method and allow further configuration until the desired state is created.\n\n[[refactored-queryoptions-to-be-immutable-objects]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc", "title": "migration-guide-1.5-to-2.0", "heading": "Refactored CQL Specifications to Value Objects and Configurators", "heading_level": 2, "file_order": 23, "section_index": 7, "content_hash": "0a5e9ab3f1b3a1722fa52937b19a7cd23a4e041a7d3775f160bc71784f0f05ee", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc"}}
{"id": "sha256:ac2174b72892c88578907ccb60689b9468213ee77b326d58fcdb51679ac96390", "content": "`QueryOptions` and `WriteOptions` are now immutable and can be created through builders.\nMethods accepting\n`QueryOptions` enforce non-null objects, which are available from static `empty()` factory methods.\nThe following example shows how to use `QueryOptions.builder()`:\n\n[source,java]\n----\nQueryOptions queryOptions = QueryOptions.builder()\n .consistencyLevel(ConsistencyLevel.ANY)\n .retryPolicy(FallthroughRetryPolicy.INSTANCE)\n .readTimeout(Duration.ofSeconds(10))\n .fetchSize(10)\n .tracing(true)\n .build();\n----\n\n[[refactored-cassandrapersistentproperty-to-single-column]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc", "title": "migration-guide-1.5-to-2.0", "heading": "Refactored `QueryOptions` to be Immutable Objects", "heading_level": 2, "file_order": 23, "section_index": 8, "content_hash": "ac2174b72892c88578907ccb60689b9468213ee77b326d58fcdb51679ac96390", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc"}}
{"id": "sha256:29bfe6fcb23f69ad2f3fcc96b736602f5fdf5032087b82347e237c872e98e4f0", "content": "This change affects You only if you operate directly on the mapping model.\n\n`CassandraPersistentProperty` allowed previously multiple column names to be bound for composite primary key use.\nColumns of a `CassandraPersistentProperty` are now reduced to a single column.\nResolved composite primary keys map to a class through `MappingContext.getRequiredPersistentEntity(…)`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc", "title": "migration-guide-1.5-to-2.0", "heading": "Refactored `CassandraPersistentProperty` to Single-column", "heading_level": 2, "file_order": 23, "section_index": 9, "content_hash": "29bfe6fcb23f69ad2f3fcc96b736602f5fdf5032087b82347e237c872e98e4f0", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-1.5-to-2.0.adoc"}}
{"id": "sha256:24b3442a9e12ced369520e143d731cec4c058e244c025e72e1f23570e8b2c617", "content": "[[cassandra.migration.2.x-to-3.x]]\n\nSpring Data for Apache Cassandra 3.0 introduces a set of breaking changes when upgrading from earlier versions.\n\n[[review-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "migration-guide-2.2-to-3.0", "heading_level": 1, "file_order": 24, "section_index": 0, "content_hash": "24b3442a9e12ced369520e143d731cec4c058e244c025e72e1f23570e8b2c617", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:0850350449e88288328b84c7536839752beab5eb5a0f24d8bf777bd004101df8", "content": "Upgrading to Spring Data Cassandra requires an upgrade to the DataStax Driver version 4. Upgrading to the new driver comes with transitive dependency changes, most notably, Google Guava is bundled and shaded by the driver.\nCheck out the https://docs.datastax.com/en/developer/java-driver/4.3/upgrade_guide/[DataStax Java Driver for Apache Cassandra 4 Upgrade Guide] for details on the Driver-related changes.\n\n[[adapt-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Review dependencies", "heading_level": 2, "file_order": 24, "section_index": 1, "content_hash": "0850350449e88288328b84c7536839752beab5eb5a0f24d8bf777bd004101df8", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:3b87271f750388c42c2444246f9c0bcc53d328453c2f4c9574e9d4bfb42652d5", "content": "DataStax Java Driver 4 merges `Cluster` and `Session` objects into a single `CqlSession` object, therefore, all `Cluster`-related API was removed.\nThe configuration was revised in large parts by removing most configuration items that were moved into `DriverConfigLoader` that is mostly file-based.\nThis means that `SocketOptions`, `AddressTranslator` and many more options are configured now through other means.\n\nIf you're using XML-based configuration, make sure to migrate all configuration files from the `cql` namespace (`http://www.springframework.org/schema/cql https://www.springframework.org/schema/cql/spring-cql.xsd`) to the `cassandra` namespace (`http://www.springframework.org/schema/data/cassandra https://www.springframework.org/schema/data/cassandra/spring-cassandra.xsd`).\n\nTo reflect the change in configuration builders, `ClusterBuilderConfigurer` was renamed to `SessionBuilderConfigurer` accepting now `CqlSessionBuilder` instead of the `Cluster.Builder`.\nMake sure to also provide the local data center in your configuration as it is required to properly configure load balancing.\n\n[[connectivity]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Adapt Configuration", "heading_level": 2, "file_order": 24, "section_index": 2, "content_hash": "3b87271f750388c42c2444246f9c0bcc53d328453c2f4c9574e9d4bfb42652d5", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:8008eba389077bd6decd5b569fa27509496f1c541eea5c8741963ccbd8e22b57", "content": "The configuration elements for `Cluster` (`cassandra:cluster`) and `Session` (`cassandra:session`) were merged into a single `CqlSession` (`cassandra:session`) element that configures both, the keyspace and endpoints.\n\nWith the upgrade, schema support was moved to a new namespace element: `cassandra:session-factory` that provides a `SessionFactory` bean.\n\n.Cluster, Session and Schema Configuration in version 2:\n====\n[source,xml]\n----\n<cassandra:cluster contact-points=\"localhost\" port=\"9042\">\n <cassandra:keyspace action=\"CREATE_DROP\" name=\"mykeyspace\" />\n</cassandra:cluster>\n\n<cassandra:session keyspace-name=\"mykeyspace\" schema-action=\"CREATE\">\n <cassandra:startup-cql>CREATE TABLE …</cassandra:startup-cql>\n</cassandra:session>\n----\n====\n\n.Session and Schema Configuration in version 3:\n====\n[source,xml]\n----\n<cassandra:session contact-points=\"localhost\" port=\"9042\" keyspace=\"mykeyspace\" local-datacenter=\"datacenter1\">\n <cassandra:keyspace action=\"CREATE_DROP\" name=\"mykeyspace\" />\n</cassandra:session>\n\n<cassandra:session-factory schema-action=\"CREATE\">\n <cassandra:script location=\"classpath:/schema.cql\"/>\n</cassandra:session-factory>\n----\n====\n\nNOTE: Spring Data Cassandra 3.0 no longer registers default Mapping Context, Context and Template API beans when using XML namespace configuration.\nThe defaulting should be applied on application or Spring Boot level.\n\n[[template-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Connectivity", "heading_level": 3, "file_order": 24, "section_index": 3, "content_hash": "8008eba389077bd6decd5b569fa27509496f1c541eea5c8741963ccbd8e22b57", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:75a046f8202ad8d5f84a201852badef9b9246ad65c31249c9df159d95293a2c1", "content": "Spring Data for Apache Cassandra encapsulates most of the changes that come with the driver upgrade as the Template API and repository support if your application mainly interacts with mapped entities or primitive Java types.\n\nWe generally recommend to create `CqlTemplate` and `CassandraTemplate` objects by using `SessionFactory` as the factory usage allows synchronization for schema creation and introduces a level of flexibility when working with multiple databases.\n\n.Template API configuration in version 2:\n====\n[source,xml]\n----\n<cql:template session-ref=\"…\" />\n\n<cassandra:template session-ref=\"…\" cassandra-converter-ref=\"…\"/>\n----\n====\n\n.Template API configuration in version 3:\n====\n[source,xml]\n----\n<cassandra:session-factory />\n\n<cassandra:cql-template session-factory-ref=\"…\" />\n\n<cassandra:template session-factory-ref=\"…\" cassandra-converter-ref=\"…\"/>\n----\n====\n\nYou will have to adapt your code in all places, where you use DataStax driver API directly.\nTypical cases include:\n\n* Implementations of `ResultSetExtractor`\n* Implementations of `RowCallbackHandler`\n* Implementations of `RowMapper`\n* Implementations of `PreparedStatementCreator` including async and reactive variants\n* Calls to `CqlTemplate.queryForResultSet(…)`\n* Calling methods that accept `Statement`\n\n[[changes-in-asynccqltemplate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Template API", "heading_level": 2, "file_order": 24, "section_index": 4, "content_hash": "75a046f8202ad8d5f84a201852badef9b9246ad65c31249c9df159d95293a2c1", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:c0a4eb72a6e14d4ff78f5743dd7c500af9048d4e63698d91d552f7604ba632f4", "content": "DataStax driver 4 has changed the result type of queries that are run asynchronously.\nTo reflect these changes, you need to adapt your code that provides:\n\n* Implementations of `AsyncSessionCallback`\n* Implementations of `AsyncPreparedStatementCreator`\n\nResult set extraction requires a new interface for DataStax' `AsyncResultSet`.\n`AsyncCqlTemplate` now uses `AsyncResultSetExtractor` in places where it used previously `ResultSetExtractor`.\nNote that `AsyncResultSetExtractor.extractData(…)` returns a `Future` instead of a scalar object so a migration of code comes with the possibility to use fully non-blocking code in the extractor.\n\n[[data-model-migrations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Changes in `AsyncCqlTemplate`", "heading_level": 3, "file_order": 24, "section_index": 5, "content_hash": "c0a4eb72a6e14d4ff78f5743dd7c500af9048d4e63698d91d552f7604ba632f4", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:b121e486bcb82433c9b16381cc5ecefd8b976706e07da51a5dd2a833907367ee", "content": "Your data model may require updates if you use the following features:\n\n* `@CassandraType`\n* `forceQuote` in `@Table`, `@Column`, `@PrimaryKeyColumn`, `@PrimaryKey` and `@UserDefinedType`\n* Properties using `java.lang.Date`\n* Properties using `UDTValue` or `TupleValue`\n\n[[cassandratype]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Data model migrations", "heading_level": 2, "file_order": 24, "section_index": 6, "content_hash": "b121e486bcb82433c9b16381cc5ecefd8b976706e07da51a5dd2a833907367ee", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:188698c8071349279f7e6059c94654f27afb6d9731b29b6f4c5433fdabf39dd9", "content": "DataStax driver 4 no longer ships with a `Name` enumeration to describe the Cassandra type.\nWe decided to re-introduce the enumeration with `CassandraType.Name`.\nMake sure to update your imports to use the newly introduced replacement type.\n\n[[force-quote]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "`@CassandraType`", "heading_level": 3, "file_order": 24, "section_index": 7, "content_hash": "188698c8071349279f7e6059c94654f27afb6d9731b29b6f4c5433fdabf39dd9", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:324a1d4cb7a0fa0338d5fb923a14082138a0c1c88d5bec301d1d11f863e7fdb4", "content": "This flag is now deprecated, and we recommend not to use it any longer.\nSpring Data for Apache Cassandra internally uses the driver's `CqlIdentifier` that ensures quoting where it's required.\n\n[[property-types]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Force Quote", "heading_level": 3, "file_order": 24, "section_index": 8, "content_hash": "324a1d4cb7a0fa0338d5fb923a14082138a0c1c88d5bec301d1d11f863e7fdb4", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:fd6b15ccf6eb8ecf1fcb2f9f8def4f7986e9e4ec5f43f7dcead778852ed6a48c", "content": "DataStax driver 4 no longer uses `java.lang.Date`.\nPlease upgrade your data model to use `java.time.LocalDateTime`.\nPlease also migrate raw UDT and tuple types to the new driver types `UdtValue` respective `TupleValue`.\n\n[[other-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Property Types", "heading_level": 3, "file_order": 24, "section_index": 9, "content_hash": "fd6b15ccf6eb8ecf1fcb2f9f8def4f7986e9e4ec5f43f7dcead778852ed6a48c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:08be1d880e8200061a911fbb1da91bc08208336b18387e9621e80572f0787f8c", "content": "* Driver's `ConsistencyLevel` constant class was removed and reintroduced as `DefaultConsistencyLevel`. `@Consistency` was adapted to `DefaultConsistencyLevel`.\n* `RetryPolicy` on `QueryOptions` and `…CqlTemplate` types was removed without replacement.\n* Drivers's `PagingState` type was removed.\nPaging state now uses `ByteBuffer`.\n* `SimpleUserTypeResolver` accepts `CqlSession` instead of `Cluster`.\n* `SimpleTupleTypeFactory` was migrated to `enum`. `SimpleTupleTypeFactory.INSTANCE` no longer requires a `Cluster`/`CqlSession` context.\n* Introduction of `StatementBuilder` to functionally build statements as the QueryBuilder API uses immutable statement types.\n* `Session` bean renamed from `session` to `cassandraSession` and `SessionFactory` bean renamed from `sessionFactory` to `cassandraSessionFactory`.\n* `ReactiveSession` bean renamed from `reactiveSession` to `reactiveCassandraSession` and `ReactiveSessionFactory` bean renamed from `reactiveSessionFactory` to `reactiveCassandraSessionFactory`.\n* `ReactiveSessionFactory.getSession()` now returns a `Mono<ReactiveSession>`.\nPreviously it returned just `ReactiveSession`.\n* Data type resolution was moved into `ColumnTypeResolver` so all `DataType`-related methods were moved from `CassandraPersistentEntity`/`CassandraPersistentProperty` into `ColumnTypeResolver` (affected methods are `MappingContext.getDataType(…)`, `CassandraPersistentProperty.getDataType()`, `CassandraPersistentEntity.getUserType()`, and `CassandraPersistentEntity.getTupleType()`).\n* Schema creation was moved from `MappingContext` to `SchemaFactory` (affected methods are `CassandraMappingContext.getCreateTableSpecificationFor(…)`, `CassandraMappingContext.getCreateIndexSpecificationsFor(…)`, and `CassandraMappingContext.getCreateUserTypeSpecificationFor(…)`).\n\n[[deprecations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Other changes", "heading_level": 2, "file_order": 24, "section_index": 10, "content_hash": "08be1d880e8200061a911fbb1da91bc08208336b18387e9621e80572f0787f8c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:373d1f002536da7c983e4fcd0708e96ddd941a65975f518f6ee82d1cd9ea5a67", "content": "* `CassandraCqlSessionFactoryBean`, use `CqlSessionFactoryBean` instead.\n* `KeyspaceIdentifier` and `CqlIdentifier`, use `com.datastax.oss.driver.api.core.CqlIdentifier` instead.\n* `CassandraSessionFactoryBean`, use `CqlSessionFactoryBean` instead.\n* `AbstractCqlTemplateConfiguration`, use `AbstractSessionConfiguration` instead.\n* `AbstractSessionConfiguration.getClusterName()`, use `AbstractSessionConfiguration.getSessionName()` instead.\n* `CodecRegistryTupleTypeFactory`, use `SimpleTupleTypeFactory` instead.\n* Spring Data's `CqlIdentifier`, use the driver `CqlIdentifier` instead.\n* `forceQuote` attributes as quoting is no longer required. `CqlIdentifier` properly escapes reserved keywords and takes care of case-sensitivity.\n* `fetchSize` on `QueryOptions` and `…CqlTemplate` types was deprecated, use `pageSize` instead\n* `CassandraMappingContext.setUserTypeResolver(…)`, `CassandraMappingContext.setCodecRegistry(…)`, and `CassandraMappingContext.setCustomConversions(…)`: Configure these properties on `CassandraConverter`.\n* `TupleTypeFactory` and `CassandraMappingContext.setTupleTypeFactory(…)`: `TupleTypeFactory` is no longer used as the Cassandra driver ships with a `DataTypes.tupleOf(…)` factory method.\n* Schema creation via `CqlSessionFactoryBean` (`cassandra:session`) is deprecated.\nKeyspace creation via `CqlSessionFactoryBean` (`cassandra:session`) is not affected.\n\n[[removals]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Deprecations", "heading_level": 2, "file_order": 24, "section_index": 11, "content_hash": "373d1f002536da7c983e4fcd0708e96ddd941a65975f518f6ee82d1cd9ea5a67", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:ff65e77ca7efaf14c8b750ff7d4926ee63acc37b7c46a6d66c055ebc6005397c", "content": "[[removal.configuration-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Removals", "heading_level": 2, "file_order": 24, "section_index": 12, "content_hash": "ff65e77ca7efaf14c8b750ff7d4926ee63acc37b7c46a6d66c055ebc6005397c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:e36d013963974b195377adbbf1b15496ff4bb9251754f3ea8c8baebd461e1410", "content": "* `PoolingOptionsFactoryBean`\n* `SocketOptionsFactoryBean`\n* `CassandraClusterFactoryBean`\n* `CassandraClusterParser`\n* `CassandraCqlClusterFactoryBean`\n* `CassandraCqlClusterParser`\n* `CassandraCqlSessionParser`\n* `AbstractClusterConfiguration`\n* `ClusterBuilderConfigurer` (use `SessionBuilderConfigurer` instead\n\n[[utilities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Configuration API", "heading_level": 3, "file_order": 24, "section_index": 13, "content_hash": "e36d013963974b195377adbbf1b15496ff4bb9251754f3ea8c8baebd461e1410", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:a772649541af06df0026bd09569514db7f8132cfc11239b6608ef0a227c06437", "content": "* `GuavaListenableFutureAdapter`\n* `QueryOptions` and `WriteOptions` constructor taking `ConsistencyLevel` and `RetryPolicy` arguments.\nUse the builder in conjunction of execution profiles as replacement.\n* `CassandraAccessor.setRetryPolicy(…)` and `ReactiveCqlTemplate.setRetryPolicy(…)` methods.\nUse execution profiles as replacement.\n\n[[removal.namespace-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Utilities", "heading_level": 3, "file_order": 24, "section_index": 14, "content_hash": "a772649541af06df0026bd09569514db7f8132cfc11239b6608ef0a227c06437", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:655e466f58479cf9a9c30c9d1bd24e9823a9782e934147712cd59c2e509efc9a", "content": "* `cql` namespace (`http://www.springframework.org/schema/cql`, use `http://www.springframework.org/schema/data/cassandra` instead)\n* `cassandra:cluster` (endpoint properties merged to `cassandra:session`)\n* `cql:template`, use `cassandra:cql-template` instead\n* Removed implicit bean registrations Mapping Context, Context and Template API beans.\nThese must be declared explicitly.\n\n[[additions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Namespace support", "heading_level": 3, "file_order": 24, "section_index": 15, "content_hash": "655e466f58479cf9a9c30c9d1bd24e9823a9782e934147712cd59c2e509efc9a", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:574ba94cbbc9f82e9ad9a14f66c1133d4e41106891fce7fe0a44bd6104ac550e", "content": "[[add.configuration-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Additions", "heading_level": 2, "file_order": 24, "section_index": 16, "content_hash": "574ba94cbbc9f82e9ad9a14f66c1133d4e41106891fce7fe0a44bd6104ac550e", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:6e76f047fc5fae6a69b0a7fb15e64c0a53513bc2a269f58398d095465468cda7", "content": "* `CqlSessionFactoryBean`\n* `InitializeKeyspaceBeanDefinitionParser`\n* `SessionFactoryFactoryBean` including schema creation via `KeyspacePopulator`\n* `KeyspacePopulator` and `SessionFactoryInitializer` to initialize a keyspace\n\n[[add.namespace-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Configuration API", "heading_level": 3, "file_order": 24, "section_index": 17, "content_hash": "6e76f047fc5fae6a69b0a7fb15e64c0a53513bc2a269f58398d095465468cda7", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:c15e6d9863b2aec0a590b2411777bcfa215954a992246b709cc9ec2b06a98966", "content": "* `cassandra:cluster` (endpoint properties merged to `cassandra:session`)\n* `cassandra:initialize-keyspace` namespace support\n* `cassandra:session-factory` with `cassandra:script` support", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc", "title": "migration-guide-2.2-to-3.0", "heading": "Namespace support", "heading_level": 3, "file_order": 24, "section_index": 18, "content_hash": "c15e6d9863b2aec0a590b2411777bcfa215954a992246b709cc9ec2b06a98966", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-2.2-to-3.0.adoc"}}
{"id": "sha256:5de43effda24481d5eb13bf576256fadf946485691758e37bd043a047ba0a156", "content": "[[cassandra.migration.3.x-to-4.x]]\n\nSpring Data for Apache Cassandra 4.0 introduces a set of breaking changes when upgrading from earlier versions.\n\n[[asynchronous-template-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-3.0-to-4.0.adoc", "title": "migration-guide-3.0-to-4.0", "heading": "migration-guide-3.0-to-4.0", "heading_level": 1, "file_order": 25, "section_index": 0, "content_hash": "5de43effda24481d5eb13bf576256fadf946485691758e37bd043a047ba0a156", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-3.0-to-4.0.adoc"}}
{"id": "sha256:c9bdfbed3fd6d1d1cd9d672bb197e6ea812d8fd10d5c451b75286127c5582680", "content": "With the deprecation of `ListenableFuture`, `AsyncCqlOperations` and `AsyncCassandraOperations` and their dependant classes were migrated to `CompletableFuture`.\nIf your application heavily depends on `ListenableFuture` and you cannot easily migrate to `CompletableFuture` then we suggest switching to the legacy `Async…Operations` types in the `legacy` subpackage.\nThat is `org.springframework.data.cassandra.core.cql.legacy` for `AsyncCqlOperations` and `org.springframework.data.cassandra.core.legacy` for `AsyncCassandraOperations`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-3.0-to-4.0.adoc", "title": "migration-guide-3.0-to-4.0", "heading": "Asynchronous Template API", "heading_level": 2, "file_order": 25, "section_index": 1, "content_hash": "c9bdfbed3fd6d1d1cd9d672bb197e6ea812d8fd10d5c451b75286127c5582680", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-3.0-to-4.0.adoc"}}
{"id": "sha256:d9280af91121318775eeef0b9e4f67c7b32dd70844991ac8d762d52d82a8a266", "content": "[[cassandra.migration.4.x-to-4.3]]\n\nSpring Data for Apache Cassandra 4.3 has migrated the `com.datastax.oss` groupId to `org.apache.cassandra`.\n\n[[driver-group-id]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-4.0-to-4.3.adoc", "title": "migration-guide-4.0-to-4.3", "heading": "migration-guide-4.0-to-4.3", "heading_level": 1, "file_order": 26, "section_index": 0, "content_hash": "d9280af91121318775eeef0b9e4f67c7b32dd70844991ac8d762d52d82a8a266", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-4.0-to-4.3.adoc"}}
{"id": "sha256:b7e3611d4cfc8fb65d56ce65e2a31528174afaafd32b2f0b05ca9593eae4cf92", "content": "With the migration of the Datastax driver into the Apache foundation, you need to update coordinates of the driver in your code. Consider the following example showing a potential previous state of a Maven project configuration:\n\n.`pom.xml` Example up to 4.2.x\n====\n[source,xml]\n----\n<dependency>\n\t<groupId>com.datastax.oss</groupId>\n\t<artifactId>java-driver-core</artifactId>\n</dependency>\n\n<dependency>\n\t<groupId>com.datastax.oss</groupId>\n\t<artifactId>java-driver-query-builder</artifactId>\n</dependency>\n----\n====\n\nWith upgrading the groupId from `com.datastax.oss` to `org.apache.cassandra` your project configuration would look like:\n\n.`pom.xml` Example since to 4.3.x\n====\n[source,xml]\n----\n<dependency>\n\t<groupId>org.apache.cassandra</groupId>\n\t<artifactId>java-driver-core</artifactId>\n</dependency>\n\n<dependency>\n\t<groupId>org.apache.cassandra</groupId>\n\t<artifactId>java-driver-query-builder</artifactId>\n</dependency>\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guide/migration-guide-4.0-to-4.3.adoc", "title": "migration-guide-4.0-to-4.3", "heading": "Migration of the Datastax driver into Apache", "heading_level": 2, "file_order": 26, "section_index": 1, "content_hash": "b7e3611d4cfc8fb65d56ce65e2a31528174afaafd32b2f0b05ca9593eae4cf92", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guide/migration-guide-4.0-to-4.3.adoc"}}
{"id": "sha256:b1399c1d198d809b07c02fefea94e06e8c4dff127edc8bb725070c3c63bac836", "content": "[[observability-conventions]]\n\nBelow you can find a list of all `GlobalObservabilityConventions` and `ObservabilityConventions` declared by this project.\n\n.ObservationConvention implementations\n|===\n|ObservationConvention Class Name | Applicable ObservationContext Class Name\n|`org.springframework.data.cassandra.observability.DefaultCassandraObservationConvention`|`n/a`\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/observability/conventions.adoc", "title": "conventions", "heading": "conventions", "heading_level": 1, "file_order": 27, "section_index": 0, "content_hash": "b1399c1d198d809b07c02fefea94e06e8c4dff127edc8bb725070c3c63bac836", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/observability/conventions.adoc"}}
{"id": "sha256:8155fbab1b2ba6b80b8bdbc6677ba6f24724a4bfc9a470d422ca07b83af3b11a", "content": "[[observability-metrics]]\n\nBelow you can find a list of all metrics declared by this project.\n\n[[observability-metrics-cassandra-query-observation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/observability/metrics.adoc", "title": "metrics", "heading": "metrics", "heading_level": 1, "file_order": 28, "section_index": 0, "content_hash": "8155fbab1b2ba6b80b8bdbc6677ba6f24724a4bfc9a470d422ca07b83af3b11a", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/observability/metrics.adoc"}}
{"id": "sha256:9ae24c8efca35dd61cfb5ab8efcda5e39447ca24a507e995e1ba3e281b6981de", "content": "____\nCreate an `io.micrometer.observation.Observation` for Cassandra-based queries.\n____\n\n**Metric name** `spring.data.cassandra.query`. **Type** `timer` and **base unit** `seconds`.\n\nFully qualified name of the enclosing class `org.springframework.data.cassandra.observability.CassandraObservation`.\n\n.Low cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`db.cassandra.coordinator.dc`|\n|`db.cassandra.coordinator.id`|\n|`db.name`|Name of the Cassandra keyspace.\n|`db.operation`|The database operation.\n|`db.system`|Database system.\n|`net.peer.name`|Name of the database host.\n|`net.peer.port`|Logical remote port number.\n|`net.sock.peer.addr`|Cassandra peer address.\n|`net.sock.peer.port`|Cassandra peer port.\n|`net.transport`|Network transport.\n|`spring.data.cassandra.methodName`|The method name\n|`spring.data.cassandra.sessionName`|Cassandra session\n|===\n\n.High cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`db.cassandra.consistency_level`|\n|`db.cassandra.idempotence`|\n|`db.cassandra.page_size`|\n|`db.statement`|A key-value containing Cassandra CQL.\n|`spring.data.cassandra.node[%s].error`|A tag containing error that occurred for the given node. (since the name contains `%s` the final value will be resolved at runtime)\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/observability/metrics.adoc", "title": "metrics", "heading": "Cassandra Query Observation", "heading_level": 2, "file_order": 28, "section_index": 1, "content_hash": "9ae24c8efca35dd61cfb5ab8efcda5e39447ca24a507e995e1ba3e281b6981de", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/observability/metrics.adoc"}}
{"id": "sha256:66b95fa4e6d5a9ddb2d89388312ce700db00f408fb2b166419a4f4b5de3c3242", "content": "[[observability-spans]]\n\nBelow you can find a list of all spans declared by this project.\n\n[[observability-spans-cassandra-query-observation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/observability/spans.adoc", "title": "spans", "heading": "spans", "heading_level": 1, "file_order": 29, "section_index": 0, "content_hash": "66b95fa4e6d5a9ddb2d89388312ce700db00f408fb2b166419a4f4b5de3c3242", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/observability/spans.adoc"}}
{"id": "sha256:747f0b881c06c59750943ee963c6ea56bc1f59267bedb3b4dc2a163eb2a2922e", "content": "> Create an `io.micrometer.observation.Observation` for Cassandra-based queries.\n\n**Span name** `spring.data.cassandra.query`.\n\nFully qualified name of the enclosing class `org.springframework.data.cassandra.observability.CassandraObservation`.\n\n.Tag Keys\n|===\n|Name | Description\n|`db.cassandra.consistency_level`|\n|`db.cassandra.coordinator.dc`|\n|`db.cassandra.coordinator.id`|\n|`db.cassandra.idempotence`|\n|`db.cassandra.page_size`|\n|`db.name`|Name of the Cassandra keyspace.\n|`db.operation`|The database operation.\n|`db.statement`|A key-value containing Cassandra CQL.\n|`db.system`|Database system.\n|`net.peer.name`|Name of the database host.\n|`net.peer.port`|Logical remote port number.\n|`net.sock.peer.addr`|Cassandra peer address.\n|`net.sock.peer.port`|Cassandra peer port.\n|`net.transport`|Network transport.\n|`spring.data.cassandra.methodName`|The method name\n|`spring.data.cassandra.node[%s].error`|A tag containing error that occurred for the given node. (since the name contains `%s` the final value will be resolved at runtime)\n|`spring.data.cassandra.sessionName`|Cassandra session\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/observability/spans.adoc", "title": "spans", "heading": "Cassandra Query Observation Span", "heading_level": 2, "file_order": 29, "section_index": 1, "content_hash": "747f0b881c06c59750943ee963c6ea56bc1f59267bedb3b4dc2a163eb2a2922e", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/observability/spans.adoc"}}
{"id": "sha256:70ba9673b60f6c261784c6a6442c66b25b7bb0b00ea4b7c88db243508136544e", "content": "include::{commons}@data-commons::page$repositories/core-concepts.adoc[]\n\n[[cassandra.entity-persistence.state-detection-strategies]]\ninclude::{commons}@data-commons::page$is-new-state-detection.adoc[leveloffset=+1]\n\nNOTE: Cassandra provides no means to generate identifiers upon inserting data.\nAs consequence, entities must be associated with identifier values.\nSpring Data defaults to identifier inspection to determine whether an entity is new.\nIf you want to use xref:cassandra/auditing.adoc[auditing] make sure to either use xref:cassandra/template.adoc#cassandra.template.optimistic-locking[Optimistic Locking] or implement `Persistable` for proper entity state detection.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/repositories/core-concepts.adoc", "title": "core-concepts", "heading": "core-concepts", "heading_level": 1, "file_order": 30, "section_index": 0, "content_hash": "70ba9673b60f6c261784c6a6442c66b25b7bb0b00ea4b7c88db243508136544e", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/repositories/core-concepts.adoc"}}
{"id": "sha256:81e019ce75dee61eea59094a236a3871f4c9af62f0fcd3a5c7a87af4b30030f9", "content": "include::{commons}@data-commons::page$repositories/core-domain-events.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/repositories/core-domain-events.adoc", "title": "core-domain-events", "heading": "core-domain-events", "heading_level": 1, "file_order": 31, "section_index": 0, "content_hash": "81e019ce75dee61eea59094a236a3871f4c9af62f0fcd3a5c7a87af4b30030f9", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/repositories/core-domain-events.adoc"}}
{"id": "sha256:64aa7d024c0d4411af2a39c72ec3db2ed9b849e1a6db2f27c6bebd29fb12b71b", "content": "include::{commons}@data-commons::page$repositories/core-extensions.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/repositories/core-extensions.adoc", "title": "core-extensions", "heading": "core-extensions", "heading_level": 1, "file_order": 32, "section_index": 0, "content_hash": "64aa7d024c0d4411af2a39c72ec3db2ed9b849e1a6db2f27c6bebd29fb12b71b", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/repositories/core-extensions.adoc"}}
{"id": "sha256:bac28174cb786cac49ffd811dcd631b892f0813fc0fc9743e93def55346e1e58", "content": "include::{commons}@data-commons::page$repositories/create-instances.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/repositories/create-instances.adoc", "title": "create-instances", "heading": "create-instances", "heading_level": 1, "file_order": 33, "section_index": 0, "content_hash": "bac28174cb786cac49ffd811dcd631b892f0813fc0fc9743e93def55346e1e58", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/repositories/create-instances.adoc"}}
{"id": "sha256:bcf8fe4d0728082fd278624d23223ff29157e4fb465061471d2d50f2f401bc0d", "content": "include::{commons}@data-commons::page$repositories/custom-implementations.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/repositories/custom-implementations.adoc", "title": "custom-implementations", "heading": "custom-implementations", "heading_level": 1, "file_order": 34, "section_index": 0, "content_hash": "bcf8fe4d0728082fd278624d23223ff29157e4fb465061471d2d50f2f401bc0d", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/repositories/custom-implementations.adoc"}}
{"id": "sha256:661a93bfb9c9780b8bb205b092562b371e697955026e3abea11cc0abb0a3fc20", "content": "include::{commons}@data-commons::page$repositories/definition.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/repositories/definition.adoc", "title": "definition", "heading": "definition", "heading_level": 1, "file_order": 35, "section_index": 0, "content_hash": "661a93bfb9c9780b8bb205b092562b371e697955026e3abea11cc0abb0a3fc20", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/repositories/definition.adoc"}}
{"id": "sha256:8ca895bfddcd8ee24e8f9d5197f423b2399d74f11d14249d9f906762f4b72806", "content": "include::{commons}@data-commons::page$repositories/null-handling.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/repositories/null-handling.adoc", "title": "null-handling", "heading": "null-handling", "heading_level": 1, "file_order": 36, "section_index": 0, "content_hash": "8ca895bfddcd8ee24e8f9d5197f423b2399d74f11d14249d9f906762f4b72806", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/repositories/null-handling.adoc"}}
{"id": "sha256:a1da94517961d8d68b031ddd4ca676bb4ea8bc88cedbf3099f530a1c8c53e509", "content": "[[cassandra.projections]]\n\ninclude::{commons}@data-commons::page$repositories/projections.adoc[leveloffset=+1]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/repositories/projections.adoc", "title": "projections", "heading": "projections", "heading_level": 1, "file_order": 37, "section_index": 0, "content_hash": "a1da94517961d8d68b031ddd4ca676bb4ea8bc88cedbf3099f530a1c8c53e509", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/repositories/projections.adoc"}}
{"id": "sha256:7e953260056fa458d00ccd6d3916965e33c635a0e5a9c1068e6d4c915b4642be", "content": "include::{commons}@data-commons::page$repositories/query-keywords-reference.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/repositories/query-keywords-reference.adoc", "title": "query-keywords-reference", "heading": "query-keywords-reference", "heading_level": 1, "file_order": 38, "section_index": 0, "content_hash": "7e953260056fa458d00ccd6d3916965e33c635a0e5a9c1068e6d4c915b4642be", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/repositories/query-keywords-reference.adoc"}}
{"id": "sha256:2931a4be98bc609c2eb349faa7f3ea7d07742930fa4e31487a2957e5874e0633", "content": "include::{commons}@data-commons::page$repositories/query-methods-details.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/repositories/query-methods-details.adoc", "title": "query-methods-details", "heading": "query-methods-details", "heading_level": 1, "file_order": 39, "section_index": 0, "content_hash": "2931a4be98bc609c2eb349faa7f3ea7d07742930fa4e31487a2957e5874e0633", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/repositories/query-methods-details.adoc"}}
{"id": "sha256:8586bea837d1b2b190fc36059384044b5c88fe73a8012f0e6782feb992f85865", "content": "include::{commons}@data-commons::page$repositories/query-return-types-reference.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/repositories/query-return-types-reference.adoc", "title": "query-return-types-reference", "heading": "query-return-types-reference", "heading_level": 1, "file_order": 40, "section_index": 0, "content_hash": "8586bea837d1b2b190fc36059384044b5c88fe73a8012f0e6782feb992f85865", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/repositories/query-return-types-reference.adoc"}}
{"id": "sha256:fdb3d70fce13be0d36993d30a95864be10d5cf26b7b839e82a5e331348412777", "content": "[[cassandra.core]]\n\nThis part of the reference documentation explains the core functionality offered by Spring Data for Apache Cassandra.\nSpring Data support for Apache Cassandra contains a wide range of features:\n\n* Spring configuration support with xref:cassandra/configuration.adoc[Java-based `@Configuration` classes or the XML namespace].\n* The xref:cassandra/cql-template.adoc[`CqlTemplate`, `AsyncCqlTemplate`, and `ReactiveCqlTemplate`] helper classes that increases productivity by properly handling common Cassandra data access operations.\n* The xref:cassandra/template.adoc[`CassandraTemplate`, `AsyncCassandraTemplate`, and `ReactiveCassandraTemplate`] helper classes that provide object mapping between CQL Tables and POJOs.\n* xref:cassandra/cql-template.adoc#exception-translation[Exception translation] into Spring's portable {springDocsUrl}/data-access/dao.html#dao-exceptions[Data Access Exception Hierarchy].\n* Feature rich xref:object-mapping.adoc[object mapping] integrated with _Spring's_ {springDocsUrl}/core/validation/convert.html[Conversion Service].\n* xref:object-mapping.adoc#mapping.usage-annotations[Annotation-based mapping] metadata that is extensible to support other metadata formats.\n* Java-based xref:cassandra/template.adoc#cassandra.template.query[query, criteria, and update DSLs].\n* Automatic implementation of xref:repositories.adoc[imperative and reactive `Repository` interfaces] including support for xref:repositories/custom-implementations.adoc[custom query methods].\n\n[[cassandra.abstractions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra.adoc", "title": "cassandra", "heading": "cassandra", "heading_level": 1, "file_order": 41, "section_index": 0, "content_hash": "fdb3d70fce13be0d36993d30a95864be10d5cf26b7b839e82a5e331348412777", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra.adoc"}}
{"id": "sha256:898b81069ab63ef05bd984825da29df7c9b0d23107f33c2d02ce58f00722a446", "content": "Spring Data for Apache Cassandra allows interaction on both the CQL and the entity level.\n\nThe value provided by the Spring Data for Apache Cassandra abstraction is perhaps best shown by the sequence of actions outlined in the table below.\nThe table shows which actions Spring take care of and which actions are the responsibility of you, the application developer.\n\n[[cassandra.modules.who-does-what]]\n.Spring Data for Apache Cassandra - who does what?\n|===\n| Action| Spring| You\n\n| Define connection parameters.\n|\n| X\n\n| Open the connection.\n| X\n|\n\n| Specify the CQL statement.\n|\n| X\n\n| Declare parameters and provide parameter values\n|\n| X\n\n| Prepare and run the statement.\n| X\n|\n\n| Set up the loop to iterate through the results (if any).\n| X\n|\n\n| Do the work for each iteration.\n|\n| X\n\n| Process any exception.\n| X\n|\n\n| Close the Session.\n| X\n|\n|===\n\nThe core CQL support takes care of all the low-level details that can make Cassandra and CQL such a tedious API with which to develop.\nUsing mapped entity objects allows schema generation, object mapping, and repository support.\n\n[[cassandra.choose-style]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra.adoc", "title": "cassandra", "heading": "Abstractions", "heading_level": 2, "file_order": 41, "section_index": 1, "content_hash": "898b81069ab63ef05bd984825da29df7c9b0d23107f33c2d02ce58f00722a446", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra.adoc"}}
{"id": "sha256:ea7b7e42fe5be2b119bb1b162cf6a24280acbd953dfd33c9bc91c7977159d33d", "content": "You can choose among several approaches to use as a basis for your Cassandra database access.\nSpring's support for Apache Cassandra comes in different flavors.\nOnce you start using one of these approaches, you can still mix and match to include a feature from a different approach.\nThe following approaches work well:\n\n* xref:cassandra/cql-template.adoc[`CqlTemplate`] and xref:cassandra/reactive-cassandra.adoc[`ReactiveCqlTemplate`] are the classic Spring CQL approach and the most popular.\nThis is the \"`lowest-level`\" approach.\nNote that components like `CassandraTemplate`\nuse `CqlTemplate` under-the-hood.\n* xref:cassandra/template.adoc[`CassandraTemplate`] wraps a `CqlTemplate` to provide query result-to-object mapping and the use of `SELECT`, `INSERT`, `UPDATE`, and `DELETE` methods instead of writing CQL statements.\nThis approach provides better documentation and ease of use.\n* xref:cassandra/reactive-cassandra.adoc[`ReactiveCassandraTemplate`] wraps a `ReactiveCqlTemplate` to provide query result-to-object mapping and the use of `SELECT`, `INSERT`, `UPDATE`, and `DELETE` methods instead of writing CQL statements.\nThis approach provides better documentation and ease of use.\n* Repository Abstraction lets you create repository declarations in your data access layer.\nThe goal of Spring Data's repository abstraction is to significantly reduce the amount of boilerplate code required to implement data access layers for various persistence stores.\n\nFor most data-oriented tasks, you can use the `[Reactive|Async]CassandraTemplate` or the `Repository` support, both of which use the rich object-mapping functionality. `[Reactive|Async]CqlTemplate` is commonly used to increment counters or perform ad-hoc CRUD operations. `[Reactive|Async]CqlTemplate` also provides callback methods that make it easy to get low-level API objects, such as `com.datastax.oss.driver.api.core.CqlSession`, which lets you communicate directly with Cassandra.\nSpring Data for Apache Cassandra uses consistent naming conventions on objects in various APIs to those found in the DataStax Java Driver so that they are familiar and so that you can map your existing knowledge onto the Spring APIs.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/cassandra.adoc", "title": "cassandra", "heading": "Choosing an Approach for Cassandra Database Access", "heading_level": 3, "file_order": 41, "section_index": 2, "content_hash": "ea7b7e42fe5be2b119bb1b162cf6a24280acbd953dfd33c9bc91c7977159d33d", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/cassandra.adoc"}}
{"id": "sha256:161a47fa7eee9a523aba22c4e3dbb4f157b74241a34c05b656f3b0d62a7b1538", "content": "[[spring-data-cassandra-reference-documentation]]\n\n_Spring Data for Apache Cassandra provides repository support for the Apache Cassandra database.\nIt eases development of applications with a consistent programming model that need to access Cassandra data sources._\n\n[horizontal]\nxref:cassandra.adoc[Cassandra] :: Apache Cassandra support and connectivity\nxref:repositories.adoc[Repositories] :: Apache Cassandra Repositories\nxref:observability.adoc[Observability] :: Observability Integration\nxref:kotlin.adoc[Kotlin] :: Kotlin support\nxref:migration-guides.adoc[Migration] :: Migration Guides\nhttps://github.com/spring-projects/spring-data-commons/wiki[Wiki] :: What's New, Upgrade Notes, Supported Versions, additional cross-version information.\n\nDavid Webb, Matthew Adams, John Blum, Mark Paluch, Jay Bryant\n\n(C) 2008-{copyright-year} VMware, Inc.\n\nCopies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 42, "section_index": 0, "content_hash": "161a47fa7eee9a523aba22c4e3dbb4f157b74241a34c05b656f3b0d62a7b1538", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:7ea6ef941532b479cba6ee5ca2f2f8dafc3373a9e29b7a6348efb81ee0c2cde3", "content": "include::{commons}@data-commons::page$kotlin.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/kotlin.adoc", "title": "kotlin", "heading": "kotlin", "heading_level": 1, "file_order": 43, "section_index": 0, "content_hash": "7ea6ef941532b479cba6ee5ca2f2f8dafc3373a9e29b7a6348efb81ee0c2cde3", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/kotlin.adoc"}}
{"id": "sha256:6269ed037f3359013c04f04edc9a65e07ded26c16ece5835e08849d1ccc45719", "content": "[[cassandra.migration]]\n\nThis section contains version-specific migration guides explaining how to upgrade between two versions.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/migration-guides.adoc", "title": "migration-guides", "heading": "migration-guides", "heading_level": 1, "file_order": 44, "section_index": 0, "content_hash": "6269ed037f3359013c04f04edc9a65e07ded26c16ece5835e08849d1ccc45719", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/migration-guides.adoc"}}
{"id": "sha256:fd44fce1417a04d167f81e3edd1f9f9b1efe51dd02644e15327533213d578430", "content": "[[mapping.chapter]]\n\nRich object mapping support is provided by the `MappingCassandraConverter`. `MappingCassandraConverter` has a rich metadata model that provides a complete feature set of functionality to map domain objects to CQL tables.\n\nThe mapping metadata model is populated by using annotations on your domain objects.\nHowever, the infrastructure is not limited to using annotations as the only source of metadata.\nThe `MappingCassandraConverter` also lets you map domain objects to tables without providing any additional metadata, by following a set of conventions.\n\nIn this chapter, we describe the features of the `MappingCassandraConverter`, how to use conventions for mapping domain objects to tables, and how to override those conventions with annotation-based mapping metadata.\n\ninclude::{commons}@data-commons::page$object-mapping.adoc[leveloffset=+1]\n\n[[mapping-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "object-mapping", "heading_level": 1, "file_order": 45, "section_index": 0, "content_hash": "fd44fce1417a04d167f81e3edd1f9f9b1efe51dd02644e15327533213d578430", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:9f4d0a84052640eb8232d0cff3ace0b2f9361beae6aef02066c99fd73aacf7b5", "content": "This section explains how types are mapped to and from an Apache Cassandra representation.\n\nSpring Data for Apache Cassandra supports several types that are provided by Apache Cassandra.\nIn addition to these types, Spring Data for Apache Cassandra provides a set of built-in converters to map additional types.\nYou can provide your own custom converters to adjust type conversion.\nSee \"`xref:cassandra/converters.adoc[Overriding Default Mapping with Custom Converters]`\" for further details.\nThe following table maps Spring Data types to Cassandra types:\n\n[cols=\"3,2\",options=\"header\"]\n.Type\n|===\n| Type\n| Cassandra types\n\n| `String`\n| `text` (default), `varchar`, `ascii`\n\n| `double`, `Double`\n| `double`\n\n| `float`, `Float`\n| `float`\n\n| `long`, `Long`\n| `bigint` (default), `counter`\n\n| `int`, `Integer`\n| `int`\n\n| `short`, `Short`\n| `smallint`\n\n| `byte`, `Byte`\n| `tinyint`\n\n| `boolean`, `Boolean`\n| `boolean`\n\n| `BigInteger`\n| `varint`\n\n| `BigDecimal`\n| `decimal`\n\n| `java.util.Date`\n| `timestamp`\n\n| `com.datastax.driver.core.LocalDate`\n| `date`\n\n| `InetAddress`\n| `inet`\n\n| `ByteBuffer`\n| `blob`\n\n| `java.util.UUID`\n| `uuid`\n\n| `TupleValue`, mapped Tuple Types\n| `tuple<…>`\n\n| `UDTValue`, mapped User-Defined Types\n| user type\n\n| `Vector`, `CqlVector`\n| `vector<…>`\n\n| `java.util.Map<K, V>`\n| `map`\n\n| `java.util.List<E>`\n| `list`\n\n| `java.util.Set<E>`\n| `set`\n\n| `Enum`\n| `text` (default), `bigint`, `varint`, `int`, `smallint`, `tinyint`\n\n| `LocalDate` +\n(Joda, Java 8, JSR310-BackPort)\n| `date`\n\n| `LocalTime`+\n(Joda, Java 8, JSR310-BackPort)\n| `time`\n\n| `LocalDateTime`, `LocalTime`, `Instant` +\n(Joda, Java 8, JSR310-BackPort)\n| `timestamp`\n\n| `ZoneId` (Java 8, JSR310-BackPort)\n| `text`\n\n|===\n\nEach supported type maps to a default\nhttps://docs.datastax.com/en/cql-oss/3.x/cql/cql_reference/cql_data_types_c.html[Cassandra data type].\nJava types can be mapped to other Cassandra types by using `@CassandraType`, as the following example shows:\n\n.Enum mapping to numeric types\n====\n[source,java]\n----\n@Table\npublic class EnumToOrdinalMapping {\n\n @PrimaryKey String id;\n\n @CassandraType(type = Name.INT) Condition asOrdinal;\n}\n\npublic enum Condition {\n NEW, USED\n}\n----\n====\n\n[[mapping-conventions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "Data Mapping and Type Conversion", "heading_level": 2, "file_order": 45, "section_index": 1, "content_hash": "9f4d0a84052640eb8232d0cff3ace0b2f9361beae6aef02066c99fd73aacf7b5", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:642717d89a1365d365c6cc22db04803ac69891142f8880303634d9814f552338", "content": "`MappingCassandraConverter` uses a few conventions for mapping domain objects to CQL tables when no additional mapping metadata is provided.\nThe conventions are:\n\n* The simple (short) Java class name is mapped to the table name by being changed to lower case.\nFor example, `com.bigbank.SavingsAccount` maps to a table named `savingsaccount`.\n* The converter uses any registered Spring `Converter` instances to override the default mapping of object properties to tables columns.\n* The properties of an object are used to convert to and from columns in the table.\n\nYou can adjust conventions by configuring a `NamingStrategy` on `CassandraMappingContext`.\nNaming strategy objects implement the convention by which a table, column or user-defined type is derived from an entity class and from an actual property.\n\nThe following example shows how to configure a `NamingStrategy`:\n\n.Configuring `NamingStrategy` on `CassandraMappingContext`\n====\n[source,java]\n----\ninclude::example$NamingStrategyConfiguration.java[tags=method]\n----\n====\n\n[[mapping-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "Convention-based Mapping", "heading_level": 2, "file_order": 45, "section_index": 2, "content_hash": "642717d89a1365d365c6cc22db04803ac69891142f8880303634d9814f552338", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:7e410881e4b4f1f0345107c9cbc98e8731561abd30974c06e321c0b53dc3091c", "content": "Unless explicitly configured, an instance of `MappingCassandraConverter` is created by default when creating a `CassandraTemplate`.\nYou can create your own instance of the `MappingCassandraConverter` to tell it where to scan the classpath at startup for your domain classes to extract metadata and construct indexes.\n\nAlso, by creating your own instance, you can register Spring `Converter` instances to use for mapping specific classes to and from the database.\nThe following example configuration class sets up Cassandra mapping support:\n\n.@Configuration class to configure Cassandra mapping support\n====\n[source,java]\n----\ninclude::example$SchemaConfiguration.java[tags=class]\n----\n====\n\n`AbstractCassandraConfiguration` requires you to implement methods that define a keyspace.\n`AbstractCassandraConfiguration` also has a method named `getEntityBasePackages(…)`.\nYou can override it to tell the converter where to scan for classes annotated with the `@Table` annotation.\n\nYou can add additional converters to the `MappingCassandraConverter` by overriding the `customConversions` method.\n\nNOTE: `AbstractCassandraConfiguration` creates a `CassandraTemplate` instance and registers it with the container under the name of `cassandraTemplate`.\n\n[[mapping.usage]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "Mapping Configuration", "heading_level": 3, "file_order": 45, "section_index": 3, "content_hash": "7e410881e4b4f1f0345107c9cbc98e8731561abd30974c06e321c0b53dc3091c", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:4c3447d3675dc56a86bf89d943e76e8ed9ce83a615a6fe33c31d56ef1060ed72", "content": "To take full advantage of the object mapping functionality inside the Spring Data for Apache Cassandra support, you should annotate your mapped domain objects with the `@Table` annotation.\nDoing so lets the classpath scanner find and pre-process your domain objects to extract the necessary metadata.\nOnly annotated entities are used to perform schema actions.\nIn the worst case, a `SchemaAction.RECREATE_DROP_UNUSED` operation drops your tables, and you lose your data.\nNote that tables are accessed from the session keyspace.\nYou can however specify a custom keyspace to use a table/UDT from a specific keyspace.\n\nThe following example shows a simple domain object:\n\n.Example domain object\n====\n[source,java]\n----\npackage com.mycompany.domain;\n\n@Table\npublic class Person {\n\n @Id\n private String id;\n\n @CassandraType(type = Name.VARINT)\n private Integer ssn;\n\n private String firstName;\n\n private String lastName;\n}\n----\n====\n\nIMPORTANT: The `@Id` annotation tells the mapper which property you want to use for the Cassandra primary key.\nComposite primary keys can require a slightly different data model.\n\n[[cassandra-template.id-handling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "Metadata-based Mapping", "heading_level": 2, "file_order": 45, "section_index": 4, "content_hash": "4c3447d3675dc56a86bf89d943e76e8ed9ce83a615a6fe33c31d56ef1060ed72", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:1cea10791b01d6a5607b989b44a77528ce65943279f7fa8e699ed13c1359e140", "content": "Cassandra requires at least one partition key field for a CQL table.\nA table can additionally declare one or more clustering key fields.\nWhen your CQL table has a composite primary key, you must create a `@PrimaryKeyClass` to define the structure of the composite primary key.\nIn this context, \"`composite primary key`\" means one or more partition columns optionally combined with one or more clustering columns.\n\nPrimary keys can make use of any singular simple Cassandra type or mapped user-defined Type.\nCollection-typed primary keys are not supported.\n\n[[cassandra-template.id-handling.simple]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "Working with Primary Keys", "heading_level": 3, "file_order": 45, "section_index": 5, "content_hash": "1cea10791b01d6a5607b989b44a77528ce65943279f7fa8e699ed13c1359e140", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:780cd9653a57c6839f6f9aa220482c7e117efd428d2198d327bfdf599c5383cf", "content": "A simple primary key consists of one partition key field within an entity class.\nSince it is one field only, we safely can assume it is a partition key.\nThe following listing shows a CQL table defined in Cassandra with a primary key of `user_id`:\n\n.CQL Table defined in Cassandra\n====\n[source]\n----\nCREATE TABLE user (\n user_id text,\n firstname text,\n lastname text,\n PRIMARY KEY (user_id))\n;\n----\n====\n\nThe following example shows a Java class annotated such that it corresponds to the Cassandra defined in the previous listing:\n\n.Annotated Entity\n====\n[source,java]\n----\n@Table(value = \"login_event\")\npublic class LoginEvent {\n\n @PrimaryKey(\"user_id\")\n private String userId;\n\n private String firstname;\n private String lastname;\n\n // getters and setters omitted\n\n}\n----\n====\n\n[[cassandra-template.id-handling.composite]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "Simple Primary Keys", "heading_level": 4, "file_order": 45, "section_index": 6, "content_hash": "780cd9653a57c6839f6f9aa220482c7e117efd428d2198d327bfdf599c5383cf", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:d8f7396c2bda0b6e92b2ebb782ab3cf8df045e0ec239ecd5eb7b41c9a3dcc03a", "content": "Composite primary keys (or compound keys) consist of more than one primary key field.\nThat said, a composite primary key can consist of multiple partition keys, a partition key and a clustering key, or a multitude of primary key fields.\n\nComposite keys can be represented in two ways with Spring Data for Apache Cassandra:\n\n* Embedded in an entity.\n* By using `@PrimaryKeyClass`.\n\nThe simplest form of a composite key is a key with one partition key and one clustering key.\n\nThe following example shows a CQL statement to represent the table and its composite key:\n\n.CQL Table with a Composite Primary Key\n====\n[source]\n----\nCREATE TABLE login_event(\n person_id text,\n event_code int,\n event_time timestamp,\n ip_address text,\n PRIMARY KEY (person_id, event_code, event_time))\n WITH CLUSTERING ORDER BY (event_time DESC)\n;\n----\n====\n\n[[cassandra-template.id-handling.flat]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "Composite Keys", "heading_level": 4, "file_order": 45, "section_index": 7, "content_hash": "d8f7396c2bda0b6e92b2ebb782ab3cf8df045e0ec239ecd5eb7b41c9a3dcc03a", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:11ae4d846e12528807f28ec008ee3b3149e70828c361717c3e423e5ecfe3971d", "content": "Flat composite primary keys are embedded inside the entity as flat fields.\nPrimary key fields are annotated with\n`@PrimaryKeyColumn`.\nSelection requires either a query to contain predicates for the individual fields or the use of `MapId`.\nThe following example shows a class with a flat composite primary key:\n\n.Using a flat composite primary key\n====\n[source,java]\n----\ninclude::example$LoginEvent.java[tags=class]\n----\n====\n\n[[cassandra-template.id-handling.pk-class]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "Flat Composite Primary Keys", "heading_level": 4, "file_order": 45, "section_index": 8, "content_hash": "11ae4d846e12528807f28ec008ee3b3149e70828c361717c3e423e5ecfe3971d", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:be842d8908a86fa422e33b5c78b8b85460e8a5ac45bfd31e28385353e7827612", "content": "A primary key class is a composite primary key class that is mapped to multiple fields or properties of the entity.\nIt is annotated with `@PrimaryKeyClass` and should define `equals` and `hashCode` methods.\nThe semantics of value equality for these methods should be consistent with the database equality for the database types to which the key is mapped.\nPrimary key classes can be used with repositories (as the `Id` type) and to represent an entity's identity in a single complex object.\nThe following example shows a composite primary key class:\n\n.Composite primary key class\n====\n[source,java]\n----\ninclude::example$LoginEventKey.java[tags=class]\n----\n====\n\nThe following example shows how to use a composite primary key:\n\n.Using a composite primary key\n====\n[source,java]\n----\n@Table(value = \"login_event\")\npublic class LoginEvent {\n\n @PrimaryKey\n private LoginEventKey key;\n\n @Column(\"ip_address\")\n private String ipAddress;\n\n // getters and setters omitted\n}\n----\n====\n\n[[mapping.embedded-entities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "Primary Key Class", "heading_level": 4, "file_order": 45, "section_index": 9, "content_hash": "be842d8908a86fa422e33b5c78b8b85460e8a5ac45bfd31e28385353e7827612", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:09a31f565830c71a8dacc926274e4e10dcde1394d9b6472e9c299c07d7379474", "content": "Embedded entities are used to design value objects in your Java domain model whose properties are flattened out into the table.\nIn the following example you see, that `User.name` is annotated with `@Embedded`.\nThe consequence of this is that all properties of `UserName` are folded into the `user` table which consists of 3 columns (`user_id`, `firstname`, `lastname`).\n\n[NOTE]\n====\nEmbedded entities may only contain simple property types.\nIt is not possible to nest an embedded entity into another embedded one.\n====\n\nHowever, if the `firstname` and `lastname` column values are actually `null` within the result set, the entire property `name` will be set to `null` according to the `onEmpty` of `@Embedded`, which ``null``s objects when all nested properties are `null`. +\nOpposite to this behavior `USE_EMPTY` tries to create a new instance using either a default constructor or one that accepts nullable parameter values from the result set.\n\n.Sample Code of embedding objects\n====\n[source,java]\n----\npublic class User {\n\n @PrimaryKey(\"user_id\")\n private String userId;\n\n @Embedded(onEmpty = USE_NULL) <1>\n UserName name;\n}\n\npublic class UserName {\n private String firstname;\n private String lastname;\n}\n----\n<1> Property is `null` if `firstname` and `lastname` are `null`.\nUse `onEmpty=USE_EMPTY` to instantiate `UserName` with a potential `null` value for its properties.\n====\n\nYou can embed a value object multiple times in an entity by using the optional `prefix` element of the `@Embedded` annotation.\nThis element represents a prefix and is prepended to each column name in the embedded object.\nNote that properties will overwrite each other if multiple properties render to the same column name.\n\n[TIP]\n====\nMake use of the shortcuts `@Embedded.Nullable` and `@Embedded.Empty` for `@Embedded(onEmpty = USE_NULL)` and `@Embedded(onEmpty = USE_EMPTY)` to reduce verbosity and simultaneously set JSR-305 `@javax.annotation.Nonnull` accordingly.\n\n[source,java]\n----\npublic class MyEntity {\n\n @Id\n Integer id;\n\n @Embedded.Nullable <1>\n EmbeddedEntity embeddedEntity;\n}\n----\n<1> Shortcut for `@Embedded(onEmpty = USE_NULL)`.\n====\n\n[[mapping.usage-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "Embedded Entity Support", "heading_level": 3, "file_order": 45, "section_index": 10, "content_hash": "09a31f565830c71a8dacc926274e4e10dcde1394d9b6472e9c299c07d7379474", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:1cd5bd1a5ab2eeb68d2a02e006b39e32b7358a1038e37bf988d566f3d7b3ac6d", "content": "The `MappingCassandraConverter` can use metadata to drive the mapping of objects to rows in a Cassandra table.\nAn overview of the annotations follows:\n\n* `@Id`: Applied at the field or property level to mark the property used for identity purposes.\n* `@Table`: Applied at the class level to indicate that this class is a candidate for mapping to the database.\nYou can specify the name of the table where the object is stored.\nWhen specifying the keyspace, the table name will be prefixed with the keyspace for all DML and DDL operations.\n* `@PrimaryKey`: Similar to `@Id` but lets you specify the column name.\n* `@PrimaryKeyColumn`: Cassandra-specific annotation for primary key columns that lets you specify primary key column attributes, such as for clustered or partitioned.\nCan be used on single and multiple attributes to indicate either a single or a composite (compound) primary key.\nIf used on a property within the entity, make sure to apply the `@Id` annotation as well.\n* `@PrimaryKeyClass`: Applied at the class level to indicate that this class is a compound primary key class.\nMust be referenced with `@PrimaryKey` in the entity class.\n* `@Transient`: By default, all private fields are mapped to the row.\nThis annotation excludes the field where it is applied from being stored in the database.\nTransient properties cannot be used within a persistence constructor as the converter cannot materialize a value for the constructor argument.\n* `@PersistenceConstructor`: Marks a given constructor -- even a package protected one -- to use when instantiating the object from the database.\nConstructor arguments are mapped by name to the key values in the retrieved row.\n* `@Value`: This annotation is part of the Spring Framework . Within the mapping framework it can be applied to constructor arguments.\nThis lets you use a Spring Expression Language statement to transform a key's value retrieved in the database before it is used to construct a domain object.\nIn order to reference a property of a given `Row`/`UdtValue`/`TupleValue` one has to use expressions like: `@Value(\"#root.getString(0)\")` where `root` refers to the root of the given document.\n* `@ReadOnlyProperty`: Applies at the field level to mark a property as read-only.\nEntity-bound insert and update statements do not include this property.\n* `@Column`: Applied at the field level.\nDescribes the column name as it is represented in the Cassandra table, thus letting the name differ from the field name of the class.\nCan be used on constructor arguments to customize the column name during constructor creation.\n* `@Embedded`: Applied at the field level.\nEnables embedded object usage for types mapped to a table or a user-defined type.\nProperties of the embedded object are flattened into the structure of its parent.\n* `@Indexed`: Applied at the field level.\nDescribes the index to be created at session initialization.\n* `@SASI`: Applied at the field level.\nAllows SASI index creation during session initialization.\n* `@SaiIndexed`: Applied at the field level.\nAllows to define SAI (storage-attached indexes) index creation during session initialization.\n* `@CassandraType`: Applied at the field level to specify a Cassandra data type.\nTypes are derived from the property declaration by default.\n* `@VectorType`: Applied at the field level to specify the Cassandra vector type.\nThis annotation is required when using schema generation.\n* `@Frozen`: Applied at the field level to class-types and parametrized types.\nDeclares a frozen UDT column or frozen collection like `List<@Frozen UserDefinedPersonType>`.\n* `@UserDefinedType`: Applied at the type level to specify a Cassandra User-defined Data Type (UDT).\nWhen specifying the keyspace, the UDT name will be prefixed with the keyspace for all DML and DDL operations.\nTypes are derived from the declaration by default.\n* `@Tuple`: Applied at the type level to use a type as a mapped tuple.\n* `@Element`: Applied at the field level to specify element or field ordinals within a mapped tuple.\nTypes are derived from the property declaration by default.\nCan be used on constructor arguments to customize tuple element ordinals during constructor creation.\n* `@Version`: Applied at field level is used for optimistic locking and checked for modification on save operations.\nThe initial value is `zero` which is bumped automatically on every update.\n\nThe mapping metadata infrastructure is defined in the separate, spring-data-commons project that is both technology- and data store-agnostic.\n\nThe following example shows a more complex mapping:\n\n.Mapped `Person` class\n====\n[source,java]\n----\ninclude::example$mapping/Person.java[tags=class]\n----\n====\n\nThe following example shows how to map a UDT `Address`:\n\n.Mapped User-Defined Type `Address`\n====\n[source,java]\n----\ninclude::example$mapping/Address.java[tags=class]\n----\n====\n\nNOTE: Working with User-Defined Types requires a `UserTypeResolver` that is configured with the mapping context.\nSee the xref:cassandra/configuration.adoc[configuration chapter] for how to configure a `UserTypeResolver`.\n\nThe following example shows how map a tuple:\n\n.Mapped Tuple\n====\n[source,java]\n----\ninclude::example$mapping/Coordinates.java[tags=class]\n----\n====\n\n[[mapping.index-creation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "Mapping Annotation Overview", "heading_level": 3, "file_order": 45, "section_index": 11, "content_hash": "1cd5bd1a5ab2eeb68d2a02e006b39e32b7358a1038e37bf988d566f3d7b3ac6d", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:ae7028bd5da2e13908d37afe6a89d8fa9ca637a75c6a3200555f3ed3d70736cd", "content": "You can annotate particular entity properties with `@Indexed`, `@SaiIndexed`, or `@SASI` if you wish to create secondary indexes on application startup.\nIndex creation creates simple secondary indexes for scalar types, user-defined types, and collection types.\n\nYou can configure a SASI Index to apply an analyzer, such as `StandardAnalyzer` or `NonTokenizingAnalyzer` (by using\n`@StandardAnalyzed` and `@NonTokenizingAnalyzed`, respectively).\n\nMap types distinguish between `ENTRY`, `KEYS`, and `VALUES` indexes.\nIndex creation derives the index type from the annotated element.\nThe following example shows a number of ways to create an index:\n\n.Variants of map indexing\n====\n[source,java]\n----\ninclude::example$mapping/PersonWithIndexes.java[tags=class]\n----\n====\n\n[NOTE]\n====\nThe `@Indexed` annotation can be applied to single properties of embedded entities or along with the `@Embedded` annotation, in which case all properties of the embedded are indexed.\n====\n\nCAUTION: Index creation on session initialization may have a severe performance impact on application startup.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/object-mapping.adoc", "title": "object-mapping", "heading": "Index Creation", "heading_level": 4, "file_order": 45, "section_index": 12, "content_hash": "ae7028bd5da2e13908d37afe6a89d8fa9ca637a75c6a3200555f3ed3d70736cd", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/object-mapping.adoc"}}
{"id": "sha256:5316a90ac66817bc91f93abe9d093b36c09c8e596f653d0151aff7c2f1dd5f4f", "content": "[[cassandra.observability]]\n\nGetting insights from an application component about its operations, timing and relation to application code is crucial to understand latency.\nSpring Data Cassandra ships with a Micrometer instrumentation through the Cassandra driver to collect observations during Cassandra interaction.\nOnce the integration is set up, Micrometer will create meters and spans (for distributed tracing) for each Cassandra statement.\n\nTo enable the instrumentation, apply the following configuration to your application:\n\n====\n[source,java]\n----\n@Configuration\nclass ObservabilityConfiguration {\n\n @Bean\n public ObservableCqlSessionFactoryBean observableCqlSession(CqlSessionBuilder builder,\n ObservationRegistry registry) {\n return new ObservableCqlSessionFactoryBean(builder, registry); // <1>\n }\n\n @Bean\n public ObservableReactiveSessionFactoryBean observableReactiveSession(CqlSession session,\n ObservationRegistry registry) {\n return new ObservableReactiveSessionFactoryBean(session, registry); // <2>\n }\n}\n----\n\n<1> Wraps the CQL session object to observe Cassandra statement execution.\nAlso, registers `ObservationRequestTracker.INSTANCE` with the `CqlSessionBuilder`.\n<2> Wraps a CQL session object to observe reactive Cassandra statement execution.\n====\n\nBoth, javadoc:org.springframework.data.cassandra.observability.ObservableCqlSessionFactoryBean[] and javadoc:org.springframework.data.cassandra.observability.ObservableReactiveSessionFactoryBean[] support configuration of javadoc:org.springframework.data.cassandra.observability.CassandraObservationConvention[].\n\nSee also https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/database/#cassandra[OpenTelemetry Semantic Conventions] for further reference.\n\ninclude::observability/conventions.adoc[leveloffset=+1]\n\ninclude::observability/metrics.adoc[leveloffset=+1]\n\ninclude::observability/spans.adoc[leveloffset=+1]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/observability.adoc", "title": "observability", "heading": "observability", "heading_level": 1, "file_order": 46, "section_index": 0, "content_hash": "5316a90ac66817bc91f93abe9d093b36c09c8e596f653d0151aff7c2f1dd5f4f", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/observability.adoc"}}
{"id": "sha256:5a818c44b3cd630d4505642ed167d83a9dfb9b3671cac0b301d23124a37bb8ab", "content": "include::{commons}@data-commons::page$property-paths.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/property-paths.adoc", "title": "property-paths", "heading": "property-paths", "heading_level": 1, "file_order": 47, "section_index": 0, "content_hash": "5a818c44b3cd630d4505642ed167d83a9dfb9b3671cac0b301d23124a37bb8ab", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/property-paths.adoc"}}
{"id": "sha256:de5beb8e712a2d3df3b2ae1b96ee3030bb8b5a733d7727d32b5ba6659b3d73f9", "content": "[[cassandra.repositories]]\n\nThis chapter explains the basic foundations of Spring Data repositories and Cassandra specifics.\nBefore continuing to the Cassandra specifics, make sure you have a sound understanding of the basic concepts.\n\nThe goal of the Spring Data repository abstraction is to significantly reduce the amount of boilerplate code required to implement data access layers for various persistence stores.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-cassandra", "path": "antora/modules/ROOT/pages/repositories.adoc", "title": "repositories", "heading": "repositories", "heading_level": 1, "file_order": 48, "section_index": 0, "content_hash": "de5beb8e712a2d3df3b2ae1b96ee3030bb8b5a733d7727d32b5ba6659b3d73f9", "source_url": "https://github.com/spring-projects/spring-data-cassandra/blob/3aa42ea34d9c20485ebd280a955863fe71bfa587/src/main/antora/modules/ROOT/pages/repositories.adoc"}}
