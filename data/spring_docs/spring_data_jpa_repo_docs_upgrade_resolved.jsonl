{"id": "sha256:43cbd2549100ed63938f23081eadc0002eee8b9c544f083a434936d68ae31979", "content": "include::{commons}@data-commons::page$upgrade.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/commons/upgrade.adoc", "title": "upgrade", "heading": "upgrade", "heading_level": 1, "file_order": 0, "section_index": 0, "content_hash": "43cbd2549100ed63938f23081eadc0002eee8b9c544f083a434936d68ae31979", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/commons/upgrade.adoc"}}
{"id": "sha256:feb95a9ae3ed15b7e44e5518cb6726f869a45577ea1c5bb145a36b5d301859f5", "content": "[[envers.configuration]]\n\nAs a starting point for using Spring Data Envers, you need a project with Spring Data JPA on the classpath and an additional `spring-data-envers` dependency:\n\n====\n[source,xml,subs=\"+attributes\"]\n----\n<dependencies>\n\n <!-- other dependency elements omitted -->\n\n <dependency>\n <groupId>org.springframework.data</groupId>\n <artifactId>spring-data-envers</artifactId>\n <version>{version}</version>\n </dependency>\n\n</dependencies>\n----\n====\n\nThis also brings `hibernate-envers` into the project as a transient dependency.\n\nTo enable Spring Data Envers and Spring Data JPA, we need to configure two beans and a special `repositoryFactoryBeanClass`:\n\n====\n[source,java]\n----\n@Configuration\n@EnableEnversRepositories\n@EnableTransactionManagement\npublic class EnversDemoConfiguration {\n\n\t@Bean\n\tpublic DataSource dataSource() {\n\n EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();\n return builder.setType(EmbeddedDatabaseType.HSQL).build();\n\t}\n\n\t@Bean\n\tpublic LocalContainerEntityManagerFactoryBean entityManagerFactory() {\n\n HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();\n vendorAdapter.setGenerateDdl(true);\n\n LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();\n factory.setJpaVendorAdapter(vendorAdapter);\n factory.setPackagesToScan(\"example.springdata.jpa.envers\");\n factory.setDataSource(dataSource());\n return factory;\n\t}\n\n\t@Bean\n\tpublic PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {\n\n JpaTransactionManager txManager = new JpaTransactionManager();\n txManager.setEntityManagerFactory(entityManagerFactory);\n return txManager;\n\t}\n}\n----\n====\n\nTo actually use Spring Data Envers, make one or more repositories into a {spring-data-commons-javadoc-base}/org/springframework/data/repository/history/RevisionRepository.html[`RevisionRepository`] by adding it as an extended interface:\n\n====\n[source,java]\n----\ninterface PersonRepository\n extends CrudRepository<Person, Long>,\n RevisionRepository<Person, Long, Long> // <1>\n{}\n----\n<1> The first type parameter (`Person`) denotes the entity type, the second (`Long`) denotes the type of the id property, and the last one (`Long`) is the type of the revision number.\nFor Envers in default configuration, the revision number parameter should be `Integer` or `Long`.\n====\n\nThe entity for that repository must be an entity with Envers auditing enabled (that is, it must have an `@Audited` annotation):\n\n====\n[source,java]\n----\n@Entity\n@Audited\nclass Person {\n\n\t@Id @GeneratedValue\n\tLong id;\n\tString name;\n\t@Version Long version;\n}\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/envers/configuration.adoc", "title": "configuration", "heading": "configuration", "heading_level": 1, "file_order": 1, "section_index": 0, "content_hash": "feb95a9ae3ed15b7e44e5518cb6726f869a45577ea1c5bb145a36b5d301859f5", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/envers/configuration.adoc"}}
{"id": "sha256:aefd53ee3f7ff832b0ec50dd3c95b8238cc2a86ce49e91662ac62debc039fefa", "content": "[[envers.introduction]]\n\n[[envers.what.is.spring.data]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/envers/introduction.adoc", "title": "introduction", "heading": "introduction", "heading_level": 1, "file_order": 2, "section_index": 0, "content_hash": "aefd53ee3f7ff832b0ec50dd3c95b8238cc2a86ce49e91662ac62debc039fefa", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/envers/introduction.adoc"}}
{"id": "sha256:1b7d17043a2e1c83fa4eeb6f584832b5a91d71e248d363caa7a9c9fa6ea24d12", "content": "Spring Data Envers makes typical Envers queries available in repositories for Spring Data JPA.\nIt differs from other Spring Data modules in that it is always used in combination with another Spring Data Module: Spring Data JPA.\n\n[[envers.what]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/envers/introduction.adoc", "title": "introduction", "heading": "What is Spring Data Envers?", "heading_level": 2, "file_order": 2, "section_index": 1, "content_hash": "1b7d17043a2e1c83fa4eeb6f584832b5a91d71e248d363caa7a9c9fa6ea24d12", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/envers/introduction.adoc"}}
{"id": "sha256:41762b67b0d920a1a1cc44c145088db63eaf0ee3e024c45669fe502ed712a189", "content": "Envers is a https://hibernate.org/orm/envers/[Hibernate module] that adds auditing capabilities to JPA entities.\nThis documentation assumes you are familiar with Envers, just as Spring Data Envers relies on Envers being properly configured.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/envers/introduction.adoc", "title": "introduction", "heading": "What is Envers?", "heading_level": 2, "file_order": 2, "section_index": 2, "content_hash": "41762b67b0d920a1a1cc44c145088db63eaf0ee3e024c45669fe502ed712a189", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/envers/introduction.adoc"}}
{"id": "sha256:9ff65b3b6dba453d3579fb33259fbf0175093422dee3c957fa8eba97a8cb1120", "content": "[[envers.usage]]\n\nYou can now use the methods from `RevisionRepository` to query the revisions of the entity, as the following test case shows:\n\n====\n[source,java]\n----\n@ExtendWith(SpringExtension.class)\n@Import(EnversDemoConfiguration.class) // <1>\nclass EnversIntegrationTests {\n\n\tfinal PersonRepository repository;\n\tfinal TransactionTemplate tx;\n\n\tEnversIntegrationTests(@Autowired PersonRepository repository, @Autowired PlatformTransactionManager tm) {\n this.repository = repository;\n this.tx = new TransactionTemplate(tm);\n\t}\n\n\t@Test\n\tvoid testRepository() {\n\n Person updated = preparePersonHistory();\n\n Revisions<Long, Person> revisions = repository.findRevisions(updated.id);\n\n Iterator<Revision<Long, Person>> revisionIterator = revisions.iterator();\n\n checkNextRevision(revisionIterator, \"John\", RevisionType.INSERT);\n checkNextRevision(revisionIterator, \"Jonny\", RevisionType.UPDATE);\n checkNextRevision(revisionIterator, null, RevisionType.DELETE);\n assertThat(revisionIterator.hasNext()).isFalse();\n\n\t}\n\n\t/**\n * Checks that the next element in the iterator is a Revision entry referencing a Person\n * with the given name after whatever change brought that Revision into existence.\n * <p>\n * As a side effect the Iterator gets advanced by one element.\n *\n * @param revisionIterator the iterator to be tested.\n * @param name the expected name of the Person referenced by the Revision.\n * @param revisionType the type of the revision denoting if it represents an insert, update or delete.\n */\n\tprivate void checkNextRevision(Iterator<Revision<Long, Person>> revisionIterator, String name,\n RevisionType revisionType) {\n\n assertThat(revisionIterator.hasNext()).isTrue();\n Revision<Long, Person> revision = revisionIterator.next();\n assertThat(revision.getEntity().name).isEqualTo(name);\n assertThat(revision.getMetadata().getRevisionType()).isEqualTo(revisionType);\n\t}\n\n\t/**\n * Creates a Person with a couple of changes so it has a non-trivial revision history.\n * @return the created Person.\n */\n\tprivate Person preparePersonHistory() {\n\n Person john = new Person();\n john.setName(\"John\");\n\n // create\n Person saved = tx.execute(__ -> repository.save(john));\n assertThat(saved).isNotNull();\n\n saved.setName(\"Jonny\");\n\n // update\n Person updated = tx.execute(__ -> repository.save(saved));\n assertThat(updated).isNotNull();\n\n // delete\n tx.executeWithoutResult(__ -> repository.delete(updated));\n return updated;\n\t}\n}\n----\n<1> This references the application context configuration presented earlier (in the xref:envers.adoc#envers.configuration[Configuration] section).\n====\n\n[[envers.resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/envers/usage.adoc", "title": "usage", "heading": "usage", "heading_level": 1, "file_order": 3, "section_index": 0, "content_hash": "9ff65b3b6dba453d3579fb33259fbf0175093422dee3c957fa8eba97a8cb1120", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/envers/usage.adoc"}}
{"id": "sha256:d7edd98c41810e5e4d980f6eda559720b1919f47723c96cfb2e8a71cb205053d", "content": "You can download the https://github.com/spring-projects/spring-data-examples[Spring Data Envers example in the Spring Data Examples repository] and play around with to get a feel for how the library works.\n\nYou should also check out the {spring-data-commons-javadoc-base}/org/springframework/data/repository/history/RevisionRepository.html[Javadoc for `RevisionRepository`] and related classes.\n\nYou can ask questions at https://stackoverflow.com/questions/tagged/spring-data-envers[Stackoverflow by using the `spring-data-envers` tag].\n\nThe https://github.com/spring-projects/spring-data-jpa[source code and issue tracker for Spring Data Envers is hosted at GitHub] (as a module of Spring Data JPA).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/envers/usage.adoc", "title": "usage", "heading": "Further Resources", "heading_level": 2, "file_order": 3, "section_index": 1, "content_hash": "d7edd98c41810e5e4d980f6eda559720b1919f47723c96cfb2e8a71cb205053d", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/envers/usage.adoc"}}
{"id": "sha256:1e18c144bf66ebb5acabad693564b1beac0c4281f671bb5b8cac67466ad97df9", "content": "include::{commons}@data-commons::page$aot.adoc[]\n\n[[aot.repositories.jpa]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/aot.adoc", "title": "aot", "heading": "aot", "heading_level": 1, "file_order": 4, "section_index": 0, "content_hash": "1e18c144bf66ebb5acabad693564b1beac0c4281f671bb5b8cac67466ad97df9", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/aot.adoc"}}
{"id": "sha256:865474dbb64d3b94ee8a4015195492bbd66aedbeb599e73733ab5570c20d8ef1", "content": "AOT repositories filter methods that are eligible for AOT processing.\nThese are typically all query methods that are not backed by an xref:repositories/custom-implementations.adoc[implementation fragment].\n\n[NOTE]\n====\nAOT processing avoids database access.\nTherefore, it initializes an in-memory Hibernate instance for metadata collection.\nTypes for the Hibernate configuration are determined by our AOT metadata collector.\nWe prefer using a `PersistentEntityTypes` bean if available and fall back to `PersistenceUnitInfo` or our own discovered types.\nIf our type scanning is not sufficient for your arrangement, you can enable direct `EntityManagerFactory` usage by configuring the `spring.aot.jpa.repositories.use-entitymanager=true` property.\n====\n\n**Supported Features**\n\n* Derived query methods, `@Query`/`@NativeQuery` and named query methods\n* Stored procedure query methods annotated with `@Procedure`\n* `@Modifying` methods returning `void` or `int`\n* `@QueryHints` support\n* Pagination, `Slice`, `Stream`, and `Optional` return types\n* Sort query rewriting\n* Interface and DTO Projections\n* Value Expressions (Those require a bit of reflective information.\nMind that using Value Expressions requires expression parsing and contextual information to evaluate the expression)\n\n**Limitations**\n\n* Requires Hibernate for AOT processing.\n* `QueryRewriter` must be a no-args class. `QueryRewriter` beans are not yet supported.\n* Methods accepting `ScrollPosition` (e.g. `Keyset` pagination) are not yet supported.\n* Custom Collection return types (e.g. `io.vavr.collection`, `\"org.eclipse.collections`) are not yet supported.\n\n**Excluded methods**\n\n* `CrudRepository`, Querydsl, Query by Example, and other base interface methods as their implementation is provided by the base class respective fragments\n* Methods whose implementation would be overly complex\n** Methods accepting `ScrollPosition` (e.g. `Keyset` pagination)\n** Dynamic projections", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/aot.adoc", "title": "aot", "heading": "JPA Ahead of Time Repositories", "heading_level": 2, "file_order": 4, "section_index": 1, "content_hash": "865474dbb64d3b94ee8a4015195492bbd66aedbeb599e73733ab5570c20d8ef1", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/aot.adoc"}}
{"id": "sha256:2aef758f489f0c481fcbd43a64b127ae985b9d9f560b6646f11df3abf462fe94", "content": "[[jpa.entity-persistence]]\n\nThis section describes how to persist (save) entities with Spring Data JPA.\n\n[[jpa.entity-persistence.saving-entities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/entity-persistence.adoc", "title": "entity-persistence", "heading": "entity-persistence", "heading_level": 1, "file_order": 5, "section_index": 0, "content_hash": "2aef758f489f0c481fcbd43a64b127ae985b9d9f560b6646f11df3abf462fe94", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/entity-persistence.adoc"}}
{"id": "sha256:789ed4bbba3d4f2c10e4ebd43e50e158ee353921e62ba060c51bcb5a668d5053", "content": "Saving an entity can be performed with the `CrudRepository.save(…)` method. It persists or merges the given entity by using the underlying JPA `EntityManager`. If the entity has not yet been persisted, Spring Data JPA saves the entity with a call to the `entityManager.persist(…)` method. Otherwise, it calls the `entityManager.merge(…)` method.\n\n[[jpa.entity-persistence.saving-entities.strategies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/entity-persistence.adoc", "title": "entity-persistence", "heading": "Saving Entities", "heading_level": 2, "file_order": 5, "section_index": 1, "content_hash": "789ed4bbba3d4f2c10e4ebd43e50e158ee353921e62ba060c51bcb5a668d5053", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/entity-persistence.adoc"}}
{"id": "sha256:579f9fe975a1c4a95df47949ba80ad7bad9f455a4b60e792e4b73c5dc6091c71", "content": "Spring Data JPA offers the following strategies to detect whether an entity is new or not:\n\n1. Version-Property and Id-Property inspection (*default*):\n By default Spring Data JPA inspects first if there is a Version-property of non-primitive type.\n If there is, the entity is considered new if the value of that property is `null`.\n Without such a Version-property Spring Data JPA inspects the identifier property of the given entity.\n If the identifier property is `null`, then the entity is assumed to be new.\n Otherwise, it is assumed to be not new.\nIn contrast to other Spring Data modules, JPA considers `0` (zero) as the first inserted version of an entity and therefore, a primitive version property cannot be used to determine whether an entity is new or not.\n2. Implementing `Persistable`: If an entity implements `Persistable`, Spring Data JPA delegates the new detection to the `isNew(…)` method of the entity.\nSee the link:{spring-data-commons-javadoc-base}/org/springframework/data/domain/Persistable.html[JavaDoc] for details.\n3. Implementing `EntityInformation`: You can customize the `EntityInformation` abstraction used in the `SimpleJpaRepository` implementation by creating a subclass of `JpaRepositoryFactory` and overriding the `getEntityInformation(…)` method accordingly. You then have to register the custom implementation of `JpaRepositoryFactory` as a Spring bean. Note that this should be rarely necessary. See the javadoc:org.springframework.data.jpa.repository.support.JpaRepositoryFactory[JavaDoc] for details.\n\nOption 1 is not an option for entities that use manually assigned identifiers and no version attribute as with those the identifier will always be non-`null`.\nA common pattern in that scenario is to use a common base class with a transient flag defaulting to indicate a new instance and using JPA lifecycle callbacks to flip that flag on persistence operations:\n\n.A base class for entities with manually assigned identifiers\n====\n[source, java]\n----\n@MappedSuperclass\npublic abstract class AbstractEntity<ID> implements Persistable<ID> {\n\n @Transient\n private boolean isNew = true; <1>\n\n @Override\n public boolean isNew() {\n return isNew; <2>\n }\n\n @PostPersist <3>\n @PostLoad\n void markNotNew() {\n this.isNew = false;\n }\n\n // More code…\n}\n----\n<1> Declare a flag to hold the new state. Transient so that it's not persisted to the database.\n<2> Return the flag in the implementation of `Persistable.isNew()` so that Spring Data repositories know whether to call `EntityManager.persist()` or `….merge()`.\n<3> Declare a method using JPA entity callbacks so that the flag is switched to indicate an existing entity after a repository call to `save(…)` or an instance creation by the persistence provider.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/entity-persistence.adoc", "title": "entity-persistence", "heading": "Entity State-detection Strategies", "heading_level": 3, "file_order": 5, "section_index": 2, "content_hash": "579f9fe975a1c4a95df47949ba80ad7bad9f455a4b60e792e4b73c5dc6091c71", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/entity-persistence.adoc"}}
{"id": "sha256:dc5b2d885068c280063563f6b8ecf6b6bf1d8e4c4f556f430f409d26042bb5c5", "content": "[appendix]\n[[faq]]\n\n[[faq.common]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/faq.adoc", "title": "faq", "heading": "faq", "heading_level": 1, "file_order": 6, "section_index": 0, "content_hash": "dc5b2d885068c280063563f6b8ecf6b6bf1d8e4c4f556f430f409d26042bb5c5", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/faq.adoc"}}
{"id": "sha256:3e9ae80338e5719a00eb3d01745f088910cb6500bcef715769e16f4a4e2a1690", "content": "[qanda]\nI'd like to get more detailed logging information on what methods are called inside `JpaRepository` for example. How can I gain them? :: You can make use of `CustomizableTraceInterceptor` provided by Spring, as shown in the following example:\n+\n[source, xml]\n----\n<bean id=\"customizableTraceInterceptor\" class=\"\n org.springframework.aop.interceptor.CustomizableTraceInterceptor\">\n <property name=\"enterMessage\" value=\"Entering $[methodName]($[arguments])\"/>\n <property name=\"exitMessage\" value=\"Leaving $[methodName](): $[returnValue]\"/>\n</bean>\n\n<aop:config>\n <aop:advisor advice-ref=\"customizableTraceInterceptor\"\n pointcut=\"execution(public * org.springframework.data.jpa.repository.JpaRepository+.*(..))\"/>\n</aop:config>\n----\n\n[[faq.auditing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/faq.adoc", "title": "faq", "heading": "Common", "heading_level": 2, "file_order": 6, "section_index": 1, "content_hash": "3e9ae80338e5719a00eb3d01745f088910cb6500bcef715769e16f4a4e2a1690", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/faq.adoc"}}
{"id": "sha256:27b8b83b7174500a9035c6252ea8f70f6016c2cc32e7c394cf93497408b4758f", "content": "[qanda]\nI want to use Spring Data JPA auditing capabilities but have my database already configured to set modification and creation date on entities. How can I prevent Spring Data from setting the date programmatically? :: Set the `set-dates` attribute of the `auditing` namespace element to `false`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/faq.adoc", "title": "faq", "heading": "Auditing", "heading_level": 2, "file_order": 6, "section_index": 2, "content_hash": "27b8b83b7174500a9035c6252ea8f70f6016c2cc32e7c394cf93497408b4758f", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/faq.adoc"}}
{"id": "sha256:95efa1d81578aa565eaa7ec6f2602ad877736b889ada5aec1566e116bb4532ef", "content": "[[jpa.getting-started]]\n\nAn easy way to bootstrap setting up a working environment is to create a Spring-based project via https://start.spring.io/#!type=maven-project&dependencies=h2,data-jpa[start.spring.io] or create a Spring project in https://spring.io/tools[Spring Tools].\n\n[[jpa.examples-repo]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/getting-started.adoc", "title": "getting-started", "heading": "getting-started", "heading_level": 1, "file_order": 7, "section_index": 0, "content_hash": "95efa1d81578aa565eaa7ec6f2602ad877736b889ada5aec1566e116bb4532ef", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/getting-started.adoc"}}
{"id": "sha256:6cfe805734d3a29010761f041128d7e8037f101fc2764a14b65822124aa0780a", "content": "The GitHub https://github.com/spring-projects/spring-data-examples[spring-data-examples repository] hosts several examples that you can download and play around with to get a feel for how the library works.\n\n[[redis.hello-world]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/getting-started.adoc", "title": "getting-started", "heading": "Examples Repository", "heading_level": 2, "file_order": 7, "section_index": 1, "content_hash": "6cfe805734d3a29010761f041128d7e8037f101fc2764a14b65822124aa0780a", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/getting-started.adoc"}}
{"id": "sha256:5b48358357fc486dd20b1a8b3c1dc6945c759a4ff15a98259af3c0d532a40de3", "content": "Let's start with a simple entity and its corresponding repository:\n\n[source,java]\n----\n@Entity\nclass Person {\n\n @Id @GeneratedValue(strategy = GenerationType.AUTO)\n private Long id;\n private String name;\n\n // getters and setters omitted for brevity\n}\n\ninterface PersonRepository extends Repository<Person, Long> {\n\n Person save(Person person);\n\n Optional<Person> findById(long id);\n}\n----\n\nCreate the main application to run, as the following example shows:\n\n[source,java]\n----\n@SpringBootApplication\npublic class DemoApplication {\n\n public static void main(String[] args) {\n SpringApplication.run(DemoApplication.class, args);\n }\n\n @Bean\n CommandLineRunner runner(PersonRepository repository) {\n return args -> {\n\n Person person = new Person();\n person.setName(\"John\");\n\n repository.save(person);\n Person saved = repository.findById(person.getId()).orElseThrow(NoSuchElementException::new);\n };\n }\n}\n----\n\nEven in this simple example, there are a few notable things to point out:\n\n* Repository instances are automatically implemented.\nWhen used as parameters of `@Bean` methods, these will be autowired without further need for annotations.\n* The basic repository extends `Repository`.\nWe suggest to consider how much API surface you want to expose towards your application.\nMore complex repository interfaces are `ListCrudRepository` or `JpaRepository`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/getting-started.adoc", "title": "getting-started", "heading": "Hello World", "heading_level": 2, "file_order": 7, "section_index": 2, "content_hash": "5b48358357fc486dd20b1a8b3c1dc6945c759a4ff15a98259af3c0d532a40de3", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/getting-started.adoc"}}
{"id": "sha256:16d69ef4509552bc683543f62c79977bde883e539f53683084c22012968bdd84", "content": "[glossary]\n[[glossary]]\n\nAOP :: Aspect oriented programming\n\nCommons DBCP :: Commons DataBase Connection Pools - a library from the Apache foundation that offers pooling implementations of the DataSource interface.\n\nCRUD :: Create, Read, Update, Delete - Basic persistence operations.\n\nDAO :: Data Access Object - Pattern to separate persisting logic from the object to be persisted\n\nDependency Injection :: Pattern to hand a component's dependency to the component from outside, freeing the component to lookup the dependent itself. For more information, see link:$$https://en.wikipedia.org/wiki/Dependency_Injection$$[https://en.wikipedia.org/wiki/Dependency_Injection].\n\nEclipseLink :: Object relational mapper implementing JPA - link:$$https://www.eclipse.org/eclipselink/$$[https://www.eclipse.org/eclipselink/]\n\nHibernate :: Object relational mapper implementing JPA - link:$$https://hibernate.org/$$[https://hibernate.org/]\n\nJPA :: Jakarta Persistence API\n\nSpring :: Java application framework - link:$$https://spring.io/projects/spring-framework/$$[https://spring.io/projects/spring-framework]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/glossary.adoc", "title": "glossary", "heading": "glossary", "heading_level": 1, "file_order": 8, "section_index": 0, "content_hash": "16d69ef4509552bc683543f62c79977bde883e539f53683084c22012968bdd84", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/glossary.adoc"}}
{"id": "sha256:60798d89dade85fcb257366b3707bec76f01f27b7e6161d43e5e478ec7e98ee9", "content": "[[jpd.misc.cdi-integration]]\n\nInstances of the repository interfaces are usually created by a container, for which Spring is the most natural choice when working with Spring Data. Spring offers sophisticated support for creating bean instances, as documented in {spring-data-commons-docs-url}/repositories/create-instances.html[Creating Repository Instances]. As of version 1.1.0, Spring Data JPA ships with a custom CDI extension that allows using the repository abstraction in CDI environments. The extension is part of the JAR. To activate it, include the Spring Data JPA JAR on your classpath.\n\nYou can now set up the infrastructure by implementing a CDI Producer for the `EntityManagerFactory` and `EntityManager`, as shown in the following example:\n\n[source, java]\n----\nclass EntityManagerFactoryProducer {\n\n @Produces\n @ApplicationScoped\n public EntityManagerFactory createEntityManagerFactory() {\n return Persistence.createEntityManagerFactory(\"my-persistence-unit\");\n }\n\n public void close(@Disposes EntityManagerFactory entityManagerFactory) {\n entityManagerFactory.close();\n }\n\n @Produces\n @RequestScoped\n public EntityManager createEntityManager(EntityManagerFactory entityManagerFactory) {\n return entityManagerFactory.createEntityManager();\n }\n\n public void close(@Disposes EntityManager entityManager) {\n entityManager.close();\n }\n}\n----\n\nThe necessary setup can vary depending on the JavaEE environment. You may need to do nothing more than redeclare a `EntityManager` as a CDI bean, as follows:\n\n[source, java]\n----\nclass CdiConfig {\n\n @Produces\n @RequestScoped\n @PersistenceContext\n public EntityManager entityManager;\n}\n----\n\nIn the preceding example, the container has to be capable of creating JPA `EntityManagers` itself. All the configuration does is re-export the JPA `EntityManager` as a CDI bean.\n\nThe Spring Data JPA CDI extension picks up all available `EntityManager` instances as CDI beans and creates a proxy for a Spring Data repository whenever a bean of a repository type is requested by the container. Thus, obtaining an instance of a Spring Data repository is a matter of declaring an `@Inject` property, as shown in the following example:\n\n[source, java]\n----\nclass RepositoryClient {\n\n @Inject\n PersonRepository repository;\n\n public void businessMethod() {\n List<Person> people = repository.findAll();\n }\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/jpd-misc-cdi-integration.adoc", "title": "jpd-misc-cdi-integration", "heading": "jpd-misc-cdi-integration", "heading_level": 1, "file_order": 9, "section_index": 0, "content_hash": "60798d89dade85fcb257366b3707bec76f01f27b7e6161d43e5e478ec7e98ee9", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/jpd-misc-cdi-integration.adoc"}}
{"id": "sha256:069e7fd6c42e727cd699a77c1b6733f73763e2f3ec152e57037d63ee21b98224", "content": "[[locking]]\n\nTo specify the lock mode to be used, you can use the `@Lock` annotation on query methods, as shown in the following example:\n\n.Defining lock metadata on query methods\n====\n[source, java]\n----\ninterface UserRepository extends Repository<User, Long> {\n\n // Plain query method\n @Lock(LockModeType.READ)\n List<User> findByLastname(String lastname);\n}\n----\n====\n\nThis method declaration causes the query being triggered to be equipped with a `LockModeType` of `READ`. You can also define locking for CRUD methods by redeclaring them in your repository interface and adding the `@Lock` annotation, as shown in the following example:\n\n.Defining lock metadata on CRUD methods\n====\n[source, java]\n----\ninterface UserRepository extends Repository<User, Long> {\n\n // Redeclaration of a CRUD method\n @Lock(LockModeType.READ)\n List<User> findAll();\n}\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/locking.adoc", "title": "locking", "heading": "locking", "heading_level": 1, "file_order": 10, "section_index": 0, "content_hash": "069e7fd6c42e727cd699a77c1b6733f73763e2f3ec152e57037d63ee21b98224", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/locking.adoc"}}
{"id": "sha256:60c3737d65e87bec083a5e21175564f0b1a1c7945e6daa77678071d3feb19fec", "content": "[[jpa.misc.merging-persistence-units]]\n\nSpring supports having multiple persistence units. Sometimes, however, you might want to modularize your application but still make sure that all these modules run inside a single persistence unit. To enable that behavior, Spring Data JPA offers a `PersistenceUnitManager` implementation that automatically merges persistence units based on their name, as shown in the following example:\n\n.Using MergingPersistenceUnitManager\n====\n[source, xml]\n----\n<bean class=\"….LocalContainerEntityManagerFactoryBean\">\n <property name=\"persistenceUnitManager\">\n <bean class=\"….MergingPersistenceUnitManager\" />\n </property>\n</bean>\n----\n====\n\n[[jpa.misc.entity-scanning]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/misc-merging-persistence-units.adoc", "title": "misc-merging-persistence-units", "heading": "misc-merging-persistence-units", "heading_level": 1, "file_order": 11, "section_index": 0, "content_hash": "60c3737d65e87bec083a5e21175564f0b1a1c7945e6daa77678071d3feb19fec", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/misc-merging-persistence-units.adoc"}}
{"id": "sha256:54aca4548b8778c20024b7c2102efc9b3926d2758d32f80f4fae42f4510c2064", "content": "A plain JPA setup requires all annotation-mapped entity classes to be listed in `orm.xml`. The same applies to XML mapping files. Spring Data JPA provides a `ClasspathScanningPersistenceUnitPostProcessor` that gets a base package configured and optionally takes a mapping filename pattern. It then scans the given package for classes annotated with `@Entity` or `@MappedSuperclass`, loads the configuration files that match the filename pattern, and hands them to the JPA configuration. The post-processor must be configured as follows:\n\n.Using ClasspathScanningPersistenceUnitPostProcessor\n====\n[source, xml]\n----\n<bean class=\"….LocalContainerEntityManagerFactoryBean\">\n <property name=\"persistenceUnitPostProcessors\">\n <list>\n <bean class=\"org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor\">\n <constructor-arg value=\"com.acme.domain\" />\n <property name=\"mappingFileNamePattern\" value=\"**/*Mapping.xml\" />\n </bean>\n </list>\n </property>\n</bean>\n----\n====\n\nNOTE: As of Spring 3.1, a package to scan can be configured on the `LocalContainerEntityManagerFactoryBean` directly to enable classpath scanning for entity classes. See the link:{springJavadocUrl}/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html#setPackagesToScan(java.lang.String...)$$[JavaDoc] for details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/misc-merging-persistence-units.adoc", "title": "misc-merging-persistence-units", "heading": "Classpath Scanning for @Entity Classes and JPA Mapping Files", "heading_level": 2, "file_order": 11, "section_index": 1, "content_hash": "54aca4548b8778c20024b7c2102efc9b3926d2758d32f80f4fae42f4510c2064", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/misc-merging-persistence-units.adoc"}}
{"id": "sha256:0282503f607485ac1e5d46913139a9010f2a2d91208c0473dd52d066b220b123", "content": "[[jpa.query-methods]]\n\nThis section describes the various ways to create a query with Spring Data JPA.\n\n[[jpa.sample-app.finders.strategies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "query-methods", "heading_level": 1, "file_order": 12, "section_index": 0, "content_hash": "0282503f607485ac1e5d46913139a9010f2a2d91208c0473dd52d066b220b123", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:9e6b8fcc9e638cce97ed2627e71aaecdb4d34ea9b89b8b3393715c5d0536483d", "content": "The JPA module supports defining a query manually as a String or having it being derived from the method name.\n\nDerived queries with the predicates `IsStartingWith`, `StartingWith`, `StartsWith`, `IsEndingWith`, `EndingWith`, `EndsWith`,\n`IsNotContaining`, `NotContaining`, `NotContains`, `IsContaining`, `Containing`, `Contains` the respective arguments for these queries will get sanitized.\nThis means if the arguments actually contain characters recognized by `LIKE` as wildcards these will get escaped so they match only as literals.\nThe escape character used can be configured by setting the `escapeCharacter` of the `@EnableJpaRepositories` annotation.\nCompare with xref:jpa/query-methods.adoc#jpa.query.spel-expressions[Using Value Expressions].\n\n[[jpa.query-methods.declared-queries]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Query Lookup Strategies", "heading_level": 2, "file_order": 12, "section_index": 1, "content_hash": "9e6b8fcc9e638cce97ed2627e71aaecdb4d34ea9b89b8b3393715c5d0536483d", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:ed773f419c314d0942559c186479bf6452fc4649eb3e6accdb064f1ce7d6f881", "content": "Although getting a query derived from the method name is quite convenient, one might face the situation in which either the method name parser does not support the keyword one wants to use or the method name would get unnecessarily ugly. So you can either use JPA named queries through a naming convention (see xref:jpa/query-methods.adoc#jpa.query-methods.named-queries[Using JPA Named Queries] for more information) or rather annotate your query method with `@Query` (see xref:jpa/query-methods.adoc#jpa.query-methods.at-query[Using `@Query`] for details).\n\n[[jpa.query-methods.query-creation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Declared Queries", "heading_level": 3, "file_order": 12, "section_index": 2, "content_hash": "ed773f419c314d0942559c186479bf6452fc4649eb3e6accdb064f1ce7d6f881", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:ef123f45d2123ce3dc262376f675a3ea1246d53986c78c61d56f890425b74f15", "content": "Generally, the query creation mechanism for JPA works as described in {spring-data-commons-docs-url}/repositories/query-methods.html[Query Methods]. The following example shows what a JPA query method translates into:\n\n.Query creation from method names\n====\n[source, java]\n----\npublic interface UserRepository extends Repository<User, Long> {\n\n List<User> findByEmailAddressAndLastname(String emailAddress, String lastname);\n}\n----\nWe create a query using JPQL translating into the following query: `select u from User u where u.emailAddress = ?1 and u.lastname = ?2`. Spring Data JPA does a property check and traverses nested properties, as described in xref:repositories/query-methods-details.adoc#repositories.query-methods.query-property-expressions[Property Expressions].\n====\n\nThe following table describes the keywords supported for JPA and what a method containing that keyword translates to:\n\n.Supported keywords inside method names\n[options = \"header, autowidth\"]\n|===============\n|Keyword|Sample|JPQL snippet\n|`Distinct`|`findDistinctByLastnameAndFirstname`|`select distinct ... where x.lastname = ?1 and x.firstname = ?2`\n|`And`|`findByLastnameAndFirstname`|`… where x.lastname = ?1 and x.firstname = ?2`\n|`Or`|`findByLastnameOrFirstname`|`… where x.lastname = ?1 or x.firstname = ?2`\n|`Is`, `Equals`|`findByFirstname`,`findByFirstnameIs`,`findByFirstnameEquals`|`… where x.firstname = ?1` (or `… where x.firstname IS NULL` if the argument is `null`)\n|`Between`|`findByStartDateBetween`|`… where x.startDate between ?1 and ?2`\n|`LessThan`|`findByAgeLessThan`|`… where x.age < ?1`\n|`LessThanEqual`|`findByAgeLessThanEqual`|`… where x.age \\<= ?1`\n|`GreaterThan`|`findByAgeGreaterThan`|`… where x.age > ?1`\n|`GreaterThanEqual`|`findByAgeGreaterThanEqual`|`… where x.age >= ?1`\n|`After`|`findByStartDateAfter`|`… where x.startDate > ?1`\n|`Before`|`findByStartDateBefore`|`… where x.startDate < ?1`\n|`IsNull`, `Null`|`findByAge(Is)Null`|`… where x.age is null`\n|`IsNotNull`, `NotNull`|`findByAge(Is)NotNull`|`… where x.age is not null`\n|`Like`|`findByFirstnameLike`|`… where x.firstname like ?1`\n|`NotLike`|`findByFirstnameNotLike`|`… where x.firstname not like ?1`\n|`StartingWith`|`findByFirstnameStartingWith`|`… where x.firstname like ?1` (parameter bound with appended `%`)\n|`EndingWith`|`findByFirstnameEndingWith`|`… where x.firstname like ?1` (parameter bound with prepended `%`)\n|`Containing`|`findByFirstnameContaining`|`… where x.firstname like ?1` (parameter bound wrapped in `%`)\n|`OrderBy`|`findByAgeOrderByLastnameDesc`|`… where x.age = ?1 order by x.lastname desc`\n|`Not`|`findByLastnameNot`|`… where x.lastname <> ?1` (or `… where x.lastname IS NOT NULL` if the argument is `null`)\n|`In`|`findByAgeIn(Collection<Age> ages)`|`… where x.age in ?1`\n|`NotIn`|`findByAgeNotIn(Collection<Age> ages)`|`… where x.age not in ?1`\n|`True`|`findByActiveTrue()`|`… where x.active = true`\n|`False`|`findByActiveFalse()`|`… where x.active = false`\n|`IgnoreCase`|`findByFirstnameIgnoreCase`|`… where UPPER(x.firstname) = UPPER(?1)`\n|===============\n\nNOTE: `In` and `NotIn` also take any subclass of `Collection` as a parameter as well as arrays or varargs. For other syntactical versions of the same logical operator, check xref:repositories/query-keywords-reference.adoc[Repository query keywords].\n\n[WARNING]\n====\n`DISTINCT` can be tricky and not always producing the results you expect.\nFor example, `select distinct u from User u` will produce a complete different result than `select distinct u.lastname from User u`.\nIn the first case, since you are including `User.id`, nothing will be duplicated, hence you'll get the whole table, and it would be of `User` objects.\n\nHowever, that latter query would narrow the focus to just `User.lastname` and find all unique last names for that table.\nThis would also yield a `List<String>` result set instead of a `List<User>` result set.\n\n`countDistinctByLastname(String lastname)` can also produce unexpected results.\nSpring Data JPA will derive `select count(distinct u.id) from User u where u.lastname = ?1`.\nAgain, since `u.id` won't hit any duplicates, this query will count up all the users that had the binding last name.\nWhich would be the same as `countByLastname(String lastname)`!\n\nWhat is the point of this query anyway? To find the number of people with a given last name? To find the number of _distinct_ people with that binding last name?\nTo find the number of _distinct last names_? (That last one is an entirely different query!)\nUsing `distinct` sometimes requires writing the query by hand and using `@Query` to best capture the information you seek, since you also may be needing a projection\nto capture the result set.\n====\n\n[[jpa.query-methods.named-queries.annotation-based-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Query Creation", "heading_level": 2, "file_order": 12, "section_index": 3, "content_hash": "ef123f45d2123ce3dc262376f675a3ea1246d53986c78c61d56f890425b74f15", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:04b6379ffe3cccce1bf1a8819939a8e3674041232b723eb1b89bff33151ab57b", "content": "Annotation-based configuration has the advantage of not needing another configuration file to be edited, lowering maintenance effort. You pay for that benefit by the need to recompile your domain class for every new query declaration.\n\n.Annotation-based named query configuration\n====\n[source, java]\n----\n@Entity\n@NamedQuery(name = \"User.findByEmailAddress\",\n query = \"select u from User u where u.emailAddress = ?1\")\npublic class User {\n\n}\n----\n====\n\n[[jpa.query-methods.named-queries]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Annotation-based Configuration", "heading_level": 3, "file_order": 12, "section_index": 4, "content_hash": "04b6379ffe3cccce1bf1a8819939a8e3674041232b723eb1b89bff33151ab57b", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:7f3c227fd93794349c25b662ac54b9ecd6bc5b80f3262505830414e066938b33", "content": "NOTE: The examples use the `<named-query />` element and `@NamedQuery` annotation. The queries for these configuration elements have to be defined in the JPA query language. Of course, you can use `<named-native-query />` or `@NamedNativeQuery` too. These elements let you define the query in native SQL by losing the database platform independence.\n\n[[jpa.query-methods.named-queries.xml-named-query-definition]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Using JPA Named Queries", "heading_level": 2, "file_order": 12, "section_index": 5, "content_hash": "7f3c227fd93794349c25b662ac54b9ecd6bc5b80f3262505830414e066938b33", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:ed402f927c75cac7c069620dd63157d9d32c44e7a67bc77614618cf2b162588d", "content": "To use XML configuration, add the necessary `<named-query />` element to the `orm.xml` JPA configuration file located in the `META-INF` folder of your classpath. Automatic invocation of named queries is enabled by using some defined naming convention. For more details, see below.\n\n.XML named query configuration\n====\n[source, xml]\n----\n<named-query name=\"User.findByLastname\">\n <query>select u from User u where u.lastname = ?1</query>\n</named-query>\n----\n====\n\nThe query has a special name that is used to resolve it at runtime.\n\n[[jpa.query-methods.named-queries.declaring-interfaces]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "XML Named Query Definition", "heading_level": 3, "file_order": 12, "section_index": 6, "content_hash": "ed402f927c75cac7c069620dd63157d9d32c44e7a67bc77614618cf2b162588d", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:8de1590a8e1127204329938aa17b6cf34514d94af5d5312a917549ec80e0d567", "content": "To allow these named queries, specify the `UserRepository` as follows:\n\n.Query method declaration in UserRepository\n====\n[source, java]\n----\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n List<User> findByLastname(String lastname);\n\n User findByEmailAddress(String emailAddress);\n}\n----\n====\n\nSpring Data tries to resolve a call to these methods to a named query, starting with the simple name of the configured domain class, followed by the method name separated by a dot.\nSo the preceding example would use the named queries defined earlier instead of trying to create a query from the method name.\n\n[[jpa.query-methods.at-query]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Declaring Interfaces", "heading_level": 3, "file_order": 12, "section_index": 7, "content_hash": "8de1590a8e1127204329938aa17b6cf34514d94af5d5312a917549ec80e0d567", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:838b33b961f53e8603a54f72908884d1c684bc2c02bde32d2f17f09cedfa15c3", "content": "Using named queries to declare queries for entities is a valid approach and works fine for a small number of queries. As the queries themselves are tied to the Java method that runs them, you can actually bind them directly by using the Spring Data JPA `@Query` annotation rather than annotating them to the domain class. This frees the domain class from persistence specific information and co-locates the query to the repository interface.\n\nQueries annotated to the query method take precedence over queries defined using `@NamedQuery` or named queries declared in `orm.xml`.\n\nThe following example shows a query created with the `@Query` annotation:\n\n.Declare query at the query method using `@Query`\n====\n[source, java]\n----\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n @Query(\"select u from User u where u.emailAddress = ?1\")\n User findByEmailAddress(String emailAddress);\n}\n----\n====\n\n[[jpa.query-methods.at-query.advanced-like]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Using `@Query`", "heading_level": 2, "file_order": 12, "section_index": 8, "content_hash": "838b33b961f53e8603a54f72908884d1c684bc2c02bde32d2f17f09cedfa15c3", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:353efc25b2cfae6ae231a5536ec85e5b49b99323a29ddef2a6f20f7fae0dae61", "content": "The query running mechanism for manually defined queries created with `@Query` allows the definition of advanced `LIKE` expressions inside the query definition, as shown in the following example:\n\n.Advanced `like` expressions in @Query\n====\n[source, java]\n----\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n @Query(\"select u from User u where u.firstname like %?1\")\n List<User> findByFirstnameEndsWith(String firstname);\n}\n----\n====\n\nIn the preceding example, the `LIKE` delimiter character (`%`) is recognized, and the query is transformed into a valid JPQL query (removing the `%`). Upon running the query, the parameter passed to the method call gets augmented with the previously recognized `LIKE` pattern.\n\n[[jpa.query-methods.at-query.native]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Using Advanced `LIKE` Expressions", "heading_level": 3, "file_order": 12, "section_index": 9, "content_hash": "353efc25b2cfae6ae231a5536ec85e5b49b99323a29ddef2a6f20f7fae0dae61", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:71f94d87c4d2cf5372e479f262f55cb27b3510bbb17b5473a7938ecf3ed1fd0e", "content": "Using the `@NativeQuery` annotation allows running native queries, as shown in the following example:\n\n.Declare a native query at the query method using `@NativeQuery`\n====\n[source, java]\n----\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n @NativeQuery(value = \"SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1\")\n User findByEmailAddress(String emailAddress);\n}\n----\n====\n\nNOTE: The `@NativeQuery` annotation is mostly a composed annotation for `@Query(nativeQuery=true)` but it also provides additional attributes such as `sqlResultSetMapping` to leverage JPA's `@SqlResultSetMapping(…)`.\n\nNOTE: Spring Data can rewrite simple queries for pagination and sorting.\nMore complex queries require either link:https://github.com/JSQLParser/JSqlParser[JSqlParser] to be on the class path or a `countQuery` declared in your code.\nSee the example below for more details.\n\n.Declare native count queries for pagination at the query method by using `@NativeQuery`\n====\n[source, java]\n----\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n @NativeQuery(value = \"SELECT * FROM USERS WHERE LASTNAME = ?1\",\n countQuery = \"SELECT count(*) FROM USERS WHERE LASTNAME = ?1\")\n Page<User> findByLastname(String lastname, Pageable pageable);\n}\n----\n====\n\nA similar approach also works with named native queries, by adding the `.count` suffix to a copy of your query. You probably need to register a result set mapping for your count query, though.\n\nNext to obtaining mapped results, native queries allow you to read the raw `Tuple` from the database by choosing a `Map` container as the method's return type.\nThe resulting map contains key/value pairs representing the actual database column name and the value.\n\n.Native query returning raw column name/value pairs\n====\n[source, java]\n----\ninterface UserRepository extends JpaRepository<User, Long> {\n\n @NativeQuery(\"SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1\")\n Map<String, Object> findRawMapByEmail(String emailAddress); <1>\n\n @NativeQuery(\"SELECT * FROM USERS WHERE LASTNAME = ?1\")\n List<Map<String, Object>> findRawMapByLastname(String lastname); <2>\n}\n----\n<1> Single `Map` result backed by a `Tuple`.\n<2> Multiple `Map` results backed by ``Tuple``s.\n====\n\nNOTE: String-based Tuple Queries are only supported by Hibernate.\nEclipselink supports only Criteria-based Tuple Queries.\n\n[[jpa.query-methods.query-introspection-rewriting]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Native Queries", "heading_level": 3, "file_order": 12, "section_index": 10, "content_hash": "71f94d87c4d2cf5372e479f262f55cb27b3510bbb17b5473a7938ecf3ed1fd0e", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:b82fd4022b0297e49a94489abd8a5727091d71c41294d51fa993c98f98605548", "content": "Spring Data JPA provides a wide range of functionality that can be used to run various flavors of queries.\nSpecifically, given a declared query, Spring Data JPA can:\n\n* Introspect a query for its projection and run a tuple query for interface projections\n* Use DTO projections if the query uses constructor expressions and rewrite the projection when the query declares the entity alias or just a multi-select of expressions\n* Apply dynamic sorting\n* Derive a `COUNT` query\n\nFor this purpose, we ship with Query Parsers specific to HQL (Hibernate) and EQL (EclipseLink) dialects as these dialects are well-defined.\nSQL on the other hand allows for quite some variance across dialects.\nBecause of this, there is no way Spring Data will ever be able to support all levels of query complexity.\nWe are not general purpose SQL parser library but one to increase developer productivity through making query execution simpler.\nOur built-in SQL query enhancer supports only simple queries for introspection `COUNT` query derivation.\nA more complex query will require either the usage of link:https://github.com/JSQLParser/JSqlParser[JSqlParser] or that you provide a `COUNT` query through `@Query(countQuery=…)`.\nIf JSqlParser is on the class path, Spring Data JPA will use it for native queries.\n\nFor a fine-grained control over selection, you can configure javadoc:org.springframework.data.jpa.repository.query.QueryEnhancerSelector[] using `@EnableJpaRepositories`:\n\n.Spring Data JPA repositories using JavaConfig\n====\n[source,java]\n----\n@Configuration\n@EnableJpaRepositories(queryEnhancerSelector = MyQueryEnhancerSelector.class)\nclass ApplicationConfig {\n // …\n}\n----\n====\n\n`QueryEnhancerSelector` is a strategy interface intended to select a javadoc:org.springframework.data.jpa.repository.query.QueryEnhancer[] based on a specific query.\nYou can also provide your own `QueryEnhancer` implementation if you want.\n\n[[jpa.query-methods.query-rewriter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Query Introspection and Rewriting", "heading_level": 3, "file_order": 12, "section_index": 11, "content_hash": "b82fd4022b0297e49a94489abd8a5727091d71c41294d51fa993c98f98605548", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:340df43d7085b1ec286b2eb8f7cd302db603bd7fc78ade7e249cea3a6f177b6e", "content": "Sometimes, no matter how many features you try to apply, it seems impossible to get Spring Data JPA to apply every thing you'd like to a query before it is sent to the `EntityManager`.\n\nYou have the ability to get your hands on the query, right before it's sent to the `EntityManager` and \"rewrite\" it.\nThat is, you can make any alterations at the last moment.\nQuery rewriting applies to the actual query and, when applicable, to count queries.\nCount queries are optimized and therefore, either not necessary or a count is obtained through other means, such as derived from a Hibernate `SelectionQuery` if there is an enclosing transaction.\n\n.Declare a QueryRewriter using `@Query` and `@NativeQuery`\n====\n[source,java]\n----\npublic interface MyRepository extends JpaRepository<User, Long> {\n\n @NativeQuery(value = \"select original_user_alias.* from SD_USER original_user_alias\",\n queryRewriter = MyQueryRewriter.class)\n List<User> findByNativeQuery(String param);\n\n @Query(value = \"select original_user_alias from User original_user_alias\",\n queryRewriter = MyQueryRewriter.class)\n List<User> findByNonNativeQuery(String param);\n}\n----\n====\n\nThis example shows both a native (pure SQL) rewriter as well as a JPQL query, both leveraging the same `QueryRewriter`.\nIn this scenario, Spring Data JPA will look for a bean registered in the application context of the corresponding type.\n\nYou can write a query rewriter like this:\n\n.Example `QueryRewriter`\n====\n[source,java]\n----\npublic class MyQueryRewriter implements QueryRewriter {\n\n @Override\n public String rewrite(String query, Sort sort) {\n return query.replaceAll(\"original_user_alias\", \"rewritten_user_alias\");\n }\n}\n----\n====\n\nYou have to ensure your `QueryRewriter` is registered in the application context, whether it's by applying one of Spring Framework's\n`@Component`-based annotations, or having it as part of a `@Bean` method inside an `@Configuration` class.\n\nAnother option is to have the repository itself implement the interface.\n\n.Repository that provides the `QueryRewriter`\n====\n[source,java]\n----\npublic interface MyRepository extends JpaRepository<User, Long>, QueryRewriter {\n\n @Query(value = \"select original_user_alias.* from SD_USER original_user_alias\",\n nativeQuery = true,\n queryRewriter = MyRepository.class)\n List<User> findByNativeQuery(String param);\n\n @Query(value = \"select original_user_alias from User original_user_alias\",\n queryRewriter = MyRepository.class)\n List<User> findByNonNativeQuery(String param);\n\n @Override\n default String rewrite(String query, Sort sort) {\n return query.replaceAll(\"original_user_alias\", \"rewritten_user_alias\");\n }\n}\n----\n====\n\nDepending on what you're doing with your `QueryRewriter`, it may be advisable to have more than one, each registered with the application context.\n\nNOTE: In a CDI-based environment, Spring Data JPA will search the `BeanManager` for instances of your implementation of\n`QueryRewriter`.\n\n[[jpa.query-methods.sorting]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Applying a QueryRewriter", "heading_level": 3, "file_order": 12, "section_index": 12, "content_hash": "340df43d7085b1ec286b2eb8f7cd302db603bd7fc78ade7e249cea3a6f177b6e", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:8436a744efe00b58cf61837e8c973850665da26b686aec07bffcc6ab624fa4c6", "content": "Sorting can be done by either providing a `PageRequest` or by using `Sort` directly. The properties actually used within the `Order` instances of `Sort` need to match your domain model, which means they need to resolve to either a property or an alias used within the query. The JPQL defines this as a state field path expression.\n\nNOTE: Using any non-referenceable path expression leads to an `Exception`.\n\nHowever, using `Sort` together with xref:jpa/query-methods.adoc#jpa.query-methods.at-query[`@Query`] lets you sneak in non-path-checked `Order` instances containing functions within the `ORDER BY` clause. This is possible because the `Order` is appended to the given query string. By default, Spring Data JPA rejects any `Order` instance containing function calls, but you can use `JpaSort.unsafe` to add potentially unsafe ordering.\n\nThe following example uses `Sort` and `JpaSort`, including an unsafe option on `JpaSort`:\n\n.Using `Sort` and `JpaSort`\n====\n[source, java]\n----\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n @Query(\"select u from User u where u.lastname like ?1%\")\n List<User> findByAndSort(String lastname, Sort sort);\n\n @Query(\"select u.id, LENGTH(u.firstname) as fn_len from User u where u.lastname like ?1%\")\n List<Object[]> findByAsArrayAndSort(String lastname, Sort sort);\n}\n\nrepo.findByAndSort(\"lannister\", Sort.by(\"firstname\")); <1>\nrepo.findByAndSort(\"stark\", Sort.by(\"LENGTH(firstname)\")); <2>\nrepo.findByAndSort(\"targaryen\", JpaSort.unsafe(\"LENGTH(firstname)\")); <3>\nrepo.findByAsArrayAndSort(\"bolton\", Sort.by(\"fn_len\")); <4>\n----\n\n<1> Valid `Sort` expression pointing to property in domain model.\n<2> Invalid `Sort` containing function call.\nThrows Exception.\n<3> Valid `Sort` containing explicitly _unsafe_ `Order`.\n<4> Valid `Sort` expression pointing to aliased function.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Using Sort", "heading_level": 2, "file_order": 12, "section_index": 13, "content_hash": "8436a744efe00b58cf61837e8c973850665da26b686aec07bffcc6ab624fa4c6", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:e02a8c35b00f2b34c03268e81fff02b5dd990e556b2a04fadc703ff9b35eecef", "content": "`JpaSort.unsafe(…)` operates in two modes:\n\n* When used with derived Queries or String-based Queries, the order string is appended to the query.\n* When used with Query by Example or Specifications (that use `CriteriaQuery`), order expressions are parsed and added to the `CriteriaQuery` as expressions.\nQuery expressions can contain function calls, various clauses (such as `CASE WHEN`, arithmetic expressions) or property paths.\nOrder translation does not support subquery expressions, `TREAT` and `CAST`.\n\n[[jpa.query-methods.paging]]\n\n[[jpa.query-methods.scroll]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "JpaSort.unsafe(…) limitations", "heading_level": 3, "file_order": 12, "section_index": 14, "content_hash": "e02a8c35b00f2b34c03268e81fff02b5dd990e556b2a04fadc703ff9b35eecef", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:a50e3de2b1cae5cdf920320bc9dfefcd39444554fdbdb8246cbfe953ad21c291", "content": "When working with large data sets, <<repositories.scrolling,scrolling>> can help to process those results efficiently without loading all results into memory.\n\nYou have multiple options to consume large query results:\n\n1. xref:repositories/query-methods-details.adoc#repositories.paging-and-sorting[Paging].\nYou have learned in the previous chapter about `Pageable` and `PageRequest`.\n2. <<repositories.scrolling.offset,Offset-based scrolling>>.\nThis is a lighter variant than paging because it does not require the total result count.\n3. <<repositories.scrolling.keyset,Keyset-based scrolling>>.\nThis method avoids https://use-the-index-luke.com/no-offset[the shortcomings of offset-based result retrieval by leveraging database indexes].\n\nRead more on xref:repositories/query-methods-details.adoc#repositories.scrolling.guidance[which method to use best] for your particular arrangement.\n\nYou can use the Scroll API with query methods, xref:repositories/query-by-example.adoc[Query-by-Example], and xref:repositories/core-extensions.adoc#core.extensions.querydsl[Querydsl].\n\nNOTE: Scrolling with String-based query methods is not yet supported.\nScrolling is also not supported using stored `@Procedure` query methods.\n\n[[jpa.named-parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Scrolling Large Query Results", "heading_level": 2, "file_order": 12, "section_index": 15, "content_hash": "a50e3de2b1cae5cdf920320bc9dfefcd39444554fdbdb8246cbfe953ad21c291", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:65aa86817fa5cc640d92cd787f4fee57e624a50803527838400717fed8c5dc0a", "content": "By default, Spring Data JPA uses position-based parameter binding, as described in all the preceding examples.\nThis makes query methods a little error-prone when refactoring regarding the parameter position.\nTo solve this issue, you can use `@Param` annotation to give a method parameter a concrete name and bind the name in the query, as shown in the following example:\n\n.Using named parameters\n====\n[source,java]\n----\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n @Query(\"select u from User u where u.firstname = :firstname or u.lastname = :lastname\")\n User findByLastnameOrFirstname(@Param(\"lastname\") String lastname,\n @Param(\"firstname\") String firstname);\n}\n----\n====\n\nNOTE: The method parameters are switched according to their order in the defined query.\n\nNOTE: As of version 4, Spring fully supports Java 8’s parameter name discovery based on the `-parameters` compiler flag. By using this flag in your build as an alternative to debug information, you can omit the `@Param` annotation for named parameters.\n\n[[jpa.query.spel-expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Using Named Parameters", "heading_level": 2, "file_order": 12, "section_index": 16, "content_hash": "65aa86817fa5cc640d92cd787f4fee57e624a50803527838400717fed8c5dc0a", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:53ecf2c263e3f2de82ff9009c06c3bb32fb1d94fe7931563aff69d1aad691ac5", "content": "We support the usage of restricted expressions in manually defined queries that are defined with `@Query`.\nUpon the query being run, these expressions are evaluated against a predefined set of variables.\n\nNOTE: If you are not familiar with Value Expressions, please refer to xref:jpa/value-expressions.adoc[] to learn about SpEL Expressions and Property Placeholders.\n\nSpring Data JPA supports a template variable called `entityName`.\nIts usage is `select x from #{#entityName} x`.\nIt inserts the `entityName` of the domain type associated with the given repository.\nThe `entityName` is resolved as follows:\n* If the domain type has set the name property on the `@Entity` annotation, it is used.\n* Otherwise, the simple class-name of the domain type is used.\n\nThe following example demonstrates one use case for the `+#{#entityName}+` expression in a query string where you want to define a repository interface with a query method and a manually defined query:\n\n.Using SpEL expressions in repository query methods: entityName\n====\n[source, java]\n----\n@Entity\npublic class User {\n\n @Id\n @GeneratedValue\n Long id;\n\n String lastname;\n}\n\npublic interface UserRepository extends JpaRepository<User,Long> {\n\n @Query(\"select u from #{#entityName} u where u.lastname = ?1\")\n List<User> findByLastname(String lastname);\n}\n----\n====\n\nTo avoid stating the actual entity name in the query string of a `@Query` annotation, you can use the `+#{#entityName}+` variable.\n\nNOTE: The `entityName` can be customized by using the `@Entity` annotation.\nCustomizations in `orm.xml` are not supported for the SpEL expressions.\n\nOf course, you could have just used `User` in the query declaration directly, but that would require you to change the query as well.\nThe reference to `#entityName` picks up potential future remappings of the `User` class to a different entity name (for example, by using `@Entity(name = \"MyUser\")`.\n\nAnother use case for the `#{#entityName}` expression in a query string is if you want to define a generic repository interface with specialized repository interfaces for a concrete domain type.\nTo not repeat the definition of custom query methods on the concrete interfaces, you can use the entity name expression in the query string of the `@Query` annotation in the generic repository interface, as shown in the following example:\n\n.Using SpEL expressions in Repository Query Methods: entityName with Inheritance\n====\n[source, java]\n----\n@MappedSuperclass\npublic abstract class AbstractMappedType {\n …\n String attribute;\n}\n\n@Entity\npublic class ConcreteType extends AbstractMappedType { … }\n\n@NoRepositoryBean\npublic interface MappedTypeRepository<T extends AbstractMappedType>\n extends Repository<T, Long> {\n\n @Query(\"select t from #{#entityName} t where t.attribute = ?1\")\n List<T> findAllByAttribute(String attribute);\n}\n\npublic interface ConcreteRepository\n extends MappedTypeRepository<ConcreteType> { … }\n----\n====\n\nIn the preceding example, the `MappedTypeRepository` interface is the common parent interface for a few domain types extending `AbstractMappedType`.\nIt also defines the generic `findAllByAttribute(…)` method, which can be used on instances of the specialized repository interfaces.\nIf you now invoke `findAllByAttribute(…)` on `ConcreteRepository`, the query becomes `select t from ConcreteType t where t.attribute = ?1`.\n\nYou can also use Expressions to control arguments may also be used to control method arguments.\nIn these expressions the entity name is not available, but the arguments are.\nThey can be accessed by name or index as demonstrated in the following example.\n\n.Using Value Expressions in Repository Query Methods: Accessing Arguments\n====\n[source, java]\n----\n@Query(\"select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}\")\nList<User> findByFirstnameAndCurrentUserWithCustomQuery(String firstname);\n----\n====\n\nFor `like`-conditions one often wants to append `%` to the beginning or the end of a String valued parameter.\nThis can be done by appending or prefixing a bind parameter marker or a SpEL expression with `%`.\nAgain the following example demonstrates this.\n\n.Using Value Expressions in Repository Query Methods: Wildcard shortcut\n====\n[source, java]\n----\n@Query(\"select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%\")\nList<User> findByLastnameWithSpelExpression(@Param(\"lastname\") String lastname);\n----\n====\n\nWhen using `like`-conditions with values that are coming from a not secure source the values should be sanitized so they can't contain any wildcards and thereby allow attackers to select more data than they should be able to.\nFor this purpose the `escape(String)` method is made available in the SpEL context.\nIt prefixes all instances of `_` and `%` in the first argument with the single character from the second argument.\nIn combination with the `escape` clause of the `like` expression available in JPQL and standard SQL this allows easy cleaning of bind parameters.\n\n.Using Value Expressions in Repository Query Methods: Sanitizing Input Values\n====\n[source, java]\n----\n@Query(\"select u from User u where u.firstname like %?#{escape([0])}% escape ?#{escapeCharacter()}\")\nList<User> findContainingEscaped(String namePart);\n----\n====\n\nGiven this method declaration in a repository interface `findContainingEscaped(\"Peter_\")` will find `Peter_Parker` but not `Peter Parker`.\nThe escape character used can be configured by setting the `escapeCharacter` of the `@EnableJpaRepositories` annotation.\nNote that the method `escape(String)` available in the SpEL context will only escape the SQL and JPQL standard wildcards `_` and `%`.\nIf the underlying database or the JPA implementation supports additional wildcards these will not get escaped.\n\n.Using Value Expressions in Repository Query Methods: Configuration Properties\n====\n[source,java]\n----\n@Query(\"select u from User u where u.applicationName = ?${spring.application.name:unknown}\")\nList<User> findContainingEscaped(String namePart);\n----\n====\n\nYou can refer in your query methods also to configuration property names including fallbacks if you wish to resolve a property from `Environment` during runtime.\nThe property is being evaluated upon query execution.\nTypically, property placeholders resolve to String-like values.\n\n[[jpa.query.other-methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Templated Queries and Expressions", "heading_level": 2, "file_order": 12, "section_index": 17, "content_hash": "53ecf2c263e3f2de82ff9009c06c3bb32fb1d94fe7931563aff69d1aad691ac5", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:c9eb4253292660300033625a174aed67e2686e46a968ba39a06fe9953b178f49", "content": "Spring Data JPA offers many ways to build queries.\nBut sometimes, your query may simply be too complicated for the techniques offered.\nIn that situation, consider:\n\n* If you haven't already, simply write the query yourself using xref:jpa/query-methods.adoc#jpa.query-methods.at-query[`@Query`].\n* If that doesn't fit your needs, consider implementing a xref:repositories/custom-implementations.adoc[custom implementation]. This lets you register a method in your repository while leaving the implementation completely up to you. This gives you the ability to:\n** Talk directly to the `EntityManager` (writing pure HQL/JPQL/EQL/native SQL or using the *Criteria API*)\n** Leverage Spring Framework's `JdbcTemplate` (native SQL)\n** Use another 3rd-party database toolkit.\n* Another option is putting your query inside the database and then using either Spring Data JPA's xref:jpa/stored-procedures.adoc[`@StoredProcedure` annotation] or if it's a database function using the xref:jpa/query-methods.adoc#jpa.query-methods.at-query[`@Query` annotation] and invoking it with a `CALL`.\n\nThese tactics may be most effective when you need maximum control of your query, while still letting Spring Data JPA provide resource management.\n\n[[jpa.modifying-queries]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Other Methods", "heading_level": 2, "file_order": 12, "section_index": 18, "content_hash": "c9eb4253292660300033625a174aed67e2686e46a968ba39a06fe9953b178f49", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:2888f0b968eead007c830c530b4dab5dc9eb78be509231a46985d56409d8510a", "content": "All the previous sections describe how to declare queries to access a given entity or collection of entities.\nYou can add custom modifying behavior by using the custom method facilities described in {spring-data-commons-docs-url}/repositories/custom-implementations.html[Custom Implementations for Spring Data Repositories].\nAs this approach is feasible for comprehensive custom functionality, you can modify queries that only need parameter binding by annotating the query method with `@Modifying`, as shown in the following example:\n\n.Declaring manipulating queries\n====\n[source, java]\n----\n@Modifying\n@Query(\"update User u set u.firstname = ?1 where u.lastname = ?2\")\nint setFixedFirstnameFor(String firstname, String lastname);\n----\n====\n\nDoing so triggers the query annotated to the method as an updating query instead of a selecting one. As the `EntityManager` might contain outdated entities after the execution of the modifying query, we do not automatically clear it (see the https://jakarta.ee/specifications/persistence/2.2/apidocs/javax/persistence/entitymanager[JavaDoc] of `EntityManager.clear()` for details), since this effectively drops all non-flushed changes still pending in the `EntityManager`.\nIf you wish the `EntityManager` to be cleared automatically, you can set the `@Modifying` annotation's `clearAutomatically` attribute to `true`.\n\nThe `@Modifying` annotation is only relevant in combination with the `@Query` annotation.\nDerived query methods or custom methods do not require this annotation.\n\n[[jpa.modifying-queries.derived-delete]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Modifying Queries", "heading_level": 2, "file_order": 12, "section_index": 19, "content_hash": "2888f0b968eead007c830c530b4dab5dc9eb78be509231a46985d56409d8510a", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:3dd1dff30544b680baa05e06f51283fbe6c0a73ffe8c0ca10dd152db5a21c275", "content": "Spring Data JPA also supports derived delete queries that let you avoid having to declare the JPQL query explicitly, as shown in the following example:\n\n.Using a derived delete query\n====\n[source, java]\n----\ninterface UserRepository extends Repository<User, Long> {\n\n void deleteByRoleId(long roleId);\n\n @Modifying\n @Query(\"delete from User u where u.role.id = ?1\")\n void deleteInBulkByRoleId(long roleId);\n}\n----\n====\n\nAlthough the `deleteByRoleId(…)` method looks like it basically produces the same result as the `deleteInBulkByRoleId(…)`, there is an important difference between the two method declarations in terms of the way they are run.\nAs the name suggests, the latter method issues a single JPQL query (the one defined in the annotation) against the database.\nThis means even currently loaded instances of `User` do not see lifecycle callbacks invoked.\n\nTo make sure lifecycle queries are actually invoked, an invocation of `deleteByRoleId(…)` runs a query and then deletes the returned instances one by one, so that the persistence provider can actually invoke `@PreRemove` callbacks on those entities.\n\nIn fact, a derived delete query is a shortcut for running the query and then calling `CrudRepository.delete(Iterable<User> users)` on the result and keeping behavior in sync with the implementations of other `delete(…)` methods in `CrudRepository`.\n\nNOTE: When deleting a lot of objects you will need to consider the performance implications to ensure sufficient memory availability.\nAll resulting objects are loaded into memory before being deleted and are held in the session until flushing or completing the transaction.\n\n[[jpa.query-hints]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Derived Delete Queries", "heading_level": 3, "file_order": 12, "section_index": 20, "content_hash": "3dd1dff30544b680baa05e06f51283fbe6c0a73ffe8c0ca10dd152db5a21c275", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:2f68d2479c587185d33114507b86dcc6a0ddb90456bbaac931b5b00c7e81adbd", "content": "To apply JPA query hints to the queries declared in your repository interface, you can use the `@QueryHints` annotation. It takes an array of JPA `@QueryHint` annotations plus a boolean flag to potentially disable the hints applied to the additional count query triggered when applying pagination, as shown in the following example:\n\n.Using QueryHints with a repository method\n====\n[source, java]\n----\npublic interface UserRepository extends Repository<User, Long> {\n\n @QueryHints(value = { @QueryHint(name = \"name\", value = \"value\")},\n forCounting = false)\n Page<User> findByLastname(String lastname, Pageable pageable);\n}\n----\n====\nThe preceding declaration would apply the configured `@QueryHint` for that actually query but omit applying it to the count query triggered to calculate the total number of pages.\n\n[[jpa.query-hints.comments]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Applying Query Hints", "heading_level": 2, "file_order": 12, "section_index": 21, "content_hash": "2f68d2479c587185d33114507b86dcc6a0ddb90456bbaac931b5b00c7e81adbd", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:db8604647371fd8e102c4f312696bb02c22d473cbd8b9d18ff5242b104e599cd", "content": "Sometimes, you need to debug a query based upon database performance.\nThe query your database administrator shows you may look VERY different than what you wrote using `@Query`, or it may look\nnothing like what you presume Spring Data JPA has generated regarding a custom finder or if you used query by example.\n\nTo make this process easier, you can insert custom comments into almost any JPA operation, whether its a query or other operation\nby applying the `@Meta` annotation.\n\n.Apply `@Meta` annotation to repository operations\n====\n[source, java]\n----\npublic interface RoleRepository extends JpaRepository<Role, Integer> {\n\n\t@Meta(comment = \"find roles by name\")\n\tList<Role> findByName(String name);\n\n\t@Override\n\t@Meta(comment = \"find roles using QBE\")\n\t<S extends Role> List<S> findAll(Example<S> example);\n\n\t@Meta(comment = \"count roles for a given name\")\n\tlong countByName(String name);\n\n\t@Override\n\t@Meta(comment = \"exists based on QBE\")\n\t<S extends Role> boolean exists(Example<S> example);\n}\n----\n====\n\nThis sample repository has a mixture of custom finders as well as overriding the inherited operations from `JpaRepository`.\nEither way, the `@Meta` annotation lets you add a `comment` that will be inserted into queries before they are sent to the database.\n\nIt's also important to note that this feature isn't confined solely to queries. It extends to the `count` and `exists` operations.\nAnd while not shown, it also extends to certain `delete` operations.\n\nIMPORTANT: While we have attempted to apply this feature everywhere possible, some operations of the underlying `EntityManager` don't support comments. For example, `entityManager.createQuery()` is clearly documented as supporting comments, but `entityManager.find()` operations do not.\n\nNeither JPQL logging nor SQL logging is a standard in JPA, so each provider requires custom configuration, as shown the sections below.\n\n[[activating-hibernate-comments]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Adding Comments to Queries", "heading_level": 3, "file_order": 12, "section_index": 22, "content_hash": "db8604647371fd8e102c4f312696bb02c22d473cbd8b9d18ff5242b104e599cd", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:e74f9d1dbf8cd4596be4404e354ddb428a9b2c4f43f4c41de4a9674a28357be1", "content": "To activate query comments in Hibernate, you must set `hibernate.use_sql_comments` to `true`.\n\nIf you are using Java-based configuration settings, this can be done like this:\n\n.Java-based JPA configuration\n====\n[source, java]\n----\n@Bean\npublic Properties jpaProperties() {\n\n\tProperties properties = new Properties();\n\tproperties.setProperty(\"hibernate.use_sql_comments\", \"true\");\n\treturn properties;\n}\n----\n====\n\nIf you have a `persistence.xml` file, you can apply it there:\n\n.`persistence.xml`-based configuration\n====\n[source, xml]\n----\n<persistence-unit name=\"my-persistence-unit\">\n\n ...registered classes...\n\n\t<properties>\n <property name=\"hibernate.use_sql_comments\" value=\"true\" />\n\t</properties>\n</persistence-unit>\n----\n====\n\nFinally, if you are using Spring Boot, then you can set it up inside your `application.properties` file:\n\n.Spring Boot property-based configuration\n====\n----\nspring.jpa.properties.hibernate.use_sql_comments=true\n----\n====\n\n[[activating-eclipselink-comments]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Activating Hibernate comments", "heading_level": 4, "file_order": 12, "section_index": 23, "content_hash": "e74f9d1dbf8cd4596be4404e354ddb428a9b2c4f43f4c41de4a9674a28357be1", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:5e47b5251a8c733d723b9aa5c06b65c858acaff8153303e7a35b4bc35e2fddbc", "content": "To activate query comments in EclipseLink, you must set `eclipselink.logging.level.sql` to `FINE`.\n\nIf you are using Java-based configuration settings, this can be done like this:\n\n.Java-based JPA configuration\n====\n[source, java]\n----\n@Bean\npublic Properties jpaProperties() {\n\n\tProperties properties = new Properties();\n\tproperties.setProperty(\"eclipselink.logging.level.sql\", \"FINE\");\n\treturn properties;\n}\n----\n====\n\nIf you have a `persistence.xml` file, you can apply it there:\n\n.`persistence.xml`-based configuration\n====\n[source, xml]\n----\n<persistence-unit name=\"my-persistence-unit\">\n\n ...registered classes...\n\n\t<properties>\n <property name=\"eclipselink.logging.level.sql\" value=\"FINE\" />\n\t</properties>\n</persistence-unit>\n----\n====\n\nFinally, if you are using Spring Boot, then you can set it up inside your `application.properties` file:\n\n.Spring Boot property-based configuration\n====\n----\nspring.jpa.properties.eclipselink.logging.level.sql=FINE\n----\n====\n\n[[jpa.entity-graph]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Activating EclipseLink comments", "heading_level": 4, "file_order": 12, "section_index": 24, "content_hash": "5e47b5251a8c733d723b9aa5c06b65c858acaff8153303e7a35b4bc35e2fddbc", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:bb329cee5d8b02321f00b58b81070f7ba16943192d39303e835b4abd61c6e8cb", "content": "The JPA 2.1 specification introduced support for specifying Fetch- and LoadGraphs that we also support with the `@EntityGraph` annotation, which lets you reference a `@NamedEntityGraph` definition. You can use that annotation on an entity to configure the fetch plan of the resulting query. The type (`Fetch` or `Load`) of the fetching can be configured by using the `type` attribute on the `@EntityGraph` annotation. See the JPA 2.1 Spec 3.7.4 for further reference.\n\nThe following example shows how to define a named entity graph on an entity:\n\n.Defining a named entity graph on an entity.\n====\n[source, java]\n----\n@Entity\n@NamedEntityGraph(name = \"GroupInfo.detail\",\n attributeNodes = @NamedAttributeNode(\"members\"))\npublic class GroupInfo {\n\n // default fetch mode is lazy.\n @ManyToMany\n List<GroupMember> members = new ArrayList<GroupMember>();\n\n …\n}\n----\n====\n\nThe following example shows how to reference a named entity graph on a repository query method:\n\n.Referencing a named entity graph definition on a repository query method.\n====\n[source, java]\n----\npublic interface GroupRepository extends CrudRepository<GroupInfo, String> {\n\n @EntityGraph(value = \"GroupInfo.detail\", type = EntityGraphType.LOAD)\n GroupInfo getByGroupName(String name);\n\n}\n----\n====\n\nIt is also possible to define ad hoc entity graphs by using `@EntityGraph`. The provided `attributePaths` are translated into the according `EntityGraph` without needing to explicitly add `@NamedEntityGraph` to your domain types, as shown in the following example:\n\n.Using ad-hoc entity graph definitions on a repository query method\n====\n[source, java]\n----\npublic interface GroupRepository extends CrudRepository<GroupInfo, String> {\n\n @EntityGraph(attributePaths = { \"members\" })\n GroupInfo getByGroupName(String name);\n\n}\n----\n====\n\ninclude::{commons}@data-commons::page$repositories/scrolling.adoc[leveloffset=+1]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/query-methods.adoc", "title": "query-methods", "heading": "Configuring Fetch- and LoadGraphs", "heading_level": 2, "file_order": 12, "section_index": 25, "content_hash": "bb329cee5d8b02321f00b58b81070f7ba16943192d39303e835b4abd61c6e8cb", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/query-methods.adoc"}}
{"id": "sha256:40193cd2c96e6adc59fbf3c76c2d590fd64c2158c3d05fe166abc592de342375", "content": "[[specifications]]\n\nJPA's Criteria API lets you build queries programmatically.\nSpring Data JPA `Specification` provides a small, focused API to express predicates over entities and reuse them across repositories.\nBased on the concept of a specification from Eric Evans' book \"`Domain Driven Design`\", specifications follow the same semantics providing an API to define criteria using JPA.\nTo support specifications, you can extend your repository interface with the `JpaSpecificationExecutor` interface, as follows:\n\n[source, java]\n----\npublic interface CustomerRepository extends CrudRepository<Customer, Long>, JpaSpecificationExecutor<Customer> {\n}\n----\n\nA specification is a predicate over an entity expressed with the Criteria API.\nSpring Data JPA offers two entry points:\n\n* <<predicate-specification,`PredicateSpecification`>>: A flexible, query-type-agnostic interface introduced with Spring Data JPA 4.0.\n* <<specification-interfaces,`Specification`>> (and `UpdateSpecification`, `DeleteSpecification`): Query-bound variants.\n\n[[predicate-specification]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/specifications.adoc", "title": "specifications", "heading": "specifications", "heading_level": 1, "file_order": 13, "section_index": 0, "content_hash": "40193cd2c96e6adc59fbf3c76c2d590fd64c2158c3d05fe166abc592de342375", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/specifications.adoc"}}
{"id": "sha256:bc69ce168d7ca0bcc6ee38391194d1af0ef4e9e4a56ba0b0a52cfe4a78146ada", "content": "The `PredicateSpecification` interface is defined with a minimal set of dependencies allowing broad functional composition:\n\n[source, java]\n----\npublic interface PredicateSpecification<T> {\n Predicate toPredicate(From<?, T> from, CriteriaBuilder builder);\n}\n----\n\nSpecifications can easily be used to build an extensible set of predicates and used with `JpaRepository` removing the need to declare a query (method) for every needed combination as shown in the following example:\n\n.Specifications for a Customer\n====\n[source,java]\n----\nclass CustomerSpecs {\n\n static PredicateSpecification<Customer> isLongTermCustomer() {\n return (from, builder) -> {\n LocalDate date = LocalDate.now().minusYears(2);\n return builder.lessThan(from.get(Customer_.createdAt), date);\n };\n }\n\n static PredicateSpecification<Customer> hasSalesOfMoreThan(MonetaryAmount value) {\n return (from, builder) -> {\n // build predicate for sales > value\n };\n }\n}\n----\n\nThe `Customer_` type is a metamodel type generated using the JPA Metamodel generator (see the link:$$https://docs.jboss.org/hibernate/jpamodelgen/1.3/reference/en-US/html_single/#whatisit$$[Hibernate implementation's documentation for an example]).\nSo the expression, `Customer_.createdAt`, assumes the `Customer` has a `createdAt` attribute of type `Date`.\nBesides that, we have expressed some criteria on a business requirement abstraction level and created executable `Specifications`.\n====\n\nUse a specification directly with a repository:\n\n[source,java]\n----\nList<Customer> customers = customerRepository.findAll(isLongTermCustomer());\n----\n\nSpecifications become most valuable when composed:\n\n[source,java]\n----\nMonetaryAmount amount = new MonetaryAmount(200.0, Currencies.DOLLAR);\nList<Customer> customers = customerRepository.findAll(\n isLongTermCustomer().or(hasSalesOfMoreThan(amount))\n);\n----\n\n[[specification-interfaces]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/specifications.adoc", "title": "specifications", "heading": "PredicateSpecification", "heading_level": 2, "file_order": 13, "section_index": 1, "content_hash": "bc69ce168d7ca0bcc6ee38391194d1af0ef4e9e4a56ba0b0a52cfe4a78146ada", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/specifications.adoc"}}
{"id": "sha256:36c91a0f3f499b6e78c03bbc28b2acff1bf7fe71e4cce73e00c0c1dd2e11a0ce", "content": "The javadoc:org.springframework.data.jpa.domain.Specification[] interface has been available for a much longer time and is tied a particular query type (select, update, delete) as per Criteria API restrictions.\nThe three specification interfaces are defined as follows:\n\n[tabs]\n======\nSpecification::\n+\n====\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\npublic interface Specification<T> {\n Predicate toPredicate(Root<T> root, CriteriaQuery<?> query,\n CriteriaBuilder builder);\n}\n----\n====\n\nUpdateSpecification::\n+\n====\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\npublic interface UpdateSpecification<T> {\n Predicate toPredicate(Root<T> root, CriteriaUpdate<T> update,\n CriteriaBuilder builder);\n}\n----\n====\n\nDeleteSpecification::\n+\n====\n[source,java,indent=0,subs=\"verbatim,quotes\",role=\"tertiary\"]\n----\npublic interface DeleteSpecification<T> {\n Predicate toPredicate(Root<T> root, CriteriaDelete<T> delete,\n CriteriaBuilder builder);\n}\n----\n====\n======\n\n`Specification` objects can be constructed either directly or by reusing `PredicateSpecification` instances, as shown in the following example:\n\n.Specifications for a Customer\n====\n[source, java]\n----\npublic class CustomerSpecs {\n\n public static UpdateSpecification<Customer> updateLastnameByFirstnameAndLastname(String newLastName, String currentFirstname, String currentLastname) {\n return UpdateSpecification<User> updateLastname = UpdateSpecification.<User> update((root, update, criteriaBuilder) -> {\n update.set(\"lastname\", newLastName);\n }).where(hasFirstname(currentFirstname).and(hasLastname(currentLastname)));\n }\n\n public static PredicateSpecification<Customer> hasFirstname(String firstname) {\n return (root, builder) -> {\n return builder.equal(from.get(\"firstname\"), value);\n };\n }\n\n public static PredicateSpecification<Customer> hasLastname(String lastname) {\n return (root, builder) -> {\n // build query here\n };\n }\n}\n----\n====\n\n[[specification-fluent]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/specifications.adoc", "title": "specifications", "heading": "`Specification`, `UpdateSpecification`, `DeleteSpecification`", "heading_level": 2, "file_order": 13, "section_index": 2, "content_hash": "36c91a0f3f499b6e78c03bbc28b2acff1bf7fe71e4cce73e00c0c1dd2e11a0ce", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/specifications.adoc"}}
{"id": "sha256:2839a746e71311c6d3bc3bd1d5eb34d1e9cb35e09766ad6df4b98e422956af06", "content": "`JpaSpecificationExecutor` defines fluent query methods for flexible execution of queries based on `Specification` instances:\n\n1. For `PredicateSpecification`: `findBy(PredicateSpecification<T> spec, Function<? super SpecificationFluentQuery<S>, R> queryFunction)`\n2. For `Specification`: `findBy(Specification<T> spec, Function<? super SpecificationFluentQuery<S>, R> queryFunction)`\n\nAs with other methods, it executes a query derived from a `Specification`.\nHowever, the query function allows you to take control over aspects of query execution that you cannot dynamically control otherwise.\nYou do so by invoking the various intermediate and terminal methods of `SpecificationFluentQuery`.\n\n**Intermediate methods**\n\n* `sortBy`: Apply an ordering for your result.\nRepeated method calls append each `Sort` (note that `page(Pageable)` using a sorted `Pageable` overrides any previous sort order).\n* `limit`: Limit the result count.\n* `as`: Specify the type to be read or projected to.\n* `project`: Limit the queries properties.\n\n**Terminal methods**\n\n* `first`, `firstValue`: Return the first value. `first` returns an `Optional<T>` or `Optional.empty()` if the query did not yield any result. `firstValue` is its nullable variant without the need to use `Optional`.\n* `one`, `oneValue`: Return the one value. `one` returns an `Optional<T>` or `Optional.empty()` if the query did not yield any result. `oneValue` is its nullable variant without the need to use `Optional`.\nThrows `IncorrectResultSizeDataAccessException` if more than one match found.\n* `all`: Return all results as a `List<T>`.\n* `page(Pageable)`: Return all results as a `Page<T>`.\n* `slice(Pageable)`: Return all results as a `Slice<T>`.\n* `scroll(ScrollPosition)`: Use scrolling (offset, keyset) to retrieve results as a `Window<T>`.\n* `stream()`: Return a `Stream<T>` to process results lazily.\nThe stream is stateful and must be closed after use.\n* `count` and `exists`: Return the count of matching entities or whether any match exists.\n\nNOTE: Intermediate and terminal methods must be invoked within the query function.\n\n.Use the fluent API to get a projected `Page`, ordered by `lastname`\n====\n[source,java]\n----\nPage<CustomerProjection> page = repository.findBy(spec,\n q -> q.as(CustomerProjection.class)\n .page(PageRequest.of(0, 20, Sort.by(\"lastname\")))\n);\n----\n====\n\n.Use the fluent API to get the last of potentially many results, ordered by `lastname`\n====\n[source,java]\n----\nOptional<Customer> match = repository.findBy(spec,\n q -> q.sortBy(Sort.by(\"lastname\").descending())\n .first()\n);\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/specifications.adoc", "title": "specifications", "heading": "Fluent API", "heading_level": 2, "file_order": 13, "section_index": 3, "content_hash": "2839a746e71311c6d3bc3bd1d5eb34d1e9cb35e09766ad6df4b98e422956af06", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/specifications.adoc"}}
{"id": "sha256:d721e3592f918300a5a836a60121153564595bcaf589008bcf63eba96a52f1a6", "content": "[[jpa.stored-procedures]]\n\nThe JPA 2.1 specification introduced support for calling stored procedures by using the JPA criteria query API.\nWe Introduced the `@Procedure` annotation for declaring stored procedure metadata on a repository method.\n\nThe examples to follow use the following stored procedure:\n\n.The definition of the `plus1inout` procedure in HSQL DB.\n====\n[source, sql]\n----\n/;\nDROP procedure IF EXISTS plus1inout\n/;\nCREATE procedure plus1inout (IN arg int, OUT res int)\nBEGIN ATOMIC\n set res = arg + 1;\nEND\n/;\n----\n====\n\nMetadata for stored procedures can be configured by using the `NamedStoredProcedureQuery` annotation on an entity type.\n\n[[jpa.stored-procedure-entity-metadata]]\n.StoredProcedure metadata definitions on an entity.\n====\n[source, java]\n----\n@Entity\n@NamedStoredProcedureQuery(name = \"User.plus1\", procedureName = \"plus1inout\", parameters = {\n @StoredProcedureParameter(mode = ParameterMode.IN, name = \"arg\", type = Integer.class),\n @StoredProcedureParameter(mode = ParameterMode.OUT, name = \"res\", type = Integer.class) })\npublic class User {}\n----\n====\n\nNote that `@NamedStoredProcedureQuery` has two different names for the stored procedure.\n`name` is the name JPA uses. `procedureName` is the name the stored procedure has in the database.\n\nYou can reference stored procedures from a repository method in multiple ways.\nThe stored procedure to be called can either be defined directly by using the `value` or `procedureName` attribute of the `@Procedure` annotation.\nThis refers directly to the stored procedure in the database and ignores any configuration via `@NamedStoredProcedureQuery`.\n\nAlternatively you may specify the `@NamedStoredProcedureQuery.name` attribute as the `@Procedure.name` attribute.\nIf neither `value`, `procedureName` nor `name` is configured, the name of the repository method is used as the `name` attribute.\n\nThe following example shows how to reference an explicitly mapped procedure:\n\n[[jpa.stored-procedure-reference]]\n.Referencing explicitly mapped procedure with name \"plus1inout\" in database.\n====\n[source, java]\n----\n@Procedure(\"plus1inout\")\nInteger explicitlyNamedPlus1inout(Integer arg);\n----\n====\n\nThe following example is equivalent to the previous one but uses the `procedureName` alias:\n\n.Referencing implicitly mapped procedure with name \"plus1inout\" in database via `procedureName` alias.\n====\n[source, java]\n----\n@Procedure(procedureName = \"plus1inout\")\nInteger callPlus1InOut(Integer arg);\n----\n====\n\nThe following is again equivalent to the previous two but using the method name instead of an explicit annotation attribute.\n\n.Referencing implicitly mapped named stored procedure \"User.plus1\" in `EntityManager` by using the method name.\n====\n[source, java]\n----\n@Procedure\nInteger plus1inout(@Param(\"arg\") Integer arg);\n----\n====\n\nThe following example shows how to reference a stored procedure by referencing the `@NamedStoredProcedureQuery.name` attribute.\n\n.Referencing explicitly mapped named stored procedure \"User.plus1IO\" in `EntityManager`.\n====\n[source, java]\n----\n@Procedure(name = \"User.plus1IO\")\nInteger entityAnnotatedCustomNamedProcedurePlus1IO(@Param(\"arg\") Integer arg);\n----\n====\n\nIf the stored procedure getting called has a single out parameter that parameter may be returned as the return value of the method.\nIf there are multiple out parameters specified in a `@NamedStoredProcedureQuery` annotation those can be returned as a `Map` with the key being the parameter name given in the `@NamedStoredProcedureQuery` annotation.\n\nNOTE: Note that if the stored procedure returns a `ResultSet` then any `OUT` parameters are omitted as Java can only return a single method return value unless the method declares a `Map` return type.\n\nThe following example shows how to obtain multiple `OUT` parameters if the stored procedure has multiple `OUT` parameters and is registered as `@NamedStoredProcedureQuery`. `@NamedStoredProcedureQuery` registration is required to provide parameter metadata.\n\n.StoredProcedure metadata definitions on an entity.\n====\n[source,java]\n----\n@Entity\n@NamedStoredProcedureQuery(name = \"User.multiple_out_parameters\", procedureName = \"multiple_out_parameters\", parameters = {\n @StoredProcedureParameter(mode = ParameterMode.IN, name = \"arg\", type = Integer.class),\n @StoredProcedureParameter(mode = ParameterMode.REF_CURSOR, name = \"some_cursor\", type = void.class),\n @StoredProcedureParameter(mode = ParameterMode.OUT, name = \"res\", type = Integer.class) })\npublic class User {}\n----\n====\n\n.Returning multiple OUT parameters\n====\n[source,java]\n----\n@Procedure(name = \"User.multiple_out_parameters\")\nMap<String, Object> returnsMultipleOutParameters(@Param(\"arg\") Integer arg);\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/stored-procedures.adoc", "title": "stored-procedures", "heading": "stored-procedures", "heading_level": 1, "file_order": 14, "section_index": 0, "content_hash": "d721e3592f918300a5a836a60121153564595bcaf589008bcf63eba96a52f1a6", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/stored-procedures.adoc"}}
{"id": "sha256:bd5127cd672c450dd12e7c300111ff821994eb73cca383cfd8f871dc5bd80b89", "content": "[[transactions]]\n\nBy default, methods inherited from `CrudRepository` inherit the transactional configuration from javadoc:org.springframework.data.jpa.repository.support.SimpleJpaRepository[].\nFor read operations, the transaction configuration `readOnly` flag is set to `true`.\nAll others are configured with a plain `@Transactional` so that default transaction configuration applies.\nRepository methods that are backed by transactional repository fragments inherit the transactional attributes from the actual fragment method.\n\nIf you need to tweak transaction configuration for one of the methods declared in a repository, redeclare the method in your repository interface, as follows:\n\n.Custom transaction configuration for CRUD\n====\n[source, java]\n----\npublic interface UserRepository extends CrudRepository<User, Long> {\n\n @Override\n @Transactional(timeout = 10)\n public List<User> findAll();\n\n // Further query method declarations\n}\n----\nDoing so causes the `findAll()` method to run with a timeout of 10 seconds and without the `readOnly` flag.\n====\n\nAnother way to alter transactional behaviour is to use a facade or service implementation that (typically) covers more than one repository. Its purpose is to define transactional boundaries for non-CRUD operations. The following example shows how to use such a facade for more than one repository:\n\n.Using a facade to define transactions for multiple repository calls\n====\n[source, java]\n----\n@Service\npublic class UserManagementImpl implements UserManagement {\n\n private final UserRepository userRepository;\n private final RoleRepository roleRepository;\n\n public UserManagementImpl(UserRepository userRepository,\n RoleRepository roleRepository) {\n this.userRepository = userRepository;\n this.roleRepository = roleRepository;\n }\n\n @Transactional\n public void addRoleToAllUsers(String roleName) {\n\n Role role = roleRepository.findByName(roleName);\n\n for (User user : userRepository.findAll()) {\n user.addRole(role);\n userRepository.save(user);\n }\n }\n}\n----\nThis example causes call to `addRoleToAllUsers(…)` to run inside a transaction (participating in an existing one or creating a new one if none are already running). The transaction configuration at the repositories is then neglected, as the outer transaction configuration determines the actual one used. Note that you must activate `<tx:annotation-driven />` or use `@EnableTransactionManagement` explicitly to get annotation-based configuration of facades to work.\nThis example assumes you use component scanning.\n\nNote that the call to `save` is not strictly necessary from a JPA point of view, but should still be there in order to stay consistent to the repository abstraction offered by Spring Data.\n====\n\n[[transactional-query-methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/transactions.adoc", "title": "transactions", "heading": "transactions", "heading_level": 1, "file_order": 15, "section_index": 0, "content_hash": "bd5127cd672c450dd12e7c300111ff821994eb73cca383cfd8f871dc5bd80b89", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/transactions.adoc"}}
{"id": "sha256:e237abe5d7a0dc18e8444617baf04f51bc3f2a3d3a71c448f67f97549f02b9b9", "content": "Declared query methods (including default methods) do not get any transaction configuration applied by default.\nTo run those methods transactionally, use `@Transactional` at the repository interface you define, as shown in the following example:\n\n.Using @Transactional at query methods\n====\n[source, java]\n----\n@Transactional(readOnly = true)\ninterface UserRepository extends JpaRepository<User, Long> {\n\n List<User> findByLastname(String lastname);\n\n @Modifying\n @Transactional\n @Query(\"delete from User u where u.active = false\")\n void deleteInactiveUsers();\n}\n----\nTypically, you want the `readOnly` flag to be set to `true`, as most of the query methods only read data. In contrast to that, `deleteInactiveUsers()` makes use of the `@Modifying` annotation and overrides the transaction configuration. Thus, the method runs with the `readOnly` flag set to `false`.\n====\n\n[NOTE]\n====\nYou can use transactions for read-only queries and mark them as such by setting the `readOnly` flag. Doing so does not, however, act as a check that you do not trigger a manipulating query (although some databases reject `INSERT` and `UPDATE` statements inside a read-only transaction). The `readOnly` flag is instead propagated as a hint to the underlying JDBC driver for performance optimizations. Furthermore, Spring performs some optimizations on the underlying JPA provider. For example, when used with Hibernate, the flush mode is set to `NEVER` when you configure a transaction as `readOnly`, which causes Hibernate to skip dirty checks (a noticeable improvement on large object trees).\n====\n\n[NOTE]\n====\nWhile examples discuss `@Transactional` usage on the repository, we generally recommend declaring transaction boundaries when starting a unit of work to ensure proper consistency and desired transaction participation.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/transactions.adoc", "title": "transactions", "heading": "Transactional query methods", "heading_level": 2, "file_order": 15, "section_index": 1, "content_hash": "e237abe5d7a0dc18e8444617baf04f51bc3f2a3d3a71c448f67f97549f02b9b9", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/transactions.adoc"}}
{"id": "sha256:b7ac613eb85acd8f33a34199ed36428642cf280a68b7560b2df37b411ca5fded", "content": "include::{commons}@data-commons::page$value-expressions.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa/value-expressions.adoc", "title": "value-expressions", "heading": "value-expressions", "heading_level": 1, "file_order": 16, "section_index": 0, "content_hash": "b7ac613eb85acd8f33a34199ed36428642cf280a68b7560b2df37b411ca5fded", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa/value-expressions.adoc"}}
{"id": "sha256:8e9b44400b53dbc606e4a389b77e7e9d995def5d7f568ee68dc4c138fb6e3828", "content": "include::{commons}@data-commons::page$repositories/core-concepts.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/core-concepts.adoc", "title": "core-concepts", "heading": "core-concepts", "heading_level": 1, "file_order": 17, "section_index": 0, "content_hash": "8e9b44400b53dbc606e4a389b77e7e9d995def5d7f568ee68dc4c138fb6e3828", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/core-concepts.adoc"}}
{"id": "sha256:81e019ce75dee61eea59094a236a3871f4c9af62f0fcd3a5c7a87af4b30030f9", "content": "include::{commons}@data-commons::page$repositories/core-domain-events.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/core-domain-events.adoc", "title": "core-domain-events", "heading": "core-domain-events", "heading_level": 1, "file_order": 18, "section_index": 0, "content_hash": "81e019ce75dee61eea59094a236a3871f4c9af62f0fcd3a5c7a87af4b30030f9", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/core-domain-events.adoc"}}
{"id": "sha256:e3cec919442bd63cc3c46de66aefd1d27aca6e40d4c9fad5d5bcfb83baa79a74", "content": "[[core.extensions]]\n\nThis section documents a set of Spring Data extensions that enable Spring Data usage in a variety of contexts.\nCurrently, most of the integration is targeted towards Spring MVC.\n\ninclude::{commons}@data-commons::page$repositories/core-extensions-querydsl.adoc[leveloffset=1]\n\n[[jpa.repositories.queries.type-safe.apt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/core-extensions.adoc", "title": "core-extensions", "heading": "core-extensions", "heading_level": 1, "file_order": 19, "section_index": 0, "content_hash": "e3cec919442bd63cc3c46de66aefd1d27aca6e40d4c9fad5d5bcfb83baa79a74", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/core-extensions.adoc"}}
{"id": "sha256:37c51a225e8eedce1e2661cf491d5e780d5df482201c5bcd114545d191dce81e", "content": "To use Querydsl with Spring Data JPA, you need to set up annotation processing in your build system that generates the `Q` classes.\nWhile you could write the `Q` classes by hand, it is recommended to use the Querydsl annotation processor to generate them for you to keep your `Q` classes in sync with your domain model.\n\nMost Spring Data users do not use Querydsl, so it does not make sense to require additional mandatory dependencies for projects that would not benefit from Querydsl.\nHence, you need to activate annotation processing in your build system.\n\nThe following example shows how to set up annotation processing by mentioning dependencies and compiler config changes in Maven and Gradle:\n\n[tabs]\n======\nMaven::\n+\n[source,xml,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n<dependencies>\n <dependency>\n <groupId>com.querydsl</groupId>\n <artifactId>querydsl-jpa</artifactId>\n <version>${querydslVersion}</version>\n <classifier>jakarta</classifier>\n </dependency>\n</dependencies>\n\n<build>\n <plugins>\n <plugin>\n <groupId>org.apache.maven.plugins</groupId>\n <artifactId>maven-compiler-plugin</artifactId>\n <configuration>\n <annotationProcessorPaths>\n <!-- Explicit opt-in required via annotationProcessors or\n annotationProcessorPaths on Java 22+, see https://bugs.openjdk.org/browse/JDK-8306819 -->\n <annotationProcessorPath>\n <groupId>com.querydsl</groupId>\n <artifactId>querydsl-apt</artifactId>\n <version>${querydslVersion}</version>\n <classifier>jakarta</classifier>\n </annotationProcessorPath>\n <annotationProcessorPath>\n <groupId>jakarta.persistence</groupId>\n <artifactId>jakarta.persistence-api</artifactId>\n </annotationProcessorPath>\n </annotationProcessorPaths>\n\n <!-- Recommended: Some IDE's might require this configuration to include generated sources for IDE usage -->\n <generatedTestSourcesDirectory>target/generated-test-sources</generatedTestSourcesDirectory>\n <generatedSourcesDirectory>target/generated-sources</generatedSourcesDirectory>\n </configuration>\n </plugin>\n </plugins>\n</build>\n----\n\nGradle::\n+\n====\n[source,groovy,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\ndependencies {\n\n implementation 'com.querydsl:querydsl-jpa:${querydslVersion}:jakarta'\n annotationProcessor 'com.querydsl:querydsl-apt:${querydslVersion}:jakarta'\n annotationProcessor 'jakarta.persistence:jakarta.persistence-api'\n\n testAnnotationProcessor 'com.querydsl:querydsl-apt:${querydslVersion}:jakarta'\n testAnnotationProcessor 'jakarta.persistence:jakarta.persistence-api'\n}\n----\n====\n\nMaven (OpenFeign)::\n+\n[source,xml,indent=0,subs=\"verbatim,quotes\",role=\"primary\"]\n----\n<dependencies>\n <dependency>\n <groupId>io.github.openfeign.querydsl</groupId>\n <artifactId>querydsl-jpa</artifactId>\n <version>${querydslVersion}</version>\n </dependency>\n</dependencies>\n\n<build>\n <plugins>\n <plugin>\n <groupId>org.apache.maven.plugins</groupId>\n <artifactId>maven-compiler-plugin</artifactId>\n <configuration>\n <annotationProcessorPaths>\n <!-- Explicit opt-in required via annotationProcessors or\n annotationProcessorPaths on Java 22+, see https://bugs.openjdk.org/browse/JDK-8306819 -->\n <annotationProcessorPath>\n <groupId>io.github.openfeign.querydsl</groupId>\n <artifactId>querydsl-apt</artifactId>\n <version>${querydslVersion}</version>\n <classifier>jpa</classifier>\n </annotationProcessorPath>\n <annotationProcessorPath>\n <groupId>jakarta.persistence</groupId>\n <artifactId>jakarta.persistence-api</artifactId>\n </annotationProcessorPath>\n </annotationProcessorPaths>\n <!-- Recommended: Some IDE's might require this configuration to include generated sources for IDE usage -->\n <generatedTestSourcesDirectory>target/generated-test-sources</generatedTestSourcesDirectory>\n <generatedSourcesDirectory>target/generated-sources</generatedSourcesDirectory>\n </configuration>\n </plugin>\n </plugins>\n</build>\n----\n\nGradle (OpenFeign)::\n+\n====\n[source,groovy,indent=0,subs=\"verbatim,quotes\",role=\"secondary\"]\n----\ndependencies {\n\n implementation \"io.github.openfeign.querydsl:querydsl-jpa:${querydslVersion}\"\n annotationProcessor \"io.github.openfeign.querydsl:querydsl-apt:${querydslVersion}:jpa\"\n annotationProcessor 'jakarta.persistence:jakarta.persistence-api'\n\n testAnnotationProcessor \"io.github.openfeign.querydsl:querydsl-apt:${querydslVersion}:jpa\"\n testAnnotationProcessor 'jakarta.persistence:jakarta.persistence-api'\n}\n----\n====\n======\n\nNote that the setup above shows the simplemost usage omitting any other options or dependencies that your project might require.\n\ninclude::{commons}@data-commons::page$repositories/core-extensions-web.adoc[leveloffset=1]\n\ninclude::{commons}@data-commons::page$repositories/core-extensions-populators.adoc[leveloffset=1]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/core-extensions.adoc", "title": "core-extensions", "heading": "Setting up Annotation Processing", "heading_level": 3, "file_order": 19, "section_index": 1, "content_hash": "37c51a225e8eedce1e2661cf491d5e780d5df482201c5bcd114545d191dce81e", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/core-extensions.adoc"}}
{"id": "sha256:24482ed3029b6d4a5d974d16caa36f4323de383cb3a4c34f1c1f33e7660223ac", "content": "[[jpa.configuration]]\n\nThis section describes configuring Spring Data JPA through either:\n\n* \"`<<jpa.java-config,Annotation-based Configuration>>`\" (Java configuration)\n* \"`<<repositories.create-instances.xml,Spring Namespace>>`\" (XML configuration)\n\n[[jpa.java-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/create-instances.adoc", "title": "create-instances", "heading": "create-instances", "heading_level": 1, "file_order": 20, "section_index": 0, "content_hash": "24482ed3029b6d4a5d974d16caa36f4323de383cb3a4c34f1c1f33e7660223ac", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/create-instances.adoc"}}
{"id": "sha256:34434d33d000aeaf3fc1c710d0035f0c7f36a16e388e4341191a9e3329e1ea20", "content": "The Spring Data JPA repositories support can be activated through both JavaConfig as well as a custom XML namespace, as shown in the following example:\n\n.Spring Data JPA repositories using JavaConfig\n====\n[source, java]\n----\n@Configuration\n@EnableJpaRepositories\n@EnableTransactionManagement\nclass ApplicationConfig {\n\n @Bean\n public DataSource dataSource() {\n\n EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();\n return builder.setType(EmbeddedDatabaseType.HSQL).build();\n }\n\n @Bean\n public LocalContainerEntityManagerFactoryBean entityManagerFactory() {\n\n HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();\n vendorAdapter.setGenerateDdl(true);\n\n LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();\n factory.setJpaVendorAdapter(vendorAdapter);\n factory.setPackagesToScan(\"com.acme.domain\");\n factory.setDataSource(dataSource());\n return factory;\n }\n\n @Bean\n public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {\n\n JpaTransactionManager txManager = new JpaTransactionManager();\n txManager.setEntityManagerFactory(entityManagerFactory);\n return txManager;\n }\n}\n----\n====\nNOTE: You must create `LocalContainerEntityManagerFactoryBean` and not `EntityManagerFactory` directly, since the former also participates in exception translation mechanisms in addition to creating `EntityManagerFactory`.\n\nThe preceding configuration class sets up an embedded HSQL database by using the `EmbeddedDatabaseBuilder` API of `spring-jdbc`. Spring Data then sets up an `EntityManagerFactory` and uses Hibernate as the sample persistence provider. The last infrastructure component declared here is the `JpaTransactionManager`. Finally, the example activates Spring Data JPA repositories by using the `@EnableJpaRepositories` annotation, which essentially carries the same attributes as the XML namespace. If no base package is configured, it uses the one in which the configuration class resides.\n\n[[repositories.create-instances.xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/create-instances.adoc", "title": "create-instances", "heading": "Annotation-based Configuration", "heading_level": 2, "file_order": 20, "section_index": 1, "content_hash": "34434d33d000aeaf3fc1c710d0035f0c7f36a16e388e4341191a9e3329e1ea20", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/create-instances.adoc"}}
{"id": "sha256:c425d69566170e6676a0dbdaf19f535d9654d1d831e9591bca3b4d07d93a8664", "content": "The JPA module of Spring Data contains a custom namespace that allows defining repository beans. It also contains certain features and element attributes that are special to JPA. Generally, the JPA repositories can be set up by using the `repositories` element, as shown in the following example:\n\n.Setting up JPA repositories by using the namespace\n====\n[source, xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:jpa=\"http://www.springframework.org/schema/data/jpa\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/data/jpa\n https://www.springframework.org/schema/data/jpa/spring-jpa.xsd\">\n\n <jpa:repositories base-package=\"com.acme.repositories\" />\n\n</beans>\n----\n====\n\nTIP: Which is better, JavaConfig or XML? XML is how Spring was configured long ago. In today's era of fast-growing Java, record types, annotations, and more, new projects typically use as much pure Java as possible. While there is no immediate plan to remove XML support, some of the newest features MAY not be available through XML.\n\nUsing the `repositories` element it activates persistence exception translation for all beans annotated with `@Repository`, to let exceptions being thrown by the JPA persistence providers be converted into Spring's `DataAccessException` hierarchy.\n\n[[jpa.namespace.custom-namespace-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/create-instances.adoc", "title": "create-instances", "heading": "Spring Namespace", "heading_level": 2, "file_order": 20, "section_index": 2, "content_hash": "c425d69566170e6676a0dbdaf19f535d9654d1d831e9591bca3b4d07d93a8664", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/create-instances.adoc"}}
{"id": "sha256:80fa3c37d87e21932859dae7894210537ea1ada48ed16e55e5fe0f3ad85f3ec0", "content": "Beyond the default attributes of the `repositories` element, the JPA namespace offers additional attributes to let you gain more detailed control over the setup of the repositories:\n\n.Custom JPA-specific attributes of the `repositories` element\n[options = \"autowidth\"]\n|===============\n|`entity-manager-factory-ref`|Explicitly wire the `EntityManagerFactory` to be used with the repositories being detected by the `repositories` element. Usually used if multiple `EntityManagerFactory` beans are used within the application. If not configured, Spring Data automatically looks up the `EntityManagerFactory` bean with the name `entityManagerFactory` in the `ApplicationContext`.\n|`transaction-manager-ref`|Explicitly wire the `PlatformTransactionManager` to be used with the repositories being detected by the `repositories` element. Usually only necessary if multiple transaction managers or `EntityManagerFactory` beans have been configured. Default to a single defined `PlatformTransactionManager` inside the current `ApplicationContext`.\n|===============\n\nNOTE: Spring Data JPA requires a `PlatformTransactionManager` bean named `transactionManager` to be present if no explicit `transaction-manager-ref` is defined.\n\n[[jpa.bootstrap-mode]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/create-instances.adoc", "title": "create-instances", "heading": "Custom Namespace Attributes", "heading_level": 3, "file_order": 20, "section_index": 3, "content_hash": "80fa3c37d87e21932859dae7894210537ea1ada48ed16e55e5fe0f3ad85f3ec0", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/create-instances.adoc"}}
{"id": "sha256:8c4a52cb498bfcb53ca0931ffd7ffe6bf47327ba07165036fc69a8c42bdb246e", "content": "By default, Spring Data JPA repositories are default Spring beans.\nThey are singleton scoped and eagerly initialized.\nDuring startup, they already interact with the JPA `EntityManager` for verification and metadata analysis purposes.\nSpring Framework supports the initialization of the JPA `EntityManagerFactory` in a background thread because that process usually takes up a significant amount of startup time in a Spring application.\nTo make use of that background initialization effectively, we need to make sure that JPA repositories are initialized as late as possible.\n\nAs of Spring Data JPA 2.1 you can now configure a `BootstrapMode` (either via the `@EnableJpaRepositories` annotation or the XML namespace) that takes the following values:\n\n* `DEFAULT` (default) -- Repositories are instantiated eagerly unless explicitly annotated with `@Lazy`.\nThe lazification only has effect if no client bean needs an instance of the repository as that will require the initialization of the repository bean.\n* `LAZY` -- Implicitly declares all repository beans lazy and also causes lazy initialization proxies to be created to be injected into client beans.\nThat means, that repositories will not get instantiated if the client bean is simply storing the instance in a field and not making use of the repository during initialization.\nRepository instances will be initialized and verified upon first interaction with the repository.\n* `DEFERRED` -- Fundamentally the same mode of operation as `LAZY`, but triggering repository initialization in response to an `ContextRefreshedEvent` so that repositories are verified before the application has completely started.\n\n[[jpa.bootstrap-mode.recommendations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/create-instances.adoc", "title": "create-instances", "heading": "Bootstrap Mode", "heading_level": 2, "file_order": 20, "section_index": 4, "content_hash": "8c4a52cb498bfcb53ca0931ffd7ffe6bf47327ba07165036fc69a8c42bdb246e", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/create-instances.adoc"}}
{"id": "sha256:099187121821f2f11ba0ce6ff3d74f5e0fdbf85d6c6ae57ab9d2d9da0fd98944", "content": "If you're not using asynchronous JPA bootstrap stick with the default bootstrap mode.\n\nIn case you bootstrap JPA asynchronously, `DEFERRED` is a reasonable default as it will make sure the Spring Data JPA bootstrap only waits for the `EntityManagerFactory` setup if that itself takes longer than initializing all other application components.\nStill, it makes sure that repositories are properly initialized and validated before the application signals it's up.\n\n`LAZY` is a decent choice for testing scenarios and local development.\nOnce you are pretty sure that repositories can properly bootstrap, or in cases where you are testing other parts of the application, running verification for all repositories might unnecessarily increase the startup time.\nThe same applies to local development in which you only access parts of the application that might need to have a single repository initialized.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/create-instances.adoc", "title": "create-instances", "heading": "Recommendations", "heading_level": 3, "file_order": 20, "section_index": 5, "content_hash": "099187121821f2f11ba0ce6ff3d74f5e0fdbf85d6c6ae57ab9d2d9da0fd98944", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/create-instances.adoc"}}
{"id": "sha256:7683b1e5b22624b11b7d5cdd40595b44c803c27500d716065413b359c457ff8c", "content": "include::{commons}@data-commons::page$repositories/custom-implementations.adoc[]\n\n[[jpa.misc.jpa-context]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/custom-implementations.adoc", "title": "custom-implementations", "heading": "custom-implementations", "heading_level": 1, "file_order": 21, "section_index": 0, "content_hash": "7683b1e5b22624b11b7d5cdd40595b44c803c27500d716065413b359c457ff8c", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/custom-implementations.adoc"}}
{"id": "sha256:fbd6a8b96e8d38e9542b6fda6f03c0b55c9cdc7da929ab387ceebd2cfaac159f", "content": "When working with multiple `EntityManager` instances and xref:repositories/custom-implementations.adoc#repositories.custom-implementations[custom repository implementations], you need to wire the correct `EntityManager` into the repository implementation class. You can do so by explicitly naming the `EntityManager` in the `@PersistenceContext` annotation or, if the `EntityManager` is `@Autowired`, by using `@Qualifier`.\n\nAs of Spring Data JPA 1.9, Spring Data JPA includes a class called `JpaContext` that lets you obtain the `EntityManager` by managed domain class, assuming it is managed by only one of the `EntityManager` instances in the application. The following example shows how to use `JpaContext` in a custom repository:\n\n.Using `JpaContext` in a custom repository implementation\n====\n[source, java]\n----\nclass UserRepositoryImpl implements UserRepositoryCustom {\n\n private final EntityManager em;\n\n @Autowired\n public UserRepositoryImpl(JpaContext context) {\n this.em = context.getEntityManagerByManagedType(User.class);\n }\n\n …\n}\n----\n====\n\nThe advantage of this approach is that, if the domain type gets assigned to a different persistence unit, the repository does not have to be touched to alter the reference to the persistence unit.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/custom-implementations.adoc", "title": "custom-implementations", "heading": "Using `JpaContext` in Custom Implementations", "heading_level": 2, "file_order": 21, "section_index": 1, "content_hash": "fbd6a8b96e8d38e9542b6fda6f03c0b55c9cdc7da929ab387ceebd2cfaac159f", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/custom-implementations.adoc"}}
{"id": "sha256:661a93bfb9c9780b8bb205b092562b371e697955026e3abea11cc0abb0a3fc20", "content": "include::{commons}@data-commons::page$repositories/definition.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/definition.adoc", "title": "definition", "heading": "definition", "heading_level": 1, "file_order": 22, "section_index": 0, "content_hash": "661a93bfb9c9780b8bb205b092562b371e697955026e3abea11cc0abb0a3fc20", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/definition.adoc"}}
{"id": "sha256:8ca895bfddcd8ee24e8f9d5197f423b2399d74f11d14249d9f906762f4b72806", "content": "include::{commons}@data-commons::page$repositories/null-handling.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/null-handling.adoc", "title": "null-handling", "heading": "null-handling", "heading_level": 1, "file_order": 23, "section_index": 0, "content_hash": "8ca895bfddcd8ee24e8f9d5197f423b2399d74f11d14249d9f906762f4b72806", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/null-handling.adoc"}}
{"id": "sha256:cee9024c74aba01f1d045a026f4d5f002bf8f4406ee35950bcba7bcaaeab1216", "content": "[[jpa.projections]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/projections.adoc", "title": "projections", "heading": "projections", "heading_level": 1, "file_order": 24, "section_index": 0, "content_hash": "cee9024c74aba01f1d045a026f4d5f002bf8f4406ee35950bcba7bcaaeab1216", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/projections.adoc"}}
{"id": "sha256:9e94f4c73328d484e379d55c6b40cf26e23c182c4ce29ed42fa6b1681611381a", "content": "include::{commons}@data-commons::page$repositories/projections-intro.adoc[leveloffset+=1]\n\ninclude::{commons}@data-commons::page$repositories/projections-interface.adoc[leveloffset=2]\n\ninclude::{commons}@data-commons::page$repositories/projections-class.adoc[leveloffset=2]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/projections.adoc", "title": "projections", "heading": "Introduction", "heading_level": 2, "file_order": 24, "section_index": 1, "content_hash": "9e94f4c73328d484e379d55c6b40cf26e23c182c4ce29ed42fa6b1681611381a", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/projections.adoc"}}
{"id": "sha256:80fcdb1e627c4cd4e032aeda5e9d2a5c835d8b185b63271032dc6594391dbfc9", "content": "You can use Projections with JPA in several ways.\nDepending on the technique and query type, you need to apply specific considerations.\n\nSpring Data JPA uses generally `Tuple` queries to construct interface proxies for <<projections.interfaces,Interface-based Projections>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/projections.adoc", "title": "projections", "heading": "Using Projections with JPA", "heading_level": 2, "file_order": 24, "section_index": 2, "content_hash": "80fcdb1e627c4cd4e032aeda5e9d2a5c835d8b185b63271032dc6594391dbfc9", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/projections.adoc"}}
{"id": "sha256:d961eeba7ce37ade1ee2d0cd5f9859282c78049d29e1215a044bd5568e73b137", "content": "Query derivation supports both, class-based and interface projections by introspecting the returned type.\nClass-based projections use JPA's instantiation mechanism (constructor expressions) to create the projection instance.\n\nProjections limit the selection to top-level properties of the target entity.\nAny nested properties resolving to joins select the entire nested property causing the full join to materialize.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/projections.adoc", "title": "projections", "heading": "Derived queries", "heading_level": 3, "file_order": 24, "section_index": 3, "content_hash": "d961eeba7ce37ade1ee2d0cd5f9859282c78049d29e1215a044bd5568e73b137", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/projections.adoc"}}
{"id": "sha256:dec182c680ecf8dfbc50c72268761d41b40d366a0e622e090c0f1c8de0d3b585", "content": "Support for string-based queries covers both JPQL queries (`@Query`) and native queries (`@NativeQuery`).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/projections.adoc", "title": "projections", "heading": "String-based queries", "heading_level": 3, "file_order": 24, "section_index": 4, "content_hash": "dec182c680ecf8dfbc50c72268761d41b40d366a0e622e090c0f1c8de0d3b585", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/projections.adoc"}}
{"id": "sha256:e99b177929c523cd4e3cdd3f275e478c68d42c45f1acdc28a0cbaa8ddcee4874", "content": "JPA's mechanism to return <<projections.dtos,Class-based projections>> using JPQL is *constructor expressions*.\nTherefore, your query must define a constructor expression such as `SELECT new com.example.NamesOnly(u.firstname, u.lastname) from User u`.\n(Note the usage of a FQDN for the DTO type!) This JPQL expression can be used in `@Query` annotations as well where you define any named queries.\nAs a workaround you may use named queries with `ResultSetMapping` or the Hibernate-specific javadoc:{hibernatejavadocurl}org.hibernate.query.ResultListTransformer[].\n\nSpring Data JPA can aid with rewriting your query to a constructor expression if your query selects the primary entity or a list of select items.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/projections.adoc", "title": "projections", "heading": "JPQL Queries", "heading_level": 4, "file_order": 24, "section_index": 5, "content_hash": "e99b177929c523cd4e3cdd3f275e478c68d42c45f1acdc28a0cbaa8ddcee4874", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/projections.adoc"}}
{"id": "sha256:7e4a9521e5dc36a833db09295baf79988f0a7b8f8c4b8b47078307b32a57dcdc", "content": "JPQL queries allow selection of the root object, individual properties, and DTO objects through constructor expressions.\nUsing a constructor expression can quickly add a lot of text to a query and make it difficult to read the actual query.\nSpring Data JPA can support you with your JPQL queries by introducing constructor expressions for your convenience.\n\nConsider the following queries:\n\n.Projection Queries\n====\n[source,java]\n----\ninterface UserRepository extends Repository<User, Long> {\n\n @Query(\"SELECT u FROM USER u WHERE u.lastname = :lastname\") <1>\n List<UserDto> findByLastname(String lastname);\n\n @Query(\"SELECT u.firstname, u.lastname FROM USER u WHERE u.lastname = :lastname\") <2>\n List<UserDto> findMultipleColumnsByLastname(String lastname);\n}\n\nrecord UserDto(String firstname, String lastname){}\n----\n\n<1> Selection of the top-level entity.\nThis query gets rewritten to `SELECT new UserDto(u.firstname, u.lastname) FROM USER u WHERE u.lastname = :lastname`.\n<2> Multi-select of `firstname` and `lastname` properties.\nThis query gets rewritten to `SELECT new UserDto(u.firstname, u.lastname) FROM USER u WHERE u.lastname = :lastname`.\n====\n\n[WARNING]\n====\nJPQL constructor expressions must not contain aliases for selected columns and query rewriting will not remove them for you.\nWhile `SELECT u as user, count(u.roles) as roleCount FROM USER u …` is a valid query for interface-based projections that rely on column names from the returned `Tuple`, the same construct is invalid when requesting a DTO where it needs to be `SELECT u, count(u.roles) FROM USER u …`. +\nSome persistence providers may be lenient about this, others not.\n====\n\nRepository query methods that return a DTO projection type (a Java type outside the domain type hierarchy) are subject for query rewriting.\nIf an `@Query`-annotated query already uses constructor expressions, then Spring Data backs off and doesn't apply DTO constructor expression rewriting.\n\nMake sure that your DTO types provide an all-args constructor for the projection, otherwise the query will fail.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/projections.adoc", "title": "projections", "heading": "DTO Projection JPQL Query Rewriting", "heading_level": 5, "file_order": 24, "section_index": 6, "content_hash": "7e4a9521e5dc36a833db09295baf79988f0a7b8f8c4b8b47078307b32a57dcdc", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/projections.adoc"}}
{"id": "sha256:9a089971ed45d56a0ae9b50fdf92bfc7fd10c27a683feaf45a50c14f455e4aa4", "content": "When using <<projections.dtos,Class-based projections>>, their usage requires slightly more consideration depending on your :\n\n* If properties of the result type map directly to the result (the order of columns and their types match the constructor arguments), then you can declare the query result type as the DTO type without further hints (or use the DTO class through dynamic projections).\n* If the properties do not match or require transformation, use `@SqlResultSetMapping` through JPA's annotations map the result set to the DTO and provide the result mapping name through `@NativeQuery(resultSetMapping = \"…\")`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/projections.adoc", "title": "projections", "heading": "Native Queries", "heading_level": 4, "file_order": 24, "section_index": 7, "content_hash": "9a089971ed45d56a0ae9b50fdf92bfc7fd10c27a683feaf45a50c14f455e4aa4", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/projections.adoc"}}
{"id": "sha256:ce36910d3991cf49debed12049992aa1a64a9ea81e6b0cab2ce11afab46d4303", "content": "include::{commons}@data-commons::page$query-by-example.adoc[]\n\n[[query-by-example.running]]\nIn Spring Data JPA, you can use Query by Example with Repositories, as shown in the following example:\n\n.Query by Example using a Repository\n====\n[source, java]\n----\npublic interface PersonRepository extends JpaRepository<Person, String> { … }\n\npublic class PersonService {\n\n @Autowired PersonRepository personRepository;\n\n public List<Person> findPeople(Person probe) {\n return personRepository.findAll(Example.of(probe));\n }\n}\n----\n====\n\nNOTE: Currently, only `SingularAttribute` properties can be used for property matching.\n\nThe property specifier accepts property names (such as `firstname` and `lastname`). You can navigate by chaining properties together with dots (`address.city`). You can also tune it with matching options and case sensitivity.\n\nThe following table shows the various `StringMatcher` options that you can use and the result of using them on a field named `firstname`:\n\n[cols=\"1,2\", options=\"header\"]\n.`StringMatcher` options\n|===\n| Matching\n| Logical result\n\n| `DEFAULT` (case-sensitive)\n| `firstname = ?0`\n\n| `DEFAULT` (case-insensitive)\n| `LOWER(firstname) = LOWER(?0)`\n\n| `EXACT` (case-sensitive)\n| `firstname = ?0`\n\n| `EXACT` (case-insensitive)\n| `LOWER(firstname) = LOWER(?0)`\n\n| `STARTING` (case-sensitive)\n| `firstname like ?0 + '%'`\n\n| `STARTING` (case-insensitive)\n| `LOWER(firstname) like LOWER(?0) + '%'`\n\n| `ENDING` (case-sensitive)\n| `firstname like '%' + ?0`\n\n| `ENDING` (case-insensitive)\n| `LOWER(firstname) like '%' + LOWER(?0)`\n\n| `CONTAINING` (case-sensitive)\n| `firstname like '%' + ?0 + '%'`\n\n| `CONTAINING` (case-insensitive)\n| `LOWER(firstname) like '%' + LOWER(?0) + '%'`\n\n|===\n\nNOTE: Regex-matching is not supported by JPA.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/query-by-example.adoc", "title": "query-by-example", "heading": "query-by-example", "heading_level": 1, "file_order": 25, "section_index": 0, "content_hash": "ce36910d3991cf49debed12049992aa1a64a9ea81e6b0cab2ce11afab46d4303", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/query-by-example.adoc"}}
{"id": "sha256:7e953260056fa458d00ccd6d3916965e33c635a0e5a9c1068e6d4c915b4642be", "content": "include::{commons}@data-commons::page$repositories/query-keywords-reference.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/query-keywords-reference.adoc", "title": "query-keywords-reference", "heading": "query-keywords-reference", "heading_level": 1, "file_order": 26, "section_index": 0, "content_hash": "7e953260056fa458d00ccd6d3916965e33c635a0e5a9c1068e6d4c915b4642be", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/query-keywords-reference.adoc"}}
{"id": "sha256:2931a4be98bc609c2eb349faa7f3ea7d07742930fa4e31487a2957e5874e0633", "content": "include::{commons}@data-commons::page$repositories/query-methods-details.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/query-methods-details.adoc", "title": "query-methods-details", "heading": "query-methods-details", "heading_level": 1, "file_order": 27, "section_index": 0, "content_hash": "2931a4be98bc609c2eb349faa7f3ea7d07742930fa4e31487a2957e5874e0633", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/query-methods-details.adoc"}}
{"id": "sha256:8586bea837d1b2b190fc36059384044b5c88fe73a8012f0e6782feb992f85865", "content": "include::{commons}@data-commons::page$repositories/query-return-types-reference.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/query-return-types-reference.adoc", "title": "query-return-types-reference", "heading": "query-return-types-reference", "heading_level": 1, "file_order": 28, "section_index": 0, "content_hash": "8586bea837d1b2b190fc36059384044b5c88fe73a8012f0e6782feb992f85865", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/query-return-types-reference.adoc"}}
{"id": "sha256:05bef57e1055af63c2d926b71457d13c2778432431fde94c94ba1e5a2eb9a35f", "content": "include::partial$vector-search.adoc[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories/vector-search.adoc", "title": "vector-search", "heading": "vector-search", "heading_level": 1, "file_order": 29, "section_index": 0, "content_hash": "05bef57e1055af63c2d926b71457d13c2778432431fde94c94ba1e5a2eb9a35f", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories/vector-search.adoc"}}
{"id": "sha256:156a542f2f325802db9c26fb08de05d5bee84f63f0a9c18b6087c80841a43ac2", "content": "include::{commons}@data-commons::page$auditing.adoc[]\n\nThere is also a convenience base class, `AbstractAuditable`, which you can extend to avoid the need to manually implement the interface methods. Doing so increases the coupling of your domain classes to Spring Data, which might be something you want to avoid. Usually, the annotation-based way of defining auditing metadata is preferred as it is less invasive and more flexible.\n\n[[jpa.auditing.configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/auditing.adoc", "title": "auditing", "heading": "auditing", "heading_level": 1, "file_order": 30, "section_index": 0, "content_hash": "156a542f2f325802db9c26fb08de05d5bee84f63f0a9c18b6087c80841a43ac2", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/auditing.adoc"}}
{"id": "sha256:8990d5106497d0e1cf5d9f1d75b399a71f192d9d1814b2f0e5633394ea0f7838", "content": "Spring Data JPA ships with an entity listener that can be used to trigger the capturing of auditing information. First, you must register the `AuditingEntityListener` to be used for all entities in your persistence contexts inside your `orm.xml` file, as shown in the following example:\n\n.Auditing configuration orm.xml\n====\n[source, xml]\n----\n<persistence-unit-metadata>\n <persistence-unit-defaults>\n <entity-listeners>\n <entity-listener class=\"….data.jpa.domain.support.AuditingEntityListener\" />\n </entity-listeners>\n </persistence-unit-defaults>\n</persistence-unit-metadata>\n----\n====\n\nYou can also enable the `AuditingEntityListener` on a per-entity basis by using the `@EntityListeners` annotation, as follows:\n\n====\n[source, java]\n----\n@Entity\n@EntityListeners(AuditingEntityListener.class)\npublic class MyEntity {\n\n}\n----\n====\n\nNOTE: The auditing feature requires `spring-aspects.jar` to be on the classpath.\n\nWith `orm.xml` suitably modified and `spring-aspects.jar` on the classpath, activating auditing functionality is a matter of adding the Spring Data JPA `auditing` namespace element to your configuration, as follows:\n\n.Activating auditing using XML configuration\n====\n[source, xml]\n----\n<jpa:auditing auditor-aware-ref=\"yourAuditorAwareBean\" />\n----\n====\n\nAs of Spring Data JPA 1.5, you can enable auditing by annotating a configuration class with the `@EnableJpaAuditing` annotation. You must still modify the `orm.xml` file and have `spring-aspects.jar` on the classpath. The following example shows how to use the `@EnableJpaAuditing` annotation:\n\n.Activating auditing with Java configuration\n====\n[source, java]\n----\n@Configuration\n@EnableJpaAuditing\nclass Config {\n\n @Bean\n public AuditorAware<AuditableUser> auditorProvider() {\n return new AuditorAwareImpl();\n }\n}\n----\n====\n\nIf you expose a bean of type `AuditorAware` to the `ApplicationContext`, the auditing infrastructure automatically picks it up and uses it to determine the current user to be set on domain types. If you have multiple implementations registered in the `ApplicationContext`, you can select the one to be used by explicitly setting the `auditorAwareRef` attribute of `@EnableJpaAuditing`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/auditing.adoc", "title": "auditing", "heading": "General Auditing Configuration", "heading_level": 2, "file_order": 30, "section_index": 1, "content_hash": "8990d5106497d0e1cf5d9f1d75b399a71f192d9d1814b2f0e5633394ea0f7838", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/auditing.adoc"}}
{"id": "sha256:52aab487f30c8805266172a6b894fccff6b838f8845de4752bae1abd54d89786", "content": "[[envers]]\n\nThis chapter points out the specialties for repository support for Envers. This builds on the core repository support explained earlier. Make sure you have a sound understanding of the basic concepts explained there.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/envers.adoc", "title": "envers", "heading": "envers", "heading_level": 1, "file_order": 31, "section_index": 0, "content_hash": "52aab487f30c8805266172a6b894fccff6b838f8845de4752bae1abd54d89786", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/envers.adoc"}}
{"id": "sha256:e3df0b049a99bcb12535f845c12e163edf638105b29a475847f39bed6b437cc2", "content": "[[spring-data-jpa-reference-documentation]]\n\n_Spring Data JPA provides repository support for the Jakarta Persistence API (JPA).\nIt eases development of applications with a consistent programming model that need to access JPA data sources._\n\n[horizontal]\nxref:jpa.adoc[JPA] :: JPA and JPA Repositories\nxref:envers.adoc[Envers] :: Support for Envers Revision Repositories\nhttps://github.com/spring-projects/spring-data-commons/wiki[Wiki] :: What's New,\nUpgrade Notes, Supported Versions, additional cross-version information.\n\nOliver Gierke, Thomas Darimont, Christoph Strobl, Mark Paluch, Jay Bryant, Greg Turnquist\n\n(C) 2008-{copyright-year} VMware, Inc.\n\nCopies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 32, "section_index": 0, "content_hash": "e3df0b049a99bcb12535f845c12e163edf638105b29a475847f39bed6b437cc2", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:8d37f20eb4ad841dea277725c1fa077905157c83ea723d174e5c5f3eb9ca6d3b", "content": "[[jpa.repositories]]\n\nThis chapter points out the specialties for repository support for JPA. This builds on the core repository support explained in xref:repositories.adoc[Working with Spring Data Repositories]. Make sure you have a sound understanding of the basic concepts explained there.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/jpa.adoc", "title": "jpa", "heading": "jpa", "heading_level": 1, "file_order": 33, "section_index": 0, "content_hash": "8d37f20eb4ad841dea277725c1fa077905157c83ea723d174e5c5f3eb9ca6d3b", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/jpa.adoc"}}
{"id": "sha256:f4f768d0e6882175332d131f38e919e2bf5234340098475f9e095977e0260ec1", "content": "[[common.basics]]\n\nThis chapter explains the basic foundations of Spring Data repositories. Before continuing to the JPA specifics, make sure you have a sound understanding of the basic concepts explained here.\n\nThe goal of the Spring Data repository abstraction is to significantly reduce the amount of boilerplate code required to implement data access layers for various persistence stores.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-data-jpa", "path": "antora/modules/ROOT/pages/repositories.adoc", "title": "repositories", "heading": "repositories", "heading_level": 1, "file_order": 34, "section_index": 0, "content_hash": "f4f768d0e6882175332d131f38e919e2bf5234340098475f9e095977e0260ec1", "source_url": "https://github.com/spring-projects/spring-data-jpa/blob/9f648345e2fe11970cb028830a1aa13d45fa13a1/src/main/antora/modules/ROOT/pages/repositories.adoc"}}
