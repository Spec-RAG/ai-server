{"id": "sha256:a8394dae51c509293f258fee9c91ae40a6bdb2eb4fe387e8f93611a41e764c6b", "content": "[[aop-advice]]\n\nAdvice is associated with a pointcut expression and runs before, after, or around method\nexecutions matched by the pointcut. The pointcut expression may be either an _inline\npointcut_ or a reference to a xref:core/aop/ataspectj/pointcuts.adoc#aop-common-pointcuts[_named pointcut_].\n\n[[aop-advice-before]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "advice", "heading_level": 1, "file_order": 0, "section_index": 0, "content_hash": "a8394dae51c509293f258fee9c91ae40a6bdb2eb4fe387e8f93611a41e764c6b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:28ae576ceb4c8d29ae4919d36591e4f43f2066b6edc5c8d694fe4e583d06d141", "content": "You can declare before advice in an aspect by using the `@Before` annotation.\n\nThe following example uses an inline pointcut expression.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect;\n\timport org.aspectj.lang.annotation.Before;\n\n\t@Aspect\n\tpublic class BeforeExample {\n\n @Before(\"execution(* com.xyz.dao.*.*(..))\")\n public void doAccessCheck() {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect\n\timport org.aspectj.lang.annotation.Before\n\n\t@Aspect\n\tclass BeforeExample {\n\n @Before(\"execution(* com.xyz.dao.*.*(..))\")\n fun doAccessCheck() {\n // ...\n }\n\t}\n----\n======\n\nIf we use a xref:core/aop/ataspectj/pointcuts.adoc#aop-common-pointcuts[named pointcut], we can rewrite the preceding example\nas follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect;\n\timport org.aspectj.lang.annotation.Before;\n\n\t@Aspect\n\tpublic class BeforeExample {\n\n @Before(\"com.xyz.CommonPointcuts.dataAccessOperation()\")\n public void doAccessCheck() {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect\n\timport org.aspectj.lang.annotation.Before\n\n\t@Aspect\n\tclass BeforeExample {\n\n @Before(\"com.xyz.CommonPointcuts.dataAccessOperation()\")\n fun doAccessCheck() {\n // ...\n }\n\t}\n----\n======\n\n[[aop-advice-after-returning]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "Before Advice", "heading_level": 2, "file_order": 0, "section_index": 1, "content_hash": "28ae576ceb4c8d29ae4919d36591e4f43f2066b6edc5c8d694fe4e583d06d141", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:2bbd659d61de47cf98a3fc2151d234f378d86f9b84eafb80c649e1871efb47aa", "content": "After returning advice runs when a matched method execution returns normally.\nYou can declare it by using the `@AfterReturning` annotation.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect;\n\timport org.aspectj.lang.annotation.AfterReturning;\n\n\t@Aspect\n\tpublic class AfterReturningExample {\n\n @AfterReturning(\"execution(* com.xyz.dao.*.*(..))\")\n public void doAccessCheck() {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect\n\timport org.aspectj.lang.annotation.AfterReturning\n\n\t@Aspect\n\tclass AfterReturningExample {\n\n @AfterReturning(\"execution(* com.xyz.dao.*.*(..))\")\n fun doAccessCheck() {\n // ...\n }\n\t}\n----\n======\n\nNOTE: You can have multiple advice declarations (and other members as well),\nall inside the same aspect. We show only a single advice declaration in these\nexamples to focus the effect of each one.\n\nSometimes, you need access in the advice body to the actual value that was returned.\nYou can use the form of `@AfterReturning` that binds the return value to get that\naccess, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect;\n\timport org.aspectj.lang.annotation.AfterReturning;\n\n\t@Aspect\n\tpublic class AfterReturningExample {\n\n @AfterReturning(\n pointcut=\"execution(* com.xyz.dao.*.*(..))\",\n returning=\"retVal\")\n public void doAccessCheck(Object retVal) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect\n\timport org.aspectj.lang.annotation.AfterReturning\n\n\t@Aspect\n\tclass AfterReturningExample {\n\n @AfterReturning(\n pointcut = \"execution(* com.xyz.dao.*.*(..))\",\n returning = \"retVal\")\n fun doAccessCheck(retVal: Any?) {\n // ...\n }\n\t}\n----\n======\n\nThe name used in the `returning` attribute must correspond to the name of a parameter\nin the advice method. When a method execution returns, the return value is passed to\nthe advice method as the corresponding argument value. A `returning` clause also\nrestricts matching to only those method executions that return a value of the\nspecified type (in this case, `Object`, which matches any return value).\n\nPlease note that it is not possible to return a totally different reference when\nusing after returning advice.\n\n[[aop-advice-after-throwing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "After Returning Advice", "heading_level": 2, "file_order": 0, "section_index": 2, "content_hash": "2bbd659d61de47cf98a3fc2151d234f378d86f9b84eafb80c649e1871efb47aa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:fc058f64bfd9f9c223e521d1b7ec351d936eafb53130ffa020bfa39a39b8d355", "content": "After throwing advice runs when a matched method execution exits by throwing an\nexception. You can declare it by using the `@AfterThrowing` annotation, as the\nfollowing example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect;\n\timport org.aspectj.lang.annotation.AfterThrowing;\n\n\t@Aspect\n\tpublic class AfterThrowingExample {\n\n @AfterThrowing(\"execution(* com.xyz.dao.*.*(..))\")\n public void doRecoveryActions() {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect\n\timport org.aspectj.lang.annotation.AfterThrowing\n\n\t@Aspect\n\tclass AfterThrowingExample {\n\n @AfterThrowing(\"execution(* com.xyz.dao.*.*(..))\")\n fun doRecoveryActions() {\n // ...\n }\n\t}\n----\n======\n\nOften, you want the advice to run only when exceptions of a given type are thrown,\nand you also often need access to the thrown exception in the advice body. You can\nuse the `throwing` attribute to both restrict matching (if desired -- use `Throwable`\nas the exception type otherwise) and bind the thrown exception to an advice parameter.\nThe following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect;\n\timport org.aspectj.lang.annotation.AfterThrowing;\n\n\t@Aspect\n\tpublic class AfterThrowingExample {\n\n @AfterThrowing(\n pointcut=\"execution(* com.xyz.dao.*.*(..))\",\n throwing=\"ex\")\n public void doRecoveryActions(DataAccessException ex) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect\n\timport org.aspectj.lang.annotation.AfterThrowing\n\n\t@Aspect\n\tclass AfterThrowingExample {\n\n @AfterThrowing(\n pointcut = \"execution(* com.xyz.dao.*.*(..))\",\n throwing = \"ex\")\n fun doRecoveryActions(ex: DataAccessException) {\n // ...\n }\n\t}\n----\n======\n\nThe name used in the `throwing` attribute must correspond to the name of a parameter in\nthe advice method. When a method execution exits by throwing an exception, the exception\nis passed to the advice method as the corresponding argument value. A `throwing` clause\nalso restricts matching to only those method executions that throw an exception of the\nspecified type (`DataAccessException`, in this case).\n\n[NOTE]\n====\nNote that `@AfterThrowing` does not indicate a general exception handling callback.\nSpecifically, an `@AfterThrowing` advice method is only supposed to receive exceptions\nfrom the join point (user-declared target method) itself but not from an accompanying\n`@After`/`@AfterReturning` method.\n====\n\n[[aop-advice-after-finally]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "After Throwing Advice", "heading_level": 2, "file_order": 0, "section_index": 3, "content_hash": "fc058f64bfd9f9c223e521d1b7ec351d936eafb53130ffa020bfa39a39b8d355", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:36d9495fb553614534596b738a7ae1ae50338cd652c802d5b2271cce84de5131", "content": "After (finally) advice runs when a matched method execution exits. It is declared by\nusing the `@After` annotation. After advice must be prepared to handle both normal and\nexception return conditions. It is typically used for releasing resources and similar\npurposes. The following example shows how to use after finally advice:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect;\n\timport org.aspectj.lang.annotation.After;\n\n\t@Aspect\n\tpublic class AfterFinallyExample {\n\n @After(\"execution(* com.xyz.dao.*.*(..))\")\n public void doReleaseLock() {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect\n\timport org.aspectj.lang.annotation.After\n\n\t@Aspect\n\tclass AfterFinallyExample {\n\n @After(\"execution(* com.xyz.dao.*.*(..))\")\n fun doReleaseLock() {\n // ...\n }\n\t}\n----\n======\n\n[NOTE]\n====\nNote that `@After` advice in AspectJ is defined as \"after finally advice\", analogous\nto a finally block in a try-catch statement. It will be invoked for any outcome,\nnormal return or exception thrown from the join point (user-declared target method),\nin contrast to `@AfterReturning` which only applies to successful normal returns.\n====\n\n[[aop-ataspectj-around-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "After (Finally) Advice", "heading_level": 2, "file_order": 0, "section_index": 4, "content_hash": "36d9495fb553614534596b738a7ae1ae50338cd652c802d5b2271cce84de5131", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:8395520befaa0ff0f5adc49dff06ef63e52329b588222d70bdea2fef27c0888b", "content": "The last kind of advice is _around_ advice. Around advice runs \"around\" a matched\nmethod's execution. It has the opportunity to do work both before and after the method\nruns and to determine when, how, and even if the method actually gets to run at all.\nAround advice is often used if you need to share state before and after a method\nexecution in a thread-safe manner â€“ for example, starting and stopping a timer.\n\n[TIP]\n====\nAlways use the least powerful form of advice that meets your requirements.\n\nFor example, do not use _around_ advice if _before_ advice is sufficient for your needs.\n====\n\nAround advice is declared by annotating a method with the `@Around` annotation. The\nmethod should declare `Object` as its return type, and the first parameter of the method\nmust be of type `ProceedingJoinPoint`. Within the body of the advice method, you must\ninvoke `proceed()` on the `ProceedingJoinPoint` in order for the underlying method to\nrun. Invoking `proceed()` without arguments will result in the caller's original\narguments being supplied to the underlying method when it is invoked. For advanced use\ncases, there is an overloaded variant of the `proceed()` method which accepts an array of\narguments (`Object[]`). The values in the array will be used as the arguments to the\nunderlying method when it is invoked.\n\n[NOTE]\n====\nThe behavior of `proceed` when called with an `Object[]` is a little different than the\nbehavior of `proceed` for around advice compiled by the AspectJ compiler. For around\nadvice written using the traditional AspectJ language, the number of arguments passed to\n`proceed` must match the number of arguments passed to the around advice (not the number\nof arguments taken by the underlying join point), and the value passed to proceed in a\ngiven argument position supplants the original value at the join point for the entity the\nvalue was bound to (do not worry if this does not make sense right now).\n\nThe approach taken by Spring is simpler and a better match to its proxy-based,\nexecution-only semantics. You only need to be aware of this difference if you compile\n`@AspectJ` aspects written for Spring and use `proceed` with arguments with the AspectJ\ncompiler and weaver. There is a way to write such aspects that is 100% compatible across\nboth Spring AOP and AspectJ, and this is discussed in the\nxref:core/aop/ataspectj/advice.adoc#aop-ataspectj-advice-proceeding-with-the-call[following section on advice parameters].\n====\n\nThe value returned by the around advice is the return value seen by the caller of the\nmethod. For example, a simple caching aspect could return a value from a cache if it has\none or invoke `proceed()` (and return that value) if it does not. Note that `proceed`\nmay be invoked once, many times, or not at all within the body of the around advice. All\nof these are legal.\n\nWARNING: If you declare the return type of your around advice method as `void`, `null`\nwill always be returned to the caller, effectively ignoring the result of any invocation\nof `proceed()`. It is therefore recommended that an around advice method declare a return\ntype of `Object`. The advice method should typically return the value returned from an\ninvocation of `proceed()`, even if the underlying method has a `void` return type.\nHowever, the advice may optionally return a cached value, a wrapped value, or some other\nvalue depending on the use case.\n\nThe following example shows how to use around advice:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect;\n\timport org.aspectj.lang.annotation.Around;\n\timport org.aspectj.lang.ProceedingJoinPoint;\n\n\t@Aspect\n\tpublic class AroundExample {\n\n @Around(\"execution(* com.xyz..service.*.*(..))\")\n public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {\n // start stopwatch\n Object retVal = pjp.proceed();\n // stop stopwatch\n return retVal;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\timport org.aspectj.lang.annotation.Aspect\n\timport org.aspectj.lang.annotation.Around\n\timport org.aspectj.lang.ProceedingJoinPoint\n\n\t@Aspect\n\tclass AroundExample {\n\n @Around(\"execution(* com.xyz..service.*.*(..))\")\n fun doBasicProfiling(pjp: ProceedingJoinPoint): Any? {\n // start stopwatch\n val retVal = pjp.proceed()\n // stop stopwatch\n return retVal\n }\n\t}\n----\n======\n\n[[aop-ataspectj-advice-params]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "Around Advice", "heading_level": 2, "file_order": 0, "section_index": 5, "content_hash": "8395520befaa0ff0f5adc49dff06ef63e52329b588222d70bdea2fef27c0888b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:93b94aca8166296246ae6dd051900838076267e3d4c5a7254299fc389021f13a", "content": "Spring offers fully typed advice, meaning that you declare the parameters you need in the\nadvice signature (as we saw earlier for the returning and throwing examples) rather than\nwork with `Object[]` arrays all the time. We see how to make argument and other contextual\nvalues available to the advice body later in this section. First, we take a look at how to\nwrite generic advice that can find out about the method the advice is currently advising.\n\n[[aop-ataspectj-advice-params-the-joinpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "Advice Parameters", "heading_level": 2, "file_order": 0, "section_index": 6, "content_hash": "93b94aca8166296246ae6dd051900838076267e3d4c5a7254299fc389021f13a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:ff6e0b76ad74998311684d96e672636a61f37112680d739e15768587b3e47f83", "content": "Any advice method may declare, as its first parameter, a parameter of type\n`org.aspectj.lang.JoinPoint`. Note that around advice is required to declare a first\nparameter of type `ProceedingJoinPoint`, which is a subclass of `JoinPoint`.\n\nThe `JoinPoint` interface provides a number of useful methods:\n\n* `getArgs()`: Returns the method arguments.\n* `getThis()`: Returns the proxy object.\n* `getTarget()`: Returns the target object.\n* `getSignature()`: Returns a description of the method that is being advised.\n* `toString()`: Prints a useful description of the method being advised.\n\nSee the {aspectj-api}/org/aspectj/lang/JoinPoint.html[javadoc] for more detail.\n\n[[aop-ataspectj-advice-params-passing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "Access to the Current `JoinPoint`", "heading_level": 3, "file_order": 0, "section_index": 7, "content_hash": "ff6e0b76ad74998311684d96e672636a61f37112680d739e15768587b3e47f83", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:cbd444aef63a74c3b4e3293791ae7788b8aa33b98f0033983520a5d074919baf", "content": "We have already seen how to bind the returned value or exception value (using after\nreturning and after throwing advice). To make argument values available to the advice\nbody, you can use the binding form of `args`. If you use a parameter name in place of a\ntype name in an `args` expression, the value of the corresponding argument is passed as\nthe parameter value when the advice is invoked. An example should make this clearer.\nSuppose you want to advise the execution of DAO operations that take an `Account`\nobject as the first parameter, and you need access to the account in the advice body.\nYou could write the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\"execution(* com.xyz.dao.*.*(..)) && args(account,..)\")\n\tpublic void validateAccount(Account account) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\"execution(* com.xyz.dao.*.*(..)) && args(account,..)\")\n\tfun validateAccount(account: Account) {\n // ...\n\t}\n----\n======\n\nThe `args(account,..)` part of the pointcut expression serves two purposes. First, it\nrestricts matching to only those method executions where the method takes at least one\nparameter, and the argument passed to that parameter is an instance of `Account`.\nSecond, it makes the actual `Account` object available to the advice through the `account`\nparameter.\n\nAnother way of writing this is to declare a pointcut that \"provides\" the `Account`\nobject value when it matches a join point, and then refer to the named pointcut\nfrom the advice. This would look as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Pointcut(\"execution(* com.xyz.dao.*.*(..)) && args(account,..)\")\n\tprivate void accountDataAccessOperation(Account account) {}\n\n\t@Before(\"accountDataAccessOperation(account)\")\n\tpublic void validateAccount(Account account) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Pointcut(\"execution(* com.xyz.dao.*.*(..)) && args(account,..)\")\n\tprivate fun accountDataAccessOperation(account: Account) {\n\t}\n\n\t@Before(\"accountDataAccessOperation(account)\")\n\tfun validateAccount(account: Account) {\n // ...\n\t}\n----\n======\n\nSee the AspectJ programming guide for more details.\n\nThe proxy object (`this`), target object (`target`), and annotations (`@within`,\n`@target`, `@annotation`, and `@args`) can all be bound in a similar fashion. The next\nset of examples shows how to match the execution of methods annotated with an\n`@Auditable` annotation and extract the audit code:\n\nThe following shows the definition of the `@Auditable` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target(ElementType.METHOD)\n\tpublic @interface Auditable {\n AuditCode value();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@Target(AnnotationTarget.FUNCTION)\n\tannotation class Auditable(val value: AuditCode)\n----\n======\n\nThe following shows the advice that matches the execution of `@Auditable` methods:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\"com.xyz.Pointcuts.publicMethod() && @annotation(auditable)\") // <1>\n\tpublic void audit(Auditable auditable) {\n AuditCode code = auditable.value();\n // ...\n\t}\n----\n<1> References the `publicMethod` named pointcut defined in xref:core/aop/ataspectj/pointcuts.adoc#aop-pointcuts-combining[Combining Pointcut Expressions].\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\"com.xyz.Pointcuts.publicMethod() && @annotation(auditable)\") // <1>\n\tfun audit(auditable: Auditable) {\n val code = auditable.value()\n // ...\n\t}\n----\n<1> References the `publicMethod` named pointcut defined in xref:core/aop/ataspectj/pointcuts.adoc#aop-pointcuts-combining[Combining Pointcut Expressions].\n======\n\n[[aop-ataspectj-advice-params-generics]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "Passing Parameters to Advice", "heading_level": 3, "file_order": 0, "section_index": 8, "content_hash": "cbd444aef63a74c3b4e3293791ae7788b8aa33b98f0033983520a5d074919baf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:c82bca008400576cf8c8494701a1d183f779eb1a7fb853490531b785190b4581", "content": "Spring AOP can handle generics used in class declarations and method parameters. Suppose\nyou have a generic type like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic interface Sample<T> {\n void sampleGenericMethod(T param);\n void sampleGenericCollectionMethod(Collection<T> param);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tinterface Sample<T> {\n fun sampleGenericMethod(param: T)\n fun sampleGenericCollectionMethod(param: Collection<T>)\n\t}\n----\n======\n\nYou can restrict interception of method types to certain parameter types by\ntying the advice parameter to the parameter type for which you want to intercept the method:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\"execution(* ..Sample+.sampleGenericMethod(*)) && args(param)\")\n\tpublic void beforeSampleMethod(MyType param) {\n // Advice implementation\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\"execution(* ..Sample+.sampleGenericMethod(*)) && args(param)\")\n\tfun beforeSampleMethod(param: MyType) {\n // Advice implementation\n\t}\n----\n======\n\nThis approach does not work for generic collections. So you cannot define a\npointcut as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\"execution(* ..Sample+.sampleGenericCollectionMethod(*)) && args(param)\")\n\tpublic void beforeSampleMethod(Collection<MyType> param) {\n // Advice implementation\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\"execution(* ..Sample+.sampleGenericCollectionMethod(*)) && args(param)\")\n\tfun beforeSampleMethod(param: Collection<MyType>) {\n // Advice implementation\n\t}\n----\n======\n\nTo make this work, we would have to inspect every element of the collection, which is not\nreasonable, as we also cannot decide how to treat `null` values in general. To achieve\nsomething similar to this, you have to type the parameter to `Collection<?>` and manually\ncheck the type of the elements.\n\n[[aop-ataspectj-advice-params-names]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "Advice Parameters and Generics", "heading_level": 3, "file_order": 0, "section_index": 9, "content_hash": "c82bca008400576cf8c8494701a1d183f779eb1a7fb853490531b785190b4581", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:97e08e4045a129b20b5585f5aada8ed4880825f21c6c280c9b42aae43dacbbab", "content": "Parameter binding in advice invocations relies on matching the names used in pointcut\nexpressions to the parameter names declared in advice and pointcut method signatures.\n\nNOTE: This section uses the terms _argument_ and _parameter_ interchangeably, since\nAspectJ APIs refer to parameter names as argument names.\n\nSpring AOP uses the following `ParameterNameDiscoverer` implementations to determine\nparameter names. Each discoverer will be given a chance to discover parameter names, and\nthe first successful discoverer wins. If none of the registered discoverers is capable\nof determining parameter names, an exception will be thrown.\n\n`AspectJAnnotationParameterNameDiscoverer` :: Uses parameter names that have been explicitly\n specified by the user via the `argNames` attribute in the corresponding advice or\n pointcut annotation. See xref:core/aop/ataspectj/advice.adoc#aop-ataspectj-advice-params-names-explicit[Explicit Argument Names] for details.\n`KotlinReflectionParameterNameDiscoverer` :: Uses Kotlin reflection APIs to determine\n parameter names. This discoverer is only used if such APIs are present on the classpath.\n`StandardReflectionParameterNameDiscoverer` :: Uses the standard `java.lang.reflect.Parameter`\n API to determine parameter names. Requires that code be compiled with the `-parameters`\n flag for `javac`. Recommended approach.\n`AspectJAdviceParameterNameDiscoverer` :: Deduces parameter names from the pointcut\n expression, `returning`, and `throwing` clauses. See the\n {spring-framework-api}/aop/aspectj/AspectJAdviceParameterNameDiscoverer.html[javadoc]\n for details on the algorithm used.\n\n[[aop-ataspectj-advice-params-names-explicit]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "Determining Argument Names", "heading_level": 3, "file_order": 0, "section_index": 10, "content_hash": "97e08e4045a129b20b5585f5aada8ed4880825f21c6c280c9b42aae43dacbbab", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:ec0cfa58291110e7fec1d307ef7103625f662a8703139a33cdb40721842b5f21", "content": "@AspectJ advice and pointcut annotations have an optional `argNames` attribute that you\ncan use to specify the argument names of the annotated method.\n\n[TIP]\n====\nIf an @AspectJ aspect has been compiled by the AspectJ compiler (`ajc`) even without\ndebug information, you do not need to add the `argNames` attribute, since the compiler\nretains the needed information.\n\nSimilarly, if an @AspectJ aspect has been compiled with `javac` using the `-parameters`\nflag, you do not need to add the `argNames` attribute, since the compiler retains the\nneeded information.\n====\n\nThe following example shows how to use the `argNames` attribute:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\n value = \"com.xyz.Pointcuts.publicMethod() && target(bean) && @annotation(auditable)\", // <1>\n argNames = \"bean,auditable\") // <2>\n\tpublic void audit(Object bean, Auditable auditable) {\n AuditCode code = auditable.value();\n // ... use code and bean\n\t}\n----\n<1> References the `publicMethod` named pointcut defined in xref:core/aop/ataspectj/pointcuts.adoc#aop-pointcuts-combining[Combining Pointcut Expressions].\n<2> Declares `bean` and `auditable` as the argument names.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\n value = \"com.xyz.Pointcuts.publicMethod() && target(bean) && @annotation(auditable)\", // <1>\n argNames = \"bean,auditable\") // <2>\n\tfun audit(bean: Any, auditable: Auditable) {\n val code = auditable.value()\n // ... use code and bean\n\t}\n----\n<1> References the `publicMethod` named pointcut defined in xref:core/aop/ataspectj/pointcuts.adoc#aop-pointcuts-combining[Combining Pointcut Expressions].\n<2> Declares `bean` and `auditable` as the argument names.\n======\n\nIf the first parameter is of type `JoinPoint`, `ProceedingJoinPoint`, or\n`JoinPoint.StaticPart`, you can omit the name of the parameter from the value of the\n`argNames` attribute. For example, if you modify the preceding advice to receive the join\npoint object, the `argNames` attribute does not need to include it:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\n value = \"com.xyz.Pointcuts.publicMethod() && target(bean) && @annotation(auditable)\", // <1>\n argNames = \"bean,auditable\") // <2>\n\tpublic void audit(JoinPoint jp, Object bean, Auditable auditable) {\n AuditCode code = auditable.value();\n // ... use code, bean, and jp\n\t}\n----\n<1> References the `publicMethod` named pointcut defined in xref:core/aop/ataspectj/pointcuts.adoc#aop-pointcuts-combining[Combining Pointcut Expressions].\n<2> Declares `bean` and `auditable` as the argument names.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\n value = \"com.xyz.Pointcuts.publicMethod() && target(bean) && @annotation(auditable)\", // <1>\n argNames = \"bean,auditable\") // <2>\n\tfun audit(jp: JoinPoint, bean: Any, auditable: Auditable) {\n val code = auditable.value()\n // ... use code, bean, and jp\n\t}\n----\n<1> References the `publicMethod` named pointcut defined in xref:core/aop/ataspectj/pointcuts.adoc#aop-pointcuts-combining[Combining Pointcut Expressions].\n<2> Declares `bean` and `auditable` as the argument names.\n======\n\nThe special treatment given to the first parameter of type `JoinPoint`,\n`ProceedingJoinPoint`, or `JoinPoint.StaticPart` is particularly convenient for advice\nmethods that do not collect any other join point context. In such situations, you may\nomit the `argNames` attribute. For example, the following advice does not need to declare\nthe `argNames` attribute:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\"com.xyz.Pointcuts.publicMethod()\") // <1>\n\tpublic void audit(JoinPoint jp) {\n // ... use jp\n\t}\n----\n<1> References the `publicMethod` named pointcut defined in xref:core/aop/ataspectj/pointcuts.adoc#aop-pointcuts-combining[Combining Pointcut Expressions].\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Before(\"com.xyz.Pointcuts.publicMethod()\") // <1>\n\tfun audit(jp: JoinPoint) {\n // ... use jp\n\t}\n----\n<1> References the `publicMethod` named pointcut defined in xref:core/aop/ataspectj/pointcuts.adoc#aop-pointcuts-combining[Combining Pointcut Expressions].\n======\n\n[[aop-ataspectj-advice-proceeding-with-the-call]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "Explicit Argument Names", "heading_level": 3, "file_order": 0, "section_index": 11, "content_hash": "ec0cfa58291110e7fec1d307ef7103625f662a8703139a33cdb40721842b5f21", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:d03c8709183807cd7a8dd451f2f22995a0862d49964cc4759bf12fee6f461178", "content": "We remarked earlier that we would describe how to write a `proceed` call with\narguments that works consistently across Spring AOP and AspectJ. The solution is\nto ensure that the advice signature binds each of the method parameters in order.\nThe following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Around(\"execution(List<Account> find*(..)) && \" +\n \"com.xyz.CommonPointcuts.inDataAccessLayer() && \" +\n \"args(accountHolderNamePattern)\") // <1>\n\tpublic Object preProcessQueryPattern(ProceedingJoinPoint pjp,\n String accountHolderNamePattern) throws Throwable {\n String newPattern = preProcess(accountHolderNamePattern);\n return pjp.proceed(new Object[] {newPattern});\n\t}\n----\n<1> References the `inDataAccessLayer` named pointcut defined in xref:core/aop/ataspectj/pointcuts.adoc#aop-common-pointcuts[Sharing Named Pointcut Definitions].\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Around(\"execution(List<Account> find*(..)) && \" +\n \"com.xyz.CommonPointcuts.inDataAccessLayer() && \" +\n \"args(accountHolderNamePattern)\") // <1>\n\tfun preProcessQueryPattern(pjp: ProceedingJoinPoint,\n accountHolderNamePattern: String): Any? {\n val newPattern = preProcess(accountHolderNamePattern)\n return pjp.proceed(arrayOf<Any>(newPattern))\n\t}\n----\n<1> References the `inDataAccessLayer` named pointcut defined in xref:core/aop/ataspectj/pointcuts.adoc#aop-common-pointcuts[Sharing Named Pointcut Definitions].\n======\n\nIn many cases, you do this binding anyway (as in the preceding example).\n\n[[aop-ataspectj-advice-ordering]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "Proceeding with Arguments", "heading_level": 3, "file_order": 0, "section_index": 12, "content_hash": "d03c8709183807cd7a8dd451f2f22995a0862d49964cc4759bf12fee6f461178", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:df48654c9739b7d1d9155eb9ad2e272cf10661746ebcbc2fc1dbee326fbd1e73", "content": "What happens when multiple pieces of advice all want to run at the same join point?\nSpring AOP follows the same precedence rules as AspectJ to determine the order of advice\nexecution. The highest precedence advice runs first \"on the way in\" (so, given two pieces\nof before advice, the one with highest precedence runs first). \"On the way out\" from a\njoin point, the highest precedence advice runs last (so, given two pieces of after\nadvice, the one with the highest precedence will run second).\n\nWhen two pieces of advice defined in different aspects both need to run at the same\njoin point, unless you specify otherwise, the order of execution is undefined. You can\ncontrol the order of execution by specifying precedence. This is done in the normal\nSpring way by either implementing the `org.springframework.core.Ordered` interface in\nthe aspect class or annotating it with the `@Order` annotation. Given two aspects, the\naspect returning the lower value from `Ordered.getOrder()` (or the annotation value) has\nthe higher precedence.\n\n[NOTE]\n====\nEach of the distinct advice types of a particular aspect is conceptually meant to apply\nto the join point directly. As a consequence, an `@AfterThrowing` advice method is not\nsupposed to receive an exception from an accompanying `@After`/`@AfterReturning` method.\n\nAdvice methods defined in the same `@Aspect` class that\nneed to run at the same join point are assigned precedence based on their advice type in\nthe following order, from highest to lowest precedence: `@Around`, `@Before`, `@After`,\n`@AfterReturning`, `@AfterThrowing`. Note, however, that an `@After` advice method will\neffectively be invoked after any `@AfterReturning` or `@AfterThrowing` advice methods\nin the same aspect, following AspectJ's \"after finally advice\" semantics for `@After`.\n\nWhen two pieces of the same type of advice (for example, two `@After` advice methods)\ndefined in the same `@Aspect` class both need to run at the same join point, the ordering\nis undefined (since there is no way to retrieve the source code declaration order through\nreflection for javac-compiled classes). Consider collapsing such advice methods into one\nadvice method per join point in each `@Aspect` class or refactor the pieces of advice into\nseparate `@Aspect` classes that you can order at the aspect level via `Ordered` or `@Order`.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc", "title": "advice", "heading": "Advice Ordering", "heading_level": 2, "file_order": 0, "section_index": 13, "content_hash": "df48654c9739b7d1d9155eb9ad2e272cf10661746ebcbc2fc1dbee326fbd1e73", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/advice.adoc"}}
{"id": "sha256:0359d3b35545102498e3bb6353361a0325c56ffd5a8ed1ddeba3571fcea7018b", "content": "[[aop-aspectj-support]]\n\nTo use @AspectJ aspects in a Spring configuration, you need to enable Spring support for\nconfiguring Spring AOP based on @AspectJ aspects and auto-proxying beans based on\nwhether or not they are advised by those aspects. By auto-proxying, we mean that, if Spring\ndetermines that a bean is advised by one or more aspects, it automatically generates\na proxy for that bean to intercept method invocations and ensures that advice is run\nas needed.\n\nThe @AspectJ support can be enabled with programmatic or XML configuration. In either\ncase, you also need to ensure that AspectJ's `org.aspectj:aspectjweaver` library is on the\nclasspath of your application (version 1.9 or later).\n\ninclude-code::./ApplicationConfiguration[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/aspectj-support.adoc", "title": "aspectj-support", "heading": "aspectj-support", "heading_level": 1, "file_order": 1, "section_index": 0, "content_hash": "0359d3b35545102498e3bb6353361a0325c56ffd5a8ed1ddeba3571fcea7018b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/aspectj-support.adoc"}}
{"id": "sha256:1183327e9e766ea9bfbfbe1ff4f64b676bdf0ca58fdec4c9abf513adea258a99", "content": "[[aop-at-aspectj]]\n\nWith @AspectJ support enabled, any bean defined in your application context with a\nclass that is an @AspectJ aspect (has the `@Aspect` annotation) is automatically\ndetected by Spring and used to configure Spring AOP. The next two examples show the\nminimal steps required for a not-very-useful aspect.\n\nThe first of the two examples shows a regular bean definition in the application context\nthat points to a bean class that is annotated with `@Aspect`:\n\ninclude-code::./ApplicationConfiguration[tag=snippet,indent=0]\n\nThe second of the two examples shows the `NotVeryUsefulAspect` class definition, which is\nannotated with `@Aspect`:\n\ninclude-code::./NotVeryUsefulAspect[tag=snippet,indent=0]\n\nAspects (classes annotated with `@Aspect`) can have methods and fields, the same as any\nother class. They can also contain pointcut, advice, and introduction (inter-type)\ndeclarations.\n\n.Autodetecting aspects through component scanning\nNOTE: You can register aspect classes as regular beans in your Spring XML configuration,\nvia `@Bean` methods in `@Configuration` classes, or have Spring autodetect them through\nclasspath scanning -- the same as any other Spring-managed bean. However, note that the\n`@Aspect` annotation is not sufficient for autodetection in the classpath. For that\npurpose, you need to add a separate `@Component` annotation (or, alternatively, a custom\nstereotype annotation that qualifies, as per the rules of Spring's component scanner).\n\n.Advising aspects with other aspects?\nNOTE: In Spring AOP, aspects themselves cannot be the targets of advice from other\naspects. The `@Aspect` annotation on a class marks it as an aspect and, hence, excludes\nit from auto-proxying.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/at-aspectj.adoc", "title": "at-aspectj", "heading": "at-aspectj", "heading_level": 1, "file_order": 2, "section_index": 0, "content_hash": "1183327e9e766ea9bfbfbe1ff4f64b676bdf0ca58fdec4c9abf513adea258a99", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/at-aspectj.adoc"}}
{"id": "sha256:187685187368c2845882ebff5f9bb75e4981d6f421c93cd0d2cbaeff548b9082", "content": "[[aop-ataspectj-example]]\n\nNow that you have seen how all the constituent parts work, we can put them together to do\nsomething useful.\n\nThe execution of business services can sometimes fail due to concurrency issues (for\nexample, a deadlock loser). If the operation is retried, it is likely to succeed\non the next try. For business services where it is appropriate to retry in such\nconditions (idempotent operations that do not need to go back to the user for conflict\nresolution), we want to transparently retry the operation to avoid the client seeing a\n`PessimisticLockingFailureException`. This is a requirement that clearly cuts across\nmultiple services in the service layer and, hence, is ideal for implementing through an\naspect.\n\nBecause we want to retry the operation, we need to use around advice so that we can\ncall `proceed` multiple times. The following listing shows the basic aspect implementation:\n\ninclude-code::./ConcurrentOperationExecutor[tag=snippet,indent=0]\n\n`@Around(\"com.xyz.CommonPointcuts.businessService()\")` references the `businessService` named pointcut defined in\nxref:core/aop/ataspectj/pointcuts.adoc#aop-common-pointcuts[Sharing Named Pointcut Definitions].\n\nNote that the aspect implements the `Ordered` interface so that we can set the precedence of\nthe aspect higher than the transaction advice (we want a fresh transaction each time we\nretry). The `maxRetries` and `order` properties are both configured by Spring. The\nmain action happens in the `doConcurrentOperation` around advice. Notice that, for the\nmoment, we apply the retry logic to each `businessService`. We try to proceed,\nand if we fail with a `PessimisticLockingFailureException`, we try again, unless\nwe have exhausted all of our retry attempts.\n\nThe corresponding Spring configuration follows:\n\ninclude-code::./ApplicationConfiguration[tag=snippet,indent=0]\n\nTo refine the aspect so that it retries only idempotent operations, we might define the following\n`Idempotent` annotation:\n\ninclude-code::./service/Idempotent[tag=snippet,indent=0]\n\nWe can then use the annotation to annotate the implementation of service operations. The change\nto the aspect to retry only idempotent operations involves refining the pointcut\nexpression so that only `@Idempotent` operations match, as follows:\n\ninclude-code::./service/SampleService[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/example.adoc", "title": "example", "heading": "example", "heading_level": 1, "file_order": 3, "section_index": 0, "content_hash": "187685187368c2845882ebff5f9bb75e4981d6f421c93cd0d2cbaeff548b9082", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/example.adoc"}}
{"id": "sha256:b1ee47cf194e879e3751ccec352affe262a66656d40e5261aaed6035b15e5ab3", "content": "[[aop-instantiation-models]]\n\nNOTE: This is an advanced topic. If you are just starting out with AOP, you can safely skip\nit until later.\n\nBy default, there is a single instance of each aspect within the application\ncontext. AspectJ calls this the singleton instantiation model. It is possible to define\naspects with alternate lifecycles. Spring supports AspectJ's `perthis`, `pertarget`, and\n`pertypewithin` instantiation models; `percflow` and `percflowbelow` are not currently\nsupported.\n\nYou can declare a `perthis` aspect by specifying a `perthis` clause in the `@Aspect`\nannotation. Consider the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Aspect(\"perthis(execution(* com.xyz..service.*.*(..)))\")\n\tpublic class MyAspect {\n\n private int someState;\n\n @Before(\"execution(* com.xyz..service.*.*(..))\")\n public void recordServiceUsage() {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Aspect(\"perthis(execution(* com.xyz..service.*.*(..)))\")\n\tclass MyAspect {\n\n private val someState: Int = 0\n\n @Before(\"execution(* com.xyz..service.*.*(..))\")\n fun recordServiceUsage() {\n // ...\n }\n\t}\n----\n======\n\nIn the preceding example, the effect of the `perthis` clause is that one aspect instance\nis created for each unique service object that performs a business service (each unique\nobject bound to `this` at join points matched by the pointcut expression). The aspect\ninstance is created the first time that a method is invoked on the service object. The\naspect goes out of scope when the service object goes out of scope. Before the aspect\ninstance is created, none of the advice within it runs. As soon as the aspect instance\nhas been created, the advice declared within it runs at matched join points, but only\nwhen the service object is the one with which this aspect is associated. See the AspectJ\nProgramming Guide for more information on `per` clauses.\n\nThe `pertarget` instantiation model works in exactly the same way as `perthis`, but it\ncreates one aspect instance for each unique target object at matched join points.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/instantiation-models.adoc", "title": "instantiation-models", "heading": "instantiation-models", "heading_level": 1, "file_order": 4, "section_index": 0, "content_hash": "b1ee47cf194e879e3751ccec352affe262a66656d40e5261aaed6035b15e5ab3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/instantiation-models.adoc"}}
{"id": "sha256:fc89847191715f91d28e4ce86e4f5bdaaaa23455770fdaad93b47170c416ff60", "content": "[[aop-introductions]]\n\nIntroductions (known as inter-type declarations in AspectJ) enable an aspect to declare\nthat advised objects implement a given interface, and to provide an implementation of\nthat interface on behalf of those objects.\n\nYou can make an introduction by using the `@DeclareParents` annotation. This annotation\nis used to declare that matching types have a new parent (hence the name). For example,\ngiven an interface named `UsageTracked` and an implementation of that interface named\n`DefaultUsageTracked`, the following aspect declares that all implementors of service\ninterfaces also implement the `UsageTracked` interface (for example, for statistics via JMX):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Aspect\n\tpublic class UsageTracking {\n\n @DeclareParents(value=\"com.xyz.service.*+\", defaultImpl=DefaultUsageTracked.class)\n public static UsageTracked mixin;\n\n @Before(\"execution(* com.xyz..service.*.*(..)) && this(usageTracked)\")\n public void recordUsage(UsageTracked usageTracked) {\n usageTracked.incrementUseCount();\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Aspect\n\tclass UsageTracking {\n\n companion object {\n @DeclareParents(value = \"com.xyz.service.*+\",\n defaultImpl = DefaultUsageTracked::class)\n lateinit var mixin: UsageTracked\n }\n\n @Before(\"execution(* com.xyz..service.*.*(..)) && this(usageTracked)\")\n fun recordUsage(usageTracked: UsageTracked) {\n usageTracked.incrementUseCount()\n }\n\t}\n----\n======\n\nThe interface to be implemented is determined by the type of the annotated field. The\n`value` attribute of the `@DeclareParents` annotation is an AspectJ type pattern. Any\nbean of a matching type implements the `UsageTracked` interface. Note that, in the\nbefore advice of the preceding example, service beans can be directly used as\nimplementations of the `UsageTracked` interface. If accessing a bean programmatically,\nyou would write the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tUsageTracked usageTracked = context.getBean(\"myService\", UsageTracked.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tval usageTracked = context.getBean<UsageTracked>(\"myService\")\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/introductions.adoc", "title": "introductions", "heading": "introductions", "heading_level": 1, "file_order": 5, "section_index": 0, "content_hash": "fc89847191715f91d28e4ce86e4f5bdaaaa23455770fdaad93b47170c416ff60", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/introductions.adoc"}}
{"id": "sha256:36859102c891f38370be7c647fc4d12211aa9b526aff87d7c230e594b446be55", "content": "[[aop-pointcuts]]\n\nPointcuts determine join points of interest and thus enable us to control\nwhen advice runs. Spring AOP only supports method execution join points for Spring\nbeans, so you can think of a pointcut as matching the execution of methods on Spring\nbeans. A pointcut declaration has two parts: a signature comprising a name and any\nparameters and a pointcut expression that determines exactly which method\nexecutions we are interested in. In the @AspectJ annotation-style of AOP, a pointcut\nsignature is provided by a regular method definition, and the pointcut expression is\nindicated by using the `@Pointcut` annotation (the method serving as the pointcut signature\nmust have a `void` return type).\n\nAn example may help make this distinction between a pointcut signature and a pointcut\nexpression clear. The following example defines a pointcut named `anyOldTransfer` that\nmatches the execution of any method named `transfer`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Pointcut(\"execution(* transfer(..))\") // the pointcut expression\n\tprivate void anyOldTransfer() {} // the pointcut signature\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Pointcut(\"execution(* transfer(..))\") // the pointcut expression\n\tprivate fun anyOldTransfer() {} // the pointcut signature\n----\n======\n\nThe pointcut expression that forms the value of the `@Pointcut` annotation is a regular\nAspectJ pointcut expression. For a full discussion of AspectJ's pointcut language, see\nthe {aspectj-docs-progguide}/index.html[AspectJ\nProgramming Guide] (and, for extensions, the\n{aspectj-docs}/adk15notebook/index.html[AspectJ 5\nDeveloper's Notebook]) or one of the books on AspectJ (such as _Eclipse AspectJ_, by Colyer\net al., or _AspectJ in Action_, by Ramnivas Laddad).\n\n[[aop-pointcuts-designators]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/pointcuts.adoc", "title": "pointcuts", "heading": "pointcuts", "heading_level": 1, "file_order": 6, "section_index": 0, "content_hash": "36859102c891f38370be7c647fc4d12211aa9b526aff87d7c230e594b446be55", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/pointcuts.adoc"}}
{"id": "sha256:1e90c04d4a67613866ed50205b4f9a20a619a553f74621a3b834a29e19448171", "content": "Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut\nexpressions:\n\n* `execution`: For matching method execution join points. This is the primary\n pointcut designator to use when working with Spring AOP.\n* `within`: Limits matching to join points within certain types (the execution\n of a method declared within a matching type when using Spring AOP).\n* `this`: Limits matching to join points (the execution of methods when using Spring\n AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.\n* `target`: Limits matching to join points (the execution of methods when using\n Spring AOP) where the target object (application object being proxied) is an instance\n of the given type.\n* `args`: Limits matching to join points (the execution of methods when using Spring\n AOP) where the arguments are instances of the given types.\n* `@target`: Limits matching to join points (the execution of methods when using\n Spring AOP) where the class of the executing object has an annotation of the given type.\n* `@args`: Limits matching to join points (the execution of methods when using Spring\n AOP) where the runtime type of the actual arguments passed have annotations of the\n given types.\n* `@within`: Limits matching to join points within types that have the given\n annotation (the execution of methods declared in types with the given annotation when\n using Spring AOP).\n* `@annotation`: Limits matching to join points where the subject of the join point\n (the method being run in Spring AOP) has the given annotation.\n\n.Other pointcut types\n****\nThe full AspectJ pointcut language supports additional pointcut designators that are not\nsupported in Spring: `call`, `get`, `set`, `preinitialization`,\n`staticinitialization`, `initialization`, `handler`, `adviceexecution`, `withincode`, `cflow`,\n`cflowbelow`, `if`, `@this`, and `@withincode`. Use of these pointcut designators in pointcut\nexpressions interpreted by Spring AOP results in an `IllegalArgumentException` being\nthrown.\n\nThe set of pointcut designators supported by Spring AOP may be extended in future\nreleases to support more of the AspectJ pointcut designators.\n****\n\nBecause Spring AOP limits matching to only method execution join points, the preceding discussion\nof the pointcut designators gives a narrower definition than you can find in the\nAspectJ programming guide. In addition, AspectJ itself has type-based semantics and, at\nan execution join point, both `this` and `target` refer to the same object: the\nobject executing the method. Spring AOP is a proxy-based system and differentiates\nbetween the proxy object itself (which is bound to `this`) and the target object behind the\nproxy (which is bound to `target`).\n\n[NOTE]\n====\nDue to the proxy-based nature of Spring's AOP framework, calls within the target object\nare, by definition, not intercepted. For JDK proxies, only public interface method\ncalls on the proxy can be intercepted. With CGLIB, public and protected method calls on\nthe proxy are intercepted (and even package-visible methods, if necessary). However,\ncommon interactions through proxies should always be designed through public signatures.\n\nNote that pointcut definitions are generally matched against any intercepted method.\nIf a pointcut is strictly meant to be public-only, even in a CGLIB proxy scenario with\npotential non-public interactions through proxies, it needs to be defined accordingly.\n\nIf your interception needs to include method calls or even constructors within the target\nclass, consider the use of Spring-driven xref:core/aop/using-aspectj.adoc#aop-aj-ltw[native AspectJ weaving] instead\nof Spring's proxy-based AOP framework. This constitutes a different mode of AOP usage\nwith different characteristics, so be sure to make yourself familiar with weaving\nbefore making a decision.\n====\n\nSpring AOP also supports an additional PCD named `bean`. This PCD lets you limit\nthe matching of join points to a particular named Spring bean or to a set of named\nSpring beans (when using wildcards). The `bean` PCD has the following form:\n\n[source,indent=0,subs=\"verbatim\"]\n----\n\tbean(idOrNameOfBean)\n----\n\nThe `idOrNameOfBean` token can be the name of any Spring bean. Limited wildcard\nsupport that uses the `*` character is provided, so, if you establish some naming\nconventions for your Spring beans, you can write a `bean` PCD expression\nto select them. As is the case with other pointcut designators, the `bean` PCD can\nbe used with the `&&` (and), `||` (or), and `!` (negation) operators, too.\n\n[NOTE]\n====\nThe `bean` PCD is supported only in Spring AOP and not in\nnative AspectJ weaving. It is a Spring-specific extension to the standard PCDs that\nAspectJ defines and is, therefore, not available for aspects declared in the `@Aspect` model.\n\nThe `bean` PCD operates at the instance level (building on the Spring bean name\nconcept) rather than at the type level only (to which weaving-based AOP is limited).\nInstance-based pointcut designators are a special capability of Spring's\nproxy-based AOP framework and its close integration with the Spring bean factory, where\nit is natural and straightforward to identify specific beans by name.\n====\n\n[[aop-pointcuts-combining]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/pointcuts.adoc", "title": "pointcuts", "heading": "Supported Pointcut Designators", "heading_level": 2, "file_order": 6, "section_index": 1, "content_hash": "1e90c04d4a67613866ed50205b4f9a20a619a553f74621a3b834a29e19448171", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/pointcuts.adoc"}}
{"id": "sha256:02992a6a0f117d11c58be1e216fb65bdf2bf70ddd5915ddb45c7fc8ffcc9b669", "content": "You can combine pointcut expressions by using `&&,` `||` and `!`. You can also refer to\npointcut expressions by name. The following example shows three pointcut expressions:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz;\n\n\tpublic class Pointcuts {\n\n @Pointcut(\"execution(public * *(..))\")\n public void publicMethod() {} // <1>\n\n @Pointcut(\"within(com.xyz.trading..*)\")\n public void inTrading() {} // <2>\n\n @Pointcut(\"publicMethod() && inTrading()\")\n public void tradingOperation() {} // <3>\n\t}\n----\n<1> `publicMethod` matches if a method execution join point represents the execution\nof any public method.\n<2> `inTrading` matches if a method execution is in the trading module.\n<3> `tradingOperation` matches if a method execution represents any public method in the\ntrading module.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz\n\n\tclass Pointcuts {\n\n @Pointcut(\"execution(public * *(..))\")\n fun publicMethod() {} // <1>\n\n @Pointcut(\"within(com.xyz.trading..*)\")\n fun inTrading() {} // <2>\n\n @Pointcut(\"publicMethod() && inTrading()\")\n fun tradingOperation() {} // <3>\n\t}\n----\n<1> `publicMethod` matches if a method execution join point represents the execution\nof any public method.\n<2> `inTrading` matches if a method execution is in the trading module.\n<3> `tradingOperation` matches if a method execution represents any public method in the\ntrading module.\n======\n\nIt is a best practice to build more complex pointcut expressions out of smaller _named\npointcuts_, as shown above. When referring to pointcuts by name, normal Java visibility\nrules apply (you can see `private` pointcuts in the same type, `protected` pointcuts in\nthe hierarchy, `public` pointcuts anywhere, and so on). Visibility does not affect\npointcut matching.\n\n[[aop-common-pointcuts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/pointcuts.adoc", "title": "pointcuts", "heading": "Combining Pointcut Expressions", "heading_level": 2, "file_order": 6, "section_index": 2, "content_hash": "02992a6a0f117d11c58be1e216fb65bdf2bf70ddd5915ddb45c7fc8ffcc9b669", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/pointcuts.adoc"}}
{"id": "sha256:92c286ef825024a94f32d341b516afe8e6351c4f37ab04a4e64a1f17b4fd027a", "content": "When working with enterprise applications, developers often have the need to refer to\nmodules of the application and particular sets of operations from within several aspects.\nWe recommend defining a dedicated class that captures commonly used _named pointcut_\nexpressions for this purpose. Such a class typically resembles the following\n`CommonPointcuts` example (though what you name the class is up to you):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\",chomp=\"-packages\",fold=\"none\"]\n----\n\tpackage com.xyz;\n\n\timport org.aspectj.lang.annotation.Pointcut;\n\n\tpublic class CommonPointcuts {\n\n /**\n * A join point is in the web layer if the method is defined\n * in a type in the com.xyz.web package or any sub-package\n * under that.\n */\n @Pointcut(\"within(com.xyz.web..*)\")\n public void inWebLayer() {}\n\n /**\n * A join point is in the service layer if the method is defined\n * in a type in the com.xyz.service package or any sub-package\n * under that.\n */\n @Pointcut(\"within(com.xyz.service..*)\")\n public void inServiceLayer() {}\n\n /**\n * A join point is in the data access layer if the method is defined\n * in a type in the com.xyz.dao package or any sub-package\n * under that.\n */\n @Pointcut(\"within(com.xyz.dao..*)\")\n public void inDataAccessLayer() {}\n\n /**\n * A business service is the execution of any method defined on a service\n * interface. This definition assumes that interfaces are placed in the\n * \"service\" package, and that implementation types are in sub-packages.\n *\n * If you group service interfaces by functional area (for example,\n * in packages com.xyz.abc.service and com.xyz.def.service) then\n * the pointcut expression \"execution(* com.xyz..service.*.*(..))\"\n * could be used instead.\n *\n * Alternatively, you can write the expression using the 'bean'\n * PCD, like so \"bean(*Service)\". (This assumes that you have\n * named your Spring service beans in a consistent fashion.)\n */\n @Pointcut(\"execution(* com.xyz..service.*.*(..))\")\n public void businessService() {}\n\n /**\n * A data access operation is the execution of any method defined on a\n * DAO interface. This definition assumes that interfaces are placed in the\n * \"dao\" package, and that implementation types are in sub-packages.\n */\n @Pointcut(\"execution(* com.xyz.dao.*.*(..))\")\n public void dataAccessOperation() {}\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\",chomp=\"-packages\",fold=\"none\"]\n----\n\tpackage com.xyz\n\n\timport org.aspectj.lang.annotation.Pointcut\n\n\tclass CommonPointcuts {\n\n /**\n * A join point is in the web layer if the method is defined\n * in a type in the com.xyz.web package or any sub-package\n * under that.\n */\n @Pointcut(\"within(com.xyz.web..*)\")\n fun inWebLayer() {}\n\n /**\n * A join point is in the service layer if the method is defined\n * in a type in the com.xyz.service package or any sub-package\n * under that.\n */\n @Pointcut(\"within(com.xyz.service..*)\")\n fun inServiceLayer() {}\n\n /**\n * A join point is in the data access layer if the method is defined\n * in a type in the com.xyz.dao package or any sub-package\n * under that.\n */\n @Pointcut(\"within(com.xyz.dao..*)\")\n fun inDataAccessLayer() {}\n\n /**\n * A business service is the execution of any method defined on a service\n * interface. This definition assumes that interfaces are placed in the\n * \"service\" package, and that implementation types are in sub-packages.\n *\n * If you group service interfaces by functional area (for example,\n * in packages com.xyz.abc.service and com.xyz.def.service) then\n * the pointcut expression \"execution(* com.xyz..service.*.*(..))\"\n * could be used instead.\n *\n * Alternatively, you can write the expression using the 'bean'\n * PCD, like so \"bean(*Service)\". (This assumes that you have\n * named your Spring service beans in a consistent fashion.)\n */\n @Pointcut(\"execution(* com.xyz..service.*.*(..))\")\n fun businessService() {}\n\n /**\n * A data access operation is the execution of any method defined on a\n * DAO interface. This definition assumes that interfaces are placed in the\n * \"dao\" package, and that implementation types are in sub-packages.\n */\n @Pointcut(\"execution(* com.xyz.dao.*.*(..))\")\n fun dataAccessOperation() {}\n\n\t}\n----\n======\n\nYou can refer to the pointcuts defined in such a class anywhere you need a pointcut\nexpression by referencing the fully-qualified name of the class combined with the\n`@Pointcut` method's name. For example, to make the service layer transactional, you\ncould write the following which references the\n`com.xyz.CommonPointcuts.businessService()` _named pointcut_:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:config>\n <aop:advisor\n pointcut=\"com.xyz.CommonPointcuts.businessService()\"\n advice-ref=\"tx-advice\"/>\n\t</aop:config>\n\n\t<tx:advice id=\"tx-advice\">\n <tx:attributes>\n <tx:method name=\"*\" propagation=\"REQUIRED\"/>\n </tx:attributes>\n\t</tx:advice>\n----\n\nThe `<aop:config>` and `<aop:advisor>` elements are discussed in xref:core/aop/schema.adoc[Schema-based AOP Support]. The\ntransaction elements are discussed in xref:data-access/transaction.adoc[Transaction Management].\n\n[[aop-pointcuts-examples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/pointcuts.adoc", "title": "pointcuts", "heading": "Sharing Named Pointcut Definitions", "heading_level": 2, "file_order": 6, "section_index": 3, "content_hash": "92c286ef825024a94f32d341b516afe8e6351c4f37ab04a4e64a1f17b4fd027a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/pointcuts.adoc"}}
{"id": "sha256:bccb4c036184c6b245baba61fce0c707f3faf812d70bb12314795e9f2854dbe1", "content": "Spring AOP users are likely to use the `execution` pointcut designator the most often.\nThe format of an execution expression follows:\n\n[literal,indent=0,subs=\"verbatim\"]\n----\n\texecution(modifiers-pattern?\n ret-type-pattern\n declaring-type-pattern?name-pattern(param-pattern)\n throws-pattern?)\n----\n\nAll parts except the returning type pattern (`ret-type-pattern` in the preceding snippet),\nthe name pattern, and the parameters pattern are optional. The returning type pattern determines\nwhat the return type of the method must be in order for a join point to be matched.\n`{asterisk}` is most frequently used as the returning type pattern. It matches any return\ntype. A fully-qualified type name matches only when the method returns the given\ntype. The name pattern matches the method name. You can use the `{asterisk}` wildcard as all or\npart of a name pattern. If you specify a declaring type pattern,\ninclude a trailing `.` to join it to the name pattern component.\nThe parameters pattern is slightly more complex: `()` matches a\nmethod that takes no parameters, whereas `(..)` matches any number (zero or more) of parameters.\nThe `({asterisk})` pattern matches a method that takes one parameter of any type.\n`(*,String)` matches a method that takes two parameters. The first can be of any type, while the\nsecond must be a `String`. Consult the\n{aspectj-docs-progguide}/semantics-pointcuts.html[Language\nSemantics] section of the AspectJ Programming Guide for more information.\n\nThe following examples show some common pointcut expressions:\n\n* The execution of any public method:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\texecution(public * *(..))\n----\n\n* The execution of any method with a name that begins with `set`:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\texecution(* set*(..))\n----\n\n* The execution of any method defined by the `AccountService` interface:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\texecution(* com.xyz.service.AccountService.*(..))\n----\n\n* The execution of any method defined in the `service` package:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\texecution(* com.xyz.service.*.*(..))\n----\n\n* The execution of any method defined in the service package or one of its sub-packages:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\texecution(* com.xyz.service..*.*(..))\n----\n\n* Any join point (method execution only in Spring AOP) within the service package:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\twithin(com.xyz.service.*)\n----\n\n* Any join point (method execution only in Spring AOP) within the service package or one of its\nsub-packages:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\twithin(com.xyz.service..*)\n----\n\n* Any join point (method execution only in Spring AOP) where the proxy implements the\n`AccountService` interface:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\tthis(com.xyz.service.AccountService)\n----\n+\nNOTE: `this` is more commonly used in a binding form. See the section on xref:core/aop/ataspectj/advice.adoc[Declaring Advice]\nfor how to make the proxy object available in the advice body.\n\n* Any join point (method execution only in Spring AOP) where the target object\nimplements the `AccountService` interface:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\ttarget(com.xyz.service.AccountService)\n----\n+\nNOTE: `target` is more commonly used in a binding form. See the xref:core/aop/ataspectj/advice.adoc[Declaring Advice] section\nfor how to make the target object available in the advice body.\n\n* Any join point (method execution only in Spring AOP) that takes a single parameter\nand where the argument passed at runtime is `Serializable`:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\targs(java.io.Serializable)\n----\n+\nNOTE: `args` is more commonly used in a binding form. See the xref:core/aop/ataspectj/advice.adoc[Declaring Advice] section\nfor how to make the method arguments available in the advice body.\n+\nNote that the pointcut given in this example is different from `execution(*\n*(java.io.Serializable))`. The args version matches if the argument passed at runtime is\n`Serializable`, and the execution version matches if the method signature declares a single\nparameter of type `Serializable`.\n\n* Any join point (method execution only in Spring AOP) where the target object has a\n`@Transactional` annotation:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\t@target(org.springframework.transaction.annotation.Transactional)\n----\n+\nNOTE: You can also use `@target` in a binding form. See the xref:core/aop/ataspectj/advice.adoc[Declaring Advice] section for\nhow to make the annotation object available in the advice body.\n\n* Any join point (method execution only in Spring AOP) where the declared type of the\ntarget object has an `@Transactional` annotation:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\t@within(org.springframework.transaction.annotation.Transactional)\n----\n+\nNOTE: You can also use `@within` in a binding form. See the xref:core/aop/ataspectj/advice.adoc[Declaring Advice] section for\nhow to make the annotation object available in the advice body.\n\n* Any join point (method execution only in Spring AOP) where the executing method has an\n`@Transactional` annotation:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\t@annotation(org.springframework.transaction.annotation.Transactional)\n----\n+\nNOTE: You can also use `@annotation` in a binding form. See the xref:core/aop/ataspectj/advice.adoc[Declaring Advice] section\nfor how to make the annotation object available in the advice body.\n\n* Any join point (method execution only in Spring AOP) which takes a single parameter,\nand where the runtime type of the argument passed has the `@Classified` annotation:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\t@args(com.xyz.security.Classified)\n----\n+\nNOTE: You can also use `@args` in a binding form. See the xref:core/aop/ataspectj/advice.adoc[Declaring Advice] section\nhow to make the annotation object(s) available in the advice body.\n\n* Any join point (method execution only in Spring AOP) on a Spring bean named\n`tradeService`:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\tbean(tradeService)\n----\n\n* Any join point (method execution only in Spring AOP) on Spring beans having names that\nmatch the wildcard expression `*Service`:\n+\n[literal,indent=0,subs=\"verbatim\"]\n----\n\tbean(*Service)\n----\n\n[[writing-good-pointcuts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/pointcuts.adoc", "title": "pointcuts", "heading": "Examples", "heading_level": 2, "file_order": 6, "section_index": 4, "content_hash": "bccb4c036184c6b245baba61fce0c707f3faf812d70bb12314795e9f2854dbe1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/pointcuts.adoc"}}
{"id": "sha256:64dfae02dae7b76279ea4a2eaa1f8b253ae4c4ac095b089056c94ffb89c2713c", "content": "During compilation, AspectJ processes pointcuts in order to optimize matching\nperformance. Examining code and determining if each join point matches (statically or\ndynamically) a given pointcut is a costly process. (A dynamic match means the match\ncannot be fully determined from static analysis and that a test is placed in the code to\ndetermine if there is an actual match when the code is running). On first encountering a\npointcut declaration, AspectJ rewrites it into an optimal form for the matching\nprocess. What does this mean? Basically, pointcuts are rewritten in DNF (Disjunctive\nNormal Form) and the components of the pointcut are sorted such that those components\nthat are cheaper to evaluate are checked first. This means you do not have to worry\nabout understanding the performance of various pointcut designators and may supply them\nin any order in a pointcut declaration.\n\nHowever, AspectJ can work only with what it is told. For optimal performance of\nmatching, you should think about what you are trying to achieve and narrow the search\nspace for matches as much as possible in the definition. The existing designators\nnaturally fall into one of three groups: kinded, scoping, and contextual:\n\n* Kinded designators select a particular kind of join point:\n`execution`, `get`, `set`, `call`, and `handler`.\n* Scoping designators select a group of join points of interest\n(probably of many kinds): `within` and `withincode`\n* Contextual designators match (and optionally bind) based on context:\n`this`, `target`, and `@annotation`\n\nA well written pointcut should include at least the first two types (kinded and\nscoping). You can include the contextual designators to match based on\njoin point context or bind that context for use in the advice. Supplying only a\nkinded designator or only a contextual designator works but could affect weaving\nperformance (time and memory used), due to extra processing and analysis. Scoping\ndesignators are very fast to match, and using them means AspectJ can very quickly\ndismiss groups of join points that should not be further processed. A good\npointcut should always include one if possible.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj/pointcuts.adoc", "title": "pointcuts", "heading": "Writing Good Pointcuts", "heading_level": 2, "file_order": 6, "section_index": 5, "content_hash": "64dfae02dae7b76279ea4a2eaa1f8b253ae4c4ac095b089056c94ffb89c2713c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj/pointcuts.adoc"}}
{"id": "sha256:b5bf10c7e12e0aa7cd30c709a28d41c3cfea728e1e6aa08c4c6bb320ea7aa0f4", "content": "[[aop-aspectj-programmatic]]\n\nIn addition to declaring aspects in your configuration by using either `<aop:config>`\nor `<aop:aspectj-autoproxy>`, it is also possible to programmatically create proxies\nthat advise target objects. For the full details of Spring's AOP API, see the\nxref:core/aop-api.adoc[next chapter]. Here, we want to focus on the ability to automatically\ncreate proxies by using @AspectJ aspects.\n\nYou can use the `org.springframework.aop.aspectj.annotation.AspectJProxyFactory` class\nto create a proxy for a target object that is advised by one or more @AspectJ aspects.\nThe basic usage for this class is very simple, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t// create a factory that can generate a proxy for the given target object\n\tAspectJProxyFactory factory = new AspectJProxyFactory(targetObject);\n\n\t// add an aspect, the class must be an @AspectJ aspect\n\t// you can call this as many times as you need with different aspects\n\tfactory.addAspect(SecurityManager.class);\n\n\t// you can also add existing aspect instances, the type of the object supplied\n\t// must be an @AspectJ aspect\n\tfactory.addAspect(usageTracker);\n\n\t// now get the proxy object...\n\tMyInterfaceType proxy = factory.getProxy();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t// create a factory that can generate a proxy for the given target object\n\tval factory = AspectJProxyFactory(targetObject)\n\n\t// add an aspect, the class must be an @AspectJ aspect\n\t// you can call this as many times as you need with different aspects\n\tfactory.addAspect(SecurityManager::class.java)\n\n\t// you can also add existing aspect instances, the type of the object supplied\n\t// must be an @AspectJ aspect\n\tfactory.addAspect(usageTracker)\n\n\t// now get the proxy object...\n\tval proxy = factory.getProxy<Any>()\n----\n======\n\nSee the {spring-framework-api}/aop/aspectj/annotation/AspectJProxyFactory.html[javadoc] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/aspectj-programmatic.adoc", "title": "aspectj-programmatic", "heading": "aspectj-programmatic", "heading_level": 1, "file_order": 7, "section_index": 0, "content_hash": "b5bf10c7e12e0aa7cd30c709a28d41c3cfea728e1e6aa08c4c6bb320ea7aa0f4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/aspectj-programmatic.adoc"}}
{"id": "sha256:9e11c978d6dec0625e8aab9f87759bc38b8e691ce481d3dd2aad5579acbc9c10", "content": "[[aop-ataspectj]]\n\n@AspectJ refers to a style of declaring aspects as regular Java classes annotated with\nannotations. The @AspectJ style was introduced by the\n{aspectj-site}[AspectJ project] as part of the AspectJ 5 release. Spring\ninterprets the same annotations as AspectJ 5, using a library supplied by AspectJ\nfor pointcut parsing and matching. The AOP runtime is still pure Spring AOP, though, and\nthere is no dependency on the AspectJ compiler or weaver.\n\nNOTE: Using the AspectJ compiler and weaver enables use of the full AspectJ language and\nis discussed in xref:core/aop/using-aspectj.adoc[Using AspectJ with Spring Applications].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/ataspectj.adoc", "title": "ataspectj", "heading": "ataspectj", "heading_level": 1, "file_order": 8, "section_index": 0, "content_hash": "9e11c978d6dec0625e8aab9f87759bc38b8e691ce481d3dd2aad5579acbc9c10", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/ataspectj.adoc"}}
{"id": "sha256:10420909f7dcb6514543415baa253ad8230433ee7253c8518098fd84ebb24abe", "content": "[[aop-choosing]]\n\nOnce you have decided that an aspect is the best approach for implementing a given\nrequirement, how do you decide between using Spring AOP or AspectJ and between the\nAspect language (code) style, the @AspectJ annotation style, or the Spring XML style? These\ndecisions are influenced by a number of factors including application requirements,\ndevelopment tools, and team familiarity with AOP.\n\n[[aop-spring-or-aspectj]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/choosing.adoc", "title": "choosing", "heading": "choosing", "heading_level": 1, "file_order": 9, "section_index": 0, "content_hash": "10420909f7dcb6514543415baa253ad8230433ee7253c8518098fd84ebb24abe", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/choosing.adoc"}}
{"id": "sha256:5f4d81de187e0ef0c06c421c5e3bc76b57657059cae8c1e7ce1fac42cc413575", "content": "Use the simplest thing that can work. Spring AOP is simpler than using full AspectJ, as\nthere is no requirement to introduce the AspectJ compiler / weaver into your development\nand build processes. If you only need to advise the execution of operations on Spring\nbeans, Spring AOP is the right choice. If you need to advise objects not managed by\nthe Spring container (such as domain objects, typically), you need to use\nAspectJ. You also need to use AspectJ if you wish to advise join points other than\nsimple method executions (for example, field get or set join points and so on).\n\nWhen you use AspectJ, you have the choice of the AspectJ language syntax (also known as\nthe \"code style\") or the @AspectJ annotation style. If aspects play a large\nrole in your design, and you are able to use the https://www.eclipse.org/ajdt/[AspectJ\nDevelopment Tools (AJDT)] plugin for Eclipse, the AspectJ language syntax is the\npreferred option. It is cleaner and simpler because the language was purposefully\ndesigned for writing aspects. If you do not use Eclipse or have only a few aspects\nthat do not play a major role in your application, you may want to consider using\nthe @AspectJ style, sticking with regular Java compilation in your IDE, and adding\nan aspect weaving phase to your build script.\n\n[[aop-ataspectj-or-xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/choosing.adoc", "title": "choosing", "heading": "Spring AOP or Full AspectJ?", "heading_level": 2, "file_order": 9, "section_index": 1, "content_hash": "5f4d81de187e0ef0c06c421c5e3bc76b57657059cae8c1e7ce1fac42cc413575", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/choosing.adoc"}}
{"id": "sha256:cab8953a30b4592edd238506cd61a237c5d4eb91ac1c08653923ea67b7c3c836", "content": "If you have chosen to use Spring AOP, you have a choice of @AspectJ or XML style.\nThere are various tradeoffs to consider.\n\nThe XML style may be most familiar to existing Spring users, and it is backed by genuine\nPOJOs. When using AOP as a tool to configure enterprise services, XML can be a good\nchoice (a good test is whether you consider the pointcut expression to be a part of your\nconfiguration that you might want to change independently). With the XML style, it is\narguably clearer from your configuration which aspects are present in the system.\n\nThe XML style has two disadvantages. First, it does not fully encapsulate the\nimplementation of the requirement it addresses in a single place. The DRY principle says\nthat there should be a single, unambiguous, authoritative representation of any piece of\nknowledge within a system. When using the XML style, the knowledge of how a requirement\nis implemented is split across the declaration of the backing bean class and the XML in\nthe configuration file. When you use the @AspectJ style, this information is encapsulated\nin a single module: the aspect. Secondly, the XML style is slightly more limited in what\nit can express than the @AspectJ style: Only the \"singleton\" aspect instantiation model\nis supported, and it is not possible to combine named pointcuts declared in XML.\nFor example, in the @AspectJ style you can write something like the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Pointcut(\"execution(* get*())\")\n\tpublic void propertyAccess() {}\n\n\t@Pointcut(\"execution(com.xyz.Account+ *(..))\")\n\tpublic void operationReturningAnAccount() {}\n\n\t@Pointcut(\"propertyAccess() && operationReturningAnAccount()\")\n\tpublic void accountPropertyAccess() {}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Pointcut(\"execution(* get*())\")\n\tfun propertyAccess() {}\n\n\t@Pointcut(\"execution(com.xyz.Account+ *(..))\")\n\tfun operationReturningAnAccount() {}\n\n\t@Pointcut(\"propertyAccess() && operationReturningAnAccount()\")\n\tfun accountPropertyAccess() {}\n----\n======\n\nIn the XML style you can declare the first two pointcuts:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:pointcut id=\"propertyAccess\"\n expression=\"execution(* get*())\"/>\n\n\t<aop:pointcut id=\"operationReturningAnAccount\"\n expression=\"execution(com.xyz.Account+ *(..))\"/>\n----\n\nThe downside of the XML approach is that you cannot define the\n`accountPropertyAccess` pointcut by combining these definitions.\n\nThe @AspectJ style supports additional instantiation models and richer pointcut\ncomposition. It has the advantage of keeping the aspect as a modular unit. It also has\nthe advantage that the @AspectJ aspects can be understood (and thus consumed) both by\nSpring AOP and by AspectJ. So, if you later decide you need the capabilities of AspectJ\nto implement additional requirements, you can easily migrate to a classic AspectJ setup.\nIn general, the Spring team prefers the @AspectJ style for custom aspects beyond simple\nconfiguration of enterprise services.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/choosing.adoc", "title": "choosing", "heading": "@AspectJ or XML for Spring AOP?", "heading_level": 2, "file_order": 9, "section_index": 2, "content_hash": "cab8953a30b4592edd238506cd61a237c5d4eb91ac1c08653923ea67b7c3c836", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/choosing.adoc"}}
{"id": "sha256:c6aace7a152196c804ea5603dee041008107f163f736f2f168016259c6c55486", "content": "[[aop-introduction-defn]]\n\nLet us begin by defining some central AOP concepts and terminology. These terms are not\nSpring-specific. Unfortunately, AOP terminology is not particularly intuitive.\nHowever, it would be even more confusing if Spring used its own terminology.\n\n* Aspect: A modularization of a concern that cuts across multiple classes.\n Transaction management is a good example of a crosscutting concern in enterprise Java\n applications. In Spring AOP, aspects are implemented by using regular classes\n (the xref:core/aop/schema.adoc[schema-based approach]) or regular classes annotated with the\n `@Aspect` annotation (the xref:core/aop/ataspectj.adoc[@AspectJ style]).\n* Join point: A point during the execution of a program, such as the execution of a\n method or the handling of an exception. In Spring AOP, a join point always\n represents a method execution.\n* Advice: Action taken by an aspect at a particular join point. Different types of\n advice include \"around\", \"before\", and \"after\" advice. (Advice types are discussed\n later.) Many AOP frameworks, including Spring, model an advice as an interceptor and\n maintain a chain of interceptors around the join point.\n* Pointcut: A predicate that matches join points. Advice is associated with a\n pointcut expression and runs at any join point matched by the pointcut (for example,\n the execution of a method with a certain name). The concept of join points as matched\n by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut\n expression language by default.\n* Introduction: Declaring additional methods or fields on behalf of a type. Spring\n AOP lets you introduce new interfaces (and a corresponding implementation) to any\n advised object. For example, you could use an introduction to make a bean implement an\n `IsModified` interface, to simplify caching. (An introduction is known as an\n inter-type declaration in the AspectJ community.)\n* Target object: An object being advised by one or more aspects. Also referred to as\n the \"advised object\". Since Spring AOP is implemented by using runtime proxies, this\n object is always a proxied object.\n* AOP proxy: An object created by the AOP framework in order to implement the aspect\n contracts (advice method executions and so on). In the Spring Framework, an AOP proxy\n is a JDK dynamic proxy or a CGLIB proxy.\n* Weaving: linking aspects with other application types or objects to create an\n advised object. This can be done at compile time (using the AspectJ compiler, for\n example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks,\n performs weaving at runtime.\n\nSpring AOP includes the following types of advice:\n\n* Before advice: Advice that runs before a join point but that does not have\n the ability to prevent execution flow proceeding to the join point (unless it throws\n an exception).\n* After returning advice: Advice to be run after a join point completes\n normally (for example, if a method returns without throwing an exception).\n* After throwing advice: Advice to be run if a method exits by throwing an\n exception.\n* After (finally) advice: Advice to be run regardless of the means by which a\n join point exits (normal or exceptional return).\n* Around advice: Advice that surrounds a join point such as a method invocation.\n This is the most powerful kind of advice. Around advice can perform custom behavior\n before and after the method invocation. It is also responsible for choosing whether to\n proceed to the join point or to shortcut the advised method execution by returning its\n own return value or throwing an exception.\n\nAround advice is the most general kind of advice. Since Spring AOP, like AspectJ,\nprovides a full range of advice types, we recommend that you use the least powerful\nadvice type that can implement the required behavior. For example, if you need only to\nupdate a cache with the return value of a method, you are better off implementing an\nafter returning advice than an around advice, although an around advice can accomplish\nthe same thing. Using the most specific advice type provides a simpler programming model\nwith less potential for errors. For example, you do not need to invoke the `proceed()`\nmethod on the `JoinPoint` used for around advice, and, hence, you cannot fail to invoke it.\n\nAll advice parameters are statically typed so that you work with advice parameters of\nthe appropriate type (for example, the type of the return value from a method execution) rather\nthan `Object` arrays.\n\nThe concept of join points matched by pointcuts is the key to AOP, which distinguishes\nit from older technologies offering only interception. Pointcuts enable advice to be\ntargeted independently of the object-oriented hierarchy. For example, you can apply an\naround advice providing declarative transaction management to a set of methods that span\nmultiple objects (such as all business operations in the service layer).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/introduction-defn.adoc", "title": "introduction-defn", "heading": "introduction-defn", "heading_level": 1, "file_order": 10, "section_index": 0, "content_hash": "c6aace7a152196c804ea5603dee041008107f163f736f2f168016259c6c55486", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/introduction-defn.adoc"}}
{"id": "sha256:9a932d0d16d51cdfd54d17bb07314ef6b0f222986143f24f92de137dfa2104a3", "content": "[[aop-introduction-proxies]]\n\nSpring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This\nenables any interface (or set of interfaces) to be proxied.\n\nSpring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than\ninterfaces. By default, CGLIB is used if a business object does not implement an\ninterface. As it is good practice to program to interfaces rather than classes, business\nclasses normally implement one or more business interfaces. It is possible to\nxref:core/aop/proxying.adoc[force the use of CGLIB], in those (hopefully rare) cases where you\nneed to advise a method that is not declared on an interface or where you need to\npass a proxied object to a method as a concrete type.\n\nIt is important to grasp the fact that Spring AOP is proxy-based. See\nxref:core/aop/proxying.adoc#aop-understanding-aop-proxies[Understanding AOP Proxies]\nfor a thorough examination of exactly what this implementation detail actually means.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/introduction-proxies.adoc", "title": "introduction-proxies", "heading": "introduction-proxies", "heading_level": 1, "file_order": 11, "section_index": 0, "content_hash": "9a932d0d16d51cdfd54d17bb07314ef6b0f222986143f24f92de137dfa2104a3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/introduction-proxies.adoc"}}
{"id": "sha256:8da8294e88410e3c30b3f1a6ebb38a8b46f44aeec07a28e0bc882224a5242c51", "content": "[[aop-introduction-spring-defn]]\n\nSpring AOP is implemented in pure Java. There is no need for a special compilation\nprocess. Spring AOP does not need to control the class loader hierarchy and is thus\nsuitable for use in a servlet container or application server.\n\nSpring AOP currently supports only method execution join points (advising the execution\nof methods on Spring beans). Field interception is not implemented, although support for\nfield interception could be added without breaking the core Spring AOP APIs. If you need\nto advise field access and update join points, consider a language such as AspectJ.\n\nSpring AOP's approach to AOP differs from that of most other AOP frameworks. The aim is\nnot to provide the most complete AOP implementation (although Spring AOP is quite\ncapable). Rather, the aim is to provide a close integration between AOP implementation and\nSpring IoC, to help solve common problems in enterprise applications.\n\nThus, for example, the Spring Framework's AOP functionality is normally used in\nconjunction with the Spring IoC container. Aspects are configured by using normal bean\ndefinition syntax (although this allows powerful \"auto-proxying\" capabilities). This is a\ncrucial difference from other AOP implementations. You cannot do some things\neasily or efficiently with Spring AOP, such as advise very fine-grained objects (typically,\ndomain objects). AspectJ is the best choice in such cases. However, our\nexperience is that Spring AOP provides an excellent solution to most problems in\nenterprise Java applications that are amenable to AOP.\n\nSpring AOP never strives to compete with AspectJ to provide a comprehensive AOP\nsolution. We believe that both proxy-based frameworks such as Spring AOP and full-blown\nframeworks such as AspectJ are valuable and that they are complementary, rather than in\ncompetition. Spring seamlessly integrates Spring AOP and IoC with AspectJ, to enable\nall uses of AOP within a consistent Spring-based application\narchitecture. This integration does not affect the Spring AOP API or the AOP Alliance\nAPI. Spring AOP remains backward-compatible. See xref:core/aop-api.adoc[the following chapter]\nfor a discussion of the Spring AOP APIs.\n\n[NOTE]\n====\nOne of the central tenets of the Spring Framework is that of non-invasiveness. This\nis the idea that you should not be forced to introduce framework-specific classes and\ninterfaces into your business or domain model. However, in some places, the Spring Framework\ndoes give you the option to introduce Spring Framework-specific dependencies into your\ncodebase. The rationale in giving you such options is because, in certain scenarios, it\nmight be just plain easier to read or code some specific piece of functionality in such\na way. However, the Spring Framework (almost) always offers you the choice: You have the\nfreedom to make an informed decision as to which option best suits your particular use\ncase or scenario.\n\nOne such choice that is relevant to this chapter is that of which AOP framework (and\nwhich AOP style) to choose. You have the choice of AspectJ, Spring AOP, or both. You\nalso have the choice of either the @AspectJ annotation-style approach or the Spring XML\nconfiguration-style approach. The fact that this chapter chooses to introduce the\n@AspectJ-style approach first should not be taken as an indication that the Spring team\nfavors the @AspectJ annotation-style approach over the Spring XML configuration-style.\n\nSee xref:core/aop/choosing.adoc[Choosing which AOP Declaration Style to Use] for a more\ncomplete discussion of the advantages and disadvantages of each style.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/introduction-spring-defn.adoc", "title": "introduction-spring-defn", "heading": "introduction-spring-defn", "heading_level": 1, "file_order": 12, "section_index": 0, "content_hash": "8da8294e88410e3c30b3f1a6ebb38a8b46f44aeec07a28e0bc882224a5242c51", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/introduction-spring-defn.adoc"}}
{"id": "sha256:eef8d7e5e0d4c0f251532909fb01759cd9bc67be2e14883ce5d28a1daacfe4b7", "content": "[[aop-mixing-styles]]\n\nIt is perfectly possible to mix @AspectJ style aspects by using the auto-proxying support,\nschema-defined `<aop:aspect>` aspects, `<aop:advisor>` declared advisors, and even proxies\nand interceptors in other styles in the same configuration. All of these are implemented\nby using the same underlying support mechanism and can co-exist without any difficulty.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/mixing-styles.adoc", "title": "mixing-styles", "heading": "mixing-styles", "heading_level": 1, "file_order": 13, "section_index": 0, "content_hash": "eef8d7e5e0d4c0f251532909fb01759cd9bc67be2e14883ce5d28a1daacfe4b7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/mixing-styles.adoc"}}
{"id": "sha256:f410d058297f234393b035c0bbfd0db5cab442926bfd3fcefe76f7478761c358", "content": "[[aop-proxying]]\n\nSpring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given\ntarget object. JDK dynamic proxies are built into the JDK, whereas CGLIB is a common\nopen-source class definition library (repackaged into `spring-core`).\n\nIf the target object to be proxied implements at least one interface, a JDK dynamic\nproxy is used, and all of the interfaces implemented by the target type are proxied.\nIf the target object does not implement any interfaces, a CGLIB proxy is created which\nis a runtime-generated subclass of the target type.\n\nIf you want to force the use of CGLIB proxying (for example, to proxy every method\ndefined for the target object, not only those implemented by its interfaces),\nyou can do so. However, you should consider the following issues:\n\n* `final` classes cannot be proxied, because they cannot be extended.\n* `final` methods cannot be advised, because they cannot be overridden.\n* `private` methods cannot be advised, because they cannot be overridden.\n* Methods that are not visible â€“ for example, package-private methods in a parent class\n from a different package â€“ cannot be advised because they are effectively private.\n* The constructor of your proxied object will not be called twice, since the CGLIB proxy\n instance is created through Objenesis. However, if your JVM does not allow for\n constructor bypassing, you might see double invocations and corresponding debug log\n entries from Spring's AOP support.\n* Your CGLIB proxy usage may face limitations with the Java Module System. As a typical\n case, you cannot create a CGLIB proxy for a class from the `java.lang` package when\n deploying on the module path. Such cases require a JVM bootstrap flag\n `--add-opens=java.base/java.lang=ALL-UNNAMED` which is not available for modules.\n\n[[aop-forcing-proxy-types]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/proxying.adoc", "title": "proxying", "heading": "proxying", "heading_level": 1, "file_order": 14, "section_index": 0, "content_hash": "f410d058297f234393b035c0bbfd0db5cab442926bfd3fcefe76f7478761c358", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/proxying.adoc"}}
{"id": "sha256:07caa36dbeb59e06dcc379d0a5874df9f6526b705c35d09121b38ced062a6a79", "content": "To force the use of CGLIB proxies, set the value of the `proxy-target-class` attribute\nof the `<aop:config>` element to true, as follows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:config proxy-target-class=\"true\">\n <!-- other beans defined here... -->\n\t</aop:config>\n----\n\nTo force CGLIB proxying when you use the @AspectJ auto-proxy support, set the\n`proxy-target-class` attribute of the `<aop:aspectj-autoproxy>` element to `true`,\nas follows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:aspectj-autoproxy proxy-target-class=\"true\"/>\n----\n\n[NOTE]\n====\nMultiple `<aop:config/>` sections are collapsed into a single unified auto-proxy creator\nat runtime, which applies the _strongest_ proxy settings that any of the\n`<aop:config/>` sections (typically from different XML bean definition files) specified.\nThis also applies to the `<tx:annotation-driven/>` and `<aop:aspectj-autoproxy/>`\nelements.\n\nTo be clear, using `proxy-target-class=\"true\"` on `<tx:annotation-driven/>`,\n`<aop:aspectj-autoproxy/>`, or `<aop:config/>` elements forces the use of CGLIB\nproxies _for all three of them_.\n====\n\n`@EnableAspectJAutoProxy`, `@EnableTransactionManagement` and related configuration\nannotations offer a corresponding `proxyTargetClass` attribute. These are collapsed\ninto a single unified auto-proxy creator too, effectively applying the _strongest_\nproxy settings at runtime. As of 7.0, this applies to individual proxy processors\nas well, for example `@EnableAsync`, consistently participating in unified global\ndefault settings for all auto-proxying attempts in a given application.\n\nThe global default proxy type may differ between setups. While the core framework\nsuggests interface-based proxies by default, Spring Boot may - depending on\nconfiguration properties - enable class-based proxies by default.\n\nAs of 7.0, forcing a specific proxy type for individual beans is possible through\nthe `@Proxyable` annotation on a given `@Bean` method or `@Component` class, with\n`@Proxyable(INTERFACES)` or `@Proxyable(TARGET_CLASS)` overriding any globally\nconfigured default. For very specific purposes, you may even specify the proxy\ninterface(s) to use through `@Proxyable(interfaces=...)`, limiting the exposure\nto selected interfaces rather than all interfaces that the target bean implements.\n\n[[aop-understanding-aop-proxies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/proxying.adoc", "title": "proxying", "heading": "Forcing Specific AOP Proxy Types", "heading_level": 2, "file_order": 14, "section_index": 1, "content_hash": "07caa36dbeb59e06dcc379d0a5874df9f6526b705c35d09121b38ced062a6a79", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/proxying.adoc"}}
{"id": "sha256:30e2ade0911bd9b44a5169b606d8d75d155a97fb25e6f330d3f1b3e0480c9b66", "content": "Spring AOP is proxy-based. It is vitally important that you grasp the semantics of\nwhat that last statement actually means before you write your own aspects or use any of\nthe Spring AOP-based aspects supplied with the Spring Framework.\n\nConsider first the scenario where you have a plain-vanilla, un-proxied object reference,\nas the following code snippet shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic class SimplePojo implements Pojo {\n\n public void foo() {\n // this next method invocation is a direct call on the 'this' reference\n this.bar();\n }\n\n public void bar() {\n // some logic...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tclass SimplePojo : Pojo {\n\n fun foo() {\n // this next method invocation is a direct call on the 'this' reference\n this.bar()\n }\n\n fun bar() {\n // some logic...\n }\n\t}\n----\n======\n\nIf you invoke a method on an object reference, the method is invoked directly on\nthat object reference, as the following image and listing show:\n\nimage::aop-proxy-plain-pojo-call.png[]\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic class Main {\n\n public static void main(String[] args) {\n Pojo pojo = new SimplePojo();\n // this is a direct method call on the 'pojo' reference\n pojo.foo();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tfun main() {\n val pojo = SimplePojo()\n // this is a direct method call on the 'pojo' reference\n pojo.foo()\n\t}\n----\n======\n\nThings change slightly when the reference that client code has is a proxy. Consider the\nfollowing diagram and code snippet:\n\nimage::aop-proxy-call.png[]\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic class Main {\n\n public static void main(String[] args) {\n ProxyFactory factory = new ProxyFactory(new SimplePojo());\n factory.addInterface(Pojo.class);\n factory.addAdvice(new RetryAdvice());\n\n Pojo pojo = (Pojo) factory.getProxy();\n // this is a method call on the proxy!\n pojo.foo();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\nfun main() {\n\tval factory = ProxyFactory(SimplePojo())\n\tfactory.addInterface(Pojo::class.java)\n\tfactory.addAdvice(RetryAdvice())\n\n\tval pojo = factory.proxy as Pojo\n\t// this is a method call on the proxy!\n\tpojo.foo()\n}\n----\n======\n\nThe key thing to understand here is that the client code inside the `main(..)` method\nof the `Main` class has a reference to the proxy. This means that method calls on that\nobject reference are calls on the proxy. As a result, the proxy can delegate to all of\nthe interceptors (advice) that are relevant to that particular method call. However,\nonce the call has finally reached the target object (the `SimplePojo` reference in\nthis case), any method calls that it may make on itself, such as `this.bar()` or\n`this.foo()`, are going to be invoked against the `this` reference, and not the proxy.\nThis has important implications. It means that self invocation is not going to result\nin the advice associated with a method invocation getting a chance to run. In other words,\nself invocation via an explicit or implicit `this` reference will bypass the advice.\n\nTo address that, you have the following options.\n\nAvoid self invocation ::\n The best approach (the term \"best\" is used loosely here) is to refactor your code such\n that the self invocation does not happen. This does entail some work on your part, but\n it is the best, least-invasive approach.\nInject a self reference ::\n An alternative approach is to make use of\n xref:core/beans/annotation-config/autowired.adoc#beans-autowired-annotation-self-injection[self injection],\n and invoke methods on the proxy via the self reference instead of via `this`.\nUse `AopContext.currentProxy()` ::\n This last approach is highly discouraged, and we hesitate to point it out, in favor of\n the previous options. However, as a last resort you can choose to tie the logic within\n your class to Spring AOP, as the following example shows.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic class SimplePojo implements Pojo {\n\n public void foo() {\n // This works, but it should be avoided if possible.\n ((Pojo) AopContext.currentProxy()).bar();\n }\n\n public void bar() {\n // some logic...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tclass SimplePojo : Pojo {\n\n fun foo() {\n // This works, but it should be avoided if possible.\n (AopContext.currentProxy() as Pojo).bar()\n }\n\n fun bar() {\n // some logic...\n }\n\t}\n----\n======\n\nThe use of `AopContext.currentProxy()` totally couples your code to Spring AOP, and it\nmakes the class itself aware of the fact that it is being used in an AOP context, which\nreduces some of the benefits of AOP. It also requires that the `ProxyFactory` is\nconfigured to expose the proxy, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic class Main {\n\n public static void main(String[] args) {\n ProxyFactory factory = new ProxyFactory(new SimplePojo());\n factory.addInterface(Pojo.class);\n factory.addAdvice(new RetryAdvice());\n factory.setExposeProxy(true);\n\n Pojo pojo = (Pojo) factory.getProxy();\n // this is a method call on the proxy!\n pojo.foo();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tfun main() {\n val factory = ProxyFactory(SimplePojo())\n factory.addInterface(Pojo::class.java)\n factory.addAdvice(RetryAdvice())\n factory.isExposeProxy = true\n\n val pojo = factory.proxy as Pojo\n // this is a method call on the proxy!\n pojo.foo()\n\t}\n----\n======\n\nNOTE: AspectJ compile-time weaving and load-time weaving do not have this self-invocation\nissue because they apply advice within the bytecode instead of via a proxy.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/proxying.adoc", "title": "proxying", "heading": "Understanding AOP Proxies", "heading_level": 2, "file_order": 14, "section_index": 2, "content_hash": "30e2ade0911bd9b44a5169b606d8d75d155a97fb25e6f330d3f1b3e0480c9b66", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/proxying.adoc"}}
{"id": "sha256:ccde6aa653f3fdfcd2be60c74c3caa0017f9948cbb8f40674be8e8bf892dcf34", "content": "[[aop-resources]]\n\nMore information on AspectJ can be found on the {aspectj-site}[AspectJ website].\n\n_Eclipse AspectJ_ by Adrian Colyer et. al. (Addison-Wesley, 2005) provides a\ncomprehensive introduction and reference for the AspectJ language.\n\n_AspectJ in Action_, Second Edition by Ramnivas Laddad (Manning, 2009) comes highly\nrecommended. The focus of the book is on AspectJ, but a lot of general AOP themes are\nexplored (in some depth).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/resources.adoc", "title": "resources", "heading": "resources", "heading_level": 1, "file_order": 15, "section_index": 0, "content_hash": "ccde6aa653f3fdfcd2be60c74c3caa0017f9948cbb8f40674be8e8bf892dcf34", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/resources.adoc"}}
{"id": "sha256:0ffad9eb69901428ef8690e44854dcfb60e2ef01c304e8c91a62c1f3c8244f12", "content": "[[aop-schema]]\n\nIf you prefer an XML-based format, Spring also offers support for defining aspects\nusing the `aop` namespace tags. The exact same pointcut expressions and advice kinds\nas when using the @AspectJ style are supported. Hence, in this section we focus on\nthat syntax and refer the reader to the discussion in the previous section\n(xref:core/aop/ataspectj.adoc[@AspectJ support]) for an understanding of writing pointcut expressions and the binding\nof advice parameters.\n\nTo use the aop namespace tags described in this section, you need to import the\n`spring-aop` schema, as described in xref:core/appendix/xsd-schemas.adoc[XML Schema-based configuration]\n. See xref:core/appendix/xsd-schemas.adoc#aop[the AOP schema]\nfor how to import the tags in the `aop` namespace.\n\nWithin your Spring configurations, all aspect and advisor elements must be placed within\nan `<aop:config>` element (you can have more than one `<aop:config>` element in an\napplication context configuration). An `<aop:config>` element can contain pointcut,\nadvisor, and aspect elements (note that these must be declared in that order).\n\nWARNING: The `<aop:config>` style of configuration makes heavy use of Spring's\nxref:core/aop-api/autoproxy.adoc[auto-proxying] mechanism. This can cause issues (such as advice\nnot being woven) if you already use explicit auto-proxying through the use of\n`BeanNameAutoProxyCreator` or something similar. The recommended usage pattern is to\nuse either only the `<aop:config>` style or only the `AutoProxyCreator` style and\nnever mix them.\n\n[[aop-schema-declaring-an-aspect]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "schema", "heading_level": 1, "file_order": 16, "section_index": 0, "content_hash": "0ffad9eb69901428ef8690e44854dcfb60e2ef01c304e8c91a62c1f3c8244f12", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:92072c06ac44247137773eb56090ada64538dc14789055694f7a488625698b5c", "content": "When you use the schema support, an aspect is a regular Java object defined as a bean in\nyour Spring application context. The state and behavior are captured in the fields and\nmethods of the object, and the pointcut and advice information are captured in the XML.\n\nYou can declare an aspect by using the `<aop:aspect>` element, and reference the backing bean\nby using the `ref` attribute, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:config>\n <aop:aspect id=\"myAspect\" ref=\"aBean\">\n ...\n </aop:aspect>\n\t</aop:config>\n\n\t<bean id=\"aBean\" class=\"...\">\n ...\n\t</bean>\n----\n\nThe bean that backs the aspect (`aBean` in this case) can of course be configured and\ndependency injected just like any other Spring bean.\n\n[[aop-schema-pointcuts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "Declaring an Aspect", "heading_level": 2, "file_order": 16, "section_index": 1, "content_hash": "92072c06ac44247137773eb56090ada64538dc14789055694f7a488625698b5c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:65ffb8c54f73df9348c2256f76634e015ed88b1b690bbd43f88e4fb334b4bde9", "content": "You can declare a _named pointcut_ inside an `<aop:config>` element, letting the pointcut\ndefinition be shared across several aspects and advisors.\n\nA pointcut that represents the execution of any business service in the service layer can\nbe defined as follows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:config>\n\n <aop:pointcut id=\"businessService\"\n expression=\"execution(* com.xyz.service.*.*(..))\" />\n\n\t</aop:config>\n----\n\nNote that the pointcut expression itself uses the same AspectJ pointcut expression\nlanguage as described in xref:core/aop/ataspectj.adoc[@AspectJ support]. If you use the schema based declaration\nstyle, you can also refer to _named pointcuts_ defined in `@Aspect` types within the\npointcut expression. Thus, another way of defining the above pointcut would be as follows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:config>\n\n <aop:pointcut id=\"businessService\"\n expression=\"com.xyz.CommonPointcuts.businessService()\" /> <1>\n\n\t</aop:config>\n----\n<1> References the `businessService` named pointcut defined in xref:core/aop/ataspectj/pointcuts.adoc#aop-common-pointcuts[Sharing Named Pointcut Definitions].\n\nDeclaring a pointcut _inside_ an aspect is very similar to declaring a top-level pointcut,\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:config>\n\n <aop:aspect id=\"myAspect\" ref=\"aBean\">\n\n <aop:pointcut id=\"businessService\"\n expression=\"execution(* com.xyz.service.*.*(..))\"/>\n\n ...\n </aop:aspect>\n\n\t</aop:config>\n----\n\nIn much the same way as an @AspectJ aspect, pointcuts declared by using the schema based\ndefinition style can collect join point context. For example, the following pointcut\ncollects the `this` object as the join point context and passes it to the advice:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:config>\n\n <aop:aspect id=\"myAspect\" ref=\"aBean\">\n\n <aop:pointcut id=\"businessService\"\n expression=\"execution(* com.xyz.service.*.*(..)) &amp;&amp; this(service)\"/>\n\n <aop:before pointcut-ref=\"businessService\" method=\"monitor\"/>\n\n ...\n </aop:aspect>\n\n\t</aop:config>\n----\n\nThe advice must be declared to receive the collected join point context by including\nparameters of the matching names, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic void monitor(Object service) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tfun monitor(service: Any) {\n // ...\n\t}\n----\n======\n\nWhen combining pointcut sub-expressions, `+&amp;&amp;+` is awkward within an XML\ndocument, so you can use the `and`, `or`, and `not` keywords in place of `+&amp;&amp;+`,\n`||`, and `!`, respectively. For example, the previous pointcut can be better written as\nfollows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:config>\n\n <aop:aspect id=\"myAspect\" ref=\"aBean\">\n\n <aop:pointcut id=\"businessService\"\n expression=\"execution(* com.xyz.service.*.*(..)) and this(service)\"/>\n\n <aop:before pointcut-ref=\"businessService\" method=\"monitor\"/>\n\n ...\n </aop:aspect>\n\n\t</aop:config>\n----\n\nNote that pointcuts defined in this way are referred to by their XML `id` and cannot be\nused as named pointcuts to form composite pointcuts. The named pointcut support in the\nschema-based definition style is thus more limited than that offered by the @AspectJ style.\n\n[[aop-schema-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "Declaring a Pointcut", "heading_level": 2, "file_order": 16, "section_index": 2, "content_hash": "65ffb8c54f73df9348c2256f76634e015ed88b1b690bbd43f88e4fb334b4bde9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:a2af8bb8dfa22ff29b114c10a3457432af6cfb554d3fa54b8f59303a5f3a0aae", "content": "The schema-based AOP support uses the same five kinds of advice as the @AspectJ style, and they have\nexactly the same semantics.\n\n[[aop-schema-advice-before]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "Declaring Advice", "heading_level": 2, "file_order": 16, "section_index": 3, "content_hash": "a2af8bb8dfa22ff29b114c10a3457432af6cfb554d3fa54b8f59303a5f3a0aae", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:ad8dbdab9b8489918a1b585b693513ee9d133b57f74fd300d773f8ece1a4627f", "content": "Before advice runs before a matched method execution. It is declared inside an\n`<aop:aspect>` by using the `<aop:before>` element, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:aspect id=\"beforeExample\" ref=\"aBean\">\n\n <aop:before\n pointcut-ref=\"dataAccessOperation\"\n method=\"doAccessCheck\"/>\n\n ...\n\n\t</aop:aspect>\n----\n\nIn the example above, `dataAccessOperation` is the `id` of a _named pointcut_ defined at\nthe top (`<aop:config>`) level (see xref:core/aop/schema.adoc#aop-schema-pointcuts[Declaring a Pointcut]).\n\nNOTE: As we noted in the discussion of the @AspectJ style, using _named pointcuts_ can\nsignificantly improve the readability of your code. See xref:core/aop/ataspectj/pointcuts.adoc#aop-common-pointcuts[Sharing Named Pointcut Definitions] for\ndetails.\n\nTo define the pointcut inline instead, replace the `pointcut-ref` attribute with a\n`pointcut` attribute, as follows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:aspect id=\"beforeExample\" ref=\"aBean\">\n\n <aop:before\n pointcut=\"execution(* com.xyz.dao.*.*(..))\"\n method=\"doAccessCheck\"/>\n\n ...\n\n\t</aop:aspect>\n----\n\nThe `method` attribute identifies a method (`doAccessCheck`) that provides the body of\nthe advice. This method must be defined for the bean referenced by the aspect element\nthat contains the advice. Before a data access operation is performed (a method execution\njoin point matched by the pointcut expression), the `doAccessCheck` method on the aspect\nbean is invoked.\n\n[[aop-schema-advice-after-returning]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "Before Advice", "heading_level": 3, "file_order": 16, "section_index": 4, "content_hash": "ad8dbdab9b8489918a1b585b693513ee9d133b57f74fd300d773f8ece1a4627f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:1d6f89afb5864eb1d2887a1f7104b09939bfc0a60f8aba2ba65c4536d227813c", "content": "After returning advice runs when a matched method execution completes normally. It is\ndeclared inside an `<aop:aspect>` in the same way as before advice. The following example\nshows how to declare it:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:aspect id=\"afterReturningExample\" ref=\"aBean\">\n\n <aop:after-returning\n pointcut=\"execution(* com.xyz.dao.*.*(..))\"\n method=\"doAccessCheck\"/>\n\n ...\n\t</aop:aspect>\n----\n\nAs in the @AspectJ style, you can get the return value within the advice body.\nTo do so, use the `returning` attribute to specify the name of the parameter to which\nthe return value should be passed, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:aspect id=\"afterReturningExample\" ref=\"aBean\">\n\n <aop:after-returning\n pointcut=\"execution(* com.xyz.dao.*.*(..))\"\n returning=\"retVal\"\n method=\"doAccessCheck\"/>\n\n ...\n\t</aop:aspect>\n----\n\nThe `doAccessCheck` method must declare a parameter named `retVal`. The type of this\nparameter constrains matching in the same way as described for `@AfterReturning`. For\nexample, you can declare the method signature as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic void doAccessCheck(Object retVal) {...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tfun doAccessCheck(retVal: Any) {...\n----\n======\n\n[[aop-schema-advice-after-throwing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "After Returning Advice", "heading_level": 3, "file_order": 16, "section_index": 5, "content_hash": "1d6f89afb5864eb1d2887a1f7104b09939bfc0a60f8aba2ba65c4536d227813c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:cf18da8d54ddd3663968648bd08ebfebad6294bcd3b87e51c9a43f8d9a607c13", "content": "After throwing advice runs when a matched method execution exits by throwing an\nexception. It is declared inside an `<aop:aspect>` by using the `after-throwing` element,\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:aspect id=\"afterThrowingExample\" ref=\"aBean\">\n\n <aop:after-throwing\n pointcut=\"execution(* com.xyz.dao.*.*(..))\"\n method=\"doRecoveryActions\"/>\n\n ...\n\t</aop:aspect>\n----\n\nAs in the @AspectJ style, you can get the thrown exception within the advice body.\nTo do so, use the `throwing` attribute to specify the name of the parameter to\nwhich the exception should be passed as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:aspect id=\"afterThrowingExample\" ref=\"aBean\">\n\n <aop:after-throwing\n pointcut=\"execution(* com.xyz.dao.*.*(..))\"\n throwing=\"dataAccessEx\"\n method=\"doRecoveryActions\"/>\n\n ...\n\t</aop:aspect>\n----\n\nThe `doRecoveryActions` method must declare a parameter named `dataAccessEx`.\nThe type of this parameter constrains matching in the same way as described for\n`@AfterThrowing`. For example, the method signature may be declared as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic void doRecoveryActions(DataAccessException dataAccessEx) {...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tfun doRecoveryActions(dataAccessEx: DataAccessException) {...\n----\n======\n\n[[aop-schema-advice-after-finally]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "After Throwing Advice", "heading_level": 3, "file_order": 16, "section_index": 6, "content_hash": "cf18da8d54ddd3663968648bd08ebfebad6294bcd3b87e51c9a43f8d9a607c13", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:db854bfd4be1df788ec499fde999dbd51c372cf1beb627cd99220d7027e03aad", "content": "After (finally) advice runs no matter how a matched method execution exits.\nYou can declare it by using the `after` element, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:aspect id=\"afterFinallyExample\" ref=\"aBean\">\n\n <aop:after\n pointcut=\"execution(* com.xyz.dao.*.*(..))\"\n method=\"doReleaseLock\"/>\n\n ...\n\t</aop:aspect>\n----\n\n[[aop-schema-advice-around]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "After (Finally) Advice", "heading_level": 3, "file_order": 16, "section_index": 7, "content_hash": "db854bfd4be1df788ec499fde999dbd51c372cf1beb627cd99220d7027e03aad", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:869cd5292be38942cc9c763f9a359b4eab1628a9f928c619c740cdf88d208c0b", "content": "The last kind of advice is _around_ advice. Around advice runs \"around\" a matched\nmethod's execution. It has the opportunity to do work both before and after the method\nruns and to determine when, how, and even if the method actually gets to run at all.\nAround advice is often used if you need to share state before and after a method\nexecution in a thread-safe manner â€“ for example, starting and stopping a timer.\n\n[TIP]\n====\nAlways use the least powerful form of advice that meets your requirements.\n\nFor example, do not use _around_ advice if _before_ advice is sufficient for your needs.\n====\n\nYou can declare around advice by using the `aop:around` element. The advice method should\ndeclare `Object` as its return type, and the first parameter of the method must be of\ntype `ProceedingJoinPoint`. Within the body of the advice method, you must invoke\n`proceed()` on the `ProceedingJoinPoint` in order for the underlying method to run.\nInvoking `proceed()` without arguments will result in the caller's original arguments\nbeing supplied to the underlying method when it is invoked. For advanced use cases, there\nis an overloaded variant of the `proceed()` method which accepts an array of arguments\n(`Object[]`). The values in the array will be used as the arguments to the underlying\nmethod when it is invoked. See xref:core/aop/ataspectj/advice.adoc#aop-ataspectj-around-advice[Around Advice] for notes on calling\n`proceed` with an `Object[]`.\n\nThe following example shows how to declare around advice in XML:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:aspect id=\"aroundExample\" ref=\"aBean\">\n\n <aop:around\n pointcut=\"execution(* com.xyz.service.*.*(..))\"\n method=\"doBasicProfiling\"/>\n\n ...\n\t</aop:aspect>\n----\n\nThe implementation of the `doBasicProfiling` advice can be exactly the same as in the\n@AspectJ example (minus the annotation, of course), as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {\n // start stopwatch\n Object retVal = pjp.proceed();\n // stop stopwatch\n return retVal;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tfun doBasicProfiling(pjp: ProceedingJoinPoint): Any? {\n // start stopwatch\n val retVal = pjp.proceed()\n // stop stopwatch\n return pjp.proceed()\n\t}\n----\n======\n\n[[aop-schema-params]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "Around Advice", "heading_level": 3, "file_order": 16, "section_index": 8, "content_hash": "869cd5292be38942cc9c763f9a359b4eab1628a9f928c619c740cdf88d208c0b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:0b5a7acc89c71b239de39e2f39d785f63c60fdfbd00451b91e2d107e6598dcb1", "content": "The schema-based declaration style supports fully typed advice in the same way as\ndescribed for the @AspectJ support -- by matching pointcut parameters by name against\nadvice method parameters. See\nxref:core/aop/ataspectj/advice.adoc#aop-ataspectj-advice-params[Advice Parameters] for details.\nIf you wish to explicitly specify argument names for the advice methods (not relying on the\ndetection strategies previously described), you can do so by using the `arg-names`\nattribute of the advice element, which is treated in the same manner as the `argNames`\nattribute in an advice annotation (as described in\nxref:core/aop/ataspectj/advice.adoc#aop-ataspectj-advice-params-names[Determining Argument Names]).\nThe following example shows how to specify an argument name in XML:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:before\n pointcut=\"com.xyz.Pointcuts.publicMethod() and @annotation(auditable)\" <1>\n method=\"audit\"\n arg-names=\"auditable\" />\n----\n<1> References the `publicMethod` named pointcut defined in\nxref:core/aop/ataspectj/pointcuts.adoc#aop-pointcuts-combining[Combining Pointcut Expressions].\n\nThe `arg-names` attribute accepts a comma-delimited list of parameter names.\n\nThe following slightly more involved example of the XSD-based approach shows\nsome around advice used in conjunction with a number of strongly typed parameters:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz.service;\n\n\tpublic interface PersonService {\n\n Person getPerson(String personName, int age);\n\t}\n\n\tpublic class DefaultPersonService implements PersonService {\n\n public Person getPerson(String name, int age) {\n return new Person(name, age);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz.service\n\n\tinterface PersonService {\n\n fun getPerson(personName: String, age: Int): Person\n\t}\n\n\tclass DefaultPersonService : PersonService {\n\n fun getPerson(name: String, age: Int): Person {\n return Person(name, age)\n }\n\t}\n----\n======\n\nNext up is the aspect. Notice the fact that the `profile(..)` method accepts a number of\nstrongly-typed parameters, the first of which happens to be the join point used to\nproceed with the method call. The presence of this parameter is an indication that the\n`profile(..)` is to be used as `around` advice, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz;\n\n\timport org.aspectj.lang.ProceedingJoinPoint;\n\timport org.springframework.util.StopWatch;\n\n\tpublic class SimpleProfiler {\n\n public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable {\n StopWatch clock = new StopWatch(\"Profiling for '\" + name + \"' and '\" + age + \"'\");\n try {\n clock.start(call.toShortString());\n return call.proceed();\n } finally {\n clock.stop();\n System.out.println(clock.prettyPrint());\n }\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz\n\n\timport org.aspectj.lang.ProceedingJoinPoint\n\timport org.springframework.util.StopWatch\n\n\tclass SimpleProfiler {\n\n fun profile(call: ProceedingJoinPoint, name: String, age: Int): Any? {\n val clock = StopWatch(\"Profiling for '$name' and '$age'\")\n try {\n clock.start(call.toShortString())\n return call.proceed()\n } finally {\n clock.stop()\n println(clock.prettyPrint())\n }\n }\n\t}\n----\n======\n\nFinally, the following example XML configuration effects the execution of the\npreceding advice for a particular join point:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:aop=\"http://www.springframework.org/schema/aop\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/aop\n https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n <!-- this is the object that will be proxied by Spring's AOP infrastructure -->\n <bean id=\"personService\" class=\"com.xyz.service.DefaultPersonService\"/>\n\n <!-- this is the actual advice itself -->\n <bean id=\"profiler\" class=\"com.xyz.SimpleProfiler\"/>\n\n <aop:config>\n <aop:aspect ref=\"profiler\">\n\n <aop:pointcut id=\"theExecutionOfSomePersonServiceMethod\"\n expression=\"execution(* com.xyz.service.PersonService.getPerson(String,int))\n and args(name, age)\"/>\n\n <aop:around pointcut-ref=\"theExecutionOfSomePersonServiceMethod\"\n method=\"profile\"/>\n\n </aop:aspect>\n </aop:config>\n\n\t</beans>\n----\n\nConsider the following driver script:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic class Boot {\n\n public static void main(String[] args) {\n ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");\n PersonService person = ctx.getBean(PersonService.class);\n person.getPerson(\"Pengo\", 12);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tfun main() {\n val ctx = ClassPathXmlApplicationContext(\"beans.xml\")\n val person = ctx.getBean(PersonService.class)\n person.getPerson(\"Pengo\", 12)\n\t}\n----\n======\n\nWith such a `Boot` class, we would get output similar to the following on standard output:\n\n[literal,subs=\"verbatim\"]\n----\nStopWatch 'Profiling for 'Pengo' and '12': running time (millis) = 0\n-----------------------------------------\nms % Task name\n-----------------------------------------\n00000 ? execution(getFoo)\n----\n\n[[aop-ordering]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "Advice Parameters", "heading_level": 3, "file_order": 16, "section_index": 9, "content_hash": "0b5a7acc89c71b239de39e2f39d785f63c60fdfbd00451b91e2d107e6598dcb1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:25e663451c6e051becd753eedd38615de0d76fe65b117e663043a4736628b5df", "content": "When multiple pieces of advice need to run at the same join point (executing method)\nthe ordering rules are as described in\nxref:core/aop/ataspectj/advice.adoc#aop-ataspectj-advice-ordering[Advice Ordering]. The\nprecedence between aspects is determined via the `order` attribute in the `<aop:aspect>`\nelement or by either adding the `@Order` annotation to the bean that backs the aspect\nor by having the bean implement the `Ordered` interface.\n\n[NOTE]\n====\nIn contrast to the precedence rules for advice methods defined in the same `@Aspect`\nclass, when two pieces of advice defined in the same `<aop:aspect>` element both need to\nrun at the same join point, the precedence is determined by the order in which the advice\nelements are declared within the enclosing `<aop:aspect>` element, from highest to lowest\nprecedence.\n\nFor example, given an `around` advice and a `before` advice defined in the same\n`<aop:aspect>` element that apply to the same join point, to ensure that the `around`\nadvice has higher precedence than the `before` advice, the `<aop:around>` element must be\ndeclared before the `<aop:before>` element.\n\nAs a general rule of thumb, if you find that you have multiple pieces of advice defined\nin the same `<aop:aspect>` element that apply to the same join point, consider collapsing\nsuch advice methods into one advice method per join point in each `<aop:aspect>` element\nor refactor the pieces of advice into separate `<aop:aspect>` elements that you can order\nat the aspect level.\n====\n\n[[aop-schema-introductions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "Advice Ordering", "heading_level": 3, "file_order": 16, "section_index": 10, "content_hash": "25e663451c6e051becd753eedd38615de0d76fe65b117e663043a4736628b5df", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:9206df062a16309dc50d0f5e26d65964245ce9ed8d89d1a9826c262d396be707", "content": "Introductions (known as inter-type declarations in AspectJ) let an aspect declare\nthat advised objects implement a given interface and provide an implementation of\nthat interface on behalf of those objects.\n\nYou can make an introduction by using the `aop:declare-parents` element inside an `aop:aspect`.\nYou can use the `aop:declare-parents` element to declare that matching types have a new parent (hence the name).\nFor example, given an interface named `UsageTracked` and an implementation of that interface named\n`DefaultUsageTracked`, the following aspect declares that all implementors of service\ninterfaces also implement the `UsageTracked` interface. (In order to expose statistics\nthrough JMX for example.)\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:aspect id=\"usageTrackerAspect\" ref=\"usageTracking\">\n\n <aop:declare-parents\n types-matching=\"com.xyz.service.*+\"\n implement-interface=\"com.xyz.service.tracking.UsageTracked\"\n default-impl=\"com.xyz.service.tracking.DefaultUsageTracked\"/>\n\n <aop:before\n pointcut=\"execution(* com.xyz..service.*.*(..))\n and this(usageTracked)\"\n method=\"recordUsage\"/>\n\n\t</aop:aspect>\n----\n\nThe class that backs the `usageTracking` bean would then contain the following method:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic void recordUsage(UsageTracked usageTracked) {\n usageTracked.incrementUseCount();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tfun recordUsage(usageTracked: UsageTracked) {\n usageTracked.incrementUseCount()\n\t}\n----\n======\n\nThe interface to be implemented is determined by the `implement-interface` attribute. The\nvalue of the `types-matching` attribute is an AspectJ type pattern. Any bean of a\nmatching type implements the `UsageTracked` interface. Note that, in the before\nadvice of the preceding example, service beans can be directly used as implementations of\nthe `UsageTracked` interface. To access a bean programmatically, you could write the\nfollowing:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tUsageTracked usageTracked = context.getBean(\"myService\", UsageTracked.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tval usageTracked = context.getBean(\"myService\", UsageTracked.class)\n----\n======\n\n[[aop-schema-instantiation-models]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "Introductions", "heading_level": 2, "file_order": 16, "section_index": 11, "content_hash": "9206df062a16309dc50d0f5e26d65964245ce9ed8d89d1a9826c262d396be707", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:629f80374946f0437a74c98311fd405c2f4c6eb21e917294594f65456d063cb3", "content": "The only supported instantiation model for schema-defined aspects is the singleton\nmodel. Other instantiation models may be supported in future releases.\n\n[[aop-schema-advisors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "Aspect Instantiation Models", "heading_level": 2, "file_order": 16, "section_index": 12, "content_hash": "629f80374946f0437a74c98311fd405c2f4c6eb21e917294594f65456d063cb3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:502b37509fe3154a1cbbf783b9c422664abe6ecc0c7135764f64d8d5a6325eee", "content": "The concept of \"advisors\" comes from the AOP support defined in Spring\nand does not have a direct equivalent in AspectJ. An advisor is like a small\nself-contained aspect that has a single piece of advice. The advice itself is\nrepresented by a bean and must implement one of the advice interfaces described in\nxref:core/aop-api/advice.adoc#aop-api-advice-types[Advice Types in Spring].\nAdvisors can take advantage of AspectJ pointcut expressions.\n\nSpring supports the advisor concept with the `<aop:advisor>` element. You most\ncommonly see it used in conjunction with transactional advice, which also has its own\nnamespace support in Spring. The following example shows an advisor:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:config>\n\n <aop:pointcut id=\"businessService\"\n expression=\"execution(* com.xyz.service.*.*(..))\"/>\n\n <aop:advisor\n pointcut-ref=\"businessService\"\n advice-ref=\"tx-advice\" />\n\n\t</aop:config>\n\n\t<tx:advice id=\"tx-advice\">\n <tx:attributes>\n <tx:method name=\"*\" propagation=\"REQUIRED\"/>\n </tx:attributes>\n\t</tx:advice>\n----\n\nAs well as the `pointcut-ref` attribute used in the preceding example, you can also use the\n`pointcut` attribute to define a pointcut expression inline.\n\nTo define the precedence of an advisor so that the advice can participate in ordering,\nuse the `order` attribute to define the `Ordered` value of the advisor.\n\n[[aop-schema-example]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "Advisors", "heading_level": 2, "file_order": 16, "section_index": 13, "content_hash": "502b37509fe3154a1cbbf783b9c422664abe6ecc0c7135764f64d8d5a6325eee", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:81ed6fe171028ec990f3c56da08ab62fc84fceb37885f3276baa4f715a77dfab", "content": "This section shows how the concurrent locking failure retry example from\nxref:core/aop/ataspectj/example.adoc[An AOP Example] looks when rewritten with the schema support.\n\nThe execution of business services can sometimes fail due to concurrency issues (for\nexample, a deadlock loser). If the operation is retried, it is likely to succeed\non the next try. For business services where it is appropriate to retry in such\nconditions (idempotent operations that do not need to go back to the user for conflict\nresolution), we want to transparently retry the operation to avoid the client seeing a\n`PessimisticLockingFailureException`. This is a requirement that clearly cuts across\nmultiple services in the service layer and, hence, is ideal for implementing through an\naspect.\n\nBecause we want to retry the operation, we need to use around advice so that we can\ncall `proceed` multiple times. The following listing shows the basic aspect implementation\n(which is a regular Java class that uses the schema support):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic class ConcurrentOperationExecutor implements Ordered {\n\n private static final int DEFAULT_MAX_RETRIES = 2;\n\n private int maxRetries = DEFAULT_MAX_RETRIES;\n private int order = 1;\n\n public void setMaxRetries(int maxRetries) {\n this.maxRetries = maxRetries;\n }\n\n public int getOrder() {\n return this.order;\n }\n\n public void setOrder(int order) {\n this.order = order;\n }\n\n public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {\n int numAttempts = 0;\n PessimisticLockingFailureException lockFailureException;\n do {\n numAttempts++;\n try {\n return pjp.proceed();\n }\n catch(PessimisticLockingFailureException ex) {\n lockFailureException = ex;\n }\n } while(numAttempts <= this.maxRetries);\n throw lockFailureException;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tclass ConcurrentOperationExecutor : Ordered {\n\n private val DEFAULT_MAX_RETRIES = 2\n\n private var maxRetries = DEFAULT_MAX_RETRIES\n private var order = 1\n\n fun setMaxRetries(maxRetries: Int) {\n this.maxRetries = maxRetries\n }\n\n override fun getOrder(): Int {\n return this.order\n }\n\n fun setOrder(order: Int) {\n this.order = order\n }\n\n fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any? {\n var numAttempts = 0\n var lockFailureException: PessimisticLockingFailureException\n do {\n numAttempts++\n try {\n return pjp.proceed()\n } catch (ex: PessimisticLockingFailureException) {\n lockFailureException = ex\n }\n\n } while (numAttempts <= this.maxRetries)\n throw lockFailureException\n }\n\t}\n----\n======\n\nNote that the aspect implements the `Ordered` interface so that we can set the precedence of\nthe aspect higher than the transaction advice (we want a fresh transaction each time we\nretry). The `maxRetries` and `order` properties are both configured by Spring. The\nmain action happens in the `doConcurrentOperation` around advice method. We try to\nproceed. If we fail with a `PessimisticLockingFailureException`, we try again,\nunless we have exhausted all of our retry attempts.\n\nNOTE: This class is identical to the one used in the @AspectJ example, but with the\nannotations removed.\n\nThe corresponding Spring configuration is as follows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:config>\n\n <aop:aspect id=\"concurrentOperationRetry\" ref=\"concurrentOperationExecutor\">\n\n <aop:pointcut id=\"idempotentOperation\"\n expression=\"execution(* com.xyz.service.*.*(..))\"/>\n\n <aop:around\n pointcut-ref=\"idempotentOperation\"\n method=\"doConcurrentOperation\"/>\n\n </aop:aspect>\n\n\t</aop:config>\n\n\t<bean id=\"concurrentOperationExecutor\"\n class=\"com.xyz.service.impl.ConcurrentOperationExecutor\">\n <property name=\"maxRetries\" value=\"3\"/>\n <property name=\"order\" value=\"100\"/>\n\t</bean>\n----\n\nNotice that, for the time being, we assume that all business services are idempotent. If\nthis is not the case, we can refine the aspect so that it retries only genuinely\nidempotent operations, by introducing an `Idempotent` annotation and using the annotation\nto annotate the implementation of service operations, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Retention(RetentionPolicy.RUNTIME)\n\t// marker annotation\n\tpublic @interface Idempotent {\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Retention(AnnotationRetention.RUNTIME)\n\t// marker annotation\n\tannotation class Idempotent\n----\n======\n\nThe\nchange to the aspect to retry only idempotent operations involves refining the\npointcut expression so that only `@Idempotent` operations match, as follows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:pointcut id=\"idempotentOperation\"\n expression=\"execution(* com.xyz.service.*.*(..)) and\n @annotation(com.xyz.service.Idempotent)\"/>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/schema.adoc", "title": "schema", "heading": "An AOP Schema Example", "heading_level": 2, "file_order": 16, "section_index": 14, "content_hash": "81ed6fe171028ec990f3c56da08ab62fc84fceb37885f3276baa4f715a77dfab", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/schema.adoc"}}
{"id": "sha256:2bc86b9983d3f226041d1b21b7ac3f8a84b0eb1c4aa7e901e396296693e8a24c", "content": "[[aop-using-aspectj]]\n\nEverything we have covered so far in this chapter is pure Spring AOP. In this section,\nwe look at how you can use the AspectJ compiler or weaver instead of or in\naddition to Spring AOP if your needs go beyond the facilities offered by Spring AOP\nalone.\n\nSpring ships with a small AspectJ aspect library, which is available stand-alone in your\ndistribution as `spring-aspects.jar`. You need to add this to your classpath in order\nto use the aspects in it.\nxref:core/aop/using-aspectj.adoc#aop-atconfigurable[Using AspectJ to Dependency Inject Domain Objects with Spring]\nand xref:core/aop/using-aspectj.adoc#aop-ajlib-other[Other Spring aspects for AspectJ]\ndiscuss the content of this library and how you can use it.\nxref:core/aop/using-aspectj.adoc#aop-aj-configure[Configuring AspectJ Aspects by Using Spring IoC]\ndiscusses how to dependency inject AspectJ aspects that are woven using the AspectJ compiler. Finally,\nxref:core/aop/using-aspectj.adoc#aop-aj-ltw[Load-time Weaving with AspectJ in the Spring Framework]\nprovides an introduction to load-time weaving for Spring applications that use AspectJ.\n\n[[aop-atconfigurable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "using-aspectj", "heading_level": 1, "file_order": 17, "section_index": 0, "content_hash": "2bc86b9983d3f226041d1b21b7ac3f8a84b0eb1c4aa7e901e396296693e8a24c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:6482514066a4a765576562d674f6cdfab2cab193e3f7eb8a28f88023b547c1c6", "content": "The Spring container instantiates and configures beans defined in your application\ncontext. It is also possible to ask a bean factory to configure a pre-existing\nobject, given the name of a bean definition that contains the configuration to be applied.\n`spring-aspects.jar` contains an annotation-driven aspect that exploits this\ncapability to allow dependency injection of any object. The support is intended to\nbe used for objects created outside of the control of any container. Domain objects\noften fall into this category because they are often created programmatically with the\n`new` operator or by an ORM tool as a result of a database query.\n\nThe `@Configurable` annotation marks a class as being eligible for Spring-driven\nconfiguration. In the simplest case, you can use purely it as a marker annotation, as the\nfollowing example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz.domain;\n\n\timport org.springframework.beans.factory.annotation.Configurable;\n\n\t@Configurable\n\tpublic class Account {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz.domain\n\n\timport org.springframework.beans.factory.annotation.Configurable\n\n\t@Configurable\n\tclass Account {\n // ...\n\t}\n----\n======\n\nWhen used as a marker interface in this way, Spring configures new instances of the\nannotated type (`Account`, in this case) by using a bean definition (typically\nprototype-scoped) with the same name as the fully-qualified type name\n(`com.xyz.domain.Account`). Since the default name for a bean defined via XML is the\nfully-qualified name of its type, a convenient way to declare the prototype definition\nis to omit the `id` attribute, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<bean class=\"com.xyz.domain.Account\" scope=\"prototype\">\n <property name=\"fundsTransferService\" ref=\"fundsTransferService\"/>\n\t</bean>\n----\n\nIf you want to explicitly specify the name of the prototype bean definition to use, you\ncan do so directly in the annotation, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz.domain;\n\n\timport org.springframework.beans.factory.annotation.Configurable;\n\n\t@Configurable(\"account\")\n\tpublic class Account {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz.domain\n\n\timport org.springframework.beans.factory.annotation.Configurable\n\n\t@Configurable(\"account\")\n\tclass Account {\n // ...\n\t}\n----\n======\n\nSpring now looks for a bean definition named `account` and uses that as the\ndefinition to configure new `Account` instances.\n\nYou can also use autowiring to avoid having to specify a dedicated bean definition at\nall. To have Spring apply autowiring, use the `autowire` property of the `@Configurable`\nannotation. You can specify either `@Configurable(autowire=Autowire.BY_TYPE)` or\n`@Configurable(autowire=Autowire.BY_NAME)` for autowiring by type or by name,\nrespectively. As an alternative, it is preferable to specify explicit, annotation-driven\ndependency injection for your `@Configurable` beans through `@Autowired` or `@Inject`\nat the field or method level (see xref:core/beans/annotation-config.adoc[Annotation-based Container Configuration] for further details).\n\nFinally, you can enable Spring dependency checking for the object references in the newly\ncreated and configured object by using the `dependencyCheck` attribute (for example,\n`@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)`). If this attribute is\nset to `true`, Spring validates after configuration that all properties (which\nare not primitives or collections) have been set.\n\nNote that using the annotation on its own does nothing. It is the\n`AnnotationBeanConfigurerAspect` in `spring-aspects.jar` that acts on the presence of\nthe annotation. In essence, the aspect says, \"after returning from the initialization of\na new object of a type annotated with `@Configurable`, configure the newly created object\nusing Spring in accordance with the properties of the annotation\". In this context,\n\"initialization\" refers to newly instantiated objects (for example, objects instantiated\nwith the `new` operator) as well as to `Serializable` objects that are undergoing\ndeserialization (for example, through\n{java-api}/java.base/java/io/Serializable.html[readResolve()]).\n\n[NOTE]\n=====\nOne of the key phrases in the above paragraph is \"in essence\". For most cases, the\nexact semantics of \"after returning from the initialization of a new object\" are\nfine. In this context, \"after initialization\" means that the dependencies are\ninjected after the object has been constructed. This means that the dependencies\nare not available for use in the constructor bodies of the class. If you want the\ndependencies to be injected before the constructor bodies run and thus be\navailable for use in the body of the constructors, you need to define this on the\n`@Configurable` declaration, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Configurable(preConstruction = true)\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Configurable(preConstruction = true)\n----\n======\n\nYou can find more information about the language semantics of the various pointcut\ntypes in AspectJ\n{aspectj-docs-progguide}/semantics-joinPoints.html[in this appendix] of the\n{aspectj-docs-progguide}/index.html[AspectJ Programming Guide].\n=====\n\nFor this to work, the annotated types must be woven with the AspectJ weaver. You can\neither use a build-time Ant or Maven task to do this (see, for example, the\n{aspectj-docs-devguide}/antTasks.html[AspectJ Development\nEnvironment Guide]) or load-time weaving (see xref:core/aop/using-aspectj.adoc#aop-aj-ltw[Load-time Weaving with AspectJ in the Spring Framework]). The\n`AnnotationBeanConfigurerAspect` itself needs to be configured by Spring (in order to obtain\na reference to the bean factory that is to be used to configure new objects). You can define\nthe related configuration as follows:\n\ninclude-code::./ApplicationConfiguration[tag=snippet,indent=0]\n\nInstances of `@Configurable` objects created before the aspect has been configured\nresult in a message being issued to the debug log and no configuration of the\nobject taking place. An example might be a bean in the Spring configuration that creates\ndomain objects when it is initialized by Spring. In this case, you can use the\n`depends-on` bean attribute to manually specify that the bean depends on the\nconfiguration aspect. The following example shows how to use the `depends-on` attribute:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<bean id=\"myService\"\n class=\"com.xyz.service.MyService\"\n depends-on=\"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect\">\n\n <!-- ... -->\n\n\t</bean>\n----\n\nNOTE: Do not activate `@Configurable` processing through the bean configurer aspect unless you\nreally mean to rely on its semantics at runtime. In particular, make sure that you do\nnot use `@Configurable` on bean classes that are registered as regular Spring beans\nwith the container. Doing so results in double initialization, once through the\ncontainer and once through the aspect.\n\n[[aop-configurable-testing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "Using AspectJ to Dependency Inject Domain Objects with Spring", "heading_level": 2, "file_order": 17, "section_index": 1, "content_hash": "6482514066a4a765576562d674f6cdfab2cab193e3f7eb8a28f88023b547c1c6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:fb7e735018337671b40067bbe635bc177c58f70c56c313f7f20524ab8a6a5caf", "content": "One of the goals of the `@Configurable` support is to enable independent unit testing\nof domain objects without the difficulties associated with hard-coded lookups.\nIf `@Configurable` types have not been woven by AspectJ, the annotation has no affect\nduring unit testing. You can set mock or stub property references in the object under\ntest and proceed as normal. If `@Configurable` types have been woven by AspectJ,\nyou can still unit test outside of the container as normal, but you see a warning\nmessage each time that you construct a `@Configurable` object indicating that it has\nnot been configured by Spring.\n\n[[aop-configurable-container]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "Unit Testing `@Configurable` Objects", "heading_level": 3, "file_order": 17, "section_index": 2, "content_hash": "fb7e735018337671b40067bbe635bc177c58f70c56c313f7f20524ab8a6a5caf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:f3e55277f282dc041ee4e3468b90af5abdbe7b24c8a43e5ab2a902f32c305a5b", "content": "The `AnnotationBeanConfigurerAspect` that is used to implement the `@Configurable` support\nis an AspectJ singleton aspect. The scope of a singleton aspect is the same as the scope\nof `static` members: There is one aspect instance per `ClassLoader` that defines the type.\nThis means that, if you define multiple application contexts within the same `ClassLoader`\nhierarchy, you need to consider where to define the `@EnableSpringConfigured` bean and\nwhere to place `spring-aspects.jar` on the classpath.\n\nConsider a typical Spring web application configuration that has a shared parent application\ncontext that defines common business services, everything needed to support those services,\nand one child application context for each servlet (which contains definitions particular\nto that servlet). All of these contexts co-exist within the same `ClassLoader` hierarchy,\nand so the `AnnotationBeanConfigurerAspect` can hold a reference to only one of them.\nIn this case, we recommend defining the `@EnableSpringConfigured` bean in the shared\n(parent) application context. This defines the services that you are likely to want to\ninject into domain objects. A consequence is that you cannot configure domain objects\nwith references to beans defined in the child (servlet-specific) contexts by using the\n@Configurable mechanism (which is probably not something you want to do anyway).\n\nWhen deploying multiple web applications within the same container, ensure that each\nweb application loads the types in `spring-aspects.jar` by using its own `ClassLoader`\n(for example, by placing `spring-aspects.jar` in `WEB-INF/lib`). If `spring-aspects.jar`\nis added only to the container-wide classpath (and hence loaded by the shared parent\n`ClassLoader`), all web applications share the same aspect instance (which is probably\nnot what you want).\n\n[[aop-ajlib-other]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "Working with Multiple Application Contexts", "heading_level": 3, "file_order": 17, "section_index": 3, "content_hash": "f3e55277f282dc041ee4e3468b90af5abdbe7b24c8a43e5ab2a902f32c305a5b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:72781c8ad02d6fa7b99350afaf322cb369b3e70715d7e5a9444a495514110b2d", "content": "In addition to the `@Configurable` aspect, `spring-aspects.jar` contains an AspectJ\naspect that you can use to drive Spring's transaction management for types and methods\nannotated with the `@Transactional` annotation. This is primarily intended for users who\nwant to use the Spring Framework's transaction support outside of the Spring container.\n\nThe aspect that interprets `@Transactional` annotations is the\n`AnnotationTransactionAspect`. When you use this aspect, you must annotate the\nimplementation class (or methods within that class or both), not the interface (if\nany) that the class implements. AspectJ follows Java's rule that annotations on\ninterfaces are not inherited.\n\nA `@Transactional` annotation on a class specifies the default transaction semantics for\nthe execution of any public operation in the class.\n\nA `@Transactional` annotation on a method within the class overrides the default\ntransaction semantics given by the class annotation (if present). Methods of any\nvisibility may be annotated, including private methods. Annotating non-public methods\ndirectly is the only way to get transaction demarcation for the execution of such methods.\n\nTIP: Since Spring Framework 4.2, `spring-aspects` provides a similar aspect that offers the\nexact same features for the standard `jakarta.transaction.Transactional` annotation. Check\n`JtaAnnotationTransactionAspect` for more details.\n\nFor AspectJ programmers who want to use the Spring configuration and transaction\nmanagement support but do not want to (or cannot) use annotations, `spring-aspects.jar`\nalso contains `abstract` aspects you can extend to provide your own pointcut\ndefinitions. See the sources for the `AbstractBeanConfigurerAspect` and\n`AbstractTransactionAspect` aspects for more information. As an example, the following\nexcerpt shows how you could write an aspect to configure all instances of objects\ndefined in the domain model by using prototype bean definitions that match the\nfully qualified class names:\n\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tpublic aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect {\n\n public DomainObjectConfiguration() {\n setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver());\n }\n\n // the creation of a new bean (any object in the domain model)\n protected pointcut beanCreation(Object beanInstance) :\n initialization(new(..)) &&\n CommonPointcuts.inDomainModel() &&\n this(beanInstance);\n\t}\n----\n\n[[aop-aj-configure]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "Other Spring aspects for AspectJ", "heading_level": 2, "file_order": 17, "section_index": 4, "content_hash": "72781c8ad02d6fa7b99350afaf322cb369b3e70715d7e5a9444a495514110b2d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:6cf85d7f24e231e10ecfdf298b29a7408a2f2f8918bbc7d3effb8cee5b1cf4b3", "content": "When you use AspectJ aspects with Spring applications, it is natural to both want and\nexpect to be able to configure such aspects with Spring. The AspectJ runtime itself is\nresponsible for aspect creation, and the means of configuring the AspectJ-created\naspects through Spring depends on the AspectJ instantiation model (the `per-xxx` clause)\nused by the aspect.\n\nThe majority of AspectJ aspects are singleton aspects. Configuration of these\naspects is easy. You can create a bean definition that references the aspect type as\nnormal and include the `factory-method=\"aspectOf\"` bean attribute. This ensures that\nSpring obtains the aspect instance by asking AspectJ for it rather than trying to create\nan instance itself. The following example shows how to use the `factory-method=\"aspectOf\"` attribute:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<bean id=\"profiler\" class=\"com.xyz.profiler.Profiler\"\n factory-method=\"aspectOf\"> <1>\n\n <property name=\"profilingStrategy\" ref=\"jamonProfilingStrategy\"/>\n\t</bean>\n----\n<1> Note the `factory-method=\"aspectOf\"` attribute\n\nNon-singleton aspects are harder to configure. However, it is possible to do so by\ncreating prototype bean definitions and using the `@Configurable` support from\n`spring-aspects.jar` to configure the aspect instances once they have bean created by\nthe AspectJ runtime.\n\nIf you have some @AspectJ aspects that you want to weave with AspectJ (for example,\nusing load-time weaving for domain model types) and other @AspectJ aspects that you want\nto use with Spring AOP, and these aspects are all configured in Spring, you\nneed to tell the Spring AOP @AspectJ auto-proxying support which exact subset of the\n@AspectJ aspects defined in the configuration should be used for auto-proxying. You can\ndo this by using one or more `<include/>` elements inside the `<aop:aspectj-autoproxy/>`\ndeclaration. Each `<include/>` element specifies a name pattern, and only beans with\nnames matched by at least one of the patterns are used for Spring AOP auto-proxy\nconfiguration. The following example shows how to use `<include/>` elements:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:aspectj-autoproxy>\n <aop:include name=\"thisBean\"/>\n <aop:include name=\"thatBean\"/>\n\t</aop:aspectj-autoproxy>\n----\n\nNOTE: Do not be misled by the name of the `<aop:aspectj-autoproxy/>` element. Using it\nresults in the creation of Spring AOP proxies. The @AspectJ style of aspect\ndeclaration is being used here, but the AspectJ runtime is not involved.\n\n[[aop-aj-ltw]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "Configuring AspectJ Aspects by Using Spring IoC", "heading_level": 2, "file_order": 17, "section_index": 5, "content_hash": "6cf85d7f24e231e10ecfdf298b29a7408a2f2f8918bbc7d3effb8cee5b1cf4b3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:e677668bf8f634ee3d0638969dafd3f8239805f35f4c8f06d8218e09999ffbff", "content": "Load-time weaving (LTW) refers to the process of weaving AspectJ aspects into an\napplication's class files as they are being loaded into the Java virtual machine (JVM).\nThe focus of this section is on configuring and using LTW in the specific context of the\nSpring Framework. This section is not a general introduction to LTW. For full details on\nthe specifics of LTW and configuring LTW with only AspectJ (with Spring not being\ninvolved at all), see the\n{aspectj-docs-devguide}/ltw.html[LTW section of the AspectJ\nDevelopment Environment Guide].\n\nThe value that the Spring Framework brings to AspectJ LTW is in enabling much\nfiner-grained control over the weaving process. 'Vanilla' AspectJ LTW is effected by using\na Java (5+) agent, which is switched on by specifying a VM argument when starting up a\nJVM. It is, thus, a JVM-wide setting, which may be fine in some situations but is often a\nlittle too coarse. Spring-enabled LTW lets you switch on LTW on a\nper-`ClassLoader` basis, which is more fine-grained and which can make more\nsense in a 'single-JVM-multiple-application' environment (such as is found in a typical\napplication server environment).\n\nFurther, xref:core/aop/using-aspectj.adoc#aop-aj-ltw-environments[in certain environments], this support enables\nload-time weaving without making any modifications to the application server's launch\nscript that is needed to add `-javaagent:path/to/aspectjweaver.jar` or (as we describe\nlater in this section) `-javaagent:path/to/spring-instrument.jar`. Developers configure\nthe application context to enable load-time weaving instead of relying on administrators\nwho typically are in charge of the deployment configuration, such as the launch script.\n\nNow that the sales pitch is over, let us first walk through a quick example of AspectJ\nLTW that uses Spring, followed by detailed specifics about elements introduced in the\nexample. For a complete example, see the\n{petclinic-github-org}/spring-framework-petclinic[Petclinic sample application based on Spring Framework].\n\n[[aop-aj-ltw-first-example]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "Load-time Weaving with AspectJ in the Spring Framework", "heading_level": 2, "file_order": 17, "section_index": 6, "content_hash": "e677668bf8f634ee3d0638969dafd3f8239805f35f4c8f06d8218e09999ffbff", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:4d88948f5586c2bafba8447d29b26e746365147b4b1581d01f3ced64d3a7075f", "content": "Assume that you are an application developer who has been tasked with diagnosing\nthe cause of some performance problems in a system. Rather than break out a\nprofiling tool, we are going to switch on a simple profiling aspect that lets us\nquickly get some performance metrics. We can then apply a finer-grained profiling\ntool to that specific area immediately afterwards.\n\nNOTE: The example presented here uses XML configuration. You can also configure and\nuse @AspectJ with xref:core/beans/java.adoc[Java configuration]. Specifically, you can use the\n`@EnableLoadTimeWeaving` annotation as an alternative to `<context:load-time-weaver/>`\n(see xref:core/aop/using-aspectj.adoc#aop-aj-ltw-spring[below] for details).\n\nThe following example shows the profiling aspect, which is not fancy.\nIt is a time-based profiler that uses the @AspectJ-style of aspect declaration:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz;\n\n\timport org.aspectj.lang.ProceedingJoinPoint;\n\timport org.aspectj.lang.annotation.Aspect;\n\timport org.aspectj.lang.annotation.Around;\n\timport org.aspectj.lang.annotation.Pointcut;\n\timport org.springframework.util.StopWatch;\n\timport org.springframework.core.annotation.Order;\n\n\t@Aspect\n\tpublic class ProfilingAspect {\n\n @Around(\"methodsToBeProfiled()\")\n public Object profile(ProceedingJoinPoint pjp) throws Throwable {\n StopWatch sw = new StopWatch(getClass().getSimpleName());\n try {\n sw.start(pjp.getSignature().getName());\n return pjp.proceed();\n } finally {\n sw.stop();\n System.out.println(sw.prettyPrint());\n }\n }\n\n @Pointcut(\"execution(public * com.xyz..*.*(..))\")\n public void methodsToBeProfiled(){}\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz\n\n\timport org.aspectj.lang.ProceedingJoinPoint\n\timport org.aspectj.lang.annotation.Aspect\n\timport org.aspectj.lang.annotation.Around\n\timport org.aspectj.lang.annotation.Pointcut\n\timport org.springframework.util.StopWatch\n\timport org.springframework.core.annotation.Order\n\n\t@Aspect\n\tclass ProfilingAspect {\n\n @Around(\"methodsToBeProfiled()\")\n fun profile(pjp: ProceedingJoinPoint): Any? {\n val sw = StopWatch(javaClass.simpleName)\n try {\n sw.start(pjp.getSignature().getName())\n return pjp.proceed()\n } finally {\n sw.stop()\n println(sw.prettyPrint())\n }\n }\n\n @Pointcut(\"execution(public * com.xyz..*.*(..))\")\n fun methodsToBeProfiled() {\n }\n\t}\n----\n======\n\nWe also need to create an `META-INF/aop.xml` file, to inform the AspectJ weaver that\nwe want to weave our `ProfilingAspect` into our classes. This file convention, namely\nthe presence of a file (or files) on the Java classpath called `META-INF/aop.xml` is\nstandard AspectJ. The following example shows the `aop.xml` file:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<!DOCTYPE aspectj PUBLIC \"-//AspectJ//DTD//EN\" \"https://www.eclipse.org/aspectj/dtd/aspectj.dtd\">\n\t<aspectj>\n\n <weaver>\n <!-- only weave classes in our application-specific packages and sub-packages -->\n <include within=\"com.xyz..*\"/>\n </weaver>\n\n <aspects>\n <!-- weave in just this aspect -->\n <aspect name=\"com.xyz.ProfilingAspect\"/>\n </aspects>\n\n\t</aspectj>\n----\n\nNOTE: It is recommended to only weave specific classes (typically those in the\napplication packages, as shown in the `aop.xml` example above) in order\nto avoid side effects such as AspectJ dump files and warnings.\nThis is also a best practice from an efficiency perspective.\n\nNow we can move on to the Spring-specific portion of the configuration. We need\nto configure a `LoadTimeWeaver` (explained later). This load-time weaver is the\nessential component responsible for weaving the aspect configuration in one or\nmore `META-INF/aop.xml` files into the classes in your application. The good\nthing is that it does not require a lot of configuration (there are some more\noptions that you can specify, but these are detailed later), as can be seen in\nthe following example:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:context=\"http://www.springframework.org/schema/context\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/context\n https://www.springframework.org/schema/context/spring-context.xsd\">\n\n <!-- a service object; we will be profiling its methods -->\n <bean id=\"entitlementCalculationService\"\n class=\"com.xyz.StubEntitlementCalculationService\"/>\n\n <!-- this switches on the load-time weaving -->\n <context:load-time-weaver/>\n\t</beans>\n----\n\nNow that all the required artifacts (the aspect, the `META-INF/aop.xml`\nfile, and the Spring configuration) are in place, we can create the following\ndriver class with a `main(..)` method to demonstrate the LTW in action:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz;\n\n\t// imports\n\n\tpublic class Main {\n\n public static void main(String[] args) {\n ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");\n\n EntitlementCalculationService service =\n ctx.getBean(EntitlementCalculationService.class);\n\n // the profiling aspect is 'woven' around this method execution\n service.calculateEntitlement();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz\n\n\t// imports\n\n\tfun main() {\n val ctx = ClassPathXmlApplicationContext(\"beans.xml\")\n\n val service = ctx.getBean(EntitlementCalculationService.class)\n\n // the profiling aspect is 'woven' around this method execution\n service.calculateEntitlement()\n\t}\n----\n======\n\nWe have one last thing to do. The introduction to this section did say that one could\nswitch on LTW selectively on a per-`ClassLoader` basis with Spring, and this is true.\nHowever, for this example, we use a Java agent (supplied with Spring) to switch on LTW.\nWe use the following command to run the `Main` class shown earlier:\n\n[literal,subs=\"verbatim\"]\n----\njava -javaagent:C:/projects/xyz/lib/spring-instrument.jar com.xyz.Main\n----\n\nThe `-javaagent` is a flag for specifying and enabling\n{java-api}/java.instrument/java/lang/instrument/package-summary.html[agents\nto instrument programs that run on the JVM]. The Spring Framework ships with such an\nagent, the `InstrumentationSavingAgent`, which is packaged in the\n`spring-instrument.jar` that was supplied as the value of the `-javaagent` argument in\nthe preceding example.\n\nThe output from the execution of the `Main` program looks something like the next example.\n(I have introduced a `Thread.sleep(..)` statement into the `calculateEntitlement()`\nimplementation so that the profiler actually captures something other than 0\nmilliseconds (the `01234` milliseconds is not an overhead introduced by the AOP).\nThe following listing shows the output we got when we ran our profiler:\n\n[literal,subs=\"verbatim\"]\n----\nCalculating entitlement\n\nStopWatch 'ProfilingAspect': running time (millis) = 1234\n------ ----- ----------------------------\nms % Task name\n------ ----- ----------------------------\n01234 100% calculateEntitlement\n----\n\nSince this LTW is effected by using full-blown AspectJ, we are not limited only to advising\nSpring beans. The following slight variation on the `Main` program yields the same\nresult:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz;\n\n\t// imports\n\n\tpublic class Main {\n\n public static void main(String[] args) {\n new ClassPathXmlApplicationContext(\"beans.xml\");\n\n EntitlementCalculationService service =\n new StubEntitlementCalculationService();\n\n // the profiling aspect will be 'woven' around this method execution\n service.calculateEntitlement();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage com.xyz\n\n\t// imports\n\n\tfun main(args: Array<String>) {\n ClassPathXmlApplicationContext(\"beans.xml\")\n\n val service = StubEntitlementCalculationService()\n\n // the profiling aspect will be 'woven' around this method execution\n service.calculateEntitlement()\n\t}\n----\n======\n\nNotice how, in the preceding program, we bootstrap the Spring container and\nthen create a new instance of the `StubEntitlementCalculationService` totally outside\nthe context of Spring. The profiling advice still gets woven in.\n\nAdmittedly, the example is simplistic. However, the basics of the LTW support in Spring\nhave all been introduced in the earlier example, and the rest of this section explains\nthe \"why\" behind each bit of configuration and usage in detail.\n\nNOTE: The `ProfilingAspect` used in this example may be basic, but it is quite useful. It is a\nnice example of a development-time aspect that developers can use during development\nand then easily exclude from builds of the application being deployed\ninto UAT or production.\n\n[[aop-aj-ltw-the-aspects]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "A First Example", "heading_level": 3, "file_order": 17, "section_index": 7, "content_hash": "4d88948f5586c2bafba8447d29b26e746365147b4b1581d01f3ced64d3a7075f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:1139fc0fedc1a669c91c546182943a4183f4d4b5aebb94122f638dc0fd2120aa", "content": "The aspects that you use in LTW have to be AspectJ aspects. You can write them in\neither the AspectJ language itself, or you can write your aspects in the @AspectJ-style.\nYour aspects are then both valid AspectJ and Spring AOP aspects.\nFurthermore, the compiled aspect classes need to be available on the classpath.\n\n[[aop-aj-ltw-aop_dot_xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "Aspects", "heading_level": 3, "file_order": 17, "section_index": 8, "content_hash": "1139fc0fedc1a669c91c546182943a4183f4d4b5aebb94122f638dc0fd2120aa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:8cb1dbd82f9b6a39031b3fc383656791054ca7efac51946b16ab7eb7ef90b20a", "content": "The AspectJ LTW infrastructure is configured by using one or more `META-INF/aop.xml`\nfiles that are on the Java classpath (either directly or, more typically, in jar files).\nFor example:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<!DOCTYPE aspectj PUBLIC \"-//AspectJ//DTD//EN\" \"https://www.eclipse.org/aspectj/dtd/aspectj.dtd\">\n\t<aspectj>\n\n <weaver>\n <!-- only weave classes in our application-specific packages and sub-packages -->\n <include within=\"com.xyz..*\"/>\n </weaver>\n\n\t</aspectj>\n----\n\nNOTE: It is recommended to only weave specific classes (typically those in the\napplication packages, as shown in the `aop.xml` example above) in order\nto avoid side effects such as AspectJ dump files and warnings.\nThis is also a best practice from an efficiency perspective.\n\nThe structure and contents of this file is detailed in the LTW part of the\n{aspectj-docs-devguide}/ltw-configuration.html[AspectJ reference\ndocumentation]. Because the `aop.xml` file is 100% AspectJ, we do not describe it further here.\n\n[[aop-aj-ltw-libraries]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "`META-INF/aop.xml`", "heading_level": 3, "file_order": 17, "section_index": 9, "content_hash": "8cb1dbd82f9b6a39031b3fc383656791054ca7efac51946b16ab7eb7ef90b20a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:2c7047eaa9d3c34a9c4d91be00ff8f4b631b179e045386b9622d2445bf1c96a2", "content": "At minimum, you need the following libraries to use the Spring Framework's support\nfor AspectJ LTW:\n\n* `spring-aop.jar`\n* `aspectjweaver.jar`\n\nIf you use the xref:core/aop/using-aspectj.adoc#aop-aj-ltw-environments-generic[Spring-provided agent to enable instrumentation]\n, you also need:\n\n* `spring-instrument.jar`\n\n[[aop-aj-ltw-spring]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "Required libraries (JARS)", "heading_level": 3, "file_order": 17, "section_index": 10, "content_hash": "2c7047eaa9d3c34a9c4d91be00ff8f4b631b179e045386b9622d2445bf1c96a2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:881141746631bf8b1a016da39325d7502666d819d4a4ef6b91e1ff96f0d4d5aa", "content": "The key component in Spring's LTW support is the `LoadTimeWeaver` interface (in the\n`org.springframework.instrument.classloading` package), and the numerous implementations\nof it that ship with the Spring distribution. A `LoadTimeWeaver` is responsible for\nadding one or more `java.lang.instrument.ClassFileTransformers` to a `ClassLoader` at\nruntime, which opens the door to all manner of interesting applications, one of which\nhappens to be the LTW of aspects.\n\nTIP: If you are unfamiliar with the idea of runtime class file transformation, see the\njavadoc API documentation for the `java.lang.instrument` package before continuing.\nWhile that documentation is not comprehensive, at least you can see the key interfaces\nand classes (for reference as you read through this section).\n\nConfiguring a `LoadTimeWeaver` for a particular `ApplicationContext` can be as easy as\nadding one line. (Note that you almost certainly need to use an\n`ApplicationContext` as your Spring container -- typically, a `BeanFactory` is not\nenough because the LTW support uses `BeanFactoryPostProcessors`.)\n\nTo enable the Spring Framework's LTW support, you need to configure a `LoadTimeWeaver` as follows:\n\ninclude-code::./ApplicationConfiguration[tag=snippet,indent=0]\n\nThe preceding configuration automatically defines and registers a number of LTW-specific\ninfrastructure beans, such as a `LoadTimeWeaver` and an `AspectJWeavingEnabler`, for you.\nThe default `LoadTimeWeaver` is the `DefaultContextLoadTimeWeaver` class, which attempts\nto decorate an automatically detected `LoadTimeWeaver`. The exact type of `LoadTimeWeaver`\nthat is \"automatically detected\" is dependent upon your runtime environment.\nThe following table summarizes various `LoadTimeWeaver` implementations:\n\n[[aop-aj-ltw-spring-env-impls]]\n.DefaultContextLoadTimeWeaver LoadTimeWeavers\n|===\n| Runtime Environment| `LoadTimeWeaver` implementation\n\n| Running in https://tomcat.apache.org/[Apache Tomcat]\n| `TomcatLoadTimeWeaver`\n\n| Running in https://eclipse-ee4j.github.io/glassfish/[GlassFish] (limited to EAR deployments)\n| `GlassFishLoadTimeWeaver`\n\n| Running in Red Hat's https://www.jboss.org/jbossas/[JBoss AS] or https://www.wildfly.org/[WildFly]\n| `JBossLoadTimeWeaver`\n\n| JVM started with Spring `InstrumentationSavingAgent`\n (`java -javaagent:path/to/spring-instrument.jar`)\n| `InstrumentationLoadTimeWeaver`\n\n| Fallback, expecting the underlying ClassLoader to follow common conventions\n (namely `addTransformer` and optionally a `getThrowawayClassLoader` method)\n| `ReflectiveLoadTimeWeaver`\n|===\n\nNote that the table lists only the `LoadTimeWeavers` that are autodetected when you\nuse the `DefaultContextLoadTimeWeaver`. You can specify exactly which `LoadTimeWeaver`\nimplementation to use.\n\nTo configure a specific `LoadTimeWeaver`, implement the\n`LoadTimeWeavingConfigurer` interface and override the `getLoadTimeWeaver()` method\n(or use the XML equivalent).\nThe following example specifies a `ReflectiveLoadTimeWeaver`:\n\ninclude-code::./CustomWeaverConfiguration[tag=snippet,indent=0]\n\nThe `LoadTimeWeaver` that is defined and registered by the configuration can be later\nretrieved from the Spring container by using the well known name, `loadTimeWeaver`.\nRemember that the `LoadTimeWeaver` exists only as a mechanism for Spring's LTW\ninfrastructure to add one or more `ClassFileTransformers`. The actual\n`ClassFileTransformer` that does the LTW is the `ClassPreProcessorAgentAdapter` (from\nthe `org.aspectj.weaver.loadtime` package) class. See the class-level javadoc of the\n`ClassPreProcessorAgentAdapter` class for further details, because the specifics of how\nthe weaving is actually effected is beyond the scope of this document.\n\nThere is one final attribute of the configuration left to discuss: the `aspectjWeaving`\nattribute (or `aspectj-weaving` if you use XML). This attribute controls whether LTW\nis enabled or not. It accepts one of three possible values, with the default value being\n`autodetect` if the attribute is not present. The following table summarizes the three\npossible values:\n\n[[aop-aj-ltw-ltw-tag-attrs]]\n.AspectJ weaving attribute values\n|===\n| Annotation Value| XML Value| Explanation\n\n| `ENABLED`\n| `on`\n| AspectJ weaving is on, and aspects are woven at load-time as appropriate.\n\n| `DISABLED`\n| `off`\n| LTW is off. No aspect is woven at load-time.\n\n| `AUTODETECT`\n| `autodetect`\n| If the Spring LTW infrastructure can find at least one `META-INF/aop.xml` file,\n then AspectJ weaving is on. Otherwise, it is off. This is the default value.\n|===\n\n[[aop-aj-ltw-environments]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "Spring Configuration", "heading_level": 3, "file_order": 17, "section_index": 11, "content_hash": "881141746631bf8b1a016da39325d7502666d819d4a4ef6b91e1ff96f0d4d5aa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:5137539c06f58db64f2c3a8334084784155527f87473a45a1bc233df7bffab28", "content": "This last section contains any additional settings and configuration that you need\nwhen you use Spring's LTW support in environments such as application servers and web\ncontainers.\n\n[[aop-aj-ltw-environments-tomcat-jboss-etc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "Environment-specific Configuration", "heading_level": 3, "file_order": 17, "section_index": 12, "content_hash": "5137539c06f58db64f2c3a8334084784155527f87473a45a1bc233df7bffab28", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:4f81d34eff30eff610cc446d3423e2676532926bcc8fab720a6c4121e5f2e259", "content": "Tomcat and JBoss/WildFly provide a general app `ClassLoader` that is capable of local\ninstrumentation. Spring's native LTW may leverage those ClassLoader implementations\nto provide AspectJ weaving.\nYou can simply enable load-time weaving, as xref:core/aop/using-aspectj.adoc[described earlier].\nSpecifically, you do not need to modify the JVM launch script to add\n`-javaagent:path/to/spring-instrument.jar`.\n\nNote that on JBoss, you may need to disable the app server scanning to prevent it from\nloading the classes before the application actually starts. A quick workaround is to add\nto your artifact a file named `WEB-INF/jboss-scanning.xml` with the following content:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<scanning xmlns=\"urn:jboss:scanning:1.0\"/>\n----\n\n[[aop-aj-ltw-environments-generic]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "Tomcat, JBoss, WildFly", "heading_level": 4, "file_order": 17, "section_index": 13, "content_hash": "4f81d34eff30eff610cc446d3423e2676532926bcc8fab720a6c4121e5f2e259", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:20dd8c90029fe028d7bcfd25b9f9000671319ea56729d161cf8d0fa4e30dc53f", "content": "When class instrumentation is required in environments that are not supported by\nspecific `LoadTimeWeaver` implementations, a JVM agent is the general solution.\nFor such cases, Spring provides `InstrumentationLoadTimeWeaver` which requires a\nSpring-specific (but very general) JVM agent, `spring-instrument.jar`, autodetected\nby common `@EnableLoadTimeWeaving` and `<context:load-time-weaver/>` setups.\n\nTo use it, you must start the virtual machine with the Spring agent by supplying\nthe following JVM options:\n\n[literal]\n[subs=\"verbatim\"]\n----\n-javaagent:/path/to/spring-instrument.jar\n----\n\nNote that this requires modification of the JVM launch script, which may prevent you\nfrom using this in application server environments (depending on your server and your\noperation policies). That said, for one-app-per-JVM deployments such as standalone\nSpring Boot applications, you typically control the entire JVM setup in any case.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc", "title": "using-aspectj", "heading": "Generic Java Applications", "heading_level": 4, "file_order": 17, "section_index": 14, "content_hash": "20dd8c90029fe028d7bcfd25b9f9000671319ea56729d161cf8d0fa4e30dc53f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop/using-aspectj.adoc"}}
{"id": "sha256:4712f5388b2f23e99323e7c17f21e1b32b583697bd646d9e664671855a2189d6", "content": "[[aop-api-advice]]\n\nNow we can examine how Spring AOP handles advice.\n\n[[aop-api-advice-lifecycle]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc", "title": "advice", "heading": "advice", "heading_level": 1, "file_order": 18, "section_index": 0, "content_hash": "4712f5388b2f23e99323e7c17f21e1b32b583697bd646d9e664671855a2189d6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc"}}
{"id": "sha256:9dcf1da2baac666b4db291b1c5f762c4c643da07266ca5496ecc5acde5f4834f", "content": "Each advice is a Spring bean. An advice instance can be shared across all advised\nobjects or be unique to each advised object. This corresponds to per-class or\nper-instance advice.\n\nPer-class advice is used most often. It is appropriate for generic advice, such as\ntransaction advisors. These do not depend on the state of the proxied object or add new\nstate. They merely act on the method and arguments.\n\nPer-instance advice is appropriate for introductions, to support mixins. In this case,\nthe advice adds state to the proxied object.\n\nYou can use a mix of shared and per-instance advice in the same AOP proxy.\n\n[[aop-api-advice-types]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc", "title": "advice", "heading": "Advice Lifecycles", "heading_level": 2, "file_order": 18, "section_index": 1, "content_hash": "9dcf1da2baac666b4db291b1c5f762c4c643da07266ca5496ecc5acde5f4834f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc"}}
{"id": "sha256:465a3780b9f9b508bb2c6dcc33a3576ba4fa28d69c887bbe314828c7caa18b3b", "content": "Spring provides several advice types and is extensible to support\narbitrary advice types. This section describes the basic concepts and standard advice types.\n\n[[aop-api-advice-around]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc", "title": "advice", "heading": "Advice Types in Spring", "heading_level": 2, "file_order": 18, "section_index": 2, "content_hash": "465a3780b9f9b508bb2c6dcc33a3576ba4fa28d69c887bbe314828c7caa18b3b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc"}}
{"id": "sha256:61d72ee8b0cfc6cf845ed275c3d335c3318b7c92375dfba96b8fafa42d78c89b", "content": "The most fundamental advice type in Spring is _interception around advice_.\n\nSpring is compliant with the AOP Alliance interface for around advice that uses method\ninterception. Classes that implement around advice should therefore implement the\nfollowing `MethodInterceptor` interface from the `org.aopalliance.intercept` package:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface MethodInterceptor extends Interceptor {\n\n Object invoke(MethodInvocation invocation) throws Throwable;\n\t}\n----\n\nThe `MethodInvocation` argument to the `invoke()` method exposes the method being\ninvoked, the target join point, the AOP proxy, and the arguments to the method. The\n`invoke()` method should return the invocation's result: typically the return value of\nthe join point.\n\nThe following example shows a simple `MethodInterceptor` implementation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class DebugInterceptor implements MethodInterceptor {\n\n public Object invoke(MethodInvocation invocation) throws Throwable {\n System.out.println(\"Before: invocation=[\" + invocation + \"]\");\n Object result = invocation.proceed();\n System.out.println(\"Invocation returned\");\n return result;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass DebugInterceptor : MethodInterceptor {\n\n override fun invoke(invocation: MethodInvocation): Any {\n println(\"Before: invocation=[$invocation]\")\n val result = invocation.proceed()\n println(\"Invocation returned\")\n return result\n }\n\t}\n----\n======\n\nNote the call to the `proceed()` method of `MethodInvocation`. This proceeds down the\ninterceptor chain towards the join point. Most interceptors invoke this method and\nreturn its return value. However, a `MethodInterceptor`, like any around advice, can\nreturn a different value or throw an exception rather than invoke the proceed method.\nHowever, you do not want to do this without good reason.\n\nNOTE: `MethodInterceptor` implementations offer interoperability with other AOP Alliance-compliant AOP\nimplementations. The other advice types discussed in the remainder of this section\nimplement common AOP concepts but in a Spring-specific way. While there is an advantage\nin using the most specific advice type, stick with `MethodInterceptor` around advice if\nyou are likely to want to run the aspect in another AOP framework. Note that pointcuts\nare not currently interoperable between frameworks, and the AOP Alliance does not\ncurrently define pointcut interfaces.\n\n[[aop-api-advice-before]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc", "title": "advice", "heading": "Interception Around Advice", "heading_level": 3, "file_order": 18, "section_index": 3, "content_hash": "61d72ee8b0cfc6cf845ed275c3d335c3318b7c92375dfba96b8fafa42d78c89b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc"}}
{"id": "sha256:b0073aa7fc4fd26e87b8614f8850a8a9fa842e93f69f5890ba19d693fdd92212", "content": "A simpler advice type is a _before advice_. This does not need a `MethodInvocation`\nobject, since it is called only before entering the method.\n\nThe main advantage of a before advice is that there is no need to invoke the `proceed()`\nmethod and, therefore, no possibility of inadvertently failing to proceed down the\ninterceptor chain.\n\nThe following listing shows the `MethodBeforeAdvice` interface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface MethodBeforeAdvice extends BeforeAdvice {\n\n void before(Method m, Object[] args, Object target) throws Throwable;\n\t}\n----\n\nNote that the return type is `void`. Before advice can insert custom behavior before the join\npoint runs but cannot change the return value. If a before advice throws an\nexception, it stops further execution of the interceptor chain. The exception\npropagates back up the interceptor chain. If it is unchecked or on the signature of\nthe invoked method, it is passed directly to the client. Otherwise, it is\nwrapped in an unchecked exception by the AOP proxy.\n\nThe following example shows a before advice in Spring, which counts all method invocations:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class CountingBeforeAdvice implements MethodBeforeAdvice {\n\n private int count;\n\n public void before(Method m, Object[] args, Object target) throws Throwable {\n ++count;\n }\n\n public int getCount() {\n return count;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass CountingBeforeAdvice : MethodBeforeAdvice {\n\n var count: Int = 0\n\n override fun before(m: Method, args: Array<Any>, target: Any?) {\n ++count\n }\n\t}\n----\n======\n\nTIP: Before advice can be used with any pointcut.\n\n[[aop-api-advice-throws]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc", "title": "advice", "heading": "Before Advice", "heading_level": 3, "file_order": 18, "section_index": 4, "content_hash": "b0073aa7fc4fd26e87b8614f8850a8a9fa842e93f69f5890ba19d693fdd92212", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc"}}
{"id": "sha256:84170f90d1399a2dd19d9264cde1b9f184acff14036a08c1b36067f1afc3634f", "content": "_Throws advice_ is invoked after the return of the join point if the join point threw\nan exception. Spring offers typed throws advice. Note that this means that the\n`org.springframework.aop.ThrowsAdvice` interface does not contain any methods. It is a\nmarker interface identifying that the given object implements one or more typed throws\nadvice methods. These should be in the following form:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tafterThrowing([Method, args, target], subclassOfThrowable)\n----\n\nOnly the last argument is required. The method signatures may have either one or four\narguments, depending on whether the advice method is interested in the method and\narguments. The next two listings show classes that are examples of throws advice.\n\nThe following advice is invoked if a `RemoteException` is thrown (including subclasses of\n`RemoteException`):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class RemoteThrowsAdvice implements ThrowsAdvice {\n\n public void afterThrowing(RemoteException ex) throws Throwable {\n // Do something with remote exception\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass RemoteThrowsAdvice : ThrowsAdvice {\n\n fun afterThrowing(ex: RemoteException) {\n // Do something with remote exception\n }\n\t}\n----\n======\n\nUnlike the preceding advice, the next example declares four arguments, so that it has\naccess to the invoked method, method arguments, and target object. The following advice\nis invoked if a `ServletException` is thrown:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ServletThrowsAdviceWithArguments implements ThrowsAdvice {\n\n public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {\n // Do something with all arguments\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ServletThrowsAdviceWithArguments : ThrowsAdvice {\n\n fun afterThrowing(m: Method, args: Array<Any>, target: Any, ex: ServletException) {\n // Do something with all arguments\n }\n\t}\n----\n======\n\nThe final example illustrates how these two methods could be used in a single class\nthat handles both `RemoteException` and `ServletException`. Any number of throws advice\nmethods can be combined in a single class. The following listing shows the final example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic static class CombinedThrowsAdvice implements ThrowsAdvice {\n\n public void afterThrowing(RemoteException ex) throws Throwable {\n // Do something with remote exception\n }\n\n public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {\n // Do something with all arguments\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass CombinedThrowsAdvice : ThrowsAdvice {\n\n fun afterThrowing(ex: RemoteException) {\n // Do something with remote exception\n }\n\n fun afterThrowing(m: Method, args: Array<Any>, target: Any, ex: ServletException) {\n // Do something with all arguments\n }\n\t}\n----\n======\n\nNOTE: If a throws-advice method throws an exception itself, it overrides the\noriginal exception (that is, it changes the exception thrown to the user). The overriding\nexception is typically a RuntimeException, which is compatible with any method\nsignature. However, if a throws-advice method throws a checked exception, it must\nmatch the declared exceptions of the target method and is, hence, to some degree\ncoupled to specific target method signatures. _Do not throw an undeclared checked\nexception that is incompatible with the target method's signature!_\n\nTIP: Throws advice can be used with any pointcut.\n\n[[aop-api-advice-after-returning]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc", "title": "advice", "heading": "Throws Advice", "heading_level": 3, "file_order": 18, "section_index": 5, "content_hash": "84170f90d1399a2dd19d9264cde1b9f184acff14036a08c1b36067f1afc3634f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc"}}
{"id": "sha256:97cd3132c9e85c17ce86ae0cd214e4e2dbddc2618a1ef782113fa25b93af5065", "content": "An _after returning advice_ in Spring must implement the\n`org.springframework.aop.AfterReturningAdvice` interface, which the following listing shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface AfterReturningAdvice extends Advice {\n\n void afterReturning(Object returnValue, Method m, Object[] args, Object target)\n throws Throwable;\n\t}\n----\n\nAn after returning advice has access to the return value (which it cannot modify),\nthe invoked method, the method's arguments, and the target.\n\nThe following after returning advice counts all successful method invocations that have\nnot thrown exceptions:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class CountingAfterReturningAdvice implements AfterReturningAdvice {\n\n private int count;\n\n public void afterReturning(Object returnValue, Method m, Object[] args, Object target)\n throws Throwable {\n ++count;\n }\n\n public int getCount() {\n return count;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass CountingAfterReturningAdvice : AfterReturningAdvice {\n\n var count: Int = 0\n private set\n\n override fun afterReturning(returnValue: Any?, m: Method, args: Array<Any>, target: Any?) {\n ++count\n }\n\t}\n----\n======\n\nThis advice does not change the execution path. If it throws an exception, it is\nthrown up the interceptor chain instead of the return value.\n\nTIP: After returning advice can be used with any pointcut.\n\n[[aop-api-advice-introduction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc", "title": "advice", "heading": "After Returning Advice", "heading_level": 3, "file_order": 18, "section_index": 6, "content_hash": "97cd3132c9e85c17ce86ae0cd214e4e2dbddc2618a1ef782113fa25b93af5065", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc"}}
{"id": "sha256:b35bad6a4136910a24dbbe79ab16162e42df4a8a32679b65895a718066632773", "content": "Spring treats _introduction advice_ as a special kind of interception advice.\n\nIntroduction requires an `IntroductionAdvisor` and an `IntroductionInterceptor` that\nimplement the following interface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface IntroductionInterceptor extends MethodInterceptor {\n\n boolean implementsInterface(Class intf);\n\t}\n----\n\nThe `invoke()` method inherited from the AOP Alliance `MethodInterceptor` interface must\nimplement the introduction. That is, if the invoked method is on an introduced\ninterface, the introduction interceptor is responsible for handling the method call -- it\ncannot invoke `proceed()`.\n\nIntroduction advice cannot be used with any pointcut, as it applies only at the class,\nrather than the method, level. You can only use introduction advice with the\n`IntroductionAdvisor`, which has the following methods:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface IntroductionAdvisor extends Advisor, IntroductionInfo {\n\n ClassFilter getClassFilter();\n\n void validateInterfaces() throws IllegalArgumentException;\n\t}\n\n\tpublic interface IntroductionInfo {\n\n Class<?>[] getInterfaces();\n\t}\n----\n\nThere is no `MethodMatcher` and, hence, no `Pointcut` associated with introduction\nadvice. Only class filtering is logical.\n\nThe `getInterfaces()` method returns the interfaces introduced by this advisor.\n\nThe `validateInterfaces()` method is used internally to see whether or not the\nintroduced interfaces can be implemented by the configured `IntroductionInterceptor`.\n\nConsider an example from the Spring test suite and suppose we want to\nintroduce the following interface to one or more objects:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface Lockable {\n void lock();\n void unlock();\n boolean locked();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tinterface Lockable {\n fun lock()\n fun unlock()\n fun locked(): Boolean\n\t}\n----\n======\n\nThis illustrates a mixin. We want to be able to cast advised objects to `Lockable`,\nwhatever their type and call lock and unlock methods. If we call the `lock()` method, we\nwant all setter methods to throw a `LockedException`. Thus, we can add an aspect that\nprovides the ability to make objects immutable without them having any knowledge of it:\na good example of AOP.\n\nFirst, we need an `IntroductionInterceptor` that does the heavy lifting. In this\ncase, we extend the `org.springframework.aop.support.DelegatingIntroductionInterceptor`\nconvenience class. We could implement `IntroductionInterceptor` directly, but using\n`DelegatingIntroductionInterceptor` is best for most cases.\n\nThe `DelegatingIntroductionInterceptor` is designed to delegate an introduction to an\nactual implementation of the introduced interfaces, concealing the use of interception\nto do so. You can set the delegate to any object using a constructor argument. The\ndefault delegate (when the no-argument constructor is used) is `this`. Thus, in the next example,\nthe delegate is the `LockMixin` subclass of `DelegatingIntroductionInterceptor`.\nGiven a delegate (by default, itself), a `DelegatingIntroductionInterceptor` instance\nlooks for all interfaces implemented by the delegate (other than\n`IntroductionInterceptor`) and supports introductions against any of them.\nSubclasses such as `LockMixin` can call the `suppressInterface(Class intf)`\nmethod to suppress interfaces that should not be exposed. However, no matter how many\ninterfaces an `IntroductionInterceptor` is prepared to support, the\n`IntroductionAdvisor` used controls which interfaces are actually exposed. An\nintroduced interface conceals any implementation of the same interface by the target.\n\nThus, `LockMixin` extends `DelegatingIntroductionInterceptor` and implements `Lockable`\nitself. The superclass automatically picks up that `Lockable` can be supported for\nintroduction, so we do not need to specify that. We could introduce any number of\ninterfaces in this way.\n\nNote the use of the `locked` instance variable. This effectively adds additional state\nto that held in the target object.\n\nThe following example shows the example `LockMixin` class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class LockMixin extends DelegatingIntroductionInterceptor implements Lockable {\n\n private boolean locked;\n\n public void lock() {\n this.locked = true;\n }\n\n public void unlock() {\n this.locked = false;\n }\n\n public boolean locked() {\n return this.locked;\n }\n\n public Object invoke(MethodInvocation invocation) throws Throwable {\n if (locked() && invocation.getMethod().getName().indexOf(\"set\") == 0) {\n throw new LockedException();\n }\n return super.invoke(invocation);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass LockMixin : DelegatingIntroductionInterceptor(), Lockable {\n\n private var locked: Boolean = false\n\n fun lock() {\n this.locked = true\n }\n\n fun unlock() {\n this.locked = false\n }\n\n fun locked(): Boolean {\n return this.locked\n }\n\n override fun invoke(invocation: MethodInvocation): Any? {\n if (locked() && invocation.method.name.indexOf(\"set\") == 0) {\n throw LockedException()\n }\n return super.invoke(invocation)\n }\n\t}\n----\n======\n\nOften, you need not override the `invoke()` method. The\n`DelegatingIntroductionInterceptor` implementation (which calls the `delegate` method if\nthe method is introduced, otherwise proceeds towards the join point) usually\nsuffices. In the present case, we need to add a check: no setter method can be invoked\nif in locked mode.\n\nThe required introduction only needs to hold a distinct\n`LockMixin` instance and specify the introduced interfaces (in this case, only\n`Lockable`). A more complex example might take a reference to the introduction\ninterceptor (which would be defined as a prototype). In this case, there is no\nconfiguration relevant for a `LockMixin`, so we create it by using `new`.\nThe following example shows our `LockMixinAdvisor` class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class LockMixinAdvisor extends DefaultIntroductionAdvisor {\n\n public LockMixinAdvisor() {\n super(new LockMixin(), Lockable.class);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass LockMixinAdvisor : DefaultIntroductionAdvisor(LockMixin(), Lockable::class.java)\n----\n======\n\nWe can apply this advisor very simply, because it requires no configuration. (However, it\nis impossible to use an `IntroductionInterceptor` without an\n`IntroductionAdvisor`.) As usual with introductions, the advisor must be per-instance,\nas it is stateful. We need a different instance of `LockMixinAdvisor`, and hence\n`LockMixin`, for each advised object. The advisor comprises part of the advised object's\nstate.\n\nWe can apply this advisor programmatically by using the `Advised.addAdvisor()` method or\n(the recommended way) in XML configuration, as any other advisor. All proxy creation\nchoices discussed below, including \"`auto proxy creators,`\" correctly handle introductions\nand stateful mixins.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc", "title": "advice", "heading": "Introduction Advice", "heading_level": 3, "file_order": 18, "section_index": 7, "content_hash": "b35bad6a4136910a24dbbe79ab16162e42df4a8a32679b65895a718066632773", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/advice.adoc"}}
{"id": "sha256:88d71305edf3381e8d836c886801b322dadeaa374a4759e051d549b3a64a7b83", "content": "[[aop-api-advised]]\n\nHowever you create AOP proxies, you can manipulate them BY using the\n`org.springframework.aop.framework.Advised` interface. Any AOP proxy can be cast to this\ninterface, no matter which other interfaces it implements. This interface includes the\nfollowing methods:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tAdvisor[] getAdvisors();\n\n\tvoid addAdvice(Advice advice) throws AopConfigException;\n\n\tvoid addAdvice(int pos, Advice advice) throws AopConfigException;\n\n\tvoid addAdvisor(Advisor advisor) throws AopConfigException;\n\n\tvoid addAdvisor(int pos, Advisor advisor) throws AopConfigException;\n\n\tint indexOf(Advisor advisor);\n\n\tboolean removeAdvisor(Advisor advisor) throws AopConfigException;\n\n\tvoid removeAdvisor(int index) throws AopConfigException;\n\n\tboolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;\n\n\tboolean isFrozen();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun getAdvisors(): Array<Advisor>\n\n\t@Throws(AopConfigException::class)\n\tfun addAdvice(advice: Advice)\n\n\t@Throws(AopConfigException::class)\n\tfun addAdvice(pos: Int, advice: Advice)\n\n\t@Throws(AopConfigException::class)\n\tfun addAdvisor(advisor: Advisor)\n\n\t@Throws(AopConfigException::class)\n\tfun addAdvisor(pos: Int, advisor: Advisor)\n\n\tfun indexOf(advisor: Advisor): Int\n\n\t@Throws(AopConfigException::class)\n\tfun removeAdvisor(advisor: Advisor): Boolean\n\n\t@Throws(AopConfigException::class)\n\tfun removeAdvisor(index: Int)\n\n\t@Throws(AopConfigException::class)\n\tfun replaceAdvisor(a: Advisor, b: Advisor): Boolean\n\n\tfun isFrozen(): Boolean\n----\n======\n\nThe `getAdvisors()` method returns an `Advisor` for every advisor, interceptor, or\nother advice type that has been added to the factory. If you added an `Advisor`, the\nreturned advisor at this index is the object that you added. If you added an\ninterceptor or other advice type, Spring wrapped this in an advisor with a\npointcut that always returns `true`. Thus, if you added a `MethodInterceptor`, the advisor\nreturned for this index is a `DefaultPointcutAdvisor` that returns your\n`MethodInterceptor` and a pointcut that matches all classes and methods.\n\nThe `addAdvisor()` methods can be used to add any `Advisor`. Usually, the advisor holding\npointcut and advice is the generic `DefaultPointcutAdvisor`, which you can use with\nany advice or pointcut (but not for introductions).\n\nBy default, it is possible to add or remove advisors or interceptors even once a proxy\nhas been created. The only restriction is that it is impossible to add or remove an\nintroduction advisor, as existing proxies from the factory do not show the interface\nchange. (You can obtain a new proxy from the factory to avoid this problem.)\n\nThe following example shows casting an AOP proxy to the `Advised` interface and examining and\nmanipulating its advice:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tAdvised advised = (Advised) myObject;\n\tAdvisor[] advisors = advised.getAdvisors();\n\tint oldAdvisorCount = advisors.length;\n\tSystem.out.println(oldAdvisorCount + \" advisors\");\n\n\t// Add an advice like an interceptor without a pointcut\n\t// Will match all proxied methods\n\t// Can use for interceptors, before, after returning or throws advice\n\tadvised.addAdvice(new DebugInterceptor());\n\n\t// Add selective advice using a pointcut\n\tadvised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));\n\n\tassertEquals(\"Added two advisors\", oldAdvisorCount + 2, advised.getAdvisors().length);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval advised = myObject as Advised\n\tval advisors = advised.advisors\n\tval oldAdvisorCount = advisors.size\n\tprintln(\"$oldAdvisorCount advisors\")\n\n\t// Add an advice like an interceptor without a pointcut\n\t// Will match all proxied methods\n\t// Can use for interceptors, before, after returning or throws advice\n\tadvised.addAdvice(DebugInterceptor())\n\n\t// Add selective advice using a pointcut\n\tadvised.addAdvisor(DefaultPointcutAdvisor(mySpecialPointcut, myAdvice))\n\n\tassertEquals(\"Added two advisors\", oldAdvisorCount + 2, advised.advisors.size)\n----\n======\n\nNOTE: It is questionable whether it is advisable (no pun intended) to modify advice on a\nbusiness object in production, although there are, no doubt, legitimate usage cases.\nHowever, it can be very useful in development (for example, in tests). We have sometimes\nfound it very useful to be able to add test code in the form of an interceptor or other\nadvice, getting inside a method invocation that we want to test. (For example, the advice can\nget inside a transaction created for that method, perhaps to run SQL to check that\na database was correctly updated, before marking the transaction for roll back.)\n\nDepending on how you created the proxy, you can usually set a `frozen` flag. In that\ncase, the `Advised` `isFrozen()` method returns `true`, and any attempts to modify\nadvice through addition or removal results in an `AopConfigException`. The ability\nto freeze the state of an advised object is useful in some cases (for example, to\nprevent calling code removing a security interceptor).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/advised.adoc", "title": "advised", "heading": "advised", "heading_level": 1, "file_order": 19, "section_index": 0, "content_hash": "88d71305edf3381e8d836c886801b322dadeaa374a4759e051d549b3a64a7b83", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/advised.adoc"}}
{"id": "sha256:5619fb729d5326d9dc978113569457368b98141ee76439a4d53dc0636280da75", "content": "[[aop-api-advisor]]\n\nIn Spring, an Advisor is an aspect that contains only a single advice object associated\nwith a pointcut expression.\n\nApart from the special case of introductions, any advisor can be used with any advice.\n`org.springframework.aop.support.DefaultPointcutAdvisor` is the most commonly used\nadvisor class. It can be used with a `MethodInterceptor`, `BeforeAdvice`, or\n`ThrowsAdvice`.\n\nIt is possible to mix advisor and advice types in Spring in the same AOP proxy. For\nexample, you could use an interception around advice, throws advice, and before advice in\none proxy configuration. Spring automatically creates the necessary interceptor\nchain.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/advisor.adoc", "title": "advisor", "heading": "advisor", "heading_level": 1, "file_order": 20, "section_index": 0, "content_hash": "5619fb729d5326d9dc978113569457368b98141ee76439a4d53dc0636280da75", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/advisor.adoc"}}
{"id": "sha256:03be4b485042ec02b65c016070a40a52b48a094139be5e332886b5926ac6c1a8", "content": "[[aop-autoproxy]]\n\nSo far, we have considered explicit creation of AOP proxies by using a `ProxyFactoryBean` or\nsimilar factory bean.\n\nSpring also lets us use \"`auto-proxy`\" bean definitions, which can automatically\nproxy selected bean definitions. This is built on Spring's \"`bean post processor`\"\ninfrastructure, which enables modification of any bean definition as the container loads.\n\nIn this model, you set up some special bean definitions in your XML bean definition file\nto configure the auto-proxy infrastructure. This lets you declare the targets\neligible for auto-proxying. You need not use `ProxyFactoryBean`.\n\nThere are two ways to do this:\n\n* By using an auto-proxy creator that refers to specific beans in the current context.\n* A special case of auto-proxy creation that deserves to be considered separately:\n auto-proxy creation driven by source-level metadata attributes.\n\n[[aop-autoproxy-choices]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/autoproxy.adoc", "title": "autoproxy", "heading": "autoproxy", "heading_level": 1, "file_order": 21, "section_index": 0, "content_hash": "03be4b485042ec02b65c016070a40a52b48a094139be5e332886b5926ac6c1a8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/autoproxy.adoc"}}
{"id": "sha256:0b292cd336434dde9752f5f00828a77896376931ceb54d157ddf47f1599f69a0", "content": "This section covers the auto-proxy creators provided by the\n`org.springframework.aop.framework.autoproxy` package.\n\n[[aop-api-autoproxy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/autoproxy.adoc", "title": "autoproxy", "heading": "Auto-proxy Bean Definitions", "heading_level": 2, "file_order": 21, "section_index": 1, "content_hash": "0b292cd336434dde9752f5f00828a77896376931ceb54d157ddf47f1599f69a0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/autoproxy.adoc"}}
{"id": "sha256:64dbe9a545fa22afadbc7c537a691aad1648c0a7e6f4ed8ec2e6130989d6693c", "content": "The `BeanNameAutoProxyCreator` class is a `BeanPostProcessor` that automatically creates\nAOP proxies for beans with names that match literal values or wildcards. The following\nexample shows how to create a `BeanNameAutoProxyCreator` bean:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean class=\"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator\">\n <property name=\"beanNames\" value=\"jdk*,onlyJdk\"/>\n <property name=\"interceptorNames\">\n <list>\n <value>myInterceptor</value>\n </list>\n </property>\n\t</bean>\n----\n\nAs with `ProxyFactoryBean`, there is an `interceptorNames` property rather than a list\nof interceptors, to allow correct behavior for prototype advisors. Named \"`interceptors`\"\ncan be advisors or any advice type.\n\nAs with auto-proxying in general, the main point of using `BeanNameAutoProxyCreator` is\nto apply the same configuration consistently to multiple objects, with minimal volume of\nconfiguration. It is a popular choice for applying declarative transactions to multiple\nobjects.\n\nBean definitions whose names match, such as `jdkMyBean` and `onlyJdk` in the preceding\nexample, are plain old bean definitions with the target class. An AOP proxy is\nautomatically created by the `BeanNameAutoProxyCreator`. The same advice is applied\nto all matching beans. Note that, if advisors are used (rather than the interceptor in\nthe preceding example), the pointcuts may apply differently to different beans.\n\n[[aop-api-autoproxy-default]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/autoproxy.adoc", "title": "autoproxy", "heading": "`BeanNameAutoProxyCreator`", "heading_level": 3, "file_order": 21, "section_index": 2, "content_hash": "64dbe9a545fa22afadbc7c537a691aad1648c0a7e6f4ed8ec2e6130989d6693c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/autoproxy.adoc"}}
{"id": "sha256:a8f17dd20f8912de795982b09cc69a4b41fe9a40c812e1cb9b5f364a33a095af", "content": "A more general and extremely powerful auto-proxy creator is\n`DefaultAdvisorAutoProxyCreator`. This automagically applies eligible advisors in the\ncurrent context, without the need to include specific bean names in the auto-proxy\nadvisor's bean definition. It offers the same merit of consistent configuration and\navoidance of duplication as `BeanNameAutoProxyCreator`.\n\nUsing this mechanism involves:\n\n* Specifying a `DefaultAdvisorAutoProxyCreator` bean definition.\n* Specifying any number of advisors in the same or related contexts. Note that these\n must be advisors, not interceptors or other advice. This is necessary,\n because there must be a pointcut to evaluate, to check the eligibility of each advice\n to candidate bean definitions.\n\nThe `DefaultAdvisorAutoProxyCreator` automatically evaluates the pointcut contained\nin each advisor, to see what (if any) advice it should apply to each business object\n(such as `businessObject1` and `businessObject2` in the example).\n\nThis means that any number of advisors can be applied automatically to each business\nobject. If no pointcut in any of the advisors matches any method in a business object,\nthe object is not proxied. As bean definitions are added for new business objects,\nthey are automatically proxied if necessary.\n\nAuto-proxying in general has the advantage of making it impossible for callers or\ndependencies to obtain an un-advised object. Calling `getBean(\"businessObject1\")` on this\n`ApplicationContext` returns an AOP proxy, not the target business object. (The \"`inner\nbean`\" idiom shown earlier also offers this benefit.)\n\nThe following example creates a `DefaultAdvisorAutoProxyCreator` bean and the other\nelements discussed in this section:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean class=\"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator\"/>\n\n\t<bean class=\"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor\">\n <property name=\"transactionInterceptor\" ref=\"transactionInterceptor\"/>\n\t</bean>\n\n\t<bean id=\"customAdvisor\" class=\"com.mycompany.MyAdvisor\"/>\n\n\t<bean id=\"businessObject1\" class=\"com.mycompany.BusinessObject1\">\n <!-- Properties omitted -->\n\t</bean>\n\n\t<bean id=\"businessObject2\" class=\"com.mycompany.BusinessObject2\"/>\n----\n\nThe `DefaultAdvisorAutoProxyCreator` is very useful if you want to apply the same advice\nconsistently to many business objects. Once the infrastructure definitions are in place,\nyou can add new business objects without including specific proxy configuration.\nYou can also easily drop in additional aspects (for example, tracing or\nperformance monitoring aspects) with minimal change to configuration.\n\nThe `DefaultAdvisorAutoProxyCreator` offers support for filtering (by using a naming\nconvention so that only certain advisors are evaluated, which allows the use of multiple,\ndifferently configured, AdvisorAutoProxyCreators in the same factory) and ordering.\nAdvisors can implement the `org.springframework.core.Ordered` interface to ensure\ncorrect ordering if this is an issue. The `TransactionAttributeSourceAdvisor` used in the\npreceding example has a configurable order value. The default setting is unordered.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/autoproxy.adoc", "title": "autoproxy", "heading": "`DefaultAdvisorAutoProxyCreator`", "heading_level": 3, "file_order": 21, "section_index": 3, "content_hash": "a8f17dd20f8912de795982b09cc69a4b41fe9a40c812e1cb9b5f364a33a095af", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/autoproxy.adoc"}}
{"id": "sha256:61e303f958846754af3ebe9d55ca16303fd93fe73ec15802bcd75800142c7387", "content": "[[aop-concise-proxy]]\n\nEspecially when defining transactional proxies, you may end up with many similar proxy\ndefinitions. The use of parent and child bean definitions, along with inner bean\ndefinitions, can result in much cleaner and more concise proxy definitions.\n\nFirst, we create a parent, template, bean definition for the proxy, as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"txProxyTemplate\" abstract=\"true\"\n class=\"org.springframework.transaction.interceptor.TransactionProxyFactoryBean\">\n <property name=\"transactionManager\" ref=\"transactionManager\"/>\n <property name=\"transactionAttributes\">\n <props>\n <prop key=\"*\">PROPAGATION_REQUIRED</prop>\n </props>\n </property>\n\t</bean>\n----\n\nThis is never instantiated itself, so it can actually be incomplete. Then, each proxy\nthat needs to be created is a child bean definition, which wraps the target of the\nproxy as an inner bean definition, since the target is never used on its own anyway.\nThe following example shows such a child bean:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"myService\" parent=\"txProxyTemplate\">\n <property name=\"target\">\n <bean class=\"org.springframework.samples.MyServiceImpl\">\n </bean>\n </property>\n\t</bean>\n----\n\nYou can override properties from the parent template. In the following example,\nwe override the transaction propagation settings:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"mySpecialService\" parent=\"txProxyTemplate\">\n <property name=\"target\">\n <bean class=\"org.springframework.samples.MySpecialServiceImpl\">\n </bean>\n </property>\n <property name=\"transactionAttributes\">\n <props>\n <prop key=\"get*\">PROPAGATION_REQUIRED,readOnly</prop>\n <prop key=\"find*\">PROPAGATION_REQUIRED,readOnly</prop>\n <prop key=\"load*\">PROPAGATION_REQUIRED,readOnly</prop>\n <prop key=\"store*\">PROPAGATION_REQUIRED</prop>\n </props>\n </property>\n\t</bean>\n----\n\nNote that in the parent bean example, we explicitly marked the parent bean definition as\nbeing abstract by setting the `abstract` attribute to `true`, as described\nxref:core/beans/child-bean-definitions.adoc[previously], so that it may not actually ever be\ninstantiated. Application contexts (but not simple bean factories), by default,\npre-instantiate all singletons. Therefore, it is important (at least for singleton beans)\nthat, if you have a (parent) bean definition that you intend to use only as a template,\nand this definition specifies a class, you must make sure to set the `abstract`\nattribute to `true`. Otherwise, the application context actually tries to\npre-instantiate it.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/concise-proxy.adoc", "title": "concise-proxy", "heading": "concise-proxy", "heading_level": 1, "file_order": 22, "section_index": 0, "content_hash": "61e303f958846754af3ebe9d55ca16303fd93fe73ec15802bcd75800142c7387", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/concise-proxy.adoc"}}
{"id": "sha256:780fe03ccc25d524d653a5c36fd93f5590370a7bea4404d7cc691e25cf3ca132", "content": "[[aop-extensibility]]\n\nSpring AOP is designed to be extensible. While the interception implementation strategy\nis presently used internally, it is possible to support arbitrary advice types in\naddition to the interception around advice, before, throws advice, and\nafter returning advice.\n\nThe `org.springframework.aop.framework.adapter` package is an SPI package that lets\nsupport for new custom advice types be added without changing the core framework.\nThe only constraint on a custom `Advice` type is that it must implement the\n`org.aopalliance.aop.Advice` marker interface.\n\nSee the {spring-framework-api}/aop/framework/adapter/package-summary.html[`org.springframework.aop.framework.adapter`]\njavadoc for further information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/extensibility.adoc", "title": "extensibility", "heading": "extensibility", "heading_level": 1, "file_order": 23, "section_index": 0, "content_hash": "780fe03ccc25d524d653a5c36fd93f5590370a7bea4404d7cc691e25cf3ca132", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/extensibility.adoc"}}
{"id": "sha256:5d6cccc09fe8c2cdc22ae2f0e1b7c9d07c13bf1eefbfaa19df053811d75f9249", "content": "[[aop-pfb]]\n\nIf you use the Spring IoC container (an `ApplicationContext` or `BeanFactory`) for your\nbusiness objects (and you should be!), you want to use one of Spring's AOP\n`FactoryBean` implementations. (Remember that a factory bean introduces a layer of indirection, letting\nit create objects of a different type.)\n\nNOTE: The Spring AOP support also uses factory beans under the covers.\n\nThe basic way to create an AOP proxy in Spring is to use the\n`org.springframework.aop.framework.ProxyFactoryBean`. This gives complete control over\nthe pointcuts, any advice that applies, and their ordering. However, there are simpler\noptions that are preferable if you do not need such control.\n\n[[aop-pfb-1]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc", "title": "pfb", "heading": "pfb", "heading_level": 1, "file_order": 24, "section_index": 0, "content_hash": "5d6cccc09fe8c2cdc22ae2f0e1b7c9d07c13bf1eefbfaa19df053811d75f9249", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc"}}
{"id": "sha256:78e0e77852eb13fb0cb25ea7e234abb2605d3c670dbf23c6a3aa23b164d0aa55", "content": "The `ProxyFactoryBean`, like other Spring `FactoryBean` implementations, introduces a\nlevel of indirection. If you define a `ProxyFactoryBean` named `foo`, objects that\nreference `foo` do not see the `ProxyFactoryBean` instance itself but an object\ncreated by the implementation of the `getObject()` method in the `ProxyFactoryBean` . This\nmethod creates an AOP proxy that wraps a target object.\n\nOne of the most important benefits of using a `ProxyFactoryBean` or another IoC-aware\nclass to create AOP proxies is that advice and pointcuts can also be\nmanaged by IoC. This is a powerful feature, enabling certain approaches that are hard to\nachieve with other AOP frameworks. For example, an advice may itself reference\napplication objects (besides the target, which should be available in any AOP\nframework), benefiting from all the pluggability provided by Dependency Injection.\n\n[[aop-pfb-2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc", "title": "pfb", "heading": "Basics", "heading_level": 2, "file_order": 24, "section_index": 1, "content_hash": "78e0e77852eb13fb0cb25ea7e234abb2605d3c670dbf23c6a3aa23b164d0aa55", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc"}}
{"id": "sha256:a1ac074e4c4818017fe06c8451ee1e94febc9c93826270d08c7fe2d6f3f565f7", "content": "In common with most `FactoryBean` implementations provided with Spring, the\n`ProxyFactoryBean` class is itself a JavaBean. Its properties are used to:\n\n* Specify the target you want to proxy.\n* Specify whether to use CGLIB (described later and see also xref:core/aop-api/pfb.adoc#aop-pfb-proxy-types[JDK- and CGLIB-based proxies]).\n\nSome key properties are inherited from `org.springframework.aop.framework.ProxyConfig`\n(the superclass for all AOP proxy factories in Spring). These key properties include\nthe following:\n\n* `proxyTargetClass`: `true` if the target class is to be proxied, rather than the\n target class's interfaces. If this property value is set to `true`, then CGLIB proxies\n are created (but see also xref:core/aop-api/pfb.adoc#aop-pfb-proxy-types[JDK- and CGLIB-based proxies]).\n* `optimize`: Controls whether or not aggressive optimizations are applied to proxies\n created through CGLIB. You should not blithely use this setting unless you fully\n understand how the relevant AOP proxy handles optimization. This is currently used\n only for CGLIB proxies. It has no effect with JDK dynamic proxies.\n* `frozen`: If a proxy configuration is `frozen`, changes to the configuration are\n no longer allowed. This is useful both as a slight optimization and for those cases\n when you do not want callers to be able to manipulate the proxy (through the `Advised`\n interface) after the proxy has been created. The default value of this property is\n `false`, so changes (such as adding additional advice) are allowed.\n* `exposeProxy`: Determines whether or not the current proxy should be exposed in a\n `ThreadLocal` so that it can be accessed by the target. If a target needs to obtain\n the proxy and the `exposeProxy` property is set to `true`, the target can use the\n `AopContext.currentProxy()` method.\n\nOther properties specific to `ProxyFactoryBean` include the following:\n\n* `proxyInterfaces`: An array of `String` interface names. If this is not supplied, a CGLIB\n proxy for the target class is used (but see also xref:core/aop-api/pfb.adoc#aop-pfb-proxy-types[JDK- and CGLIB-based proxies]).\n* `interceptorNames`: A `String` array of `Advisor`, interceptor, or other advice names to\n apply. Ordering is significant, on a first come-first served basis. That is to say\n that the first interceptor in the list is the first to be able to intercept the\n invocation.\n+\nThe names are bean names in the current factory, including bean names from ancestor\nfactories. You cannot mention bean references here, since doing so results in the\n`ProxyFactoryBean` ignoring the singleton setting of the advice.\n+\nYou can append an interceptor name with an asterisk (`*`). Doing so results in the\napplication of all advisor beans with names that start with the part before the asterisk\nto be applied. You can find an example of using this feature in xref:core/aop-api/pfb.adoc#aop-global-advisors[Using \"`Global`\" Advisors].\n\n* singleton: Whether or not the factory should return a single object, no matter how\n often the `getObject()` method is called. Several `FactoryBean` implementations offer\n such a method. The default value is `true`. If you want to use stateful advice - for\n example, for stateful mixins - use prototype advice along with a singleton value of\n `false`.\n\n[[aop-pfb-proxy-types]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc", "title": "pfb", "heading": "JavaBean Properties", "heading_level": 2, "file_order": 24, "section_index": 2, "content_hash": "a1ac074e4c4818017fe06c8451ee1e94febc9c93826270d08c7fe2d6f3f565f7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc"}}
{"id": "sha256:1bf428326efe2a7bc77f8b37df7e00112979593a88b5548d845430fabdf91195", "content": "This section serves as the definitive documentation on how the `ProxyFactoryBean`\nchooses to create either a JDK-based proxy or a CGLIB-based proxy for a particular target\nobject (which is to be proxied).\n\nNOTE: The behavior of the `ProxyFactoryBean` with regard to creating JDK- or CGLIB-based\nproxies changed between versions 1.2.x and 2.0 of Spring. The `ProxyFactoryBean` now\nexhibits similar semantics with regard to auto-detecting interfaces as those of the\n`TransactionProxyFactoryBean` class.\n\nIf the class of a target object that is to be proxied (hereafter simply referred to as\nthe target class) does not implement any interfaces, a CGLIB-based proxy is\ncreated. This is the easiest scenario, because JDK proxies are interface-based, and no\ninterfaces means JDK proxying is not even possible. You can plug in the target bean\nand specify the list of interceptors by setting the `interceptorNames` property. Note that a\nCGLIB-based proxy is created even if the `proxyTargetClass` property of the\n`ProxyFactoryBean` has been set to `false`. (Doing so makes no sense and is best\nremoved from the bean definition, because it is, at best, redundant, and, at worst\nconfusing.)\n\nIf the target class implements one (or more) interfaces, the type of proxy that is\ncreated depends on the configuration of the `ProxyFactoryBean`.\n\nIf the `proxyTargetClass` property of the `ProxyFactoryBean` has been set to `true`,\na CGLIB-based proxy is created. This makes sense and is in keeping with the\nprinciple of least surprise. Even if the `proxyInterfaces` property of the\n`ProxyFactoryBean` has been set to one or more fully qualified interface names, the fact\nthat the `proxyTargetClass` property is set to `true` causes CGLIB-based\nproxying to be in effect.\n\nIf the `proxyInterfaces` property of the `ProxyFactoryBean` has been set to one or more\nfully qualified interface names, a JDK-based proxy is created. The created\nproxy implements all of the interfaces that were specified in the `proxyInterfaces`\nproperty. If the target class happens to implement a whole lot more interfaces than\nthose specified in the `proxyInterfaces` property, that is all well and good, but those\nadditional interfaces are not implemented by the returned proxy.\n\nIf the `proxyInterfaces` property of the `ProxyFactoryBean` has not been set, but\nthe target class does implement one (or more) interfaces, the\n`ProxyFactoryBean` auto-detects the fact that the target class does actually\nimplement at least one interface, and a JDK-based proxy is created. The interfaces\nthat are actually proxied are all of the interfaces that the target class\nimplements. In effect, this is the same as supplying a list of each and every\ninterface that the target class implements to the `proxyInterfaces` property. However,\nit is significantly less work and less prone to typographical errors.\n\n[[aop-api-proxying-intf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc", "title": "pfb", "heading": "JDK- and CGLIB-based proxies", "heading_level": 2, "file_order": 24, "section_index": 3, "content_hash": "1bf428326efe2a7bc77f8b37df7e00112979593a88b5548d845430fabdf91195", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc"}}
{"id": "sha256:1f1f0bac99a415c995595d88966a11efe6490ad2c7ae8763ee285c19f20d060c", "content": "Consider a simple example of `ProxyFactoryBean` in action. This example involves:\n\n* A target bean that is proxied. This is the `personTarget` bean definition in\n the example.\n* An `Advisor` and an `Interceptor` used to provide advice.\n* An AOP proxy bean definition to specify the target object (the `personTarget` bean),\n the interfaces to proxy, and the advice to apply.\n\nThe following listing shows the example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"personTarget\" class=\"com.mycompany.PersonImpl\">\n <property name=\"name\" value=\"Tony\"/>\n <property name=\"age\" value=\"51\"/>\n\t</bean>\n\n\t<bean id=\"myAdvisor\" class=\"com.mycompany.MyAdvisor\">\n <property name=\"someProperty\" value=\"Custom string property value\"/>\n\t</bean>\n\n\t<bean id=\"debugInterceptor\" class=\"org.springframework.aop.interceptor.DebugInterceptor\">\n\t</bean>\n\n\t<bean id=\"person\"\n class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n <property name=\"proxyInterfaces\" value=\"com.mycompany.Person\"/>\n\n <property name=\"target\" ref=\"personTarget\"/>\n <property name=\"interceptorNames\">\n <list>\n <value>myAdvisor</value>\n <value>debugInterceptor</value>\n </list>\n </property>\n\t</bean>\n----\n\nNote that the `interceptorNames` property takes a list of `String`, which holds the bean names of the\ninterceptors or advisors in the current factory. You can use advisors, interceptors, before, after\nreturning, and throws advice objects. The ordering of advisors is significant.\n\nNOTE: You might be wondering why the list does not hold bean references. The reason for this is\nthat, if the singleton property of the `ProxyFactoryBean` is set to `false`, it must be able to\nreturn independent proxy instances. If any of the advisors is itself a prototype, an\nindependent instance would need to be returned, so it is necessary to be able to obtain\nan instance of the prototype from the factory. Holding a reference is not sufficient.\n\nThe `person` bean definition shown earlier can be used in place of a `Person` implementation, as\nfollows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tPerson person = (Person) factory.getBean(\"person\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval person = factory.getBean(\"person\") as Person\n----\n======\n\nOther beans in the same IoC context can express a strongly typed dependency on it, as\nwith an ordinary Java object. The following example shows how to do so:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"personUser\" class=\"com.mycompany.PersonUser\">\n <property name=\"person\"><ref bean=\"person\"/></property>\n\t</bean>\n----\n\nThe `PersonUser` class in this example exposes a property of type `Person`. As far as\nit is concerned, the AOP proxy can be used transparently in place of a \"`real`\" person\nimplementation. However, its class would be a dynamic proxy class. It would be possible\nto cast it to the `Advised` interface (discussed later).\n\nYou can conceal the distinction between target and proxy by using an anonymous\ninner bean. Only the `ProxyFactoryBean` definition is different. The\nadvice is included only for completeness. The following example shows how to use an\nanonymous inner bean:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"myAdvisor\" class=\"com.mycompany.MyAdvisor\">\n <property name=\"someProperty\" value=\"Custom string property value\"/>\n\t</bean>\n\n\t<bean id=\"debugInterceptor\" class=\"org.springframework.aop.interceptor.DebugInterceptor\"/>\n\n\t<bean id=\"person\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n <property name=\"proxyInterfaces\" value=\"com.mycompany.Person\"/>\n <!-- Use inner bean, not local reference to target -->\n <property name=\"target\">\n <bean class=\"com.mycompany.PersonImpl\">\n <property name=\"name\" value=\"Tony\"/>\n <property name=\"age\" value=\"51\"/>\n </bean>\n </property>\n <property name=\"interceptorNames\">\n <list>\n <value>myAdvisor</value>\n <value>debugInterceptor</value>\n </list>\n </property>\n\t</bean>\n----\n\nUsing an anonymous inner bean has the advantage that there is only one object of type `Person`. This is useful if we want\nto prevent users of the application context from obtaining a reference to the un-advised\nobject or need to avoid any ambiguity with Spring IoC autowiring. There is also,\narguably, an advantage in that the `ProxyFactoryBean` definition is self-contained.\nHowever, there are times when being able to obtain the un-advised target from the\nfactory might actually be an advantage (for example, in certain test scenarios).\n\n[[aop-api-proxying-class]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc", "title": "pfb", "heading": "Proxying Interfaces", "heading_level": 2, "file_order": 24, "section_index": 4, "content_hash": "1f1f0bac99a415c995595d88966a11efe6490ad2c7ae8763ee285c19f20d060c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc"}}
{"id": "sha256:2be6a0116b2c219341f607894a9d1e7f3851a7a385a84e90c9fc2a24d91ee2b7", "content": "What if you need to proxy a class, rather than one or more interfaces?\n\nImagine that in our earlier example, there was no `Person` interface. We needed to advise\na class called `Person` that did not implement any business interface. In this case, you\ncan configure Spring to use CGLIB proxying rather than dynamic proxies. To do so, set the\n`proxyTargetClass` property on the `ProxyFactoryBean` shown earlier to `true`. While it is best to\nprogram to interfaces rather than classes, the ability to advise classes that do not\nimplement interfaces can be useful when working with legacy code. (In general, Spring\nis not prescriptive. While it makes it easy to apply good practices, it avoids forcing a\nparticular approach.)\n\nIf you want to, you can force the use of CGLIB in any case, even if you do have\ninterfaces.\n\nCGLIB proxying works by generating a subclass of the target class at runtime. Spring\nconfigures this generated subclass to delegate method calls to the original target. The\nsubclass is used to implement the Decorator pattern, weaving in the advice.\n\nCGLIB proxying should generally be transparent to users. However, there are some issues\nto consider:\n\n* `final` classes cannot be proxied, because they cannot be extended.\n* `final` methods cannot be advised, because they cannot be overridden.\n* `private` methods cannot be advised, because they cannot be overridden.\n* Methods that are not visible, typically package private methods in a parent class\nfrom a different package, cannot be advised because they are effectively private.\n\nNOTE: There is no need to add CGLIB to your classpath. CGLIB is repackaged and included\nin the `spring-core` JAR. In other words, CGLIB-based AOP works \"out of the box\", as do\nJDK dynamic proxies.\n\nThere is little performance difference between CGLIB proxies and dynamic proxies.\nPerformance should not be a decisive consideration in this case.\n\n[[aop-global-advisors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc", "title": "pfb", "heading": "Proxying Classes", "heading_level": 2, "file_order": 24, "section_index": 5, "content_hash": "2be6a0116b2c219341f607894a9d1e7f3851a7a385a84e90c9fc2a24d91ee2b7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc"}}
{"id": "sha256:80f7a83f037e55d023e08618ecd424997393558d328bb7889c3069695dfed4f5", "content": "By appending an asterisk to an interceptor name, all advisors with bean names that match\nthe part before the asterisk are added to the advisor chain. This can come in handy\nif you need to add a standard set of \"`global`\" advisors. The following example defines\ntwo global advisors:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"proxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n <property name=\"target\" ref=\"service\"/>\n <property name=\"interceptorNames\">\n <list>\n <value>global*</value>\n </list>\n </property>\n\t</bean>\n\n\t<bean id=\"global_debug\" class=\"org.springframework.aop.interceptor.DebugInterceptor\"/>\n\t<bean id=\"global_performance\" class=\"org.springframework.aop.interceptor.PerformanceMonitorInterceptor\"/>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc", "title": "pfb", "heading": "Using \"`Global`\" Advisors", "heading_level": 2, "file_order": 24, "section_index": 6, "content_hash": "80f7a83f037e55d023e08618ecd424997393558d328bb7889c3069695dfed4f5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pfb.adoc"}}
{"id": "sha256:d77acf4fcab840c046a86707f2dd09a095158dc4f399b6468b4eeda2fabed125", "content": "[[aop-api-pointcuts]]\n\nThis section describes how Spring handles the crucial pointcut concept.\n\n[[aop-api-concepts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc", "title": "pointcuts", "heading": "pointcuts", "heading_level": 1, "file_order": 25, "section_index": 0, "content_hash": "d77acf4fcab840c046a86707f2dd09a095158dc4f399b6468b4eeda2fabed125", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc"}}
{"id": "sha256:f3d42c617305e4e5d18e3c6f31c6baf018c724a9b412d03d5f6179ab76742f23", "content": "Spring's pointcut model enables pointcut reuse independent of advice types. You can\ntarget different advice with the same pointcut.\n\nThe `org.springframework.aop.Pointcut` interface is the central interface, used to\ntarget advice to particular classes and methods. The complete interface follows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface Pointcut {\n\n ClassFilter getClassFilter();\n\n MethodMatcher getMethodMatcher();\n\t}\n----\n\nSplitting the `Pointcut` interface into two parts allows reuse of class and method\nmatching parts and fine-grained composition operations (such as performing a \"`union`\"\nwith another method matcher).\n\nThe `ClassFilter` interface is used to restrict the pointcut to a given set of target\nclasses. If the `matches()` method always returns true, all target classes are\nmatched. The following listing shows the `ClassFilter` interface definition:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface ClassFilter {\n\n boolean matches(Class clazz);\n\t}\n----\n\nThe `MethodMatcher` interface is normally more important. The complete interface follows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface MethodMatcher {\n\n boolean matches(Method m, Class<?> targetClass);\n\n boolean isRuntime();\n\n boolean matches(Method m, Class<?> targetClass, Object... args);\n\t}\n----\n\nThe `matches(Method, Class)` method is used to test whether this pointcut ever\nmatches a given method on a target class. This evaluation can be performed when an AOP\nproxy is created to avoid the need for a test on every method invocation. If the\ntwo-argument `matches` method returns `true` for a given method, and the `isRuntime()`\nmethod for the MethodMatcher returns `true`, the three-argument matches method is\ninvoked on every method invocation. This lets a pointcut look at the arguments passed\nto the method invocation immediately before the target advice starts.\n\nMost `MethodMatcher` implementations are static, meaning that their `isRuntime()` method\nreturns `false`. In this case, the three-argument `matches` method is never invoked.\n\nTIP: If possible, try to make pointcuts static, allowing the AOP framework to cache the\nresults of pointcut evaluation when an AOP proxy is created.\n\n[[aop-api-pointcut-ops]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc", "title": "pointcuts", "heading": "Concepts", "heading_level": 2, "file_order": 25, "section_index": 1, "content_hash": "f3d42c617305e4e5d18e3c6f31c6baf018c724a9b412d03d5f6179ab76742f23", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc"}}
{"id": "sha256:3082437ddfbf541f653a63862bb55a1e44fd8fff13aaf9a2936a229a49b16913", "content": "Spring supports operations (notably, union and intersection) on pointcuts.\n\nUnion means the methods that either pointcut matches.\nIntersection means the methods that both pointcuts match.\nUnion is usually more useful.\nYou can compose pointcuts by using the static methods in the\n`org.springframework.aop.support.Pointcuts` class or by using the\n`ComposablePointcut` class in the same package. However, using AspectJ pointcut\nexpressions is usually a simpler approach.\n\n[[aop-api-pointcuts-aspectj]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc", "title": "pointcuts", "heading": "Operations on Pointcuts", "heading_level": 2, "file_order": 25, "section_index": 2, "content_hash": "3082437ddfbf541f653a63862bb55a1e44fd8fff13aaf9a2936a229a49b16913", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc"}}
{"id": "sha256:e29e47733c4a51c0d9098a4e15e92ee6c0be4ed6aa6525b6a87d034504ea83e1", "content": "Since 2.0, the most important type of pointcut used by Spring is\n`org.springframework.aop.aspectj.AspectJExpressionPointcut`. This is a pointcut that\nuses an AspectJ-supplied library to parse an AspectJ pointcut expression string.\n\nSee the xref:core/aop.adoc[previous chapter] for a discussion of supported AspectJ pointcut primitives.\n\n[[aop-api-pointcuts-impls]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc", "title": "pointcuts", "heading": "AspectJ Expression Pointcuts", "heading_level": 2, "file_order": 25, "section_index": 3, "content_hash": "e29e47733c4a51c0d9098a4e15e92ee6c0be4ed6aa6525b6a87d034504ea83e1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc"}}
{"id": "sha256:5a5ccf51503f36087a86661dd11a5dea747b6b8d7220cf466f9b9e501ce361d7", "content": "Spring provides several convenient pointcut implementations. You can use some of them\ndirectly; others are intended to be subclassed in application-specific pointcuts.\n\n[[aop-api-pointcuts-static]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc", "title": "pointcuts", "heading": "Convenience Pointcut Implementations", "heading_level": 2, "file_order": 25, "section_index": 4, "content_hash": "5a5ccf51503f36087a86661dd11a5dea747b6b8d7220cf466f9b9e501ce361d7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc"}}
{"id": "sha256:fed8faebab5bbb64d8ac2f59dcb0a1aa92f48b4985c286e38a307c375abdc3da", "content": "Static pointcuts are based on the method and the target class and cannot take into account\nthe method's arguments. Static pointcuts suffice -- and are best -- for most usages.\nSpring can evaluate a static pointcut only once, when a method is first invoked.\nAfter that, there is no need to evaluate the pointcut again with each method invocation.\n\nThe rest of this section describes some of the static pointcut implementations that are\nincluded with Spring.\n\n[[aop-api-pointcuts-regex]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc", "title": "pointcuts", "heading": "Static Pointcuts", "heading_level": 3, "file_order": 25, "section_index": 5, "content_hash": "fed8faebab5bbb64d8ac2f59dcb0a1aa92f48b4985c286e38a307c375abdc3da", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc"}}
{"id": "sha256:e6b61bfc29786db56154d38136fcc4218a03a38c5092f7532c133ffcc0e4612e", "content": "One obvious way to specify static pointcuts is regular expressions. Several AOP\nframeworks besides Spring make this possible.\n`org.springframework.aop.support.JdkRegexpMethodPointcut` is a generic regular\nexpression pointcut that uses the regular expression support in the JDK.\n\nWith the `JdkRegexpMethodPointcut` class, you can provide a list of pattern strings.\nIf any of these is a match, the pointcut evaluates to `true`. (As a consequence,\nthe resulting pointcut is effectively the union of the specified patterns.)\n\nThe following example shows how to use `JdkRegexpMethodPointcut`:\n\ninclude-code::./JdkRegexpConfiguration[tag=snippet,indent=0]\n\nSpring provides a convenience class named `RegexpMethodPointcutAdvisor`, which lets us\nalso reference an `Advice` (remember that an `Advice` can be an interceptor, before advice,\nthrows advice, and others). Behind the scenes, Spring uses a `JdkRegexpMethodPointcut`.\nUsing `RegexpMethodPointcutAdvisor` simplifies wiring, as the one bean encapsulates both\npointcut and advice, as the following example shows:\n\ninclude-code::./RegexpConfiguration[tag=snippet,indent=0]\n\nYou can use `RegexpMethodPointcutAdvisor` with any `Advice` type.\n\n[[aop-api-pointcuts-attribute-driven]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc", "title": "pointcuts", "heading": "Regular Expression Pointcuts", "heading_level": 4, "file_order": 25, "section_index": 6, "content_hash": "e6b61bfc29786db56154d38136fcc4218a03a38c5092f7532c133ffcc0e4612e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc"}}
{"id": "sha256:1d55acb14809835fef59515847ea318a199769c6cd92fcc8ca724fdd3d1f7c87", "content": "An important type of static pointcut is a metadata-driven pointcut. This uses the\nvalues of metadata attributes (typically, source-level metadata).\n\n[[aop-api-pointcuts-dynamic]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc", "title": "pointcuts", "heading": "Attribute-driven Pointcuts", "heading_level": 4, "file_order": 25, "section_index": 7, "content_hash": "1d55acb14809835fef59515847ea318a199769c6cd92fcc8ca724fdd3d1f7c87", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc"}}
{"id": "sha256:9cae7c1dfa00193bb7bf4d90d3c813ed4b248306823b6bec48f79dab04224482", "content": "Dynamic pointcuts are costlier to evaluate than static pointcuts. They take into account\nmethod arguments as well as static information. This means that they must be\nevaluated with every method invocation and that the result cannot be cached, as arguments will\nvary.\n\nThe main example is the `control flow` pointcut.\n\n[[aop-api-pointcuts-cflow]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc", "title": "pointcuts", "heading": "Dynamic pointcuts", "heading_level": 3, "file_order": 25, "section_index": 8, "content_hash": "9cae7c1dfa00193bb7bf4d90d3c813ed4b248306823b6bec48f79dab04224482", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc"}}
{"id": "sha256:c873e65b0f1155d30b0c534f6fef3c4da62738c3c3a21aab59ccd5dbed2167d9", "content": "Spring control flow pointcuts are conceptually similar to AspectJ `cflow` pointcuts,\nalthough less powerful. (There is currently no way to specify that a pointcut runs\nbelow a join point matched by another pointcut.) A control flow pointcut matches the\ncurrent call stack. For example, it might fire if the join point was invoked by a method\nin the `com.mycompany.web` package or by the `SomeCaller` class. Control flow pointcuts\nare specified by using the `org.springframework.aop.support.ControlFlowPointcut` class.\n\nNOTE: Control flow pointcuts are significantly more expensive to evaluate at runtime than even\nother dynamic pointcuts. In Java 1.4, the cost is about five times that of other dynamic\npointcuts.\n\n[[aop-api-pointcuts-superclasses]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc", "title": "pointcuts", "heading": "Control Flow Pointcuts", "heading_level": 4, "file_order": 25, "section_index": 9, "content_hash": "c873e65b0f1155d30b0c534f6fef3c4da62738c3c3a21aab59ccd5dbed2167d9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc"}}
{"id": "sha256:9fd05ae437b7928df2f76e45e217b2569c7c4f5b33186ac9f167f9c1e532507d", "content": "Spring provides useful pointcut superclasses to help you to implement your own pointcuts.\n\nBecause static pointcuts are most useful, you should probably subclass\n`StaticMethodMatcherPointcut`. This requires implementing only one\nabstract method (although you can override other methods to customize behavior). The\nfollowing example shows how to subclass `StaticMethodMatcherPointcut`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass TestStaticPointcut extends StaticMethodMatcherPointcut {\n\n public boolean matches(Method m, Class targetClass) {\n // return true if custom criteria match\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass TestStaticPointcut : StaticMethodMatcherPointcut() {\n\n override fun matches(method: Method, targetClass: Class<*>): Boolean {\n // return true if custom criteria match\n }\n\t}\n----\n======\n\nThere are also superclasses for dynamic pointcuts.\nYou can use custom pointcuts with any advice type.\n\n[[aop-api-pointcuts-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc", "title": "pointcuts", "heading": "Pointcut Superclasses", "heading_level": 2, "file_order": 25, "section_index": 10, "content_hash": "9fd05ae437b7928df2f76e45e217b2569c7c4f5b33186ac9f167f9c1e532507d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc"}}
{"id": "sha256:59525562d0c4095ad51a01856154ea41440ba5fa45303f005b4ed6da01d40b65", "content": "Because pointcuts in Spring AOP are Java classes rather than language features (as in\nAspectJ), you can declare custom pointcuts, whether static or dynamic. Custom\npointcuts in Spring can be arbitrarily complex. However, we recommend using the AspectJ pointcut\nexpression language, if you can.\n\nNOTE: Later versions of Spring may offer support for \"`semantic pointcuts`\" as offered by JAC --\nfor example, \"`all methods that change instance variables in the target object.`\"", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc", "title": "pointcuts", "heading": "Custom Pointcuts", "heading_level": 2, "file_order": 25, "section_index": 11, "content_hash": "59525562d0c4095ad51a01856154ea41440ba5fa45303f005b4ed6da01d40b65", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/pointcuts.adoc"}}
{"id": "sha256:f713eb19a413b76e042fe81aaefecc6051ba6c341bf42fe2d89e79db95a94417", "content": "[[aop-prog]]\n\nIt is easy to create AOP proxies programmatically with Spring. This lets you use\nSpring AOP without dependency on Spring IoC.\n\nThe interfaces implemented by the target object are\nautomatically proxied. The following listing shows creation of a proxy for a target object, with one\ninterceptor and one advisor:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);\n\tfactory.addAdvice(myMethodInterceptor);\n\tfactory.addAdvisor(myAdvisor);\n\tMyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval factory = ProxyFactory(myBusinessInterfaceImpl)\n\tfactory.addAdvice(myMethodInterceptor)\n\tfactory.addAdvisor(myAdvisor)\n\tval tb = factory.proxy as MyBusinessInterface\n----\n======\n\nThe first step is to construct an object of type\n`org.springframework.aop.framework.ProxyFactory`. You can create this with a target\nobject, as in the preceding example, or specify the interfaces to be proxied in an alternate\nconstructor.\n\nYou can add advice (with interceptors as a specialized kind of advice), advisors, or both\nand manipulate them for the life of the `ProxyFactory`. If you add an\n`IntroductionInterceptionAroundAdvisor`, you can cause the proxy to implement additional\ninterfaces.\n\nThere are also convenience methods on `ProxyFactory` (inherited from `AdvisedSupport`)\nthat let you add other advice types, such as before and throws advice.\n`AdvisedSupport` is the superclass of both `ProxyFactory` and `ProxyFactoryBean`.\n\nTIP: Integrating AOP proxy creation with the IoC framework is best practice in most\napplications. We recommend that you externalize configuration from Java code with AOP,\nas you should in general.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/prog.adoc", "title": "prog", "heading": "prog", "heading_level": 1, "file_order": 26, "section_index": 0, "content_hash": "f713eb19a413b76e042fe81aaefecc6051ba6c341bf42fe2d89e79db95a94417", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/prog.adoc"}}
{"id": "sha256:f8e7e96902990187ceff9962a295b1026abf54a1eee077e3fa0f6c68a95f7fb1", "content": "[[aop-targetsource]]\n\nSpring offers the concept of a `TargetSource`, expressed in the\n`org.springframework.aop.TargetSource` interface. This interface is responsible for\nreturning the \"`target object`\" that implements the join point. The `TargetSource`\nimplementation is asked for a target instance each time the AOP proxy handles a method\ninvocation.\n\nDevelopers who use Spring AOP do not normally need to work directly with `TargetSource` implementations, but\nthis provides a powerful means of supporting pooling, hot swappable, and other\nsophisticated targets. For example, a pooling `TargetSource` can return a different target\ninstance for each invocation, by using a pool to manage instances.\n\nIf you do not specify a `TargetSource`, a default implementation is used to wrap a\nlocal object. The same target is returned for each invocation (as you would expect).\n\nThe rest of this section describes the standard target sources provided with Spring and how you can use them.\n\nTIP: When using a custom target source, your target will usually need to be a prototype\nrather than a singleton bean definition. This allows Spring to create a new target\ninstance when required.\n\n[[aop-ts-swap]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/targetsource.adoc", "title": "targetsource", "heading": "targetsource", "heading_level": 1, "file_order": 27, "section_index": 0, "content_hash": "f8e7e96902990187ceff9962a295b1026abf54a1eee077e3fa0f6c68a95f7fb1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/targetsource.adoc"}}
{"id": "sha256:b2d800371fc841db7ab2aab39bbe521d0be939696206fe2fc10a40763d8fceb5", "content": "The `org.springframework.aop.target.HotSwappableTargetSource` exists to let the target\nof an AOP proxy be switched while letting callers keep their references to it.\n\nChanging the target source's target takes effect immediately. The\n`HotSwappableTargetSource` is thread-safe.\n\nYou can change the target by using the `swap()` method on HotSwappableTargetSource, as the follow example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHotSwappableTargetSource swapper = (HotSwappableTargetSource) beanFactory.getBean(\"swapper\");\n\tObject oldTarget = swapper.swap(newTarget);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval swapper = beanFactory.getBean(\"swapper\") as HotSwappableTargetSource\n\tval oldTarget = swapper.swap(newTarget)\n----\n======\n\nThe following example shows the required XML definitions:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"initialTarget\" class=\"mycompany.OldTarget\"/>\n\n\t<bean id=\"swapper\" class=\"org.springframework.aop.target.HotSwappableTargetSource\">\n <constructor-arg ref=\"initialTarget\"/>\n\t</bean>\n\n\t<bean id=\"swappable\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n <property name=\"targetSource\" ref=\"swapper\"/>\n\t</bean>\n----\n\nThe preceding `swap()` call changes the target of the swappable bean. Clients that hold a\nreference to that bean are unaware of the change but immediately start hitting\nthe new target.\n\nAlthough this example does not add any advice (it is not necessary to add advice to\nuse a `TargetSource`), any `TargetSource` can be used in conjunction with\narbitrary advice.\n\n[[aop-ts-pool]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/targetsource.adoc", "title": "targetsource", "heading": "Hot-swappable Target Sources", "heading_level": 2, "file_order": 27, "section_index": 1, "content_hash": "b2d800371fc841db7ab2aab39bbe521d0be939696206fe2fc10a40763d8fceb5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/targetsource.adoc"}}
{"id": "sha256:53f3bfedba8cdd3dc7f20c682a83a663afd99a3c41e7d462b77c06c59e32c138", "content": "Using a pooling target source provides a similar programming model to stateless session\nEJBs, in which a pool of identical instances is maintained, with method invocations\ngoing to free objects in the pool.\n\nA crucial difference between Spring pooling and SLSB pooling is that Spring pooling can\nbe applied to any POJO. As with Spring in general, this service can be applied in a\nnon-invasive way.\n\nSpring provides support for Commons Pool 2, which provides a\nfairly efficient pooling implementation. You need the `commons-pool` Jar on your\napplication's classpath to use this feature. You can also subclass\n`org.springframework.aop.target.AbstractPoolingTargetSource` to support any other\npooling API.\n\nThe following listing shows an example configuration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"businessObjectTarget\" class=\"com.mycompany.MyBusinessObject\"\n scope=\"prototype\">\n ... properties omitted\n\t</bean>\n\n\t<bean id=\"poolTargetSource\" class=\"org.springframework.aop.target.CommonsPool2TargetSource\">\n <property name=\"targetBeanName\" value=\"businessObjectTarget\"/>\n <property name=\"maxSize\" value=\"25\"/>\n\t</bean>\n\n\t<bean id=\"businessObject\" class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n <property name=\"targetSource\" ref=\"poolTargetSource\"/>\n <property name=\"interceptorNames\" value=\"myInterceptor\"/>\n\t</bean>\n----\n\nNote that the target object (`businessObjectTarget` in the preceding example) must be a\nprototype. This lets the `PoolingTargetSource` implementation create new instances\nof the target to grow the pool as necessary. See the {spring-framework-api}/aop/target/AbstractPoolingTargetSource.html[javadoc of\n`AbstractPoolingTargetSource`] and the concrete subclass you wish to use for information\nabout its properties. `maxSize` is the most basic and is always guaranteed to be present.\n\nIn this case, `myInterceptor` is the name of an interceptor that would need to be\ndefined in the same IoC context. However, you need not specify interceptors to\nuse pooling. If you want only pooling and no other advice, do not set the\n`interceptorNames` property at all.\n\nYou can configure Spring to be able to cast any pooled object to the\n`org.springframework.aop.target.PoolingConfig` interface, which exposes information\nabout the configuration and current size of the pool through an introduction. You\nneed to define an advisor similar to the following:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"poolConfigAdvisor\" class=\"org.springframework.beans.factory.config.MethodInvokingFactoryBean\">\n <property name=\"targetObject\" ref=\"poolTargetSource\"/>\n <property name=\"targetMethod\" value=\"getPoolingConfigMixin\"/>\n\t</bean>\n----\n\nThis advisor is obtained by calling a convenience method on the\n`AbstractPoolingTargetSource` class, hence the use of `MethodInvokingFactoryBean`. This\nadvisor's name (`poolConfigAdvisor`, here) must be in the list of interceptors names in\nthe `ProxyFactoryBean` that exposes the pooled object.\n\nThe cast is defined as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tPoolingConfig conf = (PoolingConfig) beanFactory.getBean(\"businessObject\");\n\tSystem.out.println(\"Max pool size is \" + conf.getMaxSize());\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval conf = beanFactory.getBean(\"businessObject\") as PoolingConfig\n\tprintln(\"Max pool size is \" + conf.maxSize)\n----\n======\n\nNOTE: Pooling stateless service objects is not usually necessary. We do not believe it should\nbe the default choice, as most stateless objects are naturally thread-safe, and instance\npooling is problematic if resources are cached.\n\nSimpler pooling is available by using auto-proxying. You can set the `TargetSource` implementations\nused by any auto-proxy creator.\n\n[[aop-ts-prototype]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/targetsource.adoc", "title": "targetsource", "heading": "Pooling Target Sources", "heading_level": 2, "file_order": 27, "section_index": 2, "content_hash": "53f3bfedba8cdd3dc7f20c682a83a663afd99a3c41e7d462b77c06c59e32c138", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/targetsource.adoc"}}
{"id": "sha256:50cb75e95c5c1225e7ca0ed8ad6ec1cc6ecc4c0cb434b9c54f198479406f6557", "content": "Setting up a \"`prototype`\" target source is similar to setting up a pooling `TargetSource`. In this\ncase, a new instance of the target is created on every method invocation. Although\nthe cost of creating a new object is not high in a modern JVM, the cost of wiring up the\nnew object (satisfying its IoC dependencies) may be more expensive. Thus, you should not\nuse this approach without very good reason.\n\nTo do this, you could modify the `poolTargetSource` definition shown earlier as follows\n(we also changed the name, for clarity):\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"prototypeTargetSource\" class=\"org.springframework.aop.target.PrototypeTargetSource\">\n <property name=\"targetBeanName\" ref=\"businessObjectTarget\"/>\n\t</bean>\n----\n\nThe only property is the name of the target bean. Inheritance is used in the\n`TargetSource` implementations to ensure consistent naming. As with the pooling target\nsource, the target bean must be a prototype bean definition.\n\n[[aop-ts-threadlocal]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/targetsource.adoc", "title": "targetsource", "heading": "Prototype Target Sources", "heading_level": 2, "file_order": 27, "section_index": 3, "content_hash": "50cb75e95c5c1225e7ca0ed8ad6ec1cc6ecc4c0cb434b9c54f198479406f6557", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/targetsource.adoc"}}
{"id": "sha256:14d1df5982815022ddff42a07b592bf1d700d10e504cdfa4677192bbd8329920", "content": "`ThreadLocal` target sources are useful if you need an object to be created for each\nincoming request (per thread that is). The concept of a `ThreadLocal` provides a JDK-wide\nfacility to transparently store a resource alongside a thread. Setting up a\n`ThreadLocalTargetSource` is pretty much the same as was explained for the other types\nof target source, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"threadlocalTargetSource\" class=\"org.springframework.aop.target.ThreadLocalTargetSource\">\n <property name=\"targetBeanName\" value=\"businessObjectTarget\"/>\n\t</bean>\n----\n\nNOTE: `ThreadLocal` instances come with serious issues (potentially resulting in memory leaks) when\nincorrectly using them in multi-threaded and multi-classloader environments. You\nshould always consider wrapping a `ThreadLocal` in some other class and never directly use\nthe `ThreadLocal` itself (except in the wrapper class). Also, you should\nalways remember to correctly set and unset (where the latter involves a call to\n`ThreadLocal.remove()`) the resource local to the thread. Unsetting should be done in\nany case, since not unsetting it might result in problematic behavior. Spring's\n`ThreadLocal` support does this for you and should always be considered in favor of using\n`ThreadLocal` instances without other proper handling code.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api/targetsource.adoc", "title": "targetsource", "heading": "`ThreadLocal` Target Sources", "heading_level": 2, "file_order": 27, "section_index": 4, "content_hash": "14d1df5982815022ddff42a07b592bf1d700d10e504cdfa4677192bbd8329920", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api/targetsource.adoc"}}
{"id": "sha256:062b3d0975daf2598ec06ee1aaabe6f4dbe2ba1707012f95f5e5a74bebc289f3", "content": "[[application-startup-steps]]\n\nThis part of the appendix lists the existing `StartupSteps` that the core container is instrumented with.\n\nWARNING: The name and detailed information about each startup step is not part of the public contract and\nis subject to change; this is considered as an implementation detail of the core container and will follow\nits behavior changes.\n\n.Application startup steps defined in the core container\n|===\n| Name| Description| Tags\n\n| `spring.beans.instantiate`\n| Instantiation of a bean and its dependencies.\n| `beanName` the name of the bean, `beanType` the type required at the injection point.\n\n| `spring.beans.smart-initialize`\n| Initialization of `SmartInitializingSingleton` beans.\n| `beanName` the name of the bean.\n\n| `spring.context.base-packages.scan`\n| Scanning of base packages.\n| `packages` array of base packages for scanning.\n\n| `spring.context.beans.post-process`\n| Beans post-processing phase.\n|\n\n| `spring.context.bean-factory.post-process`\n| Invocation of the `BeanFactoryPostProcessor` beans.\n| `postProcessor` the current post-processor.\n\n| `spring.context.beandef-registry.post-process`\n| Invocation of the `BeanDefinitionRegistryPostProcessor` beans.\n| `postProcessor` the current post-processor.\n\n| `spring.context.component-classes.register`\n| Registration of component classes through `AnnotationConfigApplicationContext#register`.\n| `classes` array of given classes for registration.\n\n| `spring.context.config-classes.enhance`\n| Enhancement of configuration classes with CGLIB proxies.\n| `classCount` count of enhanced classes.\n\n| `spring.context.config-classes.parse`\n| Configuration classes parsing phase with the `ConfigurationClassPostProcessor`.\n| `classCount` count of processed classes.\n\n| `spring.context.refresh`\n| Application context refresh phase.\n|\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/application-startup-steps.adoc", "title": "application-startup-steps", "heading": "application-startup-steps", "heading_level": 1, "file_order": 28, "section_index": 0, "content_hash": "062b3d0975daf2598ec06ee1aaabe6f4dbe2ba1707012f95f5e5a74bebc289f3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/application-startup-steps.adoc"}}
{"id": "sha256:a2e635cf3eb85b12353f8431a8eef432579bbcb90388db5ae5d189e8858b10b3", "content": "[[xml-custom]]\n\n[[xsd-custom-introduction]]\nSince version 2.0, Spring has featured a mechanism for adding schema-based extensions to the\nbasic Spring XML format for defining and configuring beans. This section covers\nhow to write your own custom XML bean definition parsers and\nintegrate such parsers into the Spring IoC container.\n\nTo facilitate authoring configuration files that use a schema-aware XML editor,\nSpring's extensible XML configuration mechanism is based on XML Schema. If you are not\nfamiliar with Spring's current XML configuration extensions that come with the standard\nSpring distribution, you should first read the previous section on xref:core/appendix/xsd-schemas.adoc[XML Schemas].\n\nTo create new XML configuration extensions:\n\n. xref:core/appendix/xml-custom.adoc#core.appendix.xsd-custom-schema[Author] an XML schema to describe your custom element(s).\n. xref:core/appendix/xml-custom.adoc#core.appendix.xsd-custom-namespacehandler[Code] a custom `NamespaceHandler` implementation.\n. xref:core/appendix/xml-custom.adoc#core.appendix.xsd-custom-parser[Code] one or more `BeanDefinitionParser` implementations\n (this is where the real work is done).\n. xref:core/appendix/xml-custom.adoc#core.appendix.xsd-custom-registration[Register] your new artifacts with Spring.\n\nFor a unified example, we create an\nXML extension (a custom XML element) that lets us configure objects of the type\n`SimpleDateFormat` (from the `java.text` package). When we are done,\nwe will be able to define bean definitions of type `SimpleDateFormat` as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<myns:dateformat id=\"dateFormat\"\n pattern=\"yyyy-MM-dd HH:mm\"\n lenient=\"true\"/>\n----\n\n(We include much more detailed\nexamples follow later in this appendix. The intent of this first simple example is to walk you\nthrough the basic steps of making a custom extension.)\n\n[[xsd-custom-schema]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc", "title": "xml-custom", "heading": "xml-custom", "heading_level": 1, "file_order": 29, "section_index": 0, "content_hash": "a2e635cf3eb85b12353f8431a8eef432579bbcb90388db5ae5d189e8858b10b3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc"}}
{"id": "sha256:1533f97f9aa210d598f99a3973a5686bf520a30c27973523a2358930c34b34e6", "content": "Creating an XML configuration extension for use with Spring's IoC container starts with\nauthoring an XML Schema to describe the extension. For our example, we use the following schema\nto configure `SimpleDateFormat` objects:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- myns.xsd (inside package org/springframework/samples/xml) -->\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<xsd:schema xmlns=\"http://www.mycompany.example/schema/myns\"\n xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n xmlns:beans=\"http://www.springframework.org/schema/beans\"\n targetNamespace=\"http://www.mycompany.example/schema/myns\"\n elementFormDefault=\"qualified\"\n attributeFormDefault=\"unqualified\">\n\n <xsd:import namespace=\"http://www.springframework.org/schema/beans\"/>\n\n <xsd:element name=\"dateformat\">\n <xsd:complexType>\n <xsd:complexContent>\n <xsd:extension base=\"beans:identifiedType\"> <1>\n <xsd:attribute name=\"lenient\" type=\"xsd:boolean\"/>\n <xsd:attribute name=\"pattern\" type=\"xsd:string\" use=\"required\"/>\n </xsd:extension>\n </xsd:complexContent>\n </xsd:complexType>\n </xsd:element>\n\t</xsd:schema>\n----\n<1> The indicated line contains an extension base for all identifiable tags\n(meaning they have an `id` attribute that we can use as the bean identifier in the\ncontainer). We can use this attribute because we imported the Spring-provided\n`beans` namespace.\n\nThe preceding schema lets us configure `SimpleDateFormat` objects directly in an\nXML application context file by using the `<myns:dateformat/>` element, as the following\nexample shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<myns:dateformat id=\"dateFormat\"\n pattern=\"yyyy-MM-dd HH:mm\"\n lenient=\"true\"/>\n----\n\nNote that, after we have created the infrastructure classes, the preceding snippet of XML is\nessentially the same as the following XML snippet:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"dateFormat\" class=\"java.text.SimpleDateFormat\">\n <constructor-arg value=\"yyyy-MM-dd HH:mm\"/>\n <property name=\"lenient\" value=\"true\"/>\n\t</bean>\n----\n\nThe second of the two preceding snippets\ncreates a bean in the container (identified by the name `dateFormat` of type\n`SimpleDateFormat`) with a couple of properties set.\n\nNOTE: The schema-based approach to creating configuration format allows for tight integration\nwith an IDE that has a schema-aware XML editor. By using a properly authored schema, you\ncan use autocompletion to let a user choose between several configuration options\ndefined in the enumeration.\n\n[[xsd-custom-namespacehandler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc", "title": "xml-custom", "heading": "Authoring the Schema", "heading_level": 2, "file_order": 29, "section_index": 1, "content_hash": "1533f97f9aa210d598f99a3973a5686bf520a30c27973523a2358930c34b34e6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc"}}
{"id": "sha256:88150741ff37bbe55a883907d72058a5dba29a7138659f7a6b7ebab8e639ca77", "content": "In addition to the schema, we need a `NamespaceHandler` to parse all elements of\nthis specific namespace that Spring encounters while parsing configuration files. For this example, the\n`NamespaceHandler` should take care of the parsing of the `myns:dateformat`\nelement.\n\nThe `NamespaceHandler` interface features three methods:\n\n* `init()`: Allows for initialization of the `NamespaceHandler` and is called by\n Spring before the handler is used.\n* `BeanDefinition parse(Element, ParserContext)`: Called when Spring encounters a\n top-level element (not nested inside a bean definition or a different namespace).\n This method can itself register bean definitions, return a bean definition, or both.\n* `BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext)`: Called\n when Spring encounters an attribute or nested element of a different namespace.\n The decoration of one or more bean definitions is used (for example) with the\n xref:core/beans/factory-scopes.adoc[scopes that Spring supports].\n We start by highlighting a simple example, without using decoration, after which\n we show decoration in a somewhat more advanced example.\n\nAlthough you can code your own `NamespaceHandler` for the entire\nnamespace (and hence provide code that parses each and every element in the namespace),\nit is often the case that each top-level XML element in a Spring XML configuration file\nresults in a single bean definition (as in our case, where a single `<myns:dateformat/>`\nelement results in a single `SimpleDateFormat` bean definition). Spring features a\nnumber of convenience classes that support this scenario. In the following example, we\nuse the `NamespaceHandlerSupport` class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.samples.xml;\n\n\timport org.springframework.beans.factory.xml.NamespaceHandlerSupport;\n\n\tpublic class MyNamespaceHandler extends NamespaceHandlerSupport {\n\n public void init() {\n registerBeanDefinitionParser(\"dateformat\", new SimpleDateFormatBeanDefinitionParser());\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.samples.xml\n\n\timport org.springframework.beans.factory.xml.NamespaceHandlerSupport\n\n\tclass MyNamespaceHandler : NamespaceHandlerSupport {\n\n override fun init() {\n registerBeanDefinitionParser(\"dateformat\", SimpleDateFormatBeanDefinitionParser())\n }\n\t}\n----\n======\n\nYou may notice that there is not actually a whole lot of parsing logic\nin this class. Indeed, the `NamespaceHandlerSupport` class has a built-in notion of\ndelegation. It supports the registration of any number of `BeanDefinitionParser`\ninstances, to which it delegates to when it needs to parse an element in its\nnamespace. This clean separation of concerns lets a `NamespaceHandler` handle the\norchestration of the parsing of all of the custom elements in its namespace while\ndelegating to `BeanDefinitionParsers` to do the grunt work of the XML parsing. This\nmeans that each `BeanDefinitionParser` contains only the logic for parsing a single\ncustom element, as we can see in the next step.\n\n[[xsd-custom-parser]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc", "title": "xml-custom", "heading": "Coding a `NamespaceHandler`", "heading_level": 2, "file_order": 29, "section_index": 2, "content_hash": "88150741ff37bbe55a883907d72058a5dba29a7138659f7a6b7ebab8e639ca77", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc"}}
{"id": "sha256:08346bf1c4134d9bb5b3f2ef585adb8ad4a8e78d0d9cab4aa1a8e39a64467963", "content": "A `BeanDefinitionParser` is used if the `NamespaceHandler` encounters an XML\nelement of the type that has been mapped to the specific bean definition parser\n(`dateformat` in this case). In other words, the `BeanDefinitionParser` is\nresponsible for parsing one distinct top-level XML element defined in the schema. In\nthe parser, we' have access to the XML element (and thus to its subelements, too) so that\nwe can parse our custom XML content, as you can see in the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.samples.xml;\n\n\timport org.springframework.beans.factory.support.BeanDefinitionBuilder;\n\timport org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;\n\timport org.springframework.util.StringUtils;\n\timport org.w3c.dom.Element;\n\n\timport java.text.SimpleDateFormat;\n\n\tpublic class SimpleDateFormatBeanDefinitionParser extends AbstractSingleBeanDefinitionParser { // <1>\n\n protected Class getBeanClass(Element element) {\n return SimpleDateFormat.class; // <2>\n }\n\n protected void doParse(Element element, BeanDefinitionBuilder bean) {\n // this will never be null since the schema explicitly requires that a value be supplied\n String pattern = element.getAttribute(\"pattern\");\n bean.addConstructorArgValue(pattern);\n\n // this however is an optional property\n String lenient = element.getAttribute(\"lenient\");\n if (StringUtils.hasText(lenient)) {\n bean.addPropertyValue(\"lenient\", Boolean.valueOf(lenient));\n }\n }\n\n\t}\n----\n<1> We use the Spring-provided `AbstractSingleBeanDefinitionParser` to handle a lot of\nthe basic grunt work of creating a single `BeanDefinition`.\n<2> We supply the `AbstractSingleBeanDefinitionParser` superclass with the type that our\nsingle `BeanDefinition` represents.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.samples.xml\n\n\timport org.springframework.beans.factory.support.BeanDefinitionBuilder\n\timport org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser\n\timport org.springframework.util.StringUtils\n\timport org.w3c.dom.Element\n\n\timport java.text.SimpleDateFormat\n\n\tclass SimpleDateFormatBeanDefinitionParser : AbstractSingleBeanDefinitionParser() { // <1>\n\n override fun getBeanClass(element: Element): Class<*>? { // <2>\n return SimpleDateFormat::class.java\n }\n\n override fun doParse(element: Element, bean: BeanDefinitionBuilder) {\n // this will never be null since the schema explicitly requires that a value be supplied\n val pattern = element.getAttribute(\"pattern\")\n bean.addConstructorArgValue(pattern)\n\n // this however is an optional property\n val lenient = element.getAttribute(\"lenient\")\n if (StringUtils.hasText(lenient)) {\n bean.addPropertyValue(\"lenient\", java.lang.Boolean.valueOf(lenient))\n }\n }\n\t}\n----\n<1> We use the Spring-provided `AbstractSingleBeanDefinitionParser` to handle a lot of\nthe basic grunt work of creating a single `BeanDefinition`.\n<2> We supply the `AbstractSingleBeanDefinitionParser` superclass with the type that our\nsingle `BeanDefinition` represents.\n======\n\nIn this simple case, this is all that we need to do. The creation of our single\n`BeanDefinition` is handled by the `AbstractSingleBeanDefinitionParser` superclass, as\nis the extraction and setting of the bean definition's unique identifier.\n\n[[xsd-custom-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc", "title": "xml-custom", "heading": "Using `BeanDefinitionParser`", "heading_level": 2, "file_order": 29, "section_index": 3, "content_hash": "08346bf1c4134d9bb5b3f2ef585adb8ad4a8e78d0d9cab4aa1a8e39a64467963", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc"}}
{"id": "sha256:dc4b208c64aa3e8bc3e39e44ced3afccdf8e434ba6bdb951dcf9f98804e6118b", "content": "The coding is finished. All that remains to be done is to make the Spring XML\nparsing infrastructure aware of our custom element. We do so by registering our custom\n`namespaceHandler` and custom XSD file in two special-purpose properties files. These\nproperties files are both placed in a `META-INF` directory in your application and\ncan, for example, be distributed alongside your binary classes in a JAR file. The Spring\nXML parsing infrastructure automatically picks up your new extension by consuming\nthese special properties files, the formats of which are detailed in the next two sections.\n\n[[xsd-custom-registration-spring-handlers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc", "title": "xml-custom", "heading": "Registering the Handler and the Schema", "heading_level": 2, "file_order": 29, "section_index": 4, "content_hash": "dc4b208c64aa3e8bc3e39e44ced3afccdf8e434ba6bdb951dcf9f98804e6118b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc"}}
{"id": "sha256:2b47e355d82a89be4289199a2522e9c0e25ac295815cf95f3628d714f567945d", "content": "The properties file called `spring.handlers` contains a mapping of XML Schema URIs to\nnamespace handler classes. For our example, we need to write the following:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nhttp\\://www.mycompany.example/schema/myns=org.springframework.samples.xml.MyNamespaceHandler\n----\n\n(The `:` character is a valid delimiter in the Java properties format, so\n`:` character in the URI needs to be escaped with a backslash.)\n\nThe first part (the key) of the key-value pair is the URI associated with your custom\nnamespace extension and needs to exactly match exactly the value of the `targetNamespace`\nattribute, as specified in your custom XSD schema.\n\n[[xsd-custom-registration-spring-schemas]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc", "title": "xml-custom", "heading": "Writing `META-INF/spring.handlers`", "heading_level": 3, "file_order": 29, "section_index": 5, "content_hash": "2b47e355d82a89be4289199a2522e9c0e25ac295815cf95f3628d714f567945d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc"}}
{"id": "sha256:b8a51526c29997ff95d8c73fbb3f39e09b5ae9f516073a30ed2d5a9a6e6dbfaf", "content": "The properties file called `spring.schemas` contains a mapping of XML Schema locations\n(referred to, along with the schema declaration, in XML files that use the schema as part\nof the `xsi:schemaLocation` attribute) to classpath resources. This file is needed\nto prevent Spring from absolutely having to use a default `EntityResolver` that requires\nInternet access to retrieve the schema file. If you specify the mapping in this\nproperties file, Spring searches for the schema (in this case,\n`myns.xsd` in the `org.springframework.samples.xml` package) on the classpath.\nThe following snippet shows the line we need to add for our custom schema:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nhttp\\://www.mycompany.example/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd\n----\n\n(Remember that the `:` character must be escaped.)\n\nYou are encouraged to deploy your XSD file (or files) right alongside\nthe `NamespaceHandler` and `BeanDefinitionParser` classes on the classpath.\n\n[[xsd-custom-using]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc", "title": "xml-custom", "heading": "Writing 'META-INF/spring.schemas'", "heading_level": 3, "file_order": 29, "section_index": 6, "content_hash": "b8a51526c29997ff95d8c73fbb3f39e09b5ae9f516073a30ed2d5a9a6e6dbfaf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc"}}
{"id": "sha256:6a7ea8ea18883151f2d11bf06f4532331cc55e510ec33f87bd948978dba7a853", "content": "Using a custom extension that you yourself have implemented is no different from using\none of the \"`custom`\" extensions that Spring provides. The following\nexample uses the custom `<dateformat/>` element developed in the previous steps\nin a Spring XML configuration file:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:myns=\"http://www.mycompany.example/schema/myns\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.mycompany.example/schema/myns http://www.mycompany.com/schema/myns/myns.xsd\">\n\n <!-- as a top-level bean -->\n <myns:dateformat id=\"defaultDateFormat\" pattern=\"yyyy-MM-dd HH:mm\" lenient=\"true\"/> <1>\n\n <bean id=\"jobDetailTemplate\" abstract=\"true\">\n <property name=\"dateFormat\">\n <!-- as an inner bean -->\n <myns:dateformat pattern=\"HH:mm MM-dd-yyyy\"/>\n </property>\n </bean>\n\n\t</beans>\n----\n<1> Our custom bean.\n\n[[xsd-custom-meat]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc", "title": "xml-custom", "heading": "Using a Custom Extension in Your Spring XML Configuration", "heading_level": 2, "file_order": 29, "section_index": 7, "content_hash": "6a7ea8ea18883151f2d11bf06f4532331cc55e510ec33f87bd948978dba7a853", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc"}}
{"id": "sha256:b5f927604b0d455586765c54cee2c35ea2f06de729a3fa188a30e07a89d0f7ce", "content": "This section presents some more detailed examples of custom XML extensions.\n\n[[xsd-custom-custom-nested]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc", "title": "xml-custom", "heading": "More Detailed Examples", "heading_level": 2, "file_order": 29, "section_index": 8, "content_hash": "b5f927604b0d455586765c54cee2c35ea2f06de729a3fa188a30e07a89d0f7ce", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc"}}
{"id": "sha256:8561602123dcbcacc6fed2a0fd4568cfc3dd9569afcfcece0bf6ed710c14106b", "content": "The example presented in this section shows how you to write the various artifacts required\nto satisfy a target of the following configuration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:foo=\"http://www.foo.example/schema/component\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.foo.example/schema/component http://www.foo.example/schema/component/component.xsd\">\n\n <foo:component id=\"bionic-family\" name=\"Bionic-1\">\n <foo:component name=\"Mother-1\">\n <foo:component name=\"Karate-1\"/>\n <foo:component name=\"Sport-1\"/>\n </foo:component>\n <foo:component name=\"Rock-1\"/>\n </foo:component>\n\n\t</beans>\n----\n\nThe preceding configuration nests custom extensions within each other. The class\nthat is actually configured by the `<foo:component/>` element is the `Component`\nclass (shown in the next example). Notice how the `Component` class does not expose a\nsetter method for the `components` property. This makes it hard (or rather impossible)\nto configure a bean definition for the `Component` class by using setter injection.\nThe following listing shows the `Component` class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo;\n\n\timport java.util.ArrayList;\n\timport java.util.List;\n\n\tpublic class Component {\n\n private String name;\n private List<Component> components = new ArrayList<Component> ();\n\n // there is no setter method for the 'components'\n public void addComponent(Component component) {\n this.components.add(component);\n }\n\n public List<Component> getComponents() {\n return components;\n }\n\n public String getName() {\n return name;\n }\n\n public void setName(String name) {\n this.name = name;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo\n\n\timport java.util.ArrayList\n\n\tclass Component {\n\n var name: String? = null\n private val components = ArrayList<Component>()\n\n // there is no setter method for the 'components'\n fun addComponent(component: Component) {\n this.components.add(component)\n }\n\n fun getComponents(): List<Component> {\n return components\n }\n\t}\n----\n======\n\nThe typical solution to this issue is to create a custom `FactoryBean` that exposes a\nsetter property for the `components` property. The following listing shows such a custom\n`FactoryBean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo;\n\n\timport org.springframework.beans.factory.FactoryBean;\n\n\timport java.util.List;\n\n\tpublic class ComponentFactoryBean implements FactoryBean<Component> {\n\n private Component parent;\n private List<Component> children;\n\n public void setParent(Component parent) {\n this.parent = parent;\n }\n\n public void setChildren(List<Component> children) {\n this.children = children;\n }\n\n public Component getObject() throws Exception {\n if (this.children != null && this.children.size() > 0) {\n for (Component child : children) {\n this.parent.addComponent(child);\n }\n }\n return this.parent;\n }\n\n public Class<Component> getObjectType() {\n return Component.class;\n }\n\n public boolean isSingleton() {\n return true;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo\n\n\timport org.springframework.beans.factory.FactoryBean\n\timport org.springframework.stereotype.Component\n\n\tclass ComponentFactoryBean : FactoryBean<Component> {\n\n private var parent: Component? = null\n private var children: List<Component>? = null\n\n fun setParent(parent: Component) {\n this.parent = parent\n }\n\n fun setChildren(children: List<Component>) {\n this.children = children\n }\n\n override fun getObject(): Component? {\n if (this.children != null && this.children!!.isNotEmpty()) {\n for (child in children!!) {\n this.parent!!.addComponent(child)\n }\n }\n return this.parent\n }\n\n override fun getObjectType(): Class<Component>? {\n return Component::class.java\n }\n\n override fun isSingleton(): Boolean {\n return true\n }\n\t}\n----\n======\n\nThis works nicely, but it exposes a lot of Spring plumbing to the end user. What we are\ngoing to do is write a custom extension that hides away all of this Spring plumbing.\nIf we stick to xref:core/appendix/xml-custom.adoc#core.appendix.xsd-custom-introduction[the steps described previously], we start off\nby creating the XSD schema to define the structure of our custom tag, as the following\nlisting shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n\n\t<xsd:schema xmlns=\"http://www.foo.example/schema/component\"\n xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n targetNamespace=\"http://www.foo.example/schema/component\"\n elementFormDefault=\"qualified\"\n attributeFormDefault=\"unqualified\">\n\n <xsd:element name=\"component\">\n <xsd:complexType>\n <xsd:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n <xsd:element ref=\"component\"/>\n </xsd:choice>\n <xsd:attribute name=\"id\" type=\"xsd:ID\"/>\n <xsd:attribute name=\"name\" use=\"required\" type=\"xsd:string\"/>\n </xsd:complexType>\n </xsd:element>\n\n\t</xsd:schema>\n----\n\nAgain following xref:core/appendix/xml-custom.adoc#core.appendix.xsd-custom-introduction[the process described earlier],\nwe then create a custom `NamespaceHandler`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo;\n\n\timport org.springframework.beans.factory.xml.NamespaceHandlerSupport;\n\n\tpublic class ComponentNamespaceHandler extends NamespaceHandlerSupport {\n\n public void init() {\n registerBeanDefinitionParser(\"component\", new ComponentBeanDefinitionParser());\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo\n\n\timport org.springframework.beans.factory.xml.NamespaceHandlerSupport\n\n\tclass ComponentNamespaceHandler : NamespaceHandlerSupport() {\n\n override fun init() {\n registerBeanDefinitionParser(\"component\", ComponentBeanDefinitionParser())\n }\n\t}\n----\n======\n\nNext up is the custom `BeanDefinitionParser`. Remember that we are creating\na `BeanDefinition` that describes a `ComponentFactoryBean`. The following\nlisting shows our custom `BeanDefinitionParser` implementation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo;\n\n\timport org.springframework.beans.factory.config.BeanDefinition;\n\timport org.springframework.beans.factory.support.AbstractBeanDefinition;\n\timport org.springframework.beans.factory.support.BeanDefinitionBuilder;\n\timport org.springframework.beans.factory.support.ManagedList;\n\timport org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;\n\timport org.springframework.beans.factory.xml.ParserContext;\n\timport org.springframework.util.xml.DomUtils;\n\timport org.w3c.dom.Element;\n\n\timport java.util.List;\n\n\tpublic class ComponentBeanDefinitionParser extends AbstractBeanDefinitionParser {\n\n protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {\n return parseComponentElement(element);\n }\n\n private static AbstractBeanDefinition parseComponentElement(Element element) {\n BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class);\n factory.addPropertyValue(\"parent\", parseComponent(element));\n\n List<Element> childElements = DomUtils.getChildElementsByTagName(element, \"component\");\n if (childElements != null && childElements.size() > 0) {\n parseChildComponents(childElements, factory);\n }\n\n return factory.getBeanDefinition();\n }\n\n private static BeanDefinition parseComponent(Element element) {\n BeanDefinitionBuilder component = BeanDefinitionBuilder.rootBeanDefinition(Component.class);\n component.addPropertyValue(\"name\", element.getAttribute(\"name\"));\n return component.getBeanDefinition();\n }\n\n private static void parseChildComponents(List<Element> childElements, BeanDefinitionBuilder factory) {\n ManagedList<BeanDefinition> children = new ManagedList<>(childElements.size());\n for (Element element : childElements) {\n children.add(parseComponentElement(element));\n }\n factory.addPropertyValue(\"children\", children);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo\n\n\timport org.springframework.beans.factory.config.BeanDefinition\n\timport org.springframework.beans.factory.support.AbstractBeanDefinition\n\timport org.springframework.beans.factory.support.BeanDefinitionBuilder\n\timport org.springframework.beans.factory.support.ManagedList\n\timport org.springframework.beans.factory.xml.AbstractBeanDefinitionParser\n\timport org.springframework.beans.factory.xml.ParserContext\n\timport org.springframework.util.xml.DomUtils\n\timport org.w3c.dom.Element\n\n\timport java.util.List\n\n\tclass ComponentBeanDefinitionParser : AbstractBeanDefinitionParser() {\n\n override fun parseInternal(element: Element, parserContext: ParserContext): AbstractBeanDefinition? {\n return parseComponentElement(element)\n }\n\n private fun parseComponentElement(element: Element): AbstractBeanDefinition {\n val factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean::class.java)\n factory.addPropertyValue(\"parent\", parseComponent(element))\n\n val childElements = DomUtils.getChildElementsByTagName(element, \"component\")\n if (childElements != null && childElements.size > 0) {\n parseChildComponents(childElements, factory)\n }\n\n return factory.getBeanDefinition()\n }\n\n private fun parseComponent(element: Element): BeanDefinition {\n val component = BeanDefinitionBuilder.rootBeanDefinition(Component::class.java)\n component.addPropertyValue(\"name\", element.getAttribute(\"name\"))\n return component.beanDefinition\n }\n\n private fun parseChildComponents(childElements: List<Element>, factory: BeanDefinitionBuilder) {\n val children = ManagedList<BeanDefinition>(childElements.size)\n for (element in childElements) {\n children.add(parseComponentElement(element))\n }\n factory.addPropertyValue(\"children\", children)\n }\n\t}\n----\n======\n\nFinally, the various artifacts need to be registered with the Spring XML infrastructure,\nby modifying the `META-INF/spring.handlers` and `META-INF/spring.schemas` files, as follows:\n\n[literal,subs=\"verbatim,quotes\"]\n----\n# in 'META-INF/spring.handlers'\nhttp\\://www.foo.example/schema/component=com.foo.ComponentNamespaceHandler\n----\n\n[literal,subs=\"verbatim,quotes\"]\n----\n# in 'META-INF/spring.schemas'\nhttp\\://www.foo.example/schema/component/component.xsd=com/foo/component.xsd\n----\n\n[[xsd-custom-custom-just-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc", "title": "xml-custom", "heading": "Nesting Custom Elements within Custom Elements", "heading_level": 3, "file_order": 29, "section_index": 9, "content_hash": "8561602123dcbcacc6fed2a0fd4568cfc3dd9569afcfcece0bf6ed710c14106b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc"}}
{"id": "sha256:3351d57244cac20544f4ec4144b690f059ea8662644637a4a57d78bd2d88dc22", "content": "Writing your own custom parser and the associated artifacts is not hard. However,\nit is sometimes not the right thing to do. Consider a scenario where you need to\nadd metadata to already existing bean definitions. In this case, you certainly\ndo not want to have to write your own entire custom extension. Rather, you merely\nwant to add an additional attribute to the existing bean definition element.\n\nBy way of another example, suppose that you define a bean definition for a\nservice object that (unknown to it) accesses a clustered\n{JSR}107[JCache], and you want to ensure that the\nnamed JCache instance is eagerly started within the surrounding cluster.\nThe following listing shows such a definition:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"checkingAccountService\" class=\"com.foo.DefaultCheckingAccountService\"\n jcache:cache-name=\"checking.account\">\n <!-- other dependencies here... -->\n\t</bean>\n----\n\nWe can then create another `BeanDefinition` when the\n`'jcache:cache-name'` attribute is parsed. This `BeanDefinition` then initializes\nthe named JCache for us. We can also modify the existing `BeanDefinition` for the\n`'checkingAccountService'` so that it has a dependency on this new\nJCache-initializing `BeanDefinition`. The following listing shows our `JCacheInitializer`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo;\n\n\tpublic class JCacheInitializer {\n\n private final String name;\n\n public JCacheInitializer(String name) {\n this.name = name;\n }\n\n public void initialize() {\n // lots of JCache API calls to initialize the named cache...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo\n\n\tclass JCacheInitializer(private val name: String) {\n\n fun initialize() {\n // lots of JCache API calls to initialize the named cache...\n }\n\t}\n----\n======\n\nNow we can move onto the custom extension. First, we need to author\nthe XSD schema that describes the custom attribute, as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n\n\t<xsd:schema xmlns=\"http://www.foo.example/schema/jcache\"\n xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n targetNamespace=\"http://www.foo.example/schema/jcache\"\n elementFormDefault=\"qualified\">\n\n <xsd:attribute name=\"cache-name\" type=\"xsd:string\"/>\n\n\t</xsd:schema>\n----\n\nNext, we need to create the associated `NamespaceHandler`, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo;\n\n\timport org.springframework.beans.factory.xml.NamespaceHandlerSupport;\n\n\tpublic class JCacheNamespaceHandler extends NamespaceHandlerSupport {\n\n public void init() {\n super.registerBeanDefinitionDecoratorForAttribute(\"cache-name\",\n new JCacheInitializingBeanDefinitionDecorator());\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo\n\n\timport org.springframework.beans.factory.xml.NamespaceHandlerSupport\n\n\tclass JCacheNamespaceHandler : NamespaceHandlerSupport() {\n\n override fun init() {\n super.registerBeanDefinitionDecoratorForAttribute(\"cache-name\",\n JCacheInitializingBeanDefinitionDecorator())\n }\n\n\t}\n----\n======\n\nNext, we need to create the parser. Note that, in this case, because we are going to parse\nan XML attribute, we write a `BeanDefinitionDecorator` rather than a `BeanDefinitionParser`.\nThe following listing shows our `BeanDefinitionDecorator` implementation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo;\n\n\timport org.springframework.beans.factory.config.BeanDefinitionHolder;\n\timport org.springframework.beans.factory.support.AbstractBeanDefinition;\n\timport org.springframework.beans.factory.support.BeanDefinitionBuilder;\n\timport org.springframework.beans.factory.xml.BeanDefinitionDecorator;\n\timport org.springframework.beans.factory.xml.ParserContext;\n\timport org.w3c.dom.Attr;\n\timport org.w3c.dom.Node;\n\n\timport java.util.ArrayList;\n\timport java.util.Arrays;\n\timport java.util.List;\n\n\tpublic class JCacheInitializingBeanDefinitionDecorator implements BeanDefinitionDecorator {\n\n private static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n public BeanDefinitionHolder decorate(Node source, BeanDefinitionHolder holder,\n ParserContext ctx) {\n String initializerBeanName = registerJCacheInitializer(source, ctx);\n createDependencyOnJCacheInitializer(holder, initializerBeanName);\n return holder;\n }\n\n private void createDependencyOnJCacheInitializer(BeanDefinitionHolder holder,\n String initializerBeanName) {\n AbstractBeanDefinition definition = ((AbstractBeanDefinition) holder.getBeanDefinition());\n String[] dependsOn = definition.getDependsOn();\n if (dependsOn == null) {\n dependsOn = new String[]{initializerBeanName};\n } else {\n List dependencies = new ArrayList(Arrays.asList(dependsOn));\n dependencies.add(initializerBeanName);\n dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);\n }\n definition.setDependsOn(dependsOn);\n }\n\n private String registerJCacheInitializer(Node source, ParserContext ctx) {\n String cacheName = ((Attr) source).getValue();\n String beanName = cacheName + \"-initializer\";\n if (!ctx.getRegistry().containsBeanDefinition(beanName)) {\n BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class);\n initializer.addConstructorArg(cacheName);\n ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());\n }\n return beanName;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo\n\n\timport org.springframework.beans.factory.config.BeanDefinitionHolder\n\timport org.springframework.beans.factory.support.AbstractBeanDefinition\n\timport org.springframework.beans.factory.support.BeanDefinitionBuilder\n\timport org.springframework.beans.factory.xml.BeanDefinitionDecorator\n\timport org.springframework.beans.factory.xml.ParserContext\n\timport org.w3c.dom.Attr\n\timport org.w3c.dom.Node\n\n\timport java.util.ArrayList\n\n\tclass JCacheInitializingBeanDefinitionDecorator : BeanDefinitionDecorator {\n\n override fun decorate(source: Node, holder: BeanDefinitionHolder,\n ctx: ParserContext): BeanDefinitionHolder {\n val initializerBeanName = registerJCacheInitializer(source, ctx)\n createDependencyOnJCacheInitializer(holder, initializerBeanName)\n return holder\n }\n\n private fun createDependencyOnJCacheInitializer(holder: BeanDefinitionHolder,\n initializerBeanName: String) {\n val definition = holder.beanDefinition as AbstractBeanDefinition\n var dependsOn = definition.dependsOn\n dependsOn = if (dependsOn == null) {\n arrayOf(initializerBeanName)\n } else {\n val dependencies = ArrayList(listOf(*dependsOn))\n dependencies.add(initializerBeanName)\n dependencies.toTypedArray()\n }\n definition.setDependsOn(*dependsOn)\n }\n\n private fun registerJCacheInitializer(source: Node, ctx: ParserContext): String {\n val cacheName = (source as Attr).value\n val beanName = \"$cacheName-initializer\"\n if (!ctx.registry.containsBeanDefinition(beanName)) {\n val initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer::class.java)\n initializer.addConstructorArg(cacheName)\n ctx.registry.registerBeanDefinition(beanName, initializer.getBeanDefinition())\n }\n return beanName\n }\n\t}\n----\n======\n\nFinally, we need to register the various artifacts with the Spring XML infrastructure\nby modifying the `META-INF/spring.handlers` and `META-INF/spring.schemas` files, as follows:\n\n[literal,subs=\"verbatim,quotes\"]\n----\n# in 'META-INF/spring.handlers'\nhttp\\://www.foo.example/schema/jcache=com.foo.JCacheNamespaceHandler\n----\n\n[literal,subs=\"verbatim,quotes\"]\n----\n# in 'META-INF/spring.schemas'\nhttp\\://www.foo.example/schema/jcache/jcache.xsd=com/foo/jcache.xsd\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc", "title": "xml-custom", "heading": "Custom Attributes on \"`Normal`\" Elements", "heading_level": 3, "file_order": 29, "section_index": 10, "content_hash": "3351d57244cac20544f4ec4144b690f059ea8662644637a4a57d78bd2d88dc22", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xml-custom.adoc"}}
{"id": "sha256:847c69f37957f27ac2d4d946da3d971fb497008259b2504fb3849a5f210a2a87", "content": "[[xsd-schemas]]\n\nThis part of the appendix lists XML schemas related to the core container.\n\n[[xsd-schemas-util]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "xsd-schemas", "heading_level": 1, "file_order": 30, "section_index": 0, "content_hash": "847c69f37957f27ac2d4d946da3d971fb497008259b2504fb3849a5f210a2a87", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:5221dd3026d28a297732eb4324fe24b142996102d65ff388ac6f8214477eea4f", "content": "As the name implies, the `util` tags deal with common, utility configuration\nissues, such as configuring collections, referencing constants, and so forth.\nTo use the tags in the `util` schema, you need to have the following preamble at the top\nof your Spring XML configuration file (the text in the snippet references the\ncorrect schema so that the tags in the `util` namespace are available to you):\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:util=\"http://www.springframework.org/schema/util\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd\">\n\n <!-- bean definitions here -->\n\n\t</beans>\n----\n\n[[xsd-schemas-util-constant]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "The `util` Schema", "heading_level": 2, "file_order": 30, "section_index": 1, "content_hash": "5221dd3026d28a297732eb4324fe24b142996102d65ff388ac6f8214477eea4f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:2ff33d56163bf50b73bb099980c8a15214ae489ae612d3443b1f61be8a2ea1d7", "content": "Consider the following bean definition:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"...\" class=\"...\">\n <property name=\"isolation\">\n <bean id=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"\n class=\"org.springframework.beans.factory.config.FieldRetrievingFactoryBean\" />\n </property>\n\t</bean>\n----\n\nThe preceding configuration uses a Spring `FactoryBean` implementation (the\n`FieldRetrievingFactoryBean`) to set the value of the `isolation` property on a bean\nto the value of the `java.sql.Connection.TRANSACTION_SERIALIZABLE` constant. This is\nall well and good, but it is verbose and (unnecessarily) exposes Spring's internal\nplumbing to the end user.\n\nThe following XML Schema-based version is more concise, clearly expresses the\ndeveloper's intent (\"`inject this constant value`\"), and it reads better:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"...\" class=\"...\">\n <property name=\"isolation\">\n <util:constant static-field=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"/>\n </property>\n\t</bean>\n----\n\n[[xsd-schemas-util-frfb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<util:constant/>`", "heading_level": 3, "file_order": 30, "section_index": 2, "content_hash": "2ff33d56163bf50b73bb099980c8a15214ae489ae612d3443b1f61be8a2ea1d7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:4a7375a3b619f1fe6d3ee1de6849e2ed2e2c5be9555aaabe260ffba00864c25a", "content": "{spring-framework-api}/beans/factory/config/FieldRetrievingFactoryBean.html[`FieldRetrievingFactoryBean`]\nis a `FactoryBean` that retrieves a `static` or non-static field value. It is typically\nused for retrieving `public` `static` `final` constants, which may then be used to set a\nproperty value or constructor argument for another bean.\n\nThe following example shows how a `static` field is exposed, by using the\n{spring-framework-api}/beans/factory/config/FieldRetrievingFactoryBean.html#setStaticField(java.lang.String)[`staticField`]\nproperty:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"myField\"\n class=\"org.springframework.beans.factory.config.FieldRetrievingFactoryBean\">\n <property name=\"staticField\" value=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"/>\n\t</bean>\n----\n\nThere is also a convenience usage form where the `static` field is specified as the bean\nname, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"\n class=\"org.springframework.beans.factory.config.FieldRetrievingFactoryBean\"/>\n----\n\nThis does mean that there is no longer any choice in what the bean `id` is (so any other\nbean that refers to it also has to use this longer name), but this form is very\nconcise to define and very convenient to use as an inner bean since the `id` does not have\nto be specified for the bean reference, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"...\" class=\"...\">\n <property name=\"isolation\">\n <bean id=\"java.sql.Connection.TRANSACTION_SERIALIZABLE\"\n class=\"org.springframework.beans.factory.config.FieldRetrievingFactoryBean\" />\n </property>\n\t</bean>\n----\n\nYou can also access a non-static (instance) field of another bean, as\ndescribed in the API documentation for the\n{spring-framework-api}/beans/factory/config/FieldRetrievingFactoryBean.html[`FieldRetrievingFactoryBean`]\nclass.\n\nInjecting enumeration values into beans as either property or constructor arguments is\neasy to do in Spring. You do not actually have to do anything or know anything about\nthe Spring internals (or even about classes such as the `FieldRetrievingFactoryBean`).\nThe following example enumeration shows how easy injecting an enum value is:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage jakarta.persistence;\n\n\tpublic enum PersistenceContextType {\n\n TRANSACTION,\n EXTENDED\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage jakarta.persistence\n\n\tenum class PersistenceContextType {\n\n TRANSACTION,\n EXTENDED\n\t}\n----\n======\n\nNow consider the following setter of type `PersistenceContextType` and the corresponding bean definition:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage example;\n\n\tpublic class Client {\n\n private PersistenceContextType persistenceContextType;\n\n public void setPersistenceContextType(PersistenceContextType type) {\n this.persistenceContextType = type;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage example\n\n\tclass Client {\n\n lateinit var persistenceContextType: PersistenceContextType\n\t}\n----\n======\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean class=\"example.Client\">\n <property name=\"persistenceContextType\" value=\"TRANSACTION\"/>\n\t</bean>\n----\n\n[[xsd-schemas-util-property-path]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Setting a Bean Property or Constructor Argument from a Field Value", "heading_level": 4, "file_order": 30, "section_index": 3, "content_hash": "4a7375a3b619f1fe6d3ee1de6849e2ed2e2c5be9555aaabe260ffba00864c25a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:530afd341ba90b966d25bc7e767a4b2496116f0d2526ed9c95ca708d8f8e768a", "content": "Consider the following example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- target bean to be referenced by name -->\n\t<bean id=\"testBean\" class=\"org.springframework.beans.TestBean\" scope=\"prototype\">\n <property name=\"age\" value=\"10\"/>\n <property name=\"spouse\">\n <bean class=\"org.springframework.beans.TestBean\">\n <property name=\"age\" value=\"11\"/>\n </bean>\n </property>\n\t</bean>\n\n\t<!-- results in 10, which is the value of property 'age' of bean 'testBean' -->\n\t<bean id=\"testBean.age\" class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"/>\n----\n\nThe preceding configuration uses a Spring `FactoryBean` implementation (the\n`PropertyPathFactoryBean`) to create a bean (of type `int`) called `testBean.age` that\nhas a value equal to the `age` property of the `testBean` bean.\n\nNow consider the following example, which adds a `<util:property-path/>` element:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- target bean to be referenced by name -->\n\t<bean id=\"testBean\" class=\"org.springframework.beans.TestBean\" scope=\"prototype\">\n <property name=\"age\" value=\"10\"/>\n <property name=\"spouse\">\n <bean class=\"org.springframework.beans.TestBean\">\n <property name=\"age\" value=\"11\"/>\n </bean>\n </property>\n\t</bean>\n\n\t<!-- results in 10, which is the value of property 'age' of bean 'testBean' -->\n\t<util:property-path id=\"name\" path=\"testBean.age\"/>\n----\n\nThe value of the `path` attribute of the `<property-path/>` element follows the form of\n`beanName.beanProperty`. In this case, it picks up the `age` property of the bean named\n`testBean`. The value of that `age` property is `10`.\n\n[[xsd-schemas-util-property-path-dependency]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<util:property-path/>`", "heading_level": 3, "file_order": 30, "section_index": 4, "content_hash": "530afd341ba90b966d25bc7e767a4b2496116f0d2526ed9c95ca708d8f8e768a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:712909a0b50b0f90a11f2ce51a30b7a39cfb59972f97b0be553714ee2c645df3", "content": "`PropertyPathFactoryBean` is a `FactoryBean` that evaluates a property path on a given\ntarget object. The target object can be specified directly or by a bean name. You can then use this\nvalue in another bean definition as a property value or constructor\nargument.\n\nThe following example shows a path being used against another bean, by name:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- target bean to be referenced by name -->\n\t<bean id=\"person\" class=\"org.springframework.beans.TestBean\" scope=\"prototype\">\n <property name=\"age\" value=\"10\"/>\n <property name=\"spouse\">\n <bean class=\"org.springframework.beans.TestBean\">\n <property name=\"age\" value=\"11\"/>\n </bean>\n </property>\n\t</bean>\n\n\t<!-- results in 11, which is the value of property 'spouse.age' of bean 'person' -->\n\t<bean id=\"theAge\"\n class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\">\n <property name=\"targetBeanName\" value=\"person\"/>\n <property name=\"propertyPath\" value=\"spouse.age\"/>\n\t</bean>\n----\n\nIn the following example, a path is evaluated against an inner bean:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- results in 12, which is the value of property 'age' of the inner bean -->\n\t<bean id=\"theAge\"\n class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\">\n <property name=\"targetObject\">\n <bean class=\"org.springframework.beans.TestBean\">\n <property name=\"age\" value=\"12\"/>\n </bean>\n </property>\n <property name=\"propertyPath\" value=\"age\"/>\n\t</bean>\n----\n\nThere is also a shortcut form, where the bean name is the property path.\nThe following example shows the shortcut form:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- results in 10, which is the value of property 'age' of bean 'person' -->\n\t<bean id=\"person.age\"\n class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"/>\n----\n\nThis form does mean that there is no choice in the name of the bean. Any reference to it\nalso has to use the same `id`, which is the path. If used as an inner\nbean, there is no need to refer to it at all, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"...\" class=\"...\">\n <property name=\"age\">\n <bean id=\"person.age\"\n class=\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"/>\n </property>\n\t</bean>\n----\n\nYou can specifically set the result type in the actual definition. This is not necessary\nfor most use cases, but it can sometimes be useful. See the javadoc for more info on\nthis feature.\n\n[[xsd-schemas-util-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<util:property-path/>` to Set a Bean Property or Constructor Argument", "heading_level": 4, "file_order": 30, "section_index": 5, "content_hash": "712909a0b50b0f90a11f2ce51a30b7a39cfb59972f97b0be553714ee2c645df3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:cd1d4fdc0a7ceece2a297f407fa59f28a5652d25b8f6fdd4a895c3393137c72f", "content": "Consider the following example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- creates a java.util.Properties instance with values loaded from the supplied location -->\n\t<bean id=\"jdbcConfiguration\" class=\"org.springframework.beans.factory.config.PropertiesFactoryBean\">\n <property name=\"location\" value=\"classpath:com/foo/jdbc-production.properties\"/>\n\t</bean>\n----\n\nThe preceding configuration uses a Spring `FactoryBean` implementation (the\n`PropertiesFactoryBean`) to instantiate a `java.util.Properties` instance with values\nloaded from the supplied xref:web/webflux-webclient/client-builder.adoc#webflux-client-builder-reactor-resources[`Resource`] location).\n\nThe following example uses a `util:properties` element to make a more concise representation:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- creates a java.util.Properties instance with values loaded from the supplied location -->\n\t<util:properties id=\"jdbcConfiguration\" location=\"classpath:com/foo/jdbc-production.properties\"/>\n----\n\n[[xsd-schemas-util-list]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<util:properties/>`", "heading_level": 3, "file_order": 30, "section_index": 6, "content_hash": "cd1d4fdc0a7ceece2a297f407fa59f28a5652d25b8f6fdd4a895c3393137c72f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:c57109c836ab5a1c15ff9b615e8336adbfb02434a9f86a627e91b24a601fe28d", "content": "Consider the following example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- creates a java.util.List instance with values loaded from the supplied 'sourceList' -->\n\t<bean id=\"emails\" class=\"org.springframework.beans.factory.config.ListFactoryBean\">\n <property name=\"sourceList\">\n <list>\n <value>pechorin@hero.org</value>\n <value>raskolnikov@slums.org</value>\n <value>stavrogin@gov.org</value>\n <value>porfiry@gov.org</value>\n </list>\n </property>\n\t</bean>\n----\n\nThe preceding configuration uses a Spring `FactoryBean` implementation (the\n`ListFactoryBean`) to create a `java.util.List` instance and initialize it with values taken\nfrom the supplied `sourceList`.\n\nThe following example uses a `<util:list/>` element to make a more concise representation:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- creates a java.util.List instance with the supplied values -->\n\t<util:list id=\"emails\">\n <value>pechorin@hero.org</value>\n <value>raskolnikov@slums.org</value>\n <value>stavrogin@gov.org</value>\n <value>porfiry@gov.org</value>\n\t</util:list>\n----\n\nYou can also explicitly control the exact type of `List` that is instantiated and\npopulated by using the `list-class` attribute on the `<util:list/>` element. For\nexample, if we really need a `java.util.LinkedList` to be instantiated, we could use the\nfollowing configuration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<util:list id=\"emails\" list-class=\"java.util.LinkedList\">\n <value>jackshaftoe@vagabond.org</value>\n <value>eliza@thinkingmanscrumpet.org</value>\n <value>vanhoek@pirate.org</value>\n <value>d'Arcachon@nemesis.org</value>\n\t</util:list>\n----\n\nIf no `list-class` attribute is supplied, the container chooses a `List` implementation.\n\n[[xsd-schemas-util-map]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<util:list/>`", "heading_level": 3, "file_order": 30, "section_index": 7, "content_hash": "c57109c836ab5a1c15ff9b615e8336adbfb02434a9f86a627e91b24a601fe28d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:00265ca4e2bc8b1cd1224288ccf983f247a21c09fce7ec862df831970c3f7972", "content": "Consider the following example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- creates a java.util.Map instance with values loaded from the supplied 'sourceMap' -->\n\t<bean id=\"emails\" class=\"org.springframework.beans.factory.config.MapFactoryBean\">\n <property name=\"sourceMap\">\n <map>\n <entry key=\"pechorin\" value=\"pechorin@hero.org\"/>\n <entry key=\"raskolnikov\" value=\"raskolnikov@slums.org\"/>\n <entry key=\"stavrogin\" value=\"stavrogin@gov.org\"/>\n <entry key=\"porfiry\" value=\"porfiry@gov.org\"/>\n </map>\n </property>\n\t</bean>\n----\n\nThe preceding configuration uses a Spring `FactoryBean` implementation (the\n`MapFactoryBean`) to create a `java.util.Map` instance initialized with key-value pairs\ntaken from the supplied `'sourceMap'`.\n\nThe following example uses a `<util:map/>` element to make a more concise representation:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- creates a java.util.Map instance with the supplied key-value pairs -->\n\t<util:map id=\"emails\">\n <entry key=\"pechorin\" value=\"pechorin@hero.org\"/>\n <entry key=\"raskolnikov\" value=\"raskolnikov@slums.org\"/>\n <entry key=\"stavrogin\" value=\"stavrogin@gov.org\"/>\n <entry key=\"porfiry\" value=\"porfiry@gov.org\"/>\n\t</util:map>\n----\n\nYou can also explicitly control the exact type of `Map` that is instantiated and\npopulated by using the `'map-class'` attribute on the `<util:map/>` element. For\nexample, if we really need a `java.util.TreeMap` to be instantiated, we could use the\nfollowing configuration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<util:map id=\"emails\" map-class=\"java.util.TreeMap\">\n <entry key=\"pechorin\" value=\"pechorin@hero.org\"/>\n <entry key=\"raskolnikov\" value=\"raskolnikov@slums.org\"/>\n <entry key=\"stavrogin\" value=\"stavrogin@gov.org\"/>\n <entry key=\"porfiry\" value=\"porfiry@gov.org\"/>\n\t</util:map>\n----\n\nIf no `'map-class'` attribute is supplied, the container chooses a `Map` implementation.\n\n[[xsd-schemas-util-set]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<util:map/>`", "heading_level": 3, "file_order": 30, "section_index": 8, "content_hash": "00265ca4e2bc8b1cd1224288ccf983f247a21c09fce7ec862df831970c3f7972", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:86269f4923058028d443931f39ccee686aa858de290471969808fc6030834ecf", "content": "Consider the following example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- creates a java.util.Set instance with values loaded from the supplied 'sourceSet' -->\n\t<bean id=\"emails\" class=\"org.springframework.beans.factory.config.SetFactoryBean\">\n <property name=\"sourceSet\">\n <set>\n <value>pechorin@hero.org</value>\n <value>raskolnikov@slums.org</value>\n <value>stavrogin@gov.org</value>\n <value>porfiry@gov.org</value>\n </set>\n </property>\n\t</bean>\n----\n\nThe preceding configuration uses a Spring `FactoryBean` implementation (the\n`SetFactoryBean`) to create a `java.util.Set` instance initialized with values taken\nfrom the supplied `sourceSet`.\n\nThe following example uses a `<util:set/>` element to make a more concise representation:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- creates a java.util.Set instance with the supplied values -->\n\t<util:set id=\"emails\">\n <value>pechorin@hero.org</value>\n <value>raskolnikov@slums.org</value>\n <value>stavrogin@gov.org</value>\n <value>porfiry@gov.org</value>\n\t</util:set>\n----\n\nYou can also explicitly control the exact type of `Set` that is instantiated and\npopulated by using the `set-class` attribute on the `<util:set/>` element. For\nexample, if we really need a `java.util.TreeSet` to be instantiated, we could use the\nfollowing configuration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<util:set id=\"emails\" set-class=\"java.util.TreeSet\">\n <value>pechorin@hero.org</value>\n <value>raskolnikov@slums.org</value>\n <value>stavrogin@gov.org</value>\n <value>porfiry@gov.org</value>\n\t</util:set>\n----\n\nIf no `set-class` attribute is supplied, the container chooses a `Set` implementation.\n\n[[xsd-schemas-aop]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<util:set/>`", "heading_level": 3, "file_order": 30, "section_index": 9, "content_hash": "86269f4923058028d443931f39ccee686aa858de290471969808fc6030834ecf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:27b5e09b8fc10dc4a727faf883a5d3409049b555e1aacfb8650afb96219fe399", "content": "The `aop` tags deal with configuring all things AOP in Spring, including Spring's\nown proxy-based AOP framework and Spring's integration with the AspectJ AOP framework.\nThese tags are comprehensively covered in the chapter entitled xref:core/aop.adoc[Aspect Oriented Programming with Spring]\n.\n\nIn the interest of completeness, to use the tags in the `aop` schema, you need to have\nthe following preamble at the top of your Spring XML configuration file (the text in the\nsnippet references the correct schema so that the tags in the `aop` namespace\nare available to you):\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:aop=\"http://www.springframework.org/schema/aop\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n <!-- bean definitions here -->\n\n\t</beans>\n----\n\n[[xsd-schemas-context]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "The `aop` Schema", "heading_level": 2, "file_order": 30, "section_index": 10, "content_hash": "27b5e09b8fc10dc4a727faf883a5d3409049b555e1aacfb8650afb96219fe399", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:1b76ad06012e26db71cd70476a2f396b81881167280e0b52cfa1fa6ecb4ce599", "content": "The `context` tags deal with `ApplicationContext` configuration that relates to plumbing\n-- that is, not usually beans that are important to an end-user but rather beans that do\na lot of the \"`grunt`\" work in Spring, such as `BeanfactoryPostProcessors`. The following\nsnippet references the correct schema so that the elements in the `context` namespace are\navailable to you:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:context=\"http://www.springframework.org/schema/context\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n\n <!-- bean definitions here -->\n\n\t</beans>\n----\n\n[[xsd-schemas-context-pphc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "The `context` Schema", "heading_level": 2, "file_order": 30, "section_index": 11, "content_hash": "1b76ad06012e26db71cd70476a2f396b81881167280e0b52cfa1fa6ecb4ce599", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:890ae1c9f83d5e9abc63e937761ba3982c39f2c3b6e08d9f6376e2cfbd6350df", "content": "This element activates the replacement of `${...}` placeholders, which are resolved against a\nspecified properties file (as a xref:web/webflux-webclient/client-builder.adoc#webflux-client-builder-reactor-resources[Spring resource location]). This element\nis a convenience mechanism that sets up a xref:core/beans/factory-extension.adoc#beans-factory-placeholderconfigurer[`PropertySourcesPlaceholderConfigurer`]\n for you. If you need more control over the specific\n`PropertySourcesPlaceholderConfigurer` setup, you can explicitly define it as a bean yourself.\n\n[WARNING]\n=====\nOnly one such element should be defined for a given application with the properties\nthat it needs. Several property placeholders can be configured as long as they have distinct\nplaceholder syntax (`${...}`).\n\nIf you need to modularize the source of properties used for the replacement, you should\nnot create multiple properties placeholders. Rather, each module should contribute a\n`PropertySource` to the `Environment`. Alternatively, you can create your own\n`PropertySourcesPlaceholderConfigurer` bean that gathers the properties to use.\n=====\n\n[[xsd-schemas-context-ac]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<property-placeholder/>`", "heading_level": 3, "file_order": 30, "section_index": 12, "content_hash": "890ae1c9f83d5e9abc63e937761ba3982c39f2c3b6e08d9f6376e2cfbd6350df", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:0cec2c03e9f4e4f8eb1cf1a9ebc1e7de96bd07a91e65acdf6495c64d6e9e49c2", "content": "This element activates the Spring infrastructure to detect annotations in bean classes:\n\n* Spring's xref:core/beans/basics.adoc#beans-factory-metadata[`@Configuration`] model\n* xref:core/beans/annotation-config.adoc[`@Autowired`/`@Inject`], `@Value`, and `@Lookup`\n* JSR-250's `@Resource`, `@PostConstruct`, and `@PreDestroy` (if available)\n* JAX-WS's `@WebServiceRef` and EJB 3's `@EJB` (if available)\n* JPA's `@PersistenceContext` and `@PersistenceUnit` (if available)\n* Spring's xref:core/beans/context-introduction.adoc#context-functionality-events-annotation[`@EventListener`]\n\nAlternatively, you can choose to explicitly activate the individual `BeanPostProcessors`\nfor those annotations.\n\nNOTE: This element does not activate processing of Spring's\nxref:data-access/transaction/declarative/annotations.adoc[`@Transactional`] annotation;\nyou can use the <<data-access.adoc#tx-decl-explained, `<tx:annotation-driven/>`>>\nelement for that purpose. Similarly, Spring's\nxref:integration/cache/annotations.adoc[caching annotations] need to be explicitly\nxref:integration/cache/annotations.adoc#cache-annotation-enable[enabled] as well.\n\n[[xsd-schemas-context-component-scan]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<annotation-config/>`", "heading_level": 3, "file_order": 30, "section_index": 13, "content_hash": "0cec2c03e9f4e4f8eb1cf1a9ebc1e7de96bd07a91e65acdf6495c64d6e9e49c2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:2cffaf43ec9fe09b329156b513619cd20bb2b0d10c47c113c4d35a01f9900f19", "content": "This element is detailed in the section on xref:core/beans/annotation-config.adoc[annotation-based container configuration].\n\n[[xsd-schemas-context-ltw]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<component-scan/>`", "heading_level": 3, "file_order": 30, "section_index": 14, "content_hash": "2cffaf43ec9fe09b329156b513619cd20bb2b0d10c47c113c4d35a01f9900f19", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:2b7731b949f64a2c8929061f4f234c8559bf680d5c37a951f65c24cec7079361", "content": "This element is detailed in the section on xref:core/aop/using-aspectj.adoc#aop-aj-ltw[load-time weaving with AspectJ in the Spring Framework].\n\n[[xsd-schemas-context-sc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<load-time-weaver/>`", "heading_level": 3, "file_order": 30, "section_index": 15, "content_hash": "2b7731b949f64a2c8929061f4f234c8559bf680d5c37a951f65c24cec7079361", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:50106919222de1741413e0becefe4e787367ae19553a2b70b8e295071b10b35f", "content": "This element is detailed in the section on xref:core/aop/using-aspectj.adoc#aop-atconfigurable[using AspectJ to dependency inject domain objects with Spring].\n\n[[xsd-schemas-context-mbe]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<spring-configured/>`", "heading_level": 3, "file_order": 30, "section_index": 16, "content_hash": "50106919222de1741413e0becefe4e787367ae19553a2b70b8e295071b10b35f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:46554426e0352667e035566802f3696dc5fe2ab7e071fc97c9cd24bb8090310f", "content": "This element is detailed in the section on xref:integration/jmx/naming.adoc#jmx-context-mbeanexport[configuring annotation-based MBean export].\n\n[[xsd-schemas-beans]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "Using `<mbean-export/>`", "heading_level": 3, "file_order": 30, "section_index": 17, "content_hash": "46554426e0352667e035566802f3696dc5fe2ab7e071fc97c9cd24bb8090310f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:fe3bae40677c3d74f9401f185d317d5c527b06765c0f153a862115e4bab2fbd9", "content": "Last but not least, we have the elements in the `beans` schema. These elements\nhave been in Spring since the very dawn of the framework. Examples of the various elements\nin the `beans` schema are not shown here because they are quite comprehensively covered\nin xref:core/beans/dependencies/factory-properties-detailed.adoc[dependencies and configuration in detail]\n(and, indeed, in that entire xref:web/webmvc-view/mvc-xslt.adoc#mvc-view-xslt-beandefs[chapter]).\n\nNote that you can add zero or more key-value pairs to `<bean/>` XML definitions.\nWhat, if anything, is done with this extra metadata is totally up to your own custom\nlogic (and so is typically only of use if you write your own custom elements as described\nin the appendix entitled xref:core/appendix/xml-custom.adoc[XML Schema Authoring]).\n\nThe following example shows the `<meta/>` element in the context of a surrounding `<bean/>`\n(note that, without any logic to interpret it, the metadata is effectively useless\nas it stands).\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <bean id=\"foo\" class=\"x.y.Foo\">\n <meta key=\"cacheName\" value=\"foo\"/> <1>\n <property name=\"name\" value=\"Rick\"/>\n </bean>\n\n\t</beans>\n----\n<1> This is the example `meta` element\n\nIn the case of the preceding example, you could assume that there is some logic that consumes\nthe bean definition and sets up some caching infrastructure that uses the supplied metadata.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc", "title": "xsd-schemas", "heading": "The Beans Schema", "heading_level": 2, "file_order": 30, "section_index": 18, "content_hash": "fe3bae40677c3d74f9401f185d317d5c527b06765c0f153a862115e4bab2fbd9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix/xsd-schemas.adoc"}}
{"id": "sha256:021bd1e4a92838ead1e394f68582aaa44e98c71640a9c02bd9e7bcc3da02bdec", "content": "[[beans-autowired-annotation-primary]]\n\nBecause autowiring by type may lead to multiple candidates, it is often necessary to have\nmore control over the selection process. One way to accomplish this is with Spring's\n`@Primary` annotation. `@Primary` indicates that a particular bean should be given\npreference when multiple beans are candidates to be autowired to a single-valued\ndependency. If exactly one primary bean exists among the candidates, it becomes the\nautowired value.\n\nConsider the following configuration that defines `firstMovieCatalog` as the\nprimary `MovieCatalog`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class MovieConfiguration {\n\n @Bean\n @Primary\n public MovieCatalog firstMovieCatalog() { ... }\n\n @Bean\n public MovieCatalog secondMovieCatalog() { ... }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass MovieConfiguration {\n\n @Bean\n @Primary\n fun firstMovieCatalog(): MovieCatalog { ... }\n\n @Bean\n fun secondMovieCatalog(): MovieCatalog { ... }\n\n // ...\n\t}\n----\n======\n\nAlternatively, as of 6.2, there is a `@Fallback` annotation for demarcating\nany beans other than the regular ones to be injected. If only one regular\nbean is left, it is effectively primary as well:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class MovieConfiguration {\n\n @Bean\n public MovieCatalog firstMovieCatalog() { ... }\n\n @Bean\n @Fallback\n public MovieCatalog secondMovieCatalog() { ... }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass MovieConfiguration {\n\n @Bean\n fun firstMovieCatalog(): MovieCatalog { ... }\n\n @Bean\n @Fallback\n fun secondMovieCatalog(): MovieCatalog { ... }\n\n // ...\n\t}\n----\n======\n\nWith both variants of the preceding configuration, the following\n`MovieRecommender` is autowired with the `firstMovieCatalog`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n @Autowired\n private MovieCatalog movieCatalog;\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nclass MovieRecommender {\n\n\t@Autowired\n\tprivate lateinit var movieCatalog: MovieCatalog\n\n\t// ...\n}\n----\n======\n\nThe corresponding bean definitions follow:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:context=\"http://www.springframework.org/schema/context\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/context\n https://www.springframework.org/schema/context/spring-context.xsd\">\n\n <context:annotation-config/>\n\n <bean class=\"example.SimpleMovieCatalog\" primary=\"true\">\n <!-- inject any dependencies required by this bean -->\n </bean>\n\n <bean class=\"example.SimpleMovieCatalog\">\n <!-- inject any dependencies required by this bean -->\n </bean>\n\n <bean id=\"movieRecommender\" class=\"example.MovieRecommender\"/>\n\n\t</beans>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/annotation-config/autowired-primary.adoc", "title": "autowired-primary", "heading": "autowired-primary", "heading_level": 1, "file_order": 31, "section_index": 0, "content_hash": "021bd1e4a92838ead1e394f68582aaa44e98c71640a9c02bd9e7bcc3da02bdec", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/annotation-config/autowired-primary.adoc"}}
{"id": "sha256:7281e47c234e82ccb81a097a43a4fc4a9a9838b7de72a118d4e81ff379fe3db1", "content": "[[beans-autowired-annotation-qualifiers]]\n\n`@Primary` and `@Fallback` are effective ways to use autowiring by type with several\ninstances when one primary (or non-fallback) candidate can be determined.\n\nWhen you need more control over the selection process, you can use Spring's `@Qualifier`\nannotation. You can associate qualifier values with specific arguments, narrowing the set\nof type matches so that a specific bean is chosen for each argument. In the simplest case,\nthis can be a plain descriptive value, as shown in the following example:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n @Autowired\n @Qualifier(\"main\")\n private MovieCatalog movieCatalog;\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MovieRecommender {\n\n @Autowired\n @Qualifier(\"main\")\n private lateinit var movieCatalog: MovieCatalog\n\n // ...\n\t}\n----\n======\n--\n\nYou can also specify the `@Qualifier` annotation on individual constructor arguments or\nmethod parameters, as shown in the following example:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n private final MovieCatalog movieCatalog;\n\n private final CustomerPreferenceDao customerPreferenceDao;\n\n @Autowired\n public void prepare(@Qualifier(\"main\") MovieCatalog movieCatalog,\n CustomerPreferenceDao customerPreferenceDao) {\n this.movieCatalog = movieCatalog;\n this.customerPreferenceDao = customerPreferenceDao;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MovieRecommender {\n\n private lateinit var movieCatalog: MovieCatalog\n\n private lateinit var customerPreferenceDao: CustomerPreferenceDao\n\n @Autowired\n fun prepare(@Qualifier(\"main\") movieCatalog: MovieCatalog,\n customerPreferenceDao: CustomerPreferenceDao) {\n this.movieCatalog = movieCatalog\n this.customerPreferenceDao = customerPreferenceDao\n }\n\n // ...\n\t}\n----\n======\n--\n\nThe following example shows corresponding bean definitions.\n\n--\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:context=\"http://www.springframework.org/schema/context\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/context\n https://www.springframework.org/schema/context/spring-context.xsd\">\n\n <context:annotation-config/>\n\n <bean class=\"example.SimpleMovieCatalog\">\n <qualifier value=\"main\"/> <1>\n\n <!-- inject any dependencies required by this bean -->\n </bean>\n\n <bean class=\"example.SimpleMovieCatalog\">\n <qualifier value=\"action\"/> <2>\n\n <!-- inject any dependencies required by this bean -->\n </bean>\n\n <bean id=\"movieRecommender\" class=\"example.MovieRecommender\"/>\n\n\t</beans>\n----\n<1> The bean with the `main` qualifier value is wired with the constructor argument that\nis qualified with the same value.\n<2> The bean with the `action` qualifier value is wired with the constructor argument that\nis qualified with the same value.\n--\n\nFor a fallback match, the bean name is considered a default qualifier value. Thus, you\ncan define the bean with an `id` of `main` instead of the nested qualifier element, leading\nto the same matching result. However, although you can use this convention to refer to\nspecific beans by name, `@Autowired` is fundamentally about type-driven injection with\noptional semantic qualifiers. This means that qualifier values, even with the bean name\nfallback, always have narrowing semantics within the set of type matches. They do not\nsemantically express a reference to a unique bean `id`. Good qualifier values are `main`\nor `EMEA` or `persistent`, expressing characteristics of a specific component that are\nindependent from the bean `id`, which may be auto-generated in case of an anonymous bean\ndefinition such as the one in the preceding example.\n\nQualifiers also apply to typed collections, as discussed earlier -- for example, to\n`Set<MovieCatalog>`. In this case, all matching beans, according to the declared\nqualifiers, are injected as a collection. This implies that qualifiers do not have to be\nunique. Rather, they constitute filtering criteria. For example, you can define\nmultiple `MovieCatalog` beans with the same qualifier value \"`action`\", all of which are\ninjected into a `Set<MovieCatalog>` annotated with `@Qualifier(\"action\")`.\n\n[TIP]\n====\nLetting qualifier values select against target bean names, within the type-matching\ncandidates, does not require a `@Qualifier` annotation at the injection point.\nIf there is no other resolution indicator (such as a qualifier or a primary marker),\nfor a non-unique dependency situation, Spring matches the injection point name\n(that is, the field name or parameter name) against the target bean names and chooses\nthe same-named candidate, if any (either by bean name or by associated alias).\n\nSince version 6.1, this requires the `-parameters` Java compiler flag to be present.\nAs of 6.2, the container applies fast shortcut resolution for bean name matches,\nbypassing the full type matching algorithm when the parameter name matches the\nbean name and no type, qualifier or primary conditions override the match. It is\ntherefore recommendable for your parameter names to match the target bean names.\n====\n\nAs an alternative for injection by name, consider the JSR-250 `@Resource` annotation\nwhich is semantically defined to identify a specific target component by its unique name,\nwith the declared type being irrelevant for the matching process. `@Autowired` has rather\ndifferent semantics: after selecting candidate beans by type, the specified `String`\nqualifier value is considered within those type-selected candidates only (for example,\nmatching an `account` qualifier against beans marked with the same qualifier label).\n\nFor beans that are themselves defined as a collection, `Map`, or array type, `@Resource`\nis a fine solution, referring to the specific collection or array bean by unique name.\nThat said, you can match collection, `Map`, and array types through Spring's\n`@Autowired` type matching algorithm as well, as long as the element type information\nis preserved in `@Bean` return type signatures or collection inheritance hierarchies.\nIn this case, you can use qualifier values to select among same-typed collections,\nas outlined in the previous paragraph.\n\n`@Autowired` also considers self references for injection (that is, references back to\nthe bean that is currently injected). See\nxref:core/beans/annotation-config/autowired.adoc#beans-autowired-annotation-self-injection[Self Injection]\nfor details.\n\n`@Autowired` applies to fields, constructors, and multi-argument methods, allowing for\nnarrowing through qualifier annotations at the parameter level. In contrast, `@Resource`\nis supported only for fields and bean property setter methods with a single argument.\nAs a consequence, you should stick with qualifiers if your injection target is a\nconstructor or a multi-argument method.\n\nYou can create your own custom qualifier annotations. To do so, define an annotation and\nprovide the `@Qualifier` annotation within your definition, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target({ElementType.FIELD, ElementType.PARAMETER})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Qualifier\n\tpublic @interface Genre {\n\n String value();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@Qualifier\n\tannotation class Genre(val value: String)\n----\n======\n--\n\nThen you can provide the custom qualifier on autowired fields and parameters, as the\nfollowing example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n @Autowired\n @Genre(\"Action\")\n private MovieCatalog actionCatalog;\n\n private MovieCatalog comedyCatalog;\n\n @Autowired\n public void setComedyCatalog(@Genre(\"Comedy\") MovieCatalog comedyCatalog) {\n this.comedyCatalog = comedyCatalog;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MovieRecommender {\n\n @Autowired\n @Genre(\"Action\")\n private lateinit var actionCatalog: MovieCatalog\n\n private lateinit var comedyCatalog: MovieCatalog\n\n @Autowired\n fun setComedyCatalog(@Genre(\"Comedy\") comedyCatalog: MovieCatalog) {\n this.comedyCatalog = comedyCatalog\n }\n\n // ...\n\t}\n----\n======\n--\n\nNext, you can provide the information for the candidate bean definitions. You can add\n`<qualifier/>` tags as sub-elements of the `<bean/>` tag and then specify the `type` and\n`value` to match your custom qualifier annotations. The type is matched against the\nfully-qualified class name of the annotation. Alternately, as a convenience if no risk of\nconflicting names exists, you can use the short class name. The following example\ndemonstrates both approaches:\n\n--\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:context=\"http://www.springframework.org/schema/context\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/context\n https://www.springframework.org/schema/context/spring-context.xsd\">\n\n <context:annotation-config/>\n\n <bean class=\"example.SimpleMovieCatalog\">\n <qualifier type=\"Genre\" value=\"Action\"/>\n <!-- inject any dependencies required by this bean -->\n </bean>\n\n <bean class=\"example.SimpleMovieCatalog\">\n <qualifier type=\"example.Genre\" value=\"Comedy\"/>\n <!-- inject any dependencies required by this bean -->\n </bean>\n\n <bean id=\"movieRecommender\" class=\"example.MovieRecommender\"/>\n\n\t</beans>\n----\n--\n\nIn xref:core/beans/classpath-scanning.adoc[Classpath Scanning and Managed Components], you can see an annotation-based alternative to\nproviding the qualifier metadata in XML. Specifically, see xref:core/beans/classpath-scanning.adoc#beans-scanning-qualifiers[Providing Qualifier Metadata with Annotations].\n\nIn some cases, using an annotation without a value may suffice. This can be\nuseful when the annotation serves a more generic purpose and can be applied across\nseveral different types of dependencies. For example, you may provide an offline\ncatalog that can be searched when no Internet connection is available. First, define\nthe simple annotation, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target({ElementType.FIELD, ElementType.PARAMETER})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Qualifier\n\tpublic @interface Offline {\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@Qualifier\n\tannotation class Offline\n----\n======\n--\n\nThen add the annotation to the field or property to be autowired, as shown in the\nfollowing example:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n @Autowired\n @Offline // <1>\n private MovieCatalog offlineCatalog;\n\n // ...\n\t}\n----\n<1> This line adds the `@Offline` annotation.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nclass MovieRecommender {\n\n\t@Autowired\n\t@Offline // <1>\n\tprivate lateinit var offlineCatalog: MovieCatalog\n\n\t// ...\n}\n----\n<1> This line adds the `@Offline` annotation.\n======\n--\n\nNow the bean definition only needs a qualifier `type`, as shown in the following example:\n\n--\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean class=\"example.SimpleMovieCatalog\">\n <qualifier type=\"Offline\"/> <1>\n <!-- inject any dependencies required by this bean -->\n\t</bean>\n----\n<1> This element specifies the qualifier.\n--\n\nYou can also define custom qualifier annotations that accept named attributes in\naddition to or instead of the simple `value` attribute. If multiple attribute values are\nthen specified on a field or parameter to be autowired, a bean definition must match\nall such attribute values to be considered an autowire candidate. As an example,\nconsider the following annotation definition:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target({ElementType.FIELD, ElementType.PARAMETER})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Qualifier\n\tpublic @interface MovieQualifier {\n\n String genre();\n\n Format format();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@Qualifier\n\tannotation class MovieQualifier(val genre: String, val format: Format)\n----\n======\n--\n\nIn this case `Format` is an enum, defined as follows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic enum Format {\n VHS, DVD, BLURAY\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tenum class Format {\n VHS, DVD, BLURAY\n\t}\n----\n======\n--\n\nThe fields to be autowired are annotated with the custom qualifier and include values\nfor both attributes: `genre` and `format`, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n @Autowired\n @MovieQualifier(format=Format.VHS, genre=\"Action\")\n private MovieCatalog actionVhsCatalog;\n\n @Autowired\n @MovieQualifier(format=Format.VHS, genre=\"Comedy\")\n private MovieCatalog comedyVhsCatalog;\n\n @Autowired\n @MovieQualifier(format=Format.DVD, genre=\"Action\")\n private MovieCatalog actionDvdCatalog;\n\n @Autowired\n @MovieQualifier(format=Format.BLURAY, genre=\"Comedy\")\n private MovieCatalog comedyBluRayCatalog;\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MovieRecommender {\n\n @Autowired\n @MovieQualifier(format = Format.VHS, genre = \"Action\")\n private lateinit var actionVhsCatalog: MovieCatalog\n\n @Autowired\n @MovieQualifier(format = Format.VHS, genre = \"Comedy\")\n private lateinit var comedyVhsCatalog: MovieCatalog\n\n @Autowired\n @MovieQualifier(format = Format.DVD, genre = \"Action\")\n private lateinit var actionDvdCatalog: MovieCatalog\n\n @Autowired\n @MovieQualifier(format = Format.BLURAY, genre = \"Comedy\")\n private lateinit var comedyBluRayCatalog: MovieCatalog\n\n // ...\n\t}\n----\n======\n--\n\nFinally, the bean definitions should contain matching qualifier values. This example\nalso demonstrates that you can use bean meta attributes instead of the\n`<qualifier/>` elements. If available, the `<qualifier/>` element and its attributes take\nprecedence, but the autowiring mechanism falls back on the values provided within the\n`<meta/>` tags if no such qualifier is present, as in the last two bean definitions in\nthe following example:\n\n--\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:context=\"http://www.springframework.org/schema/context\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/context\n https://www.springframework.org/schema/context/spring-context.xsd\">\n\n <context:annotation-config/>\n\n <bean class=\"example.SimpleMovieCatalog\">\n <qualifier type=\"MovieQualifier\">\n <attribute key=\"format\" value=\"VHS\"/>\n <attribute key=\"genre\" value=\"Action\"/>\n </qualifier>\n <!-- inject any dependencies required by this bean -->\n </bean>\n\n <bean class=\"example.SimpleMovieCatalog\">\n <qualifier type=\"MovieQualifier\">\n <attribute key=\"format\" value=\"VHS\"/>\n <attribute key=\"genre\" value=\"Comedy\"/>\n </qualifier>\n <!-- inject any dependencies required by this bean -->\n </bean>\n\n <bean class=\"example.SimpleMovieCatalog\">\n <meta key=\"format\" value=\"DVD\"/>\n <meta key=\"genre\" value=\"Action\"/>\n <!-- inject any dependencies required by this bean -->\n </bean>\n\n <bean class=\"example.SimpleMovieCatalog\">\n <meta key=\"format\" value=\"BLURAY\"/>\n <meta key=\"genre\" value=\"Comedy\"/>\n <!-- inject any dependencies required by this bean -->\n </bean>\n\n\t</beans>\n----\n--", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/annotation-config/autowired-qualifiers.adoc", "title": "autowired-qualifiers", "heading": "autowired-qualifiers", "heading_level": 1, "file_order": 32, "section_index": 0, "content_hash": "7281e47c234e82ccb81a097a43a4fc4a9a9838b7de72a118d4e81ff379fe3db1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/annotation-config/autowired-qualifiers.adoc"}}
{"id": "sha256:8aa3e1949175c997d9e6d76f0da43062b708069ec18c0ff75826a3e3db7cee48", "content": "[[beans-autowired-annotation]]\n\n[NOTE]\n====\nJSR 330's `@Inject` annotation can be used in place of Spring's `@Autowired` annotation in the\nexamples included in this section. See xref:core/beans/standard-annotations.adoc[here] for more details.\n====\n\nYou can apply the `@Autowired` annotation to constructors, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n private final CustomerPreferenceDao customerPreferenceDao;\n\n @Autowired\n public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {\n this.customerPreferenceDao = customerPreferenceDao;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MovieRecommender @Autowired constructor(\n private val customerPreferenceDao: CustomerPreferenceDao)\n----\n======\n\n[TIP]\n====\nAn `@Autowired` annotation on such a constructor is not necessary if the target bean\ndefines only one constructor. However, if several constructors are available and there is\nno primary or default constructor, at least one of the constructors must be annotated\nwith `@Autowired` in order to instruct the container which one to use. See the discussion\non xref:core/beans/annotation-config/autowired.adoc#beans-autowired-annotation-constructor-resolution[constructor resolution]\nfor details.\n====\n\nYou can apply the `@Autowired` annotation to _traditional_ setter methods, as the\nfollowing example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SimpleMovieLister {\n\n private MovieFinder movieFinder;\n\n @Autowired\n public void setMovieFinder(MovieFinder movieFinder) {\n this.movieFinder = movieFinder;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass SimpleMovieLister {\n\n @set:Autowired\n lateinit var movieFinder: MovieFinder\n\n // ...\n\n\t}\n----\n======\n\nYou can apply `@Autowired` to methods with arbitrary names and multiple arguments, as the\nfollowing example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n private MovieCatalog movieCatalog;\n\n private CustomerPreferenceDao customerPreferenceDao;\n\n @Autowired\n public void prepare(MovieCatalog movieCatalog,\n CustomerPreferenceDao customerPreferenceDao) {\n this.movieCatalog = movieCatalog;\n this.customerPreferenceDao = customerPreferenceDao;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MovieRecommender {\n\n private lateinit var movieCatalog: MovieCatalog\n\n private lateinit var customerPreferenceDao: CustomerPreferenceDao\n\n @Autowired\n fun prepare(movieCatalog: MovieCatalog,\n customerPreferenceDao: CustomerPreferenceDao) {\n this.movieCatalog = movieCatalog\n this.customerPreferenceDao = customerPreferenceDao\n }\n\n // ...\n\t}\n----\n======\n\nYou can apply `@Autowired` to fields as well and even mix it with constructors, as the\nfollowing example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n private final CustomerPreferenceDao customerPreferenceDao;\n\n @Autowired\n private MovieCatalog movieCatalog;\n\n @Autowired\n public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {\n this.customerPreferenceDao = customerPreferenceDao;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MovieRecommender @Autowired constructor(\n private val customerPreferenceDao: CustomerPreferenceDao) {\n\n @Autowired\n private lateinit var movieCatalog: MovieCatalog\n\n // ...\n\t}\n----\n======\n\n[TIP]\n====\nMake sure that your target components (for example, `MovieCatalog` or `CustomerPreferenceDao`)\nare consistently declared by the type that you use for your `@Autowired`-annotated\ninjection points. Otherwise, injection may fail due to a \"no type match found\" error at\nruntime.\n\nFor XML-defined beans or component classes found via classpath scanning, the container\nusually knows the concrete type up front. However, for `@Bean` factory methods, you need\nto make sure that the declared return type is sufficiently expressive. For components\nthat implement several interfaces or for components potentially referred to by their\nimplementation type, declare the most specific return type on your factory method (at\nleast as specific as required by the injection points referring to your bean).\n====\n\n.[[beans-autowired-annotation-self-injection]]Self Injection\n****\n`@Autowired` also considers self references for injection (that is, references back to\nthe bean that is currently injected).\n\nNote, however, that self injection is a fallback mechanism. Regular dependencies on other\ncomponents always have precedence. In that sense, self references do not participate in\nregular autowiring candidate selection and are therefore in particular never primary. On\nthe contrary, they always end up as lowest precedence.\n\nIn practice, you should use self references as a last resort only â€“ for example, for\ncalling other methods on the same instance through the bean's transactional proxy. As an\nalternative, consider factoring out the affected methods to a separate delegate bean in\nsuch a scenario.\n\nAnother alternative is to use `@Resource`, which may obtain a proxy back to the current\nbean by its unique name.\n\n======\n[NOTE]\n====\nTrying to inject the results from `@Bean` methods in the same `@Configuration` class is\neffectively a self-reference scenario as well. Either lazily resolve such references\nin the method signature where it is actually needed (as opposed to an autowired field\nin the configuration class) or declare the affected `@Bean` methods as `static`,\ndecoupling them from the containing configuration class instance and its lifecycle.\nOtherwise, such beans are only considered in the fallback phase, with matching beans\non other configuration classes selected as primary candidates instead (if available).\n====\n======\n****\n\nYou can also instruct Spring to provide all beans of a particular type from the\n`ApplicationContext` by adding the `@Autowired` annotation to a field or method that\nexpects an array of that type, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n @Autowired\n private MovieCatalog[] movieCatalogs;\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MovieRecommender {\n\n @Autowired\n private lateinit var movieCatalogs: Array<MovieCatalog>\n\n // ...\n\t}\n----\n======\n\nThe same applies for typed collections, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n private Set<MovieCatalog> movieCatalogs;\n\n @Autowired\n public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {\n this.movieCatalogs = movieCatalogs;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MovieRecommender {\n\n @Autowired\n lateinit var movieCatalogs: Set<MovieCatalog>\n\n // ...\n\t}\n----\n======\n\n[[beans-factory-ordered]]\n[TIP]\n====\nYour target beans can implement the `org.springframework.core.Ordered` interface or use\nthe `@Order` or standard `@Priority` annotation if you want items in the array or list\nto be sorted in a specific order. Otherwise, their order follows the registration\norder of the corresponding target bean definitions in the container.\n\nYou can declare the `@Order` annotation at the target class level and on `@Bean` methods,\npotentially for individual bean definitions (in case of multiple definitions that\nuse the same bean class). `@Order` values may influence priorities at injection points,\nbut be aware that they do not influence singleton startup order, which is an\northogonal concern determined by dependency relationships and `@DependsOn` declarations.\n\nNote that `@Order` annotations on configuration classes just influence the evaluation\norder within the overall set of configuration classes on startup. Such configuration-level\norder values do not affect the contained `@Bean` methods at all. For bean-level ordering,\neach `@Bean` method needs to have its own `@Order` annotation which applies within a\nset of multiple matches for the specific bean type (as returned by the factory method).\n\nNote that the standard `jakarta.annotation.Priority` annotation is not available at the\n`@Bean` level, since it cannot be declared on methods. Its semantics can be modeled\nthrough `@Order` values in combination with `@Primary` on a single bean for each type.\n====\n\nEven typed `Map` instances can be autowired as long as the expected key type is `String`.\nThe map values are all beans of the expected type, and the keys are the corresponding\nbean names, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n private Map<String, MovieCatalog> movieCatalogs;\n\n @Autowired\n public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {\n this.movieCatalogs = movieCatalogs;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MovieRecommender {\n\n @Autowired\n lateinit var movieCatalogs: Map<String, MovieCatalog>\n\n // ...\n\t}\n----\n======\n\nBy default, autowiring fails when no matching candidate beans are available for a given\ninjection point. In the case of a declared array, collection, or map, at least one\nmatching element is expected.\n\nThe default behavior is to treat annotated methods and fields as indicating required\ndependencies. You can change this behavior as demonstrated in the following example,\nenabling the framework to skip a non-satisfiable injection point through marking it as\nnon-required (i.e., by setting the `required` attribute in `@Autowired` to `false`):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SimpleMovieLister {\n\n private MovieFinder movieFinder;\n\n @Autowired(required = false)\n public void setMovieFinder(MovieFinder movieFinder) {\n this.movieFinder = movieFinder;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass SimpleMovieLister {\n\n @Autowired(required = false)\n var movieFinder: MovieFinder? = null\n\n // ...\n\t}\n----\n======\n\n[NOTE]\n====\nA non-required method will not be called at all if its dependency (or one of its\ndependencies, in case of multiple arguments) is not available. A non-required field will\nnot get populated at all in such cases, leaving its default value in place.\n\nIn other words, setting the `required` attribute to `false` indicates that the\ncorresponding property is _optional_ for autowiring purposes, and the property will be\nignored if it cannot be autowired. This allows properties to be assigned default values\nthat can be optionally overridden via dependency injection.\n====\n\n[[beans-autowired-annotation-constructor-resolution]]\nInjected constructor and factory method arguments are a special case since the `required`\nattribute in `@Autowired` has a somewhat different meaning due to Spring's constructor\nresolution algorithm that may potentially deal with multiple constructors. Constructor\nand factory method arguments are effectively required by default but with a few special\nrules in a single-constructor scenario, such as multi-element injection points (arrays,\ncollections, maps) resolving to empty instances if no matching beans are available. This\nallows for a common implementation pattern where all dependencies can be declared in a\nunique multi-argument constructor â€” for example, declared as a single public constructor\nwithout an `@Autowired` annotation.\n\n[NOTE]\n====\nOnly one constructor of any given bean class may declare `@Autowired` with the `required`\nattribute set to `true`, indicating _the_ constructor to autowire when used as a Spring\nbean. As a consequence, if the `required` attribute is left at its default value `true`,\nonly a single constructor may be annotated with `@Autowired`. If multiple constructors\ndeclare the annotation, they will all have to declare `required=false` in order to be\nconsidered as candidates for autowiring (analogous to `autowire=constructor` in XML).\nThe constructor with the greatest number of dependencies that can be satisfied by matching\nbeans in the Spring container will be chosen. If none of the candidates can be satisfied,\nthen a primary/default constructor (if present) will be used. Similarly, if a class\ndeclares multiple constructors but none of them is annotated with `@Autowired`, then a\nprimary/default constructor (if present) will be used. If a class only declares a single\nconstructor to begin with, it will always be used, even if not annotated. Note that an\nannotated constructor does not have to be public.\n====\n\nAlternatively, you can express the non-required nature of a particular dependency\nthrough Java's `java.util.Optional`, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SimpleMovieLister {\n\n @Autowired\n public void setMovieFinder(Optional<MovieFinder> movieFinder) {\n ...\n }\n\t}\n----\n\nYou can also use a parameter-level `@Nullable` annotation (of any kind in any package --\nfor example, `org.jspecify.annotations.Nullable` from JSpecify) or just leverage Kotlin's\nbuilt-in null-safety support:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SimpleMovieLister {\n\n @Autowired\n public void setMovieFinder(@Nullable MovieFinder movieFinder) {\n ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass SimpleMovieLister {\n\n @Autowired\n var movieFinder: MovieFinder? = null\n\n // ...\n\t}\n----\n======\n\nYou can also use `@Autowired` for interfaces that are well-known resolvable\ndependencies: `BeanFactory`, `ApplicationContext`, `Environment`, `ResourceLoader`,\n`ApplicationEventPublisher`, and `MessageSource`. These interfaces and their extended\ninterfaces, such as `ConfigurableApplicationContext` or `ResourcePatternResolver`, are\nautomatically resolved, with no special setup necessary. The following example autowires\nan `ApplicationContext` object:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n @Autowired\n private ApplicationContext context;\n\n public MovieRecommender() {\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nclass MovieRecommender {\n\n\t@Autowired\n\tlateinit var context: ApplicationContext\n\n\t// ...\n}\n----\n======\n\n[NOTE]\n====\nThe `@Autowired`, `@Inject`, `@Value`, and `@Resource` annotations are handled by Spring\n`BeanPostProcessor` implementations. This means that you cannot apply these annotations\nwithin your own `BeanPostProcessor` or `BeanFactoryPostProcessor` types (if any).\n\nThese types must be 'wired up' explicitly by using XML or a Spring `@Bean` method.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/annotation-config/autowired.adoc", "title": "autowired", "heading": "autowired", "heading_level": 1, "file_order": 33, "section_index": 0, "content_hash": "8aa3e1949175c997d9e6d76f0da43062b708069ec18c0ff75826a3e3db7cee48", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/annotation-config/autowired.adoc"}}
{"id": "sha256:28cc8bfa8f5507dfef121812b2ebb6c24a4ebf4eea6e9bce86d6bc5b7fee0ad7", "content": "[[beans-custom-autowire-configurer]]\n\n{spring-framework-api}/beans/factory/annotation/CustomAutowireConfigurer.html[`CustomAutowireConfigurer`]\nis a `BeanFactoryPostProcessor` that lets you register your own custom qualifier\nannotation types, even if they are not annotated with Spring's `@Qualifier` annotation.\nThe following example shows how to use `CustomAutowireConfigurer`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"customAutowireConfigurer\"\n class=\"org.springframework.beans.factory.annotation.CustomAutowireConfigurer\">\n <property name=\"customQualifierTypes\">\n <set>\n <value>example.CustomQualifier</value>\n </set>\n </property>\n\t</bean>\n----\n\nThe `AutowireCandidateResolver` determines autowire candidates by:\n\n* The `autowire-candidate` value of each bean definition\n* Any `default-autowire-candidates` patterns available on the `<beans/>` element\n* The presence of `@Qualifier` annotations and any custom annotations registered\nwith the `CustomAutowireConfigurer`\n\nWhen multiple beans qualify as autowire candidates, the determination of a \"`primary`\" is\nas follows: If exactly one bean definition among the candidates has a `primary`\nattribute set to `true`, it is selected.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/annotation-config/custom-autowire-configurer.adoc", "title": "custom-autowire-configurer", "heading": "custom-autowire-configurer", "heading_level": 1, "file_order": 34, "section_index": 0, "content_hash": "28cc8bfa8f5507dfef121812b2ebb6c24a4ebf4eea6e9bce86d6bc5b7fee0ad7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/annotation-config/custom-autowire-configurer.adoc"}}
{"id": "sha256:4294ac53128d3c9b50c3561614192aa1c4dcf9d2653a0865fab12d6a0302e410", "content": "[[beans-generics-as-qualifiers]]\n\nIn addition to the `@Qualifier` annotation, you can use Java generic types\nas an implicit form of qualification. For example, suppose you have the following\nconfiguration:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class MyConfiguration {\n\n @Bean\n public StringStore stringStore() {\n return new StringStore();\n }\n\n @Bean\n public IntegerStore integerStore() {\n return new IntegerStore();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass MyConfiguration {\n\n @Bean\n fun stringStore() = StringStore()\n\n @Bean\n fun integerStore() = IntegerStore()\n\t}\n----\n======\n\nAssuming that the preceding beans implement a generic interface, (that is, `Store<String>` and\n`Store<Integer>`), you can `@Autowire` the `Store` interface and the generic is\nused as a qualifier, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Autowired\n\tprivate Store<String> s1; // <String> qualifier, injects the stringStore bean\n\n\t@Autowired\n\tprivate Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Autowired\n\tprivate lateinit var s1: Store<String> // <String> qualifier, injects the stringStore bean\n\n\t@Autowired\n\tprivate lateinit var s2: Store<Integer> // <Integer> qualifier, injects the integerStore bean\n----\n======\n\nGeneric qualifiers also apply when autowiring lists, `Map` instances and arrays. The\nfollowing example autowires a generic `List`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Inject all Store beans as long as they have an <Integer> generic\n\t// Store<String> beans will not appear in this list\n\t@Autowired\n\tprivate List<Store<Integer>> s;\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Inject all Store beans as long as they have an <Integer> generic\n\t// Store<String> beans will not appear in this list\n\t@Autowired\n\tprivate lateinit var s: List<Store<Integer>>\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/annotation-config/generics-as-qualifiers.adoc", "title": "generics-as-qualifiers", "heading": "generics-as-qualifiers", "heading_level": 1, "file_order": 35, "section_index": 0, "content_hash": "4294ac53128d3c9b50c3561614192aa1c4dcf9d2653a0865fab12d6a0302e410", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/annotation-config/generics-as-qualifiers.adoc"}}
{"id": "sha256:52c91cdbd0538c78a16cd7a590f48940f7b5a82f642d5d55fd34f1897c7d5021", "content": "[[beans-postconstruct-and-predestroy-annotations]]\n\nThe `CommonAnnotationBeanPostProcessor` not only recognizes the `@Resource` annotation\nbut also the JSR-250 lifecycle annotations: `jakarta.annotation.PostConstruct` and\n`jakarta.annotation.PreDestroy`. Introduced in Spring 2.5, the support for these\nannotations offers an alternative to the lifecycle callback mechanism described in\nxref:core/beans/factory-nature.adoc#beans-factory-lifecycle-initializingbean[initialization callbacks] and\nxref:core/beans/factory-nature.adoc#beans-factory-lifecycle-disposablebean[destruction callbacks]. Provided that the\n`CommonAnnotationBeanPostProcessor` is registered within the Spring `ApplicationContext`,\na method carrying one of these annotations is invoked at the same point in the lifecycle\nas the corresponding Spring lifecycle interface method or explicitly declared callback\nmethod. In the following example, the cache is pre-populated upon initialization and\ncleared upon destruction:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class CachingMovieLister {\n\n @PostConstruct\n public void populateMovieCache() {\n // populates the movie cache upon initialization...\n }\n\n @PreDestroy\n public void clearMovieCache() {\n // clears the movie cache upon destruction...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass CachingMovieLister {\n\n @PostConstruct\n fun populateMovieCache() {\n // populates the movie cache upon initialization...\n }\n\n @PreDestroy\n fun clearMovieCache() {\n // clears the movie cache upon destruction...\n }\n\t}\n----\n======\n\nFor details about the effects of combining various lifecycle mechanisms, see\nxref:core/beans/factory-nature.adoc#beans-factory-lifecycle-combined-effects[Combining Lifecycle Mechanisms].\n\n[NOTE]\n====\nLike `@Resource`, the `@PostConstruct` and `@PreDestroy` annotation types were a part\nof the standard Java libraries from JDK 6 to 8. However, the entire `javax.annotation`\npackage got separated from the core Java modules in JDK 9 and eventually removed in\nJDK 11. As of Jakarta EE 9, the package lives in `jakarta.annotation` now. If needed,\nthe `jakarta.annotation-api` artifact needs to be obtained via Maven Central now,\nsimply to be added to the application's classpath like any other library.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc", "title": "postconstruct-and-predestroy-annotations", "heading": "postconstruct-and-predestroy-annotations", "heading_level": 1, "file_order": 36, "section_index": 0, "content_hash": "52c91cdbd0538c78a16cd7a590f48940f7b5a82f642d5d55fd34f1897c7d5021", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc"}}
{"id": "sha256:5e0a482e3e90abce5a1e50be5be2f5c64f411f915649d251dcc4663a7a6d6c27", "content": "[[beans-resource-annotation]]\n\nSpring also supports injection by using the JSR-250 `@Resource` annotation\n(`jakarta.annotation.Resource`) on fields or bean property setter methods.\nThis is a common pattern in Jakarta EE: for example, in JSF-managed beans and JAX-WS\nendpoints. Spring supports this pattern for Spring-managed objects as well.\n\n`@Resource` takes a name attribute. By default, Spring interprets that value as\nthe bean name to be injected. In other words, it follows by-name semantics,\nas demonstrated in the following example:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SimpleMovieLister {\n\n private MovieFinder movieFinder;\n\n @Resource(name=\"myMovieFinder\") // <1>\n public void setMovieFinder(MovieFinder movieFinder) {\n this.movieFinder = movieFinder;\n }\n\t}\n----\n<1> This line injects a `@Resource`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nclass SimpleMovieLister {\n\n\t@Resource(name=\"myMovieFinder\") // <1>\n\tprivate lateinit var movieFinder:MovieFinder\n}\n----\n<1> This line injects a `@Resource`.\n======\n--\n\nIf no name is explicitly specified, the default name is derived from the field name or\nsetter method. In case of a field, it takes the field name. In case of a setter method,\nit takes the bean property name. The following example is going to have the bean\nnamed `movieFinder` injected into its setter method:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SimpleMovieLister {\n\n private MovieFinder movieFinder;\n\n @Resource\n public void setMovieFinder(MovieFinder movieFinder) {\n this.movieFinder = movieFinder;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass SimpleMovieLister {\n\n @set:Resource\n private lateinit var movieFinder: MovieFinder\n\n\t}\n----\n======\n--\n\nNOTE: The name provided with the annotation is resolved as a bean name by the\n`ApplicationContext` of which the `CommonAnnotationBeanPostProcessor` is aware.\nThe names can be resolved through JNDI if you configure Spring's\n{spring-framework-api}/jndi/support/SimpleJndiBeanFactory.html[`SimpleJndiBeanFactory`]\nexplicitly. However, we recommend that you rely on the default behavior and\nuse Spring's JNDI lookup capabilities to preserve the level of indirection.\n\nIn the exclusive case of `@Resource` usage with no explicit name specified, and similar\nto `@Autowired`, `@Resource` finds a primary type match instead of a specific named bean\nand resolves well known resolvable dependencies: the `BeanFactory`,\n`ApplicationContext`, `ResourceLoader`, `ApplicationEventPublisher`, and `MessageSource`\ninterfaces.\n\nThus, in the following example, the `customerPreferenceDao` field first looks for a bean\nnamed \"customerPreferenceDao\" and then falls back to a primary type match for the type\n`CustomerPreferenceDao`:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MovieRecommender {\n\n @Resource\n private CustomerPreferenceDao customerPreferenceDao;\n\n @Resource\n private ApplicationContext context; // <1>\n\n public MovieRecommender() {\n }\n\n // ...\n\t}\n----\n<1> The `context` field is injected based on the known resolvable dependency type:\n`ApplicationContext`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MovieRecommender {\n\n @Resource\n private lateinit var customerPreferenceDao: CustomerPreferenceDao\n\n @Resource\n private lateinit var context: ApplicationContext // <1>\n\n // ...\n\t}\n----\n<1> The `context` field is injected based on the known resolvable dependency type:\n`ApplicationContext`.\n======\n--", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/annotation-config/resource.adoc", "title": "resource", "heading": "resource", "heading_level": 1, "file_order": 37, "section_index": 0, "content_hash": "5e0a482e3e90abce5a1e50be5be2f5c64f411f915649d251dcc4663a7a6d6c27", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/annotation-config/resource.adoc"}}
{"id": "sha256:abe4d627a570854b8bef64eb430a9b2df168b240fb758967637264fe72d0dd5e", "content": "[[beans-value-annotations]]\n\n`@Value` is typically used to inject externalized properties:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tpublic class MovieRecommender {\n\n private final String catalog;\n\n public MovieRecommender(@Value(\"${catalog.name}\") String catalog) {\n this.catalog = catalog;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tclass MovieRecommender(@Value(\"\\${catalog.name}\") private val catalog: String)\n----\n======\n\nWith the following configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@PropertySource(\"classpath:application.properties\")\n\tpublic class AppConfig { }\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@PropertySource(\"classpath:application.properties\")\n\tclass AppConfig\n----\n======\n\nAnd the following `application.properties` file:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tcatalog.name=MovieCatalog\n----\n\nIn that case, the `catalog` parameter and field will be equal to the `MovieCatalog` value.\n\nA default lenient embedded value resolver is provided by Spring. It will try to resolve the\nproperty value and if it cannot be resolved, the property name (for example `${catalog.name}`)\nwill be injected as the value. If you want to maintain strict control over nonexistent\nvalues, you should declare a `PropertySourcesPlaceholderConfigurer` bean, as the following\nexample shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean\n public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {\n return new PropertySourcesPlaceholderConfigurer();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean\n fun propertyPlaceholderConfigurer() = PropertySourcesPlaceholderConfigurer()\n\t}\n----\n======\n\nNOTE: When configuring a `PropertySourcesPlaceholderConfigurer` using JavaConfig, the\n`@Bean` method must be `static`.\n\nUsing the above configuration ensures Spring initialization failure if any `${}`\nplaceholder could not be resolved. It is also possible to use methods like\n`setPlaceholderPrefix()`, `setPlaceholderSuffix()`, `setValueSeparator()`, or\n`setEscapeCharacter()` to customize the placeholder syntax. In addition, the default\nescape character can be changed or disabled globally by setting the\n`spring.placeholder.escapeCharacter.default` property via a JVM system property (or via\nthe xref:appendix.adoc#appendix-spring-properties[`SpringProperties`] mechanism).\n\nNOTE: Spring Boot configures by default a `PropertySourcesPlaceholderConfigurer` bean that\nwill get properties from `application.properties` and `application.yml` files.\n\nBuilt-in converter support provided by Spring allows simple type conversion (to `Integer`\nor `int` for example) to be automatically handled. Multiple comma-separated values can be\nautomatically converted to `String` array without extra effort.\n\nIt is possible to provide a default value as following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tpublic class MovieRecommender {\n\n private final String catalog;\n\n public MovieRecommender(@Value(\"${catalog.name:defaultCatalog}\") String catalog) {\n this.catalog = catalog;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tclass MovieRecommender(@Value(\"\\${catalog.name:defaultCatalog}\") private val catalog: String)\n----\n======\n\nA Spring `BeanPostProcessor` uses a `ConversionService` behind the scenes to handle the\nprocess for converting the `String` value in `@Value` to the target type. If you want to\nprovide conversion support for your own custom type, you can provide your own\n`ConversionService` bean instance as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean\n public ConversionService conversionService() {\n DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();\n conversionService.addConverter(new MyCustomConverter());\n return conversionService;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean\n fun conversionService(): ConversionService {\n return DefaultFormattingConversionService().apply {\n addConverter(MyCustomConverter())\n }\n }\n\t}\n----\n======\n\nWhen `@Value` contains a xref:core/expressions.adoc[`SpEL` expression] the value will be dynamically\ncomputed at runtime as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tpublic class MovieRecommender {\n\n private final String catalog;\n\n public MovieRecommender(@Value(\"#{systemProperties['user.catalog'] + 'Catalog' }\") String catalog) {\n this.catalog = catalog;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tclass MovieRecommender(\n @Value(\"#{systemProperties['user.catalog'] + 'Catalog' }\") private val catalog: String)\n----\n======\n\nSpEL also enables the use of more complex data structures:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tpublic class MovieRecommender {\n\n private final Map<String, Integer> countOfMoviesPerCatalog;\n\n public MovieRecommender(\n @Value(\"#{{'Thriller': 100, 'Comedy': 300}}\") Map<String, Integer> countOfMoviesPerCatalog) {\n this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tclass MovieRecommender(\n @Value(\"#{{'Thriller': 100, 'Comedy': 300}}\") private val countOfMoviesPerCatalog: Map<String, Int>)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/annotation-config/value-annotations.adoc", "title": "value-annotations", "heading": "value-annotations", "heading_level": 1, "file_order": 38, "section_index": 0, "content_hash": "abe4d627a570854b8bef64eb430a9b2df168b240fb758967637264fe72d0dd5e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/annotation-config/value-annotations.adoc"}}
{"id": "sha256:d3c89d34f9e1b5e81a86a94c5a235aded15630ed77eba9a975b96df0f2b8ce6a", "content": "[[beans-factory-autowire]]\n\nThe Spring container can autowire relationships between collaborating beans. You can\nlet Spring resolve collaborators (other beans) automatically for your bean by\ninspecting the contents of the `ApplicationContext`. Autowiring has the following\nadvantages:\n\n* Autowiring can significantly reduce the need to specify properties or constructor\n arguments. (Other mechanisms such as a bean template\n xref:core/beans/child-bean-definitions.adoc[discussed elsewhere in this chapter] are also valuable\n in this regard.)\n* Autowiring can update a configuration as your objects evolve. For example, if you need\n to add a dependency to a class, that dependency can be satisfied automatically without\n you needing to modify the configuration. Thus autowiring can be especially useful\n during development, without negating the option of switching to explicit wiring when\n the code base becomes more stable.\n\nWhen using XML-based configuration metadata (see\nxref:core/beans/dependencies/factory-collaborators.adoc[Dependency Injection]), you\ncan specify the autowire mode for a bean definition with the `autowire` attribute of the\n`<bean/>` element. The autowiring functionality has four modes. You specify autowiring\nper bean and can thus choose which ones to autowire. The following table describes the\nfour autowiring modes:\n\n[[beans-factory-autowiring-modes-tbl]]\n.Autowiring modes\n[cols=\"20%,80%\"]\n|===\n| Mode| Explanation\n\n| `no`\n| (Default) No autowiring. Bean references must be defined by `ref` elements. Changing\n the default setting is not recommended for larger deployments, because specifying\n collaborators explicitly gives greater control and clarity. To some extent, it\n documents the structure of a system.\n\n| `byName`\n| Autowiring by property name. Spring looks for a bean with the same name as the\n property that needs to be autowired. For example, if a bean definition is set to\n autowire by name and it contains a `master` property (that is, it has a\n `setMaster(..)` method), Spring looks for a bean definition named `master` and uses\n it to set the property.\n\n| `byType`\n| Lets a property be autowired if exactly one bean of the property type exists in\n the container. If more than one exists, a fatal exception is thrown, which indicates\n that you may not use `byType` autowiring for that bean. If there are no matching\n beans, nothing happens (the property is not set).\n\n| `constructor`\n| Analogous to `byType` but applies to constructor arguments. If there is not exactly\n one bean of the constructor argument type in the container, a fatal error is raised.\n|===\n\nWith `byType` or `constructor` autowiring mode, you can wire arrays and\ntyped collections. In such cases, all autowire candidates within the container that\nmatch the expected type are provided to satisfy the dependency. You can autowire\nstrongly-typed `Map` instances if the expected key type is `String`. An autowired `Map`\ninstance's values consist of all bean instances that match the expected type, and the\n`Map` instance's keys contain the corresponding bean names.\n\n[[beans-autowired-exceptions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-autowire.adoc", "title": "factory-autowire", "heading": "factory-autowire", "heading_level": 1, "file_order": 39, "section_index": 0, "content_hash": "d3c89d34f9e1b5e81a86a94c5a235aded15630ed77eba9a975b96df0f2b8ce6a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-autowire.adoc"}}
{"id": "sha256:524349694b337ab9a4fb2e77b1df58115e8f2ba974921d6c47b0491e6ffdf76f", "content": "Autowiring works best when it is used consistently across a project. If autowiring is\nnot used in general, it might be confusing to developers to use it to wire only one or\ntwo bean definitions.\n\nConsider the limitations and disadvantages of autowiring:\n\n* Explicit dependencies in `property` and `constructor-arg` settings always override\n autowiring. You cannot autowire simple properties such as primitives,\n `Strings`, and `Classes` (and arrays of such simple properties). This limitation is\n by-design.\n* Autowiring is less exact than explicit wiring. Although, as noted in the earlier table,\n Spring is careful to avoid guessing in case of ambiguity that might have unexpected\n results. The relationships between your Spring-managed objects are no longer\n documented explicitly.\n* Wiring information may not be available to tools that may generate documentation from\n a Spring container.\n* Multiple bean definitions within the container may match the type specified by the\n setter method or constructor argument to be autowired. For arrays, collections, or\n `Map` instances, this is not necessarily a problem. However, for dependencies that\n expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean\n definition is available, an exception is thrown.\n\nIn the latter scenario, you have several options:\n\n* Abandon autowiring in favor of explicit wiring.\n* Avoid autowiring for a bean definition by setting its `autowire-candidate` attributes\n to `false`, as described in the\n xref:core/beans/dependencies/factory-autowire.adoc#beans-factory-autowire-candidate[next section].\n* Designate a single bean definition as the primary candidate by setting the\n `primary` attribute of its `<bean/>` element to `true`.\n* Implement the more fine-grained control available with annotation-based configuration,\n as described in xref:core/beans/annotation-config.adoc[Annotation-based Container Configuration].\n\n[[beans-factory-autowire-candidate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-autowire.adoc", "title": "factory-autowire", "heading": "Limitations and Disadvantages of Autowiring", "heading_level": 2, "file_order": 39, "section_index": 1, "content_hash": "524349694b337ab9a4fb2e77b1df58115e8f2ba974921d6c47b0491e6ffdf76f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-autowire.adoc"}}
{"id": "sha256:28de79ff617fae9e64ebc4caddb0df083bde36222882e121302c1ffc3e9db4a3", "content": "On a per-bean basis, you can exclude a bean from autowiring. In Spring's XML format, set\nthe `autowire-candidate` attribute of the `<bean/>` element to `false`; with the `@Bean`\nannotation, the attribute is named `autowireCandidate`. The container makes that specific\nbean definition unavailable to the autowiring infrastructure, including annotation-based\ninjection points such as xref:core/beans/annotation-config/autowired.adoc[`@Autowired`].\n\nNOTE: The `autowire-candidate` attribute is designed to only affect type-based autowiring.\nIt does not affect explicit references by name, which get resolved even if the\nspecified bean is not marked as an autowire candidate. As a consequence, autowiring\nby name nevertheless injects a bean if the name matches.\n\nYou can also limit autowire candidates based on pattern-matching against bean names. The\ntop-level `<beans/>` element accepts one or more patterns within its\n`default-autowire-candidates` attribute. For example, to limit autowire candidate status\nto any bean whose name ends with `Repository`, provide a value of `*Repository`. To\nprovide multiple patterns, define them in a comma-separated list. An explicit value of\n`true` or `false` for a bean definition's `autowire-candidate` attribute always takes\nprecedence. For such beans, the pattern matching rules do not apply.\n\nThese techniques are useful for beans that you never want to be injected into other beans\nby autowiring. It does not mean that an excluded bean cannot itself be configured by\nusing autowiring. Rather, the bean itself is not a candidate for autowiring other beans.\n\n[NOTE]\n====\nAs of 6.2, `@Bean` methods support two variants of the autowire candidate flag:\n`autowireCandidate` and `defaultCandidate`.\n\nWhen using xref:core/beans/annotation-config/autowired-qualifiers.adoc[qualifiers],\na bean marked with `defaultCandidate=false` is only available for injection points\nwhere an additional qualifier indication is present. This is useful for restricted\ndelegates that are supposed to be injectable in certain areas but are not meant to\nget in the way of beans of the same type in other places. Such a bean will never\nget injected by plain declared type only, rather by type plus specific qualifier.\n\nIn contrast, `autowireCandidate=false` behaves exactly like the `autowire-candidate`\nattribute as explained above: Such a bean will never get injected by type at all.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-autowire.adoc", "title": "factory-autowire", "heading": "Excluding a Bean from Autowiring", "heading_level": 2, "file_order": 39, "section_index": 2, "content_hash": "28de79ff617fae9e64ebc4caddb0df083bde36222882e121302c1ffc3e9db4a3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-autowire.adoc"}}
{"id": "sha256:7e8ab152b73756d37866e7883d3f3d0a48da5f5200cfb4eace668effc73427a2", "content": "[[beans-factory-collaborators]]\n\nDependency injection (DI) is a process whereby objects define their dependencies\n(that is, the other objects with which they work) only through constructor arguments,\narguments to a factory method, or properties that are set on the object instance after\nit is constructed or returned from a factory method. The container then injects those\ndependencies when it creates the bean. This process is fundamentally the inverse (hence\nthe name, Inversion of Control) of the bean itself controlling the instantiation\nor location of its dependencies on its own by using direct construction of classes or\nthe Service Locator pattern.\n\nCode is cleaner with the DI principle, and decoupling is more effective when objects are\nprovided with their dependencies. The object does not look up its dependencies and does\nnot know the location or class of the dependencies. As a result, your classes become easier\nto test, particularly when the dependencies are on interfaces or abstract base classes,\nwhich allow for stub or mock implementations to be used in unit tests.\n\nDI exists in two major variants:\nxref:core/beans/dependencies/factory-collaborators.adoc#beans-constructor-injection[Constructor-based dependency injection]\nand xref:core/beans/dependencies/factory-collaborators.adoc#beans-setter-injection[Setter-based dependency injection].\n\n[[beans-constructor-injection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc", "title": "factory-collaborators", "heading": "factory-collaborators", "heading_level": 1, "file_order": 40, "section_index": 0, "content_hash": "7e8ab152b73756d37866e7883d3f3d0a48da5f5200cfb4eace668effc73427a2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc"}}
{"id": "sha256:d31166d8c01929d5268a9e8763b3456f45b45aac1e2fd8734648cf747c4fc693", "content": "Constructor-based DI is accomplished by the container invoking a constructor with a\nnumber of arguments, each representing a dependency. Calling a `static` factory method\nwith specific arguments to construct the bean is nearly equivalent, and this discussion\ntreats arguments to a constructor and to a `static` factory method similarly. The\nfollowing example shows a class that can only be dependency-injected with constructor\ninjection:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SimpleMovieLister {\n\n // the SimpleMovieLister has a dependency on a MovieFinder\n private final MovieFinder movieFinder;\n\n // a constructor so that the Spring container can inject a MovieFinder\n public SimpleMovieLister(MovieFinder movieFinder) {\n this.movieFinder = movieFinder;\n }\n\n // business logic that actually uses the injected MovieFinder is omitted...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// a constructor so that the Spring container can inject a MovieFinder\n\tclass SimpleMovieLister(private val movieFinder: MovieFinder) {\n // business logic that actually uses the injected MovieFinder is omitted...\n\t}\n----\n======\n\nNotice that there is nothing special about this class. It is a POJO that\nhas no dependencies on container specific interfaces, base classes, or annotations.\n\n[[beans-factory-ctor-arguments-resolution]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc", "title": "factory-collaborators", "heading": "Constructor-based Dependency Injection", "heading_level": 2, "file_order": 40, "section_index": 1, "content_hash": "d31166d8c01929d5268a9e8763b3456f45b45aac1e2fd8734648cf747c4fc693", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc"}}
{"id": "sha256:62142dd0b7a36cfd36a95b0b12bc64576098476e482e22ef68199f7495f8b9d8", "content": "Constructor argument resolution matching occurs by using the argument's type. If no\npotential ambiguity exists in the constructor arguments of a bean definition, the\norder in which the constructor arguments are defined in a bean definition is the order\nin which those arguments are supplied to the appropriate constructor when the bean is\nbeing instantiated. Consider the following class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage x.y;\n\n\tpublic class ThingOne {\n\n public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage x.y\n\n\tclass ThingOne(thingTwo: ThingTwo, thingThree: ThingThree)\n----\n======\n\nAssuming that the `ThingTwo` and `ThingThree` classes are not related by inheritance, no\npotential ambiguity exists. Thus, the following configuration works fine, and you do not\nneed to specify the constructor argument indexes or types explicitly in the\n`<constructor-arg/>` element.\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"beanOne\" class=\"x.y.ThingOne\">\n <constructor-arg ref=\"beanTwo\"/>\n <constructor-arg ref=\"beanThree\"/>\n </bean>\n\n <bean id=\"beanTwo\" class=\"x.y.ThingTwo\"/>\n\n <bean id=\"beanThree\" class=\"x.y.ThingThree\"/>\n\t</beans>\n----\n\nWhen another bean is referenced, the type is known, and matching can occur (as was the\ncase with the preceding example). When a simple type is used, such as\n`<value>true</value>`, Spring cannot determine the type of the value, and so cannot match\nby type without help. Consider the following class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage examples;\n\n\tpublic class ExampleBean {\n\n // Number of years to calculate the Ultimate Answer\n private final int years;\n\n // The Answer to Life, the Universe, and Everything\n private final String ultimateAnswer;\n\n public ExampleBean(int years, String ultimateAnswer) {\n this.years = years;\n this.ultimateAnswer = ultimateAnswer;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage examples\n\n\tclass ExampleBean(\n private val years: Int, // Number of years to calculate the Ultimate Answer\n private val ultimateAnswer: String // The Answer to Life, the Universe, and Everything\n\t)\n----\n======\n\n[discrete]\n[[beans-factory-ctor-arguments-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc", "title": "factory-collaborators", "heading": "Constructor Argument Resolution", "heading_level": 3, "file_order": 40, "section_index": 2, "content_hash": "62142dd0b7a36cfd36a95b0b12bc64576098476e482e22ef68199f7495f8b9d8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc"}}
{"id": "sha256:44aadab623329dca9c31d25538a62fe5cbf1a81ecf87040ecb1b6c59a2321ae9", "content": "In the preceding scenario, the container can use type matching with simple types if\nyou explicitly specify the type of the constructor argument via the `type` attribute,\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n <constructor-arg type=\"int\" value=\"7500000\"/>\n <constructor-arg type=\"java.lang.String\" value=\"42\"/>\n\t</bean>\n----\n\n[discrete]\n[[beans-factory-ctor-arguments-index]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc", "title": "factory-collaborators", "heading": "Constructor argument type matching", "heading_level": 4, "file_order": 40, "section_index": 3, "content_hash": "44aadab623329dca9c31d25538a62fe5cbf1a81ecf87040ecb1b6c59a2321ae9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc"}}
{"id": "sha256:c370ff0f3e1564a20ba8527b2f40eecfb8f2156f0bbaedcee9d4674f3af7b655", "content": "You can use the `index` attribute to specify explicitly the index of constructor arguments,\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n <constructor-arg index=\"0\" value=\"7500000\"/>\n <constructor-arg index=\"1\" value=\"42\"/>\n\t</bean>\n----\n\nIn addition to resolving the ambiguity of multiple simple values, specifying an index\nresolves ambiguity where a constructor has two arguments of the same type.\n\nNOTE: The index is 0-based.\n\n[discrete]\n[[beans-factory-ctor-arguments-name]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc", "title": "factory-collaborators", "heading": "Constructor argument index", "heading_level": 4, "file_order": 40, "section_index": 4, "content_hash": "c370ff0f3e1564a20ba8527b2f40eecfb8f2156f0bbaedcee9d4674f3af7b655", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc"}}
{"id": "sha256:c4e3b2ac5b66541fdfd2f3eab66d668867106da7fae94847e58cb0852ef2b88e", "content": "You can also use the constructor parameter name for value disambiguation, as the following\nexample shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n <constructor-arg name=\"years\" value=\"7500000\"/>\n <constructor-arg name=\"ultimateAnswer\" value=\"42\"/>\n\t</bean>\n----\n\nKeep in mind that, to make this work out of the box, your code must be compiled with the\n`-parameters` flag enabled so that Spring can look up the parameter name from the constructor.\nIf you cannot or do not want to compile your code with the `-parameters` flag, you can use the\nhttps://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html[@ConstructorProperties]\nJDK annotation to explicitly name your constructor arguments. The sample class would\nthen have to look as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage examples;\n\n\tpublic class ExampleBean {\n\n // Fields omitted\n\n @ConstructorProperties({\"years\", \"ultimateAnswer\"})\n public ExampleBean(int years, String ultimateAnswer) {\n this.years = years;\n this.ultimateAnswer = ultimateAnswer;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage examples\n\n\tclass ExampleBean\n\t@ConstructorProperties(\"years\", \"ultimateAnswer\")\n\tconstructor(val years: Int, val ultimateAnswer: String)\n----\n======\n\n[[beans-setter-injection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc", "title": "factory-collaborators", "heading": "Constructor argument name", "heading_level": 4, "file_order": 40, "section_index": 5, "content_hash": "c4e3b2ac5b66541fdfd2f3eab66d668867106da7fae94847e58cb0852ef2b88e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc"}}
{"id": "sha256:9caff1bee952d5aed984b9d77b4076f22e50f4806deacc613fc26da0cc3eea18", "content": "Setter-based DI is accomplished by the container calling setter methods on your\nbeans after invoking a no-argument constructor or a no-argument `static` factory method to\ninstantiate your bean.\n\nThe following example shows a class that can only be dependency-injected by using pure\nsetter injection. This class is conventional Java. It is a POJO that has no dependencies\non container specific interfaces, base classes, or annotations.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SimpleMovieLister {\n\n // the SimpleMovieLister has a dependency on the MovieFinder\n private MovieFinder movieFinder;\n\n // a setter method so that the Spring container can inject a MovieFinder\n public void setMovieFinder(MovieFinder movieFinder) {\n this.movieFinder = movieFinder;\n }\n\n // business logic that actually uses the injected MovieFinder is omitted...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nclass SimpleMovieLister {\n\n\t// a late-initialized property so that the Spring container can inject a MovieFinder\n\tlateinit var movieFinder: MovieFinder\n\n\t// business logic that actually uses the injected MovieFinder is omitted...\n}\n----\n======\n\nThe `ApplicationContext` supports constructor-based and setter-based DI for the beans it\nmanages. It also supports setter-based DI after some dependencies have already been\ninjected through the constructor approach. You configure the dependencies in the form of\na `BeanDefinition`, which you use in conjunction with `PropertyEditor` instances to\nconvert properties from one format to another. However, most Spring users do not work\nwith these classes directly (that is, programmatically) but rather with XML `bean`\ndefinitions, annotated components (that is, classes annotated with `@Component`,\n`@Controller`, and so forth), or `@Bean` methods in Java-based `@Configuration` classes.\nThese sources are then converted internally into instances of `BeanDefinition` and used to\nload an entire Spring IoC container instance.\n\n[[beans-constructor-vs-setter-injection]]\n.Constructor-based or setter-based DI?\n****\nSince you can mix constructor-based and setter-based DI, it is a good rule of thumb to\nuse constructors for mandatory dependencies and setter methods or configuration methods\nfor optional dependencies. Note that use of the xref:core/beans/annotation-config/autowired.adoc[@Autowired]\nannotation on a setter method can be used to make the property be a required dependency;\nhowever, constructor injection with programmatic validation of arguments is preferable.\n\nThe Spring team generally advocates constructor injection, as it lets you implement\napplication components as immutable objects and ensures that required dependencies\nare not `null`. Furthermore, constructor-injected components are always returned to the client\n(calling) code in a fully initialized state. As a side note, a large number of constructor\narguments is a bad code smell, implying that the class likely has too many\nresponsibilities and should be refactored to better address proper separation of concerns.\n\nSetter injection should primarily only be used for optional dependencies that can be\nassigned reasonable default values within the class. Otherwise, not-null checks must be\nperformed everywhere the code uses the dependency. One benefit of setter injection is that\nsetter methods make objects of that class amenable to reconfiguration or re-injection\nlater. Management through xref:integration/jmx.adoc[JMX MBeans] is therefore a compelling\nuse case for setter injection.\n\nUse the DI style that makes the most sense for a particular class. Sometimes, when dealing\nwith third-party classes for which you do not have the source, the choice is made for you.\nFor example, if a third-party class does not expose any setter methods, then constructor\ninjection may be the only available form of DI.\n****\n\n[[beans-dependency-resolution]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc", "title": "factory-collaborators", "heading": "Setter-based Dependency Injection", "heading_level": 2, "file_order": 40, "section_index": 6, "content_hash": "9caff1bee952d5aed984b9d77b4076f22e50f4806deacc613fc26da0cc3eea18", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc"}}
{"id": "sha256:ec3e49ecf242b992269c0b2c20c62cd5aded072ba1bcbfe4be9901f6a99a4370", "content": "The container performs bean dependency resolution as follows:\n\n* The `ApplicationContext` is created and initialized with configuration metadata that\n describes all the beans. Configuration metadata can be specified by XML, Java code, or\n annotations.\n* For each bean, its dependencies are expressed in the form of properties, constructor\n arguments, or arguments to the static-factory method (if you use that instead of a\n normal constructor). These dependencies are provided to the bean, when the bean is\n actually created.\n* Each property or constructor argument is an actual definition of the value to set, or\n a reference to another bean in the container.\n* Each property or constructor argument that is a value is converted from its specified\n format to the actual type of that property or constructor argument. By default, Spring\n can convert a value supplied in string format to all built-in types, such as `int`,\n `long`, `String`, `boolean`, and so forth.\n\nThe Spring container validates the configuration of each bean as the container is created.\nHowever, the bean properties themselves are not set until the bean is actually created.\nBeans that are singleton-scoped and set to be pre-instantiated (the default) are created\nwhen the container is created. Scopes are defined in xref:core/beans/factory-scopes.adoc[Bean Scopes]. Otherwise,\nthe bean is created only when it is requested. Creation of a bean potentially causes a\ngraph of beans to be created, as the bean's dependencies and its dependencies'\ndependencies (and so on) are created and assigned. Note that resolution mismatches among\nthose dependencies may show up late -- that is, on first creation of the affected bean.\n\n.Circular dependencies\n****\nIf you use predominantly constructor injection, it is possible to create an unresolvable\ncircular dependency scenario.\n\nFor example: Class A requires an instance of class B through constructor injection, and\nclass B requires an instance of class A through constructor injection. If you configure\nbeans for classes A and B to be injected into each other, the Spring IoC container\ndetects this circular reference at runtime, and throws a\n`BeanCurrentlyInCreationException`.\n\nOne possible solution is to edit the source code of some classes to be configured by\nsetters rather than constructors. Alternatively, avoid constructor injection and use\nsetter injection only. In other words, although it is not recommended, you can configure\ncircular dependencies with setter injection.\n\nUnlike the typical case (with no circular dependencies), a circular dependency\nbetween bean A and bean B forces one of the beans to be injected into the other prior to\nbeing fully initialized itself (a classic chicken-and-egg scenario).\n****\n\nYou can generally trust Spring to do the right thing. It detects configuration problems,\nsuch as references to non-existent beans and circular dependencies, at container\nload-time. Spring sets properties and resolves dependencies as late as possible, when\nthe bean is actually created. This means that a Spring container that has loaded\ncorrectly can later generate an exception when you request an object if there is a\nproblem creating that object or one of its dependencies -- for example, the bean throws an\nexception as a result of a missing or invalid property. This potentially delayed\nvisibility of some configuration issues is why `ApplicationContext` implementations by\ndefault pre-instantiate singleton beans. At the cost of some upfront time and memory to\ncreate these beans before they are actually needed, you discover configuration issues\nwhen the `ApplicationContext` is created, not later. You can still override this default\nbehavior so that singleton beans initialize lazily, rather than being eagerly\npre-instantiated.\n\nIf no circular dependencies exist, when one or more collaborating beans are being\ninjected into a dependent bean, each collaborating bean is totally configured prior\nto being injected into the dependent bean. This means that, if bean A has a dependency on\nbean B, the Spring IoC container completely configures bean B prior to invoking the\nsetter method on bean A. In other words, the bean is instantiated (if it is not a\npre-instantiated singleton), its dependencies are set, and the relevant lifecycle\nmethods (such as a xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-initializingbean[configured init method]\nor the xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-initializingbean[InitializingBean callback method])\nare invoked.\n\n[[beans-some-examples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc", "title": "factory-collaborators", "heading": "Dependency Resolution Process", "heading_level": 2, "file_order": 40, "section_index": 7, "content_hash": "ec3e49ecf242b992269c0b2c20c62cd5aded072ba1bcbfe4be9901f6a99a4370", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc"}}
{"id": "sha256:0ba7e75345aa76ddb33d7a9a7e7ce654a59e47dc67bff618ba83ad509f75b259", "content": "The following example uses XML-based configuration metadata for setter-based DI. A small\npart of a Spring XML configuration file specifies some bean definitions as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n <!-- setter injection using the nested ref element -->\n <property name=\"beanOne\">\n <ref bean=\"anotherExampleBean\"/>\n </property>\n\n <!-- setter injection using the neater ref attribute -->\n <property name=\"beanTwo\" ref=\"yetAnotherBean\"/>\n <property name=\"integerProperty\" value=\"1\"/>\n\t</bean>\n\n\t<bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/>\n\t<bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/>\n----\n\nThe following example shows the corresponding `ExampleBean` class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ExampleBean {\n\n private AnotherBean beanOne;\n\n private YetAnotherBean beanTwo;\n\n private int i;\n\n public void setBeanOne(AnotherBean beanOne) {\n this.beanOne = beanOne;\n }\n\n public void setBeanTwo(YetAnotherBean beanTwo) {\n this.beanTwo = beanTwo;\n }\n\n public void setIntegerProperty(int i) {\n this.i = i;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nclass ExampleBean {\n\tlateinit var beanOne: AnotherBean\n\tlateinit var beanTwo: YetAnotherBean\n\tvar i: Int = 0\n}\n----\n======\n\nIn the preceding example, setters are declared to match against the properties specified\nin the XML file. The following example uses constructor-based DI:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exampleBean\" class=\"examples.ExampleBean\">\n <!-- constructor injection using the nested ref element -->\n <constructor-arg>\n <ref bean=\"anotherExampleBean\"/>\n </constructor-arg>\n\n <!-- constructor injection using the neater ref attribute -->\n <constructor-arg ref=\"yetAnotherBean\"/>\n\n <constructor-arg type=\"int\" value=\"1\"/>\n\t</bean>\n\n\t<bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/>\n\t<bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/>\n----\n\nThe following example shows the corresponding `ExampleBean` class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ExampleBean {\n\n private AnotherBean beanOne;\n\n private YetAnotherBean beanTwo;\n\n private int i;\n\n public ExampleBean(\n AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {\n this.beanOne = anotherBean;\n this.beanTwo = yetAnotherBean;\n this.i = i;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nclass ExampleBean(\n private val beanOne: AnotherBean,\n private val beanTwo: YetAnotherBean,\n private val i: Int)\n----\n======\n\nThe constructor arguments specified in the bean definition are used as arguments to\nthe constructor of the `ExampleBean`.\n\nNow consider a variant of this example, where, instead of using a constructor, Spring is\ntold to call a `static` factory method to return an instance of the object:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exampleBean\" class=\"examples.ExampleBean\" factory-method=\"createInstance\">\n <constructor-arg ref=\"anotherExampleBean\"/>\n <constructor-arg ref=\"yetAnotherBean\"/>\n <constructor-arg value=\"1\"/>\n\t</bean>\n\n\t<bean id=\"anotherExampleBean\" class=\"examples.AnotherBean\"/>\n\t<bean id=\"yetAnotherBean\" class=\"examples.YetAnotherBean\"/>\n----\n\nThe following example shows the corresponding `ExampleBean` class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ExampleBean {\n\n // a private constructor\n private ExampleBean(...) {\n ...\n }\n\n // a static factory method; the arguments to this method can be\n // considered the dependencies of the bean that is returned,\n // regardless of how those arguments are actually used.\n public static ExampleBean createInstance (\n AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {\n\n ExampleBean eb = new ExampleBean (...);\n // some other operations...\n return eb;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ExampleBean private constructor() {\n companion object {\n // a static factory method; the arguments to this method can be\n // considered the dependencies of the bean that is returned,\n // regardless of how those arguments are actually used.\n @JvmStatic\n fun createInstance(anotherBean: AnotherBean, yetAnotherBean: YetAnotherBean, i: Int): ExampleBean {\n val eb = ExampleBean (...)\n // some other operations...\n return eb\n }\n }\n\t}\n----\n======\n\nArguments to the `static` factory method are supplied by `<constructor-arg/>` elements,\nexactly the same as if a constructor had actually been used. The type of the class being\nreturned by the factory method does not have to be of the same type as the class that\ncontains the `static` factory method (although, in this example, it is). An instance\n(non-static) factory method can be used in an essentially identical fashion (aside\nfrom the use of the `factory-bean` attribute instead of the `class` attribute), so we\ndo not discuss those details here.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc", "title": "factory-collaborators", "heading": "Examples of Dependency Injection", "heading_level": 2, "file_order": 40, "section_index": 8, "content_hash": "0ba7e75345aa76ddb33d7a9a7e7ce654a59e47dc67bff618ba83ad509f75b259", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-collaborators.adoc"}}
{"id": "sha256:074e442fe5ab48682be2b47d9dcffd9e726ba7a3b19589ee33144e4130bc0b80", "content": "[[beans-factory-dependson]]\n\nIf a bean is a dependency of another bean, that usually means that one bean is set as a\nproperty of another. Typically you accomplish this with the\nxref:core/beans/dependencies/factory-properties-detailed.adoc#beans-ref-element[`<ref/>` element]\nin XML-based metadata or through xref:core/beans/dependencies/factory-autowire.adoc[autowiring].\n\nHowever, sometimes dependencies between beans are less direct. An example is when a static\ninitializer in a class needs to be triggered, such as for database driver registration.\nThe `depends-on` attribute or `@DependsOn` annotation can explicitly force one or more beans\nto be initialized before the bean using this element is initialized. The following example\nuses the `depends-on` attribute to express a dependency on a single bean:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"beanOne\" class=\"ExampleBean\" depends-on=\"manager\"/>\n\t<bean id=\"manager\" class=\"ManagerBean\" />\n----\n\nTo express a dependency on multiple beans, supply a list of bean names as the value of\nthe `depends-on` attribute (commas, whitespace, and semicolons are valid\ndelimiters):\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"beanOne\" class=\"ExampleBean\" depends-on=\"manager,accountDao\">\n <property name=\"manager\" ref=\"manager\" />\n\t</bean>\n\n\t<bean id=\"manager\" class=\"ManagerBean\" />\n\t<bean id=\"accountDao\" class=\"x.y.jdbc.JdbcAccountDao\" />\n----\n\nNOTE: The `depends-on` attribute can specify both an initialization-time dependency and,\nin the case of xref:core/beans/factory-scopes.adoc#beans-factory-scopes-singleton[singleton]\nbeans only, a corresponding destruction-time dependency. Dependent beans that define a\n`depends-on` relationship with a given bean are destroyed first, prior to the given bean\nitself being destroyed. Thus, `depends-on` can also control shutdown order.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-dependson.adoc", "title": "factory-dependson", "heading": "factory-dependson", "heading_level": 1, "file_order": 41, "section_index": 0, "content_hash": "074e442fe5ab48682be2b47d9dcffd9e726ba7a3b19589ee33144e4130bc0b80", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-dependson.adoc"}}
{"id": "sha256:d930e0bd39eb4e0b6993c8d239e2a3097048f496eaa32aa03283074fec9e2e4c", "content": "[[beans-factory-lazy-init]]\n\nBy default, `ApplicationContext` implementations eagerly create and configure all\nxref:core/beans/factory-scopes.adoc#beans-factory-scopes-singleton[singleton] beans as part of the initialization\nprocess. Generally, this pre-instantiation is desirable, because errors in the\nconfiguration or surrounding environment are discovered immediately, as opposed to hours\nor even days later. When this behavior is not desirable, you can prevent\npre-instantiation of a singleton bean by marking the bean definition as being\nlazy-initialized. A lazy-initialized bean tells the IoC container to create a bean\ninstance when it is first requested, rather than at startup.\n\nThis behavior is controlled by the `@Lazy` annotation or in XML the `lazy-init` attribute on the `<bean/>` element, as\nthe following example shows:\n\ninclude-code::./ApplicationConfiguration[tag=snippet,indent=0]\n\nWhen the preceding configuration is consumed by an `ApplicationContext`, the `lazy` bean\nis not eagerly pre-instantiated when the `ApplicationContext` starts,\nwhereas the `notLazy` one is eagerly pre-instantiated.\n\nHowever, when a lazy-initialized bean is a dependency of a singleton bean that is\nnot lazy-initialized, the `ApplicationContext` creates the lazy-initialized bean at\nstartup, because it must satisfy the singleton's dependencies. The lazy-initialized bean\nis injected into a singleton bean elsewhere that is not lazy-initialized.\n\nYou can also control lazy-initialization for a set of beans by using the `@Lazy` annotation on your `@Configuration`\nannotated class or in XML using the `default-lazy-init` attribute on the `<beans/>` element, as the following example\nshows:\n\ninclude-code::./LazyConfiguration[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-lazy-init.adoc", "title": "factory-lazy-init", "heading": "factory-lazy-init", "heading_level": 1, "file_order": 42, "section_index": 0, "content_hash": "d930e0bd39eb4e0b6993c8d239e2a3097048f496eaa32aa03283074fec9e2e4c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-lazy-init.adoc"}}
{"id": "sha256:f0ca6eebfed4af4da3a3bcd97ca3f7d4dcdf57956f57bbafbf9f8e0256e341a6", "content": "[[beans-factory-method-injection]]\n\nIn most application scenarios, most beans in the container are\nxref:core/beans/factory-scopes.adoc#beans-factory-scopes-singleton[singletons]. When a\nsingleton bean needs to collaborate with another singleton bean or a non-singleton bean\nneeds to collaborate with another non-singleton bean, you typically handle the dependency\nby defining one bean as a property of the other. A problem arises when the bean lifecycles\nare different. Suppose singleton bean A needs to use non-singleton (prototype) bean B,\nperhaps on each method invocation on A. The container creates the singleton bean A only\nonce, and thus only gets one opportunity to set the properties. The container cannot\nprovide bean A with a new instance of bean B every time one is needed.\n\nA solution is to forego some inversion of control. You can\nxref:core/beans/factory-nature.adoc#beans-factory-aware[make bean A aware of the container]\n by implementing the `ApplicationContextAware` interface,\nand by xref:core/beans/basics.adoc#beans-factory-client[making a `getBean(\"B\")` call to the container] ask for (a\ntypically new) bean B instance every time bean A needs it. The following example\nshows this approach:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\",fold=\"none\"]\n----\n\tpackage fiona.apple;\n\n\t// Spring-API imports\n\timport org.springframework.beans.BeansException;\n\timport org.springframework.context.ApplicationContext;\n\timport org.springframework.context.ApplicationContextAware;\n\n\t/**\n * A class that uses a stateful Command-style class to perform\n * some processing.\n */\n\tpublic class CommandManager implements ApplicationContextAware {\n\n private ApplicationContext applicationContext;\n\n public Object process(Map commandState) {\n // grab a new instance of the appropriate Command\n Command command = createCommand();\n // set the state on the (hopefully brand new) Command instance\n command.setState(commandState);\n return command.execute();\n }\n\n protected Command createCommand() {\n // notice the Spring API dependency!\n return this.applicationContext.getBean(\"command\", Command.class);\n }\n\n public void setApplicationContext(\n ApplicationContext applicationContext) throws BeansException {\n this.applicationContext = applicationContext;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\",fold=\"none\"]\n----\n\tpackage fiona.apple\n\n\t// Spring-API imports\n\timport org.springframework.context.ApplicationContext\n\timport org.springframework.context.ApplicationContextAware\n\n\t// A class that uses a stateful Command-style class to perform\n\t// some processing.\n\tclass CommandManager : ApplicationContextAware {\n\n private lateinit var applicationContext: ApplicationContext\n\n fun process(commandState: Map<*, *>): Any {\n // grab a new instance of the appropriate Command\n val command = createCommand()\n // set the state on the (hopefully brand new) Command instance\n command.state = commandState\n return command.execute()\n }\n\n // notice the Spring API dependency!\n protected fun createCommand() =\n applicationContext.getBean(\"command\", Command::class.java)\n\n override fun setApplicationContext(applicationContext: ApplicationContext) {\n this.applicationContext = applicationContext\n }\n\t}\n----\n======\n\nThe preceding is not desirable, because the business code is aware of and coupled to the\nSpring Framework. Method Injection, a somewhat advanced feature of the Spring IoC\ncontainer, lets you handle this use case cleanly.\n\n****\nYou can read more about the motivation for Method Injection in\n{spring-site-blog}/2004/08/06/method-injection/[this blog entry].\n****\n\n[[beans-factory-lookup-method-injection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-method-injection.adoc", "title": "factory-method-injection", "heading": "factory-method-injection", "heading_level": 1, "file_order": 43, "section_index": 0, "content_hash": "f0ca6eebfed4af4da3a3bcd97ca3f7d4dcdf57956f57bbafbf9f8e0256e341a6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-method-injection.adoc"}}
{"id": "sha256:3e9176014e1e7225d7ba536a8c54f5f3b17ba884dd65134f4fa78188b62b99e3", "content": "Lookup method injection is the ability of the container to override methods on\ncontainer-managed beans and return the lookup result for another named bean in the\ncontainer. The lookup typically involves a prototype bean, as in the scenario described\nin xref:core/beans/dependencies/factory-method-injection.adoc[the preceding section]. The Spring Framework\nimplements this method injection by using bytecode generation from the CGLIB library to\ndynamically generate a subclass that overrides the method.\n\n[NOTE]\n====\n* For this dynamic subclassing to work, the class that the Spring bean container\n subclasses cannot be `final`, and the method to be overridden cannot be `final`, either.\n* Unit-testing a class that has an `abstract` method requires you to subclass the class\n yourself and to supply a stub implementation of the `abstract` method.\n* A further key limitation is that lookup methods do not work with factory methods and\n in particular not with `@Bean` methods in configuration classes, since, in that case,\n the container is not in charge of creating the instance and therefore cannot create\n a runtime-generated subclass on the fly.\n====\n\nIn the case of the `CommandManager` class in the previous code snippet, the\nSpring container dynamically overrides the implementation of the `createCommand()`\nmethod. The `CommandManager` class does not have any Spring dependencies, as\nthe reworked example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\",fold=\"none\"]\n----\n\tpackage fiona.apple;\n\n\t// no more Spring imports!\n\n\tpublic abstract class CommandManager {\n\n public Object process(Object commandState) {\n // grab a new instance of the appropriate Command interface\n Command command = createCommand();\n // set the state on the (hopefully brand new) Command instance\n command.setState(commandState);\n return command.execute();\n }\n\n // okay... but where is the implementation of this method?\n protected abstract Command createCommand();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\",fold=\"none\"]\n----\n\tpackage fiona.apple\n\n\t// no more Spring imports!\n\n\tabstract class CommandManager {\n\n fun process(commandState: Any): Any {\n // grab a new instance of the appropriate Command interface\n val command = createCommand()\n // set the state on the (hopefully brand new) Command instance\n command.state = commandState\n return command.execute()\n }\n\n // okay... but where is the implementation of this method?\n protected abstract fun createCommand(): Command\n\t}\n----\n======\n\nIn the client class that contains the method to be injected (the `CommandManager` in this\ncase), the method to be injected requires a signature of the following form:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<public|protected> [abstract] <return-type> theMethodName(no-arguments);\n----\n\nIf the method is `abstract`, the dynamically-generated subclass implements the method.\nOtherwise, the dynamically-generated subclass overrides the concrete method defined in\nthe original class. Consider the following example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- a stateful bean deployed as a prototype (non-singleton) -->\n\t<bean id=\"myCommand\" class=\"fiona.apple.AsyncCommand\" scope=\"prototype\">\n <!-- inject dependencies here as required -->\n\t</bean>\n\n\t<!-- commandManager uses myCommand prototype bean -->\n\t<bean id=\"commandManager\" class=\"fiona.apple.CommandManager\">\n <lookup-method name=\"createCommand\" bean=\"myCommand\"/>\n\t</bean>\n----\n\nThe bean identified as `commandManager` calls its own `createCommand()` method\nwhenever it needs a new instance of the `myCommand` bean. You must be careful to deploy\nthe `myCommand` bean as a prototype if that is actually what is needed. If it is\na xref:core/beans/factory-scopes.adoc#beans-factory-scopes-singleton[singleton], the same instance of the `myCommand`\nbean is returned each time.\n\nAlternatively, within the annotation-based component model, you can declare a lookup\nmethod through the `@Lookup` annotation, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic abstract class CommandManager {\n\n public Object process(Object commandState) {\n Command command = createCommand();\n command.setState(commandState);\n return command.execute();\n }\n\n @Lookup(\"myCommand\")\n protected abstract Command createCommand();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tabstract class CommandManager {\n\n fun process(commandState: Any): Any {\n val command = createCommand()\n command.state = commandState\n return command.execute()\n }\n\n @Lookup(\"myCommand\")\n protected abstract fun createCommand(): Command\n\t}\n----\n======\n\nOr, more idiomatically, you can rely on the target bean getting resolved against the\ndeclared return type of the lookup method:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic abstract class CommandManager {\n\n public Object process(Object commandState) {\n Command command = createCommand();\n command.setState(commandState);\n return command.execute();\n }\n\n @Lookup\n protected abstract Command createCommand();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tabstract class CommandManager {\n\n fun process(commandState: Any): Any {\n val command = createCommand()\n command.state = commandState\n return command.execute()\n }\n\n @Lookup\n protected abstract fun createCommand(): Command\n\t}\n----\n======\n\n[TIP]\n====\nAnother way of accessing differently scoped target beans is an `ObjectFactory`/\n`Provider` injection point. See\nxref:core/beans/factory-scopes.adoc#beans-factory-scopes-other-injection[Scoped Beans as Dependencies].\n\nYou may also find the `ServiceLocatorFactoryBean` (in the\n`org.springframework.beans.factory.config` package) to be useful.\n====\n\n[[beans-factory-arbitrary-method-replacement]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-method-injection.adoc", "title": "factory-method-injection", "heading": "Lookup Method Injection", "heading_level": 2, "file_order": 43, "section_index": 1, "content_hash": "3e9176014e1e7225d7ba536a8c54f5f3b17ba884dd65134f4fa78188b62b99e3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-method-injection.adoc"}}
{"id": "sha256:1669bd41f4bafa72703f5c59316a9379b3c494a724bb1e4156c48f5c1771c5c8", "content": "A less useful form of method injection than lookup method injection is the ability to\nreplace arbitrary methods in a managed bean with another method implementation. You\ncan safely skip the rest of this section until you actually need this functionality.\n\nWith XML-based configuration metadata, you can use the `replaced-method` element to\nreplace an existing method implementation with another, for a deployed bean. Consider\nthe following class, which has a method called `computeValue` that we want to override:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MyValueCalculator {\n\n public String computeValue(String input) {\n // some real code...\n }\n\n // some other methods...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MyValueCalculator {\n\n fun computeValue(input: String): String {\n // some real code...\n }\n\n // some other methods...\n\t}\n----\n======\n\nA class that implements the `org.springframework.beans.factory.support.MethodReplacer`\ninterface provides the new method definition, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t/**\n * meant to be used to override the existing computeValue(String)\n * implementation in MyValueCalculator\n */\n\tpublic class ReplacementComputeValue implements MethodReplacer {\n\n public Object reimplement(Object o, Method m, Object[] args) throws Throwable {\n // get the input value, work with it, and return a computed result\n String input = (String) args[0];\n ...\n return ...;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t/**\n * meant to be used to override the existing computeValue(String)\n * implementation in MyValueCalculator\n */\n\tclass ReplacementComputeValue : MethodReplacer {\n\n override fun reimplement(obj: Any, method: Method, args: Array<out Any>): Any {\n // get the input value, work with it, and return a computed result\n val input = args[0] as String;\n ...\n return ...;\n }\n\t}\n----\n======\n\nThe bean definition to deploy the original class and specify the method override would\nresemble the following example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"myValueCalculator\" class=\"x.y.z.MyValueCalculator\">\n <!-- arbitrary method replacement -->\n <replaced-method name=\"computeValue\" replacer=\"replacementComputeValue\">\n <arg-type>String</arg-type>\n </replaced-method>\n\t</bean>\n\n\t<bean id=\"replacementComputeValue\" class=\"a.b.c.ReplacementComputeValue\"/>\n----\n\nYou can use one or more `<arg-type/>` elements within the `<replaced-method/>`\nelement to indicate the method signature of the method being overridden. The signature\nfor the arguments is necessary only if the method is overloaded and multiple variants\nexist within the class. For convenience, the type string for an argument may be a\nsubstring of the fully qualified type name. For example, the following all match\n`java.lang.String`:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tjava.lang.String\n\tString\n\tStr\n----\n\nBecause the number of arguments is often enough to distinguish between each possible\nchoice, this shortcut can save a lot of typing, by letting you type only the\nshortest string that matches an argument type.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-method-injection.adoc", "title": "factory-method-injection", "heading": "Arbitrary Method Replacement", "heading_level": 2, "file_order": 43, "section_index": 2, "content_hash": "1669bd41f4bafa72703f5c59316a9379b3c494a724bb1e4156c48f5c1771c5c8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-method-injection.adoc"}}
{"id": "sha256:72f1fd30620950552a4864e96a4e00785cdc225b6c33bb1ab34ee733d4f2a337", "content": "[[beans-factory-properties-detailed]]\n\nAs mentioned in the xref:core/beans/dependencies/factory-collaborators.adoc[previous section],\nyou can define bean properties and constructor arguments as references to other managed beans\n(collaborators) or as values defined inline. Spring's XML-based configuration metadata supports\nsub-element types within its `<property/>` and `<constructor-arg/>` elements for this purpose.\n\n[[beans-value-element]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "factory-properties-detailed", "heading_level": 1, "file_order": 44, "section_index": 0, "content_hash": "72f1fd30620950552a4864e96a4e00785cdc225b6c33bb1ab34ee733d4f2a337", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:86d7e0e624ae8a0866da9f1d0d0e54ec4f28bd1a3a1d000d4edbe0f089412bc2", "content": "The `value` attribute of the `<property/>` element specifies a property or constructor\nargument as a human-readable string representation. Spring's\nxref:core/validation/convert.adoc#core-convert-ConversionService-API[conversion service] is used to convert these\nvalues from a `String` to the actual type of the property or argument.\nThe following example shows various values being set:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"myDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n <!-- results in a setDriverClassName(String) call -->\n <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mydb\"/>\n <property name=\"username\" value=\"root\"/>\n <property name=\"password\" value=\"misterkaoli\"/>\n\t</bean>\n----\n\nThe following example uses the xref:core/beans/dependencies/factory-properties-detailed.adoc#beans-p-namespace[p-namespace] for even more succinct\nXML configuration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:p=\"http://www.springframework.org/schema/p\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <bean id=\"myDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\"\n destroy-method=\"close\"\n p:driverClassName=\"com.mysql.jdbc.Driver\"\n p:url=\"jdbc:mysql://localhost:3306/mydb\"\n p:username=\"root\"\n p:password=\"misterkaoli\"/>\n\n\t</beans>\n----\n\nThe preceding XML is more succinct. However, typos are discovered at runtime rather than\ndesign time, unless you use an IDE (such as https://www.jetbrains.com/idea/[IntelliJ\nIDEA] or the {spring-site-tools}[Spring Tools]) that supports automatic property\ncompletion when you create bean definitions. Such IDE assistance is highly recommended.\n\nYou can also configure a `java.util.Properties` instance, as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"mappings\"\n class=\"org.springframework.context.support.PropertySourcesPlaceholderConfigurer\">\n\n <!-- typed as a java.util.Properties -->\n <property name=\"properties\">\n <value>\n jdbc.driver.className=com.mysql.jdbc.Driver\n jdbc.url=jdbc:mysql://localhost:3306/mydb\n </value>\n </property>\n\t</bean>\n----\n\nThe Spring container converts the text inside the `<value/>` element into a\n`java.util.Properties` instance by using the JavaBeans `PropertyEditor` mechanism. This\nis a nice shortcut, and is one of a few places where the Spring team do favor the use of\nthe nested `<value/>` element over the `value` attribute style.\n\n[[beans-idref-element]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "Straight Values (Primitives, Strings, and so on)", "heading_level": 2, "file_order": 44, "section_index": 1, "content_hash": "86d7e0e624ae8a0866da9f1d0d0e54ec4f28bd1a3a1d000d4edbe0f089412bc2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:98d0dee33fd4cc472ccd3068f547fc23cc16c967dd48fc2f57a02b9b9007b308", "content": "The `idref` element is simply an error-proof way to pass the `id` (a string value - not\na reference) of another bean in the container to a `<constructor-arg/>` or `<property/>`\nelement. The following example shows how to use it:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"collaborator\" class=\"...\" />\n\n\t<bean id=\"client\" class=\"...\">\n <property name=\"targetName\">\n <idref bean=\"collaborator\" />\n </property>\n\t</bean>\n----\n\nThe preceding bean definition snippet is exactly equivalent (at runtime) to the\nfollowing snippet:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"collaborator\" class=\"...\" />\n\n\t<bean id=\"client\" class=\"...\">\n <property name=\"targetName\" value=\"collaborator\" />\n\t</bean>\n----\n\nThe first form is preferable to the second, because using the `idref` tag lets the\ncontainer validate at deployment time that the referenced, named bean actually exists. In\nthe second variation, no validation is performed on the value that is passed to the\n`targetName` property of the `client` bean. Typos are therefore only discovered (with most\nlikely fatal results) when the `client` bean is actually instantiated. If the `client`\nbean is a xref:core/beans/factory-scopes.adoc[prototype] bean, this typo and the resulting\nexception may only be discovered long after the container is deployed.\n\nNOTE: A common place (at least in versions earlier than Spring 2.0) where the `<idref/>`\nelement brings value is in the configuration of xref:core/aop-api/pfb.adoc#aop-pfb-1[AOP interceptors]\nin a `ProxyFactoryBean` bean definition. Using `<idref/>` elements when you specify the\ninterceptor names prevents you from misspelling an interceptor ID.\n\n[[beans-ref-element]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "The `idref` element", "heading_level": 3, "file_order": 44, "section_index": 2, "content_hash": "98d0dee33fd4cc472ccd3068f547fc23cc16c967dd48fc2f57a02b9b9007b308", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:16de18f77eb3fe753e42141d7cf89debd1e1d9d5b7fc77156c381d4469c4e08d", "content": "The `ref` element is the final element inside a `<constructor-arg/>` or `<property/>`\ndefinition element. Here, you set the value of the specified property of a bean to be a\nreference to another bean (a collaborator) managed by the container. The referenced bean\nis a dependency of the bean whose property is to be set, and it is initialized on demand\nas needed before the property is set. (If the collaborator is a singleton bean, it may\nalready be initialized by the container.) All references are ultimately a reference to\nanother object. Scoping and validation depend on whether you specify the ID or name of the\nother object through the `bean` or `parent` attribute.\n\nSpecifying the target bean through the `bean` attribute of the `<ref/>` tag is the most\ngeneral form and allows creation of a reference to any bean in the same container or\nparent container, regardless of whether it is in the same XML file. The value of the\n`bean` attribute may be the same as the `id` attribute of the target bean or be the same\nas one of the values in the `name` attribute of the target bean. The following example\nshows how to use a `ref` element:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<ref bean=\"someBean\"/>\n----\n\nSpecifying the target bean through the `parent` attribute creates a reference to a bean\nthat is in a parent container of the current container. The value of the `parent`\nattribute may be the same as either the `id` attribute of the target bean or one of the\nvalues in the `name` attribute of the target bean. The target bean must be in a\nparent container of the current one. You should use this bean reference variant mainly\nwhen you have a hierarchy of containers and you want to wrap an existing bean in a parent\ncontainer with a proxy that has the same name as the parent bean. The following pair of\nlistings shows how to use the `parent` attribute:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- in the parent context -->\n\t<bean id=\"accountService\" class=\"com.something.SimpleAccountService\">\n <!-- insert dependencies as required here -->\n\t</bean>\n----\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- in the child (descendant) context, bean name is the same as the parent bean -->\n\t<bean id=\"accountService\"\n class=\"org.springframework.aop.framework.ProxyFactoryBean\">\n <property name=\"target\">\n <ref parent=\"accountService\"/> <!-- notice how we refer to the parent bean -->\n </property>\n <!-- insert other configuration and dependencies as required here -->\n\t</bean>\n----\n\nNOTE: The `local` attribute on the `ref` element is no longer supported in the 4.0 beans\nXSD, since it does not provide value over a regular `bean` reference any more. Change\nyour existing `ref local` references to `ref bean` when upgrading to the 4.0 schema.\n\n[[beans-inner-beans]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "References to Other Beans (Collaborators)", "heading_level": 2, "file_order": 44, "section_index": 3, "content_hash": "16de18f77eb3fe753e42141d7cf89debd1e1d9d5b7fc77156c381d4469c4e08d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:d3484e1bfca17c65c07c0ca6f2d28856b9cb06241ca80b1922a6e96603a7b156", "content": "A `<bean/>` element inside the `<property/>` or `<constructor-arg/>` elements defines an\ninner bean, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"outer\" class=\"...\">\n <!-- instead of using a reference to a target bean, simply define the target bean inline -->\n <property name=\"target\">\n <bean class=\"com.example.Person\"> <!-- this is the inner bean -->\n <property name=\"name\" value=\"Fiona Apple\"/>\n <property name=\"age\" value=\"25\"/>\n </bean>\n </property>\n\t</bean>\n----\n\nAn inner bean definition does not require a defined ID or name. If specified, the container\ndoes not use such a value as an identifier. The container also ignores the `scope` flag on\ncreation, because inner beans are always anonymous and are always created with the outer\nbean. It is not possible to access inner beans independently or to inject them into\ncollaborating beans other than into the enclosing bean.\n\nAs a corner case, it is possible to receive destruction callbacks from a custom scope --\nfor example, for a request-scoped inner bean contained within a singleton bean. The creation\nof the inner bean instance is tied to its containing bean, but destruction callbacks let it\nparticipate in the request scope's lifecycle. This is not a common scenario. Inner beans\ntypically simply share their containing bean's scope.\n\n[[beans-collection-elements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "Inner Beans", "heading_level": 2, "file_order": 44, "section_index": 4, "content_hash": "d3484e1bfca17c65c07c0ca6f2d28856b9cb06241ca80b1922a6e96603a7b156", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:9f1c4901ff729d86d40906a57a68c003e758b554064d0780e415d855c022391e", "content": "The `<list/>`, `<set/>`, `<map/>`, and `<props/>` elements set the properties\nand arguments of the Java `Collection` types `List`, `Set`, `Map`, and `Properties`,\nrespectively. The following example shows how to use them:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"moreComplexObject\" class=\"example.ComplexObject\">\n <!-- results in a setAdminEmails(java.util.Properties) call -->\n <property name=\"adminEmails\">\n <props>\n <prop key=\"administrator\">administrator@example.org</prop>\n <prop key=\"support\">support@example.org</prop>\n <prop key=\"development\">development@example.org</prop>\n </props>\n </property>\n <!-- results in a setSomeList(java.util.List) call -->\n <property name=\"someList\">\n <list>\n <value>a list element followed by a reference</value>\n <ref bean=\"myDataSource\" />\n </list>\n </property>\n <!-- results in a setSomeMap(java.util.Map) call -->\n <property name=\"someMap\">\n <map>\n <entry key=\"an entry\" value=\"just some string\"/>\n <entry key=\"a ref\" value-ref=\"myDataSource\"/>\n </map>\n </property>\n <!-- results in a setSomeSet(java.util.Set) call -->\n <property name=\"someSet\">\n <set>\n <value>just some string</value>\n <ref bean=\"myDataSource\" />\n </set>\n </property>\n\t</bean>\n----\n\nThe value of a map key or value, or a set value, can also be any of the\nfollowing elements:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\tbean | ref | idref | list | set | map | props | value | null\n----\n\n[[beans-collection-elements-merging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "Collections", "heading_level": 2, "file_order": 44, "section_index": 5, "content_hash": "9f1c4901ff729d86d40906a57a68c003e758b554064d0780e415d855c022391e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:2b55f1bbaab4369de2bfea27317493b854a8a1b515aed950ed00b35e03d6d123", "content": "The Spring container also supports merging collections. An application\ndeveloper can define a parent `<list/>`, `<map/>`, `<set/>` or `<props/>` element\nand have child `<list/>`, `<map/>`, `<set/>` or `<props/>` elements inherit and\noverride values from the parent collection. That is, the child collection's values are\nthe result of merging the elements of the parent and child collections, with the child's\ncollection elements overriding values specified in the parent collection.\n\nThis section on merging discusses the parent-child bean mechanism. Readers unfamiliar\nwith parent and child bean definitions may wish to read the\nxref:core/beans/child-bean-definitions.adoc[relevant section] before continuing.\n\nThe following example demonstrates collection merging:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"parent\" abstract=\"true\" class=\"example.ComplexObject\">\n <property name=\"adminEmails\">\n <props>\n <prop key=\"administrator\">administrator@example.com</prop>\n <prop key=\"support\">support@example.com</prop>\n </props>\n </property>\n </bean>\n <bean id=\"child\" parent=\"parent\">\n <property name=\"adminEmails\">\n <!-- the merge is specified on the child collection definition -->\n <props merge=\"true\">\n <prop key=\"sales\">sales@example.com</prop>\n <prop key=\"support\">support@example.co.uk</prop>\n </props>\n </property>\n </bean>\n\t<beans>\n----\n\nNotice the use of the `merge=true` attribute on the `<props/>` element of the\n`adminEmails` property of the `child` bean definition. When the `child` bean is resolved\nand instantiated by the container, the resulting instance has an `adminEmails`\n`Properties` collection that contains the result of merging the child's\n`adminEmails` collection with the parent's `adminEmails` collection. The following listing\nshows the result:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nadministrator=administrator@example.com\nsales=sales@example.com\nsupport=support@example.co.uk\n----\n\nThe child `Properties` collection's value set inherits all property elements from the\nparent `<props/>`, and the child's value for the `support` value overrides the value in\nthe parent collection.\n\nThis merging behavior applies similarly to the `<list/>`, `<map/>`, and `<set/>`\ncollection types. In the specific case of the `<list/>` element, the semantics\nassociated with the `List` collection type (that is, the notion of an `ordered`\ncollection of values) is maintained. The parent's values precede all of the child list's\nvalues. In the case of the `Map`, `Set`, and `Properties` collection types, no ordering\nexists. Hence, no ordering semantics are in effect for the collection types that underlie\nthe associated `Map`, `Set`, and `Properties` implementation types that the container\nuses internally.\n\n[[beans-collection-merge-limitations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "Collection Merging", "heading_level": 3, "file_order": 44, "section_index": 6, "content_hash": "2b55f1bbaab4369de2bfea27317493b854a8a1b515aed950ed00b35e03d6d123", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:e4bf54824405581589f57eee24f2f96a2fcd2e8d8eecf73c01bc3f4681d9a6c1", "content": "You cannot merge different collection types (such as a `Map` and a `List`). If you\ndo attempt to do so, an appropriate `Exception` is thrown. The `merge` attribute must be\nspecified on the lower, inherited, child definition. Specifying the `merge` attribute on\na parent collection definition is redundant and does not result in the desired merging.\n\n[[beans-collection-elements-strongly-typed]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "Limitations of Collection Merging", "heading_level": 3, "file_order": 44, "section_index": 7, "content_hash": "e4bf54824405581589f57eee24f2f96a2fcd2e8d8eecf73c01bc3f4681d9a6c1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:cb51928c0d3457f939954a83b4d85fccd499ee8659edfae9e0771c39bf427d47", "content": "Thanks to Java's support for generic types, you can use strongly typed collections.\nThat is, it is possible to declare a `Collection` type such that it can only contain\n(for example) `String` elements. If you use Spring to dependency-inject a\nstrongly-typed `Collection` into a bean, you can take advantage of Spring's\ntype-conversion support such that the elements of your strongly-typed `Collection`\ninstances are converted to the appropriate type prior to being added to the `Collection`.\nThe following Java class and bean definition show how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SomeClass {\n\n private Map<String, Float> accounts;\n\n public void setAccounts(Map<String, Float> accounts) {\n this.accounts = accounts;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nclass SomeClass {\n\tlateinit var accounts: Map<String, Float>\n}\n----\n======\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"something\" class=\"x.y.SomeClass\">\n <property name=\"accounts\">\n <map>\n <entry key=\"one\" value=\"9.99\"/>\n <entry key=\"two\" value=\"2.75\"/>\n <entry key=\"six\" value=\"3.99\"/>\n </map>\n </property>\n </bean>\n\t</beans>\n----\n\nWhen the `accounts` property of the `something` bean is prepared for injection, the generics\ninformation about the element type of the strongly-typed `Map<String, Float>` is\navailable by reflection. Thus, Spring's type conversion infrastructure recognizes the\nvarious value elements as being of type `Float`, and the string values (`9.99`, `2.75`, and\n`3.99`) are converted into an actual `Float` type.\n\n[[beans-null-element]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "Strongly-typed collection", "heading_level": 3, "file_order": 44, "section_index": 8, "content_hash": "cb51928c0d3457f939954a83b4d85fccd499ee8659edfae9e0771c39bf427d47", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:4ea79da5d695601e0ef3714218c3fbffa4dcd5d56b76278d260cdd76ef81e9b6", "content": "Spring treats empty arguments for properties and the like as empty `Strings`. The\nfollowing XML-based configuration metadata snippet sets the `email` property to the empty\n`String` value (\"\").\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean class=\"ExampleBean\">\n <property name=\"email\" value=\"\"/>\n\t</bean>\n----\n\nThe preceding example is equivalent to the following Java code:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\texampleBean.setEmail(\"\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\texampleBean.email = \"\"\n----\n======\n\nThe `<null/>` element handles `null` values. The following listing shows an example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean class=\"ExampleBean\">\n <property name=\"email\">\n <null/>\n </property>\n\t</bean>\n----\n\nThe preceding configuration is equivalent to the following Java code:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\texampleBean.setEmail(null);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\texampleBean.email = null\n----\n======\n\n[[beans-p-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "Null and Empty String Values", "heading_level": 2, "file_order": 44, "section_index": 9, "content_hash": "4ea79da5d695601e0ef3714218c3fbffa4dcd5d56b76278d260cdd76ef81e9b6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:e51fb1afe06bc9b1ec11bad405ccf686d80d84c94b1eee7ffee86a78fbc6247e", "content": "The p-namespace lets you use the `bean` element's attributes (instead of nested\n`<property/>` elements) to describe your property values collaborating beans, or both.\n\nSpring supports extensible configuration formats xref:core/appendix/xsd-schemas.adoc[with namespaces],\nwhich are based on an XML Schema definition. The `beans` configuration format discussed in\nthis chapter is defined in an XML Schema document. However, the p-namespace is not defined\nin an XSD file and exists only in the core of Spring.\n\nThe following example shows two XML snippets (the first uses\nstandard XML format and the second uses the p-namespace) that resolve to the same result:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:p=\"http://www.springframework.org/schema/p\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <bean name=\"classic\" class=\"com.example.ExampleBean\">\n <property name=\"email\" value=\"someone@somewhere.com\"/>\n </bean>\n\n <bean name=\"p-namespace\" class=\"com.example.ExampleBean\"\n p:email=\"someone@somewhere.com\"/>\n\t</beans>\n----\n\nThe example shows an attribute in the p-namespace called `email` in the bean definition.\nThis tells Spring to include a property declaration. As previously mentioned, the\np-namespace does not have a schema definition, so you can set the name of the attribute\nto the property name.\n\nThis next example includes two more bean definitions that both have a reference to\nanother bean:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:p=\"http://www.springframework.org/schema/p\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <bean name=\"john-classic\" class=\"com.example.Person\">\n <property name=\"name\" value=\"John Doe\"/>\n <property name=\"spouse\" ref=\"jane\"/>\n </bean>\n\n <bean name=\"john-modern\"\n class=\"com.example.Person\"\n p:name=\"John Doe\"\n p:spouse-ref=\"jane\"/>\n\n <bean name=\"jane\" class=\"com.example.Person\">\n <property name=\"name\" value=\"Jane Doe\"/>\n </bean>\n\t</beans>\n----\n\nThis example includes not only a property value using the p-namespace\nbut also uses a special format to declare property references. Whereas the first bean\ndefinition uses `<property name=\"spouse\" ref=\"jane\"/>` to create a reference from bean\n`john` to bean `jane`, the second bean definition uses `p:spouse-ref=\"jane\"` as an\nattribute to do the exact same thing. In this case, `spouse` is the property name,\nwhereas the `-ref` part indicates that this is not a straight value but rather a\nreference to another bean.\n\nNOTE: The p-namespace is not as flexible as the standard XML format. For example, the format\nfor declaring property references clashes with properties that end in `Ref`, whereas the\nstandard XML format does not. We recommend that you choose your approach carefully and\ncommunicate this to your team members to avoid producing XML documents that use all\nthree approaches at the same time.\n\n[[beans-c-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "XML Shortcut with the p-namespace", "heading_level": 2, "file_order": 44, "section_index": 10, "content_hash": "e51fb1afe06bc9b1ec11bad405ccf686d80d84c94b1eee7ffee86a78fbc6247e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:b842e8d810f165db6e3db73edc567f61de490fe1f66704c3c332a1928c89a192", "content": "Similar to the\nxref:core/beans/dependencies/factory-properties-detailed.adoc#beans-p-namespace[XML Shortcut with the p-namespace],\nthe c-namespace, introduced in Spring 3.1, allows inlined attributes for configuring\nthe constructor arguments rather then nested `constructor-arg` elements.\n\nThe following example uses the `c:` namespace to do the same thing as the from\nxref:core/beans/dependencies/factory-collaborators.adoc#beans-constructor-injection[Constructor-based Dependency Injection]:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:c=\"http://www.springframework.org/schema/c\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <bean id=\"beanTwo\" class=\"x.y.ThingTwo\"/>\n <bean id=\"beanThree\" class=\"x.y.ThingThree\"/>\n\n <!-- traditional declaration with optional argument names -->\n <bean id=\"beanOne\" class=\"x.y.ThingOne\">\n <constructor-arg name=\"thingTwo\" ref=\"beanTwo\"/>\n <constructor-arg name=\"thingThree\" ref=\"beanThree\"/>\n <constructor-arg name=\"email\" value=\"something@somewhere.com\"/>\n </bean>\n\n <!-- c-namespace declaration with argument names -->\n <bean id=\"beanOne\" class=\"x.y.ThingOne\" c:thingTwo-ref=\"beanTwo\"\n c:thingThree-ref=\"beanThree\" c:email=\"something@somewhere.com\"/>\n\n\t</beans>\n----\n\nThe `c:` namespace uses the same conventions as the `p:` one (a trailing `-ref` for\nbean references) for setting the constructor arguments by their names. Similarly,\nit needs to be declared in the XML file even though it is not defined in an XSD schema\n(it exists inside the Spring core).\n\nFor the rare cases where the constructor argument names are not available (usually if\nthe bytecode was compiled without the `-parameters` flag), you can fall back to the\nargument indexes, as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- c-namespace index declaration -->\n\t<bean id=\"beanOne\" class=\"x.y.ThingOne\" c:_0-ref=\"beanTwo\" c:_1-ref=\"beanThree\"\n c:_2=\"something@somewhere.com\"/>\n----\n\nNOTE: Due to the XML grammar, the index notation requires the presence of the leading `_`,\nas XML attribute names cannot start with a number (even though some IDEs allow it).\nA corresponding index notation is also available for `<constructor-arg>` elements but\nnot commonly used since the plain order of declaration is usually sufficient there.\n\nIn practice, the constructor resolution\nxref:core/beans/dependencies/factory-collaborators.adoc#beans-factory-ctor-arguments-resolution[mechanism]\nis quite efficient in matching arguments, so unless you really need to, we recommend\nusing the name notation throughout your configuration.\n\n[[beans-compound-property-names]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "XML Shortcut with the c-namespace", "heading_level": 2, "file_order": 44, "section_index": 11, "content_hash": "b842e8d810f165db6e3db73edc567f61de490fe1f66704c3c332a1928c89a192", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:c8d99138093e6b17bac313c33953cf73d02df4eb65422f477b9b3586ed9ea92a", "content": "You can use compound or nested property names when you set bean properties, as long as\nall components of the path except the final property name are not `null`. Consider the\nfollowing bean definition:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"something\" class=\"things.ThingOne\">\n <property name=\"fred.bob.sammy\" value=\"123\" />\n\t</bean>\n----\n\nThe `something` bean has a `fred` property, which has a `bob` property, which has a `sammy`\nproperty, and that final `sammy` property is being set to a value of `123`. In order for\nthis to work, the `fred` property of `something` and the `bob` property of `fred` must not\nbe `null` after the bean is constructed. Otherwise, a `NullPointerException` is thrown.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc", "title": "factory-properties-detailed", "heading": "Compound Property Names", "heading_level": 2, "file_order": 44, "section_index": 12, "content_hash": "c8d99138093e6b17bac313c33953cf73d02df4eb65422f477b9b3586ed9ea92a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies/factory-properties-detailed.adoc"}}
{"id": "sha256:3fa6efb70efd6c996152d8698a0a28069f7b069eeed2dfd740f5fd08a98495ed", "content": "[[beans-java-basic-concepts]]\n\nThe central artifacts in Spring's Java configuration support are\n`@Configuration`-annotated classes and `@Bean`-annotated methods.\n\nThe `@Bean` annotation is used to indicate that a method instantiates, configures, and\ninitializes a new object to be managed by the Spring IoC container. For those familiar\nwith Spring's `<beans/>` XML configuration, the `@Bean` annotation plays the same role as\nthe `<bean/>` element. You can use `@Bean`-annotated methods with any Spring\n`@Component`. However, they are most often used with `@Configuration` beans.\n\nAnnotating a class with `@Configuration` indicates that its primary purpose is as a\nsource of bean definitions. Furthermore, `@Configuration` classes let inter-bean\ndependencies be defined by calling other `@Bean` methods in the same class.\nThe simplest possible `@Configuration` class reads as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean\n public MyServiceImpl myService() {\n return new MyServiceImpl();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean\n fun myService(): MyServiceImpl {\n return MyServiceImpl()\n }\n\t}\n----\n======\n\nThe preceding `AppConfig` class is equivalent to the following Spring `<beans/>` XML:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"myService\" class=\"com.acme.services.MyServiceImpl\"/>\n\t</beans>\n----\n\n.@Configuration classes with or without local calls between @Bean methods?\n****\nIn common scenarios, `@Bean` methods are to be declared within `@Configuration` classes,\nensuring that full configuration class processing applies and that cross-method\nreferences therefore get redirected to the container's lifecycle management.\nThis prevents the same `@Bean` method from accidentally being invoked through a regular\nJava method call, which helps to reduce subtle bugs that can be hard to track down.\n\nWhen `@Bean` methods are declared within classes that are not annotated with\n`@Configuration`, or when `@Configuration(proxyBeanMethods=false)` is declared,\nthey are referred to as being processed in a \"lite\" mode. In such scenarios,\n`@Bean` methods are effectively a general-purpose factory method mechanism without\nspecial runtime processing (that is, without generating a CGLIB subclass for it).\nA custom Java call to such a method will not get intercepted by the container and\ntherefore behaves just like a regular method call, creating a new instance every time\nrather than reusing an existing singleton (or scoped) instance for the given bean.\n\nAs a consequence, `@Bean` methods on classes without runtime proxying are not meant to\ndeclare inter-bean dependencies at all. Instead, they are expected to operate on their\ncontaining component's fields and, optionally, on arguments that a factory method may\ndeclare in order to receive autowired collaborators. Such a `@Bean` method therefore\nnever needs to invoke other `@Bean` methods; every such call can be expressed through\na factory method argument instead. The positive side-effect here is that no CGLIB\nsubclassing has to be applied at runtime, reducing the overhead and the footprint.\n****\n\nThe `@Bean` and `@Configuration` annotations are discussed in depth in the following sections.\nFirst, however, we cover the various ways of creating a Spring container by using\nJava-based configuration.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/basic-concepts.adoc", "title": "basic-concepts", "heading": "basic-concepts", "heading_level": 1, "file_order": 45, "section_index": 0, "content_hash": "3fa6efb70efd6c996152d8698a0a28069f7b069eeed2dfd740f5fd08a98495ed", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/basic-concepts.adoc"}}
{"id": "sha256:bd7c80c1078f1a30444ae0645deb98d5d3d0fcc7e0a1bdd67323b8f2ab76c27d", "content": "[[beans-java-bean-annotation]]\n\n`@Bean` is a method-level annotation and a direct analog of the XML `<bean/>` element.\nThe annotation supports some of the attributes offered by `<bean/>`, such as:\n\n* xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-initializingbean[init-method]\n* xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-disposablebean[destroy-method]\n* xref:core/beans/dependencies/factory-autowire.adoc[autowiring]\n* `name`.\n\nYou can use the `@Bean` annotation in a `@Configuration`-annotated or in a\n`@Component`-annotated class.\n\n[[beans-java-declaring-a-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc", "title": "bean-annotation", "heading": "bean-annotation", "heading_level": 1, "file_order": 46, "section_index": 0, "content_hash": "bd7c80c1078f1a30444ae0645deb98d5d3d0fcc7e0a1bdd67323b8f2ab76c27d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc"}}
{"id": "sha256:853cb83e6adcee237d7efaa1000c87dedd9707d71721086f30d3d4d2155c0a07", "content": "To declare a bean, you can annotate a method with the `@Bean` annotation. You use this\nmethod to register a bean definition within an `ApplicationContext` of the type\nspecified as the method's return value. By default, the bean name is the same as\nthe method name. The following example shows a `@Bean` method declaration:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean\n public TransferServiceImpl transferService() {\n return new TransferServiceImpl();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean\n fun transferService() = TransferServiceImpl()\n\t}\n----\n======\n\nThe preceding configuration is exactly equivalent to the following Spring XML:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"transferService\" class=\"com.acme.TransferServiceImpl\"/>\n\t</beans>\n----\n\nBoth declarations make a bean named `transferService` available in the\n`ApplicationContext`, bound to an object instance of type `TransferServiceImpl`, as the\nfollowing text image shows:\n\n[literal,subs=\"verbatim,quotes\"]\n----\ntransferService -> com.acme.TransferServiceImpl\n----\n\nYou can also use default methods to define beans. This allows composition of bean\nconfigurations by implementing interfaces with bean definitions on default methods.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface BaseConfig {\n\n @Bean\n default TransferServiceImpl transferService() {\n return new TransferServiceImpl();\n }\n\t}\n\n\t@Configuration\n\tpublic class AppConfig implements BaseConfig {\n\n\t}\n----\n======\n\nYou can also declare your `@Bean` method with an interface (or base class)\nreturn type, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean\n public TransferService transferService() {\n return new TransferServiceImpl();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean\n fun transferService(): TransferService {\n return TransferServiceImpl()\n }\n\t}\n----\n======\n\nHowever, this limits the visibility for advance type prediction to the specified\ninterface type (`TransferService`). Then, with the full type (`TransferServiceImpl`)\nknown to the container only once the affected singleton bean has been instantiated.\nNon-lazy singleton beans get instantiated according to their declaration order,\nso you may see different type matching results depending on when another component\ntries to match by a non-declared type (such as `@Autowired TransferServiceImpl`,\nwhich resolves only once the `transferService` bean has been instantiated).\n\nTIP: If you consistently refer to your types by a declared service interface, your\n`@Bean` return types may safely join that design decision. However, for components\nthat implement several interfaces or for components potentially referred to by their\nimplementation type, it is safer to declare the most specific return type possible\n(at least as specific as required by the injection points that refer to your bean).\n\n[[beans-java-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc", "title": "bean-annotation", "heading": "Declaring a Bean", "heading_level": 2, "file_order": 46, "section_index": 1, "content_hash": "853cb83e6adcee237d7efaa1000c87dedd9707d71721086f30d3d4d2155c0a07", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc"}}
{"id": "sha256:52a4c69285f29001d900ac0e31aeba847506a84cc92eb05f811dee2513a054a0", "content": "A `@Bean`-annotated method can have an arbitrary number of parameters that describe the\ndependencies required to build that bean. For instance, if our `TransferService`\nrequires an `AccountRepository`, we can materialize that dependency with a method\nparameter, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean\n public TransferService transferService(AccountRepository accountRepository) {\n return new TransferServiceImpl(accountRepository);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean\n fun transferService(accountRepository: AccountRepository): TransferService {\n return TransferServiceImpl(accountRepository)\n }\n\t}\n----\n======\n\nThe resolution mechanism is pretty much identical to constructor-based dependency\ninjection. See\nxref:core/beans/dependencies/factory-collaborators.adoc#beans-constructor-injection[the relevant section]\nfor more details.\n\n[[beans-java-lifecycle-callbacks]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc", "title": "bean-annotation", "heading": "Bean Dependencies", "heading_level": 2, "file_order": 46, "section_index": 2, "content_hash": "52a4c69285f29001d900ac0e31aeba847506a84cc92eb05f811dee2513a054a0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc"}}
{"id": "sha256:62073b4bebfa7fec73696b61a9252c2c2634b22b24803cafdb6b0e9d34a2cad9", "content": "Any classes defined with the `@Bean` annotation support the regular lifecycle callbacks\nand can use the `@PostConstruct` and `@PreDestroy` annotations from JSR-250. See\nxref:core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc[JSR-250 annotations] for further\ndetails.\n\nThe regular Spring xref:core/beans/factory-nature.adoc[lifecycle] callbacks are fully supported as\nwell. If a bean implements `InitializingBean`, `DisposableBean`, or `Lifecycle`, their\nrespective methods are called by the container.\n\nThe standard set of `*Aware` interfaces (such as xref:core/beans/beanfactory.adoc[BeanFactoryAware],\nxref:core/beans/factory-nature.adoc#beans-factory-aware[BeanNameAware],\nxref:core/beans/context-introduction.adoc#context-functionality-messagesource[MessageSourceAware],\nxref:core/beans/factory-nature.adoc#beans-factory-aware[ApplicationContextAware], and so on) are also fully supported.\n\nThe `@Bean` annotation supports specifying arbitrary initialization and destruction\ncallback methods, much like Spring XML's `init-method` and `destroy-method` attributes\non the `bean` element, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class BeanOne {\n\n public void init() {\n // initialization logic\n }\n\t}\n\n\tpublic class BeanTwo {\n\n public void cleanup() {\n // destruction logic\n }\n\t}\n\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean(initMethod = \"init\")\n public BeanOne beanOne() {\n return new BeanOne();\n }\n\n @Bean(destroyMethod = \"cleanup\")\n public BeanTwo beanTwo() {\n return new BeanTwo();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nclass BeanOne {\n\n\tfun init() {\n // initialization logic\n\t}\n}\n\nclass BeanTwo {\n\n\tfun cleanup() {\n // destruction logic\n\t}\n}\n\n@Configuration\nclass AppConfig {\n\n\t@Bean(initMethod = \"init\")\n\tfun beanOne() = BeanOne()\n\n\t@Bean(destroyMethod = \"cleanup\")\n\tfun beanTwo() = BeanTwo()\n}\n----\n======\n\n[NOTE]\n=====\nBy default, beans defined with Java configuration that have a public `close` or `shutdown`\nmethod are automatically enlisted with a destruction callback. If you have a public\n`close` or `shutdown` method and you do not wish for it to be called when the container\nshuts down, you can add `@Bean(destroyMethod = \"\")` to your bean definition to disable the\ndefault `(inferred)` mode.\n\nYou may want to do that by default for a resource that you acquire with JNDI, as its\nlifecycle is managed outside the application. In particular, make sure to always do it\nfor a `DataSource`, as it is known to be problematic on Jakarta EE application servers.\n\nThe following example shows how to prevent an automatic destruction callback for a\n`DataSource`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean(destroyMethod = \"\")\n\tpublic DataSource dataSource() throws NamingException {\n return (DataSource) jndiTemplate.lookup(\"MyDS\");\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean(destroyMethod = \"\")\n\tfun dataSource(): DataSource {\n return jndiTemplate.lookup(\"MyDS\") as DataSource\n\t}\n----\n======\n\nAlso, with `@Bean` methods, you typically use programmatic JNDI lookups, either by\nusing Spring's `JndiTemplate` or `JndiLocatorDelegate` helpers or straight JNDI\n`InitialContext` usage but not the `JndiObjectFactoryBean` variant (which would force\nyou to declare the return type as the `FactoryBean` type instead of the actual target\ntype, making it harder to use for cross-reference calls in other `@Bean` methods that\nintend to refer to the provided resource here).\n=====\n\nIn the case of `BeanOne` from the example above the preceding note, it would be\nequally valid to call the `init()` method directly during construction, as the\nfollowing example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean\n public BeanOne beanOne() {\n BeanOne beanOne = new BeanOne();\n beanOne.init();\n return beanOne;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean\n fun beanOne() = BeanOne().apply {\n init()\n }\n\n // ...\n\t}\n----\n======\n\nTIP: When you work directly in Java, you can do anything you like with your objects and do\nnot always need to rely on the container lifecycle.\n\n[[beans-java-specifying-bean-scope]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc", "title": "bean-annotation", "heading": "Receiving Lifecycle Callbacks", "heading_level": 2, "file_order": 46, "section_index": 3, "content_hash": "62073b4bebfa7fec73696b61a9252c2c2634b22b24803cafdb6b0e9d34a2cad9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc"}}
{"id": "sha256:8da02e62688a8646754ef118b9cb96810ae98951d30330f5b8ce3a7fe835ef5a", "content": "Spring includes the `@Scope` annotation so that you can specify the scope of a bean.\n\n[[beans-java-available-scopes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc", "title": "bean-annotation", "heading": "Specifying Bean Scope", "heading_level": 2, "file_order": 46, "section_index": 4, "content_hash": "8da02e62688a8646754ef118b9cb96810ae98951d30330f5b8ce3a7fe835ef5a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc"}}
{"id": "sha256:218aa7ecadca100163a8a442d65a6cd9918d217840ab14b429c417da3d582cfa", "content": "You can specify that your beans defined with the `@Bean` annotation should have a\nspecific scope. You can use any of the standard scopes specified in the\nxref:core/beans/factory-scopes.adoc[Bean Scopes] section.\n\nThe default scope is `singleton`, but you can override this with the `@Scope` annotation,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class MyConfiguration {\n\n @Bean\n @Scope(\"prototype\")\n public Encryptor encryptor() {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass MyConfiguration {\n\n @Bean\n @Scope(\"prototype\")\n fun encryptor(): Encryptor {\n // ...\n }\n\t}\n----\n======\n\n[[beans-java-scoped-proxy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc", "title": "bean-annotation", "heading": "Using the `@Scope` Annotation", "heading_level": 3, "file_order": 46, "section_index": 5, "content_hash": "218aa7ecadca100163a8a442d65a6cd9918d217840ab14b429c417da3d582cfa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc"}}
{"id": "sha256:12426d8c0f806339c65e0aa9f86f27664eb0b968e2627a6f2a1024166c1a73cf", "content": "Spring offers a convenient way of working with scoped dependencies through\nxref:core/beans/factory-scopes.adoc#beans-factory-scopes-other-injection[scoped proxies]. The easiest way to create\nsuch a proxy when using the XML configuration is the `<aop:scoped-proxy/>` element.\nConfiguring your beans in Java with a `@Scope` annotation offers equivalent support\nwith the `proxyMode` attribute. The default is `ScopedProxyMode.DEFAULT`, which\ntypically indicates that no scoped proxy should be created unless a different default\nhas been configured at the component-scan instruction level. You can specify\n`ScopedProxyMode.TARGET_CLASS`, `ScopedProxyMode.INTERFACES` or `ScopedProxyMode.NO`.\n\nIf you port the scoped proxy example from the XML reference documentation (see\nxref:core/beans/factory-scopes.adoc#beans-factory-scopes-other-injection[scoped proxies]) to our `@Bean` using Java,\nit resembles the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// an HTTP Session-scoped bean exposed as a proxy\n\t@Bean\n\t@SessionScope\n\tpublic UserPreferences userPreferences() {\n return new UserPreferences();\n\t}\n\n\t@Bean\n\tpublic Service userService() {\n UserService service = new SimpleUserService();\n // a reference to the proxied userPreferences bean\n service.setUserPreferences(userPreferences());\n return service;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// an HTTP Session-scoped bean exposed as a proxy\n\t@Bean\n\t@SessionScope\n\tfun userPreferences() = UserPreferences()\n\n\t@Bean\n\tfun userService(): Service {\n return SimpleUserService().apply {\n // a reference to the proxied userPreferences bean\n setUserPreferences(userPreferences())\n }\n\t}\n----\n======\n\n[[beans-java-customizing-bean-naming]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc", "title": "bean-annotation", "heading": "`@Scope` and `scoped-proxy`", "heading_level": 3, "file_order": 46, "section_index": 6, "content_hash": "12426d8c0f806339c65e0aa9f86f27664eb0b968e2627a6f2a1024166c1a73cf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc"}}
{"id": "sha256:ef2902b198cfc741dcf915cd109bc7c950e2f5688d588dae7def9401fae18bc9", "content": "By default, configuration classes use a `@Bean` method's name as the name of the\nresulting bean. This functionality can be overridden, however, with the `name` attribute,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean(\"myThing\")\n public Thing thing() {\n return new Thing();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean(\"myThing\")\n fun thing() = Thing()\n\t}\n----\n======\n\n[[beans-java-bean-aliasing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc", "title": "bean-annotation", "heading": "Customizing Bean Naming", "heading_level": 2, "file_order": 46, "section_index": 7, "content_hash": "ef2902b198cfc741dcf915cd109bc7c950e2f5688d588dae7def9401fae18bc9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc"}}
{"id": "sha256:588601d88f6c9d4d683972b01a37b55d7b668a421a68f906b244083aabb00bbd", "content": "As discussed in xref:core/beans/definition.adoc#beans-beanname[Naming Beans], it is\nsometimes desirable to give a single bean multiple names, otherwise known as bean aliasing.\nThe `name` attribute of the `@Bean` annotation accepts a String array for this purpose.\nThe following example shows how to set a number of aliases for a bean:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean({\"dataSource\", \"subsystemA-dataSource\", \"subsystemB-dataSource\"})\n public DataSource dataSource() {\n // instantiate, configure and return DataSource bean...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean(\"dataSource\", \"subsystemA-dataSource\", \"subsystemB-dataSource\")\n fun dataSource(): DataSource {\n // instantiate, configure and return DataSource bean...\n }\n\t}\n----\n======\n\n[[beans-java-bean-description]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc", "title": "bean-annotation", "heading": "Bean Aliasing", "heading_level": 2, "file_order": 46, "section_index": 8, "content_hash": "588601d88f6c9d4d683972b01a37b55d7b668a421a68f906b244083aabb00bbd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc"}}
{"id": "sha256:758667850e2b6429d478fd8f96a720923b780c6d2d2e41203b8dff5090a8d895", "content": "Sometimes, it is helpful to provide a more detailed textual description of a bean. This can\nbe particularly useful when beans are exposed (perhaps through JMX) for monitoring purposes.\n\nTo add a description to a `@Bean`, you can use the\n{spring-framework-api}/context/annotation/Description.html[`@Description`]\nannotation, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean\n @Description(\"Provides a basic example of a bean\")\n public Thing thing() {\n return new Thing();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean\n @Description(\"Provides a basic example of a bean\")\n fun thing() = Thing()\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc", "title": "bean-annotation", "heading": "Bean Description", "heading_level": 2, "file_order": 46, "section_index": 9, "content_hash": "758667850e2b6429d478fd8f96a720923b780c6d2d2e41203b8dff5090a8d895", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/bean-annotation.adoc"}}
{"id": "sha256:25e84bdf039fea0dc04f510c1486397cdd605124a0047a98d39d8d4ea48d5759", "content": "[[beans-java-composing-configuration-classes]]\n\nSpring's Java-based configuration feature lets you compose annotations, which can reduce\nthe complexity of your configuration.\n\n[[beans-java-using-import]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc", "title": "composing-configuration-classes", "heading": "composing-configuration-classes", "heading_level": 1, "file_order": 47, "section_index": 0, "content_hash": "25e84bdf039fea0dc04f510c1486397cdd605124a0047a98d39d8d4ea48d5759", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc"}}
{"id": "sha256:f1caaf1f77783d771214d7e4a3ee3a497e47bb6f3ef086bc3f2eeca9162fc54e", "content": "Much as the `<import/>` element is used within Spring XML files to aid in modularizing\nconfigurations, the `@Import` annotation allows for loading `@Bean` definitions from\nanother configuration class, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class ConfigA {\n\n @Bean\n public A a() {\n return new A();\n }\n\t}\n\n\t@Configuration\n\t@Import(ConfigA.class)\n\tpublic class ConfigB {\n\n @Bean\n public B b() {\n return new B();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass ConfigA {\n\n @Bean\n fun a() = A()\n\t}\n\n\t@Configuration\n\t@Import(ConfigA::class)\n\tclass ConfigB {\n\n @Bean\n fun b() = B()\n\t}\n----\n======\n\nNow, rather than needing to specify both `ConfigA.class` and `ConfigB.class` when\ninstantiating the context, only `ConfigB` needs to be supplied explicitly, as the\nfollowing example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic static void main(String[] args) {\n ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);\n\n // now both beans A and B will be available...\n A a = ctx.getBean(A.class);\n B b = ctx.getBean(B.class);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\tfun main() {\n val ctx = AnnotationConfigApplicationContext(ConfigB::class.java)\n\n // now both beans A and B will be available...\n val a = ctx.getBean<A>()\n val b = ctx.getBean<B>()\n\t}\n----\n======\n\nThis approach simplifies container instantiation, as only one class needs to be dealt\nwith, rather than requiring you to remember a potentially large number of\n`@Configuration` classes during construction.\n\nTIP: As of Spring Framework 4.2, `@Import` also supports references to regular component\nclasses, analogous to the `AnnotationConfigApplicationContext.register` method.\nThis is particularly useful if you want to avoid component scanning, by using a few\nconfiguration classes as entry points to explicitly define all your components.\n\n[[beans-java-injecting-imported-beans]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc", "title": "composing-configuration-classes", "heading": "Using the `@Import` Annotation", "heading_level": 2, "file_order": 47, "section_index": 1, "content_hash": "f1caaf1f77783d771214d7e4a3ee3a497e47bb6f3ef086bc3f2eeca9162fc54e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc"}}
{"id": "sha256:befb93d1d7a9207c511f4bd72fdaa385b0a1c7414ba46a744ce347ebf772aecb", "content": "The preceding example works but is simplistic. In most practical scenarios, beans have\ndependencies on one another across configuration classes. When using XML, this is not an\nissue, because no compiler is involved, and you can declare\n`ref=\"someBean\"` and trust Spring to work it out during container initialization.\nWhen using `@Configuration` classes, the Java compiler places constraints on\nthe configuration model, in that references to other beans must be valid Java syntax.\n\nFortunately, solving this problem is simple. As\nxref:core/beans/java/bean-annotation.adoc#beans-java-dependencies[we already discussed],\na `@Bean` method can have an arbitrary number of parameters that describe the bean\ndependencies. Consider the following more realistic scenario with several `@Configuration`\nclasses, each depending on beans declared in the others:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class ServiceConfig {\n\n @Bean\n public TransferService transferService(AccountRepository accountRepository) {\n return new TransferServiceImpl(accountRepository);\n }\n\t}\n\n\t@Configuration\n\tpublic class RepositoryConfig {\n\n @Bean\n public AccountRepository accountRepository(DataSource dataSource) {\n return new JdbcAccountRepository(dataSource);\n }\n\t}\n\n\t@Configuration\n\t@Import({ServiceConfig.class, RepositoryConfig.class})\n\tpublic class SystemTestConfig {\n\n @Bean\n public DataSource dataSource() {\n // return new DataSource\n }\n\t}\n\n\tpublic static void main(String[] args) {\n ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);\n // everything wires up across configuration classes...\n TransferService transferService = ctx.getBean(TransferService.class);\n transferService.transfer(100.00, \"A123\", \"C456\");\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\t@Configuration\n\tclass ServiceConfig {\n\n @Bean\n fun transferService(accountRepository: AccountRepository): TransferService {\n return TransferServiceImpl(accountRepository)\n }\n\t}\n\n\t@Configuration\n\tclass RepositoryConfig {\n\n @Bean\n fun accountRepository(dataSource: DataSource): AccountRepository {\n return JdbcAccountRepository(dataSource)\n }\n\t}\n\n\t@Configuration\n\t@Import(ServiceConfig::class, RepositoryConfig::class)\n\tclass SystemTestConfig {\n\n @Bean\n fun dataSource(): DataSource {\n // return new DataSource\n }\n\t}\n\n\tfun main() {\n val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)\n // everything wires up across configuration classes...\n val transferService = ctx.getBean<TransferService>()\n transferService.transfer(100.00, \"A123\", \"C456\")\n\t}\n----\n======\n\nThere is another way to achieve the same result. Remember that `@Configuration` classes are\nultimately only another bean in the container: This means that they can take advantage of\n`@Autowired` and `@Value` injection and other features the same as any other bean.\n\n[WARNING]\n====\nMake sure that the dependencies you inject that way are of the simplest kind only. `@Configuration`\nclasses are processed quite early during the initialization of the context, and forcing a dependency\nto be injected this way may lead to unexpected early initialization. Whenever possible, resort to\nparameter-based injection, as in the preceding example.\n\nAvoid access to locally defined beans within a `@PostConstruct` method on the same configuration\nclass. This effectively leads to a circular reference since non-static `@Bean` methods semantically\nrequire a fully initialized configuration class instance to be called on. With circular references\ndisallowed (for example, in Spring Boot 2.6+), this may trigger a `BeanCurrentlyInCreationException`.\n\nAlso, be particularly careful with `BeanPostProcessor` and `BeanFactoryPostProcessor` definitions\nthrough `@Bean`. Those should usually be declared as `static @Bean` methods, not triggering the\ninstantiation of their containing configuration class. Otherwise, `@Autowired` and `@Value` may not\nwork on the configuration class itself, since it is possible to create it as a bean instance earlier than\n{spring-framework-api}/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html[`AutowiredAnnotationBeanPostProcessor`].\n====\n\nThe following example shows how one bean can be autowired to another bean:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class ServiceConfig {\n\n @Autowired\n private AccountRepository accountRepository;\n\n @Bean\n public TransferService transferService() {\n return new TransferServiceImpl(accountRepository);\n }\n\t}\n\n\t@Configuration\n\tpublic class RepositoryConfig {\n\n private final DataSource dataSource;\n\n public RepositoryConfig(DataSource dataSource) {\n this.dataSource = dataSource;\n }\n\n @Bean\n public AccountRepository accountRepository() {\n return new JdbcAccountRepository(dataSource);\n }\n\t}\n\n\t@Configuration\n\t@Import({ServiceConfig.class, RepositoryConfig.class})\n\tpublic class SystemTestConfig {\n\n @Bean\n public DataSource dataSource() {\n // return new DataSource\n }\n\t}\n\n\tpublic static void main(String[] args) {\n ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);\n // everything wires up across configuration classes...\n TransferService transferService = ctx.getBean(TransferService.class);\n transferService.transfer(100.00, \"A123\", \"C456\");\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\t@Configuration\n\tclass ServiceConfig {\n\n @Autowired\n lateinit var accountRepository: AccountRepository\n\n @Bean\n fun transferService(): TransferService {\n return TransferServiceImpl(accountRepository)\n }\n\t}\n\n\t@Configuration\n\tclass RepositoryConfig(private val dataSource: DataSource) {\n\n @Bean\n fun accountRepository(): AccountRepository {\n return JdbcAccountRepository(dataSource)\n }\n\t}\n\n\t@Configuration\n\t@Import(ServiceConfig::class, RepositoryConfig::class)\n\tclass SystemTestConfig {\n\n @Bean\n fun dataSource(): DataSource {\n // return new DataSource\n }\n\t}\n\n\tfun main() {\n val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)\n // everything wires up across configuration classes...\n val transferService = ctx.getBean<TransferService>()\n transferService.transfer(100.00, \"A123\", \"C456\")\n\t}\n----\n======\n\nTIP: Note that there is no need to specify `@Autowired` if the target bean defines\nonly one constructor.\n\n[discrete]\n[[beans-java-injecting-imported-beans-fq]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc", "title": "composing-configuration-classes", "heading": "Injecting Dependencies on Imported `@Bean` Definitions", "heading_level": 3, "file_order": 47, "section_index": 2, "content_hash": "befb93d1d7a9207c511f4bd72fdaa385b0a1c7414ba46a744ce347ebf772aecb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc"}}
{"id": "sha256:bdf26cdb02d8a3a6ff386cc07e7f9a540e8b262e2d1bdbe0e3686f26ee14ce99", "content": "In the preceding scenario, using `@Autowired` works well and provides the desired\nmodularity, but determining exactly where the autowired bean definitions are declared is\nstill somewhat ambiguous. For example, as a developer looking at `ServiceConfig`, how do\nyou know exactly where the `@Autowired AccountRepository` bean is declared? It is not\nexplicit in the code, and this may be just fine. Note that the\n{spring-site-tools}[Spring Tools] IDE support provides tooling that can render graphs\nshowing how everything is wired, which may be all you need. Also, your Java IDE can\neasily find all declarations and uses of the `AccountRepository` type and quickly show\nyou the location of `@Bean` methods that return that type.\n\nIn cases where this ambiguity is not acceptable and you wish to have direct navigation\nfrom within your IDE from one `@Configuration` class to another, consider autowiring the\nconfiguration classes themselves. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class ServiceConfig {\n\n @Autowired\n private RepositoryConfig repositoryConfig;\n\n @Bean\n public TransferService transferService() {\n // navigate 'through' the config class to the @Bean method!\n return new TransferServiceImpl(repositoryConfig.accountRepository());\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n@Configuration\nclass ServiceConfig {\n\n\t@Autowired\n\tprivate lateinit var repositoryConfig: RepositoryConfig\n\n\t@Bean\n\tfun transferService(): TransferService {\n // navigate 'through' the config class to the @Bean method!\n return TransferServiceImpl(repositoryConfig.accountRepository())\n\t}\n}\n----\n======\n\nIn the preceding situation, where `AccountRepository` is defined is completely explicit.\nHowever, `ServiceConfig` is now tightly coupled to `RepositoryConfig`. That is the\ntradeoff. This tight coupling can be somewhat mitigated by using interface-based or\nabstract class-based `@Configuration` classes. Consider the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class ServiceConfig {\n\n @Autowired\n private RepositoryConfig repositoryConfig;\n\n @Bean\n public TransferService transferService() {\n return new TransferServiceImpl(repositoryConfig.accountRepository());\n }\n\t}\n\n\t@Configuration\n\tpublic interface RepositoryConfig {\n\n @Bean\n AccountRepository accountRepository();\n\t}\n\n\t@Configuration\n\tpublic class DefaultRepositoryConfig implements RepositoryConfig {\n\n @Bean\n public AccountRepository accountRepository() {\n return new JdbcAccountRepository(...);\n }\n\t}\n\n\t@Configuration\n\t@Import({ServiceConfig.class, DefaultRepositoryConfig.class}) // import the concrete config!\n\tpublic class SystemTestConfig {\n\n @Bean\n public DataSource dataSource() {\n // return DataSource\n }\n\n\t}\n\n\tpublic static void main(String[] args) {\n ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);\n TransferService transferService = ctx.getBean(TransferService.class);\n transferService.transfer(100.00, \"A123\", \"C456\");\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\t@Configuration\n\tclass ServiceConfig {\n\n @Autowired\n private lateinit var repositoryConfig: RepositoryConfig\n\n @Bean\n fun transferService(): TransferService {\n return TransferServiceImpl(repositoryConfig.accountRepository())\n }\n\t}\n\n\t@Configuration\n\tinterface RepositoryConfig {\n\n @Bean\n fun accountRepository(): AccountRepository\n\t}\n\n\t@Configuration\n\tclass DefaultRepositoryConfig : RepositoryConfig {\n\n @Bean\n fun accountRepository(): AccountRepository {\n return JdbcAccountRepository(...)\n }\n\t}\n\n\t@Configuration\n\t@Import(ServiceConfig::class, DefaultRepositoryConfig::class) // import the concrete config!\n\tclass SystemTestConfig {\n\n @Bean\n fun dataSource(): DataSource {\n // return DataSource\n }\n\n\t}\n\n\tfun main() {\n val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)\n val transferService = ctx.getBean<TransferService>()\n transferService.transfer(100.00, \"A123\", \"C456\")\n\t}\n----\n======\n\nNow `ServiceConfig` is loosely coupled with respect to the concrete\n`DefaultRepositoryConfig`, and built-in IDE tooling is still useful: You can easily\nget a type hierarchy of `RepositoryConfig` implementations. In this\nway, navigating `@Configuration` classes and their dependencies becomes no different\nthan the usual process of navigating interface-based code.\n\n[[beans-java-startup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc", "title": "composing-configuration-classes", "heading": "Fully-qualifying imported beans for ease of navigation", "heading_level": 4, "file_order": 47, "section_index": 3, "content_hash": "bdf26cdb02d8a3a6ff386cc07e7f9a540e8b262e2d1bdbe0e3686f26ee14ce99", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc"}}
{"id": "sha256:fd7904b1e3a4900a7a837c7aa315a895219a2baf53e1e660c1a0867bf0d58e42", "content": "If you want to influence the startup creation order of certain singleton beans, consider\ndeclaring some of them as `@Lazy` for creation on first access instead of on startup.\n\n`@DependsOn` forces certain other beans to be initialized first, making sure that\nthe specified beans are created before the current bean, beyond what the latter's\ndirect dependencies imply.\n\n[[beans-java-startup-background]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc", "title": "composing-configuration-classes", "heading": "Influencing the Startup of `@Bean`-defined Singletons", "heading_level": 2, "file_order": 47, "section_index": 4, "content_hash": "fd7904b1e3a4900a7a837c7aa315a895219a2baf53e1e660c1a0867bf0d58e42", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc"}}
{"id": "sha256:eb317ef2f89e6504e029704ae066e69d4a5056a83387664e1dfc61ac4a19f7e7", "content": "As of 6.2, there is a background initialization option: `@Bean(bootstrap=BACKGROUND)`\nallows for singling out specific beans for background initialization, covering the\nentire bean creation step for each such bean on context startup.\n\nDependent beans with non-lazy injection points automatically wait for the bean instance\nto be completed. All regular background initializations are forced to complete at the end\nof context startup. Only beans additionally marked as `@Lazy` are allowed to be completed\nlater (up until the first actual access).\n\nBackground initialization typically goes together with `@Lazy` (or `ObjectProvider`)\ninjection points in dependent beans. Otherwise, the main bootstrap thread is going to\nblock when an actual background-initialized bean instance needs to be injected early.\n\nThis form of concurrent startup applies to individual beans: if such a bean depends on\nother beans, they need to have been initialized already, either simply through being\ndeclared earlier or through `@DependsOn` which enforces initialization in the main\nbootstrap thread before background initialization for the affected bean is triggered.\n\n[NOTE]\n====\nA `bootstrapExecutor` bean of type `Executor` must be declared for background\nbootstrapping to be actually active. Otherwise, the background markers will be ignored at\nruntime.\n\nThe bootstrap executor may be a bounded executor just for startup purposes or a shared\nthread pool which serves for other purposes as well.\n====\n\n[[beans-java-conditional]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc", "title": "composing-configuration-classes", "heading": "Background Initialization", "heading_level": 3, "file_order": 47, "section_index": 5, "content_hash": "eb317ef2f89e6504e029704ae066e69d4a5056a83387664e1dfc61ac4a19f7e7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc"}}
{"id": "sha256:c0fbd97d0dd240ba8721ed04dd264cf77b24c6fd0c14c194be933ce9a00b4f2e", "content": "It is often useful to conditionally enable or disable a complete `@Configuration` class\nor even individual `@Bean` methods, based on some arbitrary system state. One common\nexample of this is to use the `@Profile` annotation to activate beans only when a specific\nprofile has been enabled in the Spring `Environment` (see xref:core/beans/environment.adoc#beans-definition-profiles[Bean Definition Profiles]\nfor details).\n\nThe `@Profile` annotation is actually implemented by using a much more flexible annotation\ncalled {spring-framework-api}/context/annotation/Conditional.html[`@Conditional`].\nThe `@Conditional` annotation indicates specific\n`org.springframework.context.annotation.Condition` implementations that should be\nconsulted before a `@Bean` is registered.\n\nImplementations of the `Condition` interface provide a `matches(...)`\nmethod that returns `true` or `false`. For example, the following listing shows the actual\n`Condition` implementation used for `@Profile`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Override\n\tpublic boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n // Read the @Profile annotation attributes\n MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());\n if (attrs != null) {\n for (Object value : attrs.get(\"value\")) {\n if (context.getEnvironment().matchesProfiles((String[]) value)) {\n return true;\n }\n }\n return false;\n }\n return true;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\toverride fun matches(context: ConditionContext, metadata: AnnotatedTypeMetadata): Boolean {\n // Read the @Profile annotation attributes\n val attrs = metadata.getAllAnnotationAttributes(Profile::class.java.name)\n if (attrs != null) {\n for (value in attrs[\"value\"]!!) {\n if (context.environment.matchesProfiles(*value as Array<String>)) {\n return true\n }\n }\n return false\n }\n return true\n\t}\n----\n======\n\nSee the {spring-framework-api}/context/annotation/Conditional.html[`@Conditional`]\njavadoc for more detail.\n\n[[beans-java-combining]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc", "title": "composing-configuration-classes", "heading": "Conditionally Include `@Configuration` Classes or `@Bean` Methods", "heading_level": 2, "file_order": 47, "section_index": 6, "content_hash": "c0fbd97d0dd240ba8721ed04dd264cf77b24c6fd0c14c194be933ce9a00b4f2e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc"}}
{"id": "sha256:a515b68ef25a6794b275d4bd1376b0b391c8ef157d29c9b1f6d18baaa6c67b0c", "content": "Spring's `@Configuration` class support does not aim to be a 100% complete replacement\nfor Spring XML. Some facilities, such as Spring XML namespaces, remain an ideal way to\nconfigure the container. In cases where XML is convenient or necessary, you have a\nchoice: either instantiate the container in an \"`XML-centric`\" way by using, for example,\n`ClassPathXmlApplicationContext`, or instantiate it in a \"`Java-centric`\" way by using\n`AnnotationConfigApplicationContext` and the `@ImportResource` annotation to import XML\nas needed.\n\n[[beans-java-combining-xml-centric]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc", "title": "composing-configuration-classes", "heading": "Combining Java and XML Configuration", "heading_level": 2, "file_order": 47, "section_index": 7, "content_hash": "a515b68ef25a6794b275d4bd1376b0b391c8ef157d29c9b1f6d18baaa6c67b0c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc"}}
{"id": "sha256:a7e7b6547860419bcca856be9a551d71862482323e1d2f4d42512f43575d8699", "content": "It may be preferable to bootstrap the Spring container from XML and include\n`@Configuration` classes in an ad-hoc fashion. For example, in a large existing codebase\nthat uses Spring XML, it is easier to create `@Configuration` classes on an\nas-needed basis and include them from the existing XML files. Later in this section, we cover the\noptions for using `@Configuration` classes in this kind of \"`XML-centric`\" situation.\n\n[discrete]\n[[beans-java-combining-xml-centric-declare-as-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc", "title": "composing-configuration-classes", "heading": "XML-centric Use of `@Configuration` Classes", "heading_level": 3, "file_order": 47, "section_index": 8, "content_hash": "a7e7b6547860419bcca856be9a551d71862482323e1d2f4d42512f43575d8699", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc"}}
{"id": "sha256:385da3d284cae158ef0a5d870023e09d790866bdfd16c1e17a3b2da5cf185ba3", "content": "Remember that `@Configuration` classes are ultimately bean definitions in the container.\nIn this series of examples, we create a `@Configuration` class named `AppConfig` and\ninclude it within `system-test-config.xml` as a `<bean/>` definition. Because\n`<context:annotation-config/>` is switched on, the container recognizes the\n`@Configuration` annotation and processes the `@Bean` methods declared in `AppConfig`\nproperly.\n\nThe following example shows the `AppConfig` configuration class in Java and Kotlin:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Autowired\n private DataSource dataSource;\n\n @Bean\n public AccountRepository accountRepository() {\n return new JdbcAccountRepository(dataSource);\n }\n\n @Bean\n public TransferService transferService() {\n return new TransferServiceImpl(accountRepository());\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Autowired\n private lateinit var dataSource: DataSource\n\n @Bean\n fun accountRepository(): AccountRepository {\n return JdbcAccountRepository(dataSource)\n }\n\n @Bean\n fun transferService() = TransferService(accountRepository())\n\t}\n----\n======\n\nThe following example shows part of a sample `system-test-config.xml` file:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <!-- enable processing of annotations such as @Autowired and @Configuration -->\n <context:annotation-config/>\n\n <context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/>\n\n <bean class=\"com.acme.AppConfig\"/>\n\n <bean class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n <property name=\"url\" value=\"${jdbc.url}\"/>\n <property name=\"username\" value=\"${jdbc.username}\"/>\n <property name=\"password\" value=\"${jdbc.password}\"/>\n </bean>\n\t</beans>\n----\n\nThe following example shows a possible `jdbc.properties` file:\n\n[literal,subs=\"verbatim,quotes\"]\n----\njdbc.url=jdbc:hsqldb:hsql://localhost/xdb\njdbc.username=sa\njdbc.password=\n----\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic static void main(String[] args) {\n ApplicationContext ctx = new ClassPathXmlApplicationContext(\"classpath:/com/acme/system-test-config.xml\");\n TransferService transferService = ctx.getBean(TransferService.class);\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun main() {\n val ctx = ClassPathXmlApplicationContext(\"classpath:/com/acme/system-test-config.xml\")\n val transferService = ctx.getBean<TransferService>()\n // ...\n\t}\n----\n======\n\nNOTE: In the `system-test-config.xml` file, the `AppConfig` `<bean/>` does not declare an `id`\nattribute. While it would be acceptable to do so, it is unnecessary, given that no other bean\never refers to it, and it is unlikely to be explicitly fetched from the container by name.\nSimilarly, the `DataSource` bean is only ever autowired by type, so an explicit bean `id`\nis not strictly required.\n\n[discrete]\n[[beans-java-combining-xml-centric-component-scan]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc", "title": "composing-configuration-classes", "heading": "Declaring `@Configuration` classes as plain Spring `<bean/>` elements", "heading_level": 4, "file_order": 47, "section_index": 9, "content_hash": "385da3d284cae158ef0a5d870023e09d790866bdfd16c1e17a3b2da5cf185ba3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc"}}
{"id": "sha256:ab91da4065abde365afa2f3571eda5146c23ed0ab8b048f7d7213e8a0a1d37d2", "content": "Because `@Configuration` is meta-annotated with `@Component`, `@Configuration`-annotated\nclasses are automatically candidates for component scanning. Using the same scenario as\ndescribed in the previous example, we can redefine `system-test-config.xml` to take\nadvantage of component-scanning. Note that, in this case, we need not explicitly declare\n`<context:annotation-config/>`, because `<context:component-scan/>` enables the same\nfunctionality.\n\nThe following example shows the modified `system-test-config.xml` file:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <!-- picks up and registers AppConfig as a bean definition -->\n <context:component-scan base-package=\"com.acme\"/>\n\n <context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/>\n\n <bean class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n <property name=\"url\" value=\"${jdbc.url}\"/>\n <property name=\"username\" value=\"${jdbc.username}\"/>\n <property name=\"password\" value=\"${jdbc.password}\"/>\n </bean>\n\t</beans>\n----\n\n[[beans-java-combining-java-centric]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc", "title": "composing-configuration-classes", "heading": "Using <context:component-scan/> to pick up `@Configuration` classes", "heading_level": 4, "file_order": 47, "section_index": 10, "content_hash": "ab91da4065abde365afa2f3571eda5146c23ed0ab8b048f7d7213e8a0a1d37d2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc"}}
{"id": "sha256:60ed2755a4931a8602737e9168663f84073daa332d0261002abef217273a2d19", "content": "In applications where `@Configuration` classes are the primary mechanism for configuring\nthe container, it may still be necessary to use at least some XML. In such scenarios, you\ncan use `@ImportResource` and define only as much XML as you need. Doing so achieves a\n\"`Java-centric`\" approach to configuring the container and keeps XML to a bare minimum.\nThe following example (which includes a configuration class, an XML file that defines a\nbean, a properties file, and the `main()` method) shows how to use the `@ImportResource`\nannotation to achieve \"`Java-centric`\" configuration that uses XML as needed:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ImportResource(\"classpath:/com/acme/properties-config.xml\")\n\tpublic class AppConfig {\n\n @Value(\"${jdbc.url}\")\n private String url;\n\n @Value(\"${jdbc.username}\")\n private String username;\n\n @Value(\"${jdbc.password}\")\n private String password;\n\n @Bean\n public DataSource dataSource() {\n return new DriverManagerDataSource(url, username, password);\n }\n\n @Bean\n public AccountRepository accountRepository(DataSource dataSource) {\n return new JdbcAccountRepository(dataSource);\n }\n\n @Bean\n public TransferService transferService(AccountRepository accountRepository) {\n return new TransferServiceImpl(accountRepository);\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ImportResource(\"classpath:/com/acme/properties-config.xml\")\n\tclass AppConfig {\n\n @Value(\"\\${jdbc.url}\")\n private lateinit var url: String\n\n @Value(\"\\${jdbc.username}\")\n private lateinit var username: String\n\n @Value(\"\\${jdbc.password}\")\n private lateinit var password: String\n\n @Bean\n fun dataSource(): DataSource {\n return DriverManagerDataSource(url, username, password)\n }\n\n @Bean\n fun accountRepository(dataSource: DataSource): AccountRepository {\n return JdbcAccountRepository(dataSource)\n }\n\n @Bean\n fun transferService(accountRepository: AccountRepository): TransferService {\n return TransferServiceImpl(accountRepository)\n }\n\n\t}\n----\n======\n\n.properties-config.xml\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/>\n\t</beans>\n----\n\n.jdbc.properties\n[literal,subs=\"verbatim,quotes\"]\n----\njdbc.url=jdbc:hsqldb:hsql://localhost/xdb\njdbc.username=sa\njdbc.password=\n----\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic static void main(String[] args) {\n ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n TransferService transferService = ctx.getBean(TransferService.class);\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\tfun main() {\n val ctx = AnnotationConfigApplicationContext(AppConfig::class.java)\n val transferService = ctx.getBean<TransferService>()\n // ...\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc", "title": "composing-configuration-classes", "heading": "`@Configuration` Class-centric Use of XML with `@ImportResource`", "heading_level": 3, "file_order": 47, "section_index": 11, "content_hash": "60ed2755a4931a8602737e9168663f84073daa332d0261002abef217273a2d19", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/composing-configuration-classes.adoc"}}
{"id": "sha256:29c42051db386e622fc4f387f884197516f21c8b1ef06b004e03c584b458846a", "content": "[[beans-java-configuration-annotation]]\n\n`@Configuration` is a class-level annotation indicating that an object is a source of\nbean definitions. `@Configuration` classes declare beans through `@Bean`-annotated\nmethods. Calls to `@Bean` methods on `@Configuration` classes can also be used to define\ninter-bean dependencies. See\nxref:core/beans/java/basic-concepts.adoc[Basic Concepts: `@Bean` and `@Configuration`]\nfor a general introduction.\n\n[[beans-java-injecting-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/configuration-annotation.adoc", "title": "configuration-annotation", "heading": "configuration-annotation", "heading_level": 1, "file_order": 48, "section_index": 0, "content_hash": "29c42051db386e622fc4f387f884197516f21c8b1ef06b004e03c584b458846a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/configuration-annotation.adoc"}}
{"id": "sha256:c6a8f5b4bd2fcf3e1122ad41badef2d13c2ab9911a2b3b4d5efcb61e19d8bf96", "content": "When beans have dependencies on one another, expressing that dependency is as simple\nas having one bean method call another, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean\n public BeanOne beanOne() {\n return new BeanOne(beanTwo());\n }\n\n @Bean\n public BeanTwo beanTwo() {\n return new BeanTwo();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean\n fun beanOne() = BeanOne(beanTwo())\n\n @Bean\n fun beanTwo() = BeanTwo()\n\t}\n----\n======\n\nIn the preceding example, `beanOne` receives a reference to `beanTwo` through constructor\ninjection.\n\nNOTE: This method of declaring inter-bean dependencies works only when the `@Bean` method\nis declared within a `@Configuration` class. You cannot declare inter-bean dependencies\nby using plain `@Component` classes.\n\n[[beans-java-method-injection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/configuration-annotation.adoc", "title": "configuration-annotation", "heading": "Injecting Inter-bean Dependencies", "heading_level": 2, "file_order": 48, "section_index": 1, "content_hash": "c6a8f5b4bd2fcf3e1122ad41badef2d13c2ab9911a2b3b4d5efcb61e19d8bf96", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/configuration-annotation.adoc"}}
{"id": "sha256:7e9934e5348c8c58ccb7cd19cba1353dab86171437c8d8c132238891c03d7487", "content": "As noted earlier, xref:core/beans/dependencies/factory-method-injection.adoc[lookup method injection] is an\nadvanced feature that you should use rarely. It is useful in cases where a\nsingleton-scoped bean has a dependency on a prototype-scoped bean. Using Java for this\ntype of configuration provides a natural means for implementing this pattern. The\nfollowing example shows how to use lookup method injection:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic abstract class CommandManager {\n public Object process(Object commandState) {\n // grab a new instance of the appropriate Command interface\n Command command = createCommand();\n // set the state on the (hopefully brand new) Command instance\n command.setState(commandState);\n return command.execute();\n }\n\n // okay... but where is the implementation of this method?\n protected abstract Command createCommand();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tabstract class CommandManager {\n fun process(commandState: Any): Any {\n // grab a new instance of the appropriate Command interface\n val command = createCommand()\n // set the state on the (hopefully brand new) Command instance\n command.setState(commandState)\n return command.execute()\n }\n\n // okay... but where is the implementation of this method?\n protected abstract fun createCommand(): Command\n\t}\n----\n======\n\nBy using Java configuration, you can create a subclass of `CommandManager` where\nthe abstract `createCommand()` method is overridden in such a way that it looks up a new\n(prototype) command object. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\t@Scope(\"prototype\")\n\tpublic AsyncCommand asyncCommand() {\n AsyncCommand command = new AsyncCommand();\n // inject dependencies here as required\n return command;\n\t}\n\n\t@Bean\n\tpublic CommandManager commandManager() {\n // return new anonymous implementation of CommandManager with createCommand()\n // overridden to return a new prototype Command object\n return new CommandManager() {\n protected Command createCommand() {\n return asyncCommand();\n }\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\t@Scope(\"prototype\")\n\tfun asyncCommand(): AsyncCommand {\n val command = AsyncCommand()\n // inject dependencies here as required\n return command\n\t}\n\n\t@Bean\n\tfun commandManager(): CommandManager {\n // return new anonymous implementation of CommandManager with createCommand()\n // overridden to return a new prototype Command object\n return object : CommandManager() {\n override fun createCommand(): Command {\n return asyncCommand()\n }\n }\n\t}\n----\n======\n\n[[beans-java-further-information-java-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/configuration-annotation.adoc", "title": "configuration-annotation", "heading": "Lookup Method Injection", "heading_level": 2, "file_order": 48, "section_index": 2, "content_hash": "7e9934e5348c8c58ccb7cd19cba1353dab86171437c8d8c132238891c03d7487", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/configuration-annotation.adoc"}}
{"id": "sha256:fcc0875d7dd8197d7d264261fb2957a6151aee5f669af723a920dea7b3fd8dd9", "content": "Consider the following example, which shows a `@Bean` annotated method being called twice:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean\n public ClientService clientService1() {\n ClientServiceImpl clientService = new ClientServiceImpl();\n clientService.setClientDao(clientDao());\n return clientService;\n }\n\n @Bean\n public ClientService clientService2() {\n ClientServiceImpl clientService = new ClientServiceImpl();\n clientService.setClientDao(clientDao());\n return clientService;\n }\n\n @Bean\n public ClientDao clientDao() {\n return new ClientDaoImpl();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean\n fun clientService1(): ClientService {\n return ClientServiceImpl().apply {\n clientDao = clientDao()\n }\n }\n\n @Bean\n fun clientService2(): ClientService {\n return ClientServiceImpl().apply {\n clientDao = clientDao()\n }\n }\n\n @Bean\n fun clientDao(): ClientDao {\n return ClientDaoImpl()\n }\n\t}\n----\n======\n\n`clientDao()` has been called once in `clientService1()` and once in `clientService2()`.\nSince this method creates a new instance of `ClientDaoImpl` and returns it, you would\nnormally expect to have two instances (one for each service). That definitely would be\nproblematic: In Spring, instantiated beans have a `singleton` scope by default. This is\nwhere the magic comes in: All `@Configuration` classes are subclassed at startup-time\nwith `CGLIB`. In the subclass, the child method checks the container first for any\ncached (scoped) beans before it calls the parent method and creates a new instance.\n\nNOTE: The behavior could be different according to the scope of your bean. We are talking\nabout singletons here.\n\n[NOTE]\n====\nIt is not necessary to add CGLIB to your classpath because CGLIB classes are repackaged\nunder the `org.springframework.cglib` package and included directly within the\n`spring-core` JAR.\n====\n\n[TIP]\n====\nThere are a few restrictions due to the fact that CGLIB dynamically adds features at\nstartup-time. In particular, configuration classes must not be final. However, any\nconstructors are allowed on configuration classes, including the use of `@Autowired` or a\nsingle non-default constructor declaration for default injection.\n\nIf you prefer to avoid any CGLIB-imposed limitations, consider declaring your `@Bean`\nmethods on non-`@Configuration` classes (for example, on plain `@Component` classes\ninstead) or by annotating your configuration class with\n`@Configuration(proxyBeanMethods = false)`. Cross-method calls between `@Bean` methods\nare then not intercepted, so you have to exclusively rely on dependency injection at the\nconstructor or method level there.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/configuration-annotation.adoc", "title": "configuration-annotation", "heading": "Further Information About How Java-based Configuration Works Internally", "heading_level": 2, "file_order": 48, "section_index": 3, "content_hash": "fcc0875d7dd8197d7d264261fb2957a6151aee5f669af723a920dea7b3fd8dd9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/configuration-annotation.adoc"}}
{"id": "sha256:8986ddd7ac0b917e48e314d96c163f2f3bd06a88f2fb5daed900c5992217d36f", "content": "[[beans-java-instantiating-container]]\n\nThe following sections document Spring's `AnnotationConfigApplicationContext`, introduced in Spring\n3.0. This versatile `ApplicationContext` implementation is capable of accepting not only\n`@Configuration` classes as input but also plain `@Component` classes and classes\nannotated with JSR-330 metadata.\n\nWhen `@Configuration` classes are provided as input, the `@Configuration` class itself\nis registered as a bean definition and all declared `@Bean` methods within the class\nare also registered as bean definitions.\n\nWhen `@Component` and JSR-330 classes are provided, they are registered as bean\ndefinitions, and it is assumed that DI metadata such as `@Autowired` or `@Inject` are\nused within those classes where necessary.\n\n[[beans-java-instantiating-container-constructor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/instantiating-container.adoc", "title": "instantiating-container", "heading": "instantiating-container", "heading_level": 1, "file_order": 49, "section_index": 0, "content_hash": "8986ddd7ac0b917e48e314d96c163f2f3bd06a88f2fb5daed900c5992217d36f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/instantiating-container.adoc"}}
{"id": "sha256:d87722f40917bdf72ae965f3bdbc5e5396a27440f6572784d468704f7a644ac5", "content": "In much the same way that Spring XML files are used as input when instantiating a\n`ClassPathXmlApplicationContext`, you can use `@Configuration` classes as input when\ninstantiating an `AnnotationConfigApplicationContext`. This allows for completely\nXML-free usage of the Spring container, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic static void main(String[] args) {\n ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n MyService myService = ctx.getBean(MyService.class);\n myService.doStuff();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\tfun main() {\n val ctx = AnnotationConfigApplicationContext(AppConfig::class.java)\n val myService = ctx.getBean<MyService>()\n myService.doStuff()\n\t}\n----\n======\n\nAs mentioned earlier, `AnnotationConfigApplicationContext` is not limited to working only\nwith `@Configuration` classes. Any `@Component` or JSR-330 annotated class may be supplied\nas input to the constructor, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic static void main(String[] args) {\n ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);\n MyService myService = ctx.getBean(MyService.class);\n myService.doStuff();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\tfun main() {\n val ctx = AnnotationConfigApplicationContext(MyServiceImpl::class.java, Dependency1::class.java, Dependency2::class.java)\n val myService = ctx.getBean<MyService>()\n myService.doStuff()\n\t}\n----\n======\n\nThe preceding example assumes that `MyServiceImpl`, `Dependency1`, and `Dependency2` use Spring\ndependency injection annotations such as `@Autowired`.\n\n[[beans-java-instantiating-container-register]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/instantiating-container.adoc", "title": "instantiating-container", "heading": "Simple Construction", "heading_level": 2, "file_order": 49, "section_index": 1, "content_hash": "d87722f40917bdf72ae965f3bdbc5e5396a27440f6572784d468704f7a644ac5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/instantiating-container.adoc"}}
{"id": "sha256:5075a2841a98bbe308865c1734bdc6ff34b027dfe4837f47ac0de06040a48f8c", "content": "You can instantiate an `AnnotationConfigApplicationContext` by using a no-arg constructor\nand then configure it by using the `register()` method. This approach is particularly useful\nwhen programmatically building an `AnnotationConfigApplicationContext`. The following\nexample shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic static void main(String[] args) {\n AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n ctx.register(AppConfig.class, OtherConfig.class);\n ctx.register(AdditionalConfig.class);\n ctx.refresh();\n MyService myService = ctx.getBean(MyService.class);\n myService.doStuff();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\tfun main() {\n val ctx = AnnotationConfigApplicationContext()\n ctx.register(AppConfig::class.java, OtherConfig::class.java)\n ctx.register(AdditionalConfig::class.java)\n ctx.refresh()\n val myService = ctx.getBean<MyService>()\n myService.doStuff()\n\t}\n----\n======\n\n[[beans-java-instantiating-container-scan]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/instantiating-container.adoc", "title": "instantiating-container", "heading": "Building the Container Programmatically by Using `register(Class<?>...)`", "heading_level": 2, "file_order": 49, "section_index": 2, "content_hash": "5075a2841a98bbe308865c1734bdc6ff34b027dfe4837f47ac0de06040a48f8c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/instantiating-container.adoc"}}
{"id": "sha256:d5fabc9d8bbac7b6dfa2623609fa845f1f59df5ecf573bb952c50bcc0a4edebf", "content": "To enable component scanning, you can annotate your `@Configuration` class as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = \"com.acme\") // <1>\n\tpublic class AppConfig {\n // ...\n\t}\n----\n<1> This annotation enables component scanning.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = [\"com.acme\"]) // <1>\n\tclass AppConfig {\n // ...\n\t}\n----\n<1> This annotation enables component scanning.\n======\n\n[TIP]\n=====\nExperienced Spring users may be familiar with the XML declaration equivalent from\nSpring's `context:` namespace, shown in the following example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <context:component-scan base-package=\"com.acme\"/>\n\t</beans>\n----\n=====\n\nIn the preceding example, the `com.acme` package is scanned to look for any\n`@Component`-annotated classes, and those classes are registered as Spring bean\ndefinitions within the container. `AnnotationConfigApplicationContext` exposes the\n`scan(String...)` method to allow for the same component-scanning functionality, as the\nfollowing example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic static void main(String[] args) {\n AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n ctx.scan(\"com.acme\");\n ctx.refresh();\n MyService myService = ctx.getBean(MyService.class);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun main() {\n val ctx = AnnotationConfigApplicationContext()\n ctx.scan(\"com.acme\")\n ctx.refresh()\n val myService = ctx.getBean<MyService>()\n\t}\n----\n======\n\nNOTE: Remember that `@Configuration` classes are\nxref:core/beans/classpath-scanning.adoc#beans-meta-annotations[meta-annotated]\nwith `@Component`, so they are candidates for component-scanning. In the preceding example,\nassuming that `AppConfig` is declared within the `com.acme` package (or any package\nunderneath), it is picked up during the call to `scan()`. Upon `refresh()`, all its `@Bean`\nmethods are processed and registered as bean definitions within the container.\n\n[[beans-java-instantiating-container-web]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/instantiating-container.adoc", "title": "instantiating-container", "heading": "Enabling Component Scanning with `scan(String...)`", "heading_level": 2, "file_order": 49, "section_index": 3, "content_hash": "d5fabc9d8bbac7b6dfa2623609fa845f1f59df5ecf573bb952c50bcc0a4edebf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/instantiating-container.adoc"}}
{"id": "sha256:257f984bf933eecb4266d1356c683805b5fd42e2811ea8b4de0435d9a6c23970", "content": "A `WebApplicationContext` variant of `AnnotationConfigApplicationContext` is available\nwith `AnnotationConfigWebApplicationContext`. You can use this implementation when\nconfiguring the Spring `ContextLoaderListener` servlet listener, Spring MVC\n`DispatcherServlet`, and so forth. The following `web.xml` snippet configures a typical\nSpring MVC web application (note the use of the `contextClass` context-param and\ninit-param):\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<web-app>\n <!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext\n instead of the default XmlWebApplicationContext -->\n <context-param>\n <param-name>contextClass</param-name>\n <param-value>\n org.springframework.web.context.support.AnnotationConfigWebApplicationContext\n </param-value>\n </context-param>\n\n <!-- Configuration locations must consist of one or more comma- or space-delimited\n fully-qualified @Configuration classes. Fully-qualified packages may also be\n specified for component-scanning -->\n <context-param>\n <param-name>contextConfigLocation</param-name>\n <param-value>com.acme.AppConfig</param-value>\n </context-param>\n\n <!-- Bootstrap the root application context as usual using ContextLoaderListener -->\n <listener>\n <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n </listener>\n\n <!-- Declare a Spring MVC DispatcherServlet as usual -->\n <servlet>\n <servlet-name>dispatcher</servlet-name>\n <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n <!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext\n instead of the default XmlWebApplicationContext -->\n <init-param>\n <param-name>contextClass</param-name>\n <param-value>\n org.springframework.web.context.support.AnnotationConfigWebApplicationContext\n </param-value>\n </init-param>\n <!-- Again, config locations must consist of one or more comma- or space-delimited\n and fully-qualified @Configuration classes -->\n <init-param>\n <param-name>contextConfigLocation</param-name>\n <param-value>com.acme.web.MvcConfig</param-value>\n </init-param>\n </servlet>\n\n <!-- map all requests for /app/* to the dispatcher servlet -->\n <servlet-mapping>\n <servlet-name>dispatcher</servlet-name>\n <url-pattern>/app/*</url-pattern>\n </servlet-mapping>\n\t</web-app>\n----\n\nNOTE: For programmatic use cases, a `GenericWebApplicationContext` can be used as an\nalternative to `AnnotationConfigWebApplicationContext`. See the\n{spring-framework-api}/web/context/support/GenericWebApplicationContext.html[`GenericWebApplicationContext`]\njavadoc for details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/instantiating-container.adoc", "title": "instantiating-container", "heading": "Support for Web Applications with `AnnotationConfigWebApplicationContext`", "heading_level": 2, "file_order": 49, "section_index": 4, "content_hash": "257f984bf933eecb4266d1356c683805b5fd42e2811ea8b4de0435d9a6c23970", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/instantiating-container.adoc"}}
{"id": "sha256:81beecf63a1d8078c18d43dff40601db31dddfff720ac476d2580a177f52a019", "content": "[[beans-java-programmatic-registration]]\n\nAs of Spring Framework 7, a first-class support for programmatic bean registration is\nprovided via the {spring-framework-api}/beans/factory/BeanRegistrar.html[`BeanRegistrar`]\ninterface that can be implemented to register beans programmatically in a flexible and\nefficient way.\n\nThose bean registrar implementations are typically imported with an `@Import` annotation\non `@Configuration` classes.\n\ninclude-code::./MyConfiguration[tag=snippet,indent=0]\n\nNOTE: You can leverage type-level conditional annotations ({spring-framework-api}/context/annotation/Conditional.html[`@Conditional`],\nbut also other variants) to conditionally import the related bean registrars.\n\nThe bean registrar implementation uses {spring-framework-api}/beans/factory/BeanRegistry.html[`BeanRegistry`] and\n{spring-framework-api}/core/env/Environment.html[`Environment`] APIs to register beans programmatically in a concise\nand flexible way. For example, it allows custom registration through an `if` expression, a\n`for` loop, etc.\n\ninclude-code::./MyBeanRegistrar[tag=snippet,indent=0]\n\nNOTE: Bean registrars are supported with xref:core/aot.adoc[Ahead of Time Optimizations],\neither on the JVM or with GraalVM native images, including when instance suppliers are used.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java/programmatic-bean-registration.adoc", "title": "programmatic-bean-registration", "heading": "programmatic-bean-registration", "heading_level": 1, "file_order": 50, "section_index": 0, "content_hash": "81beecf63a1d8078c18d43dff40601db31dddfff720ac476d2580a177f52a019", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java/programmatic-bean-registration.adoc"}}
{"id": "sha256:ea665e12e530f4f558b5b03ea591c3ec1765bf48f0df45f7d1d422a9179ef864", "content": "[[beans-annotation-config]]\n\nSpring provides comprehensive support for annotation-based configuration, operating on\nmetadata in the component class itself by using annotations on the relevant class,\nmethod, or field declaration. As mentioned in\nxref:core/beans/factory-extension.adoc#beans-factory-extension-bpp-examples-aabpp[Example: The `AutowiredAnnotationBeanPostProcessor`],\nSpring uses `BeanPostProcessors` in conjunction with annotations to make the core IOC\ncontainer aware of specific annotations.\n\nFor example, the xref:core/beans/annotation-config/autowired.adoc[`@Autowired`]\nannotation provides the same capabilities as described in\nxref:core/beans/dependencies/factory-autowire.adoc[Autowiring Collaborators] but\nwith more fine-grained control and wider applicability. In addition, Spring provides\nsupport for JSR-250 annotations, such as `@PostConstruct` and `@PreDestroy`, as well as\nsupport for JSR-330 (Dependency Injection for Java) annotations contained in the\n`jakarta.inject` package such as `@Inject` and `@Named`. Details about those annotations\ncan be found in the xref:core/beans/standard-annotations.adoc[relevant section].\n\n[NOTE]\n====\nAnnotation injection is performed before external property injection. Thus, external\nconfiguration (for example, XML-specified bean properties) effectively overrides the annotations\nfor properties when wired through mixed approaches.\n====\n\nTechnically, you can register the post-processors as individual bean definitions, but they\nare implicitly registered in an `AnnotationConfigApplicationContext` already.\n\nIn an XML-based Spring setup, you may include the following configuration tag to enable\nmixing and matching with annotation-based configuration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:context=\"http://www.springframework.org/schema/context\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/context\n https://www.springframework.org/schema/context/spring-context.xsd\">\n\n <context:annotation-config/>\n\n\t</beans>\n----\n\nThe `<context:annotation-config/>` element implicitly registers the following post-processors:\n\n* {spring-framework-api}/context/annotation/ConfigurationClassPostProcessor.html[`ConfigurationClassPostProcessor`]\n* {spring-framework-api}/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html[`AutowiredAnnotationBeanPostProcessor`]\n* {spring-framework-api}/context/annotation/CommonAnnotationBeanPostProcessor.html[`CommonAnnotationBeanPostProcessor`]\n* {spring-framework-api}/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html[`PersistenceAnnotationBeanPostProcessor`]\n* {spring-framework-api}/context/event/EventListenerMethodProcessor.html[`EventListenerMethodProcessor`]\n\n[NOTE]\n====\n`<context:annotation-config/>` only looks for annotations on beans in the same\napplication context in which it is defined. This means that, if you put\n`<context:annotation-config/>` in a `WebApplicationContext` for a `DispatcherServlet`,\nit only checks for `@Autowired` beans in your controllers, and not your services. See\nxref:web/webmvc/mvc-servlet.adoc[The DispatcherServlet] for more information.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/annotation-config.adoc", "title": "annotation-config", "heading": "annotation-config", "heading_level": 1, "file_order": 51, "section_index": 0, "content_hash": "ea665e12e530f4f558b5b03ea591c3ec1765bf48f0df45f7d1d422a9179ef864", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/annotation-config.adoc"}}
{"id": "sha256:242853de6bcec4764bf8b453aaf07c8f32e360306aa2d2e6398ab5f8d216c602", "content": "[[beans-basics]]\n\nThe `org.springframework.context.ApplicationContext` interface represents the Spring IoC\ncontainer and is responsible for instantiating, configuring, and assembling the beans.\nThe container gets its instructions on the components to instantiate, configure, and\nassemble by reading configuration metadata. The configuration metadata can be represented\nas annotated component classes, configuration classes with factory methods, or external\nXML files or Groovy scripts. With either format, you may compose your application and the\nrich interdependencies between those components.\n\nSeveral implementations of the `ApplicationContext` interface are part of core Spring.\nIn stand-alone applications, it is common to create an instance of\n{spring-framework-api}/context/annotation/AnnotationConfigApplicationContext.html[`AnnotationConfigApplicationContext`]\nor {spring-framework-api}/context/support/ClassPathXmlApplicationContext.html[`ClassPathXmlApplicationContext`].\n\nIn most application scenarios, explicit user code is not required to instantiate one or\nmore instances of a Spring IoC container. For example, in a plain web application scenario,\na simple boilerplate web descriptor XML in the `web.xml` file of the application suffices (see\nxref:core/beans/context-introduction.adoc#context-create[Convenient ApplicationContext Instantiation for Web Applications]).\nIn a Spring Boot scenario, the application context is implicitly bootstrapped for you\nbased on common setup conventions.\n\nThe following diagram shows a high-level view of how Spring works. Your application classes\nare combined with configuration metadata so that, after the `ApplicationContext` is\ncreated and initialized, you have a fully configured and executable system or application.\n\n.The Spring IoC container\nimage::container-magic.png[]\n\n[[beans-factory-metadata]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/basics.adoc", "title": "basics", "heading": "basics", "heading_level": 1, "file_order": 52, "section_index": 0, "content_hash": "242853de6bcec4764bf8b453aaf07c8f32e360306aa2d2e6398ab5f8d216c602", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/basics.adoc"}}
{"id": "sha256:f13ae3f161ab875b0914c1e4c51ff00b91b1f7b1e137c89c0bafc5540e0c5b9c", "content": "As the preceding diagram shows, the Spring IoC container consumes a form of\nconfiguration metadata. This configuration metadata represents how you, as an\napplication developer, tell the Spring container to instantiate, configure,\nand assemble the components in your application.\n\nThe Spring IoC container itself is totally decoupled from the format in which this\nconfiguration metadata is actually written. These days, many developers choose\nxref:core/beans/java.adoc[Java-based configuration] for their Spring applications:\n\n* xref:core/beans/annotation-config.adoc[Annotation-based configuration]: define beans using\n annotation-based configuration metadata on your application's component classes.\n* xref:core/beans/java.adoc[Java-based configuration]: define beans external to your application\n classes by using Java-based configuration classes. To use these features, see the\n {spring-framework-api}/context/annotation/Configuration.html[`@Configuration`],\n {spring-framework-api}/context/annotation/Bean.html[`@Bean`],\n {spring-framework-api}/context/annotation/Import.html[`@Import`],\n and {spring-framework-api}/context/annotation/DependsOn.html[`@DependsOn`] annotations.\n\nSpring configuration consists of at least one and typically more than one bean definition\nthat the container must manage. Java configuration typically uses `@Bean`-annotated\nmethods within a `@Configuration` class, each corresponding to one bean definition.\n\nThese bean definitions correspond to the actual objects that make up your application.\nTypically, you define service layer objects, persistence layer objects such as\nrepositories or data access objects (DAOs), presentation objects such as Web controllers,\ninfrastructure objects such as a JPA `EntityManagerFactory`, JMS queues, and so forth.\nTypically, one does not configure fine-grained domain objects in the container, because\nit is usually the responsibility of repositories and business logic to create and load\ndomain objects.\n\n[[beans-factory-xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/basics.adoc", "title": "basics", "heading": "Configuration Metadata", "heading_level": 2, "file_order": 52, "section_index": 1, "content_hash": "f13ae3f161ab875b0914c1e4c51ff00b91b1f7b1e137c89c0bafc5540e0c5b9c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/basics.adoc"}}
{"id": "sha256:e52666055ee088bb891f920a0dbea53eb5cb69544c69ae0a1870d8cbe7bc0493", "content": "XML-based configuration metadata configures these beans as `<bean/>` elements inside\na top-level `<beans/>` element. The following example shows the basic structure of\nXML-based configuration metadata:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <bean id=\"...\" class=\"...\"> <1> <2>\n <!-- collaborators and configuration for this bean go here -->\n </bean>\n\n <bean id=\"...\" class=\"...\">\n <!-- collaborators and configuration for this bean go here -->\n </bean>\n\n <!-- more bean definitions go here -->\n\n\t</beans>\n----\n\n<1> The `id` attribute is a string that identifies the individual bean definition.\n<2> The `class` attribute defines the type of the bean and uses the fully qualified\nclass name.\n\nThe value of the `id` attribute can be used to refer to collaborating objects. The XML\nfor referring to collaborating objects is not shown in this example. See\nxref:core/beans/dependencies.adoc[Dependencies] for more information.\n\nFor instantiating a container, the location path or paths to the XML resource files\nneed to be supplied to a `ClassPathXmlApplicationContext` constructor that let the\ncontainer load configuration metadata from a variety of external resources, such\nas the local file system, the Java `CLASSPATH`, and so on.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval context = ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\")\n----\n======\n\n[NOTE]\n====\nAfter you learn about Spring's IoC container, you may want to know more about Spring's\n`Resource` abstraction (as described in\nxref:core/resources.adoc[Resources])\nwhich provides a convenient mechanism for reading an InputStream from locations defined\nin a URI syntax. In particular, `Resource` paths are used to construct applications contexts,\nas described in xref:core/resources.adoc#resources-app-ctx[Application Contexts and Resource Paths].\n====\n\nThe following example shows the service layer objects `(services.xml)` configuration file:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <!-- services -->\n\n <bean id=\"petStore\" class=\"org.springframework.samples.jpetstore.services.PetStoreServiceImpl\">\n <property name=\"accountDao\" ref=\"accountDao\"/>\n <property name=\"itemDao\" ref=\"itemDao\"/>\n <!-- additional collaborators and configuration for this bean go here -->\n </bean>\n\n <!-- more bean definitions for services go here -->\n\n\t</beans>\n----\n\nThe following example shows the data access objects `daos.xml` file:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <bean id=\"accountDao\"\n class=\"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao\">\n <!-- additional collaborators and configuration for this bean go here -->\n </bean>\n\n <bean id=\"itemDao\" class=\"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao\">\n <!-- additional collaborators and configuration for this bean go here -->\n </bean>\n\n <!-- more bean definitions for data access objects go here -->\n\n\t</beans>\n----\n\nIn the preceding example, the service layer consists of the `PetStoreServiceImpl` class\nand two data access objects of the types `JpaAccountDao` and `JpaItemDao` (based\non the JPA Object-Relational Mapping standard). The `property name` element refers to the\nname of the JavaBean property, and the `ref` element refers to the name of another bean\ndefinition. This linkage between `id` and `ref` elements expresses the dependency between\ncollaborating objects. For details of configuring an object's dependencies, see\nxref:core/beans/dependencies.adoc[Dependencies].\n\n[[beans-factory-xml-import]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/basics.adoc", "title": "basics", "heading": "XML as an External Configuration DSL", "heading_level": 3, "file_order": 52, "section_index": 2, "content_hash": "e52666055ee088bb891f920a0dbea53eb5cb69544c69ae0a1870d8cbe7bc0493", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/basics.adoc"}}
{"id": "sha256:89664b8e837795ff374a2306a13aae8a0d934637d8d81421ed66e7721efea424", "content": "It can be useful to have bean definitions span multiple XML files. Often, each individual\nXML configuration file represents a logical layer or module in your architecture.\n\nYou can use the `ClassPathXmlApplicationContext` constructor to load bean definitions from\nXML fragments. This constructor takes multiple `Resource` locations, as was shown in the\nxref:core/beans/basics.adoc#beans-factory-xml[previous section]. Alternatively,\nuse one or more occurrences of the `<import/>` element to load bean definitions from\nanother file or files. The following example shows how to do so:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <import resource=\"services.xml\"/>\n <import resource=\"resources/messageSource.xml\"/>\n\n <bean id=\"bean1\" class=\"...\"/>\n <bean id=\"bean2\" class=\"...\"/>\n\t</beans>\n----\n\nIn the preceding example, external bean definitions are loaded from the files\n`services.xml` and `messageSource.xml`. All location paths are\nrelative to the definition file doing the importing, so `services.xml` must be in the\nsame directory or classpath location as the file doing the importing, while\n`messageSource.xml` must be in a `resources` location below the\nlocation of the importing file. As you can see, a leading slash is ignored. However, given\nthat these paths are relative, it is better form not to use the slash at all. The\ncontents of the files being imported, including the top level `<beans/>` element, must\nbe valid XML bean definitions, according to the Spring Schema.\n\n[NOTE]\n====\nIt is possible, but not recommended, to reference files in parent directories using a\nrelative \"../\" path. Doing so creates a dependency on a file that is outside the current\napplication. In particular, this reference is not recommended for `classpath:` URLs (for\nexample, `classpath:../services.xml`), where the runtime resolution process chooses the\n\"`nearest`\" classpath root and then looks into its parent directory. Classpath\nconfiguration changes may lead to the choice of a different, incorrect directory.\n\nYou can always use fully qualified resource locations instead of relative paths: for\nexample, `file:C:/config/services.xml` or `classpath:/config/services.xml`. However, be\naware that you are coupling your application's configuration to specific absolute\nlocations. It is generally preferable to keep an indirection for such absolute\nlocations -- for example, through \"${...}\" placeholders that are resolved against JVM\nsystem properties at runtime.\n====\n\nThe namespace itself provides the import directive feature. Further\nconfiguration features beyond plain bean definitions are available in a selection\nof XML namespaces provided by Spring -- for example, the `context` and `util` namespaces.\n\n[[beans-factory-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/basics.adoc", "title": "basics", "heading": "Composing XML-based Configuration Metadata", "heading_level": 3, "file_order": 52, "section_index": 3, "content_hash": "89664b8e837795ff374a2306a13aae8a0d934637d8d81421ed66e7721efea424", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/basics.adoc"}}
{"id": "sha256:d360db75db5df3a725cf28f5ee8ba1e942e9f2d8f331bac775f8f133295a9c49", "content": "The `ApplicationContext` is the interface for an advanced factory capable of maintaining\na registry of different beans and their dependencies. By using the method\n`T getBean(String name, Class<T> requiredType)`, you can retrieve instances of your beans.\n\nThe `ApplicationContext` lets you read bean definitions and access them, as the following\nexample shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// create and configure beans\n\tApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\");\n\n\t// retrieve configured instance\n\tPetStoreService service = context.getBean(\"petStore\", PetStoreService.class);\n\n\t// use configured instance\n\tList<String> userList = service.getUsernameList();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\t// create and configure beans\n\tval context = ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\")\n\n\t// retrieve configured instance\n\tval service = context.getBean<PetStoreService>(\"petStore\")\n\n\t// use configured instance\n\tvar userList = service.getUsernameList()\n----\n======\n\nWith Groovy configuration, bootstrapping looks very similar. It has a different context\nimplementation class which is Groovy-aware (but also understands XML bean definitions).\nThe following example shows Groovy configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext context = new GenericGroovyApplicationContext(\"services.groovy\", \"daos.groovy\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nval context = GenericGroovyApplicationContext(\"services.groovy\", \"daos.groovy\")\n----\n======\n\nThe most flexible variant is `GenericApplicationContext` in combination with reader\ndelegates -- for example, with `XmlBeanDefinitionReader` for XML files, as the following\nexample shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tGenericApplicationContext context = new GenericApplicationContext();\n\tnew XmlBeanDefinitionReader(context).loadBeanDefinitions(\"services.xml\", \"daos.xml\");\n\tcontext.refresh();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval context = GenericApplicationContext()\n\tXmlBeanDefinitionReader(context).loadBeanDefinitions(\"services.xml\", \"daos.xml\")\n\tcontext.refresh()\n----\n======\n\nYou can also use the `GroovyBeanDefinitionReader` for Groovy files, as the following\nexample shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tGenericApplicationContext context = new GenericApplicationContext();\n\tnew GroovyBeanDefinitionReader(context).loadBeanDefinitions(\"services.groovy\", \"daos.groovy\");\n\tcontext.refresh();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval context = GenericApplicationContext()\n\tGroovyBeanDefinitionReader(context).loadBeanDefinitions(\"services.groovy\", \"daos.groovy\")\n\tcontext.refresh()\n----\n======\n\nYou can mix and match such reader delegates on the same `ApplicationContext`,\nreading bean definitions from diverse configuration sources.\n\nYou can then use `getBean` to retrieve instances of your beans. The `ApplicationContext`\ninterface has a few other methods for retrieving beans, but, ideally, your application\ncode should never use them. Indeed, your application code should have no calls to the\n`getBean()` method at all and thus have no dependency on Spring APIs at all. For example,\nSpring's integration with web frameworks provides dependency injection for various web\nframework components such as controllers and JSF-managed beans, letting you declare\na dependency on a specific bean through metadata (such as an autowiring annotation).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/basics.adoc", "title": "basics", "heading": "Using the Container", "heading_level": 2, "file_order": 52, "section_index": 4, "content_hash": "d360db75db5df3a725cf28f5ee8ba1e942e9f2d8f331bac775f8f133295a9c49", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/basics.adoc"}}
{"id": "sha256:48ef40143ef900a31fd24aeda1c74c5b6e7f0d5c6d6ab2b06fa0e23f87cdab98", "content": "[[beans-beanfactory]]\n\nThe `BeanFactory` API provides the underlying basis for Spring's IoC functionality.\nIts specific contracts are mostly used in integration with other parts of Spring and\nrelated third-party frameworks, and its `DefaultListableBeanFactory` implementation\nis a key delegate within the higher-level `GenericApplicationContext` container.\n\n`BeanFactory` and related interfaces (such as `BeanFactoryAware`, `InitializingBean`,\n`DisposableBean`) are important integration points for other framework components.\nBy not requiring any annotations or even reflection, they allow for very efficient\ninteraction between the container and its components. Application-level beans may\nuse the same callback interfaces but typically prefer declarative dependency\ninjection instead, either through annotations or through programmatic configuration.\n\nNote that the core `BeanFactory` API level and its `DefaultListableBeanFactory`\nimplementation do not make assumptions about the configuration format or any\ncomponent annotations to be used. All of these flavors come in through extensions\n(such as `XmlBeanDefinitionReader` and `AutowiredAnnotationBeanPostProcessor`) and\noperate on shared `BeanDefinition` objects as a core metadata representation.\nThis is the essence of what makes Spring's container so flexible and extensible.\n\n[[context-introduction-ctx-vs-beanfactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/beanfactory.adoc", "title": "beanfactory", "heading": "beanfactory", "heading_level": 1, "file_order": 53, "section_index": 0, "content_hash": "48ef40143ef900a31fd24aeda1c74c5b6e7f0d5c6d6ab2b06fa0e23f87cdab98", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/beanfactory.adoc"}}
{"id": "sha256:7f04e4a8941ea48a4c6b2f402c95ddb5ae6eb2211c1abf0f345bb26a7cb4486c", "content": "This section explains the differences between the `BeanFactory` and\n`ApplicationContext` container levels and the implications on bootstrapping.\n\nYou should use an `ApplicationContext` unless you have a good reason for not doing so, with\n`GenericApplicationContext` and its subclass `AnnotationConfigApplicationContext`\nas the common implementations for custom bootstrapping. These are the primary entry\npoints to Spring's core container for all common purposes: loading of configuration\nfiles, triggering a classpath scan, programmatically registering bean definitions\nand annotated classes, and (as of 5.0) registering functional bean definitions.\n\nBecause an `ApplicationContext` includes all the functionality of a `BeanFactory`, it is\ngenerally recommended over a plain `BeanFactory`, except for scenarios where full\ncontrol over bean processing is needed. Within an `ApplicationContext` (such as the\n`GenericApplicationContext` implementation), several kinds of beans are detected\nby convention (that is, by bean name or by bean type -- in particular, post-processors),\nwhile a plain `DefaultListableBeanFactory` is agnostic about any special beans.\n\nFor many extended container features, such as annotation processing and AOP proxying,\nthe xref:core/beans/factory-extension.adoc#beans-factory-extension-bpp[`BeanPostProcessor` extension point] is essential.\nIf you use only a plain `DefaultListableBeanFactory`, such post-processors do not\nget detected and activated by default. This situation could be confusing, because\nnothing is actually wrong with your bean configuration. Rather, in such a scenario,\nthe container needs to be fully bootstrapped through additional setup.\n\nThe following table lists features provided by the `BeanFactory` and\n`ApplicationContext` interfaces and implementations.\n\n[[context-introduction-ctx-vs-beanfactory-feature-matrix]]\n.Feature Matrix\n[cols=\"50%,25%,25%\"]\n|===\n| Feature | `BeanFactory` | `ApplicationContext`\n\n| Bean instantiation/wiring\n| Yes\n| Yes\n\n| Integrated lifecycle management\n| No\n| Yes\n\n| Automatic `BeanPostProcessor` registration\n| No\n| Yes\n\n| Automatic `BeanFactoryPostProcessor` registration\n| No\n| Yes\n\n| Convenient `MessageSource` access (for internationalization)\n| No\n| Yes\n\n| Built-in `ApplicationEvent` publication mechanism\n| No\n| Yes\n|===\n\nTo explicitly register a bean post-processor with a `DefaultListableBeanFactory`,\nyou need to programmatically call `addBeanPostProcessor`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\n\t// populate the factory with bean definitions\n\n\t// now register any needed BeanPostProcessor instances\n\tfactory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());\n\tfactory.addBeanPostProcessor(new MyBeanPostProcessor());\n\n\t// now start using the factory\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval factory = DefaultListableBeanFactory()\n\t// populate the factory with bean definitions\n\n\t// now register any needed BeanPostProcessor instances\n\tfactory.addBeanPostProcessor(AutowiredAnnotationBeanPostProcessor())\n\tfactory.addBeanPostProcessor(MyBeanPostProcessor())\n\n\t// now start using the factory\n----\n======\n\nTo apply a `BeanFactoryPostProcessor` to a plain `DefaultListableBeanFactory`,\nyou need to call its `postProcessBeanFactory` method, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tDefaultListableBeanFactory factory = new DefaultListableBeanFactory();\n\tXmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\n\treader.loadBeanDefinitions(new FileSystemResource(\"beans.xml\"));\n\n\t// bring in some property values from a Properties file\n\tPropertySourcesPlaceholderConfigurer cfg = new PropertySourcesPlaceholderConfigurer();\n\tcfg.setLocation(new FileSystemResource(\"jdbc.properties\"));\n\n\t// now actually do the replacement\n\tcfg.postProcessBeanFactory(factory);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval factory = DefaultListableBeanFactory()\n\tval reader = XmlBeanDefinitionReader(factory)\n\treader.loadBeanDefinitions(FileSystemResource(\"beans.xml\"))\n\n\t// bring in some property values from a Properties file\n\tval cfg = PropertySourcesPlaceholderConfigurer()\n\tcfg.setLocation(FileSystemResource(\"jdbc.properties\"))\n\n\t// now actually do the replacement\n\tcfg.postProcessBeanFactory(factory)\n----\n======\n\nIn both cases, the explicit registration steps are inconvenient, which is\nwhy the various `ApplicationContext` variants are preferred over a plain\n`DefaultListableBeanFactory` in Spring-backed applications, especially when\nrelying on `BeanFactoryPostProcessor` and `BeanPostProcessor` instances for extended\ncontainer functionality in a typical enterprise setup.\n\n[NOTE]\n====\nAn `AnnotationConfigApplicationContext` has all common annotation post-processors\nregistered and may bring in additional processors underneath the\ncovers through configuration annotations, such as `@EnableTransactionManagement`.\nAt the abstraction level of Spring's annotation-based configuration model,\nthe notion of bean post-processors becomes a mere internal container detail.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/beanfactory.adoc", "title": "beanfactory", "heading": "`BeanFactory` or `ApplicationContext`?", "heading_level": 2, "file_order": 53, "section_index": 1, "content_hash": "7f04e4a8941ea48a4c6b2f402c95ddb5ae6eb2211c1abf0f345bb26a7cb4486c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/beanfactory.adoc"}}
{"id": "sha256:895556bc316eef5b4df9f1f8fc08d4e1c18f1b380a8c6f18fc2b51798d7b7269", "content": "[[beans-child-bean-definitions]]\n\nA bean definition can contain a lot of configuration information, including constructor\narguments, property values, and container-specific information, such as the initialization\nmethod, a static factory method name, and so on. A child bean definition inherits\nconfiguration data from a parent definition. The child definition can override some\nvalues or add others as needed. Using parent and child bean definitions can save a lot\nof typing. Effectively, this is a form of templating.\n\nIf you work with an `ApplicationContext` interface programmatically, child bean\ndefinitions are represented by the `ChildBeanDefinition` class. Most users do not work\nwith them on this level. Instead, they configure bean definitions declaratively in a class\nsuch as the `ClassPathXmlApplicationContext`. When you use XML-based configuration\nmetadata, you can indicate a child bean definition by using the `parent` attribute,\nspecifying the parent bean as the value of this attribute. The following example shows how\nto do so:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"inheritedTestBean\" abstract=\"true\"\n class=\"org.springframework.beans.TestBean\">\n <property name=\"name\" value=\"parent\"/>\n <property name=\"age\" value=\"1\"/>\n\t</bean>\n\n\t<bean id=\"inheritsWithDifferentClass\"\n class=\"org.springframework.beans.DerivedTestBean\"\n parent=\"inheritedTestBean\" init-method=\"initialize\"> <1>\n <property name=\"name\" value=\"override\"/>\n <!-- the age property value of 1 will be inherited from parent -->\n\t</bean>\n----\n<1> Note the `parent` attribute.\n\nA child bean definition uses the bean class from the parent definition if none is\nspecified but can also override it. In the latter case, the child bean class must be\ncompatible with the parent (that is, it must accept the parent's property values).\n\nA child bean definition inherits scope, constructor argument values, property values, and\nmethod overrides from the parent, with the option to add new values. Any scope, initialization\nmethod, destroy method, or `static` factory method settings that you specify\noverride the corresponding parent settings.\n\nThe remaining settings are always taken from the child definition: depends on,\nautowire mode, dependency check, singleton, and lazy init.\n\nThe preceding example explicitly marks the parent bean definition as abstract by using\nthe `abstract` attribute. If the parent definition does not specify a class, explicitly\nmarking the parent bean definition as `abstract` is required, as the following example\nshows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"inheritedTestBeanWithoutClass\" abstract=\"true\">\n <property name=\"name\" value=\"parent\"/>\n <property name=\"age\" value=\"1\"/>\n\t</bean>\n\n\t<bean id=\"inheritsWithClass\" class=\"org.springframework.beans.DerivedTestBean\"\n parent=\"inheritedTestBeanWithoutClass\" init-method=\"initialize\">\n <property name=\"name\" value=\"override\"/>\n <!-- age will inherit the value of 1 from the parent bean definition-->\n\t</bean>\n----\n\nThe parent bean cannot be instantiated on its own because it is incomplete, and it is\nalso explicitly marked as `abstract`. When a definition is `abstract`, it is\nusable only as a pure template bean definition that serves as a parent definition for\nchild definitions. Trying to use such an `abstract` parent bean on its own, by referring\nto it as a ref property of another bean or doing an explicit `getBean()` call with the\nparent bean ID returns an error. Similarly, the container's internal\n`preInstantiateSingletons()` method ignores bean definitions that are defined as\nabstract.\n\nNOTE: `ApplicationContext` pre-instantiates all singletons by default. Therefore, it is\nimportant (at least for singleton beans) that if you have a (parent) bean definition\nwhich you intend to use only as a template, and this definition specifies a class, you\nmust make sure to set the __abstract__ attribute to __true__, otherwise the application\ncontext will actually (attempt to) pre-instantiate the `abstract` bean.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/child-bean-definitions.adoc", "title": "child-bean-definitions", "heading": "child-bean-definitions", "heading_level": 1, "file_order": 54, "section_index": 0, "content_hash": "895556bc316eef5b4df9f1f8fc08d4e1c18f1b380a8c6f18fc2b51798d7b7269", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/child-bean-definitions.adoc"}}
{"id": "sha256:bf24c1bce5297d5a0e4fb9a3a14f35f03e10df9e699e6b2b5a8cdb11e9d1c4ef", "content": "[[beans-classpath-scanning]]\n\nMost examples in this chapter use XML to specify the configuration metadata that\nproduces each `BeanDefinition` within the Spring container. The previous section\n(xref:core/beans/annotation-config.adoc[Annotation-based Container Configuration])\ndemonstrates how to provide a lot of the configuration metadata through source-level\nannotations. Even in those examples, however, the \"base\" bean definitions are explicitly\ndefined in the XML file, while the annotations drive only the dependency injection.\n\nThis section describes an option for implicitly detecting the candidate components by\nscanning the classpath. Candidate components are classes that match against filter\ncriteria and have a corresponding bean definition registered with the container.\nThis removes the need to use XML to perform bean registration. Instead, you can use\nannotations (for example, `@Component`), AspectJ type expressions, or your own\ncustom filter criteria to select which classes have bean definitions registered with\nthe container.\n\n[NOTE]\n====\nYou can define beans using Java rather than using XML files. Take a look at the\n`@Configuration`, `@Bean`, `@Import`, and `@DependsOn` annotations for examples\nof how to use these features.\n====\n\n[[beans-stereotype-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc", "title": "classpath-scanning", "heading": "classpath-scanning", "heading_level": 1, "file_order": 55, "section_index": 0, "content_hash": "bf24c1bce5297d5a0e4fb9a3a14f35f03e10df9e699e6b2b5a8cdb11e9d1c4ef", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc"}}
{"id": "sha256:ac10ecfb265b0c396f842497525ae23234f1718943fdaa9098355e8ece5f4726", "content": "The `@Repository` annotation is a marker for any class that fulfills the role or\n_stereotype_ of a repository (also known as Data Access Object or DAO). Among the uses\nof this marker is the automatic translation of exceptions, as described in\nxref:data-access/orm/general.adoc#orm-exception-translation[Exception Translation].\n\nSpring provides further stereotype annotations: `@Component`, `@Service`, and\n`@Controller`. `@Component` is a generic stereotype for any Spring-managed component.\n`@Repository`, `@Service`, and `@Controller` are specializations of `@Component` for\nmore specific use cases (in the persistence, service, and presentation\nlayers, respectively). Therefore, you can annotate your component classes with\n`@Component`, but, by annotating them with `@Repository`, `@Service`, or `@Controller`\ninstead, your classes are more properly suited for processing by tools or associating\nwith aspects. For example, these stereotype annotations make ideal targets for\npointcuts. `@Repository`, `@Service`, and `@Controller` may also\ncarry additional semantics in future releases of the Spring Framework. Thus, if you are\nchoosing between using `@Component` or `@Service` for your service layer, `@Service` is\nclearly the better choice. Similarly, as stated earlier, `@Repository` is already\nsupported as a marker for automatic exception translation in your persistence layer.\n\n[[beans-meta-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc", "title": "classpath-scanning", "heading": "`@Component` and Further Stereotype Annotations", "heading_level": 2, "file_order": 55, "section_index": 1, "content_hash": "ac10ecfb265b0c396f842497525ae23234f1718943fdaa9098355e8ece5f4726", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc"}}
{"id": "sha256:718d3dd691bbf3f75fb02e782067a5b83adeb324b5d7f43e60861d521d66959f", "content": "Many of the annotations provided by Spring can be used as meta-annotations in your\nown code. A meta-annotation is an annotation that can be applied to another annotation.\nFor example, the `@Service` annotation mentioned xref:core/beans/classpath-scanning.adoc#beans-stereotype-annotations[earlier]\nis meta-annotated with `@Component`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\t@Component // <1>\n\tpublic @interface Service {\n\n // ...\n\t}\n----\n<1> The `@Component` meta-annotation causes `@Service` to be treated in the same way as `@Component`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(AnnotationTarget.TYPE)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@MustBeDocumented\n\t@Component // <1>\n\tannotation class Service {\n\n // ...\n\t}\n----\n<1> The `@Component` meta-annotation causes `@Service` to be treated in the same way as `@Component`.\n======\n\nYou can also combine meta-annotations to create \"`composed annotations`\". For example,\nthe `@RestController` annotation from Spring MVC is composed of `@Controller` and\n`@ResponseBody`.\n\nIn addition, composed annotations can optionally redeclare attributes from\nmeta-annotations to allow customization. This can be particularly useful when you\nwant to only expose a subset of the meta-annotation's attributes. For example, Spring's\n`@SessionScope` annotation hard codes the scope name to `session` but still allows\ncustomization of the `proxyMode`. The following listing shows the definition of the\n`@SessionScope` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\t@Scope(WebApplicationContext.SCOPE_SESSION)\n\tpublic @interface SessionScope {\n\n /**\n * Alias for {@link Scope#proxyMode}.\n * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.\n */\n @AliasFor(annotation = Scope.class)\n ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@MustBeDocumented\n\t@Scope(WebApplicationContext.SCOPE_SESSION)\n\tannotation class SessionScope(\n @get:AliasFor(annotation = Scope::class)\n val proxyMode: ScopedProxyMode = ScopedProxyMode.TARGET_CLASS\n\t)\n----\n======\n\nYou can then use `@SessionScope` without declaring the `proxyMode` as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Service\n\t@SessionScope\n\tpublic class SessionScopedService {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Service\n\t@SessionScope\n\tclass SessionScopedService {\n // ...\n\t}\n----\n======\n\nYou can also override the value for the `proxyMode`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Service\n\t@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)\n\tpublic class SessionScopedUserService implements UserService {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Service\n\t@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)\n\tclass SessionScopedUserService : UserService {\n // ...\n\t}\n----\n======\n\nFor further details, see the\n{spring-framework-wiki}/Spring-Annotation-Programming-Model[Spring Annotation Programming Model]\nwiki page.\n\n[[beans-scanning-autodetection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc", "title": "classpath-scanning", "heading": "Using Meta-annotations and Composed Annotations", "heading_level": 2, "file_order": 55, "section_index": 2, "content_hash": "718d3dd691bbf3f75fb02e782067a5b83adeb324b5d7f43e60861d521d66959f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc"}}
{"id": "sha256:ed4daa455d452f72564c1f99d41556e471c37767eda44eb6c2f9237d83441ff1", "content": "Spring can automatically detect stereotyped classes and register corresponding\n`BeanDefinition` instances with the `ApplicationContext`. For example, the following two classes\nare eligible for such autodetection:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Service\n\tpublic class SimpleMovieLister {\n\n private final MovieFinder movieFinder;\n\n public SimpleMovieLister(MovieFinder movieFinder) {\n this.movieFinder = movieFinder;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Service\n\tclass SimpleMovieLister(private val movieFinder: MovieFinder)\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository\n\tpublic class JpaMovieFinder implements MovieFinder {\n // implementation elided for clarity\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository\n\tclass JpaMovieFinder : MovieFinder {\n // implementation elided for clarity\n\t}\n----\n======\n\nTo autodetect these classes and register the corresponding beans, you need to add\n`@ComponentScan` to your `@Configuration` class, where the `basePackages` attribute is\nconfigured with a common parent package for the two classes. Alternatively, you can\nspecify a comma-, semicolon-, or space-separated list that includes the parent package\nof each class.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = \"org.example\")\n\tpublic class AppConfig {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = [\"org.example\"])\n\tclass AppConfig {\n // ...\n\t}\n----\n======\n\nTIP: For brevity, the preceding example could have used the implicit `value` attribute of\nthe annotation instead: `@ComponentScan(\"org.example\")`\n\nThe following example uses XML configuration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:context=\"http://www.springframework.org/schema/context\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/context\n https://www.springframework.org/schema/context/spring-context.xsd\">\n\n <context:component-scan base-package=\"org.example\"/>\n\n\t</beans>\n----\n\nTIP: The use of `<context:component-scan>` implicitly enables the functionality of\n`<context:annotation-config>`. There is usually no need to include the\n`<context:annotation-config>` element when using `<context:component-scan>`.\n\n[NOTE]\n====\nThe scanning of classpath packages requires the presence of corresponding directory\nentries in the classpath. When you build JARs with Ant, make sure that you do not\nactivate the files-only switch of the JAR task. Also, classpath directories may not be\nexposed based on security policies in some environments -- for example, standalone apps on\nJDK 1.7.0_45 and higher (which requires 'Trusted-Library' setup in your manifests -- see\n{stackoverflow-questions}/19394570/java-jre-7u45-breaks-classloader-getresources).\n\nOn the module path (Java Module System), Spring's classpath scanning generally works as\nexpected. However, make sure that your component classes are exported in your `module-info`\ndescriptors. If you expect Spring to invoke non-public members of your classes, make\nsure that they are 'opened' (that is, that they use an `opens` declaration instead of an\n`exports` declaration in your `module-info` descriptor).\n====\n\nFurthermore, the `AutowiredAnnotationBeanPostProcessor` and\n`CommonAnnotationBeanPostProcessor` are both implicitly included when you use the\n`<context:component-scan>` element. That means that the two components are autodetected\nand wired together -- all without any bean configuration metadata provided in XML.\n\nNOTE: You can disable the registration of `AutowiredAnnotationBeanPostProcessor` and\n`CommonAnnotationBeanPostProcessor` by including the `annotation-config` attribute\nwith a value of `false`.\n\n[[beans-scanning-placeholders-and-patterns]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc", "title": "classpath-scanning", "heading": "Automatically Detecting Classes and Registering Bean Definitions", "heading_level": 2, "file_order": 55, "section_index": 3, "content_hash": "ed4daa455d452f72564c1f99d41556e471c37767eda44eb6c2f9237d83441ff1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc"}}
{"id": "sha256:19e44fd46421bed0354572fedc6604210c79ccc45703768083004bd9bc8e1ea2", "content": "The `basePackages` and `value` attributes in `@ComponentScan` support `${...}` property\nplaceholders which are resolved against the `Environment` as well as Ant-style package\npatterns such as `\"org.example.+++**+++\"`.\n\nIn addition, multiple packages or patterns may be specified, either separately or within\na single String â€” for example, `{\"org.example.config\", \"org.example.service.+++**+++\"}`\nor `\"org.example.config, org.example.service.+++**+++\"`.\n\nThe following example specifies the `app.scan.packages` property placeholder for the\nimplicit `value` attribute in `@ComponentScan`.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n@Configuration\n@ComponentScan(\"${app.scan.packages}\") // <1>\npublic class AppConfig {\n\t// ...\n}\n----\n<1> `app.scan.packages` property placeholder to be resolved against the `Environment`\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n@Configuration\n@ComponentScan([\"\\${app.scan.packages}\"]) // <1>\nclass AppConfig {\n\t// ...\n}\n----\n<1> `app.scan.packages` property placeholder to be resolved against the `Environment`\n======\n\nThe following listing represents a properties file which defines the `app.scan.packages`\nproperty. In the preceding example, it is assumed that this properties file has been\nregistered with the `Environment` â€“ for example, via `@PropertySource` or a similar\nmechanism.\n\n[source,properties,indent=0,subs=\"verbatim,quotes\"]\n----\napp.scan.packages=org.example.config, org.example.service.**\n----\n\n[[beans-scanning-filters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc", "title": "classpath-scanning", "heading": "Property Placeholders and Ant-style Patterns", "heading_level": 3, "file_order": 55, "section_index": 4, "content_hash": "19e44fd46421bed0354572fedc6604210c79ccc45703768083004bd9bc8e1ea2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc"}}
{"id": "sha256:2c138c84c9c5d2d326b6e8591c11541f6f63e5c9ced6cff3ec05c4fa69e8c763", "content": "By default, classes annotated with `@Component`, `@Repository`, `@Service`, `@Controller`,\n`@Configuration`, or a custom annotation that itself is annotated with `@Component` are\nthe only detected candidate components. However, you can modify and extend this behavior\nby applying custom filters. Add them as `includeFilters` or `excludeFilters` attributes of\nthe `@ComponentScan` annotation (or as `<context:include-filter />` or\n`<context:exclude-filter />` child elements of the `<context:component-scan>` element in\nXML configuration). Each filter element requires the `type` and `expression` attributes.\nThe following table describes the filtering options:\n\n[[beans-scanning-filters-tbl]]\n.Filter Types\n|===\n| Filter Type| Example Expression| Description\n\n| annotation (default)\n| `org.example.SomeAnnotation`\n| An annotation to be _present_ or _meta-present_ at the type level in target components.\n\n| assignable\n| `org.example.SomeClass`\n| A class (or interface) that the target components are assignable to (extend or implement).\n\n| aspectj\n| `org.example..*Service+`\n| An AspectJ type expression to be matched by the target components.\n\n| regex\n| `org\\.example\\.Default.*`\n| A regex expression to be matched by the target components' class names.\n\n| custom\n| `org.example.MyTypeFilter`\n| A custom implementation of the `org.springframework.core.type.TypeFilter` interface.\n|===\n\nThe following example shows `@ComponentScan` configuration that excludes all\n`@Repository` annotations and includes \"`Stub`\" repositories instead:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = \"org.example\",\n includeFilters = @Filter(type = FilterType.REGEX, pattern = \".*Stub.*Repository\"),\n excludeFilters = @Filter(Repository.class))\n\tpublic class AppConfig {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = [\"org.example\"],\n includeFilters = [Filter(type = FilterType.REGEX, pattern = [\".*Stub.*Repository\"])],\n excludeFilters = [Filter(Repository::class)])\n\tclass AppConfig {\n // ...\n\t}\n----\n======\n\nThe following listing shows the equivalent XML:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <context:component-scan base-package=\"org.example\">\n <context:include-filter type=\"regex\"\n expression=\".*Stub.*Repository\"/>\n <context:exclude-filter type=\"annotation\"\n expression=\"org.springframework.stereotype.Repository\"/>\n </context:component-scan>\n\t</beans>\n----\n\nNOTE: You can also disable the default filters by setting `useDefaultFilters=false` on the\nannotation or by providing `use-default-filters=\"false\"` as an attribute of the\n`<component-scan/>` element. This effectively disables automatic detection of classes\nannotated or meta-annotated with `@Component`, `@Repository`, `@Service`, `@Controller`,\n`@RestController`, or `@Configuration`.\n\n[[beans-scanning-name-generator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc", "title": "classpath-scanning", "heading": "Using Filters to Customize Scanning", "heading_level": 3, "file_order": 55, "section_index": 5, "content_hash": "2c138c84c9c5d2d326b6e8591c11541f6f63e5c9ced6cff3ec05c4fa69e8c763", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc"}}
{"id": "sha256:5dea22a1968ad20cca6cf507cce9657104285bea500d5a44f7b91f0af59622e8", "content": "When a component is autodetected as part of the scanning process, its bean name is\ngenerated by the `BeanNameGenerator` strategy known to that scanner.\n\nBy default, the `AnnotationBeanNameGenerator` is used. For Spring\nxref:core/beans/classpath-scanning.adoc#beans-stereotype-annotations[stereotype annotations],\nif you supply a name via the annotation's `value` attribute that name will be used as\nthe name in the corresponding bean definition. This convention also applies when the\n`@jakarta.inject.Named` annotation is used instead of Spring stereotype annotations.\n\nAs of Spring Framework 6.1, the name of the annotation attribute that is used to specify\nthe bean name is no longer required to be `value`. Custom stereotype annotations can\ndeclare an attribute with a different name (such as `name`) and annotate that attribute\nwith `@AliasFor(annotation = Component.class, attribute = \"value\")`. See the source code\ndeclaration of `ControllerAdvice#name()` for a concrete example.\n\n[WARNING]\n====\nAs of Spring Framework 6.1, support for convention-based stereotype names is deprecated\nand will be removed in a future version of the framework. Consequently, custom stereotype\nannotations must use `@AliasFor` to declare an explicit alias for the `value` attribute\nin `@Component`. See the source code declaration of `Repository#value()` and\n`ControllerAdvice#name()` for concrete examples.\n====\n\nIf an explicit bean name cannot be derived from such an annotation or for any other\ndetected component (such as those discovered by custom filters), the default bean name\ngenerator returns the uncapitalized non-qualified class name. For example, if the\nfollowing component classes were detected, the names would be `myMovieLister` and\n`movieFinderImpl`.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Service(\"myMovieLister\")\n\tpublic class SimpleMovieLister {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Service(\"myMovieLister\")\n\tclass SimpleMovieLister {\n // ...\n\t}\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository\n\tpublic class MovieFinderImpl implements MovieFinder {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository\n\tclass MovieFinderImpl : MovieFinder {\n // ...\n\t}\n----\n======\n\nIf you do not want to rely on the default bean-naming strategy, you can provide a custom\nbean-naming strategy. First, implement the\n{spring-framework-api}/beans/factory/support/BeanNameGenerator.html[`BeanNameGenerator`]\ninterface, and be sure to include a default no-arg constructor. Then, provide the fully\nqualified class name when configuring the scanner, as the following example annotation\nand bean definition show.\n\nTIP: If you run into naming conflicts due to multiple autodetected components having the\nsame non-qualified class name (i.e., classes with identical names but residing in\ndifferent packages), you may need to configure a `BeanNameGenerator` that defaults to the\nfully qualified class name for the generated bean name. The\n`FullyQualifiedAnnotationBeanNameGenerator` located in package\n`org.springframework.context.annotation` can be used for such purposes.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = \"org.example\", nameGenerator = MyNameGenerator.class)\n\tpublic class AppConfig {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = [\"org.example\"], nameGenerator = MyNameGenerator::class)\n\tclass AppConfig {\n // ...\n\t}\n----\n======\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <context:component-scan base-package=\"org.example\"\n name-generator=\"org.example.MyNameGenerator\" />\n\t</beans>\n----\n\nAs a general rule, consider specifying the name with the annotation whenever other\ncomponents may be making explicit references to it. On the other hand, the\nauto-generated names are adequate whenever the container is responsible for wiring.\n\n[[beans-scanning-scope-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc", "title": "classpath-scanning", "heading": "Naming Autodetected Components", "heading_level": 3, "file_order": 55, "section_index": 6, "content_hash": "5dea22a1968ad20cca6cf507cce9657104285bea500d5a44f7b91f0af59622e8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc"}}
{"id": "sha256:94b97b85aa6f94947b0611d7a478e76f2b8d4e195e38e00a563bd7167e239cad", "content": "As with Spring-managed components in general, the default and most common scope for\nautodetected components is `singleton`. However, sometimes you need a different scope\nthat can be specified by the `@Scope` annotation. You can provide the name of the\nscope within the annotation, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scope(\"prototype\")\n\t@Repository\n\tpublic class MovieFinderImpl implements MovieFinder {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scope(\"prototype\")\n\t@Repository\n\tclass MovieFinderImpl : MovieFinder {\n // ...\n\t}\n----\n======\n\nNOTE: `@Scope` annotations are only introspected on the concrete bean class (for annotated\ncomponents) or the factory method (for `@Bean` methods). In contrast to XML bean\ndefinitions, there is no notion of bean definition inheritance, and inheritance\nhierarchies at the class level are irrelevant for metadata purposes.\n\nFor details on web-specific scopes such as \"`request`\" or \"`session`\" in a Spring context,\nsee xref:core/beans/factory-scopes.adoc#beans-factory-scopes-other[Request, Session, Application, and WebSocket Scopes].\nAs with the pre-built annotations for those scopes, you may also compose your own scoping\nannotations by using Spring's meta-annotation approach: for example, a custom annotation\nmeta-annotated with `@Scope(\"prototype\")`, possibly also declaring a custom scoped-proxy mode.\n\nNOTE: To provide a custom strategy for scope resolution rather than relying on the\nannotation-based approach, you can implement the\n{spring-framework-api}/context/annotation/ScopeMetadataResolver.html[`ScopeMetadataResolver`]\ninterface. Be sure to include a default no-arg constructor. Then you can provide the\nfully qualified class name when configuring the scanner, as the following example of both\nan annotation and a bean definition shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = \"org.example\", scopeResolver = MyScopeResolver.class)\n\tpublic class AppConfig {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = [\"org.example\"], scopeResolver = MyScopeResolver::class)\n\tclass AppConfig {\n // ...\n\t}\n----\n======\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <context:component-scan base-package=\"org.example\" scope-resolver=\"org.example.MyScopeResolver\"/>\n\t</beans>\n----\n\nWhen using certain non-singleton scopes, it may be necessary to generate proxies for the\nscoped objects. The reasoning is described in\nxref:core/beans/factory-scopes.adoc#beans-factory-scopes-other-injection[Scoped Beans as Dependencies].\nFor this purpose, a scoped-proxy attribute is available on the component-scan\nelement. The three possible values are: `no`, `interfaces`, and `targetClass`. For example,\nthe following configuration results in standard JDK dynamic proxies:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = \"org.example\", scopedProxy = ScopedProxyMode.INTERFACES)\n\tpublic class AppConfig {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = [\"org.example\"], scopedProxy = ScopedProxyMode.INTERFACES)\n\tclass AppConfig {\n // ...\n\t}\n----\n======\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <context:component-scan base-package=\"org.example\" scoped-proxy=\"interfaces\"/>\n\t</beans>\n----\n\n[[beans-scanning-qualifiers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc", "title": "classpath-scanning", "heading": "Providing a Scope for Autodetected Components", "heading_level": 3, "file_order": 55, "section_index": 7, "content_hash": "94b97b85aa6f94947b0611d7a478e76f2b8d4e195e38e00a563bd7167e239cad", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc"}}
{"id": "sha256:ca9288044055be4fef5923ef0d715468a1a34dd33a35ffc7f4b04fa4915df88a", "content": "The `@Qualifier` annotation is discussed in\nxref:core/beans/annotation-config/autowired-qualifiers.adoc[Fine-tuning Annotation-based Autowiring with Qualifiers].\nThe examples in that section demonstrate the use of the `@Qualifier` annotation and\ncustom qualifier annotations to provide fine-grained control when you resolve autowire\ncandidates. Because those examples were based on XML bean definitions, the qualifier\nmetadata was provided on the candidate bean definitions by using the `qualifier` or `meta`\nchild elements of the `bean` element in the XML. When relying upon classpath scanning for\nauto-detection of components, you can provide the qualifier metadata with type-level\nannotations on the candidate class. The following three examples demonstrate this\ntechnique:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\t@Qualifier(\"Action\")\n\tpublic class ActionMovieCatalog implements MovieCatalog {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\t@Qualifier(\"Action\")\n\tclass ActionMovieCatalog : MovieCatalog\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\t@Genre(\"Action\")\n\tpublic class ActionMovieCatalog implements MovieCatalog {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\t@Genre(\"Action\")\n\tclass ActionMovieCatalog : MovieCatalog {\n // ...\n\t}\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\t@Offline\n\tpublic class CachingMovieCatalog implements MovieCatalog {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n@Component\n@Offline\nclass CachingMovieCatalog : MovieCatalog {\n\t// ...\n}\n----\n======\n\nNOTE: As with most annotation-based alternatives, keep in mind that the annotation metadata is\nbound to the class definition itself, while the use of XML allows for multiple beans\nof the same type to provide variations in their qualifier metadata, because that\nmetadata is provided per-instance rather than per-class.\n\n[[beans-factorybeans-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc", "title": "classpath-scanning", "heading": "Providing Qualifier Metadata with Annotations", "heading_level": 3, "file_order": 55, "section_index": 8, "content_hash": "ca9288044055be4fef5923ef0d715468a1a34dd33a35ffc7f4b04fa4915df88a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc"}}
{"id": "sha256:ff6399ddc1cee8fe7137b68a9c7b67fbc298a91908877b167c7b8a44cd5d3171", "content": "Spring components can also contribute bean definition metadata to the container. You can do\nthis with the same `@Bean` annotation used to define bean metadata within `@Configuration`\nannotated classes. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tpublic class FactoryMethodComponent {\n\n @Bean\n @Qualifier(\"public\")\n public TestBean publicInstance() {\n return new TestBean(\"publicInstance\");\n }\n\n public void doWork() {\n // Component method implementation omitted\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tclass FactoryMethodComponent {\n\n @Bean\n @Qualifier(\"public\")\n fun publicInstance() = TestBean(\"publicInstance\")\n\n fun doWork() {\n // Component method implementation omitted\n }\n\t}\n----\n======\n\nThe preceding class is a Spring component that has application-specific code in its\n`doWork()` method. However, it also contributes a bean definition that has a factory\nmethod referring to the method `publicInstance()`. The `@Bean` annotation identifies the\nfactory method and other bean definition properties, such as a qualifier value through\nthe `@Qualifier` annotation. Other method-level annotations that can be specified are\n`@Scope`, `@Lazy`, and custom qualifier annotations.\n\n[[beans-factorybeans-annotations-lazy-injection-points]]\n[TIP]\n====\nIn addition to its role for component initialization, you can also place the `@Lazy`\nannotation on injection points marked with `@Autowired` or `@Inject`. In this context,\nit leads to the injection of a lazy-resolution proxy. However, such a proxy approach\nis rather limited. For sophisticated lazy interactions, in particular in combination\nwith optional dependencies, we recommend `ObjectProvider<MyTargetBean>` instead.\n====\n\nAutowired fields and methods are supported, as previously discussed, with additional\nsupport for autowiring of `@Bean` methods. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tpublic class FactoryMethodComponent {\n\n private static int i;\n\n @Bean\n @Qualifier(\"public\")\n public TestBean publicInstance() {\n return new TestBean(\"publicInstance\");\n }\n\n // use of a custom qualifier and autowiring of method parameters\n @Bean\n protected TestBean protectedInstance(\n @Qualifier(\"public\") TestBean spouse,\n @Value(\"#{privateInstance.age}\") String country) {\n TestBean tb = new TestBean(\"protectedInstance\", 1);\n tb.setSpouse(spouse);\n tb.setCountry(country);\n return tb;\n }\n\n @Bean\n private TestBean privateInstance() {\n return new TestBean(\"privateInstance\", i++);\n }\n\n @Bean\n @RequestScope\n public TestBean requestScopedInstance() {\n return new TestBean(\"requestScopedInstance\", 3);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tclass FactoryMethodComponent {\n\n companion object {\n private var i: Int = 0\n }\n\n @Bean\n @Qualifier(\"public\")\n fun publicInstance() = TestBean(\"publicInstance\")\n\n // use of a custom qualifier and autowiring of method parameters\n @Bean\n protected fun protectedInstance(\n @Qualifier(\"public\") spouse: TestBean,\n @Value(\"#{privateInstance.age}\") country: String) = TestBean(\"protectedInstance\", 1).apply {\n this.spouse = spouse\n this.country = country\n }\n\n @Bean\n private fun privateInstance() = TestBean(\"privateInstance\", i++)\n\n @Bean\n @RequestScope\n fun requestScopedInstance() = TestBean(\"requestScopedInstance\", 3)\n\t}\n----\n======\n\nThe example autowires the `String` method parameter `country` to the value of the `age`\nproperty on another bean named `privateInstance`. A Spring Expression Language element\ndefines the value of the property through the notation `#{ <expression> }`. For `@Value`\nannotations, an expression resolver is preconfigured to look for bean names when\nresolving expression text.\n\nAs of Spring Framework 4.3, you may also declare a factory method parameter of type\n`InjectionPoint` (or its more specific subclass: `DependencyDescriptor`) to\naccess the requesting injection point that triggers the creation of the current bean.\nNote that this applies only to the actual creation of bean instances, not to the\ninjection of existing instances. As a consequence, this feature makes most sense for\nbeans of prototype scope. For other scopes, the factory method only ever sees the\ninjection point that triggered the creation of a new bean instance in the given scope\n(for example, the dependency that triggered the creation of a lazy singleton bean).\nYou can use the provided injection point metadata with semantic care in such scenarios.\nThe following example shows how to use `InjectionPoint`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tpublic class FactoryMethodComponent {\n\n @Bean @Scope(\"prototype\")\n public TestBean prototypeInstance(InjectionPoint injectionPoint) {\n return new TestBean(\"prototypeInstance for \" + injectionPoint.getMember());\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tclass FactoryMethodComponent {\n\n @Bean\n @Scope(\"prototype\")\n fun prototypeInstance(injectionPoint: InjectionPoint) =\n TestBean(\"prototypeInstance for ${injectionPoint.member}\")\n\t}\n----\n======\n\nThe `@Bean` methods in a regular Spring component are processed differently than their\ncounterparts inside a Spring `@Configuration` class. The difference is that `@Component`\nclasses are not enhanced with CGLIB to intercept the invocation of methods and fields.\nCGLIB proxying is the means by which invoking methods or fields within `@Bean` methods\nin `@Configuration` classes creates bean metadata references to collaborating objects.\nSuch methods are not invoked with normal Java semantics but rather go through the\ncontainer in order to provide the usual lifecycle management and proxying of Spring\nbeans, even when referring to other beans through programmatic calls to `@Bean` methods.\nIn contrast, invoking a method or field in a `@Bean` method within a plain `@Component`\nclass has standard Java semantics, with no special CGLIB processing or other\nconstraints applying.\n\n[NOTE]\n====\nYou may declare `@Bean` methods as `static`, allowing for them to be called without\ncreating their containing configuration class as an instance. This makes particular\nsense when defining post-processor beans (for example, of type `BeanFactoryPostProcessor`\nor `BeanPostProcessor`), since such beans get initialized early in the container\nlifecycle and should avoid triggering other parts of the configuration at that point.\n\nCalls to static `@Bean` methods never get intercepted by the container, not even within\n`@Configuration` classes (as described earlier in this section), due to technical\nlimitations: CGLIB subclassing can override only non-static methods. As a consequence,\na direct call to another `@Bean` method has standard Java semantics, resulting\nin an independent instance being returned straight from the factory method itself.\n\nThe Java language visibility of `@Bean` methods does not have an immediate impact on\nthe resulting bean definition in Spring's container. You can freely declare your\nfactory methods as you see fit in non-`@Configuration` classes and also for static\nmethods anywhere. However, regular `@Bean` methods in `@Configuration` classes need\nto be overridable -- that is, they must not be declared as `private` or `final`.\n\n`@Bean` methods are also discovered on base classes of a given component or\nconfiguration class, as well as on Java default methods declared in interfaces\nimplemented by the component or configuration class. This allows for a lot of\nflexibility in composing complex configuration arrangements, with even multiple\ninheritance being possible through Java default methods.\n\nFinally, a single class may hold multiple `@Bean` methods for the same\nbean, as an arrangement of multiple factory methods to use depending on available\ndependencies at runtime. This is the same algorithm as for choosing the \"`greediest`\"\nconstructor or factory method in other configuration scenarios: The variant with\nthe largest number of satisfiable dependencies is picked at construction time,\nanalogous to how the container selects between multiple `@Autowired` constructors.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc", "title": "classpath-scanning", "heading": "Defining Bean Metadata within Components", "heading_level": 2, "file_order": 55, "section_index": 9, "content_hash": "ff6399ddc1cee8fe7137b68a9c7b67fbc298a91908877b167c7b8a44cd5d3171", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/classpath-scanning.adoc"}}
{"id": "sha256:a55b2342df00b7b55844da6cc3ffff88ec7bbdde5c563fc1d9f91a32c04b8242", "content": "[[context-introduction]]\n\nAs discussed in the xref:core/beans/introduction.adoc[chapter introduction], the `org.springframework.beans.factory`\npackage provides basic functionality for managing and manipulating beans, including in a\nprogrammatic way. The `org.springframework.context` package adds the\n{spring-framework-api}/context/ApplicationContext.html[`ApplicationContext`]\ninterface, which extends the `BeanFactory` interface, in addition to extending other\ninterfaces to provide additional functionality in a more application\nframework-oriented style. Many people use the `ApplicationContext` in a completely\ndeclarative fashion, not even creating it programmatically, but instead relying on\nsupport classes such as `ContextLoader` to automatically instantiate an\n`ApplicationContext` as part of the normal startup process of a Jakarta EE web application.\n\nTo enhance `BeanFactory` functionality in a more framework-oriented style, the context\npackage also provides the following functionality:\n\n* Access to messages in i18n-style, through the `MessageSource` interface.\n* Access to resources, such as URLs and files, through the `ResourceLoader` interface.\n* Event publication, namely to beans that implement the `ApplicationListener` interface,\n through the use of the `ApplicationEventPublisher` interface.\n* Loading of multiple (hierarchical) contexts, letting each be focused on one\n particular layer, such as the web layer of an application, through the\n `HierarchicalBeanFactory` interface.\n\n[[context-functionality-messagesource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc", "title": "context-introduction", "heading": "context-introduction", "heading_level": 1, "file_order": 56, "section_index": 0, "content_hash": "a55b2342df00b7b55844da6cc3ffff88ec7bbdde5c563fc1d9f91a32c04b8242", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc"}}
{"id": "sha256:5a35e3c90893a9fed8e53c5c9f5bbcf95d0466bfc58aeede7ee2dd846f96b91b", "content": "The `ApplicationContext` interface extends an interface called `MessageSource` and,\ntherefore, provides internationalization (\"`i18n`\") functionality. Spring also provides the\n`HierarchicalMessageSource` interface, which can resolve messages hierarchically.\nTogether, these interfaces provide the foundation upon which Spring effects message\nresolution. The methods defined on these interfaces include:\n\n* `String getMessage(String code, Object[] args, String default, Locale loc)`: The basic\n method used to retrieve a message from the `MessageSource`. When no message is found\n for the specified locale, the default message is used. Any arguments passed in become\n replacement values, using the `MessageFormat` functionality provided by the standard\n library.\n* `String getMessage(String code, Object[] args, Locale loc)`: Essentially the same as\n the previous method but with one difference: No default message can be specified. If\n the message cannot be found, a `NoSuchMessageException` is thrown.\n* `String getMessage(MessageSourceResolvable resolvable, Locale locale)`: All properties\n used in the preceding methods are also wrapped in a class named\n `MessageSourceResolvable`, which you can use with this method.\n\nWhen an `ApplicationContext` is loaded, it automatically searches for a `MessageSource`\nbean defined in the context. The bean must have the name `messageSource`. If such a bean\nis found, all calls to the preceding methods are delegated to the message source. If no\nmessage source is found, the `ApplicationContext` attempts to find a parent containing a\nbean with the same name. If it does, it uses that bean as the `MessageSource`. If the\n`ApplicationContext` cannot find any source for messages, an empty\n`DelegatingMessageSource` is instantiated in order to be able to accept calls to the\nmethods defined above.\n\nSpring provides three `MessageSource` implementations, `ResourceBundleMessageSource`, `ReloadableResourceBundleMessageSource`\nand `StaticMessageSource`. All of them implement `HierarchicalMessageSource` in order to do nested\nmessaging. The `StaticMessageSource` is rarely used but provides programmatic ways to\nadd messages to the source. The following example shows `ResourceBundleMessageSource`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"messageSource\"\n class=\"org.springframework.context.support.ResourceBundleMessageSource\">\n <property name=\"basenames\">\n <list>\n <value>format</value>\n <value>exceptions</value>\n <value>windows</value>\n </list>\n </property>\n </bean>\n\t</beans>\n----\n\nThe example assumes that you have three resource bundles called `format`, `exceptions` and `windows`\ndefined in your classpath. Any request to resolve a message is\nhandled in the JDK-standard way of resolving messages through `ResourceBundle` objects. For the\npurposes of the example, assume the contents of two of the above resource bundle files\nare as follows:\n\n[source,properties,indent=0,subs=\"verbatim,quotes\"]\n----\n\t# in format.properties\n\tmessage=Alligators rock!\n----\n\n[source,properties,indent=0,subs=\"verbatim,quotes\"]\n----\n\t# in exceptions.properties\n\targument.required=The {0} argument is required.\n----\n\nThe next example shows a program to run the `MessageSource` functionality.\nRemember that all `ApplicationContext` implementations are also `MessageSource`\nimplementations and so can be cast to the `MessageSource` interface.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic static void main(String[] args) {\n MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\");\n String message = resources.getMessage(\"message\", null, \"Default\", Locale.ENGLISH);\n System.out.println(message);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun main() {\n val resources = ClassPathXmlApplicationContext(\"beans.xml\")\n val message = resources.getMessage(\"message\", null, \"Default\", Locale.ENGLISH)\n println(message)\n\t}\n----\n======\n\nThe resulting output from the above program is as follows:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nAlligators rock!\n----\n\nTo summarize, the `MessageSource` is defined in a file called `beans.xml`, which\nexists at the root of your classpath. The `messageSource` bean definition refers to a\nnumber of resource bundles through its `basenames` property. The three files that are\npassed in the list to the `basenames` property exist as files at the root of your\nclasspath and are called `format.properties`, `exceptions.properties`, and\n`windows.properties`, respectively.\n\nThe next example shows arguments passed to the message lookup. These arguments are\nconverted into `String` objects and inserted into placeholders in the lookup message.\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <!-- this MessageSource is being used in a web application -->\n <bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\">\n <property name=\"basename\" value=\"exceptions\"/>\n </bean>\n\n <!-- lets inject the above MessageSource into this POJO -->\n <bean id=\"example\" class=\"com.something.Example\">\n <property name=\"messages\" ref=\"messageSource\"/>\n </bean>\n\n\t</beans>\n----\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class Example {\n\n private MessageSource messages;\n\n public void setMessages(MessageSource messages) {\n this.messages = messages;\n }\n\n public void execute() {\n String message = this.messages.getMessage(\"argument.required\",\n new Object [] {\"userDao\"}, \"Required\", Locale.ENGLISH);\n System.out.println(message);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Example {\n\n\tlateinit var messages: MessageSource\n\n\tfun execute() {\n val message = messages.getMessage(\"argument.required\",\n arrayOf(\"userDao\"), \"Required\", Locale.ENGLISH)\n println(message)\n\t}\n}\n----\n======\n\nThe resulting output from the invocation of the `execute()` method is as follows:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nThe userDao argument is required.\n----\n\nWith regard to internationalization (\"`i18n`\"), Spring's various `MessageSource`\nimplementations follow the same locale resolution and fallback rules as the standard JDK\n`ResourceBundle`. In short, and continuing with the example `messageSource` defined\npreviously, if you want to resolve messages against the British (`en-GB`) locale, you\nwould create files called `format_en_GB.properties`, `exceptions_en_GB.properties`, and\n`windows_en_GB.properties`, respectively.\n\nTypically, locale resolution is managed by the surrounding environment of the\napplication. In the following example, the locale against which (British) messages are\nresolved is specified manually:\n\n[literal,subs=\"verbatim,quotes\"]\n----\n# in exceptions_en_GB.properties\nargument.required=Ebagum lad, the ''{0}'' argument is required, I say, required.\n----\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic static void main(final String[] args) {\n MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\");\n String message = resources.getMessage(\"argument.required\",\n new Object [] {\"userDao\"}, \"Required\", Locale.UK);\n System.out.println(message);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun main() {\n val resources = ClassPathXmlApplicationContext(\"beans.xml\")\n val message = resources.getMessage(\"argument.required\",\n arrayOf(\"userDao\"), \"Required\", Locale.UK)\n println(message)\n\t}\n----\n======\n\nThe resulting output from the running of the above program is as follows:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nEbagum lad, the 'userDao' argument is required, I say, required.\n----\n\nYou can also use the `MessageSourceAware` interface to acquire a reference to any\n`MessageSource` that has been defined. Any bean that is defined in an\n`ApplicationContext` that implements the `MessageSourceAware` interface is injected with\nthe application context's `MessageSource` when the bean is created and configured.\n\nNOTE: Because Spring's `MessageSource` is based on Java's `ResourceBundle`, it does not merge\nbundles with the same base name, but will only use the first bundle found.\nSubsequent message bundles with the same base name are ignored.\n\nNOTE: As an alternative to `ResourceBundleMessageSource`, Spring provides a\n`ReloadableResourceBundleMessageSource` class. This variant supports the same bundle\nfile format but is more flexible than the standard JDK based\n`ResourceBundleMessageSource` implementation. In particular, it allows for reading\nfiles from any Spring resource location (not only from the classpath) and supports hot\nreloading of bundle property files (while efficiently caching them in between).\nSee the {spring-framework-api}/context/support/ReloadableResourceBundleMessageSource.html[`ReloadableResourceBundleMessageSource`]\njavadoc for details.\n\n[[context-functionality-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc", "title": "context-introduction", "heading": "Internationalization using `MessageSource`", "heading_level": 2, "file_order": 56, "section_index": 1, "content_hash": "5a35e3c90893a9fed8e53c5c9f5bbcf95d0466bfc58aeede7ee2dd846f96b91b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc"}}
{"id": "sha256:5a854cefc12e67e5f78276e78d81642112da1e89f5fb9a3dd9d4b9189851dc09", "content": "Event handling in the `ApplicationContext` is provided through the `ApplicationEvent`\nclass and the `ApplicationListener` interface. If a bean that implements the\n`ApplicationListener` interface is deployed into the context, every time an\n`ApplicationEvent` gets published to the `ApplicationContext`, that bean is notified.\nEssentially, this is the standard Observer design pattern.\n\nTIP: As of Spring 4.2, the event infrastructure has been significantly improved and offers\nan xref:core/beans/context-introduction.adoc#context-functionality-events-annotation[annotation-based model] as well as the\nability to publish any arbitrary event (that is, an object that does not necessarily\nextend from `ApplicationEvent`). When such an object is published, we wrap it in an\nevent for you.\n\nThe following table describes the standard events that Spring provides:\n\n[[beans-ctx-events-tbl]]\n.Built-in Events\n[cols=\"30%,70%\"]\n|===\n| Event| Explanation\n\n| `ContextRefreshedEvent`\n| Published when the `ApplicationContext` is initialized or refreshed (for example, by\n using the `refresh()` method on the `ConfigurableApplicationContext` interface).\n Here, \"`initialized`\" means that all beans are loaded, post-processor beans are detected\n and activated, singletons are pre-instantiated, and the `ApplicationContext` object is\n ready for use. As long as the context has not been closed, a refresh can be triggered\n multiple times, provided that the chosen `ApplicationContext` actually supports such\n \"`hot`\" refreshes. For example, `XmlWebApplicationContext` supports hot refreshes, but\n `GenericApplicationContext` does not.\n\n| `ContextStartedEvent`\n| Published when the `ApplicationContext` is started by using the `start()` method on the\n `ConfigurableApplicationContext` interface. Here, \"`started`\" means that all `Lifecycle`\n beans receive an explicit start signal. Typically, this signal is used to restart beans\n after an explicit stop, but it may also be used to start components that have not been\n configured for autostart (for example, components that have not already started on\n initialization).\n\n| `ContextStoppedEvent`\n| Published when the `ApplicationContext` is stopped by using the `stop()` method on the\n `ConfigurableApplicationContext` interface. Here, \"`stopped`\" means that all `Lifecycle`\n beans receive an explicit stop signal. A stopped context may be restarted through a\n `start()` call.\n\n| `ContextClosedEvent`\n| Published when the `ApplicationContext` is being closed by using the `close()` method\n on the `ConfigurableApplicationContext` interface or via a JVM shutdown hook. Here,\n \"closed\" means that all singleton beans will be destroyed. Once the context is closed,\n it reaches its end of life and cannot be refreshed or restarted.\n\n| `RequestHandledEvent`\n| A web-specific event telling all beans that an HTTP request has been serviced. This\n event is published after the request is complete. This event is only applicable to\n web applications that use Spring's `DispatcherServlet`.\n\n| `ServletRequestHandledEvent`\n| A subclass of `RequestHandledEvent` that adds Servlet-specific context information.\n\n|===\n\nYou can also create and publish your own custom events. The following example shows a\nsimple class that extends Spring's `ApplicationEvent` base class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class BlockedListEvent extends ApplicationEvent {\n\n private final String address;\n private final String content;\n\n public BlockedListEvent(Object source, String address, String content) {\n super(source);\n this.address = address;\n this.content = content;\n }\n\n // accessor and other methods...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass BlockedListEvent(source: Any,\n val address: String,\n val content: String) : ApplicationEvent(source)\n----\n======\n\nTo publish a custom `ApplicationEvent`, call the `publishEvent()` method on an\n`ApplicationEventPublisher`. Typically, this is done by creating a class that implements\n`ApplicationEventPublisherAware` and registering it as a Spring bean. The following\nexample shows such a class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class EmailService implements ApplicationEventPublisherAware {\n\n private List<String> blockedList;\n private ApplicationEventPublisher publisher;\n\n public void setBlockedList(List<String> blockedList) {\n this.blockedList = blockedList;\n }\n\n public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {\n this.publisher = publisher;\n }\n\n public void sendEmail(String address, String content) {\n if (blockedList.contains(address)) {\n publisher.publishEvent(new BlockedListEvent(this, address, content));\n return;\n }\n // send email...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass EmailService : ApplicationEventPublisherAware {\n\n private lateinit var blockedList: List<String>\n private lateinit var publisher: ApplicationEventPublisher\n\n fun setBlockedList(blockedList: List<String>) {\n this.blockedList = blockedList\n }\n\n override fun setApplicationEventPublisher(publisher: ApplicationEventPublisher) {\n this.publisher = publisher\n }\n\n fun sendEmail(address: String, content: String) {\n if (blockedList!!.contains(address)) {\n publisher!!.publishEvent(BlockedListEvent(this, address, content))\n return\n }\n // send email...\n }\n\t}\n----\n======\n\nAt configuration time, the Spring container detects that `EmailService` implements\n`ApplicationEventPublisherAware` and automatically calls\n`setApplicationEventPublisher()`. In reality, the parameter passed in is the Spring\ncontainer itself. You are interacting with the application context through its\n`ApplicationEventPublisher` interface.\n\nTo receive the custom `ApplicationEvent`, you can create a class that implements\n`ApplicationListener` and register it as a Spring bean. The following example\nshows such a class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class BlockedListNotifier implements ApplicationListener<BlockedListEvent> {\n\n private String notificationAddress;\n\n public void setNotificationAddress(String notificationAddress) {\n this.notificationAddress = notificationAddress;\n }\n\n public void onApplicationEvent(BlockedListEvent event) {\n // notify appropriate parties via notificationAddress...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass BlockedListNotifier : ApplicationListener<BlockedListEvent> {\n\n lateinit var notificationAddress: String\n\n override fun onApplicationEvent(event: BlockedListEvent) {\n // notify appropriate parties via notificationAddress...\n }\n\t}\n----\n======\n\nNotice that `ApplicationListener` is generically parameterized with the type of your custom event (`BlockedListEvent` in the preceding example).\nThis means that the `onApplicationEvent()` method can remain type-safe, avoiding any need for downcasting.\nYou can register as many event listeners as you wish, but note that, by default, event listeners receive events synchronously.\nThis means that the `publishEvent()` method blocks until all listeners have finished processing the event.\nOne advantage of this synchronous and single-threaded approach is that, when a listener receives an event,\nit operates inside the transaction context of the publisher if a transaction context is available.\nIf another strategy for event publication becomes necessary, for example, asynchronous event processing by default,\nsee the javadoc for Spring's {spring-framework-api}/context/event/ApplicationEventMulticaster.html[`ApplicationEventMulticaster`] interface\nand {spring-framework-api}/context/event/SimpleApplicationEventMulticaster.html[`SimpleApplicationEventMulticaster`] implementation\nfor configuration options which can be applied to a custom \"applicationEventMulticaster\" bean definition.\nIn these cases, ThreadLocals and logging context are not propagated for the event processing.\nSee xref:integration/observability.adoc#observability.application-events[the `@EventListener` Observability section]\nfor more information on Observability concerns.\n\nThe following example shows the bean definitions used to register and configure each of\nthe classes above:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"emailService\" class=\"example.EmailService\">\n <property name=\"blockedList\">\n <list>\n <value>known.spammer@example.org</value>\n <value>known.hacker@example.org</value>\n <value>john.doe@example.org</value>\n </list>\n </property>\n\t</bean>\n\n\t<bean id=\"blockedListNotifier\" class=\"example.BlockedListNotifier\">\n <property name=\"notificationAddress\" value=\"blockedlist@example.org\"/>\n\t</bean>\n\n\t<!-- optional: a custom ApplicationEventMulticaster definition -->\n\t<bean id=\"applicationEventMulticaster\" class=\"org.springframework.context.event.SimpleApplicationEventMulticaster\">\n <property name=\"taskExecutor\" ref=\"...\"/>\n <property name=\"errorHandler\" ref=\"...\"/>\n\t</bean>\n----\n\nPutting it all together, when the `sendEmail()` method of the `emailService` bean is\ncalled, if there are any email messages that should be blocked, a custom event of type\n`BlockedListEvent` is published. The `blockedListNotifier` bean is registered as an\n`ApplicationListener` and receives the `BlockedListEvent`, at which point it can\nnotify appropriate parties.\n\nNOTE: Spring's eventing mechanism is designed for simple communication between Spring beans\nwithin the same application context. However, for more sophisticated enterprise\nintegration needs, the separately maintained\n{spring-site-projects}/spring-integration/[Spring Integration] project provides\ncomplete support for building lightweight,\nhttps://www.enterpriseintegrationpatterns.com[pattern-oriented], event-driven\narchitectures that build upon the well-known Spring programming model.\n\n[[context-functionality-events-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc", "title": "context-introduction", "heading": "Standard and Custom Events", "heading_level": 2, "file_order": 56, "section_index": 2, "content_hash": "5a854cefc12e67e5f78276e78d81642112da1e89f5fb9a3dd9d4b9189851dc09", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc"}}
{"id": "sha256:bd51bd9e7b9cc5b948c9a046e6518df66fd19a19887f66fb297886ef9e840c15", "content": "You can register an event listener on any method of a managed bean by using the\n`@EventListener` annotation. The `BlockedListNotifier` can be rewritten as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class BlockedListNotifier {\n\n private String notificationAddress;\n\n public void setNotificationAddress(String notificationAddress) {\n this.notificationAddress = notificationAddress;\n }\n\n @EventListener\n public void processBlockedListEvent(BlockedListEvent event) {\n // notify appropriate parties via notificationAddress...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass BlockedListNotifier {\n\n lateinit var notificationAddress: String\n\n @EventListener\n fun processBlockedListEvent(event: BlockedListEvent) {\n // notify appropriate parties via notificationAddress...\n }\n\t}\n----\n======\n\nNOTE: Do not define such beans to be lazy as the `ApplicationContext` will honour that and will not register the method to listen to events.\n\nThe method signature once again declares the event type to which it listens,\nbut, this time, with a flexible name and without implementing a specific listener interface.\nThe event type can also be narrowed through generics as long as the actual event type\nresolves your generic parameter in its implementation hierarchy.\n\nIf your method should listen to several events or if you want to define it with no\nparameter at all, the event types can also be specified on the annotation itself. The\nfollowing example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})\n\tpublic void handleContextStart() {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@EventListener(ContextStartedEvent::class, ContextRefreshedEvent::class)\n\tfun handleContextStart() {\n // ...\n\t}\n----\n======\n\nIt is also possible to add additional runtime filtering by using the `condition` attribute\nof the annotation that defines a xref:core/expressions.adoc[`SpEL` expression], which should match\nto actually invoke the method for a particular event.\n\nThe following example shows how our notifier can be rewritten to be invoked only if the\n`content` attribute of the event is equal to `my-event`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@EventListener(condition = \"#blEvent.content == 'my-event'\")\n\tpublic void processBlockedListEvent(BlockedListEvent blEvent) {\n // notify appropriate parties via notificationAddress...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@EventListener(condition = \"#blEvent.content == 'my-event'\")\n\tfun processBlockedListEvent(blEvent: BlockedListEvent) {\n // notify appropriate parties via notificationAddress...\n\t}\n----\n======\n\nEach `SpEL` expression evaluates against a dedicated context. The following table lists the\nitems made available to the context so that you can use them for conditional event processing:\n\n[[context-functionality-events-annotation-tbl]]\n.Event metadata available in SpEL expressions\n|===\n| Name| Location| Description| Example\n\n| Event\n| root object\n| The actual `ApplicationEvent`.\n| `#root.event` or `event`\n\n| Arguments array\n| root object\n| The arguments (as an object array) used to invoke the method.\n| `#root.args` or `args`; `args[0]` to access the first argument, etc.\n\n| __Argument name__\n| evaluation context\n| The name of a particular method argument. If the names are not available\n (for example, because the code was compiled without the `-parameters` flag), individual\n arguments are also available using the `#a<#arg>` syntax where `<#arg>` stands for the\n argument index (starting from 0).\n| `#blEvent` or `#a0` (you can also use `#p0` or `#p<#arg>` parameter notation as an alias)\n|===\n\nNote that `#root.event` gives you access to the underlying event, even if your method\nsignature actually refers to an arbitrary object that was published.\n\nIf you need to publish an event as the result of processing another event, you can change the\nmethod signature to return the event that should be published, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@EventListener\n\tpublic ListUpdateEvent handleBlockedListEvent(BlockedListEvent event) {\n // notify appropriate parties via notificationAddress and\n // then publish a ListUpdateEvent...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@EventListener\n\tfun handleBlockedListEvent(event: BlockedListEvent): ListUpdateEvent {\n // notify appropriate parties via notificationAddress and\n // then publish a ListUpdateEvent...\n\t}\n----\n======\n\nNOTE: This feature is not supported for\nxref:core/beans/context-introduction.adoc#context-functionality-events-async[asynchronous listeners].\n\nThe `handleBlockedListEvent()` method publishes a new `ListUpdateEvent` for every\n`BlockedListEvent` that it handles. If you need to publish several events, you can return\na `Collection` or an array of events instead.\n\n[[context-functionality-events-async]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc", "title": "context-introduction", "heading": "Annotation-based Event Listeners", "heading_level": 3, "file_order": 56, "section_index": 3, "content_hash": "bd51bd9e7b9cc5b948c9a046e6518df66fd19a19887f66fb297886ef9e840c15", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc"}}
{"id": "sha256:2fd42deefce008d2201a56133ac3db8ff561da940138c252a48d3c4ed34c121e", "content": "If you want a particular listener to process events asynchronously, you can reuse the\nxref:integration/scheduling.adoc#scheduling-annotation-support-async[regular `@Async` support].\nThe following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@EventListener\n\t@Async\n\tpublic void processBlockedListEvent(BlockedListEvent event) {\n // BlockedListEvent is processed in a separate thread\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@EventListener\n\t@Async\n\tfun processBlockedListEvent(event: BlockedListEvent) {\n // BlockedListEvent is processed in a separate thread\n\t}\n----\n======\n\nBe aware of the following limitations when using asynchronous events:\n\n* If an asynchronous event listener throws an `Exception`, it is not propagated to the\n caller. See\n {spring-framework-api}/aop/interceptor/AsyncUncaughtExceptionHandler.html[`AsyncUncaughtExceptionHandler`]\n for more details.\n* Asynchronous event listener methods cannot publish a subsequent event by returning a\n value. If you need to publish another event as the result of the processing, inject an\n {spring-framework-api}/context/ApplicationEventPublisher.html[`ApplicationEventPublisher`]\n to publish the event manually.\n* ThreadLocals and logging context are not propagated by default for the event processing.\n See xref:integration/observability.adoc#observability.application-events[the `@EventListener` Observability section]\n for more information on Observability concerns.\n\n[[context-functionality-events-order]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc", "title": "context-introduction", "heading": "Asynchronous Listeners", "heading_level": 3, "file_order": 56, "section_index": 4, "content_hash": "2fd42deefce008d2201a56133ac3db8ff561da940138c252a48d3c4ed34c121e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc"}}
{"id": "sha256:258ccde984b1d554e851df8f8e14e7b842fd5886cdafc24e4ef9e4a0fcc132f0", "content": "If you need one listener to be invoked before another one, you can add the `@Order`\nannotation to the method declaration, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@EventListener\n\t@Order(42)\n\tpublic void processBlockedListEvent(BlockedListEvent event) {\n // notify appropriate parties via notificationAddress...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@EventListener\n\t@Order(42)\n\tfun processBlockedListEvent(event: BlockedListEvent) {\n // notify appropriate parties via notificationAddress...\n\t}\n----\n======\n\n[[context-functionality-events-generics]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc", "title": "context-introduction", "heading": "Ordering Listeners", "heading_level": 3, "file_order": 56, "section_index": 5, "content_hash": "258ccde984b1d554e851df8f8e14e7b842fd5886cdafc24e4ef9e4a0fcc132f0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc"}}
{"id": "sha256:7eab70d8ef1bf66e7d07160bb74d67d168deb942fbe25be492e998e1493d67f7", "content": "You can also use generics to further define the structure of your event. Consider using an\n`EntityCreatedEvent<T>` where `T` is the type of the actual entity that got created. For example, you\ncan create the following listener definition to receive only `EntityCreatedEvent` for a\n`Person`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@EventListener\n\tpublic void onPersonCreated(EntityCreatedEvent<Person> event) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@EventListener\n\tfun onPersonCreated(event: EntityCreatedEvent<Person>) {\n // ...\n\t}\n----\n======\n\nDue to type erasure, this works only if the event that is fired resolves the generic\nparameters on which the event listener filters (that is, something like\n`class PersonCreatedEvent extends EntityCreatedEvent<Person> { ... }`).\n\nIn certain circumstances, this may become quite tedious if all events follow the same\nstructure (as should be the case for the event in the preceding example). In such a case,\nyou can implement `ResolvableTypeProvider` to guide the framework beyond what the runtime\nenvironment provides. The following event shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class EntityCreatedEvent<T> extends ApplicationEvent implements ResolvableTypeProvider {\n\n public EntityCreatedEvent(T entity) {\n super(entity);\n }\n\n @Override\n public ResolvableType getResolvableType() {\n return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass EntityCreatedEvent<T>(entity: T) : ApplicationEvent(entity), ResolvableTypeProvider {\n\n override fun getResolvableType(): ResolvableType? {\n return ResolvableType.forClassWithGenerics(javaClass, ResolvableType.forInstance(getSource()))\n }\n\t}\n----\n======\n\nTIP: This works not only for `ApplicationEvent` but any arbitrary object that you send as\nan event.\n\nFinally, as with classic `ApplicationListener` implementations, the actual multicasting\nhappens via a context-wide `ApplicationEventMulticaster` at runtime. By default, this is a\n`SimpleApplicationEventMulticaster` with synchronous event publication in the caller thread.\nThis can be replaced/customized through an \"applicationEventMulticaster\" bean definition,\nfor example, for processing all events asynchronously and/or for handling listener exceptions:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tApplicationEventMulticaster applicationEventMulticaster() {\n SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster();\n multicaster.setTaskExecutor(...);\n multicaster.setErrorHandler(...);\n return multicaster;\n\t}\n----\n\n[[context-functionality-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc", "title": "context-introduction", "heading": "Generic Events", "heading_level": 3, "file_order": 56, "section_index": 6, "content_hash": "7eab70d8ef1bf66e7d07160bb74d67d168deb942fbe25be492e998e1493d67f7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc"}}
{"id": "sha256:9bdbbba80fa8320d2bd77afa3d9226a7db8de5b3a6b17ff76827428a74b77930", "content": "For optimal usage and understanding of application contexts, you should familiarize\nyourself with Spring's `Resource` abstraction, as described in\nxref:core/resources.adoc[Resources].\n\nAn application context is a `ResourceLoader`, which can be used to load `Resource` objects.\nA `Resource` is essentially a more feature rich version of the JDK `java.net.URL` class.\nIn fact, implementations of `Resource` wrap an instance of `java.net.URL`, where\nappropriate. A `Resource` can obtain low-level resources from almost any location in a\ntransparent fashion, including from the classpath, a filesystem location, anywhere\ndescribable with a standard URL, and some other variations. If the resource location\nstring is a simple path without any special prefixes, where those resources come from is\nspecific and appropriate to the actual application context type.\n\nYou can configure a bean deployed into the application context to implement the special\ncallback interface, `ResourceLoaderAware`, to be automatically called back at\ninitialization time with the application context itself passed in as the `ResourceLoader`.\nYou can also expose properties of type `Resource`, to be used to access static resources.\nThey are injected into it like any other properties. You can specify those `Resource`\nproperties as simple `String` paths and rely on automatic conversion from those text\nstrings to actual `Resource` objects when the bean is deployed.\n\nThe location path or paths supplied to an `ApplicationContext` constructor are actually\nresource strings and, in simple form, are treated appropriately according to the specific\ncontext implementation. For example `ClassPathXmlApplicationContext` treats a simple\nlocation path as a classpath location. You can also use location paths (resource strings)\nwith special prefixes to force loading of definitions from the classpath or a URL,\nregardless of the actual context type.\n\n[[context-functionality-startup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc", "title": "context-introduction", "heading": "Convenient Access to Low-level Resources", "heading_level": 2, "file_order": 56, "section_index": 7, "content_hash": "9bdbbba80fa8320d2bd77afa3d9226a7db8de5b3a6b17ff76827428a74b77930", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc"}}
{"id": "sha256:8afd20af3143b70da3e49b3f48541fed797133e307c1f063453dd31b64f95672", "content": "The `ApplicationContext` manages the lifecycle of Spring applications and provides a rich\nprogramming model around components. As a result, complex applications can have equally\ncomplex component graphs and startup phases.\n\nTracking the application startup steps with specific metrics can help understand where\ntime is being spent during the startup phase, but it can also be used as a way to better\nunderstand the context lifecycle as a whole.\n\nThe `AbstractApplicationContext` (and its subclasses) is instrumented with an\n`ApplicationStartup`, which collects `StartupStep` data about various startup phases:\n\n* application context lifecycle (base packages scanning, config classes management)\n* beans lifecycle (instantiation, smart initialization, post processing)\n* application events processing\n\nHere is an example of instrumentation in the `AnnotationConfigApplicationContext`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// create a startup step and start recording\n\ttry (StartupStep scanPackages = getApplicationStartup().start(\"spring.context.base-packages.scan\")) {\n // add tagging information to the current step\n scanPackages.tag(\"packages\", () -> Arrays.toString(basePackages));\n // perform the actual phase we're instrumenting\n this.scanner.scan(basePackages);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// create a startup step and start recording\n\ttry (val scanPackages = getApplicationStartup().start(\"spring.context.base-packages.scan\")) {\n // add tagging information to the current step\n scanPackages.tag(\"packages\", () -> Arrays.toString(basePackages));\n // perform the actual phase we're instrumenting\n this.scanner.scan(basePackages);\n\t}\n----\n======\n\nThe application context is already instrumented with multiple steps.\nOnce recorded, these startup steps can be collected, displayed and analyzed with specific tools.\nFor a complete list of existing startup steps, you can check out the\nxref:core/appendix/application-startup-steps.adoc[dedicated appendix section].\n\nThe default `ApplicationStartup` implementation is a no-op variant, for minimal overhead.\nThis means no metrics will be collected during application startup by default.\nSpring Framework ships with an implementation for tracking startup steps with Java Flight Recorder:\n`FlightRecorderApplicationStartup`. To use this variant, you must configure an instance of it\nto the `ApplicationContext` as soon as it's been created.\n\nDevelopers can also use the `ApplicationStartup` infrastructure if they're providing their own\n`AbstractApplicationContext` subclass, or if they wish to collect more precise data.\n\nWARNING: `ApplicationStartup` is meant to be only used during application startup and for\nthe core container; this is by no means a replacement for Java profilers or\nmetrics libraries like https://micrometer.io[Micrometer].\n\nTo start collecting custom `StartupStep`, components can either get the `ApplicationStartup`\ninstance from the application context directly, make their component implement `ApplicationStartupAware`,\nor ask for the `ApplicationStartup` type on any injection point.\n\nNOTE: Developers should not use the `\"spring.*\"` namespace when creating custom startup steps.\nThis namespace is reserved for internal Spring usage and is subject to change.\n\n[[context-create]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc", "title": "context-introduction", "heading": "Application Startup Tracking", "heading_level": 2, "file_order": 56, "section_index": 8, "content_hash": "8afd20af3143b70da3e49b3f48541fed797133e307c1f063453dd31b64f95672", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc"}}
{"id": "sha256:c3aed4bd4018c1e82ede05d6703e1c14f577bbb6ee122e72b59a28a9c0f09a08", "content": "You can create `ApplicationContext` instances declaratively by using, for example, a\n`ContextLoader`. Of course, you can also create `ApplicationContext` instances\nprogrammatically by using one of the `ApplicationContext` implementations.\n\nYou can register an `ApplicationContext` by using the `ContextLoaderListener`, as the\nfollowing example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<context-param>\n <param-name>contextConfigLocation</param-name>\n <param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value>\n\t</context-param>\n\n\t<listener>\n <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n\t</listener>\n----\n\nThe listener inspects the `contextConfigLocation` parameter. If the parameter does not\nexist, the listener uses `/WEB-INF/applicationContext.xml` as a default. When the\nparameter does exist, the listener separates the `String` by using predefined\ndelimiters (comma, semicolon, and whitespace) and uses the values as locations where\napplication contexts are searched. Ant-style path patterns are supported as well.\nExamples are `/WEB-INF/{asterisk}Context.xml` (for all files with names that end with\n`Context.xml` and that reside in the `WEB-INF` directory) and `/WEB-INF/**/*Context.xml`\n(for all such files in any subdirectory of `WEB-INF`).\n\n[[context-deploy-rar]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc", "title": "context-introduction", "heading": "Convenient ApplicationContext Instantiation for Web Applications", "heading_level": 2, "file_order": 56, "section_index": 9, "content_hash": "c3aed4bd4018c1e82ede05d6703e1c14f577bbb6ee122e72b59a28a9c0f09a08", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc"}}
{"id": "sha256:0dd5772dceb04280cccbbe5e76934aa954ad1501857dd43c14ab78f2e5d601a0", "content": "It is possible to deploy a Spring `ApplicationContext` as a RAR file, encapsulating the\ncontext and all of its required bean classes and library JARs in a Jakarta EE RAR deployment\nunit. This is the equivalent of bootstrapping a stand-alone `ApplicationContext` (only hosted\nin Jakarta EE environment) being able to access the Jakarta EE servers facilities. RAR deployment\nis a more natural alternative to a scenario of deploying a headless WAR file -- in effect,\na WAR file without any HTTP entry points that is used only for bootstrapping a Spring\n`ApplicationContext` in a Jakarta EE environment.\n\nRAR deployment is ideal for application contexts that do not need HTTP entry points but\nrather consist only of message endpoints and scheduled jobs. Beans in such a context can\nuse application server resources such as the JTA transaction manager and JNDI-bound JDBC\n`DataSource` instances and JMS `ConnectionFactory` instances and can also register with\nthe platform's JMX server -- all through Spring's standard transaction management and JNDI\nand JMX support facilities. Application components can also interact with the application\nserver's JCA `WorkManager` through Spring's `TaskExecutor` abstraction.\n\nSee the javadoc of the\n{spring-framework-api}/jca/context/SpringContextResourceAdapter.html[`SpringContextResourceAdapter`]\nclass for the configuration details involved in RAR deployment.\n\nFor a simple deployment of a Spring ApplicationContext as a Jakarta EE RAR file:\n\n. Package\nall application classes into a RAR file (which is a standard JAR file with a different\nfile extension).\n. Add all required library JARs into the root of the RAR archive.\n. Add a\n`META-INF/ra.xml` deployment descriptor (as shown in the\n{spring-framework-api}/jca/context/SpringContextResourceAdapter.html[javadoc for `SpringContextResourceAdapter`])\nand the corresponding Spring XML bean definition file(s) (typically\n`META-INF/applicationContext.xml`).\n. Drop the resulting RAR file into your\napplication server's deployment directory.\n\nNOTE: Such RAR deployment units are usually self-contained. They do not expose components\nto the outside world, not even to other modules of the same application. Interaction with a\nRAR-based `ApplicationContext` usually occurs through JMS destinations that it shares with\nother modules. A RAR-based `ApplicationContext` may also, for example, schedule some jobs\nor react to new files in the file system (or the like). If it needs to allow synchronous\naccess from the outside, it could (for example) export RMI endpoints, which may be used\nby other application modules on the same machine.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc", "title": "context-introduction", "heading": "Deploying a Spring `ApplicationContext` as a Jakarta EE RAR File", "heading_level": 2, "file_order": 56, "section_index": 10, "content_hash": "0dd5772dceb04280cccbbe5e76934aa954ad1501857dd43c14ab78f2e5d601a0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/context-introduction.adoc"}}
{"id": "sha256:953ba4dee04e3959bcee3f87dc0fb251c9f0c496914a8b7179da9bfc43583d47", "content": "[[context-load-time-weaver]]\n\nThe `LoadTimeWeaver` is used by Spring to dynamically transform classes as they are\nloaded into the Java virtual machine (JVM).\n\nTo enable load-time weaving, you can add the `@EnableLoadTimeWeaving` to one of your\n`@Configuration` classes, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@EnableLoadTimeWeaving\n\tpublic class AppConfig {\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@EnableLoadTimeWeaving\n\tclass AppConfig\n----\n======\n\nAlternatively, for XML configuration, you can use the `context:load-time-weaver` element:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <context:load-time-weaver/>\n\t</beans>\n----\n\nOnce configured for the `ApplicationContext`, any bean within that `ApplicationContext`\nmay implement `LoadTimeWeaverAware`, thereby receiving a reference to the load-time\nweaver instance. This is particularly useful in combination with\nxref:data-access/orm/jpa.adoc[Spring's JPA support] where load-time weaving may be\nnecessary for JPA class transformation.\nConsult the\n{spring-framework-api}/orm/jpa/LocalContainerEntityManagerFactoryBean.html[`LocalContainerEntityManagerFactoryBean`]\njavadoc for more detail. For more on AspectJ load-time weaving, see\nxref:core/aop/using-aspectj.adoc#aop-aj-ltw[Load-time Weaving with AspectJ in the Spring Framework].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/context-load-time-weaver.adoc", "title": "context-load-time-weaver", "heading": "context-load-time-weaver", "heading_level": 1, "file_order": 57, "section_index": 0, "content_hash": "953ba4dee04e3959bcee3f87dc0fb251c9f0c496914a8b7179da9bfc43583d47", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/context-load-time-weaver.adoc"}}
{"id": "sha256:91609f31cd2c967e47dbc8a45c6d0e35631c296dc1a41c1ce99886254450c4c6", "content": "[[beans-definition]]\n\nA Spring IoC container manages one or more beans. These beans are created with the\nconfiguration metadata that you supply to the container (for example, in the form of XML\n`<bean/>` definitions).\n\nWithin the container itself, these bean definitions are represented as `BeanDefinition`\nobjects, which contain (among other information) the following metadata:\n\n* A package-qualified class name: typically, the actual implementation class of the\n bean being defined.\n* Bean behavioral configuration elements, which state how the bean should behave in the\n container (scope, lifecycle callbacks, and so forth).\n* References to other beans that are needed for the bean to do its work. These\n references are also called collaborators or dependencies.\n* Other configuration settings to set in the newly created object -- for example, the size\n limit of the pool or the number of connections to use in a bean that manages a\n connection pool.\n\nThis metadata translates to a set of properties that make up each bean definition.\nThe following table describes these properties:\n\n[[beans-factory-bean-definition-tbl]]\n.The bean definition\n|===\n| Property| Explained in...\n\n| Class\n| xref:core/beans/definition.adoc#beans-factory-class[Instantiating Beans]\n\n| Name\n| xref:core/beans/definition.adoc#beans-beanname[Naming Beans]\n\n| Scope\n| xref:core/beans/factory-scopes.adoc[Bean Scopes]\n\n| Constructor arguments\n| xref:core/beans/dependencies/factory-collaborators.adoc[Dependency Injection]\n\n| Properties\n| xref:core/beans/dependencies/factory-collaborators.adoc[Dependency Injection]\n\n| Autowiring mode\n| xref:core/beans/dependencies/factory-autowire.adoc[Autowiring Collaborators]\n\n| Lazy initialization mode\n| xref:core/beans/dependencies/factory-lazy-init.adoc[Lazy-initialized Beans]\n\n| Initialization method\n| xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-initializingbean[Initialization Callbacks]\n\n| Destruction method\n| xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-disposablebean[Destruction Callbacks]\n|===\n\nIn addition to bean definitions that contain information on how to create a specific\nbean, the `ApplicationContext` implementations also permit the registration of existing\nobjects that are created outside the container (by users). This is done by accessing the\nApplicationContext's `BeanFactory` through the `getAutowireCapableBeanFactory()` method,\nwhich returns the `DefaultListableBeanFactory` implementation. `DefaultListableBeanFactory`\nsupports this registration through the `registerSingleton(..)` and `registerBeanDefinition(..)`\nmethods. However, typical applications work solely with beans defined through regular\nbean definition metadata.\n\n[NOTE]\n====\nBean metadata and manually supplied singleton instances need to be registered as early\nas possible, in order for the container to properly reason about them during autowiring\nand other introspection steps. While overriding existing metadata and existing\nsingleton instances is supported to some degree, the registration of new beans at\nruntime (concurrently with live access to the factory) is not officially supported and may\nlead to concurrent access exceptions, inconsistent state in the bean container, or both.\n====\n\n[[beans-definition-overriding]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/definition.adoc", "title": "definition", "heading": "definition", "heading_level": 1, "file_order": 58, "section_index": 0, "content_hash": "91609f31cd2c967e47dbc8a45c6d0e35631c296dc1a41c1ce99886254450c4c6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/definition.adoc"}}
{"id": "sha256:b12d54a1d349b5a6f0993c88914334a1f47e44103a02bb4be7909fdc29feb81b", "content": "Bean overriding occurs when a bean is registered using an identifier that is already\nallocated. While bean overriding is possible, it makes the configuration harder to read.\n\nWARNING: Bean overriding will be deprecated in a future release.\n\nTo disable bean overriding altogether, you can set the `allowBeanDefinitionOverriding`\nflag to `false` on the `ApplicationContext` before it is refreshed. In such a setup, an\nexception is thrown if bean overriding is used.\n\nBy default, the container logs every attempt to override a bean at `INFO` level so that\nyou can adapt your configuration accordingly. While not recommended, you can silence\nthose logs by setting the `allowBeanDefinitionOverriding` flag to `true`.\n\n.Java Configuration\n****\nIf you use Java Configuration, a corresponding `@Bean` method always silently overrides\na scanned bean class with the same component name as long as the return type of the\n`@Bean` method matches that bean class. This simply means that the container will call\nthe `@Bean` factory method in favor of any pre-declared constructor on the bean class.\n****\n\nNOTE: We acknowledge that overriding beans in test scenarios is convenient, and there is\nexplicit support for this. Please refer to\nxref:testing/testcontext-framework/bean-overriding.adoc[this section] for more details.\n\n[[beans-beanname]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/definition.adoc", "title": "definition", "heading": "Overriding Beans", "heading_level": 2, "file_order": 58, "section_index": 1, "content_hash": "b12d54a1d349b5a6f0993c88914334a1f47e44103a02bb4be7909fdc29feb81b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/definition.adoc"}}
{"id": "sha256:82183405dfa509304ecff59b184076a4d689c48f4228f84c9e7d5a3a0a670b71", "content": "Every bean has one or more identifiers. These identifiers must be unique within the\ncontainer that hosts the bean. A bean usually has only one identifier. However, if it\nrequires more than one, the extra ones can be considered aliases.\n\nIn XML-based configuration metadata, you use the `id` attribute, the `name` attribute, or\nboth to specify bean identifiers. The `id` attribute lets you specify exactly one `id`.\nConventionally, these names are alphanumeric ('myBean', 'someService', etc.), but they\ncan contain special characters as well. If you want to introduce other aliases for the\nbean, you can also specify them in the `name` attribute, separated by a comma (`,`),\nsemicolon (`;`), or white space. Although the `id` attribute is defined as an\n`xsd:string` type, bean `id` uniqueness is enforced by the container, though not by XML\nparsers.\n\nYou are not required to supply a `name` or an `id` for a bean. If you do not supply a\n`name` or `id` explicitly, the container generates a unique name for that bean. However,\nif you want to refer to that bean by name, through the use of the `ref` element or a\nService Locator style lookup, you must provide a name.\nMotivations for not supplying a name are related to using xref:core/beans/dependencies/factory-properties-detailed.adoc#beans-inner-beans[inner beans]\n and xref:core/beans/dependencies/factory-autowire.adoc[autowiring collaborators].\n\n.Bean Naming Conventions\n****\nThe convention is to use the standard Java convention for instance field names when\nnaming beans. That is, bean names start with a lowercase letter and are camel-cased\nfrom there. Examples of such names include `accountManager`,\n`accountService`, `userDao`, `loginController`, and so forth.\n\nNaming beans consistently makes your configuration easier to read and understand.\nAlso, if you use Spring AOP, it helps a lot when applying advice to a set of beans\nrelated by name.\n****\n\nNOTE: With component scanning in the classpath, Spring generates bean names for unnamed\ncomponents, following the rules described earlier: essentially, taking the simple class name\nand turning its initial character to lower-case. However, in the (unusual) special\ncase when there is more than one character and both the first and second characters\nare upper case, the original casing gets preserved. These are the same rules as\ndefined by `java.beans.Introspector.decapitalize` (which Spring uses here).\n\n[[beans-beanname-alias]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/definition.adoc", "title": "definition", "heading": "Naming Beans", "heading_level": 2, "file_order": 58, "section_index": 2, "content_hash": "82183405dfa509304ecff59b184076a4d689c48f4228f84c9e7d5a3a0a670b71", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/definition.adoc"}}
{"id": "sha256:159d4ea5085bcead04b02727620012f64c9382205d391beeee967e0b3b2b464b", "content": "In a bean definition itself, you can supply more than one name for the bean, by using a\ncombination of up to one name specified by the `id` attribute and any number of other\nnames in the `name` attribute. These names can be equivalent aliases to the same bean\nand are useful for some situations, such as letting each component in an application\nrefer to a common dependency by using a bean name that is specific to that component\nitself.\n\nSpecifying all aliases where the bean is actually defined is not always adequate,\nhowever. It is sometimes desirable to introduce an alias for a bean that is defined\nelsewhere. This is commonly the case in large systems where configuration is split\namongst each subsystem, with each subsystem having its own set of object definitions.\nIn XML-based configuration metadata, you can use the `<alias/>` element to accomplish\nthis. The following example shows how to do so:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<alias name=\"fromName\" alias=\"toName\"/>\n----\n\nIn this case, a bean (in the same container) named `fromName` may also,\nafter the use of this alias definition, be referred to as `toName`.\n\nFor example, the configuration metadata for subsystem A may refer to a DataSource by the\nname of `subsystemA-dataSource`. The configuration metadata for subsystem B may refer to\na DataSource by the name of `subsystemB-dataSource`. When composing the main application\nthat uses both these subsystems, the main application refers to the DataSource by the\nname of `myApp-dataSource`. To have all three names refer to the same object, you can\nadd the following alias definitions to the configuration metadata:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<alias name=\"myApp-dataSource\" alias=\"subsystemA-dataSource\"/>\n\t<alias name=\"myApp-dataSource\" alias=\"subsystemB-dataSource\"/>\n----\n\nNow each component and the main application can refer to the dataSource through a name\nthat is unique and guaranteed not to clash with any other definition (effectively\ncreating a namespace), yet they refer to the same bean.\n\n.Java-configuration\n****\nIf you use Java Configuration, the `@Bean` annotation can be used to provide aliases.\nSee xref:core/beans/java/bean-annotation.adoc[Using the `@Bean` Annotation] for details.\n****\n\n[[beans-factory-class]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/definition.adoc", "title": "definition", "heading": "Aliasing a Bean outside the Bean Definition", "heading_level": 3, "file_order": 58, "section_index": 3, "content_hash": "159d4ea5085bcead04b02727620012f64c9382205d391beeee967e0b3b2b464b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/definition.adoc"}}
{"id": "sha256:b86e35b872f030e9ee4d4efed31e564e629427eece9a59466cbf13e742b9c0fa", "content": "A bean definition is essentially a recipe for creating one or more objects. The\ncontainer looks at the recipe for a named bean when asked and uses the configuration\nmetadata encapsulated by that bean definition to create (or acquire) an actual object.\n\nIf you use XML-based configuration metadata, you specify the type (or class) of object\nthat is to be instantiated in the `class` attribute of the `<bean/>` element. This\n`class` attribute (which, internally, is a `Class` property on a `BeanDefinition`\ninstance) is usually mandatory. (For exceptions, see\nxref:core/beans/definition.adoc#beans-factory-class-instance-factory-method[Instantiation by Using an Instance Factory Method]\nand xref:core/beans/child-bean-definitions.adoc[Bean Definition Inheritance].)\nYou can use the `Class` property in one of two ways:\n\n* Typically, to specify the bean class to be constructed in the case where the container\n itself directly creates the bean by calling its constructor reflectively, somewhat\n equivalent to Java code with the `new` operator.\n* To specify the actual class containing the `static` factory method that is\n invoked to create the object, in the less common case where the container invokes a\n `static` factory method on a class to create the bean. The object type returned\n from the invocation of the `static` factory method may be the same class or another\n class entirely.\n\n.Nested class names\n****\nIf you want to configure a bean definition for a nested class, you may use either the\nbinary name or the source name of the nested class.\n\nFor example, if you have a class called `SomeThing` in the `com.example` package, and\nthis `SomeThing` class has a `static` nested class called `OtherThing`, they can be\nseparated by a dollar sign (`$`) or a dot (`.`). So the value of the `class` attribute in\na bean definition would be `com.example.SomeThing$OtherThing` or\n`com.example.SomeThing.OtherThing`.\n****\n\n[[beans-factory-class-ctor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/definition.adoc", "title": "definition", "heading": "Instantiating Beans", "heading_level": 2, "file_order": 58, "section_index": 4, "content_hash": "b86e35b872f030e9ee4d4efed31e564e629427eece9a59466cbf13e742b9c0fa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/definition.adoc"}}
{"id": "sha256:78671e60418aeaf34ae84c1cfe9c39437b835e50aca91300ecd6936bfe1a6870", "content": "When you create a bean by the constructor approach, all normal classes are usable by and\ncompatible with Spring. That is, the class being developed does not need to implement\nany specific interfaces or to be coded in a specific fashion. Simply specifying the bean\nclass should suffice. However, depending on what type of IoC you use for that specific\nbean, you may need a default (empty) constructor.\n\nThe Spring IoC container can manage virtually any class you want it to manage. It is\nnot limited to managing true JavaBeans. Most Spring users prefer actual JavaBeans with\nonly a default (no-argument) constructor and appropriate setters and getters modeled\nafter the properties in the container. You can also have more exotic non-bean-style\nclasses in your container. If, for example, you need to use a legacy connection pool\nthat absolutely does not adhere to the JavaBean specification, Spring can manage it as\nwell.\n\nWith XML-based configuration metadata you can specify your bean class as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exampleBean\" class=\"examples.ExampleBean\"/>\n\n\t<bean name=\"anotherExample\" class=\"examples.ExampleBeanTwo\"/>\n----\n\nFor details about the mechanism for supplying arguments to the constructor (if required)\nand setting object instance properties after the object is constructed, see\nxref:core/beans/dependencies/factory-collaborators.adoc[Injecting Dependencies].\n\nNOTE: In the case of constructor arguments, the container can select a corresponding\nconstructor among several overloaded constructors. That said, to avoid ambiguities,\nit is recommended to keep your constructor signatures as straightforward as possible.\n\n[[beans-factory-class-static-factory-method]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/definition.adoc", "title": "definition", "heading": "Instantiation with a Constructor", "heading_level": 3, "file_order": 58, "section_index": 5, "content_hash": "78671e60418aeaf34ae84c1cfe9c39437b835e50aca91300ecd6936bfe1a6870", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/definition.adoc"}}
{"id": "sha256:26809a564ea30882757ecd5dd3bed308e4fe34bab44d15f17a029521b03a632c", "content": "When defining a bean that you create with a static factory method, use the `class`\nattribute to specify the class that contains the `static` factory method and an attribute\nnamed `factory-method` to specify the name of the factory method itself. You should be\nable to call this method (with optional arguments, as described later) and return a live\nobject, which subsequently is treated as if it had been created through a constructor.\nOne use for such a bean definition is to call `static` factories in legacy code.\n\nThe following bean definition specifies that the bean will be created by calling a\nfactory method. The definition does not specify the type (class) of the returned object,\nbut rather the class containing the factory method. In this example, the\n`createInstance()` method must be a `static` method. The following example shows how to\nspecify a factory method:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"clientService\"\n class=\"examples.ClientService\"\n factory-method=\"createInstance\"/>\n----\n\nThe following example shows a class that would work with the preceding bean definition:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ClientService {\n private static ClientService clientService = new ClientService();\n private ClientService() {}\n\n public static ClientService createInstance() {\n return clientService;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ClientService private constructor() {\n companion object {\n private val clientService = ClientService()\n @JvmStatic\n fun createInstance() = clientService\n }\n\t}\n----\n======\n\nFor details about the mechanism for supplying (optional) arguments to the factory method\nand setting object instance properties after the object is returned from the factory,\nsee xref:core/beans/dependencies/factory-properties-detailed.adoc[Dependencies and Configuration in Detail].\n\nNOTE: In the case of factory method arguments, the container can select a corresponding\nmethod among several overloaded methods of the same name. That said, to avoid ambiguities,\nit is recommended to keep your factory method signatures as straightforward as possible.\n\n[TIP]\n====\nA typical problematic case with factory method overloading is Mockito with its many\noverloads of the `mock` method. Choose the most specific variant of `mock` possible:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"clientService\" class=\"org.mockito.Mockito\" factory-method=\"mock\">\n <constructor-arg type=\"java.lang.Class\" value=\"examples.ClientService\"/>\n <constructor-arg type=\"java.lang.String\" value=\"clientService\"/>\n\t</bean>\n----\n====\n\n[[beans-factory-class-instance-factory-method]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/definition.adoc", "title": "definition", "heading": "Instantiation with a Static Factory Method", "heading_level": 3, "file_order": 58, "section_index": 6, "content_hash": "26809a564ea30882757ecd5dd3bed308e4fe34bab44d15f17a029521b03a632c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/definition.adoc"}}
{"id": "sha256:7f1e6293e343c5d437c902a9b8f56ca49eb047f7c6ac489f34f0f896970a23c7", "content": "Similar to instantiation through a xref:core/beans/definition.adoc#beans-factory-class-static-factory-method[static factory method]\n, instantiation with an instance factory method invokes a non-static\nmethod of an existing bean from the container to create a new bean. To use this\nmechanism, leave the `class` attribute empty and, in the `factory-bean` attribute,\nspecify the name of a bean in the current (or parent or ancestor) container that contains\nthe instance method that is to be invoked to create the object. Set the name of the\nfactory method itself with the `factory-method` attribute. The following example shows\nhow to configure such a bean:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- the factory bean, which contains a method called createClientServiceInstance() -->\n\t<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n <!-- inject any dependencies required by this locator bean -->\n\t</bean>\n\n\t<!-- the bean to be created via the factory bean -->\n\t<bean id=\"clientService\"\n factory-bean=\"serviceLocator\"\n factory-method=\"createClientServiceInstance\"/>\n----\n\nThe following example shows the corresponding class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class DefaultServiceLocator {\n\n private static ClientService clientService = new ClientServiceImpl();\n\n public ClientService createClientServiceInstance() {\n return clientService;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass DefaultServiceLocator {\n companion object {\n private val clientService = ClientServiceImpl()\n }\n fun createClientServiceInstance(): ClientService {\n return clientService\n }\n\t}\n----\n======\n\nOne factory class can also hold more than one factory method, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n <!-- inject any dependencies required by this locator bean -->\n\t</bean>\n\n\t<bean id=\"clientService\"\n factory-bean=\"serviceLocator\"\n factory-method=\"createClientServiceInstance\"/>\n\n\t<bean id=\"accountService\"\n factory-bean=\"serviceLocator\"\n factory-method=\"createAccountServiceInstance\"/>\n----\n\nThe following example shows the corresponding class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class DefaultServiceLocator {\n\n private static ClientService clientService = new ClientServiceImpl();\n\n private static AccountService accountService = new AccountServiceImpl();\n\n public ClientService createClientServiceInstance() {\n return clientService;\n }\n\n public AccountService createAccountServiceInstance() {\n return accountService;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass DefaultServiceLocator {\n companion object {\n private val clientService = ClientServiceImpl()\n private val accountService = AccountServiceImpl()\n }\n\n fun createClientServiceInstance(): ClientService {\n return clientService\n }\n\n fun createAccountServiceInstance(): AccountService {\n return accountService\n }\n\t}\n----\n======\n\nThis approach shows that the factory bean itself can be managed and configured through\ndependency injection (DI).\nSee xref:core/beans/dependencies/factory-properties-detailed.adoc[Dependencies and Configuration in Detail].\n\nNOTE: In Spring documentation, \"factory bean\" refers to a bean that is configured in the\nSpring container and that creates objects through an\nxref:core/beans/definition.adoc#beans-factory-class-instance-factory-method[instance] or\nxref:core/beans/definition.adoc#beans-factory-class-static-factory-method[static] factory method. By contrast,\n`FactoryBean` (notice the capitalization) refers to a Spring-specific\nxref:core/beans/factory-extension.adoc#beans-factory-extension-factorybean[`FactoryBean`] implementation class.\n\n[[beans-factory-type-determination]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/definition.adoc", "title": "definition", "heading": "Instantiation by Using an Instance Factory Method", "heading_level": 3, "file_order": 58, "section_index": 7, "content_hash": "7f1e6293e343c5d437c902a9b8f56ca49eb047f7c6ac489f34f0f896970a23c7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/definition.adoc"}}
{"id": "sha256:cab8719c40a5e12923901d84d05ca67edff54d4817da9fbf69f27bd2ceeeff74", "content": "The runtime type of a specific bean is non-trivial to determine. A specified class in\nthe bean metadata definition is just an initial class reference, potentially combined\nwith a declared factory method or being a `FactoryBean` class which may lead to a\ndifferent runtime type of the bean, or not being set at all in case of an instance-level\nfactory method (which is resolved via the specified `factory-bean` name instead).\nAdditionally, AOP proxying may wrap a bean instance with an interface-based proxy with\nlimited exposure of the target bean's actual type (just its implemented interfaces).\n\nThe recommended way to find out about the actual runtime type of a particular bean is\na `BeanFactory.getType` call for the specified bean name. This takes all of the above\ncases into account and returns the type of object that a `BeanFactory.getBean` call is\ngoing to return for the same bean name.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/definition.adoc", "title": "definition", "heading": "Determining a Bean's Runtime Type", "heading_level": 3, "file_order": 58, "section_index": 8, "content_hash": "cab8719c40a5e12923901d84d05ca67edff54d4817da9fbf69f27bd2ceeeff74", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/definition.adoc"}}
{"id": "sha256:824955b6b50da5f8a4781ff630972292f39111c6eff24b74d1b5b03bd076d8a0", "content": "[[beans-dependencies]]\n\nA typical enterprise application does not consist of a single object (or bean in the\nSpring parlance). Even the simplest application has a few objects that work together to\npresent what the end-user sees as a coherent application. This next section explains how\nyou go from defining a number of bean definitions that stand alone to a fully realized\napplication where objects collaborate to achieve a goal.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/dependencies.adoc", "title": "dependencies", "heading": "dependencies", "heading_level": 1, "file_order": 59, "section_index": 0, "content_hash": "824955b6b50da5f8a4781ff630972292f39111c6eff24b74d1b5b03bd076d8a0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/dependencies.adoc"}}
{"id": "sha256:ffdc231259d40c197874a43835a642350a62a78438c656a19da54fa68bbd6165", "content": "[[beans-environment]]\n\nThe {spring-framework-api}/core/env/Environment.html[`Environment`] interface\nis an abstraction integrated in the container that models two key\naspects of the application environment: xref:core/beans/environment.adoc#beans-definition-profiles[profiles]\nand xref:core/beans/environment.adoc#beans-property-source-abstraction[properties].\n\nA profile is a named, logical group of bean definitions to be registered with the\ncontainer only if the given profile is active. Beans may be assigned to a profile\nwhether defined in XML or with annotations. The role of the `Environment` object with\nrelation to profiles is in determining which profiles (if any) are currently active,\nand which profiles (if any) should be active by default.\n\nProperties play an important role in almost all applications and may originate from\na variety of sources: properties files, JVM system properties, system environment\nvariables, JNDI, servlet context parameters, ad-hoc `Properties` objects, `Map` objects, and so\non. The role of the `Environment` object with relation to properties is to provide the\nuser with a convenient service interface for configuring property sources and resolving\nproperties from them.\n\n[[beans-definition-profiles]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/environment.adoc", "title": "environment", "heading": "environment", "heading_level": 1, "file_order": 60, "section_index": 0, "content_hash": "ffdc231259d40c197874a43835a642350a62a78438c656a19da54fa68bbd6165", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/environment.adoc"}}
{"id": "sha256:c3b67a58c8d08e8d2f29fab3f16fddd605b56540d336fbc1fc7cff22ae5e71a5", "content": "Bean definition profiles provide a mechanism in the core container that allows for\nregistration of different beans in different environments. The word, \"`environment,`\"\ncan mean different things to different users, and this feature can help with many\nuse cases, including:\n\n* Working against an in-memory datasource in development versus looking up that same\ndatasource from JNDI when in QA or production.\n* Registering monitoring infrastructure only when deploying an application into a\nperformance environment.\n* Registering customized implementations of beans for customer A versus customer\nB deployments.\n\nConsider the first use case in a practical application that requires a\n`DataSource`. In a test environment, the configuration might resemble the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tpublic DataSource dataSource() {\n return new EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.HSQL)\n .addScript(\"my-schema.sql\")\n .addScript(\"my-test-data.sql\")\n .build();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tfun dataSource(): DataSource {\n return EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.HSQL)\n .addScript(\"my-schema.sql\")\n .addScript(\"my-test-data.sql\")\n .build()\n\t}\n----\n======\n\nNow consider how this application can be deployed into a QA or production\nenvironment, assuming that the datasource for the application is registered\nwith the production application server's JNDI directory. Our `dataSource` bean\nnow looks like the following listing:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean(destroyMethod = \"\")\n\tpublic DataSource dataSource() throws Exception {\n Context ctx = new InitialContext();\n return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\");\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean(destroyMethod = \"\")\n\tfun dataSource(): DataSource {\n val ctx = InitialContext()\n return ctx.lookup(\"java:comp/env/jdbc/datasource\") as DataSource\n\t}\n----\n======\n\nThe problem is how to switch between using these two variations based on the\ncurrent environment. Over time, Spring users have devised a number of ways to\nget this done, usually relying on a combination of system environment variables\nand XML `<import/>` statements containing pass:q[`${placeholder}`] tokens that resolve\nto the correct configuration file path depending on the value of an environment\nvariable. Bean definition profiles is a core container feature that provides a\nsolution to this problem.\n\nIf we generalize the use case shown in the preceding example of environment-specific bean\ndefinitions, we end up with the need to register certain bean definitions in\ncertain contexts but not in others. You could say that you want to register a\ncertain profile of bean definitions in situation A and a different profile in\nsituation B. We start by updating our configuration to reflect this need.\n\n[[beans-definition-profiles-java]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/environment.adoc", "title": "environment", "heading": "Bean Definition Profiles", "heading_level": 2, "file_order": 60, "section_index": 1, "content_hash": "c3b67a58c8d08e8d2f29fab3f16fddd605b56540d336fbc1fc7cff22ae5e71a5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/environment.adoc"}}
{"id": "sha256:1371480de4de60fc8f6ae108bc2a2d71775cbbebae913171ce3c9a5c84cdf991", "content": "The {spring-framework-api}/context/annotation/Profile.html[`@Profile`]\nannotation lets you indicate that a component is eligible for registration\nwhen one or more specified profiles are active. Using our preceding example, we\ncan rewrite the `dataSource` configuration as follows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@Profile(\"development\")\n\tpublic class StandaloneDataConfig {\n\n @Bean\n public DataSource dataSource() {\n return new EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.HSQL)\n .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n .addScript(\"classpath:com/bank/config/sql/test-data.sql\")\n .build();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@Profile(\"development\")\n\tclass StandaloneDataConfig {\n\n @Bean\n fun dataSource(): DataSource {\n return EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.HSQL)\n .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n .addScript(\"classpath:com/bank/config/sql/test-data.sql\")\n .build()\n }\n\t}\n----\n======\n--\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@Profile(\"production\")\n\tpublic class JndiDataConfig {\n\n @Bean(destroyMethod = \"\") // <1>\n public DataSource dataSource() throws Exception {\n Context ctx = new InitialContext();\n return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\");\n }\n\t}\n----\n<1> `@Bean(destroyMethod = \"\")` disables default destroy method inference.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@Profile(\"production\")\n\tclass JndiDataConfig {\n\n @Bean(destroyMethod = \"\") // <1>\n fun dataSource(): DataSource {\n val ctx = InitialContext()\n return ctx.lookup(\"java:comp/env/jdbc/datasource\") as DataSource\n }\n\t}\n----\n<1> `@Bean(destroyMethod = \"\")` disables default destroy method inference.\n======\n--\n\nNOTE: As mentioned earlier, with `@Bean` methods, you typically choose to use programmatic\nJNDI lookups, by using either Spring's `JndiTemplate`/`JndiLocatorDelegate` helpers or the\nstraight JNDI `InitialContext` usage shown earlier but not the `JndiObjectFactoryBean`\nvariant, which would force you to declare the return type as the `FactoryBean` type.\n\nThe profile string may contain a simple profile name (for example, `production`) or a\nprofile expression. A profile expression allows for more complicated profile logic to be\nexpressed (for example, `production & us-east`). The following operators are supported in\nprofile expressions:\n\n* `!`: A logical `NOT` of the profile\n* `&`: A logical `AND` of the profiles\n* `|`: A logical `OR` of the profiles\n\nNOTE: You cannot mix the `&` and `|` operators without using parentheses. For example,\n`production & us-east | eu-central` is not a valid expression. It must be expressed as\n`production & (us-east | eu-central)`.\n\nYou can use `@Profile` as a xref:core/beans/classpath-scanning.adoc#beans-meta-annotations[meta-annotation] for the purpose\nof creating a custom composed annotation. The following example defines a custom\n`@Production` annotation that you can use as a drop-in replacement for\n`@Profile(\"production\")`:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Profile(\"production\")\n\tpublic @interface Production {\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(AnnotationTarget.CLASS)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@Profile(\"production\")\n\tannotation class Production\n----\n======\n--\n\nTIP: If a `@Configuration` class is marked with `@Profile`, all of the `@Bean` methods and\n`@Import` annotations associated with that class are bypassed unless one or more of\nthe specified profiles are active. If a `@Component` or `@Configuration` class is marked\nwith `@Profile({\"p1\", \"p2\"})`, that class is not registered or processed unless\nprofiles 'p1' or 'p2' have been activated. If a given profile is prefixed with the\nNOT operator (`!`), the annotated element is registered only if the profile is not\nactive. For example, given `@Profile({\"p1\", \"!p2\"})`, registration will occur if profile\n'p1' is active or if profile 'p2' is not active.\n\n`@Profile` can also be declared at the method level to include only one particular bean\nof a configuration class (for example, for alternative variants of a particular bean), as\nthe following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean(\"dataSource\")\n @Profile(\"development\") // <1>\n public DataSource standaloneDataSource() {\n return new EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.HSQL)\n .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n .addScript(\"classpath:com/bank/config/sql/test-data.sql\")\n .build();\n }\n\n @Bean(\"dataSource\")\n @Profile(\"production\") // <2>\n public DataSource jndiDataSource() throws Exception {\n Context ctx = new InitialContext();\n return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\");\n }\n\t}\n----\n<1> The `standaloneDataSource` method is available only in the `development` profile.\n<2> The `jndiDataSource` method is available only in the `production` profile.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass AppConfig {\n\n @Bean(\"dataSource\")\n @Profile(\"development\") // <1>\n fun standaloneDataSource(): DataSource {\n return EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.HSQL)\n .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n .addScript(\"classpath:com/bank/config/sql/test-data.sql\")\n .build()\n }\n\n @Bean(\"dataSource\")\n @Profile(\"production\") // <2>\n fun jndiDataSource() =\n InitialContext().lookup(\"java:comp/env/jdbc/datasource\") as DataSource\n\t}\n----\n<1> The `standaloneDataSource` method is available only in the `development` profile.\n<2> The `jndiDataSource` method is available only in the `production` profile.\n======\n--\n\n[NOTE]\n====\nWith `@Profile` on `@Bean` methods, a special scenario may apply: In the case of\noverloaded `@Bean` methods of the same Java method name (analogous to constructor\noverloading), a `@Profile` condition needs to be consistently declared on all\noverloaded methods. If the conditions are inconsistent, only the condition on the\nfirst declaration among the overloaded methods matters. Therefore, `@Profile` can\nnot be used to select an overloaded method with a particular argument signature over\nanother. Resolution between all factory methods for the same bean follows Spring's\nconstructor resolution algorithm at creation time.\n\nIf you want to define alternative beans with different profile conditions,\nuse distinct Java method names that point to the same bean name by using the `@Bean` name\nattribute, as shown in the preceding example. If the argument signatures are all\nthe same (for example, all of the variants have no-arg factory methods), this is the only\nway to represent such an arrangement in a valid Java class in the first place\n(since there can only be one method of a particular name and argument signature).\n====\n\n[[beans-definition-profiles-xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/environment.adoc", "title": "environment", "heading": "Using `@Profile`", "heading_level": 3, "file_order": 60, "section_index": 2, "content_hash": "1371480de4de60fc8f6ae108bc2a2d71775cbbebae913171ce3c9a5c84cdf991", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/environment.adoc"}}
{"id": "sha256:fefbd515c4ed2128f3ac28629fdf0227a6f659bf970457e93802669292ea08fc", "content": "The XML counterpart is the `profile` attribute of the `<beans>` element. Our preceding sample\nconfiguration can be rewritten in two XML files, as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans profile=\"development\"\n xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n xsi:schemaLocation=\"...\">\n\n <jdbc:embedded-database id=\"dataSource\">\n <jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/>\n <jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/>\n </jdbc:embedded-database>\n\t</beans>\n----\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans profile=\"production\"\n xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:jee=\"http://www.springframework.org/schema/jee\"\n xsi:schemaLocation=\"...\">\n\n <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n\t</beans>\n----\n\nIt is also possible to avoid that split and nest `<beans/>` elements within the same file,\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n xmlns:jee=\"http://www.springframework.org/schema/jee\"\n xsi:schemaLocation=\"...\">\n\n <!-- other bean definitions -->\n\n <beans profile=\"development\">\n <jdbc:embedded-database id=\"dataSource\">\n <jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/>\n <jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/>\n </jdbc:embedded-database>\n </beans>\n\n <beans profile=\"production\">\n <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n </beans>\n\t</beans>\n----\n\nThe `spring-bean.xsd` has been constrained to allow such elements only as the\nlast ones in the file. This should help provide flexibility without incurring\nclutter in the XML files.\n\n[NOTE]\n=====\nThe XML counterpart does not support the profile expressions described earlier. It is possible,\nhowever, to negate a profile by using the `!` operator. It is also possible to apply a logical\n\"`and`\" by nesting the profiles, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n xmlns:jee=\"http://www.springframework.org/schema/jee\"\n xsi:schemaLocation=\"...\">\n\n <!-- other bean definitions -->\n\n <beans profile=\"production\">\n <beans profile=\"us-east\">\n <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n </beans>\n </beans>\n\t</beans>\n----\n\nIn the preceding example, the `dataSource` bean is exposed if both the `production` and\n`us-east` profiles are active.\n=====\n\n[[beans-definition-profiles-enable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/environment.adoc", "title": "environment", "heading": "XML Bean Definition Profiles", "heading_level": 3, "file_order": 60, "section_index": 3, "content_hash": "fefbd515c4ed2128f3ac28629fdf0227a6f659bf970457e93802669292ea08fc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/environment.adoc"}}
{"id": "sha256:ef130cda65bdbb19e1688431f322e356caf96940d8aef5a9c33ef48bccb004f9", "content": "Now that we have updated our configuration, we still need to instruct Spring which\nprofile is active. If we started our sample application right now, we would see\na `NoSuchBeanDefinitionException` thrown, because the container could not find\nthe Spring bean named `dataSource`.\n\nActivating a profile can be done in several ways, but the most straightforward is to do\nit programmatically against the `Environment` API which is available through an\n`ApplicationContext`. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tAnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();\n\tctx.getEnvironment().setActiveProfiles(\"development\");\n\tctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);\n\tctx.refresh();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ctx = AnnotationConfigApplicationContext().apply {\n environment.setActiveProfiles(\"development\")\n register(SomeConfig::class.java, StandaloneDataConfig::class.java, JndiDataConfig::class.java)\n refresh()\n\t}\n----\n======\n\nIn addition, you can also declaratively activate profiles through the\n`spring.profiles.active` property, which may be specified through system environment\nvariables, JVM system properties, servlet context parameters in `web.xml`, or even as an\nentry in JNDI (see xref:core/beans/environment.adoc#beans-property-source-abstraction[`PropertySource` Abstraction]). In integration tests, active\nprofiles can be declared by using the `@ActiveProfiles` annotation in the `spring-test`\nmodule (see xref:testing/testcontext-framework/ctx-management/env-profiles.adoc[context configuration with environment profiles]\n).\n\nNote that profiles are not an \"`either-or`\" proposition. You can activate multiple\nprofiles at once. Programmatically, you can provide multiple profile names to the\n`setActiveProfiles()` method, which accepts `String...` varargs. The following example\nactivates multiple profiles:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tctx.getEnvironment().setActiveProfiles(\"profile1\", \"profile2\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tctx.getEnvironment().setActiveProfiles(\"profile1\", \"profile2\")\n----\n======\n\nDeclaratively, `spring.profiles.active` may accept a comma-separated list of profile names,\nas the following example shows:\n\n[literal,indent=0,subs=\"verbatim,quotes\"]\n----\n\t-Dspring.profiles.active=\"profile1,profile2\"\n----\n\n[[beans-definition-profiles-default]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/environment.adoc", "title": "environment", "heading": "Activating a Profile", "heading_level": 3, "file_order": 60, "section_index": 4, "content_hash": "ef130cda65bdbb19e1688431f322e356caf96940d8aef5a9c33ef48bccb004f9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/environment.adoc"}}
{"id": "sha256:dfc2d38e060c0eb3aa7c1d3f6bc8a4cd375f8a52dabe3ab926638e4afa7b78c4", "content": "The default profile represents the profile that is enabled if no profile is active. Consider\nthe following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@Profile(\"default\")\n\tpublic class DefaultDataConfig {\n\n @Bean\n public DataSource dataSource() {\n return new EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.HSQL)\n .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n .build();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@Profile(\"default\")\n\tclass DefaultDataConfig {\n\n @Bean\n fun dataSource(): DataSource {\n return EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.HSQL)\n .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n .build()\n }\n\t}\n----\n======\n\nIf xref:#beans-definition-profiles-enable[no profile is active], the `dataSource` is\ncreated. You can see this as a way to provide a default definition for one or more\nbeans. If any profile is enabled, the default profile does not apply.\n\nThe name of the default profile is `default`. You can change the name of\nthe default profile by using `setDefaultProfiles()` on the `Environment` or,\ndeclaratively, by using the `spring.profiles.default` property.\n\n[[beans-property-source-abstraction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/environment.adoc", "title": "environment", "heading": "Default Profile", "heading_level": 3, "file_order": 60, "section_index": 5, "content_hash": "dfc2d38e060c0eb3aa7c1d3f6bc8a4cd375f8a52dabe3ab926638e4afa7b78c4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/environment.adoc"}}
{"id": "sha256:3df5bb026a4f286e240d66242f31f42869f6cddd83f80fe71f7b211d6ae2f202", "content": "Spring's `Environment` abstraction provides search operations over a configurable\nhierarchy of property sources. Consider the following listing:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext ctx = new GenericApplicationContext();\n\tEnvironment env = ctx.getEnvironment();\n\tboolean containsMyProperty = env.containsProperty(\"my-property\");\n\tSystem.out.println(\"Does my environment contain the 'my-property' property? \" + containsMyProperty);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ctx = GenericApplicationContext()\n\tval env = ctx.environment\n\tval containsMyProperty = env.containsProperty(\"my-property\")\n\tprintln(\"Does my environment contain the 'my-property' property? $containsMyProperty\")\n----\n======\n\nIn the preceding snippet, we see a high-level way of asking Spring whether the `my-property` property is\ndefined for the current environment. To answer this question, the `Environment` object performs\na search over a set of {spring-framework-api}/core/env/PropertySource.html[`PropertySource`]\nobjects. A `PropertySource` is a simple abstraction over any source of key-value pairs, and\nSpring's {spring-framework-api}/core/env/StandardEnvironment.html[`StandardEnvironment`]\nis configured with two PropertySource objects -- one representing the set of JVM system properties\n(`System.getProperties()`) and one representing the set of system environment variables\n(`System.getenv()`).\n\nNOTE: These default property sources are present for `StandardEnvironment`, for use in standalone\napplications. {spring-framework-api}/web/context/support/StandardServletEnvironment.html[`StandardServletEnvironment`]\nis populated with additional default property sources including servlet config, servlet\ncontext parameters, and a {spring-framework-api}/jndi/JndiPropertySource.html[`JndiPropertySource`]\nif JNDI is available.\n\nConcretely, when you use the `StandardEnvironment`, the call to `env.containsProperty(\"my-property\")`\nreturns true if a `my-property` system property or `my-property` environment variable is present at\nruntime.\n\n[TIP]\n====\nThe search performed is hierarchical. By default, system properties have precedence over\nenvironment variables. So, if the `my-property` property happens to be set in both places during\na call to `env.getProperty(\"my-property\")`, the system property value \"`wins`\" and is returned.\nNote that property values are not merged\nbut rather completely overridden by a preceding entry.\n\nFor a common `StandardServletEnvironment`, the full hierarchy is as follows, with the\nhighest-precedence entries at the top:\n\n. ServletConfig parameters (if applicable -- for example, in case of a `DispatcherServlet` context)\n. ServletContext parameters (web.xml context-param entries)\n. JNDI environment variables (`java:comp/env/` entries)\n. JVM system properties (`-D` command-line arguments)\n. JVM system environment (operating system environment variables)\n====\n\nMost importantly, the entire mechanism is configurable. Perhaps you have a custom source\nof properties that you want to integrate into this search. To do so, implement\nand instantiate your own `PropertySource` and add it to the set of `PropertySources` for the\ncurrent `Environment`. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\nConfigurableApplicationContext ctx = new GenericApplicationContext();\nMutablePropertySources sources = ctx.getEnvironment().getPropertySources();\nsources.addFirst(new MyPropertySource());\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ctx = GenericApplicationContext()\n\tval sources = ctx.environment.propertySources\n\tsources.addFirst(MyPropertySource())\n----\n======\n\nIn the preceding code, `MyPropertySource` has been added with highest precedence in the\nsearch. If it contains a `my-property` property, the property is detected and returned, in favor of\nany `my-property` property in any other `PropertySource`. The\n{spring-framework-api}/core/env/MutablePropertySources.html[`MutablePropertySources`]\nAPI exposes a number of methods that allow for precise manipulation of the set of\nproperty sources.\n\n[[beans-using-propertysource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/environment.adoc", "title": "environment", "heading": "`PropertySource` Abstraction", "heading_level": 2, "file_order": 60, "section_index": 6, "content_hash": "3df5bb026a4f286e240d66242f31f42869f6cddd83f80fe71f7b211d6ae2f202", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/environment.adoc"}}
{"id": "sha256:929429f794ccfd533e827c4ecf81e480cfd0d4836d88af4679d37d9a7e4aa8b3", "content": "The {spring-framework-api}/context/annotation/PropertySource.html[`@PropertySource`]\nannotation provides a convenient and declarative mechanism for adding a `PropertySource`\nto Spring's `Environment`.\n\nGiven a file called `app.properties` that contains the key-value pair `testbean.name=myTestBean`,\nthe following `@Configuration` class uses `@PropertySource` in such a way that\na call to `testBean.getName()` returns `myTestBean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n @Configuration\n @PropertySource(\"classpath:/com/myco/app.properties\")\n public class AppConfig {\n\n @Autowired\n Environment env;\n\n @Bean\n public TestBean testBean() {\n TestBean testBean = new TestBean();\n testBean.setName(env.getProperty(\"testbean.name\"));\n return testBean;\n }\n }\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@PropertySource(\"classpath:/com/myco/app.properties\")\n\tclass AppConfig {\n\n @Autowired\n private lateinit var env: Environment\n\n @Bean\n fun testBean() = TestBean().apply {\n name = env.getProperty(\"testbean.name\")!!\n }\n\t}\n----\n======\n\nAny `${...}` placeholders present in a `@PropertySource` resource location are\nresolved against the set of property sources already registered against the\nenvironment, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n @Configuration\n @PropertySource(\"classpath:/com/${my.placeholder:default/path}/app.properties\")\n public class AppConfig {\n\n @Autowired\n Environment env;\n\n @Bean\n public TestBean testBean() {\n TestBean testBean = new TestBean();\n testBean.setName(env.getProperty(\"testbean.name\"));\n return testBean;\n }\n }\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@PropertySource(\"classpath:/com/\\${my.placeholder:default/path}/app.properties\")\n\tclass AppConfig {\n\n @Autowired\n private lateinit var env: Environment\n\n @Bean\n fun testBean() = TestBean().apply {\n name = env.getProperty(\"testbean.name\")!!\n }\n\t}\n----\n======\n\nAssuming that `my.placeholder` is present in one of the property sources already\nregistered (for example, system properties or environment variables), the placeholder is\nresolved to the corresponding value. If not, then `default/path` is used\nas a default. If no default is specified and a property cannot be resolved, an\n`IllegalArgumentException` is thrown.\n\nNOTE: `@PropertySource` can be used as a repeatable annotation. `@PropertySource`\nmay also be used as a meta-annotation to create custom composed annotations with\nattribute overrides.\n\n[[beans-placeholder-resolution-in-statements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/environment.adoc", "title": "environment", "heading": "Using `@PropertySource`", "heading_level": 2, "file_order": 60, "section_index": 7, "content_hash": "929429f794ccfd533e827c4ecf81e480cfd0d4836d88af4679d37d9a7e4aa8b3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/environment.adoc"}}
{"id": "sha256:3a39e0d676377895cfe6332dc1d8bf58e1995d35da047b35ad090692601e68b1", "content": "Historically, the value of placeholders in elements could be resolved only against\nJVM system properties or environment variables. This is no longer the case. Because\nthe `Environment` abstraction is integrated throughout the container, it is easy to\nroute resolution of placeholders through it. This means that you may configure the\nresolution process in any way you like. You can change the precedence of searching through\nsystem properties and environment variables or remove them entirely. You can also add your\nown property sources to the mix, as appropriate.\n\nConcretely, the following statement works regardless of where the `customer`\nproperty is defined, as long as it is available in the `Environment`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <import resource=\"com/bank/service/${customer}-config.xml\"/>\n\t</beans>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/environment.adoc", "title": "environment", "heading": "Placeholder Resolution in Statements", "heading_level": 2, "file_order": 60, "section_index": 8, "content_hash": "3a39e0d676377895cfe6332dc1d8bf58e1995d35da047b35ad090692601e68b1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/environment.adoc"}}
{"id": "sha256:20884de50b276ef612d02eb100b450666f9c4c0989d24b092f866dfe22d40edd", "content": "[[beans-factory-extension]]\n\nTypically, an application developer does not need to subclass `ApplicationContext`\nimplementation classes. Instead, the Spring IoC container can be extended by plugging in\nimplementations of special integration interfaces. The next few sections describe these\nintegration interfaces.\n\n[[beans-factory-extension-bpp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc", "title": "factory-extension", "heading": "factory-extension", "heading_level": 1, "file_order": 61, "section_index": 0, "content_hash": "20884de50b276ef612d02eb100b450666f9c4c0989d24b092f866dfe22d40edd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc"}}
{"id": "sha256:953eaf53bfd0ce0339ff8a24dfe9525f07b7e5f2a185cffbac537643eb1d4944", "content": "The `BeanPostProcessor` interface defines callback methods that you can implement to\nprovide your own (or override the container's default) instantiation logic, dependency\nresolution logic, and so forth. If you want to implement some custom logic after the\nSpring container finishes instantiating, configuring, and initializing a bean, you can\nplug in one or more custom `BeanPostProcessor` implementations.\n\nYou can configure multiple `BeanPostProcessor` instances, and you can control the order\nin which these `BeanPostProcessor` instances run by setting the `order` property.\nYou can set this property only if the `BeanPostProcessor` implements the `Ordered`\ninterface. If you write your own `BeanPostProcessor`, you should consider implementing\nthe `Ordered` interface, too. For further details, see the javadoc of the\n{spring-framework-api}/beans/factory/config/BeanPostProcessor.html[`BeanPostProcessor`]\nand {spring-framework-api}/core/Ordered.html[`Ordered`] interfaces. See also the note on\nxref:core/beans/factory-extension.adoc#beans-factory-programmatically-registering-beanpostprocessors[programmatic registration of `BeanPostProcessor` instances].\n\n[NOTE]\n====\n`BeanPostProcessor` instances operate on bean (or object) instances. That is,\nthe Spring IoC container instantiates a bean instance and then `BeanPostProcessor`\ninstances do their work.\n\n`BeanPostProcessor` instances are scoped per-container. This is relevant only if you\nuse container hierarchies. If you define a `BeanPostProcessor` in one container,\nit post-processes only the beans in that container. In other words, beans that are\ndefined in one container are not post-processed by a `BeanPostProcessor` defined in\nanother container, even if both containers are part of the same hierarchy.\n\nTo change the actual bean definition (that is, the blueprint that defines the bean),\nyou instead need to use a `BeanFactoryPostProcessor`, as described in\nxref:core/beans/factory-extension.adoc#beans-factory-extension-factory-postprocessors[Customizing Configuration Metadata with a `BeanFactoryPostProcessor`].\n====\n\nThe `org.springframework.beans.factory.config.BeanPostProcessor` interface consists of\nexactly two callback methods. When such a class is registered as a post-processor with\nthe container, for each bean instance that is created by the container, the\npost-processor gets a callback from the container both before container\ninitialization methods (such as `InitializingBean.afterPropertiesSet()` or any\ndeclared `init` method) are called, and after any bean initialization callbacks.\nThe post-processor can take any action with the bean instance, including ignoring the\ncallback completely. A bean post-processor typically checks for callback interfaces,\nor it may wrap a bean with a proxy. Some Spring AOP infrastructure classes are\nimplemented as bean post-processors in order to provide proxy-wrapping logic.\n\nAn `ApplicationContext` automatically detects any beans that are defined in the\nconfiguration metadata that implement the `BeanPostProcessor` interface. The\n`ApplicationContext` registers these beans as post-processors so that they can be called\nlater, upon bean creation. Bean post-processors can be deployed in the container in the\nsame fashion as any other beans.\n\nNote that, when declaring a `BeanPostProcessor` by using an `@Bean` factory method on a\nconfiguration class, the return type of the factory method should be the implementation\nclass itself or at least the `org.springframework.beans.factory.config.BeanPostProcessor`\ninterface, clearly indicating the post-processor nature of that bean. Otherwise, the\n`ApplicationContext` cannot autodetect it by type before fully creating it.\nSince a `BeanPostProcessor` needs to be instantiated early in order to apply to the\ninitialization of other beans in the context, this early type detection is critical.\n\n[[beans-factory-programmatically-registering-beanpostprocessors]]\n.Programmatically registering `BeanPostProcessor` instances\nNOTE: While the recommended approach for `BeanPostProcessor` registration is through\n`ApplicationContext` auto-detection (as described earlier), you can register them\nprogrammatically against a `ConfigurableBeanFactory` by using the `addBeanPostProcessor`\nmethod. This can be useful when you need to evaluate conditional logic before\nregistration or even for copying bean post processors across contexts in a hierarchy.\nNote, however, that `BeanPostProcessor` instances added programmatically do not respect\nthe `Ordered` interface. Here, it is the order of registration that dictates the order\nof execution. Note also that `BeanPostProcessor` instances registered programmatically\nare always processed before those registered through auto-detection, regardless of any\nexplicit ordering.\n\n.`BeanPostProcessor` instances and AOP auto-proxying\n[NOTE]\n====\nClasses that implement the `BeanPostProcessor` interface are special and are treated\ndifferently by the container. All `BeanPostProcessor` instances and beans that they\ndirectly reference are instantiated on startup, as part of the special startup phase\nof the `ApplicationContext`. Next, all `BeanPostProcessor` instances are registered\nin a sorted fashion and applied to all further beans in the container. Because AOP\nauto-proxying is implemented as a `BeanPostProcessor` itself, neither `BeanPostProcessor`\ninstances nor the beans they directly reference are eligible for auto-proxying and,\nthus, do not have aspects woven into them.\n\nFor any such bean, you should see an informational log message: `Bean someBean is not\neligible for getting processed by all BeanPostProcessor interfaces (for example: not\neligible for auto-proxying)`.\n\nIf you have beans wired into your `BeanPostProcessor` by using autowiring or\n`@Resource` (which may fall back to autowiring), Spring might access unexpected beans\nwhen searching for type-matching dependency candidates and, therefore, make them\nineligible for auto-proxying or other kinds of bean post-processing. For example, if you\nhave a dependency annotated with `@Resource` where the field or setter name does not\ndirectly correspond to the declared name of a bean and no name attribute is used,\nSpring accesses other beans for matching them by type.\n====\n\nThe following examples show how to write, register, and use `BeanPostProcessor` instances\nin an `ApplicationContext`.\n\n[[beans-factory-extension-bpp-examples-hw]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc", "title": "factory-extension", "heading": "Customizing Beans by Using a `BeanPostProcessor`", "heading_level": 2, "file_order": 61, "section_index": 1, "content_hash": "953eaf53bfd0ce0339ff8a24dfe9525f07b7e5f2a185cffbac537643eb1d4944", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc"}}
{"id": "sha256:870f67862cd9842bd12bc7427b8b756eb9cb7dd64088e338cb9f749193c22fc1", "content": "This first example illustrates basic usage. The example shows a custom\n`BeanPostProcessor` implementation that invokes the `toString()` method of each bean as\nit is created by the container and prints the resulting string to the system console.\n\nThe following listing shows the custom `BeanPostProcessor` implementation class definition:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage scripting;\n\n\timport org.springframework.beans.factory.config.BeanPostProcessor;\n\n\tpublic class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {\n\n // simply return the instantiated bean as-is\n public Object postProcessBeforeInitialization(Object bean, String beanName) {\n return bean; // we could potentially return any object reference here...\n }\n\n public Object postProcessAfterInitialization(Object bean, String beanName) {\n System.out.println(\"Bean '\" + beanName + \"' created : \" + bean.toString());\n return bean;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage scripting\n\n\timport org.springframework.beans.factory.config.BeanPostProcessor\n\n\tclass InstantiationTracingBeanPostProcessor : BeanPostProcessor {\n\n // simply return the instantiated bean as-is\n override fun postProcessBeforeInitialization(bean: Any, beanName: String): Any? {\n return bean // we could potentially return any object reference here...\n }\n\n override fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {\n println(\"Bean '$beanName' created : $bean\")\n return bean\n }\n\t}\n----\n======\n\nThe following `beans` element uses the `InstantiationTracingBeanPostProcessor`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:lang=\"http://www.springframework.org/schema/lang\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/lang\n https://www.springframework.org/schema/lang/spring-lang.xsd\">\n\n <lang:groovy id=\"messenger\"\n script-source=\"classpath:org/springframework/scripting/groovy/Messenger.groovy\">\n <lang:property name=\"message\" value=\"Fiona Apple Is Just So Dreamy.\"/>\n </lang:groovy>\n\n <!--\n when the above bean (messenger) is instantiated, this custom\n BeanPostProcessor implementation will output the fact to the system console\n -->\n <bean class=\"scripting.InstantiationTracingBeanPostProcessor\"/>\n\n\t</beans>\n----\n\nNotice how the `InstantiationTracingBeanPostProcessor` is merely defined. It does not\neven have a name, and, because it is a bean, it can be dependency-injected as you would any\nother bean. (The preceding configuration also defines a bean that is backed by a Groovy\nscript.)\n\nThe following Java application runs the preceding code and configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.context.ApplicationContext;\n\timport org.springframework.context.support.ClassPathXmlApplicationContext;\n\timport org.springframework.scripting.Messenger;\n\n\tpublic final class Boot {\n\n public static void main(final String[] args) throws Exception {\n ApplicationContext ctx = new ClassPathXmlApplicationContext(\"scripting/beans.xml\");\n Messenger messenger = ctx.getBean(\"messenger\", Messenger.class);\n System.out.println(messenger);\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\tfun main() {\n val ctx = ClassPathXmlApplicationContext(\"scripting/beans.xml\")\n val messenger = ctx.getBean<Messenger>(\"messenger\")\n println(messenger)\n\t}\n----\n======\n\nThe output of the preceding application resembles the following:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nBean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961\norg.springframework.scripting.groovy.GroovyMessenger@272961\n----\n\n[[beans-factory-extension-bpp-examples-aabpp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc", "title": "factory-extension", "heading": "Example: Hello World, `BeanPostProcessor`-style", "heading_level": 3, "file_order": 61, "section_index": 2, "content_hash": "870f67862cd9842bd12bc7427b8b756eb9cb7dd64088e338cb9f749193c22fc1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc"}}
{"id": "sha256:fa18b53e469e86acae216f753214bccd5108e79cdb6c8cf8433f6cbfe76b1dde", "content": "Using callback interfaces or annotations in conjunction with a custom `BeanPostProcessor`\nimplementation is a common means of extending the Spring IoC container. An example is\nSpring's `AutowiredAnnotationBeanPostProcessor` -- a `BeanPostProcessor` implementation\nthat ships with the Spring distribution and autowires annotated fields, setter methods,\nand arbitrary config methods.\n\n[[beans-factory-extension-factory-postprocessors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc", "title": "factory-extension", "heading": "Example: The `AutowiredAnnotationBeanPostProcessor`", "heading_level": 3, "file_order": 61, "section_index": 3, "content_hash": "fa18b53e469e86acae216f753214bccd5108e79cdb6c8cf8433f6cbfe76b1dde", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc"}}
{"id": "sha256:983e44b25cdfc6ace94f0601ae59a5dbfe008967f9abc8cce11bb0b83feffb59", "content": "The next extension point that we look at is the\n`org.springframework.beans.factory.config.BeanFactoryPostProcessor`. The semantics of\nthis interface are similar to those of the `BeanPostProcessor`, with one major\ndifference: `BeanFactoryPostProcessor` operates on the bean configuration metadata.\nThat is, the Spring IoC container lets a `BeanFactoryPostProcessor` read the\nconfiguration metadata and potentially change it _before_ the container instantiates\nany beans other than `BeanFactoryPostProcessor` instances.\n\nYou can configure multiple `BeanFactoryPostProcessor` instances, and you can control the order in\nwhich these `BeanFactoryPostProcessor` instances run by setting the `order` property.\nHowever, you can only set this property if the `BeanFactoryPostProcessor` implements the\n`Ordered` interface. If you write your own `BeanFactoryPostProcessor`, you should\nconsider implementing the `Ordered` interface, too. See the javadoc of the\n{spring-framework-api}/beans/factory/config/BeanFactoryPostProcessor.html[`BeanFactoryPostProcessor`]\nand {spring-framework-api}/core/Ordered.html[`Ordered`] interfaces for more details.\n\n[NOTE]\n====\nIf you want to change the actual bean instances (that is, the objects that are created\nfrom the configuration metadata), then you instead need to use a `BeanPostProcessor`\n(described earlier in\nxref:core/beans/factory-extension.adoc#beans-factory-extension-bpp[Customizing Beans by Using a `BeanPostProcessor`]).\nWhile it is technically possible to work with bean instances within a `BeanFactoryPostProcessor`\n(for example, by using `BeanFactory.getBean()`), doing so causes premature bean instantiation,\nviolating the standard container lifecycle. This may cause negative side effects, such as\nbypassing bean post processing.\n\nAlso, `BeanFactoryPostProcessor` instances are scoped per-container. This is only relevant\nif you use container hierarchies. If you define a `BeanFactoryPostProcessor` in one\ncontainer, it is applied only to the bean definitions in that container. Bean definitions\nin one container are not post-processed by `BeanFactoryPostProcessor` instances in another\ncontainer, even if both containers are part of the same hierarchy.\n====\n\nA bean factory post-processor is automatically run when it is declared inside an\n`ApplicationContext`, in order to apply changes to the configuration metadata that\ndefine the container. Spring includes a number of predefined bean factory\npost-processors, such as `PropertyOverrideConfigurer` and\n`PropertySourcesPlaceholderConfigurer`. You can also use a custom `BeanFactoryPostProcessor`\n-- for example, to register custom property editors.\n\nAn `ApplicationContext` automatically detects any beans that are deployed into it that\nimplement the `BeanFactoryPostProcessor` interface. It uses these beans as bean factory\npost-processors, at the appropriate time. You can deploy these post-processor beans as\nyou would any other bean.\n\nNOTE: As with ``BeanPostProcessor``s , you typically do not want to configure\n``BeanFactoryPostProcessor``s for lazy initialization. If no other bean references a\n`Bean(Factory)PostProcessor`, that post-processor will not get instantiated at all.\nThus, marking it for lazy initialization will be ignored, and the\n`Bean(Factory)PostProcessor` will be instantiated eagerly even if you set the\n`default-lazy-init` attribute to `true` on the declaration of your `<beans />` element.\n\n[[beans-factory-placeholderconfigurer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc", "title": "factory-extension", "heading": "Customizing Configuration Metadata with a `BeanFactoryPostProcessor`", "heading_level": 2, "file_order": 61, "section_index": 4, "content_hash": "983e44b25cdfc6ace94f0601ae59a5dbfe008967f9abc8cce11bb0b83feffb59", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc"}}
{"id": "sha256:0600b09e2eb8fcf2a4477fa1e883f2049e2b67fe73c876b0876bdcd26b7f1466", "content": "You can use the `PropertySourcesPlaceholderConfigurer` to externalize property values\nfrom a bean definition in a separate file by using the standard Java `Properties` format.\nDoing so enables the person deploying an application to customize environment-specific\nproperties, such as database URLs and passwords, without the complexity or risk of\nmodifying the main XML definition file or files for the container.\n\nConsider the following XML-based configuration metadata fragment, where a `DataSource`\nwith placeholder values is defined:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean class=\"org.springframework.context.support.PropertySourcesPlaceholderConfigurer\">\n <property name=\"locations\" value=\"classpath:com/something/jdbc.properties\"/>\n\t</bean>\n\n\t<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/>\n <property name=\"url\" value=\"${jdbc.url}\"/>\n <property name=\"username\" value=\"${jdbc.username}\"/>\n <property name=\"password\" value=\"${jdbc.password}\"/>\n\t</bean>\n----\n\nThe example shows properties configured from an external `Properties` file. At runtime,\na `PropertySourcesPlaceholderConfigurer` is applied to the metadata that replaces some\nproperties of the `DataSource`. The values to replace are specified as placeholders of the\nform pass:q[`${property-name}`], which follows the Ant, log4j, and JSP EL style.\n\nThe actual values come from another file in the standard Java `Properties` format:\n\n[literal,subs=\"verbatim,quotes\"]\n----\njdbc.driverClassName=org.hsqldb.jdbcDriver\njdbc.url=jdbc:hsqldb:hsql://production:9002\njdbc.username=sa\njdbc.password=root\n----\n\nTherefore, the `${jdbc.username}` string is replaced at runtime with the value, 'sa', and\nthe same applies for other placeholder values that match keys in the properties file. The\n`PropertySourcesPlaceholderConfigurer` checks for placeholders in most properties and\nattributes of a bean definition. Furthermore, you can customize the placeholder prefix,\nsuffix, default value separator, and escape character. In addition, the default escape\ncharacter can be changed or disabled globally by setting the\n`spring.placeholder.escapeCharacter.default` property via a JVM system property (or via\nthe xref:appendix.adoc#appendix-spring-properties[`SpringProperties`] mechanism).\n\nWith the `context` namespace, you can configure property placeholders\nwith a dedicated configuration element. You can provide one or more locations as a\ncomma-separated list in the `location` attribute, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<context:property-placeholder location=\"classpath:com/something/jdbc.properties\"/>\n----\n\nThe `PropertySourcesPlaceholderConfigurer` not only looks for properties in the `Properties`\nfile you specify. By default, if it cannot find a property in the specified properties files,\nit checks against Spring `Environment` properties and regular Java `System` properties.\n\n[WARNING]\n=====\nOnly one such element should be defined for a given application with the properties\nthat it needs. Several property placeholders can be configured as long as they have distinct\nplaceholder syntax (`${...}`).\n\nIf you need to modularize the source of properties used for the replacement, you should\nnot create multiple properties placeholders. Rather, you should create your own\n`PropertySourcesPlaceholderConfigurer` bean that gathers the properties to use.\n=====\n\n[TIP]\n=====\nYou can use the `PropertySourcesPlaceholderConfigurer` to substitute class names, which\nis sometimes useful when you have to pick a particular implementation class at runtime.\nThe following example shows how to do so:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean class=\"org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer\">\n <property name=\"locations\">\n <value>classpath:com/something/strategy.properties</value>\n </property>\n <property name=\"properties\">\n <value>custom.strategy.class=com.something.DefaultStrategy</value>\n </property>\n\t</bean>\n\n\t<bean id=\"serviceStrategy\" class=\"${custom.strategy.class}\"/>\n----\n\nIf the class cannot be resolved at runtime to a valid class, resolution of the bean\nfails when it is about to be created, which is during the `preInstantiateSingletons()`\nphase of an `ApplicationContext` for a non-lazy-init bean.\n=====\n\n[[beans-factory-overrideconfigurer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc", "title": "factory-extension", "heading": "Example: Property Placeholder Substitution with `PropertySourcesPlaceholderConfigurer`", "heading_level": 3, "file_order": 61, "section_index": 5, "content_hash": "0600b09e2eb8fcf2a4477fa1e883f2049e2b67fe73c876b0876bdcd26b7f1466", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc"}}
{"id": "sha256:e65897af0a20cf55c1587b6c44641b7a4e7e7874b932110ed4f51fd9f0fd4035", "content": "The `PropertyOverrideConfigurer`, another bean factory post-processor, resembles the\n`PropertySourcesPlaceholderConfigurer`, but unlike the latter, the original definitions\ncan have default values or no values at all for bean properties. If an overriding\n`Properties` file does not have an entry for a certain bean property, the default\ncontext definition is used.\n\nNote that the bean definition is not aware of being overridden, so it is not\nimmediately obvious from the XML definition file that the override configurer is being\nused. In case of multiple `PropertyOverrideConfigurer` instances that define different\nvalues for the same bean property, the last one wins, due to the overriding mechanism.\n\nProperties file configuration lines take the following format:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nbeanName.property=value\n----\n\nThe following listing shows an example of the format:\n\n[literal,subs=\"verbatim,quotes\"]\n----\ndataSource.driverClassName=com.mysql.jdbc.Driver\ndataSource.url=jdbc:mysql:mydb\n----\n\nThis example file can be used with a container definition that contains a bean called\n`dataSource` that has `driverClassName` and `url` properties.\n\nCompound property names are also supported, as long as every component of the path\nexcept the final property being overridden is already non-null (presumably initialized\nby the constructors). In the following example, the `sammy` property of the `bob`\nproperty of the `fred` property of the `tom` bean is set to the scalar value `123`:\n\n[literal,subs=\"verbatim,quotes\"]\n----\ntom.fred.bob.sammy=123\n----\n\nNOTE: Specified override values are always literal values. They are not translated into\nbean references. This convention also applies when the original value in the XML bean\ndefinition specifies a bean reference.\n\nWith the `context` namespace introduced in Spring 2.5, it is possible to configure\nproperty overriding with a dedicated configuration element, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<context:property-override location=\"classpath:override.properties\"/>\n----\n\n[[beans-factory-extension-factorybean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc", "title": "factory-extension", "heading": "Example: The `PropertyOverrideConfigurer`", "heading_level": 3, "file_order": 61, "section_index": 6, "content_hash": "e65897af0a20cf55c1587b6c44641b7a4e7e7874b932110ed4f51fd9f0fd4035", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc"}}
{"id": "sha256:62e7132817b4ea4c9e1c4a60487f1dff6dcab9211070878f5b77bee5df4997c9", "content": "You can implement the `org.springframework.beans.factory.FactoryBean` interface for objects that\nare themselves factories.\n\nThe `FactoryBean` interface is a point of pluggability into the Spring IoC container's\ninstantiation logic. If you have complex initialization code that is better expressed in\nJava as opposed to a (potentially) verbose amount of XML, you can create your own\n`FactoryBean`, write the complex initialization inside that class, and then plug your\ncustom `FactoryBean` into the container.\n\nThe `FactoryBean<T>` interface provides three methods:\n\n* `T getObject()`: Returns an instance of the object this factory creates. The\n instance can possibly be shared, depending on whether this factory returns singletons\n or prototypes.\n* `boolean isSingleton()`: Returns `true` if this `FactoryBean` returns singletons or\n `false` otherwise. The default implementation of this method returns `true`.\n* `Class<?> getObjectType()`: Returns the object type returned by the `getObject()` method\n or `null` if the type is not known in advance.\n\nThe `FactoryBean` concept and interface are used in a number of places within the Spring\nFramework. More than 50 implementations of the `FactoryBean` interface ship with Spring\nitself.\n\nWhen you need to ask a container for an actual `FactoryBean` instance itself instead of\nthe bean it produces, prefix the bean's `id` with the ampersand symbol (`&`) when\ncalling the `getBean()` method of the `ApplicationContext`. So, for a given `FactoryBean`\nwith an `id` of `myBean`, invoking `getBean(\"myBean\")` on the container returns the\nproduct of the `FactoryBean`, whereas invoking `getBean(\"&myBean\")` returns the\n`FactoryBean` instance itself.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc", "title": "factory-extension", "heading": "Customizing Instantiation Logic with a `FactoryBean`", "heading_level": 2, "file_order": 61, "section_index": 7, "content_hash": "62e7132817b4ea4c9e1c4a60487f1dff6dcab9211070878f5b77bee5df4997c9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-extension.adoc"}}
{"id": "sha256:474bf28744b1991fac850dfac73a118cc0d13fd6ef2a70c9b8a7f3df09e7403e", "content": "[[beans-factory-nature]]\n\nThe Spring Framework provides a number of interfaces you can use to customize the nature\nof a bean. This section groups them as follows:\n\n* xref:core/beans/factory-nature.adoc#beans-factory-lifecycle[Lifecycle Callbacks]\n* xref:core/beans/factory-nature.adoc#beans-factory-aware[`ApplicationContextAware` and `BeanNameAware`]\n* xref:core/beans/factory-nature.adoc#aware-list[Other `Aware` Interfaces]\n\n[[beans-factory-lifecycle]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc", "title": "factory-nature", "heading": "factory-nature", "heading_level": 1, "file_order": 62, "section_index": 0, "content_hash": "474bf28744b1991fac850dfac73a118cc0d13fd6ef2a70c9b8a7f3df09e7403e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc"}}
{"id": "sha256:fd9a5dc5db470869868791bbe6f4163e75fc20265f400c44791e5c2df3adf800", "content": "To interact with the container's management of the bean lifecycle, you can implement\nthe Spring `InitializingBean` and `DisposableBean` interfaces. The container calls\n`afterPropertiesSet()` for the former and `destroy()` for the latter to let the bean\nperform certain actions upon initialization and destruction of your beans.\n\n[TIP]\n====\nThe JSR-250 `@PostConstruct` and `@PreDestroy` annotations are generally considered best\npractice for receiving lifecycle callbacks in a modern Spring application. Using these\nannotations means that your beans are not coupled to Spring-specific interfaces.\nFor details, see xref:core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc[Using `@PostConstruct` and `@PreDestroy`].\n\nIf you do not want to use the JSR-250 annotations but you still want to remove\ncoupling, consider `init-method` and `destroy-method` bean definition metadata.\n====\n\nInternally, the Spring Framework uses `BeanPostProcessor` implementations to process any\ncallback interfaces it can find and call the appropriate methods. If you need custom\nfeatures or other lifecycle behavior Spring does not by default offer, you can\nimplement a `BeanPostProcessor` yourself. For more information, see\nxref:core/beans/factory-extension.adoc[Container Extension Points].\n\nIn addition to the initialization and destruction callbacks, Spring-managed objects may\nalso implement the `Lifecycle` interface so that those objects can participate in the\nstartup and shutdown process, as driven by the container's own lifecycle.\n\nThe lifecycle callback interfaces are described in this section.\n\n[[beans-factory-lifecycle-initializingbean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc", "title": "factory-nature", "heading": "Lifecycle Callbacks", "heading_level": 2, "file_order": 62, "section_index": 1, "content_hash": "fd9a5dc5db470869868791bbe6f4163e75fc20265f400c44791e5c2df3adf800", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc"}}
{"id": "sha256:29219c4565d40a779757aee819eb3e2d1c7340e3e1a6995d0f0b5483f265962a", "content": "The `org.springframework.beans.factory.InitializingBean` interface lets a bean\nperform initialization work after the container has set all necessary properties on the\nbean. The `InitializingBean` interface specifies a single method:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tvoid afterPropertiesSet() throws Exception;\n----\n\nWe recommend that you do not use the `InitializingBean` interface, because it\nunnecessarily couples the code to Spring. Alternatively, we suggest using\nthe xref:core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc[`@PostConstruct`] annotation or\nspecifying a POJO initialization method. In the case of XML-based configuration metadata,\nyou can use the `init-method` attribute to specify the name of the method that has a void\nno-argument signature. With Java configuration, you can use the `initMethod` attribute of\n`@Bean`. See xref:core/beans/java/bean-annotation.adoc#beans-java-lifecycle-callbacks[Receiving Lifecycle Callbacks]. Consider the following example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/>\n----\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ExampleBean {\n\n public void init() {\n // do some initialization work\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ExampleBean {\n\n fun init() {\n // do some initialization work\n }\n\t}\n----\n======\n\nThe preceding example has almost exactly the same effect as the following example\n(which consists of two listings):\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exampleInitBean\" class=\"examples.AnotherExampleBean\"/>\n----\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class AnotherExampleBean implements InitializingBean {\n\n @Override\n public void afterPropertiesSet() {\n // do some initialization work\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass AnotherExampleBean : InitializingBean {\n\n override fun afterPropertiesSet() {\n // do some initialization work\n }\n\t}\n----\n======\n\nHowever, the first of the two preceding examples does not couple the code to Spring.\n\n[NOTE]\n====\nBe aware that `@PostConstruct` and initialization methods in general are executed\nwithin the container's singleton creation lock. The bean instance is only considered\nas fully initialized and ready to be published to others after returning from the\n`@PostConstruct` method. Such individual initialization methods are only meant\nfor validating the configuration state and possibly preparing some data structures\nbased on the given configuration but no further activity with external bean access.\nOtherwise there is a risk for an initialization deadlock.\n\nFor a scenario where expensive post-initialization activity is to be triggered,\nfor example, asynchronous database preparation steps, your bean should either implement\n`SmartInitializingSingleton.afterSingletonsInstantiated()` or rely on the context\nrefresh event: implementing `ApplicationListener<ContextRefreshedEvent>` or\ndeclaring its annotation equivalent `@EventListener(ContextRefreshedEvent.class)`.\nThose variants come after all regular singleton initialization and therefore\noutside of any singleton creation lock.\n\nAlternatively, you may implement the `(Smart)Lifecycle` interface and integrate with\nthe container's overall lifecycle management, including an auto-startup mechanism,\na pre-destroy stop step, and potential stop/restart callbacks (see below).\n====\n\n[[beans-factory-lifecycle-disposablebean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc", "title": "factory-nature", "heading": "Initialization Callbacks", "heading_level": 3, "file_order": 62, "section_index": 2, "content_hash": "29219c4565d40a779757aee819eb3e2d1c7340e3e1a6995d0f0b5483f265962a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc"}}
{"id": "sha256:8bd6c20b66abfb7b679490d72185999597faa51c221b5a2d73a769a11341c63a", "content": "Implementing the `org.springframework.beans.factory.DisposableBean` interface lets a\nbean get a callback when the container that contains it is destroyed. The\n`DisposableBean` interface specifies a single method:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tvoid destroy() throws Exception;\n----\n\nWe recommend that you do not use the `DisposableBean` callback interface, because it\nunnecessarily couples the code to Spring. Alternatively, we suggest using\nthe xref:core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc[`@PreDestroy`] annotation or\nspecifying a generic method that is supported by bean definitions. With XML-based\nconfiguration metadata, you can use the `destroy-method` attribute on the `<bean/>`.\nWith Java configuration, you can use the `destroyMethod` attribute of `@Bean`. See\nxref:core/beans/java/bean-annotation.adoc#beans-java-lifecycle-callbacks[Receiving Lifecycle Callbacks]. Consider the following definition:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exampleDestructionBean\" class=\"examples.ExampleBean\" destroy-method=\"cleanup\"/>\n----\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ExampleBean {\n\n public void cleanup() {\n // do some destruction work (like releasing pooled connections)\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ExampleBean {\n\n fun cleanup() {\n // do some destruction work (like releasing pooled connections)\n }\n\t}\n----\n======\n\nThe preceding definition has almost exactly the same effect as the following definition:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exampleDestructionBean\" class=\"examples.AnotherExampleBean\"/>\n----\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class AnotherExampleBean implements DisposableBean {\n\n @Override\n public void destroy() {\n // do some destruction work (like releasing pooled connections)\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass AnotherExampleBean : DisposableBean {\n\n override fun destroy() {\n // do some destruction work (like releasing pooled connections)\n }\n\t}\n----\n======\n\nHowever, the first of the two preceding definitions does not couple the code to Spring.\n\nNote that Spring also supports inference of destroy methods, detecting a public `close` or\n`shutdown` method. This is the default behavior for `@Bean` methods in Java configuration\nclasses and automatically matches `java.lang.AutoCloseable` or `java.io.Closeable`\nimplementations, not coupling the destruction logic to Spring either.\n\nTIP: For destroy method inference with XML, you may assign the `destroy-method` attribute\nof a `<bean>` element a special `(inferred)` value, which instructs Spring to automatically\ndetect a public `close` or `shutdown` method on the bean class for a specific bean definition.\nYou can also set this special `(inferred)` value on the `default-destroy-method` attribute\nof a `<beans>` element to apply this behavior to an entire set of bean definitions (see\nxref:core/beans/factory-nature.adoc#beans-factory-lifecycle-default-init-destroy-methods[Default Initialization and Destroy Methods]).\n\n[NOTE]\n====\nFor extended shutdown phases, you may implement the `Lifecycle` interface and receive\nan early stop signal before the destroy methods of any singleton beans are called.\nYou may also implement `SmartLifecycle` for a time-bound stop step where the container\nwill wait for all such stop processing to complete before moving on to destroy methods.\n====\n\n[[beans-factory-lifecycle-default-init-destroy-methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc", "title": "factory-nature", "heading": "Destruction Callbacks", "heading_level": 3, "file_order": 62, "section_index": 3, "content_hash": "8bd6c20b66abfb7b679490d72185999597faa51c221b5a2d73a769a11341c63a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc"}}
{"id": "sha256:46d4502207dd492a50cfd9b411bc127cb6925189a4289f8d6a850b80e5114738", "content": "When you write initialization and destroy method callbacks that do not use the\nSpring-specific `InitializingBean` and `DisposableBean` callback interfaces, you\ntypically write methods with names such as `init()`, `initialize()`, `dispose()`,\nand so on. Ideally, the names of such lifecycle callback methods are standardized across\na project so that all developers use the same method names and ensure consistency.\n\nYou can configure the Spring container to \"`look`\" for named initialization and destroy\ncallback method names on every bean. This means that you, as an application developer,\ncan write your application classes and use an initialization callback called `init()`,\nwithout having to configure an `init-method=\"init\"` attribute with each bean definition.\nThe Spring IoC container calls that method when the bean is created (and in accordance\nwith the standard lifecycle callback contract xref:core/beans/factory-nature.adoc#beans-factory-lifecycle[described previously]).\nThis feature also enforces a consistent naming convention for initialization and\ndestroy method callbacks.\n\nSuppose that your initialization callback methods are named `init()` and your destroy\ncallback methods are named `destroy()`. Your class then resembles the class in the\nfollowing example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class DefaultBlogService implements BlogService {\n\n private BlogDao blogDao;\n\n public void setBlogDao(BlogDao blogDao) {\n this.blogDao = blogDao;\n }\n\n // this is (unsurprisingly) the initialization callback method\n public void init() {\n if (this.blogDao == null) {\n throw new IllegalStateException(\"The [blogDao] property must be set.\");\n }\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass DefaultBlogService : BlogService {\n\n private var blogDao: BlogDao? = null\n\n // this is (unsurprisingly) the initialization callback method\n fun init() {\n if (blogDao == null) {\n throw IllegalStateException(\"The [blogDao] property must be set.\")\n }\n }\n\t}\n----\n======\n\nYou could then use that class in a bean resembling the following:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans default-init-method=\"init\">\n\n <bean id=\"blogService\" class=\"com.something.DefaultBlogService\">\n <property name=\"blogDao\" ref=\"blogDao\" />\n </bean>\n\n\t</beans>\n----\n\nThe presence of the `default-init-method` attribute on the top-level `<beans/>` element\nattribute causes the Spring IoC container to recognize a method called `init` on the bean\nclass as the initialization method callback. When a bean is created and assembled, if the\nbean class has such a method, it is invoked at the appropriate time.\n\nYou can configure destroy method callbacks similarly (in XML, that is) by using the\n`default-destroy-method` attribute on the top-level `<beans/>` element.\n\nWhere existing bean classes already have callback methods that are named at variance\nwith the convention, you can override the default by specifying (in XML, that is) the\nmethod name by using the `init-method` and `destroy-method` attributes of the `<bean/>`\nitself.\n\nThe Spring container guarantees that a configured initialization callback is called\nimmediately after a bean is supplied with all dependencies. Thus, the initialization\ncallback is called on the raw bean reference, which means that AOP interceptors and so\nforth are not yet applied to the bean. A target bean is fully created first and\nthen an AOP proxy (for example) with its interceptor chain is applied. If the target\nbean and the proxy are defined separately, your code can even interact with the raw\ntarget bean, bypassing the proxy. Hence, it would be inconsistent to apply the\ninterceptors to the `init` method, because doing so would couple the lifecycle of the\ntarget bean to its proxy or interceptors and leave strange semantics when your code\ninteracts directly with the raw target bean.\n\n[[beans-factory-lifecycle-combined-effects]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc", "title": "factory-nature", "heading": "Default Initialization and Destroy Methods", "heading_level": 3, "file_order": 62, "section_index": 4, "content_hash": "46d4502207dd492a50cfd9b411bc127cb6925189a4289f8d6a850b80e5114738", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc"}}
{"id": "sha256:ac534829be05dc034eca48ea7033262ffbb5d4be50e821ec5b3d292f5e39b3d2", "content": "As of Spring 2.5, you have three options for controlling bean lifecycle behavior:\n\n* The xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-initializingbean[`InitializingBean`] and\nxref:core/beans/factory-nature.adoc#beans-factory-lifecycle-disposablebean[`DisposableBean`] callback interfaces\n* Custom `init()` and `destroy()` methods\n* The xref:core/beans/annotation-config/postconstruct-and-predestroy-annotations.adoc[`@PostConstruct` and `@PreDestroy` annotations]\n. You can combine these mechanisms to control a given bean.\n\nNOTE: If multiple lifecycle mechanisms are configured for a bean and each mechanism is\nconfigured with a different method name, then each configured method is run in the\norder listed after this note. However, if the same method name is configured -- for example,\n`init()` for an initialization method -- for more than one of these lifecycle mechanisms,\nthat method is run once, as explained in the\nxref:core/beans/factory-nature.adoc#beans-factory-lifecycle-default-init-destroy-methods[preceding section].\n\nMultiple lifecycle mechanisms configured for the same bean, with different\ninitialization methods, are called as follows:\n\n. Methods annotated with `@PostConstruct`\n. `afterPropertiesSet()` as defined by the `InitializingBean` callback interface\n. A custom configured `init()` method\n\nDestroy methods are called in the same order:\n\n. Methods annotated with `@PreDestroy`\n. `destroy()` as defined by the `DisposableBean` callback interface\n. A custom configured `destroy()` method\n\n[[beans-factory-lifecycle-processor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc", "title": "factory-nature", "heading": "Combining Lifecycle Mechanisms", "heading_level": 3, "file_order": 62, "section_index": 5, "content_hash": "ac534829be05dc034eca48ea7033262ffbb5d4be50e821ec5b3d292f5e39b3d2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc"}}
{"id": "sha256:5a11058e2433a97c02f88886b113340b8e3e39f45cf3ce55f7d8454ad7280020", "content": "The `Lifecycle` interface defines the essential methods for any object that has its own\nlifecycle requirements (such as starting and stopping some background process):\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface Lifecycle {\n\n void start();\n\n void stop();\n\n boolean isRunning();\n\t}\n----\n\nAny Spring-managed object may implement the `Lifecycle` interface. Then, when the\n`ApplicationContext` itself receives start and stop signals (for example, for a stop/restart\nscenario at runtime), it cascades those calls to all `Lifecycle` implementations\ndefined within that context. It does this by delegating to a `LifecycleProcessor`, shown\nin the following listing:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface LifecycleProcessor extends Lifecycle {\n\n void onRefresh();\n\n void onClose();\n\t}\n----\n\nNotice that the `LifecycleProcessor` is itself an extension of the `Lifecycle`\ninterface. It also adds two other methods for reacting to the context being refreshed\nand closed.\n\n[TIP]\n====\nNote that the regular `org.springframework.context.Lifecycle` interface is a plain\ncontract for explicit start and stop notifications and does not imply auto-startup\nat context refresh time. For fine-grained control over auto-startup and for graceful\nstopping of a specific bean (including startup and stop phases), consider implementing\nthe extended `org.springframework.context.SmartLifecycle` interface instead.\n\nAlso, please note that stop notifications are not guaranteed to come before destruction.\nOn regular shutdown, all `Lifecycle` beans first receive a stop notification before\nthe general destruction callbacks are being propagated. However, on hot refresh during\na context's lifetime or on stopped refresh attempts, only destroy methods are called.\n====\n\nThe order of startup and shutdown invocations can be important. If a \"`depends-on`\"\nrelationship exists between any two objects, the dependent side starts after its\ndependency, and it stops before its dependency. However, at times, the direct\ndependencies are unknown. You may only know that objects of a certain type should start\nprior to objects of another type. In those cases, the `SmartLifecycle` interface defines\nanother option, namely the `getPhase()` method as defined on its super-interface,\n`Phased`. The following listing shows the definition of the `Phased` interface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface Phased {\n\n int getPhase();\n\t}\n----\n\nThe following listing shows the definition of the `SmartLifecycle` interface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface SmartLifecycle extends Lifecycle, Phased {\n\n boolean isAutoStartup();\n\n void stop(Runnable callback);\n\t}\n----\n\nWhen starting, the objects with the lowest phase start first. When stopping, the\nreverse order is followed. Therefore, an object that implements `SmartLifecycle` and\nwhose `getPhase()` method returns `Integer.MIN_VALUE` would be among the first to start\nand the last to stop. At the other end of the spectrum, a phase value of\n`Integer.MAX_VALUE` would indicate that the object should be started last and stopped\nfirst (likely because it depends on other processes to be running). When considering the\nphase value, it is also important to know that the default phase for any \"`normal`\"\n`Lifecycle` object that does not implement `SmartLifecycle` is `0`. Therefore, any\nnegative phase value indicates that an object should start before those standard\ncomponents (and stop after them). The reverse is true for any positive phase value.\n\nThe stop method defined by `SmartLifecycle` accepts a callback. Any\nimplementation must invoke that callback's `run()` method after that implementation's\nshutdown process is complete. That enables asynchronous shutdown where necessary, since\nthe default implementation of the `LifecycleProcessor` interface,\n`DefaultLifecycleProcessor`, waits up to its timeout value for the group of objects\nwithin each phase to invoke that callback. The default per-phase timeout is 30 seconds.\nYou can override the default lifecycle processor instance by defining a bean named\n`lifecycleProcessor` within the context. If you want only to modify the timeout,\ndefining the following would suffice:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"lifecycleProcessor\" class=\"org.springframework.context.support.DefaultLifecycleProcessor\">\n <!-- timeout value in milliseconds -->\n <property name=\"timeoutPerShutdownPhase\" value=\"10000\"/>\n\t</bean>\n----\n\nAs mentioned earlier, the `LifecycleProcessor` interface defines callback methods for the\nrefreshing and closing of the context as well. The latter drives the shutdown\nprocess as if `stop()` had been called explicitly, but it happens when the context is\nclosing. The 'refresh' callback, on the other hand, enables another feature of\n`SmartLifecycle` beans. When the context is refreshed (after all objects have been\ninstantiated and initialized), that callback is invoked. At that point, the\ndefault lifecycle processor checks the boolean value returned by each\n`SmartLifecycle` object's `isAutoStartup()` method. If `true`, that object is\nstarted at that point rather than waiting for an explicit invocation of the context's or\nits own `start()` method (unlike the context refresh, the context start does not happen\nautomatically for a standard context implementation). The `phase` value and any\n\"`depends-on`\" relationships determine the startup order as described earlier.\n\n[[beans-factory-shutdown]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc", "title": "factory-nature", "heading": "Startup and Shutdown Callbacks", "heading_level": 3, "file_order": 62, "section_index": 6, "content_hash": "5a11058e2433a97c02f88886b113340b8e3e39f45cf3ce55f7d8454ad7280020", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc"}}
{"id": "sha256:2f4438c9bacb6c25147d5ed152b1a48c035427cfa3c14628cd7673952787b38c", "content": "[NOTE]\n====\nThis section applies only to non-web applications. Spring's web-based\n`ApplicationContext` implementations already have code in place to gracefully shut down\nthe Spring IoC container when the relevant web application is shut down.\n====\n\nIf you use Spring's IoC container in a non-web application environment (for\nexample, in a rich client desktop environment), register a shutdown hook with the\nJVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your\nsingleton beans so that all resources are released. You must still configure\nand implement these destroy callbacks correctly.\n\nTo register a shutdown hook, call the `registerShutdownHook()` method that is\ndeclared on the `ConfigurableApplicationContext` interface, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.context.ConfigurableApplicationContext;\n\timport org.springframework.context.support.ClassPathXmlApplicationContext;\n\n\tpublic final class Boot {\n\n public static void main(final String[] args) throws Exception {\n ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\");\n\n // add a shutdown hook for the above context...\n ctx.registerShutdownHook();\n\n // app runs here...\n\n // main method exits, hook is called prior to the app shutting down...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.context.support.ClassPathXmlApplicationContext\n\n\tfun main() {\n val ctx = ClassPathXmlApplicationContext(\"beans.xml\")\n\n // add a shutdown hook for the above context...\n ctx.registerShutdownHook()\n\n // app runs here...\n\n // main method exits, hook is called prior to the app shutting down...\n\t}\n----\n======\n\n[[beans-factory-thread-safety]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc", "title": "factory-nature", "heading": "Shutting Down the Spring IoC Container Gracefully in Non-Web Applications", "heading_level": 3, "file_order": 62, "section_index": 7, "content_hash": "2f4438c9bacb6c25147d5ed152b1a48c035427cfa3c14628cd7673952787b38c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc"}}
{"id": "sha256:d6b0a0170b74ac03038232b62401be8101884fa8229aca3f5e59ba6f7eaee3d2", "content": "The Spring core container publishes created singleton instances in a thread-safe manner,\nguarding access through a singleton lock and guaranteeing visibility in other threads.\n\nAs a consequence, application-provided bean classes do not have to be concerned about the\nvisibility of their initialization state. Regular configuration fields do not have to be\nmarked as `volatile` as long as they are only mutated during the initialization phase,\nproviding visibility guarantees similar to `final` even for setter-based configuration\nstate that is mutable during that initial phase. If such fields get changed after the\nbean creation phase and its subsequent initial publication, they need to be declared as\n`volatile` or guarded by a common lock whenever accessed.\n\nNote that concurrent access to such configuration state in singleton bean instances,\nfor example, for controller instances or repository instances, is perfectly thread-safe after\nsuch safe initial publication from the container side. This includes common singleton\n`FactoryBean` instances which are processed within the general singleton lock as well.\n\nFor destruction callbacks, the configuration state remains thread-safe but any runtime\nstate accumulated between initialization and destruction should be kept in thread-safe\nstructures (or in `volatile` fields for simple cases) as per common Java guidelines.\n\nDeeper `Lifecycle` integration as shown above involves runtime-mutable state such as\na `runnable` field which will have to be declared as `volatile`. While the common\nlifecycle callbacks follow a certain order, for example, a start callback is guaranteed to\nonly happen after full initialization and a stop callback only after an initial start,\nthere is a special case with the common stop before destroy arrangement: It is strongly\nrecommended that the internal state in any such bean also allows for an immediate\ndestroy callback without a preceding stop since this may happen during an extraordinary\nshutdown after a cancelled bootstrap or in case of a stop timeout caused by another bean.\n\n[[beans-factory-aware]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc", "title": "factory-nature", "heading": "Thread Safety and Visibility", "heading_level": 3, "file_order": 62, "section_index": 8, "content_hash": "d6b0a0170b74ac03038232b62401be8101884fa8229aca3f5e59ba6f7eaee3d2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc"}}
{"id": "sha256:57db9e2e3a9da0c8bba725f834d1b66d74580c821f6a63a9f6d7c892d1d5a799", "content": "When an `ApplicationContext` creates an object instance that implements the\n`org.springframework.context.ApplicationContextAware` interface, the instance is provided\nwith a reference to that `ApplicationContext`. The following listing shows the definition\nof the `ApplicationContextAware` interface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface ApplicationContextAware {\n\n void setApplicationContext(ApplicationContext applicationContext) throws BeansException;\n\t}\n----\n\nThus, beans can programmatically manipulate the `ApplicationContext` that created them,\nthrough the `ApplicationContext` interface or by casting the reference to a known\nsubclass of this interface (such as `ConfigurableApplicationContext`, which exposes\nadditional functionality). One use would be the programmatic retrieval of other beans.\nSometimes this capability is useful. However, in general, you should avoid it, because\nit couples the code to Spring and does not follow the Inversion of Control style,\nwhere collaborators are provided to beans as properties. Other methods of the\n`ApplicationContext` provide access to file resources, publishing application events,\nand accessing a `MessageSource`. These additional features are described in\nxref:core/beans/context-introduction.adoc[Additional Capabilities of the `ApplicationContext`].\n\nAutowiring is another alternative to obtain a reference to the\n`ApplicationContext`. The _traditional_ `constructor` and `byType` autowiring modes\n(as described in xref:core/beans/dependencies/factory-autowire.adoc[Autowiring Collaborators]) can provide a dependency of type\n`ApplicationContext` for a constructor argument or a setter method parameter,\nrespectively. For more flexibility, including the ability to autowire fields and\nmultiple parameter methods, use the annotation-based autowiring features. If you do,\nthe `ApplicationContext` is autowired into a field, constructor argument, or method\nparameter that expects the `ApplicationContext` type if the field, constructor, or\nmethod in question carries the `@Autowired` annotation. For more information, see\nxref:core/beans/annotation-config/autowired.adoc[Using `@Autowired`].\n\nWhen an `ApplicationContext` creates a class that implements the\n`org.springframework.beans.factory.BeanNameAware` interface, the class is provided with\na reference to the name defined in its associated object definition. The following listing\nshows the definition of the BeanNameAware interface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface BeanNameAware {\n\n void setBeanName(String name) throws BeansException;\n\t}\n----\n\nThe callback is invoked after population of normal bean properties but before an\ninitialization callback such as `InitializingBean.afterPropertiesSet()` or a custom\ninit-method.\n\n[[aware-list]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc", "title": "factory-nature", "heading": "`ApplicationContextAware` and `BeanNameAware`", "heading_level": 2, "file_order": 62, "section_index": 9, "content_hash": "57db9e2e3a9da0c8bba725f834d1b66d74580c821f6a63a9f6d7c892d1d5a799", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc"}}
{"id": "sha256:5e519509cfc55ae1c78d06e7e7721adac444f12f934f6eaae53987ff99aafc78", "content": "Besides `ApplicationContextAware` and `BeanNameAware` (discussed xref:core/beans/factory-nature.adoc#beans-factory-aware[earlier]),\nSpring offers a wide range of `Aware` callback interfaces that let beans indicate to the container\nthat they require a certain infrastructure dependency. As a general rule, the name indicates the\ndependency type. The following table summarizes the most important `Aware` interfaces:\n\n[[beans-factory-nature-aware-list]]\n.Aware interfaces\n|===\n| Name| Injected Dependency| Explained in...\n\n| `ApplicationContextAware`\n| Declaring `ApplicationContext`.\n| xref:core/beans/factory-nature.adoc#beans-factory-aware[`ApplicationContextAware` and `BeanNameAware`]\n\n| `ApplicationEventPublisherAware`\n| Event publisher of the enclosing `ApplicationContext`.\n| xref:core/beans/context-introduction.adoc[Additional Capabilities of the `ApplicationContext`]\n\n| `BeanClassLoaderAware`\n| Class loader used to load the bean classes.\n| xref:core/beans/definition.adoc#beans-factory-class[Instantiating Beans]\n\n| `BeanFactoryAware`\n| Declaring `BeanFactory`.\n| xref:core/beans/beanfactory.adoc[The `BeanFactory` API]\n\n| `BeanNameAware`\n| Name of the declaring bean.\n| xref:core/beans/factory-nature.adoc#beans-factory-aware[`ApplicationContextAware` and `BeanNameAware`]\n\n| `LoadTimeWeaverAware`\n| Defined weaver for processing class definition at load time.\n| xref:core/aop/using-aspectj.adoc#aop-aj-ltw[Load-time Weaving with AspectJ in the Spring Framework]\n\n| `MessageSourceAware`\n| Configured strategy for resolving messages (with support for parameterization and\n internationalization).\n| xref:core/beans/context-introduction.adoc[Additional Capabilities of the `ApplicationContext`]\n\n| `NotificationPublisherAware`\n| Spring JMX notification publisher.\n| xref:integration/jmx/notifications.adoc[Notifications]\n\n| `ResourceLoaderAware`\n| Configured loader for low-level access to resources.\n| xref:web/webflux-webclient/client-builder.adoc#webflux-client-builder-reactor-resources[Resources]\n\n| `ServletConfigAware`\n| Current `ServletConfig` the container runs in. Valid only in a web-aware Spring\n `ApplicationContext`.\n| xref:web/webmvc.adoc#mvc[Spring MVC]\n\n| `ServletContextAware`\n| Current `ServletContext` the container runs in. Valid only in a web-aware Spring\n `ApplicationContext`.\n| xref:web/webmvc.adoc#mvc[Spring MVC]\n|===\n\nNote again that using these interfaces ties your code to the Spring API and does not\nfollow the Inversion of Control style. As a result, we recommend them for infrastructure\nbeans that require programmatic access to the container.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc", "title": "factory-nature", "heading": "Other `Aware` Interfaces", "heading_level": 2, "file_order": 62, "section_index": 10, "content_hash": "5e519509cfc55ae1c78d06e7e7721adac444f12f934f6eaae53987ff99aafc78", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-nature.adoc"}}
{"id": "sha256:6b1ff5d9c35af667423bb57dc1d9348fb11a41986304e50a6c62a6a3b82fa02d", "content": "[[beans-factory-scopes]]\n\nWhen you create a bean definition, you create a recipe for creating actual instances\nof the class defined by that bean definition. The idea that a bean definition is a\nrecipe is important, because it means that, as with a class, you can create many object\ninstances from a single recipe.\n\nYou can control not only the various dependencies and configuration values that are to\nbe plugged into an object that is created from a particular bean definition but also control\nthe scope of the objects created from a particular bean definition. This approach is\npowerful and flexible, because you can choose the scope of the objects you create\nthrough configuration instead of having to bake in the scope of an object at the Java\nclass level. Beans can be defined to be deployed in one of a number of scopes.\nThe Spring Framework supports six scopes, four of which are available only if\nyou use a web-aware `ApplicationContext`. You can also create\nxref:core/beans/factory-scopes.adoc#beans-factory-scopes-custom[a custom scope.]\n\nThe following table describes the supported scopes:\n\n[[beans-factory-scopes-tbl]]\n.Bean scopes\n[cols=\"20%,80%\"]\n|===\n| Scope| Description\n\n| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-singleton[singleton]\n| (Default) Scopes a single bean definition to a single object instance for each Spring IoC\n container.\n\n| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-prototype[prototype]\n| Scopes a single bean definition to any number of object instances.\n\n| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-request[request]\n| Scopes a single bean definition to the lifecycle of a single HTTP request. That is,\n each HTTP request has its own instance of a bean created off the back of a single bean\n definition. Only valid in the context of a web-aware Spring `ApplicationContext`.\n\n| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-session[session]\n| Scopes a single bean definition to the lifecycle of an HTTP `Session`. Only valid in\n the context of a web-aware Spring `ApplicationContext`.\n\n| xref:core/beans/factory-scopes.adoc#beans-factory-scopes-application[application]\n| Scopes a single bean definition to the lifecycle of a `ServletContext`. Only valid in\n the context of a web-aware Spring `ApplicationContext`.\n\n| xref:web/websocket/stomp/scope.adoc[websocket]\n| Scopes a single bean definition to the lifecycle of a `WebSocket`. Only valid in\n the context of a web-aware Spring `ApplicationContext`.\n|===\n\nNOTE: A thread scope is available but is not registered by default. For more information,\nsee the documentation for\n{spring-framework-api}/context/support/SimpleThreadScope.html[`SimpleThreadScope`].\nFor instructions on how to register this or any other custom scope, see\nxref:core/beans/factory-scopes.adoc#beans-factory-scopes-custom-using[Using a Custom Scope].\n\n[[beans-factory-scopes-singleton]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "factory-scopes", "heading_level": 1, "file_order": 63, "section_index": 0, "content_hash": "6b1ff5d9c35af667423bb57dc1d9348fb11a41986304e50a6c62a6a3b82fa02d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:9aa613ea85e604227103c47cdb642aebbe1ca183f0ee0820a6c2beed7f3d1192", "content": "Only one shared instance of a singleton bean is managed, and all requests for beans\nwith an ID or IDs that match that bean definition result in that one specific bean\ninstance being returned by the Spring container.\n\nTo put it another way, when you define a bean definition and it is scoped as a\nsingleton, the Spring IoC container creates exactly one instance of the object\ndefined by that bean definition. This single instance is stored in a cache of such\nsingleton beans, and all subsequent requests and references for that named bean\nreturn the cached object. The following image shows how the singleton scope works:\n\nimage::singleton.png[]\n\nSpring's concept of a singleton bean differs from the singleton pattern as defined in\nthe Gang of Four (GoF) patterns book. The GoF singleton hard-codes the scope of an\nobject such that one and only one instance of a particular class is created per\nClassLoader. The scope of the Spring singleton is best described as being per-container\nand per-bean. This means that, if you define one bean for a particular class in a\nsingle Spring container, the Spring container creates one and only one instance\nof the class defined by that bean definition. The singleton scope is the default scope\nin Spring. To define a bean as a singleton in XML, you can define a bean as shown in the\nfollowing example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"accountService\" class=\"com.something.DefaultAccountService\"/>\n\n\t<!-- the following is equivalent, though redundant (singleton scope is the default) -->\n\t<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"singleton\"/>\n----\n\n[[beans-factory-scopes-prototype]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "The Singleton Scope", "heading_level": 2, "file_order": 63, "section_index": 1, "content_hash": "9aa613ea85e604227103c47cdb642aebbe1ca183f0ee0820a6c2beed7f3d1192", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:66756812ac298afa2efe2bc1e76c26e0c65e56df618de13c5f9b7b0c2cd8b232", "content": "The non-singleton prototype scope of bean deployment results in the creation of a new\nbean instance every time a request for that specific bean is made. That is, the bean\nis injected into another bean or you request it through a `getBean()` method call on the\ncontainer. As a rule, you should use the prototype scope for all stateful beans and the\nsingleton scope for stateless beans.\n\nThe following diagram illustrates the Spring prototype scope:\n\nimage::prototype.png[]\n\n(A data access object\n(DAO) is not typically configured as a prototype, because a typical DAO does not hold\nany conversational state. It was easier for us to reuse the core of the\nsingleton diagram.)\n\nThe following example defines a bean as a prototype in XML:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/>\n----\n\nIn contrast to the other scopes, Spring does not manage the complete lifecycle of a\nprototype bean. The container instantiates, configures, and otherwise assembles a\nprototype object and hands it to the client, with no further record of that prototype\ninstance. Thus, although initialization lifecycle callback methods are called on all\nobjects regardless of scope, in the case of prototypes, configured destruction\nlifecycle callbacks are not called. The client code must clean up prototype-scoped\nobjects and release expensive resources that the prototype beans hold. To get\nthe Spring container to release resources held by prototype-scoped beans, try using a\ncustom xref:core/beans/factory-extension.adoc#beans-factory-extension-bpp[bean post-processor]\nwhich holds a reference to beans that need to be cleaned up.\n\nIn some respects, the Spring container's role in regard to a prototype-scoped bean is a\nreplacement for the Java `new` operator. All lifecycle management past that point must\nbe handled by the client. (For details on the lifecycle of a bean in the Spring\ncontainer, see xref:core/beans/factory-nature.adoc#beans-factory-lifecycle[Lifecycle Callbacks].)\n\n[[beans-factory-scopes-sing-prot-interaction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "The Prototype Scope", "heading_level": 2, "file_order": 63, "section_index": 2, "content_hash": "66756812ac298afa2efe2bc1e76c26e0c65e56df618de13c5f9b7b0c2cd8b232", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:84493a20b4e16b3eee9eb3e4773e68fd5421fd1d65e9a3d82a4a5e03dd5d3d1a", "content": "When you use singleton-scoped beans with dependencies on prototype beans, be aware that\ndependencies are resolved at instantiation time. Thus, if you dependency-inject a\nprototype-scoped bean into a singleton-scoped bean, a new prototype bean is instantiated\nand then dependency-injected into the singleton bean. The prototype instance is the sole\ninstance that is ever supplied to the singleton-scoped bean.\n\nHowever, suppose you want the singleton-scoped bean to acquire a new instance of the\nprototype-scoped bean repeatedly at runtime. You cannot dependency-inject a\nprototype-scoped bean into your singleton bean, because that injection occurs only\nonce, when the Spring container instantiates the singleton bean and resolves\nand injects its dependencies. If you need a new instance of a prototype bean at\nruntime more than once, see xref:core/beans/dependencies/factory-method-injection.adoc[Method Injection].\n\n[[beans-factory-scopes-other]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "Singleton Beans with Prototype-bean Dependencies", "heading_level": 2, "file_order": 63, "section_index": 3, "content_hash": "84493a20b4e16b3eee9eb3e4773e68fd5421fd1d65e9a3d82a4a5e03dd5d3d1a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:8dc9ea95f163f9b5df4f2f8a3326355b0e7e31a0811db6422356e2d1711fc9d3", "content": "The `request`, `session`, `application`, and `websocket` scopes are available only\nif you use a web-aware Spring `ApplicationContext` implementation (such as\n`XmlWebApplicationContext`). If you use these scopes with regular Spring IoC containers,\nsuch as the `ClassPathXmlApplicationContext`, an `IllegalStateException` that complains\nabout an unknown bean scope is thrown.\n\n[[beans-factory-scopes-other-web-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "Request, Session, Application, and WebSocket Scopes", "heading_level": 2, "file_order": 63, "section_index": 4, "content_hash": "8dc9ea95f163f9b5df4f2f8a3326355b0e7e31a0811db6422356e2d1711fc9d3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:e8f59719e35f89f47451b8c808924fa4ca867674e6731bbcd9e1a2f677e5206b", "content": "To support the scoping of beans at the `request`, `session`, `application`, and\n`websocket` levels (web-scoped beans), some minor initial configuration is\nrequired before you define your beans. (This initial setup is not required\nfor the standard scopes: `singleton` and `prototype`.)\n\nHow you accomplish this initial setup depends on your particular Servlet environment.\n\nIf you access scoped beans within Spring Web MVC, in effect, within a request that is\nprocessed by the Spring `DispatcherServlet`, no special setup is necessary.\n`DispatcherServlet` already exposes all relevant state.\n\nIf you use a Servlet web container, with requests processed outside of Spring's\n`DispatcherServlet` (for example, when using JSF), you need to register the\n`org.springframework.web.context.request.RequestContextListener` `ServletRequestListener`.\nThis can be done programmatically by using the `WebApplicationInitializer` interface.\nAlternatively, add the following declaration to your web application's `web.xml` file:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<web-app>\n ...\n <listener>\n <listener-class>\n org.springframework.web.context.request.RequestContextListener\n </listener-class>\n </listener>\n ...\n\t</web-app>\n----\n\nAlternatively, if there are issues with your listener setup, consider using Spring's\n`RequestContextFilter`. The filter mapping depends on the surrounding web\napplication configuration, so you have to change it as appropriate. The following listing\nshows the filter part of a web application:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<web-app>\n ...\n <filter>\n <filter-name>requestContextFilter</filter-name>\n <filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>\n </filter>\n <filter-mapping>\n <filter-name>requestContextFilter</filter-name>\n <url-pattern>/*</url-pattern>\n </filter-mapping>\n ...\n\t</web-app>\n----\n\n`DispatcherServlet`, `RequestContextListener`, and `RequestContextFilter` all do exactly\nthe same thing, namely bind the HTTP request object to the `Thread` that is servicing\nthat request. This makes beans that are request- and session-scoped available further\ndown the call chain.\n\n[[beans-factory-scopes-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "Initial Web Configuration", "heading_level": 3, "file_order": 63, "section_index": 5, "content_hash": "e8f59719e35f89f47451b8c808924fa4ca867674e6731bbcd9e1a2f677e5206b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:01826a791f99254dbc6b02a3d14e9dd0b42b1e1d2fe342f38e4226dd3acaf26c", "content": "Consider the following XML configuration for a bean definition:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"loginAction\" class=\"com.something.LoginAction\" scope=\"request\"/>\n----\n\nThe Spring container creates a new instance of the `LoginAction` bean by using the\n`loginAction` bean definition for each and every HTTP request. That is, the\n`loginAction` bean is scoped at the HTTP request level. You can change the internal\nstate of the instance that is created as much as you want, because other instances\ncreated from the same `loginAction` bean definition do not see these changes in state.\nThey are particular to an individual request. When the request completes processing, the\nbean that is scoped to the request is discarded.\n\nWhen using annotation-driven components or Java configuration, the `@RequestScope` annotation\ncan be used to assign a component to the `request` scope. The following example shows how\nto do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RequestScope\n\t@Component\n\tpublic class LoginAction {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RequestScope\n\t@Component\n\tclass LoginAction {\n // ...\n\t}\n----\n======\n\n[[beans-factory-scopes-session]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "Request scope", "heading_level": 3, "file_order": 63, "section_index": 6, "content_hash": "01826a791f99254dbc6b02a3d14e9dd0b42b1e1d2fe342f38e4226dd3acaf26c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:48b6ea37d4cc09999e1c4e9fdf43d143b77697e4ce751f823f22d7e207a70a82", "content": "Consider the following XML configuration for a bean definition:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"userPreferences\" class=\"com.something.UserPreferences\" scope=\"session\"/>\n----\n\nThe Spring container creates a new instance of the `UserPreferences` bean by using the\n`userPreferences` bean definition for the lifetime of a single HTTP `Session`. In other\nwords, the `userPreferences` bean is effectively scoped at the HTTP `Session` level. As\nwith request-scoped beans, you can change the internal state of the instance that is\ncreated as much as you want, knowing that other HTTP `Session` instances that are also\nusing instances created from the same `userPreferences` bean definition do not see these\nchanges in state, because they are particular to an individual HTTP `Session`. When the\nHTTP `Session` is eventually discarded, the bean that is scoped to that particular HTTP\n`Session` is also discarded.\n\nWhen using annotation-driven components or Java configuration, you can use the\n`@SessionScope` annotation to assign a component to the `session` scope.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SessionScope\n\t@Component\n\tpublic class UserPreferences {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SessionScope\n\t@Component\n\tclass UserPreferences {\n // ...\n\t}\n----\n======\n\n[[beans-factory-scopes-application]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "Session Scope", "heading_level": 3, "file_order": 63, "section_index": 7, "content_hash": "48b6ea37d4cc09999e1c4e9fdf43d143b77697e4ce751f823f22d7e207a70a82", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:a85cdaef0ee95b91c1b3c4c9bc7e003f34928c5b294be3f060a6fb75dacd81ba", "content": "Consider the following XML configuration for a bean definition:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"appPreferences\" class=\"com.something.AppPreferences\" scope=\"application\"/>\n----\n\nThe Spring container creates a new instance of the `AppPreferences` bean by using the\n`appPreferences` bean definition once for the entire web application. That is, the\n`appPreferences` bean is scoped at the `ServletContext` level and stored as a regular\n`ServletContext` attribute. This is somewhat similar to a Spring singleton bean but\ndiffers in two important ways: It is a singleton per `ServletContext`, not per Spring\n`ApplicationContext` (for which there may be several in any given web application),\nand it is actually exposed and therefore visible as a `ServletContext` attribute.\n\nWhen using annotation-driven components or Java configuration, you can use the\n`@ApplicationScope` annotation to assign a component to the `application` scope. The\nfollowing example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ApplicationScope\n\t@Component\n\tpublic class AppPreferences {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ApplicationScope\n\t@Component\n\tclass AppPreferences {\n // ...\n\t}\n----\n======\n\n[[beans-factory-scopes-websocket]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "Application Scope", "heading_level": 3, "file_order": 63, "section_index": 8, "content_hash": "a85cdaef0ee95b91c1b3c4c9bc7e003f34928c5b294be3f060a6fb75dacd81ba", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:347380d9071677f63e67299402ea3f087f203855551719f32026d5a7f5f01176", "content": "WebSocket scope is associated with the lifecycle of a WebSocket session and applies to\nSTOMP over WebSocket applications, see\nxref:web/websocket/stomp/scope.adoc[WebSocket scope] for more details.\n\n[[beans-factory-scopes-other-injection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "WebSocket Scope", "heading_level": 3, "file_order": 63, "section_index": 9, "content_hash": "347380d9071677f63e67299402ea3f087f203855551719f32026d5a7f5f01176", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:157b34afb37aed37dd66fd677d6cb21140b3b1678006e065e05794b60b8c72f3", "content": "The Spring IoC container manages not only the instantiation of your objects (beans),\nbut also the wiring up of collaborators (or dependencies). If you want to inject (for\nexample) an HTTP request-scoped bean into another bean of a longer-lived scope, you may\nchoose to inject an AOP proxy in place of the scoped bean. That is, you need to inject\na proxy object that exposes the same public interface as the scoped object but that can\nalso retrieve the real target object from the relevant scope (such as an HTTP request)\nand delegate method calls onto the real object.\n\n[NOTE]\n====\nYou may also use `<aop:scoped-proxy/>` between beans that are scoped as `singleton`,\nwith the reference then going through an intermediate proxy that is serializable\nand therefore able to re-obtain the target singleton bean on deserialization.\n\nWhen declaring `<aop:scoped-proxy/>` against a bean of scope `prototype`, every method\ncall on the shared proxy leads to the creation of a new target instance to which the\ncall is then being forwarded.\n\nAlso, scoped proxies are not the only way to access beans from shorter scopes in a\nlifecycle-safe fashion. You may also declare your injection point (that is, the\nconstructor or setter argument or autowired field) as `ObjectFactory<MyTargetBean>`,\nallowing for a `getObject()` call to retrieve the current instance on demand every\ntime it is needed -- without holding on to the instance or storing it separately.\n\nAs an extended variant, you may declare `ObjectProvider<MyTargetBean>` which delivers\nseveral additional access variants, including `getIfAvailable` and `getIfUnique`.\n\nThe JSR-330 variant of this is called `Provider` and is used with a `Provider<MyTargetBean>`\ndeclaration and a corresponding `get()` call for every retrieval attempt.\nSee xref:core/beans/standard-annotations.adoc[here] for more details on JSR-330 overall.\n====\n\nThe configuration in the following example is only one line, but it is important to\nunderstand the \"`why`\" as well as the \"`how`\" behind it:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:aop=\"http://www.springframework.org/schema/aop\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/aop\n https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n <!-- an HTTP Session-scoped bean exposed as a proxy -->\n <bean id=\"userPreferences\" class=\"com.something.UserPreferences\" scope=\"session\">\n <!-- instructs the container to proxy the surrounding bean -->\n <aop:scoped-proxy/> <1>\n </bean>\n\n <!-- a singleton-scoped bean injected with a proxy to the above bean -->\n <bean id=\"userService\" class=\"com.something.SimpleUserService\">\n <!-- a reference to the proxied userPreferences bean -->\n <property name=\"userPreferences\" ref=\"userPreferences\"/>\n </bean>\n\t</beans>\n----\n<1> The line that defines the proxy.\n\nTo create such a proxy, you insert a child `<aop:scoped-proxy/>` element into a\nscoped bean definition (see\nxref:core/beans/factory-scopes.adoc#beans-factory-scopes-other-injection-proxies[Choosing the Type of Proxy to Create]\nand xref:core/appendix/xsd-schemas.adoc[XML Schema-based configuration]).\n\nWhy do definitions of beans scoped at the `request`, `session` and custom-scope\nlevels require the `<aop:scoped-proxy/>` element in common scenarios?\nConsider the following singleton bean definition and contrast it with\nwhat you need to define for the aforementioned scopes (note that the following\n`userPreferences` bean definition as it stands is incomplete):\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"userPreferences\" class=\"com.something.UserPreferences\" scope=\"session\"/>\n\n\t<bean id=\"userManager\" class=\"com.something.UserManager\">\n <property name=\"userPreferences\" ref=\"userPreferences\"/>\n\t</bean>\n----\n\nIn the preceding example, the singleton bean (`userManager`) is injected with a reference\nto the HTTP `Session`-scoped bean (`userPreferences`). The salient point here is that the\n`userManager` bean is a singleton: it is instantiated exactly once per\ncontainer, and its dependencies (in this case only one, the `userPreferences` bean) are\nalso injected only once. This means that the `userManager` bean operates only on the\nexact same `userPreferences` object (that is, the one with which it was originally injected).\n\nThis is not the behavior you want when injecting a shorter-lived scoped bean into a\nlonger-lived scoped bean (for example, injecting an HTTP `Session`-scoped collaborating\nbean as a dependency into singleton bean). Rather, you need a single `userManager`\nobject, and, for the lifetime of an HTTP `Session`, you need a `userPreferences` object\nthat is specific to the HTTP `Session`. Thus, the container creates an object that\nexposes the exact same public interface as the `UserPreferences` class (ideally an\nobject that is a `UserPreferences` instance), which can fetch the real\n`UserPreferences` object from the scoping mechanism (HTTP request, `Session`, and so\nforth). The container injects this proxy object into the `userManager` bean, which is\nunaware that this `UserPreferences` reference is a proxy. In this example, when a\n`UserManager` instance invokes a method on the dependency-injected `UserPreferences`\nobject, it is actually invoking a method on the proxy. The proxy then fetches the real\n`UserPreferences` object from (in this case) the HTTP `Session` and delegates the\nmethod invocation onto the retrieved real `UserPreferences` object.\n\nThus, you need the following (correct and complete) configuration when injecting\n`request-` and `session-scoped` beans into collaborating objects, as the following example\nshows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"userPreferences\" class=\"com.something.UserPreferences\" scope=\"session\">\n <aop:scoped-proxy/>\n\t</bean>\n\n\t<bean id=\"userManager\" class=\"com.something.UserManager\">\n <property name=\"userPreferences\" ref=\"userPreferences\"/>\n\t</bean>\n----\n\n[[beans-factory-scopes-other-injection-proxies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "Scoped Beans as Dependencies", "heading_level": 3, "file_order": 63, "section_index": 10, "content_hash": "157b34afb37aed37dd66fd677d6cb21140b3b1678006e065e05794b60b8c72f3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:a2433be64b903b4db5f4f189d65563551c088449378dfc751d027ddd76402693", "content": "By default, when the Spring container creates a proxy for a bean that is marked up with\nthe `<aop:scoped-proxy/>` element, a CGLIB-based class proxy is created.\n\n[NOTE]\n====\nCGLIB proxies do not intercept private methods. Attempting to call a private method\non such a proxy will not delegate to the actual scoped target object.\n====\n\nAlternatively, you can configure the Spring container to create standard JDK\ninterface-based proxies for such scoped beans, by specifying `false` for the value of\nthe `proxy-target-class` attribute of the `<aop:scoped-proxy/>` element. Using JDK\ninterface-based proxies means that you do not need additional libraries in your\napplication classpath to affect such proxying. However, it also means that the class of\nthe scoped bean must implement at least one interface and that all collaborators\ninto which the scoped bean is injected must reference the bean through one of its\ninterfaces. The following example shows a proxy based on an interface:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- DefaultUserPreferences implements the UserPreferences interface -->\n\t<bean id=\"userPreferences\" class=\"com.stuff.DefaultUserPreferences\" scope=\"session\">\n <aop:scoped-proxy proxy-target-class=\"false\"/>\n\t</bean>\n\n\t<bean id=\"userManager\" class=\"com.stuff.UserManager\">\n <property name=\"userPreferences\" ref=\"userPreferences\"/>\n\t</bean>\n----\n\nFor more detailed information about choosing class-based or interface-based proxying,\nsee xref:core/aop/proxying.adoc[Proxying Mechanisms].\n\n[[beans-factory-scopes-injection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "Choosing the Type of Proxy to Create", "heading_level": 4, "file_order": 63, "section_index": 11, "content_hash": "a2433be64b903b4db5f4f189d65563551c088449378dfc751d027ddd76402693", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:045ea479687e6e8ffa81e05f048e08190d75c6a574e9c26aac2aa80b08481287", "content": "As an alternative to factory scopes, a Spring `WebApplicationContext` also supports\nthe injection of `HttpServletRequest`, `HttpServletResponse`, `HttpSession`,\n`WebRequest` and (if JSF is present) `FacesContext` and `ExternalContext` into\nSpring-managed beans, simply through type-based autowiring next to regular injection\npoints for other beans. Spring generally injects proxies for such request and session\nobjects which has the advantage of working in singleton beans and serializable beans\nas well, similar to scoped proxies for factory-scoped beans.\n\n[[beans-factory-scopes-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "Injecting Request/Session References Directly", "heading_level": 3, "file_order": 63, "section_index": 12, "content_hash": "045ea479687e6e8ffa81e05f048e08190d75c6a574e9c26aac2aa80b08481287", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:ba3a360de60c2a78be7569ac60d8ba96c8a1ce76ac634eaee171a277db7ef075", "content": "The bean scoping mechanism is extensible. You can define your own\nscopes or even redefine existing scopes, although the latter is considered bad practice\nand you cannot override the built-in `singleton` and `prototype` scopes.\n\n[[beans-factory-scopes-custom-creating]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "Custom Scopes", "heading_level": 2, "file_order": 63, "section_index": 13, "content_hash": "ba3a360de60c2a78be7569ac60d8ba96c8a1ce76ac634eaee171a277db7ef075", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:ec25463dd9ff69ff77d8adee47a02322e3c2d5b164cdf56bc760189e16691461", "content": "To integrate your custom scopes into the Spring container, you need to implement the\n`org.springframework.beans.factory.config.Scope` interface, which is described in this\nsection. For an idea of how to implement your own scopes, see the `Scope`\nimplementations that are supplied with the Spring Framework itself and the\n{spring-framework-api}/beans/factory/config/Scope.html[`Scope`] javadoc,\nwhich explains the methods you need to implement in more detail.\n\nThe `Scope` interface has four methods to get objects from the scope, remove them from\nthe scope, and let them be destroyed.\n\nThe session scope implementation, for example, returns the session-scoped bean (if it\ndoes not exist, the method returns a new instance of the bean, after having bound it to\nthe session for future reference). The following method returns the object from the\nunderlying scope:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tObject get(String name, ObjectFactory<?> objectFactory)\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun get(name: String, objectFactory: ObjectFactory<*>): Any\n----\n======\n\nThe session scope implementation, for example, removes the session-scoped bean from the\nunderlying session. The object should be returned, but you can return `null` if the\nobject with the specified name is not found. The following method removes the object from\nthe underlying scope:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tObject remove(String name)\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun remove(name: String): Any\n----\n======\n\nThe following method registers a callback that the scope should invoke when it is\ndestroyed or when the specified object in the scope is destroyed:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tvoid registerDestructionCallback(String name, Runnable destructionCallback)\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun registerDestructionCallback(name: String, destructionCallback: Runnable)\n----\n======\n\nSee the {spring-framework-api}/beans/factory/config/Scope.html#registerDestructionCallback[javadoc]\nor a Spring scope implementation for more information on destruction callbacks.\n\nThe following method obtains the conversation identifier for the underlying scope:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString getConversationId()\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun getConversationId(): String\n----\n======\n\nThis identifier is different for each scope. For a session scoped implementation, this\nidentifier can be the session identifier.\n\n[[beans-factory-scopes-custom-using]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "Creating a Custom Scope", "heading_level": 3, "file_order": 63, "section_index": 14, "content_hash": "ec25463dd9ff69ff77d8adee47a02322e3c2d5b164cdf56bc760189e16691461", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:d964f577a30706d4626305c22c530096cd36cb839f2be13234b241799c05a8b2", "content": "After you write and test one or more custom `Scope` implementations, you need to make\nthe Spring container aware of your new scopes. The following method is the central\nmethod to register a new `Scope` with the Spring container:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tvoid registerScope(String scopeName, Scope scope);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun registerScope(scopeName: String, scope: Scope)\n----\n======\n\nThis method is declared on the `ConfigurableBeanFactory` interface, which is available\nthrough the `BeanFactory` property on most of the concrete `ApplicationContext`\nimplementations that ship with Spring.\n\nThe first argument to the `registerScope(..)` method is the unique name associated with\na scope. Examples of such names in the Spring container itself are `singleton` and\n`prototype`. The second argument to the `registerScope(..)` method is an actual instance\nof the custom `Scope` implementation that you wish to register and use.\n\nSuppose that you write your custom `Scope` implementation, and then register it as shown\nin the next example.\n\nNOTE: The next example uses `SimpleThreadScope`, which is included with Spring but is not\nregistered by default. The instructions would be the same for your own custom `Scope`\nimplementations.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tScope threadScope = new SimpleThreadScope();\n\tbeanFactory.registerScope(\"thread\", threadScope);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval threadScope = SimpleThreadScope()\n\tbeanFactory.registerScope(\"thread\", threadScope)\n----\n======\n\nYou can then create bean definitions that adhere to the scoping rules of your custom\n`Scope`, as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"...\" class=\"...\" scope=\"thread\">\n----\n\nWith a custom `Scope` implementation, you are not limited to programmatic registration\nof the scope. You can also do the `Scope` registration declaratively, by using the\n`CustomScopeConfigurer` class, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:aop=\"http://www.springframework.org/schema/aop\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/aop\n https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n <bean class=\"org.springframework.beans.factory.config.CustomScopeConfigurer\">\n <property name=\"scopes\">\n <map>\n <entry key=\"thread\">\n <bean class=\"org.springframework.context.support.SimpleThreadScope\"/>\n </entry>\n </map>\n </property>\n </bean>\n\n <bean id=\"thing2\" class=\"x.y.Thing2\" scope=\"thread\">\n <property name=\"name\" value=\"Rick\"/>\n <aop:scoped-proxy/>\n </bean>\n\n <bean id=\"thing1\" class=\"x.y.Thing1\">\n <property name=\"thing2\" ref=\"thing2\"/>\n </bean>\n\n\t</beans>\n----\n\nNOTE: When you place `<aop:scoped-proxy/>` within a `<bean>` declaration for a\n`FactoryBean` implementation, it is the factory bean itself that is scoped, not the object\nreturned from `getObject()`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc", "title": "factory-scopes", "heading": "Using a Custom Scope", "heading_level": 3, "file_order": 63, "section_index": 15, "content_hash": "d964f577a30706d4626305c22c530096cd36cb839f2be13234b241799c05a8b2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/factory-scopes.adoc"}}
{"id": "sha256:cefc85359ed81ba099fca07d6e600dcec5cafa47833b9eac2b13cad4604f3744", "content": "[[beans-introduction]]\n\nThis chapter covers the Spring Framework implementation of the Inversion of Control (IoC)\nprinciple. Dependency injection (DI) is a specialized form of IoC, whereby objects define\ntheir dependencies (that is, the other objects they work with) only through constructor\narguments, arguments to a factory method, or properties that are set on the object\ninstance after it is constructed or returned from a factory method. The IoC container\nthen injects those dependencies when it creates the bean. This process is fundamentally\nthe inverse (hence the name, Inversion of Control) of the bean itself controlling the\ninstantiation or location of its dependencies by using direct construction of classes or\na mechanism such as the Service Locator pattern.\n\nThe `org.springframework.beans` and `org.springframework.context` packages are the basis\nfor Spring Framework's IoC container. The\n{spring-framework-api}/beans/factory/BeanFactory.html[`BeanFactory`]\ninterface provides an advanced configuration mechanism capable of managing any type of\nobject.\n{spring-framework-api}/context/ApplicationContext.html[`ApplicationContext`]\nis a sub-interface of `BeanFactory`. It adds:\n\n* Easier integration with Spring's AOP features\n* Message resource handling (for use in internationalization)\n* Event publication\n* Application-layer specific contexts such as the `WebApplicationContext`\nfor use in web applications.\n\nIn short, the `BeanFactory` provides the configuration framework and basic functionality,\nand the `ApplicationContext` adds more enterprise-specific functionality. The\n`ApplicationContext` is a complete superset of the `BeanFactory` and is used exclusively\nin this chapter in descriptions of Spring's IoC container. For more information on using\nthe `BeanFactory` instead of the `ApplicationContext,` see the section covering the\nxref:core/beans/beanfactory.adoc[`BeanFactory` API].\n\nIn Spring, the objects that form the backbone of your application and that are managed\nby the Spring IoC container are called beans. A bean is an object that is\ninstantiated, assembled, and managed by a Spring IoC container. Otherwise, a\nbean is simply one of many objects in your application. Beans, and the dependencies\namong them, are reflected in the configuration metadata used by a container.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/introduction.adoc", "title": "introduction", "heading": "introduction", "heading_level": 1, "file_order": 64, "section_index": 0, "content_hash": "cefc85359ed81ba099fca07d6e600dcec5cafa47833b9eac2b13cad4604f3744", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/introduction.adoc"}}
{"id": "sha256:7fc9bf1f4b38a74a2840632bc026b9075978f3c66aef6ef51f0345b48e96e5ad", "content": "[[beans-java]]\n\nThis section covers how to use annotations in your Java code to configure the Spring\ncontainer.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/java.adoc", "title": "java", "heading": "java", "heading_level": 1, "file_order": 65, "section_index": 0, "content_hash": "7fc9bf1f4b38a74a2840632bc026b9075978f3c66aef6ef51f0345b48e96e5ad", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/java.adoc"}}
{"id": "sha256:c89ce9650d3c58b403020d0597f6c26f90b9bfba2e02a72d6f4c676aac9f51f5", "content": "[[beans-standard-annotations]]\n\nSpring offers support for JSR-330 standard _Dependency Injection_ annotations which are\navailable in the `jakarta.inject` package. These annotations may optionally be used as\nalternatives to Spring annotations.\n\nTo use them, you need to have the relevant jar in your classpath. For example, the\n`jakarta.inject` artifact is available in the standard Maven repository\n(`https://repo.maven.apache.org/maven2/jakarta/inject/jakarta.inject-api/2.0.0/`),\n\n[NOTE]\n=====\nIf you use Maven, you can add the following dependency to your `pom.xml` file.\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<dependency>\n <groupId>jakarta.inject</groupId>\n <artifactId>jakarta.inject-api</artifactId>\n <version>2.0.0</version>\n\t</dependency>\n----\n=====\n\n[[beans-inject-named]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/standard-annotations.adoc", "title": "standard-annotations", "heading": "standard-annotations", "heading_level": 1, "file_order": 66, "section_index": 0, "content_hash": "c89ce9650d3c58b403020d0597f6c26f90b9bfba2e02a72d6f4c676aac9f51f5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/standard-annotations.adoc"}}
{"id": "sha256:e2dbcb1538ffa074fe2670b6f96feb755248658a9c0275f0388bca7d05b3cecb", "content": "Instead of using `@Autowired` for dependency injection, you may optionally choose to use\n`@jakarta.inject.Inject` as follows.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject;\n\n\tpublic class SimpleMovieLister {\n\n private MovieFinder movieFinder;\n\n @Inject\n public void setMovieFinder(MovieFinder movieFinder) {\n this.movieFinder = movieFinder;\n }\n\n public void listMovies() {\n this.movieFinder.findMovies(...);\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject\n\n\tclass SimpleMovieLister {\n\n @Inject\n lateinit var movieFinder: MovieFinder\n\n fun listMovies() {\n movieFinder.findMovies(...)\n // ...\n }\n\t}\n----\n======\n\nAs with `@Autowired`, you can use `@Inject` at the field level, method level, and\nconstructor-argument level.\n\nFurthermore, as an alternative to Spring's `ObjectProvider` mechanism, you may choose to\ndeclare your injection point as a `jakarta.inject.Provider`, allowing for on-demand\naccess to beans of shorter scopes or lazy access to other beans through a\n`Provider.get()` call. The following example offers a variant of the preceding example.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject;\n\timport jakarta.inject.Provider;\n\n\tpublic class SimpleMovieLister {\n\n private Provider<MovieFinder> movieFinder;\n\n @Inject\n public void setMovieFinder(Provider<MovieFinder> movieFinder) {\n this.movieFinder = movieFinder;\n }\n\n public void listMovies() {\n this.movieFinder.get().findMovies(...);\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject\n\timport jakarta.inject.Provider\n\n\tclass SimpleMovieLister {\n\n @Inject\n lateinit var movieFinder: Provider<MovieFinder>\n\n fun listMovies() {\n movieFinder.get().findMovies(...)\n // ...\n }\n\t}\n----\n======\n\nIf you would like to use a qualified name for the dependency that should be injected, you\nmay choose to use the `@Named` annotation as an alternative to Spring's `@Qualifier`\nsupport, as the following example shows.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject;\n\timport jakarta.inject.Named;\n\n\tpublic class SimpleMovieLister {\n\n private MovieFinder movieFinder;\n\n @Inject\n public void setMovieFinder(@Named(\"main\") MovieFinder movieFinder) {\n this.movieFinder = movieFinder;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject\n\timport jakarta.inject.Named\n\n\tclass SimpleMovieLister {\n\n private lateinit var movieFinder: MovieFinder\n\n @Inject\n fun setMovieFinder(@Named(\"main\") movieFinder: MovieFinder) {\n this.movieFinder = movieFinder\n }\n\n // ...\n\t}\n----\n======\n\nAs with `@Autowired`, `@Inject` can also be used with `java.util.Optional` or\n`@Nullable`. This is even more applicable here, since `@Inject` does not have a\n`required` attribute. The following examples show how to use `@Inject` with `Optional`,\n`@Nullable`, and Kotlin's built-in support for nullable types.\n\n[source,java,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject;\n\timport java.util.Optional;\n\n\tpublic class SimpleMovieLister {\n\n @Inject\n public void setMovieFinder(Optional<MovieFinder> movieFinder) {\n // ...\n }\n\t}\n----\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject;\n\timport org.jspecify.annotations.Nullable;\n\n\tpublic class SimpleMovieLister {\n\n @Inject\n public void setMovieFinder(@Nullable MovieFinder movieFinder) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject\n\n\tclass SimpleMovieLister {\n\n @Inject\n var movieFinder: MovieFinder? = null\n\t}\n----\n======\n\n[[beans-named]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/standard-annotations.adoc", "title": "standard-annotations", "heading": "Dependency Injection with `@Inject` and `@Named`", "heading_level": 2, "file_order": 66, "section_index": 1, "content_hash": "e2dbcb1538ffa074fe2670b6f96feb755248658a9c0275f0388bca7d05b3cecb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/standard-annotations.adoc"}}
{"id": "sha256:f8921cfe5bf2ef249416a3ed40cce8eca695c6e53a8755e60c50fe923b4cdcfd", "content": "Instead of `@Component` or other Spring stereotype annotations, you may optionally choose\nto use `@jakarta.inject.Named`, as the following example shows.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject;\n\timport jakarta.inject.Named;\n\n\t@Named(\"movieListener\")\n\tpublic class SimpleMovieLister {\n\n private MovieFinder movieFinder;\n\n @Inject\n public void setMovieFinder(MovieFinder movieFinder) {\n this.movieFinder = movieFinder;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject\n\timport jakarta.inject.Named\n\n\t@Named(\"movieListener\")\n\tclass SimpleMovieLister {\n\n @Inject\n lateinit var movieFinder: MovieFinder\n\n // ...\n\t}\n----\n======\n\nIt is very common to use `@Component` or other Spring stereotype annotations without\nspecifying an explicit name for the component, and `@Named` can be used in a similar\nfashion, as the following example shows.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject;\n\timport jakarta.inject.Named;\n\n\t@Named\n\tpublic class SimpleMovieLister {\n\n private MovieFinder movieFinder;\n\n @Inject\n public void setMovieFinder(MovieFinder movieFinder) {\n this.movieFinder = movieFinder;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\timport jakarta.inject.Inject\n\timport jakarta.inject.Named\n\n\t@Named\n\tclass SimpleMovieLister {\n\n @Inject\n lateinit var movieFinder: MovieFinder\n\n // ...\n\t}\n----\n======\n\nWhen you use `@Named`, you can use component scanning in the exact same way as when you\nuse Spring annotations, as the following example shows.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = \"org.example\")\n\tpublic class AppConfig {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\t@Configuration\n\t@ComponentScan(basePackages = [\"org.example\"])\n\tclass AppConfig {\n // ...\n\t}\n----\n======\n\nNOTE: In contrast to `@Component`, the JSR-330 `@Named` annotation is not composable. You\nshould use Spring's stereotype model for building custom component annotations.\n\n[TIP]\n====\nIf you work with legacy systems that still use `@javax.inject.Named` or\n`@javax.annotation.ManagedBean` for components (note the `javax` package namespace), you\ncan explicitly configure component scanning to include those annotation types, as shown\nin the following example.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\t@Configuration\n\t@ComponentScan(\n basePackages = \"org.example\",\n includeFilters = @Filter({\n javax.inject.Named.class,\n javax.annotation.ManagedBean.class\n })\n\t)\n\tpublic class AppConfig {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",fold=\"-imports\"]\n----\n\t@Configuration\n\t@ComponentScan(\n basePackages = [\"org.example\"],\n includeFilters = [Filter([\n javax.inject.Named::class,\n javax.annotation.ManagedBean::class\n ])]\n\t)\n\tclass AppConfig {\n // ...\n\t}\n----\n======\n\nIn addition, if you would like for the `value` attributes in `@javax.inject.Named` and\n`@javax.annotation.ManagedBean` to be used as component names, you need to override the\n`isStereotypeWithNameValue(...)` method in `AnnotationBeanNameGenerator` to add explicit\nsupport for `javax.annotation.ManagedBean` and `javax.inject.Named` and register your\ncustom `AnnotationBeanNameGenerator` via the `nameGenerator` attribute in\n`@ComponentScan`.\n====\n\n[[beans-standard-annotations-limitations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/standard-annotations.adoc", "title": "standard-annotations", "heading": "`@Named`: Standard Equivalent to the `@Component` Annotation", "heading_level": 2, "file_order": 66, "section_index": 2, "content_hash": "f8921cfe5bf2ef249416a3ed40cce8eca695c6e53a8755e60c50fe923b4cdcfd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/standard-annotations.adoc"}}
{"id": "sha256:15535af2f6cb5f625966a2d998b3a85b7cd91dcb0848e0a4c1cf609cf0e1bcdf", "content": "When you work with JSR-330 standard annotations, you should know that some significant\nfeatures are not available, as the following table shows.\n\n[[annotations-comparison]]\n.Spring component model versus JSR-330 variants\n|===\n| Spring | JSR-330 | JSR-330 restrictions / comments\n\n| `@Autowired`\n| `@Inject`\n| `@Inject` has no `required` attribute. Can be used with Java's `Optional` instead.\n\n| `@Component`\n| `@Named`\n| JSR-330 does not provide a composable model, only a way to identify named components.\n\n| `@Scope(\"singleton\")`\n| `@Singleton`\n| The JSR-330 default scope is like Spring's `prototype`. However, in order to keep it\n consistent with Spring's general defaults, a JSR-330 bean declared in the Spring\n container is a `singleton` by default. In order to use a scope other than `singleton`,\n you should use Spring's `@Scope` annotation. `jakarta.inject` also provides a\n `jakarta.inject.Scope` annotation; however, this one is only intended to be used\n for creating custom annotations.\n\n| `@Qualifier`\n| `@Qualifier` / `@Named`\n| `jakarta.inject.Qualifier` is just a meta-annotation for building custom qualifiers.\n Concrete `String` qualifiers (like Spring's `@Qualifier` with a value) can be associated\n through `jakarta.inject.Named`.\n\n| `@Value`\n| -\n| no equivalent\n\n| `@Lazy`\n| -\n| no equivalent\n\n| `ObjectFactory`\n| `Provider`\n| `jakarta.inject.Provider` is a direct alternative to Spring's `ObjectFactory`,\n only with a shorter `get()` method name. It can also be used in combination with\n Spring's `@Autowired` or with non-annotated constructors and setter methods.\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans/standard-annotations.adoc", "title": "standard-annotations", "heading": "Limitations of JSR-330 Standard Annotations", "heading_level": 2, "file_order": 66, "section_index": 3, "content_hash": "15535af2f6cb5f625966a2d998b3a85b7cd91dcb0848e0a4c1cf609cf0e1bcdf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans/standard-annotations.adoc"}}
{"id": "sha256:7c1ca77bba7479dd3a31a704268d5a38dfcd8f96f6de4dc7aaf0cc7980fa69df", "content": "[[expressions-array-construction]]\n\nYou can build arrays by using the familiar Java syntax, optionally supplying an initializer\nto have the array populated at construction time. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tint[] numbers1 = (int[]) parser.parseExpression(\"new int[4]\").getValue(context);\n\n\t// Array with initializer\n\tint[] numbers2 = (int[]) parser.parseExpression(\"new int[] {1, 2, 3}\").getValue(context);\n\n\t// Multi dimensional array\n\tint[][] numbers3 = (int[][]) parser.parseExpression(\"new int[4][5]\").getValue(context);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval numbers1 = parser.parseExpression(\"new int[4]\").getValue(context) as IntArray\n\n\t// Array with initializer\n\tval numbers2 = parser.parseExpression(\"new int[] {1, 2, 3}\").getValue(context) as IntArray\n\n\t// Multi dimensional array\n\tval numbers3 = parser.parseExpression(\"new int[4][5]\").getValue(context) as Array<IntArray>\n----\n======\n\n[NOTE]\n====\nYou cannot currently supply an initializer when you construct a multi-dimensional array.\n====\n\n[CAUTION]\n====\nAny expression that constructs an array â€“ for example, via `new int[4]` or\n`new int[] {1, 2, 3}` â€“ cannot be compiled. See\nxref:core/expressions/evaluation.adoc#expressions-compiler-limitations[Compiler Limitations]\nfor details.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/array-construction.adoc", "title": "array-construction", "heading": "array-construction", "heading_level": 1, "file_order": 67, "section_index": 0, "content_hash": "7c1ca77bba7479dd3a31a704268d5a38dfcd8f96f6de4dc7aaf0cc7980fa69df", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/array-construction.adoc"}}
{"id": "sha256:e88b4761e95b6c670f8c0094d8b9e0f04b97bcb6ac04da7ee6910769c8d2eadd", "content": "[[expressions-bean-references]]\n\nIf the evaluation context has been configured with a bean resolver, you can look up beans\nfrom an expression by using the `@` symbol as a prefix. The following example shows how\nto do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tStandardEvaluationContext context = new StandardEvaluationContext();\n\tcontext.setBeanResolver(new MyBeanResolver());\n\n\t// This will end up calling resolve(context, \"someBean\") on MyBeanResolver\n\t// during evaluation.\n\tObject bean = parser.parseExpression(\"@someBean\").getValue(context);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval context = StandardEvaluationContext()\n\tcontext.setBeanResolver(MyBeanResolver())\n\n\t// This will end up calling resolve(context, \"someBean\") on MyBeanResolver\n\t// during evaluation.\n\tval bean = parser.parseExpression(\"@someBean\").getValue(context)\n----\n======\n\n[NOTE]\n====\nIf a bean name contains a dot (`.`) or other special characters, you must provide the\nname of the bean as a _string literal_ â€“ for example, `@'order.service'`.\n====\n\nTo access a factory bean itself, you should instead prefix the bean name with an `&`\nsymbol. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tStandardEvaluationContext context = new StandardEvaluationContext();\n\tcontext.setBeanResolver(new MyBeanResolver());\n\n\t// This will end up calling resolve(context, \"&someFactoryBean\") on\n\t// MyBeanResolver during evaluation.\n\tObject factoryBean = parser.parseExpression(\"&someFactoryBean\").getValue(context);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval context = StandardEvaluationContext()\n\tcontext.setBeanResolver(MyBeanResolver())\n\n\t// This will end up calling resolve(context, \"&someFactoryBean\") on\n\t// MyBeanResolver during evaluation.\n\tval factoryBean = parser.parseExpression(\"&someFactoryBean\").getValue(context)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/bean-references.adoc", "title": "bean-references", "heading": "bean-references", "heading_level": 1, "file_order": 68, "section_index": 0, "content_hash": "e88b4761e95b6c670f8c0094d8b9e0f04b97bcb6ac04da7ee6910769c8d2eadd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/bean-references.adoc"}}
{"id": "sha256:c565061ad0a6b5cf9257283e2381314667b20a3bc2302d91654ec6e44ef8ef7f", "content": "[[expressions-collection-projection]]\n\nProjection lets a collection drive the evaluation of a sub-expression, and the result is\na new collection. The syntax for projection is `.![projectionExpression]`. For example,\nsuppose we have a list of inventors but want the list of cities where they were born.\nEffectively, we want to evaluate `placeOfBirth.city` for every entry in the inventor\nlist. The following example uses projection to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to [\"Smiljan\", \"Idvor\"]\n\tList placesOfBirth = parser.parseExpression(\"members.![placeOfBirth.city]\")\n .getValue(societyContext, List.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to [\"Smiljan\", \"Idvor\"]\n\tval placesOfBirth = parser.parseExpression(\"members.![placeOfBirth.city]\")\n .getValue(societyContext) as List<*>\n----\n======\n\nProjection is supported for arrays and anything that implements `java.lang.Iterable` or\n`java.util.Map`. When using a map to drive projection, the projection expression is\nevaluated against each entry in the map (represented as a Java `Map.Entry`). The result\nof a projection across a map is a list that consists of the evaluation of the projection\nexpression against each map entry.\n\n[NOTE]\n====\nThe Spring Expression Language also supports safe navigation for collection projection.\n\nSee\nxref:core/expressions/language-ref/operator-safe-navigation.adoc#expressions-operator-safe-navigation-selection-and-projection[Safe Collection Selection and Projection]\nfor details.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/collection-projection.adoc", "title": "collection-projection", "heading": "collection-projection", "heading_level": 1, "file_order": 69, "section_index": 0, "content_hash": "c565061ad0a6b5cf9257283e2381314667b20a3bc2302d91654ec6e44ef8ef7f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/collection-projection.adoc"}}
{"id": "sha256:f3f8c8319cad0b7593ec9d4ec3c7a6e014de6bcd907e6af877a781f61d448a2f", "content": "[[expressions-collection-selection]]\n\nSelection is a powerful expression language feature that lets you transform a\nsource collection into another collection by selecting from its entries.\n\nSelection uses a syntax of `.?[selectionExpression]`. It filters the collection and\nreturns a new collection that contains a subset of the original elements. For example,\nselection lets us easily get a list of Serbian inventors, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tList<Inventor> list = (List<Inventor>) parser.parseExpression(\n \"members.?[nationality == 'Serbian']\").getValue(societyContext);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval list = parser.parseExpression(\n \"members.?[nationality == 'Serbian']\").getValue(societyContext) as List<Inventor>\n----\n======\n\nSelection is supported for arrays and anything that implements `java.lang.Iterable` or\n`java.util.Map`. For an array or `Iterable`, the selection expression is evaluated\nagainst each individual element. Against a map, the selection expression is evaluated\nagainst each map entry (objects of the Java type `Map.Entry`). Each map entry has its\n`key` and `value` accessible as properties for use in the selection.\n\nGiven a `Map` stored in a variable named `#map`, the following expression returns a new\nmap that consists of those elements of the original map where the entry's value is less\nthan 27:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMap newMap = parser.parseExpression(\"#map.?[value < 27]\").getValue(Map.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval newMap = parser.parseExpression(\"#map.?[value < 27]\").getValue() as Map\n----\n======\n\nIn addition to returning all the selected elements, you can retrieve only the first or\nthe last element. To obtain the first element matching the selection expression, the\nsyntax is `.^[selectionExpression]`. To obtain the last element matching the selection\nexpression, the syntax is `.$[selectionExpression]`.\n\n[NOTE]\n====\nThe Spring Expression Language also supports safe navigation for collection selection.\n\nSee\nxref:core/expressions/language-ref/operator-safe-navigation.adoc#expressions-operator-safe-navigation-selection-and-projection[Safe Collection Selection and Projection]\nfor details.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/collection-selection.adoc", "title": "collection-selection", "heading": "collection-selection", "heading_level": 1, "file_order": 70, "section_index": 0, "content_hash": "f3f8c8319cad0b7593ec9d4ec3c7a6e014de6bcd907e6af877a781f61d448a2f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/collection-selection.adoc"}}
{"id": "sha256:4eef7ecf0fa5a2f49763c32e17e050c3a5c46f906083d2dd88c0d6f683a03dd1", "content": "[[expressions-constructors]]\n\nYou can invoke constructors by using the `new` operator. You should use the fully\nqualified class name for all types except those located in the `java.lang` package\n(`Integer`, `Float`, `String`, and so on).\nxref:core/expressions/language-ref/varargs.adoc[Varargs] are also supported.\n\nThe following example shows how to use the `new` operator to invoke constructors.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tInventor einstein = parser.parseExpression(\n \"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')\")\n .getValue(Inventor.class);\n\n\t// create new Inventor instance within the add() method of List\n\tparser.parseExpression(\n \"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))\")\n .getValue(societyContext);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval einstein = parser.parseExpression(\n \"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')\")\n .getValue(Inventor::class.java)\n\n\t// create new Inventor instance within the add() method of List\n\tparser.parseExpression(\n \"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))\")\n .getValue(societyContext)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/constructors.adoc", "title": "constructors", "heading": "constructors", "heading_level": 1, "file_order": 71, "section_index": 0, "content_hash": "4eef7ecf0fa5a2f49763c32e17e050c3a5c46f906083d2dd88c0d6f683a03dd1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/constructors.adoc"}}
{"id": "sha256:8c5e3800e49847f6e1f2dfcc9ce85ecb47f895e5b26ebf65824b6f4b8e506741", "content": "[[expressions-ref-functions]]\n\nYou can extend SpEL by registering user-defined functions that can be called within\nexpressions by using the `#functionName(...)` syntax, and like with standard method\ninvocations, xref:core/expressions/language-ref/varargs.adoc[varargs] are also supported\nfor function invocations.\n\nFunctions can be registered as _variables_ in `EvaluationContext` implementations via the\n`setVariable()` method.\n\n[TIP]\n====\n`StandardEvaluationContext` also defines `registerFunction(...)` methods that provide a\nconvenient way to register a function as a `java.lang.reflect.Method` or a\n`java.lang.invoke.MethodHandle`.\n====\n\n[WARNING]\n====\nSince functions share a common namespace with\nxref:core/expressions/language-ref/variables.adoc[variables] in the evaluation context,\ncare must be taken to ensure that function names and variable names do not overlap.\n====\n\nThe following example shows how to register a user-defined function to be invoked via\nreflection using a `java.lang.reflect.Method`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMethod method = ...;\n\n\tEvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n\tcontext.setVariable(\"myFunction\", method);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval method: Method = ...\n\n\tval context = SimpleEvaluationContext.forReadOnlyDataBinding().build()\n\tcontext.setVariable(\"myFunction\", method)\n----\n======\n\nFor example, consider the following utility method that reverses a string:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic abstract class StringUtils {\n\n public static String reverseString(String input) {\n return new StringBuilder(input).reverse().toString();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun reverseString(input: String): String {\n return StringBuilder(input).reverse().toString()\n\t}\n----\n======\n\nYou can register and use the preceding method, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\n\tEvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n\tcontext.setVariable(\"reverseString\",\n StringUtils.class.getMethod(\"reverseString\", String.class));\n\n\t// evaluates to \"olleh\"\n\tString helloWorldReversed = parser.parseExpression(\n \"#reverseString('hello')\").getValue(context, String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\n\tval context = SimpleEvaluationContext.forReadOnlyDataBinding().build()\n\tcontext.setVariable(\"reverseString\", ::reverseString.javaMethod)\n\n\t// evaluates to \"olleh\"\n\tval helloWorldReversed = parser.parseExpression(\n \"#reverseString('hello')\").getValue(context, String::class.java)\n----\n======\n\nA function can also be registered as a `java.lang.invoke.MethodHandle`. This enables\npotentially more efficient use cases if the `MethodHandle` target and parameters have\nbeen fully bound prior to registration; however, partially bound handles are also\nsupported.\n\nConsider the `String#formatted(Object...)` instance method, which produces a message\naccording to a template and a variable number of arguments\n(xref:core/expressions/language-ref/varargs.adoc[varargs]).\n\nYou can register and use the `formatted` method as a `MethodHandle`, as the following\nexample shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tEvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n\n\tMethodHandle mh = MethodHandles.lookup().findVirtual(String.class, \"formatted\",\n MethodType.methodType(String.class, Object[].class));\n\tcontext.setVariable(\"message\", mh);\n\n\t// evaluates to \"Simple message: <Hello World>\"\n\tString message = parser.parseExpression(\"#message('Simple message: <%s>', 'Hello World', 'ignored')\")\n .getValue(context, String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval context = SimpleEvaluationContext.forReadOnlyDataBinding().build()\n\n\tval mh = MethodHandles.lookup().findVirtual(String::class.java, \"formatted\",\n MethodType.methodType(String::class.java, Array<Any>::class.java))\n\tcontext.setVariable(\"message\", mh)\n\n\t// evaluates to \"Simple message: <Hello World>\"\n\tval message = parser.parseExpression(\"#message('Simple message: <%s>', 'Hello World', 'ignored')\")\n .getValue(context, String::class.java)\n----\n======\n\nAs mentioned above, binding a `MethodHandle` and registering the bound `MethodHandle` is\nalso supported. This is likely to be more performant if both the target and all the\narguments are bound. In that case no arguments are necessary in the SpEL expression, as\nthe following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tEvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n\n\tString template = \"This is a %s message with %s words: <%s>\";\n\tObject varargs = new Object[] { \"prerecorded\", 3, \"Oh Hello World!\", \"ignored\" };\n\tMethodHandle mh = MethodHandles.lookup().findVirtual(String.class, \"formatted\",\n MethodType.methodType(String.class, Object[].class))\n .bindTo(template)\n // Here we have to provide the arguments in a single array binding:\n .bindTo(varargs);\n\tcontext.setVariable(\"message\", mh);\n\n\t// evaluates to \"This is a prerecorded message with 3 words: <Oh Hello World!>\"\n\tString message = parser.parseExpression(\"#message()\")\n .getValue(context, String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval context = SimpleEvaluationContext.forReadOnlyDataBinding().build()\n\n\tval template = \"This is a %s message with %s words: <%s>\"\n\tval varargs = arrayOf(\"prerecorded\", 3, \"Oh Hello World!\", \"ignored\")\n\n\tval mh = MethodHandles.lookup().findVirtual(String::class.java, \"formatted\",\n MethodType.methodType(String::class.java, Array<Any>::class.java))\n .bindTo(template)\n // Here we have to provide the arguments in a single array binding:\n .bindTo(varargs)\n\tcontext.setVariable(\"message\", mh)\n\n\t// evaluates to \"This is a prerecorded message with 3 words: <Oh Hello World!>\"\n\tval message = parser.parseExpression(\"#message()\")\n .getValue(context, String::class.java)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/functions.adoc", "title": "functions", "heading": "functions", "heading_level": 1, "file_order": 72, "section_index": 0, "content_hash": "8c5e3800e49847f6e1f2dfcc9ce85ecb47f895e5b26ebf65824b6f4b8e506741", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/functions.adoc"}}
{"id": "sha256:341a122a7893300460885fcea56499924f44392b8cc6ce1ff8826d8ea4142e7d", "content": "[[expressions-inline-lists]]\n\nYou can directly express lists in an expression by using `{}` notation.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to a Java list containing the four numbers\n\tList numbers = (List) parser.parseExpression(\"{1,2,3,4}\").getValue(context);\n\n\tList listOfLists = (List) parser.parseExpression(\"{{'a','b'},{'x','y'}}\").getValue(context);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to a Java list containing the four numbers\n\tval numbers = parser.parseExpression(\"{1,2,3,4}\").getValue(context) as List<*>\n\n\tval listOfLists = parser.parseExpression(\"{{'a','b'},{'x','y'}}\").getValue(context) as List<*>\n----\n======\n\n`{}` by itself means an empty list. For performance reasons, if the list is itself\nentirely composed of fixed literals, a constant list is created to represent the\nexpression (rather than building a new list on each evaluation).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/inline-lists.adoc", "title": "inline-lists", "heading": "inline-lists", "heading_level": 1, "file_order": 73, "section_index": 0, "content_hash": "341a122a7893300460885fcea56499924f44392b8cc6ce1ff8826d8ea4142e7d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/inline-lists.adoc"}}
{"id": "sha256:1aa1f2c256021538287faa305275baf5b78d82195a471e2849c7eefa4cd9fecc", "content": "[[expressions-inline-maps]]\n\nYou can also directly express maps in an expression by using `{key:value}` notation. The\nfollowing example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to a Java map containing the two entries\n\tMap inventorInfo = (Map) parser.parseExpression(\"{name:'Nikola',dob:'10-July-1856'}\").getValue(context);\n\n\tMap mapOfMaps = (Map) parser.parseExpression(\"{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}\").getValue(context);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t// evaluates to a Java map containing the two entries\n\tval inventorInfo = parser.parseExpression(\"{name:'Nikola',dob:'10-July-1856'}\").getValue(context) as Map<*, *>\n\n\tval mapOfMaps = parser.parseExpression(\"{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}\").getValue(context) as Map<*, *>\n----\n======\n\n`{:}` by itself means an empty map. For performance reasons, if the map is itself\ncomposed of fixed literals or other nested constant structures (lists or maps), a\nconstant map is created to represent the expression (rather than building a new map on\neach evaluation). Quoting of the map keys is optional (unless the key contains a period\n(`.`)). The examples above do not use quoted keys.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/inline-maps.adoc", "title": "inline-maps", "heading": "inline-maps", "heading_level": 1, "file_order": 74, "section_index": 0, "content_hash": "1aa1f2c256021538287faa305275baf5b78d82195a471e2849c7eefa4cd9fecc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/inline-maps.adoc"}}
{"id": "sha256:2deef0a21b28b68882221c15781728a9248edf1f6e1e390e78a08f82fb7231a2", "content": "[[expressions-ref-literal]]\n\nSpEL supports the following types of literal expressions.\n\nString ::\n Strings can be delimited by single quotation marks (`'`) or double quotation marks\n (`\"`). To include a single quotation mark within a string literal enclosed in single\n quotation marks, use two adjacent single quotation mark characters. Similarly, to\n include a double quotation mark within a string literal enclosed in double quotation\n marks, use two adjacent double quotation mark characters.\nNumber ::\n Numbers support the use of the negative sign, exponential notation, and decimal points.\n * Integer: `int` or `long`\n * Hexadecimal: `int` or `long`\n * Real: `float` or `double`\n ** By default, real numbers are parsed using `Double.parseDouble()`.\nBoolean ::\n `true` or `false`\nNull ::\n `null`\n\n[NOTE]\n====\nDue to the design and implementation of the Spring Expression Language, literal numbers\nare always stored internally as positive numbers.\n\nFor example, `-2` is stored internally as a positive `2` which is then negated while\nevaluating the expression (by calculating the value of `0 - 2`).\n\nThis means that it is not possible to represent a negative literal number equal to the\nminimum value of that type of number in Java. For example, the minimum supported value\nfor an `int` in Java is `Integer.MIN_VALUE` which has a value of `-2147483648`. However,\nif you include `-2147483648` in a SpEL expression, an exception will be thrown informing\nyou that the value `2147483648` cannot be parsed as an `int` (because it exceeds the\nvalue of `Integer.MAX_VALUE` which is `2147483647`).\n\nIf you need to use the minimum value for a particular type of number within a SpEL\nexpression, you can either reference the `MIN_VALUE` constant for the respective wrapper\ntype (such as `Integer.MIN_VALUE`, `Long.MIN_VALUE`, etc.) or calculate the minimum\nvalue. For example, to use the minimum integer value:\n\n- `T(Integer).MIN_VALUE` -- requires a `StandardEvaluationContext`\n- `-2^31` -- can be used with any type of `EvaluationContext`\n====\n\nThe following listing shows simple usage of literals. Typically, they are not used in\nisolation like this but, rather, as part of a more complex expression -- for example,\nusing a literal on one side of a logical comparison operator or as an argument to a\nmethod.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\n\t// evaluates to \"Hello World\"\n\tString helloWorld = (String) parser.parseExpression(\"'Hello World'\").getValue();\n\n\t// evaluates to \"Tony's Pizza\"\n\tString pizzaParlor = (String) parser.parseExpression(\"'Tony''s Pizza'\").getValue();\n\n\tdouble avogadrosNumber = (Double) parser.parseExpression(\"6.0221415E+23\").getValue();\n\n\t// evaluates to 2147483647\n\tint maxValue = (Integer) parser.parseExpression(\"0x7FFFFFFF\").getValue();\n\n\tboolean trueValue = (Boolean) parser.parseExpression(\"true\").getValue();\n\n\tObject nullValue = parser.parseExpression(\"null\").getValue();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\n\t// evaluates to \"Hello World\"\n\tval helloWorld = parser.parseExpression(\"'Hello World'\").value as String\n\n\t// evaluates to \"Tony's Pizza\"\n\tval pizzaParlor = parser.parseExpression(\"'Tony''s Pizza'\").value as String\n\n\tval avogadrosNumber = parser.parseExpression(\"6.0221415E+23\").value as Double\n\n\t// evaluates to 2147483647\n\tval maxValue = parser.parseExpression(\"0x7FFFFFFF\").value as Int\n\n\tval trueValue = parser.parseExpression(\"true\").value as Boolean\n\n\tval nullValue = parser.parseExpression(\"null\").value\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/literal.adoc", "title": "literal", "heading": "literal", "heading_level": 1, "file_order": 75, "section_index": 0, "content_hash": "2deef0a21b28b68882221c15781728a9248edf1f6e1e390e78a08f82fb7231a2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/literal.adoc"}}
{"id": "sha256:01fdcd3a34637227aca4e0d319a08207e8377e27dfeedd25c1883e733dd60459", "content": "[[expressions-methods]]\n\nYou can invoke methods by using the typical Java programming syntax. You can also invoke\nmethods directly on literals such as strings or numbers.\nxref:core/expressions/language-ref/varargs.adoc[Varargs] are supported as well.\n\nThe following examples show how to invoke methods.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// string literal, evaluates to \"bc\"\n\tString bc = parser.parseExpression(\"'abc'.substring(1, 3)\").getValue(String.class);\n\n\t// evaluates to true\n\tboolean isMember = parser.parseExpression(\"isMember('Mihajlo Pupin')\").getValue(\n societyContext, Boolean.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// string literal, evaluates to \"bc\"\n\tval bc = parser.parseExpression(\"'abc'.substring(1, 3)\").getValue(String::class.java)\n\n\t// evaluates to true\n\tval isMember = parser.parseExpression(\"isMember('Mihajlo Pupin')\").getValue(\n societyContext, Boolean::class.java)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/methods.adoc", "title": "methods", "heading": "methods", "heading_level": 1, "file_order": 76, "section_index": 0, "content_hash": "01fdcd3a34637227aca4e0d319a08207e8377e27dfeedd25c1883e733dd60459", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/methods.adoc"}}
{"id": "sha256:ca7e8f325a042098fc79fdb886ae78d7d3ec371cd68102e2b3a2c3ede0ac59ed", "content": "[[expressions-operator-elvis]]\n\nThe Elvis operator (`?:`) is a shortening of the ternary operator syntax and is used in\nthe https://www.groovy-lang.org/operators.html#_elvis_operator[Groovy] language. With the\nternary operator syntax, you often have to repeat a variable twice, as the following Java\nexample shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString name = \"Elvis Presley\";\n\tString displayName = (name != null ? name : \"Unknown\");\n----\n\nInstead, you can use the Elvis operator (named for the resemblance to Elvis' hair style).\nThe following example shows how to use the Elvis operator in a SpEL expression:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\n\tString name = parser.parseExpression(\"name ?: 'Unknown'\").getValue(new Inventor(), String.class);\n\tSystem.out.println(name); // 'Unknown'\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\n\tval name = parser.parseExpression(\"name ?: 'Unknown'\").getValue(Inventor(), String::class.java)\n\tprintln(name) // 'Unknown'\n----\n======\n\n[NOTE]\n====\nThe SpEL Elvis operator also treats an _empty_ String like a `null` object. Thus, the\noriginal Java example is only close to emulating the semantics of the operator: it would\nneed to use `name != null && !name.isEmpty()` as the predicate to be compatible with the\nsemantics of the SpEL Elvis operator.\n====\n\n[TIP]\n====\nAs of Spring Framework 7.0, the SpEL Elvis operator supports `java.util.Optional` with\ntransparent unwrapping semantics.\n\nFor example, given the expression `A ?: B`, if `A` is `null` or an _empty_ `Optional`,\nthe expression evaluates to `B`. However, if `A` is a non-empty `Optional` the expression\nevaluates to the object contained in the `Optional`, thereby effectively unwrapping the\n`Optional` which correlates to `A.get()`.\n====\n\nThe following listing shows a more complex example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tEvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n\n\tInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\n\tString name = parser.parseExpression(\"name ?: 'Elvis Presley'\").getValue(context, tesla, String.class);\n\tSystem.out.println(name); // Nikola Tesla\n\n\ttesla.setName(\"\");\n\tname = parser.parseExpression(\"name ?: 'Elvis Presley'\").getValue(context, tesla, String.class);\n\tSystem.out.println(name); // Elvis Presley\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval context = SimpleEvaluationContext.forReadOnlyDataBinding().build()\n\n\tval tesla = Inventor(\"Nikola Tesla\", \"Serbian\")\n\tvar name = parser.parseExpression(\"name ?: 'Elvis Presley'\").getValue(context, tesla, String::class.java)\n\tprintln(name) // Nikola Tesla\n\n\ttesla.setName(\"\")\n\tname = parser.parseExpression(\"name ?: 'Elvis Presley'\").getValue(context, tesla, String::class.java)\n\tprintln(name) // Elvis Presley\n----\n======\n\n[TIP]\n=====\nYou can use the Elvis operator to apply default values in expressions. The following\nexample shows how to use the Elvis operator in a `@Value` expression:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Value(\"#{systemProperties['pop3.port'] ?: 25}\")\n----\n\nThis will inject the value of the system property named `pop3.port` if it is defined or\n`25` if the property is not defined.\n=====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-elvis.adoc", "title": "operator-elvis", "heading": "operator-elvis", "heading_level": 1, "file_order": 77, "section_index": 0, "content_hash": "ca7e8f325a042098fc79fdb886ae78d7d3ec371cd68102e2b3a2c3ede0ac59ed", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-elvis.adoc"}}
{"id": "sha256:0d94c2af80bbe004c54bad4eea956633b1caa91f5b862b5488568b2457185bba", "content": "[[expressions-operator-safe-navigation]]\n\nThe safe navigation operator (`?.`) is used to avoid a `NullPointerException` and comes\nfrom the https://www.groovy-lang.org/operators.html#_safe_navigation_operator[Groovy]\nlanguage. Typically, when you have a reference to an object, you might need to verify\nthat it is not `null` before accessing methods or properties of the object. To avoid\nthis, the safe navigation operator returns `null` for the particular null-safe operation\ninstead of throwing an exception.\n\n[WARNING]\n====\nWhen the safe navigation operator evaluates to `null` for a particular null-safe\noperation within a compound expression, the remainder of the compound expression will\nstill be evaluated.\n\nSee <<expressions-operator-safe-navigation-compound-expressions>> for details.\n====\n\n[[expressions-operator-safe-navigation-property-access]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-safe-navigation.adoc", "title": "operator-safe-navigation", "heading": "operator-safe-navigation", "heading_level": 1, "file_order": 78, "section_index": 0, "content_hash": "0d94c2af80bbe004c54bad4eea956633b1caa91f5b862b5488568b2457185bba", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-safe-navigation.adoc"}}
{"id": "sha256:bf6c22f71f3ebab5e1c9a9d79579313b57ad32cc099e66e3f54f4332d287b9cb", "content": "The following example shows how to use the safe navigation operator for property access\n(`?.`).\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tEvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n\n\tInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\n\ttesla.setPlaceOfBirth(new PlaceOfBirth(\"Smiljan\"));\n\n\t// evaluates to \"Smiljan\"\n\tString city = parser.parseExpression(\"placeOfBirth?.city\") // <1>\n .getValue(context, tesla, String.class);\n\n\ttesla.setPlaceOfBirth(null);\n\n\t// evaluates to null - does not throw NullPointerException\n\tcity = parser.parseExpression(\"placeOfBirth?.city\") // <2>\n .getValue(context, tesla, String.class);\n----\n<1> Use safe navigation operator on non-null `placeOfBirth` property\n<2> Use safe navigation operator on null `placeOfBirth` property\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval context = SimpleEvaluationContext.forReadOnlyDataBinding().build()\n\n\tval tesla = Inventor(\"Nikola Tesla\", \"Serbian\")\n\ttesla.setPlaceOfBirth(PlaceOfBirth(\"Smiljan\"))\n\n\t// evaluates to \"Smiljan\"\n\tvar city = parser.parseExpression(\"placeOfBirth?.city\") // <1>\n .getValue(context, tesla, String::class.java)\n\n\ttesla.setPlaceOfBirth(null)\n\n\t// evaluates to null - does not throw NullPointerException\n\tcity = parser.parseExpression(\"placeOfBirth?.city\") // <2>\n .getValue(context, tesla, String::class.java)\n----\n<1> Use safe navigation operator on non-null `placeOfBirth` property\n<2> Use safe navigation operator on null `placeOfBirth` property\n======\n\n[NOTE]\n====\nThe safe navigation operator also applies to method invocations on an object.\n\nFor example, the expression `#calculator?.max(4, 2)` evaluates to `null` if the\n`#calculator` variable has not been configured in the context. Otherwise, the\n`max(int, int)` method will be invoked on the `#calculator`.\n====\n\n[[expressions-operator-safe-navigation-indexing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-safe-navigation.adoc", "title": "operator-safe-navigation", "heading": "Safe Property and Method Access", "heading_level": 2, "file_order": 78, "section_index": 1, "content_hash": "bf6c22f71f3ebab5e1c9a9d79579313b57ad32cc099e66e3f54f4332d287b9cb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-safe-navigation.adoc"}}
{"id": "sha256:6c9c693513431f35e55d06e9a55b5f027a84688356a9550a3c3fcb49566c0921", "content": "Since Spring Framework 6.2, the Spring Expression Language supports safe navigation for\nindexing into the following types of structures.\n\n* xref:core/expressions/language-ref/properties-arrays.adoc#expressions-indexing-arrays-and-collections[arrays and collections]\n* xref:core/expressions/language-ref/properties-arrays.adoc#expressions-indexing-strings[strings]\n* xref:core/expressions/language-ref/properties-arrays.adoc#expressions-indexing-maps[maps]\n* xref:core/expressions/language-ref/properties-arrays.adoc#expressions-indexing-objects[objects]\n* xref:core/expressions/language-ref/properties-arrays.adoc#expressions-indexing-custom[custom]\n\nThe following example shows how to use the safe navigation operator for indexing into\na list (`?.[]`).\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tIEEE society = new IEEE();\n\tEvaluationContext context = new StandardEvaluationContext(society);\n\n\t// evaluates to Inventor(\"Nikola Tesla\")\n\tInventor inventor = parser.parseExpression(\"members?.[0]\") // <1>\n .getValue(context, Inventor.class);\n\n\tsociety.members = null;\n\n\t// evaluates to null - does not throw an exception\n\tinventor = parser.parseExpression(\"members?.[0]\") // <2>\n .getValue(context, Inventor.class);\n----\n<1> Use null-safe index operator on a non-null `members` list\n<2> Use null-safe index operator on a null `members` list\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval society = IEEE()\n\tval context = StandardEvaluationContext(society)\n\n\t// evaluates to Inventor(\"Nikola Tesla\")\n\tvar inventor = parser.parseExpression(\"members?.[0]\") // <1>\n .getValue(context, Inventor::class.java)\n\n\tsociety.members = null\n\n\t// evaluates to null - does not throw an exception\n\tinventor = parser.parseExpression(\"members?.[0]\") // <2>\n .getValue(context, Inventor::class.java)\n----\n<1> Use null-safe index operator on a non-null `members` list\n<2> Use null-safe index operator on a null `members` list\n======\n\n[[expressions-operator-safe-navigation-selection-and-projection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-safe-navigation.adoc", "title": "operator-safe-navigation", "heading": "Safe Index Access", "heading_level": 2, "file_order": 78, "section_index": 2, "content_hash": "6c9c693513431f35e55d06e9a55b5f027a84688356a9550a3c3fcb49566c0921", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-safe-navigation.adoc"}}
{"id": "sha256:ebf5beee1eccdac2606cffc8963d98485c8a0429bc2cd455c5242bedfbd83202", "content": "The Spring Expression Language supports safe navigation for\nxref:core/expressions/language-ref/collection-selection.adoc[collection selection] and\nxref:core/expressions/language-ref/collection-projection.adoc[collection projection] via\nthe following operators.\n\n* null-safe selection: `?.?`\n* null-safe select first: `?.^`\n* null-safe select last: `?.$`\n* null-safe projection: `?.!`\n\nThe following example shows how to use the safe navigation operator for collection\nselection (`?.?`).\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tIEEE society = new IEEE();\n\tStandardEvaluationContext context = new StandardEvaluationContext(society);\n\tString expression = \"members?.?[nationality == 'Serbian']\"; // <1>\n\n\t// evaluates to [Inventor(\"Nikola Tesla\")]\n\tList<Inventor> list = (List<Inventor>) parser.parseExpression(expression)\n .getValue(context);\n\n\tsociety.members = null;\n\n\t// evaluates to null - does not throw a NullPointerException\n\tlist = (List<Inventor>) parser.parseExpression(expression)\n .getValue(context);\n----\n<1> Use null-safe selection operator on potentially null `members` list\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval society = IEEE()\n\tval context = StandardEvaluationContext(society)\n\tval expression = \"members?.?[nationality == 'Serbian']\" // <1>\n\n\t// evaluates to [Inventor(\"Nikola Tesla\")]\n\tvar list = parser.parseExpression(expression)\n .getValue(context) as List<Inventor>\n\n\tsociety.members = null\n\n\t// evaluates to null - does not throw a NullPointerException\n\tlist = parser.parseExpression(expression)\n .getValue(context) as List<Inventor>\n----\n<1> Use null-safe selection operator on potentially null `members` list\n======\n\nThe following example shows how to use the \"null-safe select first\" operator for\ncollections (`?.^`).\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tIEEE society = new IEEE();\n\tStandardEvaluationContext context = new StandardEvaluationContext(society);\n\tString expression =\n \"members?.^[nationality == 'Serbian' || nationality == 'Idvor']\"; // <1>\n\n\t// evaluates to Inventor(\"Nikola Tesla\")\n\tInventor inventor = parser.parseExpression(expression)\n .getValue(context, Inventor.class);\n\n\tsociety.members = null;\n\n\t// evaluates to null - does not throw a NullPointerException\n\tinventor = parser.parseExpression(expression)\n .getValue(context, Inventor.class);\n----\n<1> Use \"null-safe select first\" operator on potentially null `members` list\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval society = IEEE()\n\tval context = StandardEvaluationContext(society)\n\tval expression =\n \"members?.^[nationality == 'Serbian' || nationality == 'Idvor']\" // <1>\n\n\t// evaluates to Inventor(\"Nikola Tesla\")\n\tvar inventor = parser.parseExpression(expression)\n .getValue(context, Inventor::class.java)\n\n\tsociety.members = null\n\n\t// evaluates to null - does not throw a NullPointerException\n\tinventor = parser.parseExpression(expression)\n .getValue(context, Inventor::class.java)\n----\n<1> Use \"null-safe select first\" operator on potentially null `members` list\n======\n\nThe following example shows how to use the \"null-safe select last\" operator for\ncollections (`?.$`).\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tIEEE society = new IEEE();\n\tStandardEvaluationContext context = new StandardEvaluationContext(society);\n\tString expression =\n \"members?.$[nationality == 'Serbian' || nationality == 'Idvor']\"; // <1>\n\n\t// evaluates to Inventor(\"Pupin\")\n\tInventor inventor = parser.parseExpression(expression)\n .getValue(context, Inventor.class);\n\n\tsociety.members = null;\n\n\t// evaluates to null - does not throw a NullPointerException\n\tinventor = parser.parseExpression(expression)\n .getValue(context, Inventor.class);\n----\n<1> Use \"null-safe select last\" operator on potentially null `members` list\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval society = IEEE()\n\tval context = StandardEvaluationContext(society)\n\tval expression =\n \"members?.$[nationality == 'Serbian' || nationality == 'Idvor']\" // <1>\n\n\t// evaluates to Inventor(\"Pupin\")\n\tvar inventor = parser.parseExpression(expression)\n .getValue(context, Inventor::class.java)\n\n\tsociety.members = null\n\n\t// evaluates to null - does not throw a NullPointerException\n\tinventor = parser.parseExpression(expression)\n .getValue(context, Inventor::class.java)\n----\n<1> Use \"null-safe select last\" operator on potentially null `members` list\n======\n\nThe following example shows how to use the safe navigation operator for collection\nprojection (`?.!`).\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tIEEE society = new IEEE();\n\tStandardEvaluationContext context = new StandardEvaluationContext(society);\n\n\t// evaluates to [\"Smiljan\", \"Idvor\"]\n\tList placesOfBirth = parser.parseExpression(\"members?.![placeOfBirth.city]\") // <1>\n .getValue(context, List.class);\n\n\tsociety.members = null;\n\n\t// evaluates to null - does not throw a NullPointerException\n\tplacesOfBirth = parser.parseExpression(\"members?.![placeOfBirth.city]\") // <2>\n .getValue(context, List.class);\n----\n<1> Use null-safe projection operator on non-null `members` list\n<2> Use null-safe projection operator on null `members` list\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval society = IEEE()\n\tval context = StandardEvaluationContext(society)\n\n\t// evaluates to [\"Smiljan\", \"Idvor\"]\n\tvar placesOfBirth = parser.parseExpression(\"members?.![placeOfBirth.city]\") // <1>\n .getValue(context, List::class.java)\n\n\tsociety.members = null\n\n\t// evaluates to null - does not throw a NullPointerException\n\tplacesOfBirth = parser.parseExpression(\"members?.![placeOfBirth.city]\") // <2>\n .getValue(context, List::class.java)\n----\n<1> Use null-safe projection operator on non-null `members` list\n<2> Use null-safe projection operator on null `members` list\n======\n\n[[expressions-operator-safe-navigation-optional]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-safe-navigation.adoc", "title": "operator-safe-navigation", "heading": "Safe Collection Selection and Projection", "heading_level": 2, "file_order": 78, "section_index": 3, "content_hash": "ebf5beee1eccdac2606cffc8963d98485c8a0429bc2cd455c5242bedfbd83202", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-safe-navigation.adoc"}}
{"id": "sha256:9291dc661625254d06b3df40a30358fa17fb88a3b5b8474bcfe9b8f3edab70f3", "content": "As of Spring Framework 7.0, null-safe operations are supported on instances of\n`java.util.Optional` with transparent unwrapping semantics.\n\nSpecifically, when a null-safe operator is applied to an _empty_ `Optional`, it will be\ntreated as if the `Optional` were `null`, and the subsequent operation will evaluate to\n`null`. However, if a null-safe operator is applied to a non-empty `Optional`, the\nsubsequent operation will be applied to the object contained in the `Optional`, thereby\neffectively unwrapping the `Optional`.\n\nFor example, if `user` is of type `Optional<User>`, the expression `user?.name` will\nevaluate to `null` if `user` is either `null` or an _empty_ `Optional` and will otherwise\nevaluate to the `name` of the `user`, effectively `user.get().getName()` or\n`user.get().name` for property or field access, respectively.\n\n[NOTE]\n====\nInvocations of methods defined in the `Optional` API are still supported on an _empty_\n`Optional`. For example, if `name` is of type `Optional<String>`, the expression\n`name?.orElse('Unknown')` will evaluate to `\"Unknown\"` if `name` is an empty `Optional`\nand will otherwise evaluate to the `String` contained in the `Optional` if `name` is a\nnon-empty `Optional`, effectively `name.get()`.\n====\n\nSimilarly, if `names` is of type `Optional<List<String>>`, the expression\n`names?.?&#8288;[#this.length > 5]` will evaluate to `null` if `names` is `null` or an _empty_\n`Optional` and will otherwise evaluate to a sequence containing the names whose lengths\nare greater than 5, effectively\n`names.get().stream().filter(s -> s.length() > 5).toList()`.\n\nThe same semantics apply to all of the null-safe operators mentioned previously in this\nchapter.\n\nFor further details and examples, consult the javadoc for the following operators.\n\n* {spring-framework-api}/expression/spel/ast/PropertyOrFieldReference.html[`PropertyOrFieldReference`]\n* {spring-framework-api}/expression/spel/ast/MethodReference.html[`MethodReference`]\n* {spring-framework-api}/expression/spel/ast/Indexer.html[`Indexer`]\n* {spring-framework-api}/expression/spel/ast/Selection.html[`Selection`]\n* {spring-framework-api}/expression/spel/ast/Projection.html[`Projection`]\n\n[[expressions-operator-safe-navigation-compound-expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-safe-navigation.adoc", "title": "operator-safe-navigation", "heading": "Null-safe Operations on `Optional`", "heading_level": 2, "file_order": 78, "section_index": 4, "content_hash": "9291dc661625254d06b3df40a30358fa17fb88a3b5b8474bcfe9b8f3edab70f3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-safe-navigation.adoc"}}
{"id": "sha256:f4ce552471ea79379f2c00c57d833405d3ce5c11452589db1309707c795f981a", "content": "As mentioned at the beginning of this section, when the safe navigation operator\nevaluates to `null` for a particular null-safe operation within a compound expression,\nthe remainder of the compound expression will still be evaluated. This means that the\nsafe navigation operator must be applied throughout a compound expression in order to\navoid any unwanted `NullPointerException`.\n\nGiven the expression `#person?.address.city`, if `#person` is `null` the safe navigation\noperator (`?.`) ensures that no exception will be thrown when attempting to access the\n`address` property of `#person`. However, since `#person?.address` evaluates to `null`, a\n`NullPointerException` will be thrown when attempting to access the `city` property of\n`null`. To address that, you can apply null-safe navigation throughout the compound\nexpression as in `#person?.address?.city`. That expression will safely evaluate to `null`\nif either `#person` or `#person?.address` evaluates to `null`.\n\nThe following example demonstrates how to use the \"null-safe select first\" operator\n(`?.^`) on a collection combined with null-safe property access (`?.`) within a compound\nexpression. If `members` is `null`, the result of the \"null-safe select first\" operator\n(`members?.^[nationality == 'Serbian']`) evaluates to `null`, and the additional use of\nthe safe navigation operator (`?.name`) ensures that the entire compound expression\nevaluates to `null` instead of throwing an exception.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tIEEE society = new IEEE();\n\tStandardEvaluationContext context = new StandardEvaluationContext(society);\n\tString expression = \"members?.^[nationality == 'Serbian']?.name\"; // <1>\n\n\t// evaluates to \"Nikola Tesla\"\n\tString name = parser.parseExpression(expression)\n .getValue(context, String.class);\n\n\tsociety.members = null;\n\n\t// evaluates to null - does not throw a NullPointerException\n\tname = parser.parseExpression(expression)\n .getValue(context, String.class);\n----\n<1> Use \"null-safe select first\" and null-safe property access operators within compound expression.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval society = IEEE()\n\tval context = StandardEvaluationContext(society)\n\tval expression = \"members?.^[nationality == 'Serbian']?.name\" // <1>\n\n\t// evaluates to \"Nikola Tesla\"\n\tString name = parser.parseExpression(expression)\n .getValue(context, String::class.java)\n\n\tsociety.members = null\n\n\t// evaluates to null - does not throw a NullPointerException\n\tname = parser.parseExpression(expression)\n .getValue(context, String::class.java)\n----\n<1> Use \"null-safe select first\" and null-safe property access operators within compound expression.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-safe-navigation.adoc", "title": "operator-safe-navigation", "heading": "Null-safe Operations in Compound Expressions", "heading_level": 2, "file_order": 78, "section_index": 5, "content_hash": "f4ce552471ea79379f2c00c57d833405d3ce5c11452589db1309707c795f981a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-safe-navigation.adoc"}}
{"id": "sha256:68d9ba5bac67c25e5d839ebc100b9c43fbae0a23c01c97cb23c2de521da989ff", "content": "[[expressions-operator-ternary]]\n\nYou can use the ternary operator for performing if-then-else conditional logic inside\nthe expression. The following listing shows a minimal example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString falseString = parser.parseExpression(\n \"false ? 'trueExp' : 'falseExp'\").getValue(String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval falseString = parser.parseExpression(\n \"false ? 'trueExp' : 'falseExp'\").getValue(String::class.java)\n----\n======\n\nIn this case, the boolean `false` results in returning the string value `'falseExp'`. A more\nrealistic example follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tparser.parseExpression(\"name\").setValue(societyContext, \"IEEE\");\n\tsocietyContext.setVariable(\"queryName\", \"Nikola Tesla\");\n\n\texpression = \"isMember(#queryName)? #queryName + ' is a member of the ' \" +\n \"+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'\";\n\n\tString queryResultString = parser.parseExpression(expression)\n .getValue(societyContext, String.class);\n\t// queryResultString = \"Nikola Tesla is a member of the IEEE Society\"\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tparser.parseExpression(\"name\").setValue(societyContext, \"IEEE\")\n\tsocietyContext.setVariable(\"queryName\", \"Nikola Tesla\")\n\n\texpression = \"isMember(#queryName)? #queryName + ' is a member of the ' \" + \"+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'\"\n\n\tval queryResultString = parser.parseExpression(expression)\n .getValue(societyContext, String::class.java)\n\t// queryResultString = \"Nikola Tesla is a member of the IEEE Society\"\n----\n======\n\nSee the next section on the Elvis operator for an even shorter syntax for the\nternary operator.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-ternary.adoc", "title": "operator-ternary", "heading": "operator-ternary", "heading_level": 1, "file_order": 79, "section_index": 0, "content_hash": "68d9ba5bac67c25e5d839ebc100b9c43fbae0a23c01c97cb23c2de521da989ff", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operator-ternary.adoc"}}
{"id": "sha256:79eab880aba5b665e63ed5f62bef0d398212638cb9f006730d658d98eb394480", "content": "[[expressions-operators]]\n\nThe Spring Expression Language supports the following kinds of operators:\n\n* xref:core/expressions/language-ref/operators.adoc#expressions-operators-relational[Relational Operators]\n* xref:core/expressions/language-ref/operators.adoc#expressions-operators-logical[Logical Operators]\n* xref:core/expressions/language-ref/operators.adoc#expressions-operators-string[String Operators]\n* xref:core/expressions/language-ref/operators.adoc#expressions-operators-mathematical[Mathematical Operators]\n* xref:core/expressions/language-ref/operators.adoc#expressions-assignment[The Assignment Operator]\n* xref:core/expressions/language-ref/operators.adoc#expressions-operators-overloaded[Overloaded Operators]\n\n[[expressions-operators-relational]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc", "title": "operators", "heading": "operators", "heading_level": 1, "file_order": 80, "section_index": 0, "content_hash": "79eab880aba5b665e63ed5f62bef0d398212638cb9f006730d658d98eb394480", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc"}}
{"id": "sha256:bea2929809379a48c413085ffad5745d418b41a9e07d89318876229b92eb0521", "content": "The relational operators (equal, not equal, less than, less than or equal, greater than,\nand greater than or equal) are supported by using standard operator notation.\nThese operators work on `Number` types as well as types implementing `Comparable`.\nThe following listing shows a few examples of relational operators:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to true\n\tboolean trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean.class);\n\n\t// evaluates to false\n\tboolean falseValue = parser.parseExpression(\"2 < -5.0\").getValue(Boolean.class);\n\n\t// evaluates to true\n\tboolean trueValue = parser.parseExpression(\"'black' < 'block'\").getValue(Boolean.class);\n\n\t// uses CustomValue:::compareTo\n\tboolean trueValue = parser.parseExpression(\"new CustomValue(1) < new CustomValue(2)\").getValue(Boolean.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to true\n\tval trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean::class.java)\n\n\t// evaluates to false\n\tval falseValue = parser.parseExpression(\"2 < -5.0\").getValue(Boolean::class.java)\n\n\t// evaluates to true\n\tval trueValue = parser.parseExpression(\"'black' < 'block'\").getValue(Boolean::class.java)\n\n\t// uses CustomValue:::compareTo\n\tval trueValue = parser.parseExpression(\"new CustomValue(1) < new CustomValue(2)\").getValue(Boolean::class.java);\n----\n======\n\n[NOTE]\n====\nGreater-than and less-than comparisons against `null` follow a simple rule: `null` is treated as\nnothing (that is NOT as zero). As a consequence, any other value is always greater\nthan `null` (`X > null` is always `true`) and no other value is ever less than nothing\n(`X < null` is always `false`).\n\nIf you prefer numeric comparisons instead, avoid number-based `null` comparisons\nin favor of comparisons against zero (for example, `X > 0` or `X < 0`).\n====\n\nEach symbolic operator can also be specified as a purely textual equivalent. This avoids\nproblems where the symbols used have special meaning for the document type in which the\nexpression is embedded (such as in an XML document). The textual equivalents are:\n\n* `lt` (`<`)\n* `gt` (`>`)\n* `le` (`\\<=`)\n* `ge` (`>=`)\n* `eq` (`==`)\n* `ne` (`!=`)\n\nAll of the textual operators are case-insensitive.\n\nIn addition to the standard relational operators, SpEL supports the `between`,\n`instanceof`, and regular expression-based `matches` operators. The following listing\nshows examples of all three:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tboolean result;\n\n\t// evaluates to true\n\tresult = parser.parseExpression(\n \"1 between {1, 5}\").getValue(Boolean.class);\n\n\t// evaluates to false\n\tresult = parser.parseExpression(\n \"1 between {10, 15}\").getValue(Boolean.class);\n\n\t// evaluates to true\n\tresult = parser.parseExpression(\n \"'elephant' between {'aardvark', 'zebra'}\").getValue(Boolean.class);\n\n\t// evaluates to false\n\tresult = parser.parseExpression(\n \"'elephant' between {'aardvark', 'cobra'}\").getValue(Boolean.class);\n\n\t// evaluates to true\n\tresult = parser.parseExpression(\n \"123 instanceof T(Integer)\").getValue(Boolean.class);\n\n\t// evaluates to false\n\tresult = parser.parseExpression(\n \"'xyz' instanceof T(Integer)\").getValue(Boolean.class);\n\n\t// evaluates to true\n\tresult = parser.parseExpression(\n \"'5.00' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n\n\t// evaluates to false\n\tresult = parser.parseExpression(\n \"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to true\n\tvar result = parser.parseExpression(\n \"1 between {1, 5}\").getValue(Boolean::class.java)\n\n\t// evaluates to false\n\tresult = parser.parseExpression(\n \"1 between {10, 15}\").getValue(Boolean::class.java)\n\n\t// evaluates to true\n\tresult = parser.parseExpression(\n \"'elephant' between {'aardvark', 'zebra'}\").getValue(Boolean::class.java)\n\n\t// evaluates to false\n\tresult = parser.parseExpression(\n \"'elephant' between {'aardvark', 'cobra'}\").getValue(Boolean::class.java)\n\n\t// evaluates to true\n\tresult = parser.parseExpression(\n \"123 instanceof T(Integer)\").getValue(Boolean::class.java)\n\n\t// evaluates to false\n\tresult = parser.parseExpression(\n \"'xyz' instanceof T(Integer)\").getValue(Boolean::class.java)\n\n\t// evaluates to true\n\tresult = parser.parseExpression(\n \"'5.00' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean::class.java)\n\n\t// evaluates to false\n\tresult = parser.parseExpression(\n \"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean::class.java)\n----\n======\n\n[CAUTION]\n====\nThe syntax for the `between` operator is `<input> between {<range_begin>, <range_end>}`,\nwhich is effectively a shortcut for `<input> >= <range_begin> && <input> \\<= <range_end>}`.\n\nConsequently, `1 between {1, 5}` evaluates to `true`, while `1 between {5, 1}` evaluates\nto `false`.\n====\n\nCAUTION: Be careful with primitive types, as they are immediately boxed up to their\nwrapper types. For example, `1 instanceof T(int)` evaluates to `false`, while\n`1 instanceof T(Integer)` evaluates to `true`.\n\n[[expressions-operators-logical]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc", "title": "operators", "heading": "Relational Operators", "heading_level": 2, "file_order": 80, "section_index": 1, "content_hash": "bea2929809379a48c413085ffad5745d418b41a9e07d89318876229b92eb0521", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc"}}
{"id": "sha256:6537a2bcad3c61cef774ae9adc53feda21ba497174ed507b18a84da7179edd31", "content": "SpEL supports the following logical (`boolean`) operators:\n\n* `and` (`&&`)\n* `or` (`||`)\n* `not` (`!`)\n\nAll of the textual operators are case-insensitive.\n\nThe following example shows how to use the logical operators:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// -- AND --\n\n\t// evaluates to false\n\tboolean falseValue = parser.parseExpression(\"true and false\").getValue(Boolean.class);\n\n\t// evaluates to true\n\tString expression = \"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\";\n\tboolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n\n\t// -- OR --\n\n\t// evaluates to true\n\tboolean trueValue = parser.parseExpression(\"true or false\").getValue(Boolean.class);\n\n\t// evaluates to true\n\tString expression = \"isMember('Nikola Tesla') or isMember('Albert Einstein')\";\n\tboolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n\n\t// -- NOT --\n\n\t// evaluates to false\n\tboolean falseValue = parser.parseExpression(\"!true\").getValue(Boolean.class);\n\n\t// -- AND and NOT --\n\n\tString expression = \"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\";\n\tboolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// -- AND --\n\n\t// evaluates to false\n\tval falseValue = parser.parseExpression(\"true and false\").getValue(Boolean::class.java)\n\n\t// evaluates to true\n\tval expression = \"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\"\n\tval trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean::class.java)\n\n\t// -- OR --\n\n\t// evaluates to true\n\tval trueValue = parser.parseExpression(\"true or false\").getValue(Boolean::class.java)\n\n\t// evaluates to true\n\tval expression = \"isMember('Nikola Tesla') or isMember('Albert Einstein')\"\n\tval trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean::class.java)\n\n\t// -- NOT --\n\n\t// evaluates to false\n\tval falseValue = parser.parseExpression(\"!true\").getValue(Boolean::class.java)\n\n\t// -- AND and NOT --\n\n\tval expression = \"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\"\n\tval falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean::class.java)\n----\n======\n\n[[expressions-operators-string]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc", "title": "operators", "heading": "Logical Operators", "heading_level": 2, "file_order": 80, "section_index": 2, "content_hash": "6537a2bcad3c61cef774ae9adc53feda21ba497174ed507b18a84da7179edd31", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc"}}
{"id": "sha256:ef77f5b36d998db8c36d1eb9479cc2d44a2aec3c04128454601f4c2ba10a615a", "content": "You can use the following operators on strings.\n\n* concatenation (`+`)\n* subtraction (`-`)\n - for use with a string containing a single character\n* repeat (`*`)\n\nThe following example shows the `String` operators in use:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// -- Concatenation --\n\n\t// evaluates to \"hello world\"\n\tString helloWorld = parser.parseExpression(\"'hello' + ' ' + 'world'\")\n .getValue(String.class);\n\n\t// -- Character Subtraction --\n\n\t// evaluates to 'a'\n\tchar ch = parser.parseExpression(\"'d' - 3\")\n .getValue(char.class);\n\n\t// -- Repeat --\n\n\t// evaluates to \"abcabc\"\n\tString repeated = parser.parseExpression(\"'abc' * 2\")\n .getValue(String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// -- Concatenation --\n\n\t// evaluates to \"hello world\"\n\tval helloWorld = parser.parseExpression(\"'hello' + ' ' + 'world'\")\n .getValue(String::class.java)\n\n\t// -- Character Subtraction --\n\n\t// evaluates to 'a'\n\tval ch = parser.parseExpression(\"'d' - 3\")\n .getValue(Character::class.java);\n\n\t// -- Repeat --\n\n\t// evaluates to \"abcabc\"\n\tval repeated = parser.parseExpression(\"'abc' * 2\")\n .getValue(String::class.java);\n----\n======\n\n[[expressions-operators-mathematical]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc", "title": "operators", "heading": "String Operators", "heading_level": 2, "file_order": 80, "section_index": 3, "content_hash": "ef77f5b36d998db8c36d1eb9479cc2d44a2aec3c04128454601f4c2ba10a615a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc"}}
{"id": "sha256:2d612a54713e38c53c45938d45f24d7a3fa6d0a72263b14a3134a06e6c6f1ac7", "content": "You can use the following operators on numbers, and standard operator precedence is enforced.\n\n* addition (`+`)\n* subtraction (`-`)\n* increment (`{pp}`)\n* decrement (`--`)\n* multiplication (`*`)\n* division (`/`)\n* modulus (`%`)\n* exponential power (`^`)\n\nThe division and modulus operators can also be specified as a purely textual equivalent.\nThis avoids problems where the symbols used have special meaning for the document type in\nwhich the expression is embedded (such as in an XML document). The textual equivalents\nare:\n\n* `div` (`/`)\n* `mod` (`%`)\n\nAll of the textual operators are case-insensitive.\n\n[NOTE]\n====\nThe increment and decrement operators can be used with either prefix (`{pp}A`, `--A`) or\npostfix (`A{pp}`, `A--`) notation with variables or properties that can be written to.\n====\n\nThe following example shows the mathematical operators in use:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tInventor inventor = new Inventor();\n\tEvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n\n\t// -- Addition --\n\n\tint two = parser.parseExpression(\"1 + 1\").getValue(int.class); // 2\n\n\t// -- Subtraction --\n\n\tint four = parser.parseExpression(\"1 - -3\").getValue(int.class); // 4\n\n\tdouble d = parser.parseExpression(\"1000.00 - 1e4\").getValue(double.class); // -9000\n\n\t// -- Increment --\n\n\t// The counter property in Inventor has an initial value of 0.\n\n\t// evaluates to 2; counter is now 1\n\ttwo = parser.parseExpression(\"counter++ + 2\").getValue(context, inventor, int.class);\n\n\t// evaluates to 5; counter is now 2\n\tint five = parser.parseExpression(\"3 + ++counter\").getValue(context, inventor, int.class);\n\n\t// -- Decrement --\n\n\t// The counter property in Inventor has a value of 2.\n\n\t// evaluates to 6; counter is now 1\n\tint six = parser.parseExpression(\"counter-- + 4\").getValue(context, inventor, int.class);\n\n\t// evaluates to 5; counter is now 0\n\tfive = parser.parseExpression(\"5 + --counter\").getValue(context, inventor, int.class);\n\n\t// -- Multiplication --\n\n\tsix = parser.parseExpression(\"-2 * -3\").getValue(int.class); // 6\n\n\tdouble twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(double.class); // 24.0\n\n\t// -- Division --\n\n\tint minusTwo = parser.parseExpression(\"6 / -3\").getValue(int.class); // -2\n\n\tdouble one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(double.class); // 1.0\n\n\t// -- Modulus --\n\n\tint three = parser.parseExpression(\"7 % 4\").getValue(int.class); // 3\n\n\tint oneInt = parser.parseExpression(\"8 / 5 % 2\").getValue(int.class); // 1\n\n\t// -- Exponential power --\n\n\tint maxInt = parser.parseExpression(\"(2^31) - 1\").getValue(int.class); // Integer.MAX_VALUE\n\n\tint minInt = parser.parseExpression(\"-2^31\").getValue(int.class); // Integer.MIN_VALUE\n\n\t// -- Operator precedence --\n\n\tint minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(int.class); // -21\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval inventor = Inventor()\n\tval context = SimpleEvaluationContext.forReadWriteDataBinding().build()\n\n\t// -- Addition --\n\n\tvar two = parser.parseExpression(\"1 + 1\").getValue(Int::class.java) // 2\n\n\t// -- Subtraction --\n\n\tval four = parser.parseExpression(\"1 - -3\").getValue(Int::class.java) // 4\n\n\tval d = parser.parseExpression(\"1000.00 - 1e4\").getValue(Double::class.java) // -9000\n\n\t// -- Increment --\n\n\t// The counter property in Inventor has an initial value of 0.\n\n\t// evaluates to 2; counter is now 1\n\ttwo = parser.parseExpression(\"counter++ + 2\").getValue(context, inventor, Int::class.java)\n\n\t// evaluates to 5; counter is now 2\n\tvar five = parser.parseExpression(\"3 + ++counter\").getValue(context, inventor, Int::class.java)\n\n\t// -- Decrement --\n\n\t// The counter property in Inventor has a value of 2.\n\n\t// evaluates to 6; counter is now 1\n\tvar six = parser.parseExpression(\"counter-- + 4\").getValue(context, inventor, Int::class.java)\n\n\t// evaluates to 5; counter is now 0\n\tfive = parser.parseExpression(\"5 + --counter\").getValue(context, inventor, Int::class.java)\n\n\t// -- Multiplication --\n\n\tsix = parser.parseExpression(\"-2 * -3\").getValue(Int::class.java) // 6\n\n\tval twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(Double::class.java) // 24.0\n\n\t// -- Division --\n\n\tval minusTwo = parser.parseExpression(\"6 / -3\").getValue(Int::class.java) // -2\n\n\tval one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(Double::class.java) // 1.0\n\n\t// -- Modulus --\n\n\tval three = parser.parseExpression(\"7 % 4\").getValue(Int::class.java) // 3\n\n\tval oneInt = parser.parseExpression(\"8 / 5 % 2\").getValue(Int::class.java) // 1\n\n\t// -- Exponential power --\n\n\tval maxInt = parser.parseExpression(\"(2^31) - 1\").getValue(Int::class.java) // Integer.MAX_VALUE\n\n\tval minInt = parser.parseExpression(\"-2^31\").getValue(Int::class.java) // Integer.MIN_VALUE\n\n\t// -- Operator precedence --\n\n\tval minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(Int::class.java) // -21\n----\n======\n\n[[expressions-assignment]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc", "title": "operators", "heading": "Mathematical Operators", "heading_level": 2, "file_order": 80, "section_index": 4, "content_hash": "2d612a54713e38c53c45938d45f24d7a3fa6d0a72263b14a3134a06e6c6f1ac7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc"}}
{"id": "sha256:411d989105e5d831212c4da185e44560a3ba709842e10ce51070edd4af34d61b", "content": "To set a property, use the assignment operator (`=`). This is typically done within a\ncall to `setValue` but can also be done inside a call to `getValue`. The following\nlisting shows both ways to use the assignment operator:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tInventor inventor = new Inventor();\n\tEvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n\n\tparser.parseExpression(\"name\").setValue(context, inventor, \"Aleksandar Seovic\");\n\n\t// alternatively\n\tString aleks = parser.parseExpression(\n \"name = 'Aleksandar Seovic'\").getValue(context, inventor, String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval inventor = Inventor()\n\tval context = SimpleEvaluationContext.forReadWriteDataBinding().build()\n\n\tparser.parseExpression(\"name\").setValue(context, inventor, \"Aleksandar Seovic\")\n\n\t// alternatively\n\tval aleks = parser.parseExpression(\n \"name = 'Aleksandar Seovic'\").getValue(context, inventor, String::class.java)\n----\n======\n\n[[expressions-operators-overloaded]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc", "title": "operators", "heading": "The Assignment Operator", "heading_level": 2, "file_order": 80, "section_index": 5, "content_hash": "411d989105e5d831212c4da185e44560a3ba709842e10ce51070edd4af34d61b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc"}}
{"id": "sha256:89cc0fc99432dda89fe2690e57da8a895022e421c0bcc2c1a5fde577bbeb6afd", "content": "By default, the mathematical operations defined in SpEL's `Operation` enum (`ADD`,\n`SUBTRACT`, `DIVIDE`, `MULTIPLY`, `MODULUS`, and `POWER`) support simple types like\nnumbers. By providing an implementation of `OperatorOverloader`, the expression language\ncan support these operations on other types.\n\nFor example, if we want to overload the `ADD` operator to allow two lists to be\nconcatenated using the `+` sign, we can implement a custom `OperatorOverloader` as\nfollows.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpubic class ListConcatenation implements OperatorOverloader {\n\n @Override\n public boolean overridesOperation(Operation operation, Object left, Object right) {\n return (operation == Operation.ADD &&\n left instanceof List && right instanceof List);\n }\n\n @Override\n @SuppressWarnings(\"unchecked\")\n public Object operate(Operation operation, Object left, Object right) {\n if (operation == Operation.ADD &&\n left instanceof List list1 && right instanceof List list2) {\n\n List result = new ArrayList(list1);\n result.addAll(list2);\n return result;\n }\n throw new UnsupportedOperationException(\n \"No overload for operation %s and operands [%s] and [%s]\"\n .formatted(operation, left, right));\n }\n\t}\n----\n\nIf we register `ListConcatenation` as the `OperatorOverloader` in a\n`StandardEvaluationContext`, we can then evaluate expressions like `{1, 2, 3} + {4, 5}`\nas demonstrated in the following example.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tStandardEvaluationContext context = new StandardEvaluationContext();\n\tcontext.setOperatorOverloader(new ListConcatenation());\n\n\t// evaluates to a new list: [1, 2, 3, 4, 5]\n\tparser.parseExpression(\"{1, 2, 3} + {2 + 2, 5}\").getValue(context, List.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tStandardEvaluationContext context = StandardEvaluationContext()\n\tcontext.setOperatorOverloader(ListConcatenation())\n\n\t// evaluates to a new list: [1, 2, 3, 4, 5]\n\tparser.parseExpression(\"{1, 2, 3} + {2 + 2, 5}\").getValue(context, List::class.java)\n----\n======\n\n[NOTE]\n====\nAn `OperatorOverloader` does not change the default semantics for an operator. For\nexample, `2 + 2` in the above example still evaluates to `4`.\n====\n\n[CAUTION]\n====\nAny expression that uses an overloaded operator cannot be compiled. See\nxref:core/expressions/evaluation.adoc#expressions-compiler-limitations[Compiler Limitations]\nfor details.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc", "title": "operators", "heading": "Overloaded Operators", "heading_level": 2, "file_order": 80, "section_index": 6, "content_hash": "89cc0fc99432dda89fe2690e57da8a895022e421c0bcc2c1a5fde577bbeb6afd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/operators.adoc"}}
{"id": "sha256:446222cabbe59f2d2e13cdbf8f6b08b1c46c34ce1088ebe9cfd98e87d46ef5e1", "content": "[[expressions-properties-arrays]]\n\nThe Spring Expression Language provides support for navigating object graphs and indexing\ninto various structures.\n\nNOTE: Numerical index values are zero-based, such as when accessing the n^th^ element of\nan array in Java.\n\nTIP: See the xref:core/expressions/language-ref/operator-safe-navigation.adoc[Safe Navigation Operator]\nsection for details on how to navigate object graphs and index into various structures\nusing the null-safe operator.\n\n[[expressions-property-navigation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc", "title": "properties-arrays", "heading": "properties-arrays", "heading_level": 1, "file_order": 81, "section_index": 0, "content_hash": "446222cabbe59f2d2e13cdbf8f6b08b1c46c34ce1088ebe9cfd98e87d46ef5e1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc"}}
{"id": "sha256:b6f22899a87565f530b442eec48350cb74170b028d5b0233c936e44df56a4d79", "content": "You can navigate property references within an object graph by using a period to indicate\na nested property value. The instances of the `Inventor` class, `pupin` and `tesla`, were\npopulated with data listed in the\nxref:core/expressions/example-classes.adoc[Classes used in the examples] section. To\nnavigate _down_ the object graph and get Tesla's year of birth and Pupin's city of birth,\nwe use the following expressions:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to 1856\n\tint year = (Integer) parser.parseExpression(\"birthdate.year + 1900\").getValue(context);\n\n\t// evaluates to \"Smiljan\"\n\tString city = (String) parser.parseExpression(\"placeOfBirth.city\").getValue(context);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to 1856\n\tval year = parser.parseExpression(\"birthdate.year + 1900\").getValue(context) as Int\n\n\t// evaluates to \"Smiljan\"\n\tval city = parser.parseExpression(\"placeOfBirth.city\").getValue(context) as String\n----\n======\n\n[NOTE]\n====\nCase insensitivity is allowed for the first letter of property names. Thus, the\nexpressions in the above example may be written as `Birthdate.Year + 1900` and\n`PlaceOfBirth.City`, respectively. In addition, properties may optionally be accessed via\nmethod invocations -- for example, `getPlaceOfBirth().getCity()` instead of\n`placeOfBirth.city`.\n====\n\n[[expressions-indexing-arrays-and-collections]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc", "title": "properties-arrays", "heading": "Property Navigation", "heading_level": 2, "file_order": 81, "section_index": 1, "content_hash": "b6f22899a87565f530b442eec48350cb74170b028d5b0233c936e44df56a4d79", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc"}}
{"id": "sha256:a6dafb71b9c0aa3e9fc48f4031624067b19662803d6b8d47117316714c271194", "content": "The n^th^ element of an array or collection (for example, a `Set` or `List`) can be\nobtained by using square bracket notation, as the following example shows.\n\n[NOTE]\n====\nIf the indexed collection is a `java.util.List`, the n^th^ element will be accessed\ndirectly via `list.get(n)`.\n\nFor any other type of `Collection`, the n^th^ element will be accessed by iterating over\nthe collection using its `Iterator` and returning the n^th^ element encountered.\n====\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tEvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n\n\t// Inventions Array\n\n\t// evaluates to \"Induction motor\"\n\tString invention = parser.parseExpression(\"inventions[3]\").getValue(\n context, tesla, String.class);\n\n\t// Members List\n\n\t// evaluates to \"Nikola Tesla\"\n\tString name = parser.parseExpression(\"members[0].name\").getValue(\n context, ieee, String.class);\n\n\t// List and Array Indexing\n\n\t// evaluates to \"Wireless communication\"\n\tString invention = parser.parseExpression(\"members[0].inventions[6]\").getValue(\n context, ieee, String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval context = SimpleEvaluationContext.forReadOnlyDataBinding().build()\n\n\t// Inventions Array\n\n\t// evaluates to \"Induction motor\"\n\tval invention = parser.parseExpression(\"inventions[3]\").getValue(\n context, tesla, String::class.java)\n\n\t// Members List\n\n\t// evaluates to \"Nikola Tesla\"\n\tval name = parser.parseExpression(\"members[0].name\").getValue(\n context, ieee, String::class.java)\n\n\t// List and Array Indexing\n\n\t// evaluates to \"Wireless communication\"\n\tval invention = parser.parseExpression(\"members[0].inventions[6]\").getValue(\n context, ieee, String::class.java)\n----\n======\n\n[[expressions-indexing-strings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc", "title": "properties-arrays", "heading": "Indexing into Arrays and Collections", "heading_level": 2, "file_order": 81, "section_index": 2, "content_hash": "a6dafb71b9c0aa3e9fc48f4031624067b19662803d6b8d47117316714c271194", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc"}}
{"id": "sha256:ba26d11f3d8d2bae8b3b0f9e9751e01d28232c17f62fc76af3d02777b108ae95", "content": "The n^th^ character of a string can be obtained by specifying the index within square\nbrackets, as demonstrated in the following example.\n\nNOTE: The n^th^ character of a string will evaluate to a `java.lang.String`, not a\n`java.lang.Character`.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to \"T\" (8th letter of \"Nikola Tesla\")\n\tString character = parser.parseExpression(\"members[0].name[7]\")\n .getValue(societyContext, String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to \"T\" (8th letter of \"Nikola Tesla\")\n\tval character = parser.parseExpression(\"members[0].name[7]\")\n .getValue(societyContext, String::class.java)\n----\n======\n\n[[expressions-indexing-maps]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc", "title": "properties-arrays", "heading": "Indexing into Strings", "heading_level": 2, "file_order": 81, "section_index": 3, "content_hash": "ba26d11f3d8d2bae8b3b0f9e9751e01d28232c17f62fc76af3d02777b108ae95", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc"}}
{"id": "sha256:d0c8114ebddd8351369b1ed359c8816fcf920a21477892a7db32fa6a64ff6c5d", "content": "The contents of maps are obtained by specifying the key value within square brackets. In\nthe following example, because keys for the `officers` map are strings, we can specify\nstring literals such as `'president'`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Officer's Map\n\n\t// evaluates to Inventor(\"Pupin\")\n\tInventor pupin = parser.parseExpression(\"officers['president']\")\n .getValue(societyContext, Inventor.class);\n\n\t// evaluates to \"Idvor\"\n\tString city = parser.parseExpression(\"officers['president'].placeOfBirth.city\")\n .getValue(societyContext, String.class);\n\n\tString countryExpression = \"officers['advisors'][0].placeOfBirth.country\";\n\n\t// setting values\n\tparser.parseExpression(countryExpression)\n .setValue(societyContext, \"Croatia\");\n\n\t// evaluates to \"Croatia\"\n\tString country = parser.parseExpression(countryExpression)\n .getValue(societyContext, String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Officer's Map\n\n\t// evaluates to Inventor(\"Pupin\")\n\tval pupin = parser.parseExpression(\"officers['president']\")\n .getValue(societyContext, Inventor::class.java)\n\n\t// evaluates to \"Idvor\"\n\tval city = parser.parseExpression(\"officers['president'].placeOfBirth.city\")\n .getValue(societyContext, String::class.java)\n\n\tval countryExpression = \"officers['advisors'][0].placeOfBirth.country\"\n\n\t// setting values\n\tparser.parseExpression(countryExpression)\n .setValue(societyContext, \"Croatia\")\n\n\t// evaluates to \"Croatia\"\n\tval country = parser.parseExpression(countryExpression)\n .getValue(societyContext, String::class.java)\n----\n======\n\n[[expressions-indexing-objects]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc", "title": "properties-arrays", "heading": "Indexing into Maps", "heading_level": 2, "file_order": 81, "section_index": 4, "content_hash": "d0c8114ebddd8351369b1ed359c8816fcf920a21477892a7db32fa6a64ff6c5d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc"}}
{"id": "sha256:7e51998b29cef06d1ea58581098414b8505cacc74ab3353c57f29c996adcd82d", "content": "A property of an object can be obtained by specifying the name of the property within\nsquare brackets. This is analogous to accessing the value of a map based on its key. The\nfollowing example demonstrates how to _index_ into an object to retrieve a specific\nproperty.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Create an inventor to use as the root context object.\n\tInventor tesla = new Inventor(\"Nikola Tesla\");\n\n\t// evaluates to \"Nikola Tesla\"\n\tString name = parser.parseExpression(\"#root['name']\")\n .getValue(context, tesla, String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Create an inventor to use as the root context object.\n\tval tesla = Inventor(\"Nikola Tesla\")\n\n\t// evaluates to \"Nikola Tesla\"\n\tval name = parser.parseExpression(\"#root['name']\")\n .getValue(context, tesla, String::class.java)\n----\n======\n\n[[expressions-indexing-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc", "title": "properties-arrays", "heading": "Indexing into Objects", "heading_level": 2, "file_order": 81, "section_index": 5, "content_hash": "7e51998b29cef06d1ea58581098414b8505cacc74ab3353c57f29c996adcd82d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc"}}
{"id": "sha256:979ba9512ba12b9ea2f66958b084f27e877f1008243e5b8bdc5e4a2070cc88f3", "content": "Since Spring Framework 6.2, the Spring Expression Language supports indexing into custom\nstructures by allowing developers to implement and register an `IndexAccessor` with the\n`EvaluationContext`. If you would like to support\nxref:core/expressions/evaluation.adoc#expressions-spel-compilation[compilation] of\nexpressions that rely on a custom index accessor, that index accessor must implement the\n`CompilableIndexAccessor` SPI.\n\nTo support common use cases, Spring provides a built-in `ReflectiveIndexAccessor` which\nis a flexible `IndexAccessor` that uses reflection to read from and optionally write to\nan indexed structure of a target object. The indexed structure can be accessed through a\n`public` read-method (when being read) or a `public` write-method (when being written).\nThe relationship between the read-method and write-method is based on a convention that\nis applicable for typical implementations of indexed structures.\n\nNOTE: `ReflectiveIndexAccessor` also implements `CompilableIndexAccessor` in order to\nsupport xref:core/expressions/evaluation.adoc#expressions-spel-compilation[compilation]\nto bytecode for read access. Note, however, that the configured read-method must be\ninvokable via a `public` class or `public` interface for compilation to succeed.\n\nThe following code listings define a `Color` enum and `FruitMap` type that behaves like a\nmap but does not implement the `java.util.Map` interface. Thus, if you want to index into\na `FruitMap` within a SpEL expression, you will need to register an `IndexAccessor`.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpackage example;\n\n\tpublic enum Color {\n RED, ORANGE, YELLOW\n\t}\n----\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class FruitMap {\n\n private final Map<Color, String> map = new HashMap<>();\n\n public FruitMap() {\n this.map.put(Color.RED, \"cherry\");\n this.map.put(Color.ORANGE, \"orange\");\n this.map.put(Color.YELLOW, \"banana\");\n }\n\n public String getFruit(Color color) {\n return this.map.get(color);\n }\n\n public void setFruit(Color color, String fruit) {\n this.map.put(color, fruit);\n }\n\t}\n----\n\nA read-only `IndexAccessor` for `FruitMap` can be created via `new\nReflectiveIndexAccessor(FruitMap.class, Color.class, \"getFruit\")`. With that accessor\nregistered and a `FruitMap` registered as a variable named `#fruitMap`, the SpEL\nexpression `#fruitMap[T(example.Color).RED]` will evaluate to `\"cherry\"`.\n\nA read-write `IndexAccessor` for `FruitMap` can be created via `new\nReflectiveIndexAccessor(FruitMap.class, Color.class, \"getFruit\", \"setFruit\")`. With that\naccessor registered and a `FruitMap` registered as a variable named `#fruitMap`, the SpEL\nexpression `#fruitMap[T(example.Color).RED] = 'strawberry'` can be used to change the\nfruit mapping for the color red from `\"cherry\"` to `\"strawberry\"`.\n\nThe following example demonstrates how to register a `ReflectiveIndexAccessor` to index\ninto a `FruitMap` and then index into the `FruitMap` within a SpEL expression.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Create a ReflectiveIndexAccessor for FruitMap\n\tIndexAccessor fruitMapAccessor = new ReflectiveIndexAccessor(\n FruitMap.class, Color.class, \"getFruit\", \"setFruit\");\n\n\t// Register the IndexAccessor for FruitMap\n\tcontext.addIndexAccessor(fruitMapAccessor);\n\n\t// Register the fruitMap variable\n\tcontext.setVariable(\"fruitMap\", new FruitMap());\n\n\t// evaluates to \"cherry\"\n\tString fruit = parser.parseExpression(\"#fruitMap[T(example.Color).RED]\")\n .getValue(context, String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Create a ReflectiveIndexAccessor for FruitMap\n\tval fruitMapAccessor = ReflectiveIndexAccessor(\n FruitMap::class.java, Color::class.java, \"getFruit\", \"setFruit\")\n\n\t// Register the IndexAccessor for FruitMap\n\tcontext.addIndexAccessor(fruitMapAccessor)\n\n\t// Register the fruitMap variable\n\tcontext.setVariable(\"fruitMap\", FruitMap())\n\n\t// evaluates to \"cherry\"\n\tval fruit = parser.parseExpression(\"#fruitMap[T(example.Color).RED]\")\n .getValue(context, String::class.java)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc", "title": "properties-arrays", "heading": "Indexing into Custom Structures", "heading_level": 2, "file_order": 81, "section_index": 6, "content_hash": "979ba9512ba12b9ea2f66958b084f27e877f1008243e5b8bdc5e4a2070cc88f3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/properties-arrays.adoc"}}
{"id": "sha256:87e3824f6813e36c6a0be9312f46487c9e2de42c06e2fd4c13ea372f4f041f4c", "content": "[[expressions-templating]]\n\nExpression templates allow mixing literal text with one or more evaluation blocks.\nEach evaluation block is delimited with prefix and suffix characters that you can\ndefine. A common choice is to use `+#{ }+` as the delimiters, as the following example\nshows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString randomPhrase = parser.parseExpression(\n \"random number is #{T(java.lang.Math).random()}\",\n new TemplateParserContext()).getValue(String.class);\n\n\t// evaluates to \"random number is 0.7038186818312008\"\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval randomPhrase = parser.parseExpression(\n \"random number is #{T(java.lang.Math).random()}\",\n TemplateParserContext()).getValue(String::class.java)\n\n\t// evaluates to \"random number is 0.7038186818312008\"\n----\n======\n\nThe string is evaluated by concatenating the literal text `'random number is '` with the\nresult of evaluating the expression inside the `+#{ }+` delimiters (in this case, the\nresult of calling that `random()` method). The second argument to the `parseExpression()`\nmethod is of the type `ParserContext`. The `ParserContext` interface is used to influence\nhow the expression is parsed in order to support the expression templating functionality.\nThe `TemplateParserContext` used in the previous example resides in the\n`org.springframework.expression.common` package and is an implementation of the\n`ParserContext` which by default configures the prefix and suffix to `#{` and `}`,\nrespectively.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/templating.adoc", "title": "templating", "heading": "templating", "heading_level": 1, "file_order": 82, "section_index": 0, "content_hash": "87e3824f6813e36c6a0be9312f46487c9e2de42c06e2fd4c13ea372f4f041f4c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/templating.adoc"}}
{"id": "sha256:11b8f4cb696305a9a44181e60506c0d61a37a234878f2bdbeb9ef993533193fb", "content": "[[expressions-types]]\n\nYou can use the special `T` operator to specify an instance of `java.lang.Class` (the\ntype). Static methods are invoked by using this operator as well. The\n`StandardEvaluationContext` uses a `TypeLocator` to find types, and the\n`StandardTypeLocator` (which can be replaced) is built with an understanding of the\n`java.lang` package. This means that `T()` references to types within the `java.lang`\npackage do not need to be fully qualified, but all other type references must be. The\nfollowing example shows how to use the `T` operator:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tClass dateClass = parser.parseExpression(\"T(java.util.Date)\").getValue(Class.class);\n\n\tClass stringClass = parser.parseExpression(\"T(String)\").getValue(Class.class);\n\n\tboolean trueValue = parser.parseExpression(\n \"T(java.math.RoundingMode).CEILING < T(java.math.RoundingMode).FLOOR\")\n .getValue(Boolean.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval dateClass = parser.parseExpression(\"T(java.util.Date)\").getValue(Class::class.java)\n\n\tval stringClass = parser.parseExpression(\"T(String)\").getValue(Class::class.java)\n\n\tval trueValue = parser.parseExpression(\n \"T(java.math.RoundingMode).CEILING < T(java.math.RoundingMode).FLOOR\")\n .getValue(Boolean::class.java)\n----\n======\n\n[NOTE]\n====\nIf your application or framework manages its own `EvaluationContext`, you may need to\nmanually configure a `StandardTypeLocator` with a specific `ClassLoader` to ensure that\nthe SpEL expression parser is able to reliably locate user types.\n\nFor example, the `StandardBeanExpressionResolver` in the `spring-context` module\nconfigures a `StandardTypeLocator` using the bean `ClassLoader` of the corresponding\n`BeanFactory`.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/types.adoc", "title": "types", "heading": "types", "heading_level": 1, "file_order": 83, "section_index": 0, "content_hash": "11b8f4cb696305a9a44181e60506c0d61a37a234878f2bdbeb9ef993533193fb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/types.adoc"}}
{"id": "sha256:7c155ef9a7726b4241345e119907f84a69e6a7bda128db276e472d56c6437420", "content": "[[expressions-varargs]]\n\nThe Spring Expression Language supports\nhttps://docs.oracle.com/javase/8/docs/technotes/guides/language/varargs.html[varargs]\ninvocations for xref:core/expressions/language-ref/constructors.adoc[constructors],\nxref:core/expressions/language-ref/methods.adoc[methods], and user-defined\nxref:core/expressions/language-ref/functions.adoc[functions].\n\nThe following example shows how to invoke the `java.lang.String#formatted(Object...)`\n_varargs_ method within an expression by supplying the variable argument list as separate\narguments (`'blue', 1`).\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to \"blue is color #1\"\n\tString expression = \"'%s is color #%d'.formatted('blue', 1)\";\n\tString message = parser.parseExpression(expression).getValue(String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to \"blue is color #1\"\n\tval expression = \"'%s is color #%d'.formatted('blue', 1)\"\n\tval message = parser.parseExpression(expression).getValue(String::class.java)\n----\n======\n\nA variable argument list can also be supplied as an array, as demonstrated in the\nfollowing example (`new Object[] {'blue', 1}`).\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to \"blue is color #1\"\n\tString expression = \"'%s is color #%d'.formatted(new Object[] {'blue', 1})\";\n\tString message = parser.parseExpression(expression).getValue(String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to \"blue is color #1\"\n\tval expression = \"'%s is color #%d'.formatted(new Object[] {'blue', 1})\"\n\tval message = parser.parseExpression(expression).getValue(String::class.java)\n----\n======\n\nAs an alternative, a variable argument list can be supplied as a `java.util.List` â€“ for\nexample, as an xref:core/expressions/language-ref/inline-lists.adoc[inline list]\n(`{'blue', 1}`). The following example shows how to do that.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to \"blue is color #1\"\n\tString expression = \"'%s is color #%d'.formatted({'blue', 1})\";\n\tString message = parser.parseExpression(expression).getValue(String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to \"blue is color #1\"\n\tval expression = \"'%s is color #%d'.formatted({'blue', 1})\"\n\tval message = parser.parseExpression(expression).getValue(String::class.java)\n----\n======\n\n[[expressions-varargs-type-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/varargs.adoc", "title": "varargs", "heading": "varargs", "heading_level": 1, "file_order": 84, "section_index": 0, "content_hash": "7c155ef9a7726b4241345e119907f84a69e6a7bda128db276e472d56c6437420", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/varargs.adoc"}}
{"id": "sha256:57205f0197e90fb6ce71cb3dbbe3fc6b7be5a6d2c65cad8056e1cf4f8b7335f0", "content": "In contrast to the standard support for varargs invocations in Java,\nxref:core/expressions/evaluation.adoc#expressions-type-conversion[type conversion] may be\napplied to the individual arguments when invoking varargs constructors, methods, or\nfunctions in SpEL.\n\nFor example, if we have registered a custom\nxref:core/expressions/language-ref/functions.adoc[function] in the `EvaluationContext`\nunder the name `#reverseStrings` for a method with the signature\n`String reverseStrings(String... strings)`, we can invoke that function within a SpEL\nexpression with any argument that can be converted to a `String`, as demonstrated in the\nfollowing example.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to \"3.0, 2.0, 1, SpEL\"\n\tString expression = \"#reverseStrings('SpEL', 1, 10F / 5, 3.0000)\";\n\tString message = parser.parseExpression(expression)\n .getValue(evaluationContext, String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to \"3.0, 2.0, 1, SpEL\"\n\tval expression = \"#reverseStrings('SpEL', 1, 10F / 5, 3.0000)\"\n\tval message = parser.parseExpression(expression)\n .getValue(evaluationContext, String::class.java)\n----\n======\n\nSimilarly, any array whose component type is a subtype of the required varargs type can\nbe supplied as the variable argument list for a varargs invocation. For example, a\n`String[]` array can be supplied to a varargs invocation that accepts an `Object...`\nargument list.\n\nThe following listing demonstrates that we can supply a `String[]` array to the\n`java.lang.String#formatted(Object...)` _varargs_ method. It also highlights that `1`\nwill be automatically converted to `\"1\"`.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to \"blue is color #1\"\n\tString expression = \"'%s is color #%s'.formatted(new String[] {'blue', 1})\";\n\tString message = parser.parseExpression(expression).getValue(String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// evaluates to \"blue is color #1\"\n\tval expression = \"'%s is color #%s'.formatted(new String[] {'blue', 1})\"\n\tval message = parser.parseExpression(expression).getValue(String::class.java)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/varargs.adoc", "title": "varargs", "heading": "Varargs Type Conversion", "heading_level": 2, "file_order": 84, "section_index": 1, "content_hash": "57205f0197e90fb6ce71cb3dbbe3fc6b7be5a6d2c65cad8056e1cf4f8b7335f0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/varargs.adoc"}}
{"id": "sha256:418f8118a7a07e1a1ef98f81791440394eed0d1588e2c2c993f5893c309d70cb", "content": "[[expressions-ref-variables]]\n\nYou can reference variables in an expression by using the `#variableName` syntax. Variables\nare set by using the `setVariable()` method in `EvaluationContext` implementations.\n\n[NOTE]\n====\nVariable names must begin with a letter (as defined below), an underscore, or a dollar\nsign.\n\nVariable names must be composed of one or more of the following supported types of\ncharacters.\n\n* letter: any character for which `java.lang.Character.isLetter(char)` returns `true`\n - This includes letters such as `A` to `Z`, `a` to `z`, `Ã¼`, `Ã±`, and `Ã©` as well as\n letters from other character sets such as Chinese, Japanese, Cyrillic, etc.\n* digit: `0` to `9`\n* underscore: `_`\n* dollar sign: `$`\n====\n\n[TIP]\n====\nWhen setting a variable or root context object in the `EvaluationContext`, it is advised\nthat the type of the variable or root context object be `public`.\n\nOtherwise, certain types of SpEL expressions involving a variable or root context object\nwith a non-public type may fail to evaluate or compile.\n====\n\n[WARNING]\n====\nSince variables share a common namespace with\nxref:core/expressions/language-ref/functions.adoc[functions] in the evaluation context,\ncare must be taken to ensure that variable names and functions names do not overlap.\n====\n\nThe following example shows how to use variables.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tInventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\");\n\n\tEvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n\tcontext.setVariable(\"newName\", \"Mike Tesla\");\n\n\tparser.parseExpression(\"name = #newName\").getValue(context, tesla);\n\tSystem.out.println(tesla.getName()); // \"Mike Tesla\"\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval tesla = Inventor(\"Nikola Tesla\", \"Serbian\")\n\n\tval context = SimpleEvaluationContext.forReadWriteDataBinding().build()\n\tcontext.setVariable(\"newName\", \"Mike Tesla\")\n\n\tparser.parseExpression(\"name = #newName\").getValue(context, tesla)\n\tprintln(tesla.name) // \"Mike Tesla\"\n----\n======\n\n[[expressions-this-root]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/variables.adoc", "title": "variables", "heading": "variables", "heading_level": 1, "file_order": 85, "section_index": 0, "content_hash": "418f8118a7a07e1a1ef98f81791440394eed0d1588e2c2c993f5893c309d70cb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/variables.adoc"}}
{"id": "sha256:bc9644abe00c34c2ba6c48a0ca06008ef28d9fe82458bd5ce83a5c892a0eb3af", "content": "The `#this` variable is always defined and refers to the current evaluation object\n(against which unqualified references are resolved). The `#root` variable is always\ndefined and refers to the root context object. Although `#this` may vary as components of\nan expression are evaluated, `#root` always refers to the root.\n\nThe following example shows how to use the `#this` variable in conjunction with\nxref:core/expressions/language-ref/collection-selection.adoc[collection selection].\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Create a list of prime integers.\n\tList<Integer> primes = List.of(2, 3, 5, 7, 11, 13, 17);\n\n\t// Create parser and set variable 'primes' as the list of integers.\n\tExpressionParser parser = new SpelExpressionParser();\n\tEvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n\tcontext.setVariable(\"primes\", primes);\n\n\t// Select all prime numbers > 10 from the list (using selection ?{...}).\n\tString expression = \"#primes.?[#this > 10]\";\n\n\t// Evaluates to a list containing [11, 13, 17].\n\tList<Integer> primesGreaterThanTen =\n parser.parseExpression(expression).getValue(context, List.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Create a list of prime integers.\n\tval primes = listOf(2, 3, 5, 7, 11, 13, 17)\n\n\t// Create parser and set variable 'primes' as the list of integers.\n\tval parser = SpelExpressionParser()\n\tval context = SimpleEvaluationContext.forReadWriteDataBinding().build()\n\tcontext.setVariable(\"primes\", primes)\n\n\t// Select all prime numbers > 10 from the list (using selection ?{...}).\n\tval expression = \"#primes.?[#this > 10]\"\n\n\t// Evaluates to a list containing [11, 13, 17].\n\tval primesGreaterThanTen = parser.parseExpression(expression)\n .getValue(context) as List<Int>\n----\n======\n\nThe following example shows how to use the `#this` and `#root` variables together in\nconjunction with\nxref:core/expressions/language-ref/collection-projection.adoc[collection projection].\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Create parser and evaluation context.\n\tExpressionParser parser = new SpelExpressionParser();\n\tEvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();\n\n\t// Create an inventor to use as the root context object.\n\tInventor tesla = new Inventor(\"Nikola Tesla\");\n\ttesla.setInventions(\"Telephone repeater\", \"Tesla coil transformer\");\n\n\t// Iterate over all inventions of the Inventor referenced as the #root\n\t// object, and generate a list of strings whose contents take the form\n\t// \"<inventor's name> invented the <invention>.\" (using projection !{...}).\n\tString expression = \"#root.inventions.![#root.name + ' invented the ' + #this + '.']\";\n\n\t// Evaluates to a list containing:\n\t// \"Nikola Tesla invented the Telephone repeater.\"\n\t// \"Nikola Tesla invented the Tesla coil transformer.\"\n\tList<String> results = parser.parseExpression(expression)\n .getValue(context, tesla, List.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Create parser and evaluation context.\n\tval parser = SpelExpressionParser()\n\tval context = SimpleEvaluationContext.forReadWriteDataBinding().build()\n\n\t// Create an inventor to use as the root context object.\n\tval tesla = Inventor(\"Nikola Tesla\")\n\ttesla.setInventions(\"Telephone repeater\", \"Tesla coil transformer\")\n\n\t// Iterate over all inventions of the Inventor referenced as the #root\n\t// object, and generate a list of strings whose contents take the form\n\t// \"<inventor's name> invented the <invention>.\" (using projection !{...}).\n\tval expression = \"#root.inventions.![#root.name + ' invented the ' + #this + '.']\"\n\n\t// Evaluates to a list containing:\n\t// \"Nikola Tesla invented the Telephone repeater.\"\n\t// \"Nikola Tesla invented the Tesla coil transformer.\"\n\tval results = parser.parseExpression(expression)\n .getValue(context, tesla, List::class.java)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref/variables.adoc", "title": "variables", "heading": "The `#this` and `#root` Variables", "heading_level": 2, "file_order": 85, "section_index": 1, "content_hash": "bc9644abe00c34c2ba6c48a0ca06008ef28d9fe82458bd5ce83a5c892a0eb3af", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref/variables.adoc"}}
{"id": "sha256:469949ce4a0ff5f921344d18f5be9584936a2b82fca7c14b9141a418732141e3", "content": "[[expressions-beandef]]\n\nYou can use SpEL expressions with configuration metadata for defining bean instances. In both\ncases, the syntax to define the expression is of the form `#{ <expression string> }`.\n\nAll beans in the application context are available as predefined variables with their\ncommon bean name. This includes standard context beans such as `environment` (of type\n`org.springframework.core.env.Environment`) as well as `systemProperties` and\n`systemEnvironment` (of type `Map<String, Object>`) for access to the runtime environment.\n\nTo specify a default value, you can place the `@Value` annotation on fields, methods,\nand method or constructor parameters (or XML equivalent).\n\nThe following example sets the default value of a field:\n\ninclude-code::./FieldValueTestBean[tag=snippet,indent=0]\n\nNote that you do not have to prefix the predefined variable with the `#` symbol here.\n\nThe following example shows the equivalent but on a property setter method:\n\ninclude-code::./PropertyValueTestBean[tag=snippet,indent=0]\n\nAutowired methods and constructors can also use the `@Value` annotation, as the following\nexamples show:\n\ninclude-code::./SimpleMovieLister[tag=snippet,indent=0]\n\ninclude-code::./MovieRecommender[tag=snippet,indent=0]\n\nYou can also refer to other bean properties by name, as the following example shows:\n\ninclude-code::./ShapeGuess[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/beandef.adoc", "title": "beandef", "heading": "beandef", "heading_level": 1, "file_order": 86, "section_index": 0, "content_hash": "469949ce4a0ff5f921344d18f5be9584936a2b82fca7c14b9141a418732141e3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/beandef.adoc"}}
{"id": "sha256:e6d2d2f3d223e58fb0f33b6ef291cf9c19b4f19e1669c755592bfc22feda63e2", "content": "[[expressions-evaluation]]\n\nThis section introduces programmatic use of SpEL's interfaces and its expression language.\nThe complete language reference can be found in the\nxref:core/expressions/language-ref.adoc[Language Reference].\n\nThe following code demonstrates how to use the SpEL API to evaluate the literal string\nexpression, `Hello World`.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tExpression exp = parser.parseExpression(\"'Hello World'\"); // <1>\n\tString message = (String) exp.getValue();\n----\n<1> The value of the message variable is `\"Hello World\"`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval exp = parser.parseExpression(\"'Hello World'\") // <1>\n\tval message = exp.value as String\n----\n<1> The value of the message variable is `\"Hello World\"`.\n======\n\nThe SpEL classes and interfaces you are most likely to use are located in the\n`org.springframework.expression` package and its sub-packages, such as `spel.support`.\n\nThe `ExpressionParser` interface is responsible for parsing an expression string. In the\npreceding example, the expression string is a string literal denoted by the surrounding\nsingle quotation marks. The `Expression` interface is responsible for evaluating the\ndefined expression string. The two types of exceptions that can be thrown when calling\n`parser.parseExpression(...)` and `exp.getValue(...)` are `ParseException` and\n`EvaluationException`, respectively.\n\nSpEL supports a wide range of features such as calling methods, accessing properties,\nand calling constructors.\n\nIn the following method invocation example, we call the `concat` method on the string\nliteral, `Hello World`.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tExpression exp = parser.parseExpression(\"'Hello World'.concat('!')\"); // <1>\n\tString message = (String) exp.getValue();\n----\n<1> The value of `message` is now `\"Hello World!\"`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval exp = parser.parseExpression(\"'Hello World'.concat('!')\") // <1>\n\tval message = exp.value as String\n----\n<1> The value of `message` is now `\"Hello World!\"`.\n======\n\nThe following example demonstrates how to access the `Bytes` JavaBean property of the\nstring literal, `Hello World`.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\n\t// invokes 'getBytes()'\n\tExpression exp = parser.parseExpression(\"'Hello World'.bytes\"); // <1>\n\tbyte[] bytes = (byte[]) exp.getValue();\n----\n<1> This line converts the literal to a byte array.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\n\t// invokes 'getBytes()'\n\tval exp = parser.parseExpression(\"'Hello World'.bytes\") // <1>\n\tval bytes = exp.value as ByteArray\n----\n<1> This line converts the literal to a byte array.\n======\n\nSpEL also supports nested properties by using the standard dot notation (such as\n`prop1.prop2.prop3`) as well as the corresponding setting of property values.\nPublic fields may also be accessed.\n\nThe following example shows how to use dot notation to get the length of a string literal.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\n\t// invokes 'getBytes().length'\n\tExpression exp = parser.parseExpression(\"'Hello World'.bytes.length\"); // <1>\n\tint length = (Integer) exp.getValue();\n----\n<1> `'Hello World'.bytes.length` gives the length of the literal.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\n\t// invokes 'getBytes().length'\n\tval exp = parser.parseExpression(\"'Hello World'.bytes.length\") // <1>\n\tval length = exp.value as Int\n----\n<1> `'Hello World'.bytes.length` gives the length of the literal.\n======\n\nThe String's constructor can be called instead of using a string literal, as the following\nexample shows.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExpressionParser parser = new SpelExpressionParser();\n\tExpression exp = parser.parseExpression(\"new String('hello world').toUpperCase()\"); // <1>\n\tString message = exp.getValue(String.class);\n----\n<1> Construct a new `String` from the literal and convert it to upper case.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval parser = SpelExpressionParser()\n\tval exp = parser.parseExpression(\"new String('hello world').toUpperCase()\") // <1>\n\tval message = exp.getValue(String::class.java)\n----\n<1> Construct a new `String` from the literal and convert it to upper case.\n======\n\nNote the use of the generic method: `public <T> T getValue(Class<T> desiredResultType)`.\nUsing this method removes the need to cast the value of the expression to the desired\nresult type. An `EvaluationException` is thrown if the value cannot be cast to the\ntype `T` or converted by using the registered type converter.\n\nThe more common usage of SpEL is to provide an expression string that is evaluated\nagainst a specific object instance (called the root object). The following example shows\nhow to retrieve the `name` property from an instance of the `Inventor` class and how to\nreference the `name` property in a boolean expression.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Create and set a calendar\n\tGregorianCalendar c = new GregorianCalendar();\n\tc.set(1856, 7, 9);\n\n\t// The constructor arguments are name, birthday, and nationality.\n\tInventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\");\n\n\tExpressionParser parser = new SpelExpressionParser();\n\n\tExpression exp = parser.parseExpression(\"name\"); // Parse name as an expression\n\tString name = (String) exp.getValue(tesla);\n\t// name == \"Nikola Tesla\"\n\n\texp = parser.parseExpression(\"name == 'Nikola Tesla'\");\n\tboolean result = exp.getValue(tesla, Boolean.class);\n\t// result == true\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Create and set a calendar\n\tval c = GregorianCalendar()\n\tc.set(1856, 7, 9)\n\n\t// The constructor arguments are name, birthday, and nationality.\n\tval tesla = Inventor(\"Nikola Tesla\", c.time, \"Serbian\")\n\n\tval parser = SpelExpressionParser()\n\n\tvar exp = parser.parseExpression(\"name\") // Parse name as an expression\n\tval name = exp.getValue(tesla) as String\n\t// name == \"Nikola Tesla\"\n\n\texp = parser.parseExpression(\"name == 'Nikola Tesla'\")\n\tval result = exp.getValue(tesla, Boolean::class.java)\n\t// result == true\n----\n======\n\n[[expressions-evaluation-context]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc", "title": "evaluation", "heading": "evaluation", "heading_level": 1, "file_order": 87, "section_index": 0, "content_hash": "e6d2d2f3d223e58fb0f33b6ef291cf9c19b4f19e1669c755592bfc22feda63e2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc"}}
{"id": "sha256:9c5b11bd1b6753ce4b80053dc43c19a20c7c75e3a9db959ddd375aeeec7d2917", "content": "The `EvaluationContext` API is used when evaluating an expression to resolve properties,\nmethods, or fields and to help perform type conversion. Spring provides two\nimplementations.\n\n`SimpleEvaluationContext`::\n Exposes a subset of essential SpEL language features and configuration options, for\n categories of expressions that do not require the full extent of the SpEL language\n syntax and should be meaningfully restricted. Examples include but are not limited to\n data binding expressions and property-based filters.\n\n`StandardEvaluationContext`::\n Exposes the full set of SpEL language features and configuration options. You can use\n it to specify a default root object and to configure every available evaluation-related\n strategy.\n\n`SimpleEvaluationContext` is designed to support only a subset of the SpEL language\nsyntax. For example, it excludes Java type references, constructors, and bean references.\nIt also requires you to explicitly choose the level of support for properties and methods\nin expressions. When creating a `SimpleEvaluationContext` you need to choose the level of\nsupport that you need for data binding in SpEL expressions:\n\n* Data binding for read-only access\n* Data binding for read and write access\n* A custom `PropertyAccessor` (typically not reflection-based), potentially combined with\n a `DataBindingPropertyAccessor`\n\nConveniently, `SimpleEvaluationContext.forReadOnlyDataBinding()` enables read-only access\nto properties via `DataBindingPropertyAccessor`. Similarly,\n`SimpleEvaluationContext.forReadWriteDataBinding()` enables read and write access to\nproperties. Alternatively, configure custom accessors via\n`SimpleEvaluationContext.forPropertyAccessors(...)`, potentially disable assignment, and\noptionally activate method resolution and/or a type converter through the builder.\n\n[[expressions-type-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc", "title": "evaluation", "heading": "Understanding `EvaluationContext`", "heading_level": 2, "file_order": 87, "section_index": 1, "content_hash": "9c5b11bd1b6753ce4b80053dc43c19a20c7c75e3a9db959ddd375aeeec7d2917", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc"}}
{"id": "sha256:6c23cd51fc6f18b7d058d44eff1d36d42d31fa500da4608397a197a022e555f4", "content": "By default, SpEL uses the conversion service available in Spring core\n(`org.springframework.core.convert.ConversionService`). This conversion service comes\nwith many built-in converters for common conversions, but is also fully extensible so\nthat you can add custom conversions between types. Additionally, it is generics-aware.\nThis means that, when you work with generic types in expressions, SpEL attempts\nconversions to maintain type correctness for any objects it encounters.\n\nWhat does this mean in practice? Suppose assignment, using `setValue()`, is being used\nto set a `List` property. The type of the property is actually `List<Boolean>`. SpEL\nrecognizes that the elements of the list need to be converted to `Boolean` before\nbeing placed in it. The following example shows how to do so.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Simple {\n public List<Boolean> booleanList = new ArrayList<>();\n\t}\n\n\tSimple simple = new Simple();\n\tsimple.booleanList.add(true);\n\n\tEvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();\n\n\t// \"false\" is passed in here as a String. SpEL and the conversion service\n\t// will recognize that it needs to be a Boolean and convert it accordingly.\n\tparser.parseExpression(\"booleanList[0]\").setValue(context, simple, \"false\");\n\n\t// b is false\n\tBoolean b = simple.booleanList.get(0);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Simple {\n var booleanList: MutableList<Boolean> = ArrayList()\n\t}\n\n\tval simple = Simple()\n\tsimple.booleanList.add(true)\n\n\tval context = SimpleEvaluationContext.forReadOnlyDataBinding().build()\n\n\t// \"false\" is passed in here as a String. SpEL and the conversion service\n\t// will recognize that it needs to be a Boolean and convert it accordingly.\n\tparser.parseExpression(\"booleanList[0]\").setValue(context, simple, \"false\")\n\n\t// b is false\n\tval b = simple.booleanList[0]\n----\n======\n\n[[expressions-parser-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc", "title": "evaluation", "heading": "Type Conversion", "heading_level": 3, "file_order": 87, "section_index": 2, "content_hash": "6c23cd51fc6f18b7d058d44eff1d36d42d31fa500da4608397a197a022e555f4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc"}}
{"id": "sha256:9881799cccb44c3129d05eb352b2708bb05ce99d672e6edde42318a0197ddd84", "content": "It is possible to configure the SpEL expression parser by using a parser configuration\nobject (`org.springframework.expression.spel.SpelParserConfiguration`). The configuration\nobject controls the behavior of some of the expression components. For example, if you\nindex into a collection and the element at the specified index is `null`, SpEL can\nautomatically create the element. This is useful when using expressions made up of a\nchain of property references. Similarly, if you index into a collection and specify an\nindex that is greater than the current size of the collection, SpEL can automatically\ngrow the collection to accommodate that index. In order to add an element at the\nspecified index, SpEL will try to create the element using the element type's default\nconstructor before setting the specified value. If the element type does not have a\ndefault constructor, `null` will be added to the collection. If there is no built-in\nconverter or custom converter that knows how to set the value, `null` will remain in the\ncollection at the specified index. The following example demonstrates how to\nautomatically grow a `List`.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Demo {\n public List<String> list;\n\t}\n\n\t// Turn on:\n\t// - auto null reference initialization\n\t// - auto collection growing\n\tSpelParserConfiguration config = new SpelParserConfiguration(true, true);\n\n\tExpressionParser parser = new SpelExpressionParser(config);\n\n\tExpression expression = parser.parseExpression(\"list[3]\");\n\n\tDemo demo = new Demo();\n\n\tObject o = expression.getValue(demo);\n\n\t// demo.list will now be a real collection of 4 entries\n\t// Each entry is a new empty String\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Demo {\n var list: List<String>? = null\n\t}\n\n\t// Turn on:\n\t// - auto null reference initialization\n\t// - auto collection growing\n\tval config = SpelParserConfiguration(true, true)\n\n\tval parser = SpelExpressionParser(config)\n\n\tval expression = parser.parseExpression(\"list[3]\")\n\n\tval demo = Demo()\n\n\tval o = expression.getValue(demo)\n\n\t// demo.list will now be a real collection of 4 entries\n\t// Each entry is a new empty String\n----\n======\n\nBy default, a SpEL expression cannot contain more than 10,000 characters; however, the\n`maxExpressionLength` is configurable. If you create a `SpelExpressionParser`\nprogrammatically, you can specify a custom `maxExpressionLength` when creating the\n`SpelParserConfiguration` that you provide to the `SpelExpressionParser`. If you wish to\nset the `maxExpressionLength` used for parsing SpEL expressions within an\n`ApplicationContext` -- for example, in XML bean definitions, `@Value`, etc. -- you can\nset a JVM system property or Spring property named `spring.context.expression.maxLength`\nto the maximum expression length needed by your application (see\nxref:appendix.adoc#appendix-spring-properties[Supported Spring Properties]).\n\n[[expressions-spel-compilation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc", "title": "evaluation", "heading": "Parser Configuration", "heading_level": 2, "file_order": 87, "section_index": 3, "content_hash": "9881799cccb44c3129d05eb352b2708bb05ce99d672e6edde42318a0197ddd84", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc"}}
{"id": "sha256:a23e11223c89fff54150b7a48e24f68b98515659b5e3af0fda3b3b230358cb3e", "content": "Spring provides a basic compiler for SpEL expressions. Expressions are usually\ninterpreted, which provides a lot of dynamic flexibility during evaluation but does not\nprovide optimum performance. For occasional expression usage, this is fine, but, when\nused by other components such as Spring Integration, performance can be very important,\nand there is no real need for the dynamism.\n\nThe SpEL compiler is intended to address this need. During evaluation, the compiler\ngenerates a Java class that embodies the expression behavior at runtime and uses that\nclass to achieve much faster expression evaluation. Due to the lack of typing around\nexpressions, the compiler uses information gathered during the interpreted evaluations\nof an expression when performing compilation. For example, it does not know the type\nof a property reference purely from the expression, but during the first interpreted\nevaluation, it finds out what it is. Of course, basing compilation on such derived\ninformation can cause trouble later if the types of the various expression elements\nchange over time. For this reason, compilation is best suited to expressions whose\ntype information is not going to change on repeated evaluations.\n\nConsider the following basic expression.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tsomeArray[0].someProperty.someOtherProperty < 0.1\n----\n\nBecause the preceding expression involves array access, some property de-referencing, and\nnumeric operations, the performance gain can be very noticeable. In an example micro\nbenchmark run of 50,000 iterations, it took 75ms to evaluate by using the interpreter and\nonly 3ms using the compiled version of the expression.\n\n[[expressions-compiler-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc", "title": "evaluation", "heading": "SpEL Compilation", "heading_level": 2, "file_order": 87, "section_index": 4, "content_hash": "a23e11223c89fff54150b7a48e24f68b98515659b5e3af0fda3b3b230358cb3e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc"}}
{"id": "sha256:5a0d973373d299c7b22e70c1cb03e68140bc1ffdafb3a55269486f6ef7430595", "content": "The compiler is not turned on by default, but you can turn it on in either of two\ndifferent ways. You can turn it on by using the parser configuration process\n(xref:core/expressions/evaluation.adoc#expressions-parser-configuration[discussed\nearlier]) or by using a Spring property when SpEL usage is embedded inside another\ncomponent. This section discusses both of these options.\n\nThe compiler can operate in one of three modes, which are captured in the\n`org.springframework.expression.spel.SpelCompilerMode` enum. The modes are as follows.\n\n`OFF` ::\n The compiler is switched off, and all expressions will be evaluated in _interpreted_\n mode. This is the default mode.\n`IMMEDIATE` ::\n In immediate mode, expressions are compiled as soon as possible, typically after the\n first interpreted evaluation. If evaluation of the compiled expression fails (for\n example, due to a type changing, as described earlier), the caller of the expression\n evaluation receives an exception. If the types of various expression elements change\n over time, consider switching to `MIXED` mode or turning off the compiler.\n`MIXED` ::\n In mixed mode, expression evaluation silently switches between _interpreted_ and\n _compiled_ over time. After some number of successful interpreted runs, the expression\n gets compiled. If evaluation of the compiled expression fails (for example, due to a\n type changing), that failure will be caught internally, and the system will switch back\n to interpreted mode for the given expression. Basically, the exception that the caller\n receives in `IMMEDIATE` mode is instead handled internally. Sometime later, the\n compiler may generate another compiled form and switch to it. This cycle of switching\n between interpreted and compiled mode will continue until the system determines that it\n does not make sense to continue trying â€” for example, when a certain failure threshold\n has been reached â€” at which point the system will permanently switch to interpreted\n mode for the given expression.\n\n`IMMEDIATE` mode exists because `MIXED` mode could cause issues for expressions that\nhave side effects. If a compiled expression blows up after partially succeeding, it\nmay have already done something that has affected the state of the system. If this\nhas happened, the caller may not want it to silently re-run in interpreted mode,\nsince part of the expression may be run twice.\n\nAfter selecting a mode, use the `SpelParserConfiguration` to configure the parser. The\nfollowing example shows how to do so.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tSpelParserConfiguration config = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,\n this.getClass().getClassLoader());\n\n\tSpelExpressionParser parser = new SpelExpressionParser(config);\n\n\tExpression expr = parser.parseExpression(\"payload\");\n\n\tMyMessage message = new MyMessage();\n\n\tObject payload = expr.getValue(message);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval config = SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,\n this.javaClass.classLoader)\n\n\tval parser = SpelExpressionParser(config)\n\n\tval expr = parser.parseExpression(\"payload\")\n\n\tval message = MyMessage()\n\n\tval payload = expr.getValue(message)\n----\n======\n\nWhen you specify the compiler mode, you can also specify a `ClassLoader` (passing `null`\nis allowed). Compiled expressions are defined in a child `ClassLoader` created under any\nthat is supplied. It is important to ensure that, if a `ClassLoader` is specified, it can\nsee all the types involved in the expression evaluation process. If you do not specify a\n`ClassLoader`, a default `ClassLoader` is used (typically the context `ClassLoader` for\nthe thread that is running during expression evaluation).\n\nThe second way to configure the compiler is for use when SpEL is embedded inside some\nother component and it may not be possible to configure it through a configuration\nobject. In such cases, it is possible to set the `spring.expression.compiler.mode`\nproperty via a JVM system property (or via the\nxref:appendix.adoc#appendix-spring-properties[`SpringProperties`] mechanism) to one of the\n`SpelCompilerMode` enum values (`off`, `immediate`, or `mixed`).\n\n[[expressions-compiler-limitations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc", "title": "evaluation", "heading": "Compiler Configuration", "heading_level": 3, "file_order": 87, "section_index": 5, "content_hash": "5a0d973373d299c7b22e70c1cb03e68140bc1ffdafb3a55269486f6ef7430595", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc"}}
{"id": "sha256:e2474487921da3f77486e58933ca9469de863680416eac780fa5d25d0a64b194", "content": "Spring does not support compiling every kind of expression. The primary focus is on\ncommon expressions that are likely to be used in performance-critical contexts. The\nfollowing kinds of expressions cannot be compiled.\n\n* Expressions involving assignment\n* Expressions relying on the conversion service\n* Expressions using custom resolvers\n* Expressions using overloaded operators\n* Expressions using `Optional` with the null-safe or Elvis operator\n* Expressions using array construction syntax\n* Expressions using selection or projection\n* Expressions using bean references\n\nCompilation of additional kinds of expressions may be supported in the future.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc", "title": "evaluation", "heading": "Compiler Limitations", "heading_level": 3, "file_order": 87, "section_index": 6, "content_hash": "e2474487921da3f77486e58933ca9469de863680416eac780fa5d25d0a64b194", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/evaluation.adoc"}}
{"id": "sha256:5c90fff06d217b1ce7004e82e452af83caa9074e9f75b3c7aeff4135431db16b", "content": "[[expressions-example-classes]]\n\nThis section lists the classes used in the examples throughout this chapter.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/example-classes.adoc", "title": "example-classes", "heading": "example-classes", "heading_level": 1, "file_order": 88, "section_index": 0, "content_hash": "5c90fff06d217b1ce7004e82e452af83caa9074e9f75b3c7aeff4135431db16b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/example-classes.adoc"}}
{"id": "sha256:2039d7d0ecef11940f85caea573af2c3fd3dad7100e000fddb02063f1ef11ef8", "content": "[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.spring.samples.spel.inventor;\n\n\timport java.util.Date;\n\timport java.util.GregorianCalendar;\n\n\tpublic class Inventor {\n\n private String name;\n private String nationality;\n private String[] inventions;\n private Date birthdate;\n private PlaceOfBirth placeOfBirth;\n\n public Inventor(String name, String nationality) {\n GregorianCalendar c= new GregorianCalendar();\n this.name = name;\n this.nationality = nationality;\n this.birthdate = c.getTime();\n }\n\n public Inventor(String name, Date birthdate, String nationality) {\n this.name = name;\n this.nationality = nationality;\n this.birthdate = birthdate;\n }\n\n public Inventor() {\n }\n\n public String getName() {\n return name;\n }\n\n public void setName(String name) {\n this.name = name;\n }\n\n public String getNationality() {\n return nationality;\n }\n\n public void setNationality(String nationality) {\n this.nationality = nationality;\n }\n\n public Date getBirthdate() {\n return birthdate;\n }\n\n public void setBirthdate(Date birthdate) {\n this.birthdate = birthdate;\n }\n\n public PlaceOfBirth getPlaceOfBirth() {\n return placeOfBirth;\n }\n\n public void setPlaceOfBirth(PlaceOfBirth placeOfBirth) {\n this.placeOfBirth = placeOfBirth;\n }\n\n public void setInventions(String[] inventions) {\n this.inventions = inventions;\n }\n\n public String[] getInventions() {\n return inventions;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.spring.samples.spel.inventor\n\n\tclass Inventor(\n var name: String,\n var nationality: String,\n var inventions: Array<String>? = null,\n var birthdate: Date = GregorianCalendar().time,\n var placeOfBirth: PlaceOfBirth? = null)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/example-classes.adoc", "title": "example-classes", "heading": "`Inventor`", "heading_level": 2, "file_order": 88, "section_index": 1, "content_hash": "2039d7d0ecef11940f85caea573af2c3fd3dad7100e000fddb02063f1ef11ef8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/example-classes.adoc"}}
{"id": "sha256:857581e0472a3c80aa0711cacbfd992d657e029521de7e47f26331df39bdcc10", "content": "[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.spring.samples.spel.inventor;\n\n\tpublic class PlaceOfBirth {\n\n private String city;\n private String country;\n\n public PlaceOfBirth(String city) {\n this.city=city;\n }\n\n public PlaceOfBirth(String city, String country) {\n this(city);\n this.country = country;\n }\n\n public String getCity() {\n return city;\n }\n\n public void setCity(String s) {\n this.city = s;\n }\n\n public String getCountry() {\n return country;\n }\n\n public void setCountry(String country) {\n this.country = country;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.spring.samples.spel.inventor\n\n\tclass PlaceOfBirth(var city: String, var country: String? = null) {\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/example-classes.adoc", "title": "example-classes", "heading": "`PlaceOfBirth`", "heading_level": 2, "file_order": 88, "section_index": 2, "content_hash": "857581e0472a3c80aa0711cacbfd992d657e029521de7e47f26331df39bdcc10", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/example-classes.adoc"}}
{"id": "sha256:96b456b7c465bb1045244dc506bffc43471f9cea2ad84d242e38f65700d3a103", "content": "[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.spring.samples.spel.inventor;\n\n\timport java.util.*;\n\n\tpublic class Society {\n\n private String name;\n\n public static String Advisors = \"advisors\";\n public static String President = \"president\";\n\n private List<Inventor> members = new ArrayList<>();\n private Map officers = new HashMap();\n\n public List getMembers() {\n return members;\n }\n\n public Map getOfficers() {\n return officers;\n }\n\n public String getName() {\n return name;\n }\n\n public void setName(String name) {\n this.name = name;\n }\n\n public boolean isMember(String name) {\n for (Inventor inventor : members) {\n if (inventor.getName().equals(name)) {\n return true;\n }\n }\n return false;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.spring.samples.spel.inventor\n\n\timport java.util.*\n\n\tclass Society {\n\n val Advisors = \"advisors\"\n val President = \"president\"\n\n var name: String? = null\n\n val members = ArrayList<Inventor>()\n val officers = mapOf<Any, Any>()\n\n fun isMember(name: String): Boolean {\n for (inventor in members) {\n if (inventor.name == name) {\n return true\n }\n }\n return false\n }\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/example-classes.adoc", "title": "example-classes", "heading": "`Society`", "heading_level": 2, "file_order": 88, "section_index": 3, "content_hash": "96b456b7c465bb1045244dc506bffc43471f9cea2ad84d242e38f65700d3a103", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/example-classes.adoc"}}
{"id": "sha256:31a718c0d2bbc50183b32b238a161e679a2c66e718181851775f6018f2ab6f45", "content": "[[expressions-language-ref]]\n\nThis section describes how the Spring Expression Language works.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions/language-ref.adoc", "title": "language-ref", "heading": "language-ref", "heading_level": 1, "file_order": 89, "section_index": 0, "content_hash": "31a718c0d2bbc50183b32b238a161e679a2c66e718181851775f6018f2ab6f45", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions/language-ref.adoc"}}
{"id": "sha256:9020dda6c9ed0bb41389a682c043000dcbf7b80a06709efba48ee9c6db313df5", "content": "[[validation-beanvalidation]]\n\nThe Spring Framework provides support for the\n{bean-validation-site}[Java Bean Validation] API.\n\n[[validation-beanvalidation-overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc", "title": "beanvalidation", "heading": "beanvalidation", "heading_level": 1, "file_order": 90, "section_index": 0, "content_hash": "9020dda6c9ed0bb41389a682c043000dcbf7b80a06709efba48ee9c6db313df5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc"}}
{"id": "sha256:5c3185fe71e080e398611f2da132292b4961457cdc574094ae64100557c75e9a", "content": "Bean Validation provides a common way of validation through constraint declaration and\nmetadata for Java applications. To use it, you annotate domain model properties with\ndeclarative validation constraints which are then enforced by the runtime. There are\nbuilt-in constraints, and you can also define your own custom constraints.\n\nConsider the following example, which shows a simple `PersonForm` model with two properties:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class PersonForm {\n private String name;\n private int age;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass PersonForm(\n private val name: String,\n private val age: Int\n\t)\n----\n======\n\nBean Validation lets you declare constraints as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class PersonForm {\n\n @NotNull\n @Size(max=64)\n private String name;\n\n @Min(0)\n private int age;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass PersonForm(\n @get:NotNull @get:Size(max=64)\n private val name: String,\n @get:Min(0)\n private val age: Int\n\t)\n----\n======\n\nA Bean Validation validator then validates instances of this class based on the declared\nconstraints. See {bean-validation-site}[Bean Validation] for general information about\nthe API. See the https://hibernate.org/validator/[Hibernate Validator] documentation for\nspecific constraints. To learn how to set up a bean validation provider as a Spring\nbean, keep reading.\n\n[[validation-beanvalidation-spring]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc", "title": "beanvalidation", "heading": "Overview of Bean Validation", "heading_level": 2, "file_order": 90, "section_index": 1, "content_hash": "5c3185fe71e080e398611f2da132292b4961457cdc574094ae64100557c75e9a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc"}}
{"id": "sha256:19f46b14759bd0c0863ab670da3b6a13a526c4d14105a365ecf8c19726aecfaf", "content": "Spring provides full support for the Bean Validation API including the bootstrapping of a\nBean Validation provider as a Spring bean. This lets you inject a\n`jakarta.validation.ValidatorFactory` or `jakarta.validation.Validator` wherever validation\nis needed in your application.\n\nYou can use the `LocalValidatorFactoryBean` to configure a default Validator as a Spring\nbean, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;\n\n\t@Configuration\n\tpublic class AppConfig {\n\n @Bean\n public LocalValidatorFactoryBean validator() {\n return new LocalValidatorFactoryBean();\n }\n\t}\n----\n\nXML::\n+\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"validator\"\n class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"/>\n----\n======\n\nThe basic configuration in the preceding example triggers bean validation to initialize by\nusing its default bootstrap mechanism. A Bean Validation provider, such as the Hibernate\nValidator, is expected to be present in the classpath and is automatically detected.\n\n[[validation-beanvalidation-spring-inject]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc", "title": "beanvalidation", "heading": "Configuring a Bean Validation Provider", "heading_level": 2, "file_order": 90, "section_index": 2, "content_hash": "19f46b14759bd0c0863ab670da3b6a13a526c4d14105a365ecf8c19726aecfaf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc"}}
{"id": "sha256:366a21c6ba2d572c93f0d4ea04dad03a1ab1126e5d3ce8f99c9d3caca35365d8", "content": "`LocalValidatorFactoryBean` implements both `jakarta.validation.ValidatorFactory` and\n`jakarta.validation.Validator`, so you can inject a reference to the latter to\napply validation logic if you prefer to work with the Bean Validation API directly,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport jakarta.validation.Validator;\n\n\t@Service\n\tpublic class MyService {\n\n @Autowired\n private Validator validator;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport jakarta.validation.Validator;\n\n\t@Service\n\tclass MyService(@Autowired private val validator: Validator)\n----\n======\n\n[[validation-beanvalidation-spring-inject-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc", "title": "beanvalidation", "heading": "Inject Jakarta Validator", "heading_level": 3, "file_order": 90, "section_index": 3, "content_hash": "366a21c6ba2d572c93f0d4ea04dad03a1ab1126e5d3ce8f99c9d3caca35365d8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc"}}
{"id": "sha256:e6e0f6606d936f4efb2aa71eda3fa418f559093a9b31b19dc88edba885ef5de8", "content": "In addition to implementing `jakarta.validation.Validator`, `LocalValidatorFactoryBean`\nalso adapts to `org.springframework.validation.Validator`, so you can inject a reference\nto the latter if your bean requires the Spring Validation API.\n\nFor example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.validation.Validator;\n\n\t@Service\n\tpublic class MyService {\n\n @Autowired\n private Validator validator;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.validation.Validator\n\n\t@Service\n\tclass MyService(@Autowired private val validator: Validator)\n----\n======\n\nWhen used as `org.springframework.validation.Validator`, `LocalValidatorFactoryBean`\ninvokes the underlying `jakarta.validation.Validator`, and then adapts\n``ConstraintViolation``s to ``FieldError``s, and registers them with the `Errors` object\npassed into the `validate` method.\n\n[[validation-beanvalidation-spring-constraints]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc", "title": "beanvalidation", "heading": "Inject Spring Validator", "heading_level": 3, "file_order": 90, "section_index": 4, "content_hash": "e6e0f6606d936f4efb2aa71eda3fa418f559093a9b31b19dc88edba885ef5de8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc"}}
{"id": "sha256:8da168c84a184b09285f688cc78683aefb78a6926de92d8911b882bffcfe8e93", "content": "Each bean validation constraint consists of two parts:\n\n* A `@Constraint` annotation that declares the constraint and its configurable properties.\n* An implementation of the `jakarta.validation.ConstraintValidator` interface that implements\nthe constraint's behavior.\n\nTo associate a declaration with an implementation, each `@Constraint` annotation\nreferences a corresponding `ConstraintValidator` implementation class. At runtime, a\n`ConstraintValidatorFactory` instantiates the referenced implementation when the\nconstraint annotation is encountered in your domain model.\n\nBy default, the `LocalValidatorFactoryBean` configures a `SpringConstraintValidatorFactory`\nthat uses Spring to create `ConstraintValidator` instances. This lets your custom\n`ConstraintValidators` benefit from dependency injection like any other Spring bean.\n\nThe following example shows a custom `@Constraint` declaration followed by an associated\n`ConstraintValidator` implementation that uses Spring for dependency injection:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target({ElementType.METHOD, ElementType.FIELD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Constraint(validatedBy=MyConstraintValidator.class)\n\tpublic @interface MyConstraint {\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@Constraint(validatedBy = MyConstraintValidator::class)\n\tannotation class MyConstraint\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport jakarta.validation.ConstraintValidator;\n\n\tpublic class MyConstraintValidator implements ConstraintValidator {\n\n @Autowired;\n private Foo aDependency;\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport jakarta.validation.ConstraintValidator\n\n\tclass MyConstraintValidator(private val aDependency: Foo) : ConstraintValidator {\n\n // ...\n\t}\n----\n======\n\nAs the preceding example shows, a `ConstraintValidator` implementation can have its dependencies\n`@Autowired` as any other Spring bean.\n\n[[validation-beanvalidation-spring-method]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc", "title": "beanvalidation", "heading": "Configure Custom Constraints", "heading_level": 3, "file_order": 90, "section_index": 5, "content_hash": "8da168c84a184b09285f688cc78683aefb78a6926de92d8911b882bffcfe8e93", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc"}}
{"id": "sha256:ecdbdba6eae2e37a6b6213796240deebf2c1fad788a17f6d8c29d04c0bac7d49", "content": "You can integrate the method validation feature of Bean Validation into a\nSpring context through a `MethodValidationPostProcessor` bean definition:\n\ninclude-code::./ApplicationConfiguration[tag=snippet,indent=0]\n\nTo be eligible for Spring-driven method validation, target classes need to be annotated\nwith Spring's `@Validated` annotation, which can optionally also declare the validation\ngroups to use. See\n{spring-framework-api}/validation/beanvalidation/MethodValidationPostProcessor.html[`MethodValidationPostProcessor`]\nfor setup details with the Hibernate Validator and Bean Validation providers.\n\n[TIP]\n====\nMethod validation relies on xref:core/aop/introduction-proxies.adoc[AOP Proxies] around the\ntarget classes, either JDK dynamic proxies for methods on interfaces or CGLIB proxies.\nThere are certain limitations with the use of proxies, some of which are described in\nxref:core/aop/proxying.adoc#aop-understanding-aop-proxies[Understanding AOP Proxies]. In addition remember\nto always use methods and accessors on proxied classes; direct field access will not work.\n====\n\nSpring MVC and WebFlux have built-in support for the same underlying method validation but without\nthe need for AOP. Therefore, do check the rest of this section, and also see the Spring MVC\nxref:web/webmvc/mvc-controller/ann-validation.adoc[Validation] and\nxref:web/webmvc/mvc-ann-rest-exceptions.adoc[Error Responses] sections, and the WebFlux\nxref:web/webflux/controller/ann-validation.adoc[Validation] and\nxref:web/webflux/ann-rest-exceptions.adoc[Error Responses] sections.\n\n[[validation-beanvalidation-spring-method-exceptions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc", "title": "beanvalidation", "heading": "Spring-driven Method Validation", "heading_level": 2, "file_order": 90, "section_index": 6, "content_hash": "ecdbdba6eae2e37a6b6213796240deebf2c1fad788a17f6d8c29d04c0bac7d49", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc"}}
{"id": "sha256:30fe5115cfe00681f44539a539c4cd2dc0d73048922bbd374f5c6c9bdb925537", "content": "By default, `jakarta.validation.ConstraintViolationException` is raised with the set of\n``ConstraintViolation``s returned by `jakarta.validation.Validator`. As an alternative,\nyou can have `MethodValidationException` raised instead with ``ConstraintViolation``s\nadapted to `MessageSourceResolvable` errors. To enable set the following flag:\n\ninclude-code::./ApplicationConfiguration[tag=snippet,indent=0]\n\n`MethodValidationException` contains a list of ``ParameterValidationResult``s which\ngroup errors by method parameter, and each exposes a `MethodParameter`, the argument\nvalue, and a list of `MessageSourceResolvable` errors adapted from\n``ConstraintViolation``s. For `@Valid` method parameters with cascaded violations on\nfields and properties, the `ParameterValidationResult` is `ParameterErrors` which\nimplements `org.springframework.validation.Errors` and exposes validation errors as\n``FieldError``s.\n\n[[validation-beanvalidation-spring-method-i18n]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc", "title": "beanvalidation", "heading": "Method Validation Exceptions", "heading_level": 3, "file_order": 90, "section_index": 7, "content_hash": "30fe5115cfe00681f44539a539c4cd2dc0d73048922bbd374f5c6c9bdb925537", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc"}}
{"id": "sha256:2ce286627f66bf2376bbf77a04a89f3be7f01fdbffcfaed56005a89da0d68532", "content": "The adapted `MessageSourceResolvable` errors can be turned into error messages to\ndisplay to users through the configured `MessageSource` with locale and language specific\nresource bundles. This section provides an example for illustration.\n\nGiven the following class declarations:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\trecord Person(@Size(min = 1, max = 10) String name) {\n\t}\n\n\t@Validated\n\tpublic class MyService {\n\n void addStudent(@Valid Person person, @Max(2) int degrees) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@JvmRecord\n\tinternal data class Person(@Size(min = 1, max = 10) val name: String)\n\n\t@Validated\n\tclass MyService {\n\n fun addStudent(person: @Valid Person?, degrees: @Max(2) Int) {\n // ...\n }\n\t}\n----\n======\n\nA `ConstraintViolation` on `Person.name()` is adapted to a `FieldError` with the following:\n\n- Error codes `\"Size.person.name\"`, `\"Size.name\"`, `\"Size.java.lang.String\"`, and `\"Size\"`\n- Message arguments `\"name\"`, `10`, and `1` (the field name and the constraint attributes)\n- Default message \"size must be between 1 and 10\"\n\nTo customize the default message, you can add properties to\nxref:core/beans/context-introduction.adoc#context-functionality-messagesource[MessageSource]\nresource bundles using any of the above errors codes and message arguments. Note also that the\nmessage argument `\"name\"` is itself a `MessageSourceResolvable` with error codes\n`\"person.name\"` and `\"name\"` and can be customized too. For example:\n\nProperties::\n+\n[source,properties,indent=0,subs=\"verbatim,quotes\"]\n----\nSize.person.name=Please, provide a {0} that is between {2} and {1} characters long\nperson.name=username\n----\n\nA `ConstraintViolation` on the `degrees` method parameter is adapted to a\n`MessageSourceResolvable` with the following:\n\n- Error codes `\"Max.myService#addStudent.degrees\"`, `\"Max.degrees\"`, `\"Max.int\"`, `\"Max\"`\n- Message arguments \"degrees\" and 2 (the field name and the constraint attribute)\n- Default message \"must be less than or equal to 2\"\n\nTo customize the above default message, you can add a property such as:\n\nProperties::\n+\n[source,properties,indent=0,subs=\"verbatim,quotes\"]\n----\nMax.degrees=You cannot provide more than {1} {0}\n----\n\n[[validation-beanvalidation-spring-other]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc", "title": "beanvalidation", "heading": "Customizing Validation Errors", "heading_level": 3, "file_order": 90, "section_index": 8, "content_hash": "2ce286627f66bf2376bbf77a04a89f3be7f01fdbffcfaed56005a89da0d68532", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc"}}
{"id": "sha256:9a2feeaa71922f72fc866c14ff4fbd8aee2615943f64b879b7f5d57345d59ac0", "content": "The default `LocalValidatorFactoryBean` configuration suffices for most\ncases. There are a number of configuration options for various Bean Validation\nconstructs, from message interpolation to traversal resolution. See the\n{spring-framework-api}/validation/beanvalidation/LocalValidatorFactoryBean.html[`LocalValidatorFactoryBean`]\njavadoc for more information on these options.\n\n[[validation-binder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc", "title": "beanvalidation", "heading": "Additional Configuration Options", "heading_level": 3, "file_order": 90, "section_index": 9, "content_hash": "9a2feeaa71922f72fc866c14ff4fbd8aee2615943f64b879b7f5d57345d59ac0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc"}}
{"id": "sha256:a8216cd69edb1a339d0d885a4f0dff9308cf644972a555b42a5f1ebd4308937c", "content": "You can configure a `DataBinder` instance with a `Validator`. Once configured, you can\ninvoke the `Validator` by calling `binder.validate()`. Any validation `Errors` are\nautomatically added to the binder's `BindingResult`.\n\nThe following example shows how to use a `DataBinder` programmatically to invoke validation\nlogic after binding to a target object:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tFoo target = new Foo();\n\tDataBinder binder = new DataBinder(target);\n\tbinder.setValidator(new FooValidator());\n\n\t// bind to the target object\n\tbinder.bind(propertyValues);\n\n\t// validate the target object\n\tbinder.validate();\n\n\t// get BindingResult that includes any validation errors\n\tBindingResult results = binder.getBindingResult();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval target = Foo()\n\tval binder = DataBinder(target)\n\tbinder.validator = FooValidator()\n\n\t// bind to the target object\n\tbinder.bind(propertyValues)\n\n\t// validate the target object\n\tbinder.validate()\n\n\t// get BindingResult that includes any validation errors\n\tval results = binder.bindingResult\n----\n======\n\nYou can also configure a `DataBinder` with multiple `Validator` instances through\n`dataBinder.addValidators` and `dataBinder.replaceValidators`. This is useful when\ncombining globally configured bean validation with a Spring `Validator` configured\nlocally on a DataBinder instance. See\nxref:web/webmvc/mvc-config/validation.adoc[Spring MVC Validation Configuration].\n\n[[validation-mvc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc", "title": "beanvalidation", "heading": "Configuring a `DataBinder`", "heading_level": 2, "file_order": 90, "section_index": 10, "content_hash": "a8216cd69edb1a339d0d885a4f0dff9308cf644972a555b42a5f1ebd4308937c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc"}}
{"id": "sha256:181151bc8d56e8b79a6205922b7cf4d11901ad64276e97a066b22f1666ac8677", "content": "See xref:web/webmvc/mvc-config/validation.adoc[Validation] in the Spring MVC chapter.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc", "title": "beanvalidation", "heading": "Spring MVC Validation", "heading_level": 2, "file_order": 90, "section_index": 11, "content_hash": "181151bc8d56e8b79a6205922b7cf4d11901ad64276e97a066b22f1666ac8677", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/beanvalidation.adoc"}}
{"id": "sha256:09662669f9d62c3e22e8db378dd7a8d087bb5f3afd159d1add72c3cd2ed9bce9", "content": "[[core-convert]]\n\nThe `core.convert` package provides a general type conversion system. The system defines\nan SPI to implement type conversion logic and an API to perform type conversions at\nruntime. Within a Spring container, you can use this system as an alternative to\n`PropertyEditor` implementations to convert externalized bean property value strings to\nthe required property types. You can also use the public API anywhere in your application\nwhere type conversion is needed.\n\n[[core-convert-Converter-API]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/convert.adoc", "title": "convert", "heading": "convert", "heading_level": 1, "file_order": 91, "section_index": 0, "content_hash": "09662669f9d62c3e22e8db378dd7a8d087bb5f3afd159d1add72c3cd2ed9bce9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/convert.adoc"}}
{"id": "sha256:372b7c8a0ea02f5b853f66f0c806f475011e3b56698d2033919614b6e4719b25", "content": "The SPI to implement type conversion logic is simple and strongly typed, as the following\ninterface definition shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.core.convert.converter;\n\n\tpublic interface Converter<S, T> {\n\n T convert(S source);\n\t}\n----\n\nTo create your own converter, implement the `Converter` interface and parameterize `S`\nas the type you are converting from and `T` as the type you are converting to. You can also transparently apply such a\nconverter if a collection or array of `S` needs to be\nconverted to an array or collection of `T`, provided that a delegating array or collection\nconverter has been registered as well (which `DefaultConversionService` does by default).\n\nFor each call to `convert(S)`, the source argument is guaranteed to not be null. Your\n`Converter` may throw any unchecked exception if conversion fails. Specifically, it should throw an\n`IllegalArgumentException` to report an invalid source value.\nTake care to ensure that your `Converter` implementation is thread-safe.\n\nSeveral converter implementations are provided in the `core.convert.support` package as\na convenience. These include converters from strings to numbers and other common types.\nThe following listing shows the `StringToInteger` class, which is a typical `Converter` implementation:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.core.convert.support;\n\n\tfinal class StringToInteger implements Converter<String, Integer> {\n\n public Integer convert(String source) {\n return Integer.valueOf(source);\n }\n\t}\n----\n\n[[core-convert-ConverterFactory-SPI]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/convert.adoc", "title": "convert", "heading": "Converter SPI", "heading_level": 2, "file_order": 91, "section_index": 1, "content_hash": "372b7c8a0ea02f5b853f66f0c806f475011e3b56698d2033919614b6e4719b25", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/convert.adoc"}}
{"id": "sha256:76f36e45e70156a68c17e348b3e75b5a76a88517818cd2632b364f95b1a83935", "content": "When you need to centralize the conversion logic for an entire class hierarchy\n(for example, when converting from `String` to `Enum` objects), you can implement\n`ConverterFactory`, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.core.convert.converter;\n\n\tpublic interface ConverterFactory<S, R> {\n\n <T extends R> Converter<S, T> getConverter(Class<T> targetType);\n\t}\n----\n\nParameterize `S` to be the type you are converting from and `R` to be the base type defining\nthe __range__ of classes you can convert to. Then implement `getConverter(Class<T>)`,\nwhere `T` is a subclass of `R`.\n\nConsider the `StringToEnumConverterFactory` as an example:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.core.convert.support;\n\n\tfinal class StringToEnumConverterFactory implements ConverterFactory<String, Enum> {\n\n public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {\n return new StringToEnumConverter(targetType);\n }\n\n private final class StringToEnumConverter<T extends Enum> implements Converter<String, T> {\n\n private Class<T> enumType;\n\n public StringToEnumConverter(Class<T> enumType) {\n this.enumType = enumType;\n }\n\n public T convert(String source) {\n return (T) Enum.valueOf(this.enumType, source.trim());\n }\n }\n\t}\n----\n\n[[core-convert-GenericConverter-SPI]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/convert.adoc", "title": "convert", "heading": "Using `ConverterFactory`", "heading_level": 2, "file_order": 91, "section_index": 2, "content_hash": "76f36e45e70156a68c17e348b3e75b5a76a88517818cd2632b364f95b1a83935", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/convert.adoc"}}
{"id": "sha256:66a06478738ea8d645119b0c71e76d65ce0162e92a8c4d9d079a0003dc0e2ef6", "content": "When you require a more sophisticated `Converter` implementation, consider using the\n`GenericConverter` interface. With a more flexible but less strongly typed signature than\n`Converter`, a `GenericConverter` supports converting between multiple source and target\ntypes. In addition, a `GenericConverter` is provided source and target type descriptors\nthat you can use when you implement your conversion logic. Such type descriptors enable\ntype conversion to be driven by an annotation on the source of the descriptor (such as a\nfield or method) or by generic information declared in a field signature, method\nsignature, etc. The following listing shows the definition of the `GenericConverter`\ninterface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.core.convert.converter;\n\n\tpublic interface GenericConverter {\n\n public Set<ConvertiblePair> getConvertibleTypes();\n\n Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);\n\t}\n----\n\nTo implement a `GenericConverter`, have `getConvertibleTypes()` return the supported\nsource &#8594; target type pairs. Then implement `convert(Object, TypeDescriptor,\nTypeDescriptor)` to contain your conversion logic. The source `TypeDescriptor` provides\naccess to the source field or method that holds the value being converted. The target\n`TypeDescriptor` provides access to the target field or method where the converted value\nis to be set.\n\nA good example of a `GenericConverter` is a converter that converts between a Java array\nand a collection. Such an `ArrayToCollectionConverter` introspects the field or method\nthat declares the target collection type to resolve the collection's element type. This\nlets each element in the source array be converted to the collection element type before\nthe collection is set on the target field or supplied to the target method or constructor.\n\nNOTE: Because `GenericConverter` is a more complex SPI interface, you should use\nit only when you need it. Favor `Converter` or `ConverterFactory` for basic type\nconversion needs.\n\n[[core-convert-ConditionalGenericConverter-SPI]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/convert.adoc", "title": "convert", "heading": "Using `GenericConverter`", "heading_level": 2, "file_order": 91, "section_index": 3, "content_hash": "66a06478738ea8d645119b0c71e76d65ce0162e92a8c4d9d079a0003dc0e2ef6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/convert.adoc"}}
{"id": "sha256:7afb4de48f9d89ed602d7dffda8467f5ba6bf891bde8cf497a1ec1c166b19c0f", "content": "Sometimes, you want a `Converter` to run only if a specific condition holds true. For\nexample, you might want to run a `Converter` only if a specific annotation is present on\nthe target field or method, or you might want to run a `Converter` only if a specific\nmethod (such as a `static valueOf` method) is defined on the target type.\n`ConditionalGenericConverter` is the union of the `GenericConverter` and\n`ConditionalConverter` interfaces that lets you define such custom matching criteria:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface ConditionalConverter {\n\n boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);\n\t}\n\n\tpublic interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {\n\t}\n----\n\nA good example of a `ConditionalGenericConverter` is an `IdToEntityConverter` that converts\nbetween a persistent entity identifier and an entity reference. Such an `IdToEntityConverter`\nmight match only if the target entity type declares a static finder method (for example,\n`findAccount(Long)`). You might perform such a finder method check in the implementation of\n`matches(TypeDescriptor, TypeDescriptor)`.\n\n[[core-convert-ConversionService-API]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/convert.adoc", "title": "convert", "heading": "Using `ConditionalGenericConverter`", "heading_level": 3, "file_order": 91, "section_index": 4, "content_hash": "7afb4de48f9d89ed602d7dffda8467f5ba6bf891bde8cf497a1ec1c166b19c0f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/convert.adoc"}}
{"id": "sha256:1e9d815dfc1dd3ba83e5735cb997437ca993d1318f47502217771674d525e183", "content": "`ConversionService` defines a unified API for executing type conversion logic at\nruntime. Converters are often run behind the following facade interface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.core.convert;\n\n\tpublic interface ConversionService {\n\n boolean canConvert(Class<?> sourceType, Class<?> targetType);\n\n <T> T convert(Object source, Class<T> targetType);\n\n boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);\n\n Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);\n\t}\n----\n\nMost `ConversionService` implementations also implement `ConverterRegistry`, which\nprovides an SPI for registering converters. Internally, a `ConversionService`\nimplementation delegates to its registered converters to carry out type conversion logic.\n\nA robust `ConversionService` implementation is provided in the `core.convert.support`\npackage. `GenericConversionService` is the general-purpose implementation suitable for\nuse in most environments. `ConversionServiceFactory` provides a convenient factory for\ncreating common `ConversionService` configurations.\n\n[[core-convert-Spring-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/convert.adoc", "title": "convert", "heading": "The `ConversionService` API", "heading_level": 2, "file_order": 91, "section_index": 5, "content_hash": "1e9d815dfc1dd3ba83e5735cb997437ca993d1318f47502217771674d525e183", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/convert.adoc"}}
{"id": "sha256:38db3a539c1ebda7ddda34c1232a2b2067b961cc486b4052081f74a913eb32db", "content": "A `ConversionService` is a stateless object designed to be instantiated at application\nstartup and then shared between multiple threads. In a Spring application, you typically\nconfigure a `ConversionService` instance for each Spring container (or `ApplicationContext`).\nSpring picks up that `ConversionService` and uses it whenever type\nconversion needs to be performed by the framework. You can also inject this\n`ConversionService` into any of your beans and invoke it directly.\n\nNOTE: If no `ConversionService` is registered with Spring, the original `PropertyEditor`-based\nsystem is used.\n\nTo register a default `ConversionService` with Spring, add the following bean definition\nwith an `id` of `conversionService`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"conversionService\"\n class=\"org.springframework.context.support.ConversionServiceFactoryBean\"/>\n----\n\nA default `ConversionService` can convert between strings, numbers, enums, collections,\nmaps, and other common types. To supplement or override the default converters with your\nown custom converters, set the `converters` property. Property values can implement\nany of the `Converter`, `ConverterFactory`, or `GenericConverter` interfaces.\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"conversionService\"\n class=\"org.springframework.context.support.ConversionServiceFactoryBean\">\n <property name=\"converters\">\n <set>\n <bean class=\"example.MyCustomConverter\"/>\n </set>\n </property>\n\t</bean>\n----\n\nIt is also common to use a `ConversionService` within a Spring MVC application. See\nxref:web/webmvc/mvc-config/conversion.adoc[Conversion and Formatting] in the Spring MVC chapter.\n\nIn certain situations, you may wish to apply formatting during conversion. See\nxref:core/validation/format.adoc#format-FormatterRegistry-SPI[The `FormatterRegistry` SPI]\nfor details on using `FormattingConversionServiceFactoryBean`.\n\n[[core-convert-programmatic-usage]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/convert.adoc", "title": "convert", "heading": "Configuring a `ConversionService`", "heading_level": 2, "file_order": 91, "section_index": 6, "content_hash": "38db3a539c1ebda7ddda34c1232a2b2067b961cc486b4052081f74a913eb32db", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/convert.adoc"}}
{"id": "sha256:8b4d082a6a97092ff2c4e6e5eec358db3045d4ea68ea4b602dff2fb17ad8df23", "content": "To work with a `ConversionService` instance programmatically, you can inject a reference to\nit like you would for any other bean. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Service\n\tpublic class MyService {\n\n private final ConversionService conversionService;\n\n public MyService(ConversionService conversionService) {\n this.conversionService = conversionService;\n }\n\n public void doIt() {\n this.conversionService.convert(...)\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Service\n\tclass MyService(private val conversionService: ConversionService) {\n\n fun doIt() {\n conversionService.convert(...)\n }\n\t}\n----\n======\n\nFor most use cases, you can use the `convert` method that specifies the `targetType`, but it\ndoes not work with more complex types, such as a collection of a parameterized element.\nFor example, if you want to convert a `List` of `Integer` to a `List` of `String` programmatically,\nyou need to provide a formal definition of the source and target types.\n\nFortunately, `TypeDescriptor` provides various options to make doing so straightforward,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tDefaultConversionService cs = new DefaultConversionService();\n\n\tList<Integer> input = ...\n\tcs.convert(input,\n TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(Integer.class)), // <1>\n TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class))); // <2>\n----\n<1> `List<Integer>` type descriptor\n<2> `List<String>` type descriptor\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval cs = DefaultConversionService()\n\n\tval input: List<Integer> = ...\n\tcs.convert(input,\n TypeDescriptor.collection(List::class.java, TypeDescriptor.valueOf(Integer::class.java)), // <1>\n TypeDescriptor.collection(List::class.java, TypeDescriptor.valueOf(String::class.java))) // <2>\n----\n<1> `List<Integer>` type descriptor\n<2> `List<String>` type descriptor\n======\n\nNote that `DefaultConversionService` automatically registers converters that are\nappropriate for most environments. This includes collection converters, scalar\nconverters, and basic `Object`-to-`String` converters. You can register the same converters\nwith any `ConverterRegistry` by using the static `addDefaultConverters`\nmethod on the `DefaultConversionService` class.\n\nConverters for value types are reused for arrays and collections, so there is\nno need to create a specific converter to convert from a `Collection` of `S` to a\n`Collection` of `T`, assuming that standard collection handling is appropriate.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/convert.adoc", "title": "convert", "heading": "Using a `ConversionService` Programmatically", "heading_level": 2, "file_order": 91, "section_index": 7, "content_hash": "8b4d082a6a97092ff2c4e6e5eec358db3045d4ea68ea4b602dff2fb17ad8df23", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/convert.adoc"}}
{"id": "sha256:621a5844aadeef52c03959fcd6d5b94fcafbdd2ea74542c31ba261576cb3648a", "content": "[[data-binding]]\n\nData binding is useful for binding user input to a target object where user input is a map\nwith property paths as keys, following xref:data-binding-conventions[JavaBeans conventions].\n`DataBinder` is the main class that supports this, and it provides two ways to bind user\ninput:\n\n- xref:data-binding-constructor-binding[Constructor binding] - bind user input to a\n public data constructor, looking up constructor argument values in the user input.\n- xref:data-binding-property-binding[Property binding] - bind user input to setters,\n matching keys from the user input to properties of the target object structure.\n\nYou can apply both constructor and property binding or only one.\n\n[[data-binding-constructor-binding]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc", "title": "data-binding", "heading": "data-binding", "heading_level": 1, "file_order": 92, "section_index": 0, "content_hash": "621a5844aadeef52c03959fcd6d5b94fcafbdd2ea74542c31ba261576cb3648a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc"}}
{"id": "sha256:2a2f96e7aa42639a250f37c5e9a53a215732a52b84fc7466caa347ce1478db43", "content": "To use constructor binding:\n\n1. Create a `DataBinder` with `null` as the target object.\n2. Set `targetType` to the target class.\n3. Call `construct`.\n\nThe target class should have a single public constructor or a single non-public constructor\nwith arguments. If there are multiple constructors, then a default constructor if present\nis used.\n\nBy default, argument values are looked up via constructor parameter names. Spring MVC and\nWebFlux support a custom name mapping through the `@BindParam` annotation on constructor\nparameters or fields if present. If necessary, you can also configure a `NameResolver` on\n`DataBinder` to customize the argument name to use.\n\nxref:data-binding-conventions[Type conversion] is applied as needed to convert user input.\nIf the constructor parameter is an object, it is constructed recursively in the same\nmanner, but through a nested property path. That means constructor binding creates both\nthe target object and any objects it contains.\n\nConstructor binding supports `List`, `Map`, and array arguments either converted from\na single string, for example, comma-separated list, or based on indexed keys such as\n`accounts[2].name` or `account[KEY].name`.\n\nBinding and conversion errors are reflected in the `BindingResult` of the `DataBinder`.\nIf the target is created successfully, then `target` is set to the created instance\nafter the call to `construct`.\n\n[[data-binding-property-binding]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc", "title": "data-binding", "heading": "Constructor Binding", "heading_level": 2, "file_order": 92, "section_index": 1, "content_hash": "2a2f96e7aa42639a250f37c5e9a53a215732a52b84fc7466caa347ce1478db43", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc"}}
{"id": "sha256:a4c125844c4abf1c06b4c6d969a6527ed8dcff0c2ba6909353710ea363733196", "content": "The `org.springframework.beans` package adheres to the JavaBeans standard.\nA JavaBean is a class with a default no-argument constructor and that follows\na naming convention where (for example) a property named `bingoMadness` would\nhave a setter method `setBingoMadness(..)` and a getter method `getBingoMadness()`. For\nmore information about JavaBeans and the specification, see\n{java-api}/java.desktop/java/beans/package-summary.html[javabeans].\n\nOne quite important class in the beans package is the `BeanWrapper` interface and its\ncorresponding implementation (`BeanWrapperImpl`). As quoted from the javadoc, the\n`BeanWrapper` offers functionality to set and get property values (individually or in\nbulk), get property descriptors, and query properties to determine if they are\nreadable or writable. Also, the `BeanWrapper` offers support for nested properties,\nenabling the setting of properties on sub-properties to an unlimited depth. The\n`BeanWrapper` also supports the ability to add standard JavaBeans `PropertyChangeListeners`\nand `VetoableChangeListeners`, without the need for supporting code in the target class.\nLast but not least, the `BeanWrapper` provides support for setting indexed properties.\nThe `BeanWrapper` usually is not used by application code directly but is used by the\n`DataBinder` and the `BeanFactory`.\n\nThe way the `BeanWrapper` works is partly indicated by its name: it wraps a bean to\nperform actions on that bean, such as setting and retrieving properties.\n\n[[data-binding-conventions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc", "title": "data-binding", "heading": "Property Binding with `BeanWrapper`", "heading_level": 2, "file_order": 92, "section_index": 2, "content_hash": "a4c125844c4abf1c06b4c6d969a6527ed8dcff0c2ba6909353710ea363733196", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc"}}
{"id": "sha256:c49a4f6ca734d87fbddd9ff60c03e7a42696a3a31a0eebdd961e36af002c3f93", "content": "Setting and getting properties is done through the `setPropertyValue` and\n`getPropertyValue` overloaded method variants of `BeanWrapper`. See their Javadoc for\ndetails. The below table shows some examples of these conventions:\n\n[[data-binding-conventions-properties-tbl]]\n.Examples of properties\n|===\n| Expression| Explanation\n\n| `name`\n| Indicates the property `name` that corresponds to the `getName()` or `isName()`\n and `setName(..)` methods.\n\n| `account.name`\n| Indicates the nested property `name` of the property `account` that corresponds to\n (for example) the `getAccount().setName()` or `getAccount().getName()` methods.\n\n| `accounts[2]`\n| Indicates the _third_ element of the indexed property `account`. Indexed properties\n can be of type `array`, `list`, or other naturally ordered collection.\n\n| `accounts[KEY]`\n| Indicates the value of the map entry indexed by the `KEY` value.\n|===\n\n(This next section is not vitally important to you if you do not plan to work with\nthe `BeanWrapper` directly. If you use only the `DataBinder` and the `BeanFactory`\nand their default implementations, you should skip ahead to the\nxref:core/validation/data-binding.adoc#data-binding-conversion[section on `PropertyEditors`].)\n\nThe following two example classes use the `BeanWrapper` to get and set\nproperties:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class Company {\n\n private String name;\n private Employee managingDirector;\n\n public String getName() {\n return this.name;\n }\n\n public void setName(String name) {\n this.name = name;\n }\n\n public Employee getManagingDirector() {\n return this.managingDirector;\n }\n\n public void setManagingDirector(Employee managingDirector) {\n this.managingDirector = managingDirector;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Company {\n var name: String? = null\n var managingDirector: Employee? = null\n\t}\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class Employee {\n\n private String name;\n\n private float salary;\n\n public String getName() {\n return this.name;\n }\n\n public void setName(String name) {\n this.name = name;\n }\n\n public float getSalary() {\n return salary;\n }\n\n public void setSalary(float salary) {\n this.salary = salary;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Employee {\n var name: String? = null\n var salary: Float? = null\n\t}\n----\n======\n\nThe following code snippets show some examples of how to retrieve and manipulate some of\nthe properties of instantiated ``Company``s and ``Employee``s:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tBeanWrapper company = new BeanWrapperImpl(new Company());\n\t// setting the company name..\n\tcompany.setPropertyValue(\"name\", \"Some Company Inc.\");\n\t// ... can also be done like this:\n\tPropertyValue value = new PropertyValue(\"name\", \"Some Company Inc.\");\n\tcompany.setPropertyValue(value);\n\n\t// ok, let's create the director and tie it to the company:\n\tBeanWrapper jim = new BeanWrapperImpl(new Employee());\n\tjim.setPropertyValue(\"name\", \"Jim Stravinsky\");\n\tcompany.setPropertyValue(\"managingDirector\", jim.getWrappedInstance());\n\n\t// retrieving the salary of the managingDirector through the company\n\tFloat salary = (Float) company.getPropertyValue(\"managingDirector.salary\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval company = BeanWrapperImpl(Company())\n\t// setting the company name..\n\tcompany.setPropertyValue(\"name\", \"Some Company Inc.\")\n\t// ... can also be done like this:\n\tval value = PropertyValue(\"name\", \"Some Company Inc.\")\n\tcompany.setPropertyValue(value)\n\n\t// ok, let's create the director and tie it to the company:\n\tval jim = BeanWrapperImpl(Employee())\n\tjim.setPropertyValue(\"name\", \"Jim Stravinsky\")\n\tcompany.setPropertyValue(\"managingDirector\", jim.wrappedInstance)\n\n\t// retrieving the salary of the managingDirector through the company\n\tval salary = company.getPropertyValue(\"managingDirector.salary\") as Float?\n----\n======\n\n[[data-binding-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc", "title": "data-binding", "heading": "Setting and Getting Basic and Nested Properties", "heading_level": 3, "file_order": 92, "section_index": 3, "content_hash": "c49a4f6ca734d87fbddd9ff60c03e7a42696a3a31a0eebdd961e36af002c3f93", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc"}}
{"id": "sha256:1fe448e4c27b7f32b500f5494b163db4f2b7de671cb7bedb3602ff80651c2da4", "content": "Spring uses the concept of a `PropertyEditor` to effect the conversion between an\n`Object` and a `String`. It can be handy\nto represent properties in a different way than the object itself. For example, a `Date`\ncan be represented in a human readable way (as the `String`: `'2007-14-09'`), while\nwe can still convert the human readable form back to the original date (or, even\nbetter, convert any date entered in a human readable form back to `Date` objects). This\nbehavior can be achieved by registering custom editors of type\n`java.beans.PropertyEditor`. Registering custom editors on a `BeanWrapper` or,\nalternatively, in a specific IoC container (as mentioned in the previous chapter), gives it\nthe knowledge of how to convert properties to the desired type. For more about\n`PropertyEditor`, see {java-api}/java.desktop/java/beans/package-summary.html[the javadoc of the `java.beans` package from Oracle].\n\nA couple of examples where property editing is used in Spring:\n\n* Setting properties on beans is done by using `PropertyEditor` implementations.\n When you use `String` as the value of a property of some bean that you declare\n in an XML file, Spring (if the setter of the corresponding property has a `Class`\n parameter) uses `ClassEditor` to try to resolve the parameter to a `Class` object.\n* Parsing HTTP request parameters in Spring's MVC framework is done by using all kinds\n of `PropertyEditor` implementations that you can manually bind in all subclasses of the\n `CommandController`.\n\nSpring has a number of built-in `PropertyEditor` implementations to make life easy.\nThey are all located in the `org.springframework.beans.propertyeditors`\npackage. Most, (but not all, as indicated in the following table) are, by default, registered by\n`BeanWrapperImpl`. Where the property editor is configurable in some fashion, you can\nstill register your own variant to override the default one. The following table describes\nthe various `PropertyEditor` implementations that Spring provides:\n\n[[data-binding-property-editors-tbl]]\n.Built-in `PropertyEditor` Implementations\n[cols=\"30%,70%\"]\n|===\n| Class| Explanation\n\n| `ByteArrayPropertyEditor`\n| Editor for byte arrays. Converts strings to their corresponding byte\n representations. Registered by default by `BeanWrapperImpl`.\n\n| `ClassEditor`\n| Parses Strings that represent classes to actual classes and vice-versa. When a\n class is not found, an `IllegalArgumentException` is thrown. By default, registered by\n `BeanWrapperImpl`.\n\n| `CustomBooleanEditor`\n| Customizable property editor for `Boolean` properties. By default, registered by\n `BeanWrapperImpl` but can be overridden by registering a custom instance of it as a\n custom editor.\n\n| `CustomCollectionEditor`\n| Property editor for collections, converting any source `Collection` to a given target\n `Collection` type.\n\n| `CustomDateEditor`\n| Customizable property editor for `java.util.Date`, supporting a custom `DateFormat`. NOT\n registered by default. Must be user-registered with the appropriate format as needed.\n\n| `CustomNumberEditor`\n| Customizable property editor for any `Number` subclass, such as `Integer`, `Long`, `Float`, or\n `Double`. By default, registered by `BeanWrapperImpl` but can be overridden by\n registering a custom instance of it as a custom editor.\n\n| `FileEditor`\n| Resolves strings to `java.io.File` objects. By default, registered by\n `BeanWrapperImpl`.\n\n| `InputStreamEditor`\n| One-way property editor that can take a string and produce (through an\n intermediate `ResourceEditor` and `Resource`) an `InputStream` so that `InputStream`\n properties may be directly set as strings. Note that the default usage does not close\n the `InputStream` for you. By default, registered by `BeanWrapperImpl`.\n\n| `LocaleEditor`\n| Can resolve strings to `Locale` objects and vice-versa (the string format is\n `[language]\\_[country]_[variant]`, same as the `toString()` method of\n `Locale`). Also accepts spaces as separators, as an alternative to underscores.\n By default, registered by `BeanWrapperImpl`.\n\n| `PatternEditor`\n| Can resolve strings to `java.util.regex.Pattern` objects and vice-versa.\n\n| `PropertiesEditor`\n| Can convert strings (formatted with the format defined in the javadoc of the\n `java.util.Properties` class) to `Properties` objects. By default, registered\n by `BeanWrapperImpl`.\n\n| `StringTrimmerEditor`\n| Property editor that trims strings. Optionally allows transforming an empty string\n into a `null` value. NOT registered by default -- must be user-registered.\n\n| `URLEditor`\n| Can resolve a string representation of a URL to an actual `URL` object.\n By default, registered by `BeanWrapperImpl`.\n|===\n\nSpring uses the `java.beans.PropertyEditorManager` to set the search path for property\neditors that might be needed. The search path also includes `sun.bean.editors`, which\nincludes `PropertyEditor` implementations for types such as `Font`, `Color`, and most of\nthe primitive types. Note also that the standard JavaBeans infrastructure\nautomatically discovers `PropertyEditor` classes (without you having to register them\nexplicitly) if they are in the same package as the class they handle and have the same\nname as that class, with `Editor` appended. For example, one could have the following\nclass and package structure, which would be sufficient for the `SomethingEditor` class to be\nrecognized and used as the `PropertyEditor` for `Something`-typed properties.\n\n[literal,subs=\"verbatim,quotes\"]\n----\ncom\n chank\n pop\n Something\n SomethingEditor // the PropertyEditor for the Something class\n----\n\nNote that you can also use the standard `BeanInfo` JavaBeans mechanism here as well\n(described to some extent\n{java-tutorial}/javabeans/advanced/customization.html[here]). The\nfollowing example uses the `BeanInfo` mechanism to explicitly register one or more\n`PropertyEditor` instances with the properties of an associated class:\n\n[literal,subs=\"verbatim,quotes\"]\n----\ncom\n chank\n pop\n Something\n SomethingBeanInfo // the BeanInfo for the Something class\n----\n\nThe following Java source code for the referenced `SomethingBeanInfo` class\nassociates a `CustomNumberEditor` with the `age` property of the `Something` class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SomethingBeanInfo extends SimpleBeanInfo {\n\n public PropertyDescriptor[] getPropertyDescriptors() {\n try {\n final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);\n PropertyDescriptor ageDescriptor = new PropertyDescriptor(\"age\", Something.class) {\n @Override\n public PropertyEditor createPropertyEditor(Object bean) {\n return numberPE;\n }\n };\n return new PropertyDescriptor[] { ageDescriptor };\n }\n catch (IntrospectionException ex) {\n throw new Error(ex.toString());\n }\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass SomethingBeanInfo : SimpleBeanInfo() {\n\n override fun getPropertyDescriptors(): Array<PropertyDescriptor> {\n try {\n val numberPE = CustomNumberEditor(Int::class.java, true)\n val ageDescriptor = object : PropertyDescriptor(\"age\", Something::class.java) {\n override fun createPropertyEditor(bean: Any): PropertyEditor {\n return numberPE\n }\n }\n return arrayOf(ageDescriptor)\n } catch (ex: IntrospectionException) {\n throw Error(ex.toString())\n }\n\n }\n\t}\n----\n======\n\n[[data-binding-conversion-customeditor-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc", "title": "data-binding", "heading": "``PropertyEditor``s", "heading_level": 2, "file_order": 92, "section_index": 4, "content_hash": "1fe448e4c27b7f32b500f5494b163db4f2b7de671cb7bedb3602ff80651c2da4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc"}}
{"id": "sha256:f9e12a53abe393481cdc1595514413d2dd795e3b21874344ba137df884c75b2b", "content": "When setting bean properties as string values, a Spring IoC container ultimately uses\nstandard JavaBeans `PropertyEditor` implementations to convert these strings to the complex type of the\nproperty. Spring pre-registers a number of custom `PropertyEditor` implementations (for example, to\nconvert a class name expressed as a string into a `Class` object). Additionally,\nJava's standard JavaBeans `PropertyEditor` lookup mechanism lets a `PropertyEditor`\nfor a class be named appropriately and placed in the same package as the class\nfor which it provides support, so that it can be found automatically.\n\nIf there is a need to register other custom `PropertyEditors`, several mechanisms are\navailable. The most manual approach, which is not normally convenient or\nrecommended, is to use the `registerCustomEditor()` method of the\n`ConfigurableBeanFactory` interface, assuming you have a `BeanFactory` reference.\nAnother (slightly more convenient) mechanism is to use a special bean factory\npost-processor called `CustomEditorConfigurer`. Although you can use bean factory post-processors\nwith `BeanFactory` implementations, the `CustomEditorConfigurer` has a\nnested property setup, so we strongly recommend that you use it with the\n`ApplicationContext`, where you can deploy it in similar fashion to any other bean and\nwhere it can be automatically detected and applied.\n\nNote that all bean factories and application contexts automatically use a number of\nbuilt-in property editors, through their use of a `BeanWrapper` to\nhandle property conversions. The standard property editors that the `BeanWrapper`\nregisters are listed in the xref:core/validation/data-binding.adoc#data-binding-conversion[previous section].\nAdditionally, ``ApplicationContext``s also override or add additional editors to handle\nresource lookups in a manner appropriate to the specific application context type.\n\nStandard JavaBeans `PropertyEditor` instances are used to convert property values\nexpressed as strings to the actual complex type of the property. You can use\n`CustomEditorConfigurer`, a bean factory post-processor, to conveniently add\nsupport for additional `PropertyEditor` instances to an `ApplicationContext`.\n\nConsider the following example, which defines a user class called `ExoticType` and\nanother class called `DependsOnExoticType`, which needs `ExoticType` set as a property:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage example;\n\n\tpublic class ExoticType {\n\n private String name;\n\n public ExoticType(String name) {\n this.name = name;\n }\n\t}\n\n\tpublic class DependsOnExoticType {\n\n private ExoticType type;\n\n public void setType(ExoticType type) {\n this.type = type;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage example\n\n\tclass ExoticType(val name: String)\n\n\tclass DependsOnExoticType {\n\n var type: ExoticType? = null\n\t}\n----\n======\n\nWhen things are properly set up, we want to be able to assign the type property as a\nstring, which a `PropertyEditor` converts into an actual\n`ExoticType` instance. The following bean definition shows how to set up this relationship:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"sample\" class=\"example.DependsOnExoticType\">\n <property name=\"type\" value=\"aNameForExoticType\"/>\n\t</bean>\n----\n\nThe `PropertyEditor` implementation could look similar to the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage example;\n\n\timport java.beans.PropertyEditorSupport;\n\n\t// converts string representation to ExoticType object\n\tpublic class ExoticTypeEditor extends PropertyEditorSupport {\n\n public void setAsText(String text) {\n setValue(new ExoticType(text.toUpperCase()));\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage example\n\n\timport java.beans.PropertyEditorSupport\n\n\t// converts string representation to ExoticType object\n\tclass ExoticTypeEditor : PropertyEditorSupport() {\n\n override fun setAsText(text: String) {\n value = ExoticType(text.toUpperCase())\n }\n\t}\n----\n======\n\nFinally, the following example shows how to use `CustomEditorConfigurer` to register the new `PropertyEditor` with the\n`ApplicationContext`, which will then be able to use it as needed:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\">\n <property name=\"customEditors\">\n <map>\n <entry key=\"example.ExoticType\" value=\"example.ExoticTypeEditor\"/>\n </map>\n </property>\n\t</bean>\n----\n\n[[data-binding-conversion-customeditor-registration-per]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc", "title": "data-binding", "heading": "Custom ``PropertyEditor``s", "heading_level": 3, "file_order": 92, "section_index": 5, "content_hash": "f9e12a53abe393481cdc1595514413d2dd795e3b21874344ba137df884c75b2b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc"}}
{"id": "sha256:038bbbf3fb10752c164d62fe0f66aab4dd5f03b4ade4b73742a9482d5244c01b", "content": "Another mechanism for registering property editors with the Spring container is to\ncreate and use a `PropertyEditorRegistrar`. This interface is particularly useful when\nyou need to use the same set of property editors in several different situations.\nYou can write a corresponding registrar and reuse it in each case.\n`PropertyEditorRegistrar` instances work in conjunction with an interface called\n`PropertyEditorRegistry`, an interface that is implemented by the Spring `BeanWrapper`\n(and `DataBinder`). `PropertyEditorRegistrar` instances are particularly convenient\nwhen used in conjunction with `CustomEditorConfigurer` (described\nxref:core/validation/data-binding.adoc#data-binding-conversion-customeditor-registration[here]), which exposes a property\ncalled `setPropertyEditorRegistrars(..)`. `PropertyEditorRegistrar` instances added\nto a `CustomEditorConfigurer` in this fashion can easily be shared with `DataBinder` and\nSpring MVC controllers. Furthermore, it avoids the need for synchronization on custom\neditors: A `PropertyEditorRegistrar` is expected to create fresh `PropertyEditor`\ninstances for each bean creation attempt.\n\nThe following example shows how to create your own `PropertyEditorRegistrar` implementation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo.editors.spring;\n\n\tpublic final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {\n\n public void registerCustomEditors(PropertyEditorRegistry registry) {\n\n // it is expected that new PropertyEditor instances are created\n registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());\n\n // you could register as many custom property editors as are required here...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.foo.editors.spring\n\n\timport org.springframework.beans.PropertyEditorRegistrar\n\timport org.springframework.beans.PropertyEditorRegistry\n\n\tclass CustomPropertyEditorRegistrar : PropertyEditorRegistrar {\n\n override fun registerCustomEditors(registry: PropertyEditorRegistry) {\n\n // it is expected that new PropertyEditor instances are created\n registry.registerCustomEditor(ExoticType::class.java, ExoticTypeEditor())\n\n // you could register as many custom property editors as are required here...\n }\n\t}\n----\n======\n\nSee also the `org.springframework.beans.support.ResourceEditorRegistrar` for an example\n`PropertyEditorRegistrar` implementation. Notice how in its implementation of the\n`registerCustomEditors(..)` method, it creates new instances of each property editor.\n\nThe next example shows how to configure a `CustomEditorConfigurer` and inject an instance\nof our `CustomPropertyEditorRegistrar` into it:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\">\n <property name=\"propertyEditorRegistrars\">\n <list>\n <ref bean=\"customPropertyEditorRegistrar\"/>\n </list>\n </property>\n\t</bean>\n\n\t<bean id=\"customPropertyEditorRegistrar\"\n class=\"com.foo.editors.spring.CustomPropertyEditorRegistrar\"/>\n----\n\nFinally (and in a bit of a departure from the focus of this chapter) for those of you\nusing xref:web/webmvc.adoc#mvc[Spring's MVC web framework], using a `PropertyEditorRegistrar` in\nconjunction with data-binding web controllers can be very convenient. The following\nexample uses a `PropertyEditorRegistrar` in the implementation of an `@InitBinder` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class RegisterUserController {\n\n private final PropertyEditorRegistrar customPropertyEditorRegistrar;\n\n RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {\n this.customPropertyEditorRegistrar = propertyEditorRegistrar;\n }\n\n @InitBinder\n void initBinder(WebDataBinder binder) {\n this.customPropertyEditorRegistrar.registerCustomEditors(binder);\n }\n\n // other methods related to registering a User\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tclass RegisterUserController(\n private val customPropertyEditorRegistrar: PropertyEditorRegistrar) {\n\n @InitBinder\n fun initBinder(binder: WebDataBinder) {\n this.customPropertyEditorRegistrar.registerCustomEditors(binder)\n }\n\n // other methods related to registering a User\n\t}\n----\n======\n\nThis style of `PropertyEditor` registration can lead to concise code (the implementation\nof the `@InitBinder` method is only one line long) and lets common `PropertyEditor`\nregistration code be encapsulated in a class and then shared amongst as many controllers\nas needed.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc", "title": "data-binding", "heading": "`PropertyEditorRegistrar`", "heading_level": 3, "file_order": 92, "section_index": 6, "content_hash": "038bbbf3fb10752c164d62fe0f66aab4dd5f03b4ade4b73742a9482d5244c01b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/data-binding.adoc"}}
{"id": "sha256:8212bdd87c5b70c87df03d53d5f8f42a3554e7b9ada5094c0296ccf4d4dca1a3", "content": "[[validation-error-code-resolution]]\n\nWe covered data binding and validation. This section covers outputting messages that correspond\nto validation errors. In the example shown in the xref:core/validation/validator.adoc[preceding section],\nwe rejected the `name` and `age` fields. If we want to output the error messages by using a\n`MessageSource`, we can do so using the error code we provide when rejecting the field\n('name' and 'age' in this case). When you call (either directly, or indirectly, by using,\nfor example, the `ValidationUtils` class) `rejectValue` or one of the other `reject` methods\nfrom the `Errors` interface, the underlying implementation not only registers the code you\npassed in but also registers a number of additional error codes. The `MessageCodesResolver`\ndetermines which error codes the `Errors` interface registers. By default, the\n`DefaultMessageCodesResolver` is used, which (for example) not only registers a message\nwith the code you gave but also registers messages that include the field name you passed\nto the reject method. So, if you reject a field by using `rejectValue(\"age\", \"too.darn.old\")`,\napart from the `too.darn.old` code, Spring also registers `too.darn.old.age` and\n`too.darn.old.age.int` (the first includes the field name and the second includes the type\nof the field). This is done as a convenience to aid developers when targeting error messages.\n\nMore information on the `MessageCodesResolver` and the default strategy can be found\nin the javadoc of\n{spring-framework-api}/validation/MessageCodesResolver.html[`MessageCodesResolver`] and\n{spring-framework-api}/validation/DefaultMessageCodesResolver.html[`DefaultMessageCodesResolver`],\nrespectively.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/error-code-resolution.adoc", "title": "error-code-resolution", "heading": "error-code-resolution", "heading_level": 1, "file_order": 93, "section_index": 0, "content_hash": "8212bdd87c5b70c87df03d53d5f8f42a3554e7b9ada5094c0296ccf4d4dca1a3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/error-code-resolution.adoc"}}
{"id": "sha256:c086ba96e81e0d8b4d9bb039c2e28aad101be39eb352c8958c0b70aa3d7d28cd", "content": "[[format-configuring-formatting-globaldatetimeformat]]\n\nBy default, date and time fields not annotated with `@DateTimeFormat` are converted from\nstrings by using the `DateFormat.SHORT` style. If you prefer, you can change this by\ndefining your own global format.\n\nTo do that, ensure that Spring does not register default formatters. Instead, register\nformatters manually with the help of:\n\n* `org.springframework.format.datetime.standard.DateTimeFormatterRegistrar`\n* `org.springframework.format.datetime.DateFormatterRegistrar`\n\nFor example, the following configuration registers a global `yyyyMMdd` format:\n\ninclude-code::./ApplicationConfiguration[tag=snippet,indent=0]\n\nNote there are extra considerations when configuring date and time formats in web\napplications. Please see\nxref:web/webmvc/mvc-config/conversion.adoc[WebMVC Conversion and Formatting] or\nxref:web/webflux/config.adoc#webflux-config-conversion[WebFlux Conversion and Formatting].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/format-configuring-formatting-globaldatetimeformat.adoc", "title": "format-configuring-formatting-globaldatetimeformat", "heading": "format-configuring-formatting-globaldatetimeformat", "heading_level": 1, "file_order": 94, "section_index": 0, "content_hash": "c086ba96e81e0d8b4d9bb039c2e28aad101be39eb352c8958c0b70aa3d7d28cd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/format-configuring-formatting-globaldatetimeformat.adoc"}}
{"id": "sha256:8e7b5495fb0a053fa2f81d6f902643699a4b1f65382619e04a1d29605ce0c69b", "content": "[[format]]\n\nAs discussed in the previous section, xref:core/validation/convert.adoc[`core.convert`] is a\ngeneral-purpose type conversion system. It provides a unified `ConversionService` API as\nwell as a strongly typed `Converter` SPI for implementing conversion logic from one type\nto another. A Spring container uses this system to bind bean property values. In\naddition, both the Spring Expression Language (SpEL) and `DataBinder` use this system to\nbind field values. For example, when SpEL needs to coerce a `Short` to a `Long` to\ncomplete an `expression.setValue(Object bean, Object value)` attempt, the `core.convert`\nsystem performs the coercion.\n\nNow consider the type conversion requirements of a typical client environment, such as a\nweb or desktop application. In such environments, you typically convert from `String`\nto support the client postback process, as well as back to `String` to support the\nview rendering process. In addition, you often need to localize `String` values. The more\ngeneral `core.convert` `Converter` SPI does not address such formatting requirements\ndirectly. To directly address them, Spring provides a convenient `Formatter` SPI that\nprovides a simple and robust alternative to `PropertyEditor` implementations for client\nenvironments.\n\nIn general, you can use the `Converter` SPI when you need to implement general-purpose type\nconversion logic -- for example, for converting between a `java.util.Date` and a `Long`.\nYou can use the `Formatter` SPI when you work in a client environment (such as a web\napplication) and need to parse and print localized field values. The `ConversionService`\nprovides a unified type conversion API for both SPIs.\n\n[[format-Formatter-SPI]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/format.adoc", "title": "format", "heading": "format", "heading_level": 1, "file_order": 95, "section_index": 0, "content_hash": "8e7b5495fb0a053fa2f81d6f902643699a4b1f65382619e04a1d29605ce0c69b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/format.adoc"}}
{"id": "sha256:03d75b31574c2b6fe908d1ed9787e6c1a10e1f0d45116eedd562c502d6eb2d54", "content": "The `Formatter` SPI to implement field formatting logic is simple and strongly typed. The\nfollowing listing shows the `Formatter` interface definition:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.format;\n\n\tpublic interface Formatter<T> extends Printer<T>, Parser<T> {\n\t}\n----\n\n`Formatter` extends from the `Printer` and `Parser` building-block interfaces. The\nfollowing listing shows the definitions of those two interfaces:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface Printer<T> {\n\n String print(T fieldValue, Locale locale);\n\t}\n----\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.text.ParseException;\n\n\tpublic interface Parser<T> {\n\n T parse(String clientValue, Locale locale) throws ParseException;\n\t}\n----\n\nTo create your own `Formatter`, implement the `Formatter` interface shown earlier.\nParameterize `T` to be the type of object you wish to format -- for example,\n`java.util.Date`. Implement the `print()` operation to print an instance of `T` for\ndisplay in the client locale. Implement the `parse()` operation to parse an instance of\n`T` from the formatted representation returned from the client locale. Your `Formatter`\nshould throw a `ParseException` or an `IllegalArgumentException` if a parse attempt fails. Take\ncare to ensure that your `Formatter` implementation is thread-safe.\n\nThe `format` subpackages provide several `Formatter` implementations as a convenience.\nThe `number` package provides `NumberStyleFormatter`, `CurrencyStyleFormatter`, and\n`PercentStyleFormatter` to format `Number` objects that use a `java.text.NumberFormat`.\nThe `datetime` package provides a `DateFormatter` to format `java.util.Date` objects with\na `java.text.DateFormat`, as well as a `DurationFormatter` to format `Duration` objects\nin different styles defined in the `@DurationFormat.Style` enum (see <<format-annotations-api>>).\n\nThe following `DateFormatter` is an example `Formatter` implementation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.format.datetime;\n\n\tpublic final class DateFormatter implements Formatter<Date> {\n\n private String pattern;\n\n public DateFormatter(String pattern) {\n this.pattern = pattern;\n }\n\n public String print(Date date, Locale locale) {\n if (date == null) {\n return \"\";\n }\n return getDateFormat(locale).format(date);\n }\n\n public Date parse(String formatted, Locale locale) throws ParseException {\n if (formatted.length() == 0) {\n return null;\n }\n return getDateFormat(locale).parse(formatted);\n }\n\n protected DateFormat getDateFormat(Locale locale) {\n DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);\n dateFormat.setLenient(false);\n return dateFormat;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tclass DateFormatter(private val pattern: String) : Formatter<Date> {\n\n override fun print(date: Date, locale: Locale)\n\n @Throws(ParseException::class)\n override fun parse(formatted: String, locale: Locale)\n\n protected fun getDateFormat(locale: Locale): DateFormat {\n val dateFormat = SimpleDateFormat(this.pattern, locale)\n dateFormat.isLenient = false\n return dateFormat\n }\n\t}\n----\n======\n\nThe Spring team welcomes community-driven `Formatter` contributions. See\n{spring-framework-issues}[GitHub Issues] to contribute.\n\n[[format-CustomFormatAnnotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/format.adoc", "title": "format", "heading": "The `Formatter` SPI", "heading_level": 2, "file_order": 95, "section_index": 1, "content_hash": "03d75b31574c2b6fe908d1ed9787e6c1a10e1f0d45116eedd562c502d6eb2d54", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/format.adoc"}}
{"id": "sha256:da648f3038b4bdfdb63fd4c4a3c4a36314191e671c1eacfe23b02f03fed58648", "content": "Field formatting can be configured by field type or annotation. To bind\nan annotation to a `Formatter`, implement `AnnotationFormatterFactory`. The following\nlisting shows the definition of the `AnnotationFormatterFactory` interface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.format;\n\n\tpublic interface AnnotationFormatterFactory<A extends Annotation> {\n\n Set<Class<?>> getFieldTypes();\n\n Printer<?> getPrinter(A annotation, Class<?> fieldType);\n\n Parser<?> getParser(A annotation, Class<?> fieldType);\n\t}\n----\n\nTo create an implementation:\n\n. Parameterize `A` to be the field `annotationType` with which you wish to associate\nformatting logic -- for example `org.springframework.format.annotation.DateTimeFormat`.\n. Have `getFieldTypes()` return the types of fields on which the annotation can be used.\n. Have `getPrinter()` return a `Printer` to print the value of an annotated field.\n. Have `getParser()` return a `Parser` to parse a `clientValue` for an annotated field.\n\nThe following example `AnnotationFormatterFactory` implementation binds the `@NumberFormat`\nannotation to a formatter to let a number style or pattern be specified:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic final class NumberFormatAnnotationFormatterFactory\n implements AnnotationFormatterFactory<NumberFormat> {\n\n private static final Set<Class<?>> FIELD_TYPES = Set.of(Short.class,\n Integer.class, Long.class, Float.class, Double.class,\n BigDecimal.class, BigInteger.class);\n\n public Set<Class<?>> getFieldTypes() {\n return FIELD_TYPES;\n }\n\n public Printer<Number> getPrinter(NumberFormat annotation, Class<?> fieldType) {\n return configureFormatterFrom(annotation, fieldType);\n }\n\n public Parser<Number> getParser(NumberFormat annotation, Class<?> fieldType) {\n return configureFormatterFrom(annotation, fieldType);\n }\n\n private Formatter<Number> configureFormatterFrom(NumberFormat annotation, Class<?> fieldType) {\n if (!annotation.pattern().isEmpty()) {\n return new NumberStyleFormatter(annotation.pattern());\n }\n // else\n return switch(annotation.style()) {\n case Style.PERCENT -> new PercentStyleFormatter();\n case Style.CURRENCY -> new CurrencyStyleFormatter();\n default -> new NumberStyleFormatter();\n };\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass NumberFormatAnnotationFormatterFactory : AnnotationFormatterFactory<NumberFormat> {\n\n override fun getFieldTypes(): Set<Class<*>> {\n return setOf(Short::class.java, Int::class.java, Long::class.java, Float::class.java, Double::class.java, BigDecimal::class.java, BigInteger::class.java)\n }\n\n override fun getPrinter(annotation: NumberFormat, fieldType: Class<*>): Printer<Number> {\n return configureFormatterFrom(annotation, fieldType)\n }\n\n override fun getParser(annotation: NumberFormat, fieldType: Class<*>): Parser<Number> {\n return configureFormatterFrom(annotation, fieldType)\n }\n\n private fun configureFormatterFrom(annotation: NumberFormat, fieldType: Class<*>): Formatter<Number> {\n return if (annotation.pattern.isNotEmpty()) {\n NumberStyleFormatter(annotation.pattern)\n } else {\n val style = annotation.style\n when {\n style === NumberFormat.Style.PERCENT -> PercentStyleFormatter()\n style === NumberFormat.Style.CURRENCY -> CurrencyStyleFormatter()\n else -> NumberStyleFormatter()\n }\n }\n }\n\t}\n----\n======\n\nTo trigger formatting, you can annotate fields with `@NumberFormat`, as the following\nexample shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MyModel {\n\n @NumberFormat(style=Style.CURRENCY)\n private BigDecimal decimal;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MyModel(\n @field:NumberFormat(style = Style.CURRENCY) private val decimal: BigDecimal\n\t)\n----\n======\n\n[[format-annotations-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/format.adoc", "title": "format", "heading": "Annotation-driven Formatting", "heading_level": 2, "file_order": 95, "section_index": 2, "content_hash": "da648f3038b4bdfdb63fd4c4a3c4a36314191e671c1eacfe23b02f03fed58648", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/format.adoc"}}
{"id": "sha256:9a00ee5acb783e907359698a30770151b1afb5447c86fe42ff55a22d9d7b5d91", "content": "A portable format annotation API exists in the `org.springframework.format.annotation`\npackage. You can use `@NumberFormat` to format `Number` fields such as `Double` and\n`Long`, `@DurationFormat` to format `Duration` fields in ISO-8601 and simplified styles,\nand `@DateTimeFormat` to format fields such as `java.util.Date`, `java.util.Calendar`,\nand `Long` (for millisecond timestamps) as well as JSR-310 `java.time` types.\n\nThe following example uses `@DateTimeFormat` to format a `java.util.Date` as an ISO date\n(yyyy-MM-dd):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MyModel {\n\n @DateTimeFormat(iso=ISO.DATE)\n private Date date;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MyModel(\n @DateTimeFormat(iso=ISO.DATE) private val date: Date\n\t)\n----\n======\n\nFor further details, see the javadoc for\n{spring-framework-api}/format/annotation/DateTimeFormat.html[`@DateTimeFormat`],\n{spring-framework-api}/format/annotation/DurationFormat.html[`@DurationFormat`], and\n{spring-framework-api}/format/annotation/NumberFormat.html[`@NumberFormat`].\n\n[WARNING]\n====\nStyle-based formatting and parsing rely on locale-sensitive patterns which may change\ndepending on the Java runtime. Specifically, applications that rely on date, time, or\nnumber parsing and formatting may encounter incompatible changes in behavior when running\non JDK 20 or higher.\n\nUsing an ISO standardized format or a concrete pattern that you control allows for\nreliable system-independent and locale-independent parsing and formatting of date, time,\nand number values.\n\nFor `@DateTimeFormat`, the use of fallback patterns can also help to address\ncompatibility issues.\n\nFor further details, see the\nhttps://github.com/spring-projects/spring-framework/wiki/Date-and-Time-Formatting-with-JDK-20-and-higher[Date and Time Formatting with JDK 20 and higher]\npage in the Spring Framework wiki.\n====\n\n[[format-FormatterRegistry-SPI]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/format.adoc", "title": "format", "heading": "Format Annotation API", "heading_level": 3, "file_order": 95, "section_index": 3, "content_hash": "9a00ee5acb783e907359698a30770151b1afb5447c86fe42ff55a22d9d7b5d91", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/format.adoc"}}
{"id": "sha256:4e48c39b63ce0193b1b31fc381958616daeb97482df6ab9dfa718b0afdaf237b", "content": "The `FormatterRegistry` is an SPI for registering formatters and converters.\n`FormattingConversionService` is an implementation of `FormatterRegistry` suitable for\nmost environments. You can programmatically or declaratively configure this variant\nas a Spring bean, for example, by using `FormattingConversionServiceFactoryBean`. Because this\nimplementation also implements `ConversionService`, you can directly configure it\nfor use with Spring's `DataBinder` and the Spring Expression Language (SpEL).\n\nThe following listing shows the `FormatterRegistry` SPI:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.format;\n\n\tpublic interface FormatterRegistry extends ConverterRegistry {\n\n void addPrinter(Printer<?> printer);\n\n void addParser(Parser<?> parser);\n\n void addFormatter(Formatter<?> formatter);\n\n void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter);\n\n void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser);\n\n void addFormatterForFieldAnnotation(AnnotationFormatterFactory<? extends Annotation> annotationFormatterFactory);\n\t}\n----\n\nAs shown in the preceding listing, you can register formatters by field type or by annotation.\n\nThe `FormatterRegistry` SPI lets you configure formatting rules centrally, instead of\nduplicating such configuration across your controllers. For example, you might want to\nenforce that all date fields are formatted a certain way or that fields with a specific\nannotation are formatted in a certain way. With a shared `FormatterRegistry`, you define\nthese rules once, and they are applied whenever formatting is needed.\n\n[[format-FormatterRegistrar-SPI]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/format.adoc", "title": "format", "heading": "The `FormatterRegistry` SPI", "heading_level": 2, "file_order": 95, "section_index": 4, "content_hash": "4e48c39b63ce0193b1b31fc381958616daeb97482df6ab9dfa718b0afdaf237b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/format.adoc"}}
{"id": "sha256:6e9a8339ae72eae8b6976051035674197303806e239e1f9a4ee30802c297b5de", "content": "`FormatterRegistrar` is an SPI for registering formatters and converters through the\nFormatterRegistry. The following listing shows its interface definition:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.format;\n\n\tpublic interface FormatterRegistrar {\n\n void registerFormatters(FormatterRegistry registry);\n\t}\n----\n\nA `FormatterRegistrar` is useful when registering multiple related converters and\nformatters for a given formatting category, such as date formatting. It can also be\nuseful where declarative registration is insufficient -- for example, when a formatter\nneeds to be indexed under a specific field type different from its own `<T>` or when\nregistering a `Printer`/`Parser` pair. The next section provides more information on\nconverter and formatter registration.\n\n[[format-configuring-formatting-mvc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/format.adoc", "title": "format", "heading": "The `FormatterRegistrar` SPI", "heading_level": 2, "file_order": 95, "section_index": 5, "content_hash": "6e9a8339ae72eae8b6976051035674197303806e239e1f9a4ee30802c297b5de", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/format.adoc"}}
{"id": "sha256:c86b5b8288169adaad07a246fc7af6f9b09fde567d5c62219249cd55d625a1c0", "content": "See xref:web/webmvc/mvc-config/conversion.adoc[Conversion and Formatting] in the Spring MVC chapter.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/format.adoc", "title": "format", "heading": "Configuring Formatting in Spring MVC", "heading_level": 2, "file_order": 95, "section_index": 6, "content_hash": "c86b5b8288169adaad07a246fc7af6f9b09fde567d5c62219249cd55d625a1c0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/format.adoc"}}
{"id": "sha256:edfe1c43a5b2928a7ce3951e47867195198e27ed15dff3cc147d724997fde41d", "content": "[[validator]]\n\nSpring features a `Validator` interface that you can use to validate objects. The\n`Validator` interface works by using an `Errors` object so that, while validating,\nvalidators can report validation failures to the `Errors` object.\n\nConsider the following example of a small data object:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class Person {\n\n private String name;\n private int age;\n\n // the usual getters and setters...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Person(val name: String, val age: Int)\n----\n======\n\nThe next example provides validation behavior for the `Person` class by implementing the\nfollowing two methods of the `org.springframework.validation.Validator` interface:\n\n* `supports(Class)`: Can this `Validator` validate instances of the supplied `Class`?\n* `validate(Object, org.springframework.validation.Errors)`: Validates the given object\n and, in case of validation errors, registers those with the given `Errors` object.\n\nImplementing a `Validator` is fairly straightforward, especially when you know of the\n`ValidationUtils` helper class that the Spring Framework also provides. The following\nexample implements `Validator` for `Person` instances:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class PersonValidator implements Validator {\n\n /**\n * This Validator validates only Person instances\n */\n public boolean supports(Class clazz) {\n return Person.class.equals(clazz);\n }\n\n public void validate(Object obj, Errors e) {\n ValidationUtils.rejectIfEmpty(e, \"name\", \"name.empty\");\n Person p = (Person) obj;\n if (p.getAge() < 0) {\n e.rejectValue(\"age\", \"negativevalue\");\n } else if (p.getAge() > 110) {\n e.rejectValue(\"age\", \"too.darn.old\");\n }\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass PersonValidator : Validator {\n\n /\\**\n * This Validator validates only Person instances\n */\n override fun supports(clazz: Class<*>): Boolean {\n return Person::class.java == clazz\n }\n\n override fun validate(obj: Any, e: Errors) {\n ValidationUtils.rejectIfEmpty(e, \"name\", \"name.empty\")\n val p = obj as Person\n if (p.age < 0) {\n e.rejectValue(\"age\", \"negativevalue\")\n } else if (p.age > 110) {\n e.rejectValue(\"age\", \"too.darn.old\")\n }\n }\n\t}\n----\n======\n\nThe `static` `rejectIfEmpty(..)` method on the `ValidationUtils` class is used to\nreject the `name` property if it is `null` or the empty string. Have a look at the\n{spring-framework-api}/validation/ValidationUtils.html[`ValidationUtils`] javadoc\nto see what functionality it provides besides the example shown previously.\n\nWhile it is certainly possible to implement a single `Validator` class to validate each\nof the nested objects in a rich object, it may be better to encapsulate the validation\nlogic for each nested class of object in its own `Validator` implementation. A simple\nexample of a \"`rich`\" object would be a `Customer` that is composed of two `String`\nproperties (a first and a second name) and a complex `Address` object. `Address` objects\nmay be used independently of `Customer` objects, so a distinct `AddressValidator`\nhas been implemented. If you want your `CustomerValidator` to reuse the logic contained\nwithin the `AddressValidator` class without resorting to copy-and-paste, you can\ndependency-inject or instantiate an `AddressValidator` within your `CustomerValidator`,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class CustomerValidator implements Validator {\n\n private final Validator addressValidator;\n\n public CustomerValidator(Validator addressValidator) {\n if (addressValidator == null) {\n throw new IllegalArgumentException(\"The supplied [Validator] is \" +\n \"required and must not be null.\");\n }\n if (!addressValidator.supports(Address.class)) {\n throw new IllegalArgumentException(\"The supplied [Validator] must \" +\n \"support the validation of [Address] instances.\");\n }\n this.addressValidator = addressValidator;\n }\n\n /**\n * This Validator validates Customer instances, and any subclasses of Customer too\n */\n public boolean supports(Class clazz) {\n return Customer.class.isAssignableFrom(clazz);\n }\n\n public void validate(Object target, Errors errors) {\n ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"firstName\", \"field.required\");\n ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"surname\", \"field.required\");\n Customer customer = (Customer) target;\n try {\n errors.pushNestedPath(\"address\");\n ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);\n } finally {\n errors.popNestedPath();\n }\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass CustomerValidator(private val addressValidator: Validator) : Validator {\n\n init {\n if (addressValidator == null) {\n throw IllegalArgumentException(\"The supplied [Validator] is required and must not be null.\")\n }\n if (!addressValidator.supports(Address::class.java)) {\n throw IllegalArgumentException(\"The supplied [Validator] must support the validation of [Address] instances.\")\n }\n }\n\n /**\n * This Validator validates Customer instances, and any subclasses of Customer too\n */\n override fun supports(clazz: Class<*>): Boolean {\n return Customer::class.java.isAssignableFrom(clazz)\n }\n\n override fun validate(target: Any, errors: Errors) {\n ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"firstName\", \"field.required\")\n ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"surname\", \"field.required\")\n val customer = target as Customer\n try {\n errors.pushNestedPath(\"address\")\n ValidationUtils.invokeValidator(this.addressValidator, customer.address, errors)\n } finally {\n errors.popNestedPath()\n }\n }\n\t}\n----\n======\n\nValidation errors are reported to the `Errors` object passed to the validator. In the case\nof Spring Web MVC, you can use the `<spring:bind/>` tag to inspect the error messages, but\nyou can also inspect the `Errors` object yourself. More information about the\nmethods it offers can be found in the {spring-framework-api}/validation/Errors.html[javadoc].\n\nValidators may also get locally invoked for the immediate validation of a given object,\nnot involving a binding process. As of 6.1, this has been simplified through a new\n`Validator.validateObject(Object)` method which is available by default now, returning\na simple `Errors` representation which can be inspected: typically calling `hasErrors()`\nor the new `failOnError` method for turning the error summary message into an exception\n(for example, `validator.validateObject(myObject).failOnError(IllegalArgumentException::new)`).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation/validator.adoc", "title": "validator", "heading": "validator", "heading_level": 1, "file_order": 96, "section_index": 0, "content_hash": "edfe1c43a5b2928a7ce3951e47867195198e27ed15dff3cc147d724997fde41d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation/validator.adoc"}}
{"id": "sha256:87d480fb529cf041029c1d3598ef2668469bfa45b96fb74c863e6317a62850c4", "content": "[[aop-api]]\n\nThe previous chapter described the Spring's support for AOP with @AspectJ and schema-based\naspect definitions. In this chapter, we discuss the lower-level Spring AOP APIs. For common\napplications, we recommend the use of Spring AOP with AspectJ pointcuts as described in the\nprevious chapter.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop-api.adoc", "title": "aop-api", "heading": "aop-api", "heading_level": 1, "file_order": 97, "section_index": 0, "content_hash": "87d480fb529cf041029c1d3598ef2668469bfa45b96fb74c863e6317a62850c4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop-api.adoc"}}
{"id": "sha256:1cc97684a6027f72f1088391d084e7732287f5c0c790f9d7ed88c5d69c847558", "content": "[[aop]]\n\nAspect-oriented Programming (AOP) complements Object-oriented Programming (OOP) by\nproviding another way of thinking about program structure. The key unit of modularity\nin OOP is the class, whereas in AOP the unit of modularity is the aspect. Aspects\nenable the modularization of concerns (such as transaction management) that cut across\nmultiple types and objects. (Such concerns are often termed \"crosscutting\" concerns\nin AOP literature.)\n\nOne of the key components of Spring is the AOP framework. While the Spring IoC\ncontainer does not depend on AOP (meaning you do not need to use AOP if you don't want\nto), AOP complements Spring IoC to provide a very capable middleware solution.\n\n.Spring AOP with AspectJ pointcuts\n****\nSpring provides simple and powerful ways of writing custom aspects by using either a\nxref:core/aop/schema.adoc[schema-based approach] or the xref:core/aop/ataspectj.adoc[@AspectJ annotation style].\nBoth of these styles offer fully typed advice and use of the AspectJ pointcut language\nwhile still using Spring AOP for weaving.\n\nThis chapter discusses the schema- and @AspectJ-based AOP support.\nThe lower-level AOP support is discussed in xref:core/aop-api.adoc[the following chapter].\n****\n\nAOP is used in the Spring Framework to:\n\n* Provide declarative enterprise services. The most important such service is\n xref:data-access/transaction/declarative.adoc[declarative transaction management].\n* Let users implement custom aspects, complementing their use of OOP with AOP.\n\nNOTE: If you are interested only in generic declarative services or other pre-packaged\ndeclarative middleware services such as pooling, you do not need to work directly with\nSpring AOP, and can skip most of this chapter.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aop.adoc", "title": "aop", "heading": "aop", "heading_level": 1, "file_order": 98, "section_index": 0, "content_hash": "1cc97684a6027f72f1088391d084e7732287f5c0c790f9d7ed88c5d69c847558", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aop.adoc"}}
{"id": "sha256:4441d11fb72c35af7ad6133732e42d1243a7775c7d4647664c517801c30f1695", "content": "[[aot]]\n\nThis chapter covers Spring's Ahead of Time (AOT) optimizations.\n\nFor AOT support specific to integration tests, see xref:testing/testcontext-framework/aot.adoc[Ahead of Time Support for Tests].\n\n[[aot.introduction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "aot", "heading_level": 1, "file_order": 99, "section_index": 0, "content_hash": "4441d11fb72c35af7ad6133732e42d1243a7775c7d4647664c517801c30f1695", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:81a4a362c7d242d163ce17d4d9977bc2c8e4a428e10697b4f3ba90c7a8487fec", "content": "Spring's support for AOT optimizations is meant to inspect an `ApplicationContext` at build time and apply decisions and discovery logic that usually happens at runtime.\nDoing so allows building an application startup arrangement that is more straightforward and focused on a fixed set of features based mainly on the classpath and the `Environment`.\n\nApplying such optimizations early implies the following restrictions:\n\n* The classpath is fixed and fully defined at build time.\n* The beans defined in your application cannot change at runtime, meaning:\n** `@Profile`, in particular profile-specific configuration, needs to be chosen at build time and is automatically enabled at runtime when AOT is enabled.\n** `Environment` properties that impact the presence of a bean (`@Conditional`) are only considered at build time.\n* Bean definitions with instance suppliers (lambdas or method references) cannot be transformed ahead of time.\n* Beans registered as singletons (using `registerSingleton`, typically from\n`ConfigurableListableBeanFactory`) cannot be transformed ahead of time either.\n* As we cannot rely on the instance, make sure that the bean type is as precise as\npossible.\n\nTIP: See also the xref:core/aot.adoc#aot.bestpractices[] section.\n\nWhen these restrictions are in place, it becomes possible to perform ahead-of-time processing at build time and generate additional assets.\nA Spring AOT processed application typically generates:\n\n* Java source code\n* Bytecode (usually for dynamic proxies)\n* {spring-framework-api}/aot/hint/RuntimeHints.html[`RuntimeHints`] for the use of reflection, resource loading, serialization, and JDK proxies\n\nNOTE: At the moment, AOT is focused on allowing Spring applications to be deployed as native images using GraalVM.\nWe intend to support more JVM-based use cases in future generations.\n\n[[aot.basics]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Introduction to Ahead of Time Optimizations", "heading_level": 2, "file_order": 99, "section_index": 1, "content_hash": "81a4a362c7d242d163ce17d4d9977bc2c8e4a428e10697b4f3ba90c7a8487fec", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:bf8e082db9adbe3371a1e6975c94a39cbd9382fdbf4bb6f09076f50d30770f96", "content": "The entry point of the AOT engine for processing an `ApplicationContext` is `ApplicationContextAotGenerator`. It takes care of the following steps, based on a `GenericApplicationContext` that represents the application to optimize and a {spring-framework-api}/aot/generate/GenerationContext.html[`GenerationContext`]:\n\n* Refresh an `ApplicationContext` for AOT processing. Contrary to a traditional refresh, this version only creates bean definitions, not bean instances.\n* Invoke the available `BeanFactoryInitializationAotProcessor` implementations and apply their contributions against the `GenerationContext`.\nFor instance, a core implementation iterates over all candidate bean definitions and generates the necessary code to restore the state of the `BeanFactory`.\n\nOnce this process completes, the `GenerationContext` will have been updated with the generated code, resources, and classes that are necessary for the application to run.\nThe `RuntimeHints` instance can also be used to generate the relevant GraalVM native image configuration files.\n\n`ApplicationContextAotGenerator#processAheadOfTime` returns the class name of the `ApplicationContextInitializer` entry point that allows the context to be started with AOT optimizations.\n\nThose steps are covered in greater detail in the sections below.\n\n[[aot.refresh]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "AOT Engine Overview", "heading_level": 2, "file_order": 99, "section_index": 2, "content_hash": "bf8e082db9adbe3371a1e6975c94a39cbd9382fdbf4bb6f09076f50d30770f96", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:2c8d183ff74de7626c47e4876caaa2fba18e2ea10768e3f627e58bd7f96ac13c", "content": "Refresh for AOT processing is supported on all `GenericApplicationContext` implementations.\nAn application context is created with any number of entry points, usually in the form of `@Configuration`-annotated classes.\n\nLet's look at a basic example:\n\ninclude-code::./AotProcessingSample[tag=myapplication]\n\nStarting this application with the regular runtime involves a number of steps including classpath scanning, configuration class parsing, bean instantiation, and lifecycle callback handling.\nRefresh for AOT processing only applies a subset of what happens with a xref:core/beans/introduction.adoc[regular `refresh`].\nAOT processing can be triggered as follows:\n\ninclude-code::./AotProcessingSample[tag=aotcontext]\n\nIn this mode, xref:core/beans/factory-extension.adoc#beans-factory-extension-factory-postprocessors[`BeanFactoryPostProcessor` implementations] are invoked as usual.\nThis includes configuration class parsing, import selectors, classpath scanning, etc.\nSuch steps make sure that the `BeanRegistry` contains the relevant bean definitions for the application.\nIf bean definitions are guarded by conditions (such as `@Profile`), these are evaluated,\nand bean definitions that don't match their conditions are discarded at this stage.\n\nIf custom code needs to register extra beans programmatically, make sure that custom\nregistration code uses `BeanDefinitionRegistry` instead of `BeanFactory` as only bean\ndefinitions are taken into account. A good pattern is to implement\n`ImportBeanDefinitionRegistrar` and register it via an `@Import` on one of your\nconfiguration classes.\n\nBecause this mode does not actually create bean instances, `BeanPostProcessor` implementations are not invoked, except for specific variants that are relevant for AOT processing.\nThese are:\n\n* `MergedBeanDefinitionPostProcessor` implementations post-process bean definitions to extract additional settings, such as `init` and `destroy` methods.\n* `SmartInstantiationAwareBeanPostProcessor` implementations determine a more precise bean type if necessary.\nThis makes sure to create any proxy that will be required at runtime.\n\nOnce this part completes, the `BeanFactory` contains the bean definitions that are necessary for the application to run. It does not trigger bean instantiation but allows the AOT engine to inspect the beans that will be created at runtime.\n\n[[aot.bean-factory-initialization-contributions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Refresh for AOT Processing", "heading_level": 2, "file_order": 99, "section_index": 3, "content_hash": "2c8d183ff74de7626c47e4876caaa2fba18e2ea10768e3f627e58bd7f96ac13c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:1aafc95b0409ec178d8ffa2cc5e0197c4f1a2ff94d700499a3c13735e52b7e0d", "content": "Components that want to participate in this step can implement the {spring-framework-api}/beans/factory/aot/BeanFactoryInitializationAotProcessor.html[`BeanFactoryInitializationAotProcessor`] interface.\nEach implementation can return an AOT contribution, based on the state of the bean factory.\n\nAn AOT contribution is a component that contributes generated code which reproduces a particular behavior.\nIt can also contribute `RuntimeHints` to indicate the need for reflection, resource loading, serialization, or JDK proxies.\n\nA `BeanFactoryInitializationAotProcessor` implementation can be registered in `META-INF/spring/aot.factories` with a key equal to the fully-qualified name of the interface.\n\nThe `BeanFactoryInitializationAotProcessor` interface can also be implemented directly by a bean.\nIn this mode, the bean provides an AOT contribution equivalent to the feature it provides with a regular runtime.\nConsequently, such a bean is automatically excluded from the AOT-optimized context.\n\n[NOTE]\n====\nIf a bean implements the `BeanFactoryInitializationAotProcessor` interface, the bean and **all** of its dependencies will be initialized during AOT processing.\nWe generally recommend that this interface is only implemented by infrastructure beans, such as a `BeanFactoryPostProcessor`, which have limited dependencies and are already initialized early in the bean factory lifecycle.\nIf such a bean is registered using an `@Bean` factory method, ensure the method is `static` so that its enclosing `@Configuration` class does not have to be initialized.\n====\n\n[[aot.bean-registration-contributions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Bean Factory Initialization AOT Contributions", "heading_level": 2, "file_order": 99, "section_index": 4, "content_hash": "1aafc95b0409ec178d8ffa2cc5e0197c4f1a2ff94d700499a3c13735e52b7e0d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:8e69ee9fa46e2208629231f054839e0e3a314f658018fde7ba5ed8fe396719f2", "content": "A core `BeanFactoryInitializationAotProcessor` implementation is responsible for collecting the necessary contributions for each candidate `BeanDefinition`.\nIt does so using a dedicated `BeanRegistrationAotProcessor`.\n\nThis interface is used as follows:\n\n* Implemented by a `BeanPostProcessor` bean, to replace its runtime behavior.\nFor instance xref:core/beans/factory-extension.adoc#beans-factory-extension-bpp-examples-aabpp[`AutowiredAnnotationBeanPostProcessor`] implements this interface to generate code that injects members annotated with `@Autowired`.\n* Implemented by a type registered in `META-INF/spring/aot.factories` with a key equal to the fully-qualified name of the interface.\nTypically used when the bean definition needs to be tuned for specific features of the core framework.\n\n[NOTE]\n====\nIf a bean implements the `BeanRegistrationAotProcessor` interface, the bean and **all** of its dependencies will be initialized during AOT processing.\nWe generally recommend that this interface is only implemented by infrastructure beans, such as a `BeanFactoryPostProcessor`, which have limited dependencies and are already initialized early in the bean factory lifecycle.\nIf such a bean is registered using an `@Bean` factory method, ensure the method is `static` so that its enclosing `@Configuration` class does not have to be initialized.\n====\n\nIf no `BeanRegistrationAotProcessor` handles a particular registered bean, a default implementation processes it.\nThis is the default behavior, since tuning the generated code for a bean definition should be restricted to corner cases.\n\nTaking our previous example, let's assume that `DataSourceConfiguration` is as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration(proxyBeanMethods = false)\n\tpublic class DataSourceConfiguration {\n\n @Bean\n public SimpleDataSource dataSource() {\n return new SimpleDataSource();\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration(proxyBeanMethods = false)\n\tclass DataSourceConfiguration {\n\n @Bean\n fun dataSource() = SimpleDataSource()\n\n\t}\n----\n======\n\nWARNING: Kotlin class names with backticks that use invalid Java identifiers (not starting with a letter, containing spaces, etc.) are not supported.\n\nSince there isn't any particular condition on this class, `dataSourceConfiguration` and `dataSource` are identified as candidates.\nThe AOT engine will convert the configuration class above to code similar to the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0]\n----\n\t/**\n * Bean definitions for {@link DataSourceConfiguration}\n */\n\t@Generated\n\tpublic class DataSourceConfiguration__BeanDefinitions {\n /**\n * Get the bean definition for 'dataSourceConfiguration'\n */\n public static BeanDefinition getDataSourceConfigurationBeanDefinition() {\n Class<?> beanType = DataSourceConfiguration.class;\n RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);\n beanDefinition.setInstanceSupplier(DataSourceConfiguration::new);\n return beanDefinition;\n }\n\n /**\n * Get the bean instance supplier for 'dataSource'.\n */\n private static BeanInstanceSupplier<SimpleDataSource> getDataSourceInstanceSupplier() {\n return BeanInstanceSupplier.<SimpleDataSource>forFactoryMethod(DataSourceConfiguration.class, \"dataSource\")\n .withGenerator((registeredBean) -> registeredBean.getBeanFactory().getBean(DataSourceConfiguration.class).dataSource());\n }\n\n /**\n * Get the bean definition for 'dataSource'\n */\n public static BeanDefinition getDataSourceBeanDefinition() {\n Class<?> beanType = SimpleDataSource.class;\n RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);\n beanDefinition.setInstanceSupplier(getDataSourceInstanceSupplier());\n return beanDefinition;\n }\n\t}\n----\n======\n\nNOTE: The exact code generated may differ depending on the exact nature of your bean definitions.\n\nTIP: Each generated class is annotated with `org.springframework.aot.generate.Generated` to\nidentify them if they need to be excluded, for instance by static analysis tools.\n\nThe generated code above creates bean definitions equivalent to the `@Configuration` class, but in a direct way and without the use of reflection at all if possible.\nThere is a bean definition for `dataSourceConfiguration` and one for `dataSourceBean`.\nWhen a `datasource` instance is required, a `BeanInstanceSupplier` is called.\nThis supplier invokes the `dataSource()` method on the `dataSourceConfiguration` bean.\n\n[[aot.running]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Bean Registration AOT Contributions", "heading_level": 3, "file_order": 99, "section_index": 5, "content_hash": "8e69ee9fa46e2208629231f054839e0e3a314f658018fde7ba5ed8fe396719f2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:730e272119440ab9f8f3f8b4f490f476454892befe0833c2b1c947e40d5ef774", "content": "AOT is a mandatory step to transform a Spring application to a native executable, so it\nis automatically enabled when running within a native image. However it is also possible to use AOT optimizations\non the JVM by setting the `spring.aot.enabled` System property to `true`.\n\nNOTE: When AOT optimizations are included, some decisions that have been made at build time\nare hard coded in the application setup. For instance, profiles that have been enabled at\nbuild time are automatically enabled at runtime as well.\n\n[[aot.bestpractices]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Running with AOT Optimizations", "heading_level": 2, "file_order": 99, "section_index": 6, "content_hash": "730e272119440ab9f8f3f8b4f490f476454892befe0833c2b1c947e40d5ef774", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:64d15bec10399407d7da4a1e501d5aec639df4802a5b75d18dab97b732880478", "content": "The AOT engine is designed to handle as many use cases as possible, with no code change in applications.\nHowever, keep in mind that some optimizations are made at build time based on a static definition of the beans.\n\nThis section lists the best practices that make sure your application is ready for AOT.\n\n[[aot.bestpractices.bean-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Best Practices", "heading_level": 2, "file_order": 99, "section_index": 7, "content_hash": "64d15bec10399407d7da4a1e501d5aec639df4802a5b75d18dab97b732880478", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:3d6aafb2e467e91d9e347b371a081a5495e7db5f5cadc93f9b9ac54ca5503ff4", "content": "The AOT engine takes care of the `@Configuration` model and any callback that might be\ninvoked as part of processing your configuration. If you need to register additional\nbeans programmatically, make sure to use a `BeanDefinitionRegistry` to register\nbean definitions.\n\nThis can typically be done via a `BeanDefinitionRegistryPostProcessor`. Note that, if it\nis registered itself as a bean, it will be invoked again at runtime unless you make\nsure to implement `BeanFactoryInitializationAotProcessor` as well. A more idiomatic\nway is to implement `ImportBeanDefinitionRegistrar` and register it using `@Import` on\none of your configuration classes. This invokes your custom code as part of configuration\nclass parsing.\n\nIf you declare additional beans programmatically using a different callback, they are\nlikely not going to be handled by the AOT engine, and therefore no hints are going to be\ngenerated for them. Depending on the environment, those beans may not be registered at\nall. For instance, classpath scanning does not work in a native image as there is no\nnotion of a classpath. For cases like this, it is crucial that the scanning happens at\nbuild time.\n\n[[aot.bestpractices.bean-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Programmatic Bean Registration", "heading_level": 3, "file_order": 99, "section_index": 8, "content_hash": "3d6aafb2e467e91d9e347b371a081a5495e7db5f5cadc93f9b9ac54ca5503ff4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:43ba50ee32e9bd98f5402d8461d838f8347b88fcd09f6077e81098fa66f77540", "content": "While your application may interact with an interface that a bean implements, it is still very important to declare the most precise type.\nThe AOT engine performs additional checks on the bean type, such as detecting the presence of `@Autowired` members or lifecycle callback methods.\n\nFor `@Configuration` classes, make sure that the return type of an `@Bean` factory method is as precise as possible.\nConsider the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration(proxyBeanMethods = false)\n\tpublic class UserConfiguration {\n\n @Bean\n public MyInterface myInterface() {\n return new MyImplementation();\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration(proxyBeanMethods = false)\n\tclass UserConfiguration {\n\n @Bean\n fun myInterface(): MyInterface = MyImplementation()\n\n\t}\n----\n======\n\nIn the example above, the declared type for the `myInterface` bean is `MyInterface`.\nDuring AOT processing, none of the usual post-processing will take `MyImplementation` into account.\nFor instance, if there is an annotated handler method on `MyImplementation` that the context should register, it will not be detected during AOT processing.\n\nThe example above should therefore be rewritten as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration(proxyBeanMethods = false)\n\tpublic class UserConfiguration {\n\n @Bean\n public MyImplementation myInterface() {\n return new MyImplementation();\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration(proxyBeanMethods = false)\n\tclass UserConfiguration {\n\n @Bean\n fun myInterface() = MyImplementation()\n\n\t}\n----\n======\n\nIf you are registering bean definitions programmatically, consider using `RootBeanBefinition` as it allows to specify a `ResolvableType` that handles generics.\n\n[[aot.bestpractices.constructors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Expose the Most Precise Bean Type", "heading_level": 3, "file_order": 99, "section_index": 9, "content_hash": "43ba50ee32e9bd98f5402d8461d838f8347b88fcd09f6077e81098fa66f77540", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:7a650f4dae49834562165932dcfa2b16306a1dbbd0e1edfdbc7149d767ef7344", "content": "The container is able to choose the most appropriate constructor to use based on several candidates.\nHowever, relying on that is not a best practice, and flagging the preferred constructor with `@Autowired` if necessary is preferred.\n\nIn case you are working on a code base that you cannot modify, you can set the {spring-framework-api}/beans/factory/support/AbstractBeanDefinition.html#PREFERRED_CONSTRUCTORS_ATTRIBUTE[`preferredConstructors` attribute] on the related bean definition to indicate which constructor should be used.\n\n[[aot.bestpractices.complex-data-structures]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Avoid Multiple Constructors", "heading_level": 3, "file_order": 99, "section_index": 10, "content_hash": "7a650f4dae49834562165932dcfa2b16306a1dbbd0e1edfdbc7149d767ef7344", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:03844e35767a2165ebee0e298266e94dd32b6bccd8b8420a7d43ebddb432a551", "content": "When crafting a `RootBeanDefinition` programmatically, you are not constrained in terms of types that you can use.\nFor instance, you may have a custom `record` with several properties that your bean takes as a constructor argument.\n\nWhile this works fine with the regular runtime, AOT does not know how to generate the code of your custom data structure.\nA good rule of thumb is to keep in mind that bean definitions are an abstraction on top of several models.\nRather than using such structures, decomposing to simple types or referring to a bean that is built as such is recommended.\n\nAs a last resort, you can implement your own `org.springframework.aot.generate.ValueCodeGenerator$Delegate`.\nTo use it, register its fully-qualified name in `META-INF/spring/aot.factories` using `org.springframework.aot.generate.ValueCodeGenerator$Delegate` as the key.\n\n[[aot.bestpractices.custom-arguments]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Avoid Complex Data Structures for Constructor Parameters and Properties", "heading_level": 3, "file_order": 99, "section_index": 11, "content_hash": "03844e35767a2165ebee0e298266e94dd32b6bccd8b8420a7d43ebddb432a551", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:8a638910de8cbd004e1eec6673311e1634825e546b94840f4fe331b761f63ad5", "content": "Spring AOT detects what needs to be done to create a bean and translates that into generated code that uses an instance supplier.\nThe container also supports creating a bean with {spring-framework-api}++/beans/factory/BeanFactory.html#getBean(java.lang.String,java.lang.Object...)++[custom arguments] which can lead to several issues with AOT:\n\n. The custom arguments require dynamic introspection of a matching constructor or factory method.\nThose arguments cannot be detected by AOT, so the necessary reflection hints will have to be provided manually.\n. By-passing the instance supplier means that all other optimizations after creation are skipped as well.\nFor instance, autowiring on fields and methods will be skipped as they are handled in the instance supplier.\n\nRather than having prototype-scoped beans created with custom arguments, we recommend a manual factory pattern where a bean is responsible for the creation of the instance.\n\n[[aot.bestpractices.circular-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Avoid Creating Beans with Custom Arguments", "heading_level": 3, "file_order": 99, "section_index": 12, "content_hash": "8a638910de8cbd004e1eec6673311e1634825e546b94840f4fe331b761f63ad5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:a774a7a348b47f1ac2ca102a9f6830bd06c81c3624214475c9df53dbb8bc5882", "content": "Certain use cases can result in circular dependencies between one or more beans. With the\nregular runtime, it may be possible to wire those circular dependencies via `@Autowired`\non setter methods or fields. However, an AOT-optimized context will fail to start with\nexplicit circular dependencies.\n\nIn an AOT-optimized application, you should therefore strive to avoid circular\ndependencies. If that is not possible, you can use `@Lazy` injection points or\n`ObjectProvider` to lazily access or retrieve the necessary collaborating beans. See\nxref:core/beans/classpath-scanning.adoc#beans-factorybeans-annotations-lazy-injection-points[this tip]\nfor further information.\n\n[[aot.bestpractices.factory-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Avoid Circular Dependencies", "heading_level": 3, "file_order": 99, "section_index": 13, "content_hash": "a774a7a348b47f1ac2ca102a9f6830bd06c81c3624214475c9df53dbb8bc5882", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:548ba2e15986e41c1078cbb2a7e481626fb348f4587276b18793095c90cc7903", "content": "`FactoryBean` should be used with care as it introduces an intermediate layer in terms of bean type resolution that may not be conceptually necessary.\nAs a rule of thumb, if a `FactoryBean` instance does not hold long-term state and is not needed at a later point at runtime, it should be replaced by a regular `@Bean` factory method, possibly with a `FactoryBean` adapter layer on top (for declarative configuration purposes).\n\nIf your `FactoryBean` implementation does not resolve the object type (i.e. `T`), extra care is necessary.\nConsider the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ClientFactoryBean<T extends AbstractClient> implements FactoryBean<T> {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ClientFactoryBean<T : AbstractClient> : FactoryBean<T> {\n // ...\n\t}\n----\n======\n\nA concrete client declaration should provide a resolved generic for the client, as shown in the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration(proxyBeanMethods = false)\n\tpublic class UserConfiguration {\n\n @Bean\n public ClientFactoryBean<MyClient> myClient() {\n return new ClientFactoryBean<>(...);\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration(proxyBeanMethods = false)\n\tclass UserConfiguration {\n\n @Bean\n fun myClient() = ClientFactoryBean<MyClient>(...)\n\n\t}\n----\n======\n\nIf a `FactoryBean` bean definition is registered programmatically, make sure to follow these steps:\n\n1. Use `RootBeanDefinition`.\n2. Set the `beanClass` to the `FactoryBean` class so that AOT knows that it is an intermediate layer.\n3. Set the `ResolvableType` to a resolved generic, which makes sure the most precise type is exposed.\n\nThe following example showcases a basic definition:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRootBeanDefinition beanDefinition = new RootBeanDefinition(ClientFactoryBean.class);\n\tbeanDefinition.setTargetType(ResolvableType.forClassWithGenerics(ClientFactoryBean.class, MyClient.class));\n\t// ...\n\tregistry.registerBeanDefinition(\"myClient\", beanDefinition);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval beanDefinition = RootBeanDefinition(ClientFactoryBean::class.java)\n\tbeanDefinition.setTargetType(ResolvableType.forClassWithGenerics(ClientFactoryBean::class.java, MyClient::class.java));\n\t// ...\n\tregistry.registerBeanDefinition(\"myClient\", beanDefinition)\n----\n======\n\n[[aot.bestpractices.jpa]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "FactoryBean", "heading_level": 3, "file_order": 99, "section_index": 14, "content_hash": "548ba2e15986e41c1078cbb2a7e481626fb348f4587276b18793095c90cc7903", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:476184b831a2a777a4f7fd308ce092376362d142a0c1b5375ec5a2bd8be656e0", "content": "The JPA persistence unit has to be known upfront for certain optimizations to apply. Consider the following basic example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tLocalContainerEntityManagerFactoryBean customDBEntityManagerFactory(DataSource dataSource) {\n LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();\n factoryBean.setDataSource(dataSource);\n factoryBean.setPackagesToScan(\"com.example.app\");\n return factoryBean;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tfun customDBEntityManagerFactory(dataSource: DataSource): LocalContainerEntityManagerFactoryBean {\n val factoryBean = LocalContainerEntityManagerFactoryBean()\n factoryBean.dataSource = dataSource\n factoryBean.setPackagesToScan(\"com.example.app\")\n return factoryBean\n\t}\n----\n======\n\nTo ensure that entity scanning occurs ahead of time, a `PersistenceManagedTypes` bean must be declared and used by the\nfactory bean definition, as shown by the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tPersistenceManagedTypes persistenceManagedTypes(ResourceLoader resourceLoader) {\n return new PersistenceManagedTypesScanner(resourceLoader)\n .scan(\"com.example.app\");\n\t}\n\n\t@Bean\n\tLocalContainerEntityManagerFactoryBean customDBEntityManagerFactory(DataSource dataSource, PersistenceManagedTypes managedTypes) {\n LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();\n factoryBean.setDataSource(dataSource);\n factoryBean.setManagedTypes(managedTypes);\n return factoryBean;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tfun persistenceManagedTypes(resourceLoader: ResourceLoader): PersistenceManagedTypes {\n return PersistenceManagedTypesScanner(resourceLoader)\n .scan(\"com.example.app\")\n\t}\n\n\t@Bean\n\tfun customDBEntityManagerFactory(dataSource: DataSource, managedTypes: PersistenceManagedTypes): LocalContainerEntityManagerFactoryBean {\n val factoryBean = LocalContainerEntityManagerFactoryBean()\n factoryBean.dataSource = dataSource\n factoryBean.setManagedTypes(managedTypes)\n return factoryBean\n\t}\n----\n======\n\n[[aot.hints]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "JPA", "heading_level": 3, "file_order": 99, "section_index": 15, "content_hash": "476184b831a2a777a4f7fd308ce092376362d142a0c1b5375ec5a2bd8be656e0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:22561bf99060e259687b83c42e3a52de3fdf057a989d39dd83967f26eb234323", "content": "Running an application as a native image requires additional information compared to a regular JVM runtime.\nFor instance, GraalVM needs to know ahead of time if a component uses reflection.\nSimilarly, classpath resources are not included in a native image unless specified explicitly.\nConsequently, if the application needs to load a resource, it must be referenced from the corresponding GraalVM native image configuration file.\n\nThe {spring-framework-api}/aot/hint/RuntimeHints.html[`RuntimeHints`] API collects the need for reflection, resource loading, serialization, and JDK proxies at runtime.\nThe following example makes sure that `config/app.properties` can be loaded from the classpath at runtime within a native image:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\truntimeHints.resources().registerPattern(\"config/app.properties\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\truntimeHints.resources().registerPattern(\"config/app.properties\")\n----\n======\n\nA number of contracts are handled automatically during AOT processing.\nFor instance, the return type of a `@Controller` method is inspected, and relevant reflection hints are added if Spring detects that the type should be serialized (typically to JSON).\n\nFor cases that the core container cannot infer, you can register such hints programmatically.\nA number of convenient annotations are also provided for common use cases.\n\n[[aot.hints.import-runtime-hints]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Runtime Hints", "heading_level": 2, "file_order": 99, "section_index": 16, "content_hash": "22561bf99060e259687b83c42e3a52de3fdf057a989d39dd83967f26eb234323", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:c66920526cb469a046c57539d16c6e2502da7d8718d43044402b1686be439ca5", "content": "{spring-framework-api}/aot/hint/RuntimeHintsRegistrar.html[`RuntimeHintsRegistrar`]\nimplementations allow you to get a callback to the `RuntimeHints` instance managed by the\nAOT engine. Implementations of this interface can be registered using\n{spring-framework-api}/context/annotation/ImportRuntimeHints.html[`@ImportRuntimeHints`]\non any Spring bean or `@Bean` factory method. `RuntimeHintsRegistrar` implementations are\ndetected and invoked at build time.\n\ninclude-code::./SpellCheckService[]\n\nIf at all possible, `@ImportRuntimeHints` should be used as close as possible to the component that requires the hints.\nThis way, if the component is not contributed to the `BeanFactory`, the hints will not be contributed either.\n\nIt is also possible to register an implementation statically by adding an entry in `META-INF/spring/aot.factories` with a key equal to the fully-qualified name of the `RuntimeHintsRegistrar` interface.\n\n[[aot.hints.reflective]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "`@ImportRuntimeHints`", "heading_level": 3, "file_order": 99, "section_index": 17, "content_hash": "c66920526cb469a046c57539d16c6e2502da7d8718d43044402b1686be439ca5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:8185aa2388d99678b9eb4d9e24eaee0c397110d03eb00b03e3835553d8b867ec", "content": "{spring-framework-api}/aot/hint/annotation/Reflective.html[`@Reflective`] provides an idiomatic way to flag the need for reflection on an annotated element.\nFor instance, `@EventListener` is meta-annotated with `@Reflective` since the underlying implementation invokes the annotated method using reflection.\n\nOut-of-the-box, only Spring beans are considered, but you can opt-in for scanning using\n{spring-framework-api}/context/annotation/ReflectiveScan.html[`@ReflectiveScan`]. In the\nexample below, all types in the `com.example.app` package and its subpackages are\nconsidered:\n\ninclude-code::./MyConfiguration[]\n\nScanning happens during AOT processing, and the types in the target packages do not need to have a class-level annotation to be considered.\nThis performs a _deep scan_, and the presence of `@Reflective`, either directly or as a meta-annotation, is checked on types, fields, constructors, methods, and enclosed elements.\n\nBy default, `@Reflective` registers an invocation hint for the annotated element.\nThis can be tuned by specifying a custom `ReflectiveProcessor` implementation via the `@Reflective` annotation.\n\nLibrary authors can reuse this annotation for their own purposes.\nAn example of such customization is covered in the next section.\n\n[[aot.hints.register-reflection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "`@Reflective`", "heading_level": 3, "file_order": 99, "section_index": 18, "content_hash": "8185aa2388d99678b9eb4d9e24eaee0c397110d03eb00b03e3835553d8b867ec", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:48029e00072ab5579634988412cdc722a96ba25417a6440e7a471d97e76bc4bf", "content": "{spring-framework-api}/aot/hint/annotation/RegisterReflection.html[`@RegisterReflection`] is a specialization of `@Reflective` that provides a declarative way to register reflection for arbitrary types.\n\nNOTE: As a specialization of `@Reflective`, `@RegisterReflection` is also detected if you are using `@ReflectiveScan`.\n\nIn the following example, public constructors and public methods can be invoked via reflection on `AccountService`:\n\ninclude-code::./MyConfiguration[tag=snippet,indent=0]\n\n`@RegisterReflection` can be applied to any target type at the class level, but it can also be applied directly to a method to better indicate where the hints are actually required.\n\n`@RegisterReflection` can be used as a meta-annotation to support more specific needs.\n{spring-framework-api}/aot/hint/annotation/RegisterReflectionForBinding.html[`@RegisterReflectionForBinding`] is a composed annotation that is meta-annotated with `@RegisterReflection` and registers the need for serializing arbitrary types.\nA typical use case is the use of DTOs that the container cannot infer, such as using a web client within a method body.\n\nThe following example registers `Order` for serialization.\n\ninclude-code::./OrderService[tag=snippet,indent=0]\n\nThis registers hints for constructors, fields, properties, and record components of `Order`.\nHints are also registered for types transitively used on properties and record components.\nIn other words, if `Order` exposes others types, hints are registered for those as well.\n\n[[aot.hints.convention-based-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "`@RegisterReflection`", "heading_level": 3, "file_order": 99, "section_index": 19, "content_hash": "48029e00072ab5579634988412cdc722a96ba25417a6440e7a471d97e76bc4bf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:2570e5e77cd3f3c25aca1f7763feb4815a67ab34898472386e1010164e6922ab", "content": "Although the core container provides built-in support for automatic conversion of many\ncommon types (see xref:core/validation/convert.adoc[Spring Type Conversion]), some\nconversions are supported via a convention-based algorithm that relies on reflection.\n\nSpecifically, if there is no explicit `Converter` registered with the `ConversionService`\nfor a particular source &#8594; target type pair, the internal `ObjectToObjectConverter`\nwill attempt to use conventions to convert a source object to a target type by delegating\nto a method on the source object or to a static factory method or constructor on the\ntarget type. Since this convention-based algorithm can be applied to arbitrary types at\nruntime, the core container is not able to infer the runtime hints necessary to support\nsuch reflection.\n\nIf you encounter convention-based conversion issues within a native image resulting from\nlacking runtime hints, you can register the necessary hints programmatically. For\nexample, if your application requires a conversion from `java.time.Instant` to\n`java.sql.Timestamp` and relies on `ObjectToObjectConverter` to invoke\n`java.sql.Timestamp.from(Instant)` using reflection, you could implement a custom\n`RuntimeHintsRegitrar` to support this use case within a native image, as demonstrated in\nthe following example.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\npublic class TimestampConversionRuntimeHints implements RuntimeHintsRegistrar {\n\n\tpublic void registerHints(RuntimeHints hints, ClassLoader classLoader) {\n ReflectionHints reflectionHints = hints.reflection();\n\n reflectionHints.registerTypeIfPresent(classLoader, \"java.sql.Timestamp\", hint -> hint\n .withMethod(\"from\", List.of(TypeReference.of(Instant.class)), ExecutableMode.INVOKE)\n .onReachableType(TypeReference.of(\"java.sql.Timestamp\")));\n\t}\n}\n----\n======\n\n`TimestampConversionRuntimeHints` can then be registered declaratively via\n<<aot.hints.import-runtime-hints>> or statically via a `META-INF/spring/aot.factories`\nconfiguration file.\n\n[NOTE]\n====\nThe above `TimestampConversionRuntimeHints` class is a simplified version of the\n`ObjectToObjectConverterRuntimeHints` class that is included in the framework and\nregistered by default.\n\nThus, this specific `Instant`-to-`Timestamp` use case is already handled by the framework.\n====\n\n[[aot.hints.testing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Runtime Hints for Convention-based Conversion", "heading_level": 3, "file_order": 99, "section_index": 20, "content_hash": "2570e5e77cd3f3c25aca1f7763feb4815a67ab34898472386e1010164e6922ab", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:c569fd8c569a781632be7b0fd66aaedad5c8f052860c7a688f69bb83e32f65bd", "content": "Spring Core also ships `RuntimeHintsPredicates`, a utility for checking that existing hints match a particular use case.\nThis can be used in your own tests to validate that a `RuntimeHintsRegistrar` produces the expected results.\nWe can write a test for our `SpellCheckService` and ensure that we will be able to load a dictionary at runtime:\n\ninclude-code::./SpellCheckServiceTests[tag=hintspredicates]\n\nWith `RuntimeHintsPredicates`, we can check for reflection, resource, serialization, or proxy generation hints.\nThis approach works well for unit tests but implies that the runtime behavior of a component is well known.\n\nYou can learn more about the global runtime behavior of an application by running its test suite (or the app itself) with the {graalvm-docs}/native-image/metadata/AutomaticMetadataCollection/[GraalVM tracing agent].\nThis agent will record all relevant calls requiring GraalVM hints at runtime and write them out as JSON configuration files.\n\nFor more targeted discovery and testing, Spring Framework ships a dedicated module with core AOT testing utilities, `\"org.springframework:spring-core-test\"`.\nThis module contains the RuntimeHints Agent, a Java agent that records all method invocations that are related to runtime hints and helps you to assert that a given `RuntimeHints` instance covers all recorded invocations.\nLet's consider a piece of infrastructure for which we'd like to test the hints we're contributing during the AOT processing phase.\n\ninclude-code::./SampleReflection[]\n\nWe can then write a unit test (no native compilation required) that checks our contributed hints:\n\ninclude-code::./SampleReflectionRuntimeHintsTests[]\n\nIf you forgot to contribute a hint, the test will fail and provide some details about the invocation:\n\n[source,txt,indent=0,subs=\"verbatim,quotes\"]\n----\norg.springframework.docs.core.aot.hints.testing.SampleReflection performReflection\nINFO: Spring version: 6.2.0\n\nMissing <\"ReflectionHints\"> for invocation <java.lang.Class#forName>\nwith arguments [\"org.springframework.core.SpringVersion\",\n false,\n jdk.internal.loader.ClassLoaders$AppClassLoader@251a69d7].\nStacktrace:\n<\"org.springframework.util.ClassUtils#forName, Line 284\nio.spring.runtimehintstesting.SampleReflection#performReflection, Line 19\nio.spring.runtimehintstesting.SampleReflectionRuntimeHintsTests#lambda$shouldRegisterReflectionHints$0, Line 25\n----\n\nThere are various ways to configure this Java agent in your build, so please refer to the documentation of your build tool and test execution plugin.\nThe agent itself can be configured to instrument specific packages (by default, only `org.springframework` is instrumented).\nYou'll find more details in the {spring-framework-code}/buildSrc/README.md[Spring Framework `buildSrc` README] file.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/aot.adoc", "title": "aot", "heading": "Testing Runtime Hints", "heading_level": 3, "file_order": 99, "section_index": 21, "content_hash": "c569fd8c569a781632be7b0fd66aaedad5c8f052860c7a688f69bb83e32f65bd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/aot.adoc"}}
{"id": "sha256:f2f0de3beb70184c6643e56aa938408baf19f5023b1d38690fda1356828b2645", "content": "[[appendix]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/appendix.adoc", "title": "appendix", "heading": "appendix", "heading_level": 1, "file_order": 100, "section_index": 0, "content_hash": "f2f0de3beb70184c6643e56aa938408baf19f5023b1d38690fda1356828b2645", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/appendix.adoc"}}
{"id": "sha256:524ed9e961c2f97b917d29a5c963d45b1756ab259e69088944845bae33507291", "content": "[[beans]]\n\nThis chapter covers Spring's Inversion of Control (IoC) container.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/beans.adoc", "title": "beans", "heading": "beans", "heading_level": 1, "file_order": 101, "section_index": 0, "content_hash": "524ed9e961c2f97b917d29a5c963d45b1756ab259e69088944845bae33507291", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/beans.adoc"}}
{"id": "sha256:6f2323b9cbcf920f4cfe670b6a8ce8f5d19f2c94abc346782c26e5c85967b24d", "content": "[[databuffers]]\n\nJava NIO provides `ByteBuffer` but many libraries build their own byte buffer API on top,\nespecially for network operations where reusing buffers and/or using direct buffers is\nbeneficial for performance. For example Netty has the `ByteBuf` hierarchy,\nJetty uses pooled byte buffers with a callback to be released, and so on.\nThe `spring-core` module provides a set of abstractions to work with various byte buffer\nAPIs as follows:\n\n* xref:core/databuffer-codec.adoc#databuffers-factory[`DataBufferFactory`] abstracts the creation of a data buffer.\n* xref:core/databuffer-codec.adoc#databuffers-buffer[`DataBuffer`] represents a byte buffer, which may be\nxref:core/databuffer-codec.adoc#databuffers-buffer-pooled[pooled].\n* xref:core/databuffer-codec.adoc#databuffers-utils[`DataBufferUtils`] offers utility methods for data buffers.\n* <<Codecs>> decode or encode data buffer streams into higher level objects.\n\n[[databuffers-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc", "title": "databuffer-codec", "heading": "databuffer-codec", "heading_level": 1, "file_order": 102, "section_index": 0, "content_hash": "6f2323b9cbcf920f4cfe670b6a8ce8f5d19f2c94abc346782c26e5c85967b24d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc"}}
{"id": "sha256:945ad2f91bd4c913534577675e1a7c382957826068feec23038dbdf11cff14e7", "content": "`DataBufferFactory` is used to create data buffers in one of two ways:\n\n. Allocate a new data buffer, optionally specifying capacity upfront, if known, which is\nmore efficient even though implementations of `DataBuffer` can grow and shrink on demand.\n. Wrap an existing `byte[]` or `java.nio.ByteBuffer`, which decorates the given data with\na `DataBuffer` implementation and that does not involve allocation.\n\nNote that WebFlux applications do not create a `DataBufferFactory` directly but instead\naccess it through the `ServerHttpResponse` or the `ClientHttpRequest` on the client side.\nThe type of factory depends on the underlying client or server, for example,\n`NettyDataBufferFactory` for Reactor Netty, `DefaultDataBufferFactory` for others.\n\n[[databuffers-buffer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc", "title": "databuffer-codec", "heading": "`DataBufferFactory`", "heading_level": 2, "file_order": 102, "section_index": 1, "content_hash": "945ad2f91bd4c913534577675e1a7c382957826068feec23038dbdf11cff14e7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc"}}
{"id": "sha256:31370ad5e38c8d2cd4ba939d9229c8889ba6ecf5aff297bc9d2b7a716337bb59", "content": "The `DataBuffer` interface offers similar operations as `java.nio.ByteBuffer` but also\nbrings a few additional benefits some of which are inspired by the Netty `ByteBuf`.\nBelow is a partial list of benefits:\n\n* Read and write with independent positions, i.e. not requiring a call to `flip()` to\nalternate between read and write.\n* Capacity expanded on demand as with `java.lang.StringBuilder`.\n* Pooled buffers and reference counting via xref:core/databuffer-codec.adoc#databuffers-buffer-pooled[`PooledDataBuffer`].\n* View a buffer as `java.nio.ByteBuffer`, `InputStream`, or `OutputStream`.\n* Determine the index, or the last index, for a given byte.\n\n[[databuffers-buffer-pooled]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc", "title": "databuffer-codec", "heading": "`DataBuffer`", "heading_level": 2, "file_order": 102, "section_index": 2, "content_hash": "31370ad5e38c8d2cd4ba939d9229c8889ba6ecf5aff297bc9d2b7a716337bb59", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc"}}
{"id": "sha256:4f7b2f1b775c716b7ddb1b80fc8fad6c6ce54394cf653fa314406b71bbbe1f72", "content": "As explained in the Javadoc for\n{java-api}/java.base/java/nio/ByteBuffer.html[ByteBuffer],\nbyte buffers can be direct or non-direct. Direct buffers may reside outside the Java heap\nwhich eliminates the need for copying for native I/O operations. That makes direct buffers\nparticularly useful for receiving and sending data over a socket, but they're also more\nexpensive to create and release, which leads to the idea of pooling buffers.\n\n`PooledDataBuffer` is an extension of `DataBuffer` that helps with reference counting which\nis essential for byte buffer pooling. How does it work? When a `PooledDataBuffer` is\nallocated the reference count is at 1. Calls to `retain()` increment the count, while\ncalls to `release()` decrement it. As long as the count is above 0, the buffer is\nguaranteed not to be released. When the count is decreased to 0, the pooled buffer can be\nreleased, which in practice could mean the reserved memory for the buffer is returned to\nthe memory pool.\n\nNote that instead of operating on `PooledDataBuffer` directly, in most cases it's better\nto use the convenience methods in `DataBufferUtils` that apply release or retain to a\n`DataBuffer` only if it is an instance of `PooledDataBuffer`.\n\n[[databuffers-utils]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc", "title": "databuffer-codec", "heading": "`PooledDataBuffer`", "heading_level": 2, "file_order": 102, "section_index": 3, "content_hash": "4f7b2f1b775c716b7ddb1b80fc8fad6c6ce54394cf653fa314406b71bbbe1f72", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc"}}
{"id": "sha256:9f85344e8f06165085f1257f2e6b25b93a5d6f509aeb660d9d7551edf0fda26f", "content": "`DataBufferUtils` offers a number of utility methods to operate on data buffers:\n\n* Join a stream of data buffers into a single buffer possibly with zero copy, for example, via\ncomposite buffers, if that's supported by the underlying byte buffer API.\n* Turn `InputStream` or NIO `Channel` into `Flux<DataBuffer>`, and vice versa a\n`Publisher<DataBuffer>` into `OutputStream` or NIO `Channel`.\n* Methods to release or retain a `DataBuffer` if the buffer is an instance of\n`PooledDataBuffer`.\n* Skip or take from a stream of bytes until a specific byte count.\n\n[[codecs]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc", "title": "databuffer-codec", "heading": "`DataBufferUtils`", "heading_level": 2, "file_order": 102, "section_index": 4, "content_hash": "9f85344e8f06165085f1257f2e6b25b93a5d6f509aeb660d9d7551edf0fda26f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc"}}
{"id": "sha256:546d89a845401b5a779f9ec66e406f0535f2cef466f1d6a87b8bebbf0ca49815", "content": "The `org.springframework.core.codec` package provides the following strategy interfaces:\n\n* `Encoder` to encode `Publisher<T>` into a stream of data buffers.\n* `Decoder` to decode `Publisher<DataBuffer>` into a stream of higher level objects.\n\nThe `spring-core` module provides `byte[]`, `ByteBuffer`, `DataBuffer`, `Resource`, and\n`String` encoder and decoder implementations. The `spring-web` module adds Jackson JSON,\nJackson Smile, JAXB2, Protocol Buffers and other encoders and decoders. See\nxref:web/webflux/reactive-spring.adoc#webflux-codecs[Codecs] in the WebFlux section.\n\n[[databuffers-using]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc", "title": "databuffer-codec", "heading": "Codecs", "heading_level": 2, "file_order": 102, "section_index": 5, "content_hash": "546d89a845401b5a779f9ec66e406f0535f2cef466f1d6a87b8bebbf0ca49815", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc"}}
{"id": "sha256:3e2fc00c0178cfa1ae55f3bca8cbd19f42a7d9e20256e0756ec8aca3e07e04c8", "content": "When working with data buffers, special care must be taken to ensure buffers are released\nsince they may be xref:core/databuffer-codec.adoc#databuffers-buffer-pooled[pooled]. We'll use codecs to illustrate\nhow that works but the concepts apply more generally. Let's see what codecs must do\ninternally to manage data buffers.\n\nA `Decoder` is the last to read input data buffers, before creating higher level\nobjects, and therefore it must release them as follows:\n\n. If a `Decoder` simply reads each input buffer and is ready to\nrelease it immediately, it can do so via `DataBufferUtils.release(dataBuffer)`.\n. If a `Decoder` is using `Flux` or `Mono` operators such as `flatMap`, `reduce`, and\nothers that prefetch and cache data items internally, or is using operators such as\n`filter`, `skip`, and others that leave out items, then\n`doOnDiscard(DataBuffer.class, DataBufferUtils::release)` must be added to the\ncomposition chain to ensure such buffers are released prior to being discarded, possibly\nalso as a result of an error or cancellation signal.\n. If a `Decoder` holds on to one or more data buffers in any other way, it must\nensure they are released when fully read, or in case of an error or cancellation signals that\ntake place before the cached data buffers have been read and released.\n\nNote that `DataBufferUtils#join` offers a safe and efficient way to aggregate a data\nbuffer stream into a single data buffer. Likewise `skipUntilByteCount` and\n`takeUntilByteCount` are additional safe methods for decoders to use.\n\nAn `Encoder` allocates data buffers that others must read (and release). So an `Encoder`\ndoesn't have much to do. However an `Encoder` must take care to release a data buffer if\na serialization error occurs while populating the buffer with data. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tDataBuffer buffer = factory.allocateBuffer();\n\tboolean release = true;\n\ttry {\n // serialize and populate buffer..\n release = false;\n\t}\n\tfinally {\n if (release) {\n DataBufferUtils.release(buffer);\n }\n\t}\n\treturn buffer;\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval buffer = factory.allocateBuffer()\n\tvar release = true\n\ttry {\n // serialize and populate buffer..\n release = false\n\t} finally {\n if (release) {\n DataBufferUtils.release(buffer)\n }\n\t}\n\treturn buffer\n----\n======\n\nThe consumer of an `Encoder` is responsible for releasing the data buffers it receives.\nIn a WebFlux application, the output of the `Encoder` is used to write to the HTTP server\nresponse, or to the client HTTP request, in which case releasing the data buffers is the\nresponsibility of the code writing to the server response, or to the client request.\n\nNote that when running on Netty, there are debugging options for\nhttps://github.com/netty/netty/wiki/Reference-counted-objects#troubleshooting-buffer-leaks[troubleshooting buffer leaks].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc", "title": "databuffer-codec", "heading": "Using `DataBuffer`", "heading_level": 2, "file_order": 102, "section_index": 6, "content_hash": "3e2fc00c0178cfa1ae55f3bca8cbd19f42a7d9e20256e0756ec8aca3e07e04c8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/databuffer-codec.adoc"}}
{"id": "sha256:eec5ebacea021d5646ec2ace7bd130b8884d106654415684bc2727bab68ffb22", "content": "[[expressions]]\n\nThe Spring Expression Language (\"SpEL\" for short) is a powerful expression language that\nsupports querying and manipulating an object graph at runtime. The language syntax is\nsimilar to the https://jakarta.ee/specifications/expression-language/[Jakarta Expression\nLanguage] but offers additional features, most notably method invocation and basic string\ntemplating functionality.\n\nWhile there are several other Java expression languages available -- OGNL, MVEL, and\nJBoss EL, to name a few -- the Spring Expression Language was created to provide the\nSpring community with a single well supported expression language that can be used across\nall the products in the Spring portfolio. Its language features are driven by the\nrequirements of the projects in the Spring portfolio, including tooling requirements for\ncode completion within the {spring-site-tools}[Spring Tools] IDE support. That said, SpEL\nis based on a technology-agnostic API that lets other expression language implementations\nbe integrated, should the need arise.\n\nWhile SpEL serves as the foundation for expression evaluation within the Spring\nportfolio, it is not directly tied to Spring and can be used independently. To\nbe self contained, many of the examples in this chapter use SpEL as if it were an\nindependent expression language. This requires creating a few bootstrapping\ninfrastructure classes, such as the parser. Most Spring users need not deal with\nthis infrastructure and can, instead, author only expression strings for evaluation.\nAn example of this typical use is the integration of SpEL into creating XML or\nannotation-based bean definitions, as shown in\nxref:core/expressions/beandef.adoc[Expression support for defining bean definitions].\n\nThis chapter covers the features of the expression language, its API, and its language\nsyntax. In several places, `Inventor` and `Society` classes are used as the target\nobjects for expression evaluation. These class declarations and the data used to\npopulate them are listed at the end of the chapter.\n\nThe expression language supports the following functionality:\n\n* Literal expressions\n* Accessing properties, arrays, lists, and maps\n* Inline lists\n* Inline maps\n* Array construction\n* Relational operators\n* Regular expressions\n* Logical operators\n* String operators\n* Mathematical operators\n* Assignment\n* Type expressions\n* Method invocation\n* Constructor invocation\n* Variables\n* User-defined functions\n* Bean references\n* Ternary, Elvis, and safe-navigation operators\n* Collection projection\n* Collection selection\n* Templated expressions", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/expressions.adoc", "title": "expressions", "heading": "expressions", "heading_level": 1, "file_order": 103, "section_index": 0, "content_hash": "eec5ebacea021d5646ec2ace7bd130b8884d106654415684bc2727bab68ffb22", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/expressions.adoc"}}
{"id": "sha256:9c1c298cdf997e597f2a936536bfefaad3b53a72ccde98ef2ae24ca63f64e602", "content": "[[null-safety]]\n\nAlthough Java does not let you express nullness markers with its type system yet, the Spring Framework codebase is\nannotated with https://jspecify.dev/docs/start-here/[JSpecify] annotations to declare the nullability of its APIs,\nfields, and related type usages. Reading the https://jspecify.dev/docs/user-guide/[JSpecify user guide] is highly\nrecommended in order to get familiar with those annotations and semantics.\n\nThe primary goal of this null-safety arrangement is to prevent a `NullPointerException` from being thrown at\nruntime via build time checks and to use explicit nullability as a way to express the possible absence of value.\nIt is useful in Java by leveraging nullability checkers such as https://github.com/uber/NullAway[NullAway] or IDEs\nsupporting JSpecify annotations such as IntelliJ IDEA and Eclipse (the latter requiring manual configuration). In Kotlin,\nJSpecify annotations are automatically translated to {kotlin-docs}/null-safety.html[Kotlin's null safety].\n\nThe {spring-framework-api}/core/Nullness.html[`Nullness` Spring API] can be used at runtime to detect the\nnullness of a type usage, a field, a method return type, or a parameter. It provides full support for\nJSpecify annotations, Kotlin null safety, and Java primitive types, as well as a pragmatic check on any\n`@Nullable` annotation (regardless of the package).\n\n[[null-safety-libraries]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/null-safety.adoc", "title": "null-safety", "heading": "null-safety", "heading_level": 1, "file_order": 104, "section_index": 0, "content_hash": "9c1c298cdf997e597f2a936536bfefaad3b53a72ccde98ef2ae24ca63f64e602", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/null-safety.adoc"}}
{"id": "sha256:3f0f580191132a6df6c4f7ec62e1bcd0646084f4aa846d1bbdbe1c9259a70133", "content": "As of Spring Framework 7, the Spring Framework codebase leverages JSpecify annotations to expose null-safe APIs\nand to check the consistency of those nullability declarations with https://github.com/uber/NullAway[NullAway]\nas part of its build. It is recommended for each library depending on Spring Framework and Spring portfolio projects,\nas well as other libraries related to the Spring ecosystem (Reactor, Micrometer, and Spring community projects),\nto do the same.\n\n[[null-safety-applications]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/null-safety.adoc", "title": "null-safety", "heading": "Annotating libraries with JSpecify annotations", "heading_level": 2, "file_order": 104, "section_index": 1, "content_hash": "3f0f580191132a6df6c4f7ec62e1bcd0646084f4aa846d1bbdbe1c9259a70133", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/null-safety.adoc"}}
{"id": "sha256:2b03fa4f51efa3bcb29c948da8bb8dfea42eb36076e9031eeabc29c57b193baf", "content": "Developing applications with IDEs that support nullness annotations will provide warnings in Java and errors in\nKotlin when the nullability contracts are not honored, allowing Spring application developers to refine their\nnull handling to prevent a `NullPointerException` from being thrown at runtime.\n\nOptionally, Spring application developers can annotate their codebase and use build plugins like\nhttps://github.com/uber/NullAway[NullAway] to enforce null-safety at the application level during build time.\n\n[[null-safety-guidelines]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/null-safety.adoc", "title": "null-safety", "heading": "Leveraging JSpecify annotations in Spring applications", "heading_level": 2, "file_order": 104, "section_index": 2, "content_hash": "2b03fa4f51efa3bcb29c948da8bb8dfea42eb36076e9031eeabc29c57b193baf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/null-safety.adoc"}}
{"id": "sha256:0b010df42c1a9bdb7029e430f325bacd16cbaf05d6ae31ac8199a58ef54cbbf0", "content": "The purpose of this section is to share some proposed guidelines for explicitly specifying the nullability of\nSpring-related libraries or applications.\n\n[[null-safety-guidelines-jspecify]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/null-safety.adoc", "title": "null-safety", "heading": "Guidelines", "heading_level": 2, "file_order": 104, "section_index": 3, "content_hash": "0b010df42c1a9bdb7029e430f325bacd16cbaf05d6ae31ac8199a58ef54cbbf0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/null-safety.adoc"}}
{"id": "sha256:f33ab6e5abffda0674c8bb9812432f0e15635ba407a9851d53d2023c7d31883e", "content": "A key point to understand is that the nullness of types is unknown by default in Java and that non-null type usage\nis by far more frequent than nullable usage. In order to keep codebases readable, we typically want to define by\ndefault that type usage is non-null unless marked as nullable for a specific scope. This is exactly the purpose\nof https://jspecify.dev/docs/api/org/jspecify/annotations/NullMarked.html[`@NullMarked`] which is typically set\nin Spring projects at the package level via a `package-info.java` file, for example:\n\n[source,java,subs=\"verbatim,quotes\",chomp=\"-packages\",fold=\"none\"]\n----\n@NullMarked\npackage org.springframework.core;\n\nimport org.jspecify.annotations.NullMarked;\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/null-safety.adoc", "title": "null-safety", "heading": "Defaults to non-null", "heading_level": 4, "file_order": 104, "section_index": 4, "content_hash": "f33ab6e5abffda0674c8bb9812432f0e15635ba407a9851d53d2023c7d31883e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/null-safety.adoc"}}
{"id": "sha256:4993e3d858323d122d51227f7b2370a20f154a45bfb15e4f5557476eaef789f1", "content": "In `@NullMarked` code, nullable type usage is defined explicitly with\nhttps://jspecify.dev/docs/api/org/jspecify/annotations/Nullable.html[`@Nullable`].\n\nA key difference between JSpecify `@Nullable` / `@NonNull` annotations and most other variants is that the JSpecify\nannotations are meta-annotated with `@Target(ElementType.TYPE_USE)`, so they apply only to type usage. This impacts\nwhere such annotations should be placed, either to comply with\nhttps://docs.oracle.com/javase/specs/jls/se17/html/jls-9.html#jls-9.7.4[related Java specifications] or to follow code\nstyle best practices. From a style perspective, it is recommended to embrace the type-use nature of those annotations\nby placing them on the same line as and immediately preceding the annotated type.\n\nFor example, for a field:\n\n[source,java,subs=\"verbatim,quotes\"]\n----\nprivate @Nullable String fileEncoding;\n----\n\nOr for method parameters and method return types:\n\n[source,java,subs=\"verbatim,quotes\"]\n----\npublic @Nullable String buildMessage(@Nullable String message,\n @Nullable Throwable cause) {\n // ...\n}\n----\n\n[NOTE]\n====\nWhen overriding a method, JSpecify annotations are not inherited from the original\nmethod. That means the JSpecify annotations should be copied to the overriding method if\nyou want to override the implementation and keep the same nullability semantics.\n====\n\nhttps://jspecify.dev/docs/api/org/jspecify/annotations/NonNull.html[`@NonNull`] and\nhttps://jspecify.dev/docs/api/org/jspecify/annotations/NullUnmarked.html[`@NullUnmarked`] should rarely be needed for\ntypical use cases.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/null-safety.adoc", "title": "null-safety", "heading": "Explicit nullability", "heading_level": 4, "file_order": 104, "section_index": 5, "content_hash": "4993e3d858323d122d51227f7b2370a20f154a45bfb15e4f5557476eaef789f1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/null-safety.adoc"}}
{"id": "sha256:15a84592f4729363a926507efdd3f247589a40417fea7f1be681b163d04f3a7e", "content": "With arrays and varargs, you need to be able to differentiate the nullness of the elements from the nullness of\nthe array itself. Pay attention to the syntax\nhttps://docs.oracle.com/javase/specs/jls/se17/html/jls-9.html#jls-9.7.4[defined by the Java specification] which may be\ninitially surprising. For example, in `@NullMarked` code:\n\n- `@Nullable Object[] array` means individual elements can be `null` but the array itself cannot.\n- `Object @Nullable [] array` means individual elements cannot be `null` but the array itself can.\n- `@Nullable Object @Nullable [] array` means both individual elements and the array can be `null`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/null-safety.adoc", "title": "null-safety", "heading": "Arrays and varargs", "heading_level": 4, "file_order": 104, "section_index": 6, "content_hash": "15a84592f4729363a926507efdd3f247589a40417fea7f1be681b163d04f3a7e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/null-safety.adoc"}}
{"id": "sha256:d87ecb78afb406ca1d3feef99ba42c802c2a9ee5229d3bcfc37f6f380fe621a9", "content": "JSpecify annotations apply to generics as well. For example, in `@NullMarked` code:\n\n - `List<String>` means a list of non-null elements (equivalent of `List<@NonNull String>`)\n - `List<@Nullable String>` means a list of nullable elements\n\nThings are a bit more complicated when you are declaring generic types or generic methods. See the related\nhttps://jspecify.dev/docs/user-guide/#generics[JSpecify generics documentation] for more details.\n\nWARNING: The nullability of generic types and generic methods\nhttps://github.com/uber/NullAway/issues?q=is%3Aissue+is%3Aopen+label%3Ajspecify[is not yet fully supported by NullAway].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/null-safety.adoc", "title": "null-safety", "heading": "Generics", "heading_level": 4, "file_order": 104, "section_index": 7, "content_hash": "d87ecb78afb406ca1d3feef99ba42c802c2a9ee5229d3bcfc37f6f380fe621a9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/null-safety.adoc"}}
{"id": "sha256:dadfaa60ec31dd334425a8d9f487851c63bfbf8a23e5dfb99ac58df2d58a556e", "content": "The Java specification also enforces that annotations defined with `@Target(ElementType.TYPE_USE)` â€“ like JSpecify's\n`@Nullable` annotation â€“ must be declared after the last dot (`.`) within inner or fully qualified type names:\n\n- `Cache.@Nullable ValueWrapper`\n- `jakarta.validation.@Nullable Validator`\n\n[[null-safety-guidelines-nullaway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/null-safety.adoc", "title": "null-safety", "heading": "Nested and fully qualified types", "heading_level": 4, "file_order": 104, "section_index": 8, "content_hash": "dadfaa60ec31dd334425a8d9f487851c63bfbf8a23e5dfb99ac58df2d58a556e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/null-safety.adoc"}}
{"id": "sha256:30103f9bffbe87de3e4dfdf8495341565dc8cb7f35cfb74ca3109774d1412c11", "content": "The recommended configuration is:\n\n - `NullAway:OnlyNullMarked=true` in order to perform nullability checks only for packages annotated with `@NullMarked`.\n - `NullAway:CustomContractAnnotations=org.springframework.lang.Contract` which makes NullAway aware of the\n{spring-framework-api}/lang/Contract.html[@Contract] annotation in the `org.springframework.lang` package which\ncan be used to express complementary semantics to avoid irrelevant warnings in your codebase.\n\nA good example of the benefits of a `@Contract` declaration can be seen with\n{spring-framework-api}/util/Assert.html#notNull(java.lang.Object,java.lang.String)[`Assert.notNull()`]\nwhich is annotated with `@Contract(\"null, _ -> fail\")`. With that contract declaration, NullAway will understand\nthat the value passed as a parameter cannot be null after a successful invocation of `Assert.notNull()`.\n\nOptionally, it is possible to set `NullAway:JSpecifyMode=true` to enable\nhttps://github.com/uber/NullAway/wiki/JSpecify-Support[checks on the full JSpecify semantics], including annotations on\narrays, varargs, and generics. Be aware that this mode is\nhttps://github.com/uber/NullAway/issues?q=is%3Aissue+is%3Aopen+label%3Ajspecify[still under development] and requires\nJDK 22 or later (typically combined with the `--release` Java compiler flag to configure the\nexpected baseline). It is recommended to enable the JSpecify mode only as a second step, after making sure the codebase\ngenerates no warning with the recommended configuration mentioned previously in this section.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/null-safety.adoc", "title": "null-safety", "heading": "Configuration", "heading_level": 4, "file_order": 104, "section_index": 9, "content_hash": "30103f9bffbe87de3e4dfdf8495341565dc8cb7f35cfb74ca3109774d1412c11", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/null-safety.adoc"}}
{"id": "sha256:181000e5701dccfe8a89934100fff2b6912db22dda836b1fb72703b42f251f10", "content": "There are a few valid use cases where NullAway will incorrectly detect nullability problems. In such cases,\nit is recommended to suppress related warnings and to document the reason:\n\n - `@SuppressWarnings(\"NullAway.Init\")` at field, constructor, or class level can be used to avoid unnecessary warnings\ndue to the lazy initialization of fields â€“ for example, due to a class implementing\n{spring-framework-api}/beans/factory/InitializingBean.html[`InitializingBean`].\n - `@SuppressWarnings(\"NullAway\") // Dataflow analysis limitation` can be used when NullAway dataflow analysis is not\nable to detect that the path involving a nullability problem will never happen.\n - `@SuppressWarnings(\"NullAway\") // Lambda` can be used when NullAway does not take into account assertions performed\noutside of a lambda for the code path within the lambda.\n- `@SuppressWarnings(\"NullAway\") // Reflection` can be used for some reflection operations that are known to return\nnon-null values even if that cannot be expressed by the API.\n- `@SuppressWarnings(\"NullAway\") // Well-known map keys` can be used when `Map#get` invocations are performed with keys\nthat are known to be present and when non-null related values have been inserted previously.\n- `@SuppressWarnings(\"NullAway\") // Overridden method does not define nullability` can be used when the superclass does\nnot define nullability (typically when the superclass comes from an external dependency).\n- `@SuppressWarnings(\"NullAway\") // See https://github.com/uber/NullAway/issues/1075` can be used when NullAway is not able to detect type variable nullness in generic methods.\n\n[[null-safety-migrating]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/null-safety.adoc", "title": "null-safety", "heading": "Warnings suppression", "heading_level": 4, "file_order": 104, "section_index": 10, "content_hash": "181000e5701dccfe8a89934100fff2b6912db22dda836b1fb72703b42f251f10", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/null-safety.adoc"}}
{"id": "sha256:08c0c0d7a910f994ccc43ab8d5bab24771fc775fc8468f6888b1142b4e77ac50", "content": "Spring null-safety annotations {spring-framework-api}/lang/Nullable.html[`@Nullable`],\n{spring-framework-api}/lang/NonNull.html[`@NonNull`],\n{spring-framework-api}/lang/NonNullApi.html[`@NonNullApi`], and\n{spring-framework-api}/lang/NonNullFields.html[`@NonNullFields`] in the `org.springframework.lang` package were\nintroduced in Spring Framework 5 when JSpecify did not exist, and the best option at that time was to leverage\nmeta-annotations from JSR 305 (a dormant but widespread JSR). They are deprecated as of Spring Framework 7 in favor of\nhttps://jspecify.dev/docs/start-here/[JSpecify] annotations, which provide significant enhancements such as properly\ndefined specifications, a canonical dependency with no split-package issues, better tooling, better Kotlin integration,\nand the capability to specify nullability more precisely for more use cases.\n\nA key difference is that Spring's deprecated null-safety annotations, which follow JSR 305 semantics, apply to fields,\nparameters, and return values; while JSpecify annotations apply to type usage. This subtle difference\nis pretty significant in practice, since it allows developers to differentiate between the nullness of elements and the\nnullness of arrays/varargs as well as to define the nullness of generic types.\n\nThat means array and varargs null-safety declarations have to be updated to keep the same semantics. For example\n`@Nullable Object[] array` with Spring annotations needs to be changed to `Object @Nullable [] array` with JSpecify\nannotations. The same applies to varargs.\n\nIt is also recommended to move field and return value annotations closer to the type and on the same line, for example:\n\n - For fields, instead of `@Nullable private String field` with Spring annotations, use `private @Nullable String field`\nwith JSpecify annotations.\n- For method return types, instead of `@Nullable public String method()` with Spring annotations, use\n`public @Nullable String method()` with JSpecify annotations.\n\nAlso, with JSpecify, you do not need to specify `@NonNull` when overriding a type usage annotated with `@Nullable`\nin the super method to \"undo\" the nullable declaration in null-marked code. Just declare it unannotated, and the\nnull-marked defaults will apply (type usage is considered non-null unless explicitly annotated as nullable).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/null-safety.adoc", "title": "null-safety", "heading": "Migrating from Spring null-safety annotations", "heading_level": 2, "file_order": 104, "section_index": 11, "content_hash": "08c0c0d7a910f994ccc43ab8d5bab24771fc775fc8468f6888b1142b4e77ac50", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/null-safety.adoc"}}
{"id": "sha256:a254d6b2241a04caab9142cc637839eab2d925e6a7b3e060d8e4b47bf67c30d8", "content": "[[resilience]]\n\nAs of 7.0, the core Spring Framework includes common resilience features, in particular\n<<resilience-annotations-retryable>> and <<resilience-annotations-concurrencylimit>>\nannotations for method invocations as well as <<resilience-programmatic-retry,\nprogrammatic retry support>>.\n\n[[resilience-annotations-retryable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resilience.adoc", "title": "resilience", "heading": "resilience", "heading_level": 1, "file_order": 105, "section_index": 0, "content_hash": "a254d6b2241a04caab9142cc637839eab2d925e6a7b3e060d8e4b47bf67c30d8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resilience.adoc"}}
{"id": "sha256:236109148c0bcd7b8f252cf76c6695edcac22a44e76f631553bb962d3286f0d8", "content": "{spring-framework-api}/resilience/annotation/Retryable.html[`@Retryable`] is an annotation\nthat specifies retry characteristics for an individual method (with the annotation\ndeclared at the method level), or for all proxy-invoked methods in a given class hierarchy\n(with the annotation declared at the type level).\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n@Retryable\npublic void sendNotification() {\n this.jmsClient.destination(\"notifications\").send(...);\n}\n----\n\nBy default, the method invocation will be retried for any exception thrown: with at most\n3 retry attempts (`maxRetries = 3`) after an initial failure, and a delay of 1 second\nbetween attempts.\n\n[NOTE]\n====\nA `@Retryable` method will be invoked at least once and retried at most `maxRetries`\ntimes, where `maxRetries` is the maximum number of retry attempts. Specifically,\n`total attempts = 1 initial attempt + maxRetries attempts`.\n\nFor example, if `maxRetries` is set to `4`, the `@Retryable` method will be invoked at\nleast once and at most 5 times.\n====\n\nThis can be specifically adapted for every method if necessary â€” for example, by narrowing\nthe exceptions to retry via the `includes` and `excludes` attributes. The supplied\nexception types will be matched against an exception thrown by a failed invocation as well\nas nested causes.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n@Retryable(MessageDeliveryException.class)\npublic void sendNotification() {\n this.jmsClient.destination(\"notifications\").send(...);\n}\n----\n\nNOTE: `@Retryable(MessageDeliveryException.class)` is a shortcut for\n`@Retryable(includes{nbsp}={nbsp}MessageDeliveryException.class)`.\n\n[TIP]\n====\nFor advanced use cases, you can specify a custom `MethodRetryPredicate` via the\n`predicate` attribute in `@Retryable`, and the predicate will be used to determine whether\nto retry a failed method invocation based on a `Method` and a given `Throwable` â€“ for\nexample, by checking the message of the `Throwable`.\n\nCustom predicates can be combined with `includes` and `excludes`; however, custom\npredicates will always be applied after `includes` and `excludes` have been applied.\n====\n\nOr for 4 retry attempts and an exponential back-off strategy with a bit of jitter:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n@Retryable(\n includes = MessageDeliveryException.class,\n maxRetries = 4,\n delay = 100,\n jitter = 10,\n multiplier = 2,\n maxDelay = 1000)\npublic void sendNotification() {\n this.jmsClient.destination(\"notifications\").send(...);\n}\n----\n\nLast but not least, `@Retryable` also works for reactive methods with a reactive return\ntype, decorating the pipeline with Reactor's retry capabilities:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n@Retryable(maxRetries = 4, delay = 100)\npublic Mono<Void> sendNotification() {\n return Mono.from(...); // <1>\n}\n----\n<1> This raw `Mono` will get decorated with a retry spec.\n\nFor details on the various characteristics, see the available annotation attributes in\n{spring-framework-api}/resilience/annotation/Retryable.html[`@Retryable`].\n\nTIP: Several attributes in `@Retryable` have `String` variants that provide property\nplaceholder and SpEL support, as an alternative to the specifically typed annotation\nattributes used in the above examples.\n\n[[resilience-annotations-concurrencylimit]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resilience.adoc", "title": "resilience", "heading": "`@Retryable`", "heading_level": 2, "file_order": 105, "section_index": 1, "content_hash": "236109148c0bcd7b8f252cf76c6695edcac22a44e76f631553bb962d3286f0d8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resilience.adoc"}}
{"id": "sha256:431002d3e6cfb39b2c8187df204fd6a917f7e3ec47a44895d48b19ea1961ff26", "content": "{spring-framework-api}/resilience/annotation/ConcurrencyLimit.html[`@ConcurrencyLimit`] is\nan annotation that specifies a concurrency limit for an individual method (with the\nannotation declared at the method level), or for all proxy-invoked methods in a given\nclass hierarchy (with the annotation declared at the type level).\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n@ConcurrencyLimit(10)\npublic void sendNotification() {\n this.jmsClient.destination(\"notifications\").send(...);\n}\n----\n\nThis is meant to protect the target resource from being accessed from too many threads at\nthe same time, similar to the effect of a pool size limit for a thread pool or a\nconnection pool that blocks access if its limit is reached.\n\nYou may optionally set the limit to `1`, effectively locking access to the target bean\ninstance:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n@ConcurrencyLimit(1)\npublic void sendNotification() {\n this.jmsClient.destination(\"notifications\").send(...);\n}\n----\n\nSuch limiting is particularly useful with Virtual Threads where there is generally no\nthread pool limit in place. For asynchronous tasks, this can be constrained on\n{spring-framework-api}/core/task/SimpleAsyncTaskExecutor.html[`SimpleAsyncTaskExecutor`].\nFor synchronous invocations, this annotation provides equivalent behavior through\n{spring-framework-api}/aop/interceptor/ConcurrencyThrottleInterceptor.html[`ConcurrencyThrottleInterceptor`]\nwhich has been available since Spring Framework 1.0 for programmatic use with the AOP\nframework.\n\nTIP: `@ConcurrencyLimit` also has a `limitString` attribute that provides property\nplaceholder and SpEL support, as an alternative to the `int` based examples above.\n\n[[resilience-annotations-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resilience.adoc", "title": "resilience", "heading": "`@ConcurrencyLimit`", "heading_level": 2, "file_order": 105, "section_index": 2, "content_hash": "431002d3e6cfb39b2c8187df204fd6a917f7e3ec47a44895d48b19ea1961ff26", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resilience.adoc"}}
{"id": "sha256:899467b73f9d92baa03201ab10994636843ba5c230749084df277b9876e5524d", "content": "Like many of Spring's core annotation-based features, `@Retryable` and `@ConcurrencyLimit`\nare designed as metadata that you can choose to honor or ignore. The most convenient way\nto enable processing of the resilience annotations is to declare\n{spring-framework-api}/resilience/annotation/EnableResilientMethods.html[`@EnableResilientMethods`]\non a corresponding `@Configuration` class.\n\nAlternatively, these annotations can be individually enabled by defining a\n`RetryAnnotationBeanPostProcessor` or a `ConcurrencyLimitBeanPostProcessor` bean in the\ncontext.\n\n[[resilience-programmatic-retry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resilience.adoc", "title": "resilience", "heading": "Enabling Resilient Methods", "heading_level": 2, "file_order": 105, "section_index": 3, "content_hash": "899467b73f9d92baa03201ab10994636843ba5c230749084df277b9876e5524d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resilience.adoc"}}
{"id": "sha256:409c1aa96206d1ab8d60bb1b4b261d3cc4e9a6f703d060a96a939b10684e6c67", "content": "In contrast to <<resilience-annotations-retryable>> which provides a declarative approach\nfor specifying retry semantics for methods within beans registered in the\n`ApplicationContext`,\n{spring-framework-api}/core/retry/RetryTemplate.html[`RetryTemplate`] provides a\nprogrammatic API for retrying arbitrary blocks of code.\n\nSpecifically, a `RetryTemplate` executes and potentially retries a\n{spring-framework-api}/core/retry/Retryable.html[`Retryable`] operation based on a\nconfigured {spring-framework-api}/core/retry/RetryPolicy.html[`RetryPolicy`].\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n var retryTemplate = new RetryTemplate(); // <1>\n\n retryTemplate.execute(\n () -> jmsClient.destination(\"notifications\").send(...));\n----\n<1> Implicitly uses `RetryPolicy.withDefaults()`.\n\nBy default, a retryable operation will be retried for any exception thrown: with at most\n3 retry attempts (`maxRetries = 3`) after an initial failure, and a delay of 1 second\nbetween attempts.\n\nIf you only need to customize the number of retry attempts, you can use the\n`RetryPolicy.withMaxRetries()` factory method as demonstrated below.\n\n[NOTE]\n====\nA retryable operation will be executed at least once and retried at most `maxRetries`\ntimes, where `maxRetries` is the maximum number of retry attempts. Specifically,\n`total attempts = 1 initial attempt + maxRetries attempts`.\n\nFor example, if `maxRetries` is set to `4`, the retryable operation will be invoked at\nleast once and at most 5 times.\n====\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n var retryTemplate = new RetryTemplate(RetryPolicy.withMaxRetries(4)); // <1>\n\n retryTemplate.execute(\n () -> jmsClient.destination(\"notifications\").send(...));\n----\n<1> Explicitly uses `RetryPolicy.withMaxRetries(4)`.\n\nIf you need to narrow the types of exceptions to retry, that can be achieved via the\n`includes()` and `excludes()` builder methods. The supplied exception types will be\nmatched against an exception thrown by a failed operation as well as nested causes.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n var retryPolicy = RetryPolicy.builder()\n .includes(MessageDeliveryException.class) // <1>\n .excludes(...) // <2>\n .build();\n\n var retryTemplate = new RetryTemplate(retryPolicy);\n\n retryTemplate.execute(\n () -> jmsClient.destination(\"notifications\").send(...));\n----\n<1> Specify one or more exception types to include.\n<2> Specify one or more exception types to exclude.\n\n[TIP]\n====\nFor advanced use cases, you can specify a custom `Predicate<Throwable>` via the\n`predicate()` method in the `RetryPolicy.Builder`, and the predicate will be used to\ndetermine whether to retry a failed operation based on a given `Throwable` â€“ for example,\nby checking the message of the `Throwable`.\n\nCustom predicates can be combined with `includes` and `excludes`; however, custom\npredicates will always be applied after `includes` and `excludes` have been applied.\n====\n\nThe following example demonstrates how to configure a `RetryPolicy` with 4 retry attempts\nand an exponential back-off strategy with a bit of jitter.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n var retryPolicy = RetryPolicy.builder()\n .includes(MessageDeliveryException.class)\n .maxRetries(4)\n .delay(Duration.ofMillis(100))\n .jitter(Duration.ofMillis(10))\n .multiplier(2)\n .maxDelay(Duration.ofSeconds(1))\n .build();\n\n var retryTemplate = new RetryTemplate(retryPolicy);\n\n retryTemplate.execute(\n () -> jmsClient.destination(\"notifications\").send(...));\n----\n\n[TIP]\n====\nA {spring-framework-api}/core/retry/RetryListener.html[`RetryListener`] can be registered\nwith a `RetryTemplate` to react to events published during key retry phases (before a\nretry attempt, after a retry attempt, etc.), and you can compose multiple listeners via a\n{spring-framework-api}/core/retry/support/CompositeRetryListener.html[`CompositeRetryListener`].\n====\n\nAlthough the factory methods and builder API for `RetryPolicy` cover most common\nconfiguration scenarios, you can implement a custom `RetryPolicy` for complete control\nover the types of exceptions that should trigger a retry as well as the\n{spring-framework-api}/util/backoff/BackOff.html[`BackOff`] strategy to use. Note that you\ncan also configure a customized `BackOff` strategy via the `backOff()` method in the\n`RetryPolicy.Builder`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resilience.adoc", "title": "resilience", "heading": "Programmatic Retry Support", "heading_level": 2, "file_order": 105, "section_index": 4, "content_hash": "409c1aa96206d1ab8d60bb1b4b261d3cc4e9a6f703d060a96a939b10684e6c67", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resilience.adoc"}}
{"id": "sha256:8c8de99c1f7798d6274d39ec362f10f651fce9b9119c5c46378f3f02d1214667", "content": "[[resources]]\n\nThis chapter covers how Spring handles resources and how you can work with resources in\nSpring. It includes the following topics:\n\n* xref:core/resources.adoc#resources-introduction[Introduction]\n* xref:core/resources.adoc#resources-resource[The `Resource` Interface]\n* xref:core/resources.adoc#resources-implementations[Built-in `Resource` Implementations]\n* xref:core/resources.adoc#resources-resourceloader[The `ResourceLoader` Interface]\n* xref:core/resources.adoc#resources-resourcepatternresolver[The `ResourcePatternResolver` Interface]\n* xref:core/resources.adoc#resources-resourceloaderaware[The `ResourceLoaderAware` Interface]\n* xref:core/resources.adoc#resources-as-dependencies[Resources as Dependencies]\n* xref:core/resources.adoc#resources-app-ctx[Application Contexts and Resource Paths]\n\n[[resources-introduction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "resources", "heading_level": 1, "file_order": 106, "section_index": 0, "content_hash": "8c8de99c1f7798d6274d39ec362f10f651fce9b9119c5c46378f3f02d1214667", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:862c750056ec392ab516055ac672bfdbee1e9f3a5861826b87f8b70f4027a1c7", "content": "Java's standard `java.net.URL` class and standard handlers for various URL prefixes,\nunfortunately, are not quite adequate enough for all access to low-level resources. For\nexample, there is no standardized `URL` implementation that may be used to access a\nresource that needs to be obtained from the classpath or relative to a\n`ServletContext`. While it is possible to register new handlers for specialized `URL`\nprefixes (similar to existing handlers for prefixes such as `http:`), this is generally\nquite complicated, and the `URL` interface still lacks some desirable functionality,\nsuch as a method to check for the existence of the resource being pointed to.\n\n[[resources-resource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "Introduction", "heading_level": 2, "file_order": 106, "section_index": 1, "content_hash": "862c750056ec392ab516055ac672bfdbee1e9f3a5861826b87f8b70f4027a1c7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:1dcd9a09b9608f4e660ca9e6dd39729091bed7aa66a2a617eddaab5305654f94", "content": "Spring's `Resource` interface located in the `org.springframework.core.io.` package is\nmeant to be a more capable interface for abstracting access to low-level resources. The\nfollowing listing provides an overview of the `Resource` interface. See the\n{spring-framework-api}/core/io/Resource.html[`Resource`] javadoc for further details.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface Resource extends InputStreamSource {\n\n boolean exists();\n\n boolean isReadable();\n\n boolean isOpen();\n\n boolean isFile();\n\n URL getURL() throws IOException;\n\n URI getURI() throws IOException;\n\n File getFile() throws IOException;\n\n ReadableByteChannel readableChannel() throws IOException;\n\n long contentLength() throws IOException;\n\n long lastModified() throws IOException;\n\n Resource createRelative(String relativePath) throws IOException;\n\n String getFilename();\n\n String getDescription();\n\t}\n----\n\nAs the definition of the `Resource` interface shows, it extends the `InputStreamSource`\ninterface. The following listing shows the definition of the `InputStreamSource`\ninterface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface InputStreamSource {\n\n InputStream getInputStream() throws IOException;\n\t}\n----\n\nSome of the most important methods from the `Resource` interface are:\n\n* `getInputStream()`: Locates and opens the resource, returning an `InputStream` for\n reading from the resource. It is expected that each invocation returns a fresh\n `InputStream`. It is the responsibility of the caller to close the stream.\n* `exists()`: Returns a `boolean` indicating whether this resource actually exists in\n physical form.\n* `isOpen()`: Returns a `boolean` indicating whether this resource represents a handle\n with an open stream. If `true`, the `InputStream` cannot be read multiple times and\n must be read once only and then closed to avoid resource leaks. Returns `false` for\n all usual resource implementations, with the exception of `InputStreamResource`.\n* `getDescription()`: Returns a description for this resource, to be used for error\n output when working with the resource. This is often the fully qualified file name or\n the actual URL of the resource.\n\nOther methods let you obtain an actual `URL` or `File` object representing the\nresource (if the underlying implementation is compatible and supports that\nfunctionality).\n\nSome implementations of the `Resource` interface also implement the extended\n{spring-framework-api}/core/io/WritableResource.html[`WritableResource`] interface\nfor a resource that supports writing to it.\n\nSpring itself uses the `Resource` abstraction extensively, as an argument type in\nmany method signatures when a resource is needed. Other methods in some Spring APIs\n(such as the constructors to various `ApplicationContext` implementations) take a\n`String` which in unadorned or simple form is used to create a `Resource` appropriate to\nthat context implementation or, via special prefixes on the `String` path, let the\ncaller specify that a specific `Resource` implementation must be created and used.\n\nWhile the `Resource` interface is used a lot with Spring and by Spring, it is actually\nvery convenient to use as a general utility class by itself in your own code, for access\nto resources, even when your code does not know or care about any other parts of Spring.\nWhile this couples your code to Spring, it really only couples it to this small set of\nutility classes, which serves as a more capable replacement for `URL` and can be\nconsidered equivalent to any other library you would use for this purpose.\n\nNOTE: The `Resource` abstraction does not replace functionality. It wraps it where possible.\nFor example, a `UrlResource` wraps a URL and uses the wrapped `URL` to do its work.\n\n[[resources-implementations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "The `Resource` Interface", "heading_level": 2, "file_order": 106, "section_index": 2, "content_hash": "1dcd9a09b9608f4e660ca9e6dd39729091bed7aa66a2a617eddaab5305654f94", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:b63ac69c610b3edde6ed995ff5207ce980464dbd5aad6c39dc97cdaf37483c0c", "content": "Spring includes several built-in `Resource` implementations:\n\n* xref:core/resources.adoc#resources-implementations-urlresource[`UrlResource`]\n* xref:core/resources.adoc#resources-implementations-classpathresource[`ClassPathResource`]\n* xref:core/resources.adoc#resources-implementations-filesystemresource[`FileSystemResource`]\n* xref:core/resources.adoc#resources-implementations-pathresource[`PathResource`]\n* xref:core/resources.adoc#resources-implementations-servletcontextresource[`ServletContextResource`]\n* xref:core/resources.adoc#resources-implementations-inputstreamresource[`InputStreamResource`]\n* xref:core/resources.adoc#resources-implementations-bytearrayresource[`ByteArrayResource`]\n\nFor a complete list of `Resource` implementations available in Spring, consult the\n\"All Known Implementing Classes\" section of the\n{spring-framework-api}/core/io/Resource.html[`Resource`] javadoc.\n\n[[resources-implementations-urlresource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "Built-in `Resource` Implementations", "heading_level": 2, "file_order": 106, "section_index": 3, "content_hash": "b63ac69c610b3edde6ed995ff5207ce980464dbd5aad6c39dc97cdaf37483c0c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:6d785fe99ca1d73a9456700aff6a3e1fc72ce82c56a2892d4c8d3050189b005e", "content": "`UrlResource` wraps a `java.net.URL` and can be used to access any object that is\nnormally accessible with a URL, such as files, an HTTPS target, an FTP target, and\nothers. All URLs have a standardized `String` representation, such that appropriate\nstandardized prefixes are used to indicate one URL type from another. This includes\n`file:` for accessing filesystem paths, `https:` for accessing resources through the\nHTTPS protocol, `ftp:` for accessing resources through FTP, and others.\n\nA `UrlResource` is created by Java code by explicitly using the `UrlResource` constructor\nbut is often created implicitly when you call an API method that takes a `String`\nargument meant to represent a path. For the latter case, a JavaBeans `PropertyEditor`\nultimately decides which type of `Resource` to create. If the path string contains a\nwell-known (to property editor, that is) prefix (such as `classpath:`), it creates an\nappropriate specialized `Resource` for that prefix. However, if it does not recognize the\nprefix, it assumes the string is a standard URL string and creates a `UrlResource`.\n\n[[resources-implementations-classpathresource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "`UrlResource`", "heading_level": 3, "file_order": 106, "section_index": 4, "content_hash": "6d785fe99ca1d73a9456700aff6a3e1fc72ce82c56a2892d4c8d3050189b005e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:4cbdb449813be26f7ef30cc0ee13a5e65bfccb45b1a83890cca1ce29611964a7", "content": "This class represents a resource that should be obtained from the classpath. It uses\neither the thread context class loader, a given class loader, or a given class for\nloading resources.\n\nThis `Resource` implementation supports resolution as a `java.io.File` if the class path\nresource resides in the file system but not for classpath resources that reside in a\njar and have not been expanded (by the servlet engine or whatever the environment is)\nto the filesystem. To address this, the various `Resource` implementations always support\nresolution as a `java.net.URL`.\n\nA `ClassPathResource` is created by Java code by explicitly using the `ClassPathResource`\nconstructor but is often created implicitly when you call an API method that takes a\n`String` argument meant to represent a path. For the latter case, a JavaBeans\n`PropertyEditor` recognizes the special prefix, `classpath:`, on the string path and\ncreates a `ClassPathResource` in that case.\n\n[[resources-implementations-filesystemresource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "`ClassPathResource`", "heading_level": 3, "file_order": 106, "section_index": 5, "content_hash": "4cbdb449813be26f7ef30cc0ee13a5e65bfccb45b1a83890cca1ce29611964a7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:dfeee14d82d989c67cc517ed28ce5328cfa4ace2c8977b18f3fff4740059a2be", "content": "This is a `Resource` implementation for `java.io.File` handles. It also supports\n`java.nio.file.Path` handles, applying Spring's standard String-based path\ntransformations but performing all operations via the `java.nio.file.Files` API. For pure\n`java.nio.path.Path` based support use a `PathResource` instead. `FileSystemResource`\nsupports resolution as a `File` and as a `URL`.\n\n[[resources-implementations-pathresource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "`FileSystemResource`", "heading_level": 3, "file_order": 106, "section_index": 6, "content_hash": "dfeee14d82d989c67cc517ed28ce5328cfa4ace2c8977b18f3fff4740059a2be", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:2eddf4db4fcb55ad9c6c85b9f28817dad85999f050ad957092f9301f3b82efa0", "content": "This is a `Resource` implementation for `java.nio.file.Path` handles, performing all\noperations and transformations via the `Path` API. It supports resolution as a `File` and\nas a `URL` and also implements the extended `WritableResource` interface. `PathResource`\nis effectively a pure `java.nio.path.Path` based alternative to `FileSystemResource` with\ndifferent `createRelative` behavior.\n\n[[resources-implementations-servletcontextresource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "`PathResource`", "heading_level": 3, "file_order": 106, "section_index": 7, "content_hash": "2eddf4db4fcb55ad9c6c85b9f28817dad85999f050ad957092f9301f3b82efa0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:dce26b938843d850b6ecdb353071a241e70717c4520e7ba0a04f016f53025bb2", "content": "This is a `Resource` implementation for `ServletContext` resources that interprets\nrelative paths within the relevant web application's root directory.\n\nIt always supports stream access and URL access but allows `java.io.File` access only\nwhen the web application archive is expanded and the resource is physically on the\nfilesystem. Whether or not it is expanded and on the filesystem or accessed\ndirectly from the JAR or somewhere else like a database (which is conceivable) is actually\ndependent on the Servlet container.\n\n[[resources-implementations-inputstreamresource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "`ServletContextResource`", "heading_level": 3, "file_order": 106, "section_index": 8, "content_hash": "dce26b938843d850b6ecdb353071a241e70717c4520e7ba0a04f016f53025bb2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:74769a2cdcfe7b0caf1ab2de7702931fb4bf0817a251279ff7689c064129bb01", "content": "An `InputStreamResource` is a `Resource` implementation for a given `InputStream`. It\nshould be used only if no specific `Resource` implementation is applicable. In\nparticular, prefer `ByteArrayResource` or any of the file-based `Resource`\nimplementations where possible.\n\nIn contrast to other `Resource` implementations, this is a descriptor for an\nalready-opened resource. Therefore, it returns `true` from `isOpen()`. Do not use it if\nyou need to keep the resource descriptor somewhere or if you need to read a stream\nmultiple times.\n\n[[resources-implementations-bytearrayresource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "`InputStreamResource`", "heading_level": 3, "file_order": 106, "section_index": 9, "content_hash": "74769a2cdcfe7b0caf1ab2de7702931fb4bf0817a251279ff7689c064129bb01", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:d5eed76bbe5db3978c5ca4550f5e5fafcb145c83058bd4804d523383c041aa23", "content": "This is a `Resource` implementation for a given byte array. It creates a\n`ByteArrayInputStream` for the given byte array.\n\nIt is useful for loading content from any given byte array without having to resort to a\nsingle-use `InputStreamResource`.\n\n[[resources-resourceloader]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "`ByteArrayResource`", "heading_level": 3, "file_order": 106, "section_index": 10, "content_hash": "d5eed76bbe5db3978c5ca4550f5e5fafcb145c83058bd4804d523383c041aa23", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:e9bc43fb66bd57ff73443dcca75975b277777c071f6e56558ed7f3c56f25f103", "content": "The `ResourceLoader` interface is meant to be implemented by objects that can return\n(that is, load) `Resource` instances. The following listing shows the `ResourceLoader`\ninterface definition:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface ResourceLoader {\n\n Resource getResource(String location);\n\n ClassLoader getClassLoader();\n\t}\n----\n\nAll application contexts implement the `ResourceLoader` interface. Therefore, all\napplication contexts may be used to obtain `Resource` instances.\n\nWhen you call `getResource()` on a specific application context, and the location path\nspecified doesn't have a specific prefix, you get back a `Resource` type that is\nappropriate to that particular application context. For example, assume the following\nsnippet of code was run against a `ClassPathXmlApplicationContext` instance:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tResource template = ctx.getResource(\"some/resource/path/myTemplate.txt\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval template = ctx.getResource(\"some/resource/path/myTemplate.txt\")\n----\n======\n\nAgainst a `ClassPathXmlApplicationContext`, that code returns a `ClassPathResource`. If\nthe same method were run against a `FileSystemXmlApplicationContext` instance, it would\nreturn a `FileSystemResource`. For a `WebApplicationContext`, it would return a\n`ServletContextResource`. It would similarly return appropriate objects for each context.\n\nAs a result, you can load resources in a fashion appropriate to the particular application\ncontext.\n\nOn the other hand, you may also force `ClassPathResource` to be used, regardless of the\napplication context type, by specifying the special `classpath:` prefix, as the following\nexample shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tResource template = ctx.getResource(\"classpath:some/resource/path/myTemplate.txt\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval template = ctx.getResource(\"classpath:some/resource/path/myTemplate.txt\")\n----\n======\n\nSimilarly, you can force a `UrlResource` to be used by specifying any of the standard\n`java.net.URL` prefixes. The following examples use the `file` and `https` prefixes:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tResource template = ctx.getResource(\"file:///some/resource/path/myTemplate.txt\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval template = ctx.getResource(\"file:///some/resource/path/myTemplate.txt\")\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tResource template = ctx.getResource(\"https://myhost.com/resource/path/myTemplate.txt\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval template = ctx.getResource(\"https://myhost.com/resource/path/myTemplate.txt\")\n----\n======\n\nThe following table summarizes the strategy for converting `String` objects to `Resource`\nobjects:\n\n[[resources-resource-strings]]\n.Resource strings\n|===\n| Prefix| Example| Explanation\n\n| classpath:\n| `classpath:com/myapp/config.xml`\n| Loaded from the classpath.\n\n| file:\n| `\\file:///data/config.xml`\n| Loaded as a `URL` from the filesystem. See also xref:core/resources.adoc#resources-filesystemresource-caveats[`FileSystemResource` Caveats].\n\n| https:\n| `\\https://myserver/logo.png`\n| Loaded as a `URL`.\n\n| (none)\n| `/data/config.xml`\n| Depends on the underlying `ApplicationContext`.\n|===\n\n[[resources-resourcepatternresolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "The `ResourceLoader` Interface", "heading_level": 2, "file_order": 106, "section_index": 11, "content_hash": "e9bc43fb66bd57ff73443dcca75975b277777c071f6e56558ed7f3c56f25f103", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:8becee6854d0919f001da52aad0b4c3e3003e6dd19337e1d7b8ad4cc7ff25cec", "content": "The `ResourcePatternResolver` interface is an extension to the `ResourceLoader` interface\nwhich defines a strategy for resolving a location pattern (for example, an Ant-style path\npattern) into `Resource` objects.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface ResourcePatternResolver extends ResourceLoader {\n\n String CLASSPATH_ALL_URL_PREFIX = \"classpath*:\";\n\n Resource[] getResources(String locationPattern) throws IOException;\n\t}\n----\n\nAs can be seen above, this interface also defines a special `classpath*:` resource prefix\nfor all matching resources from the class path. Note that the resource location is\nexpected to be a path without placeholders in this case -- for example,\n`classpath*:/config/beans.xml`. JAR files or different directories in the class path can\ncontain multiple files with the same path and the same name. See\nxref:core/resources.adoc#resources-app-ctx-wildcards-in-resource-paths[Wildcards in Application Context Constructor Resource Paths] and its subsections for further details\non wildcard support with the `classpath*:` resource prefix.\n\nA passed-in `ResourceLoader` (for example, one supplied via\nxref:core/resources.adoc#resources-resourceloaderaware[`ResourceLoaderAware`] semantics) can be checked whether\nit implements this extended interface too.\n\n`PathMatchingResourcePatternResolver` is a standalone implementation that is usable\noutside an `ApplicationContext` and is also used by `ResourceArrayPropertyEditor` for\npopulating `Resource[]` bean properties. `PathMatchingResourcePatternResolver` is able to\nresolve a specified resource location path into one or more matching `Resource` objects.\nThe source path may be a simple path which has a one-to-one mapping to a target\n`Resource`, or alternatively may contain the special `classpath*:` prefix and/or internal\nAnt-style regular expressions (matched using Spring's\n`org.springframework.util.AntPathMatcher` utility). Both of the latter are effectively\nwildcards.\n\n[NOTE]\n====\nThe default `ResourceLoader` in any standard `ApplicationContext` is in fact an instance\nof `PathMatchingResourcePatternResolver` which implements the `ResourcePatternResolver`\ninterface. The same is true for the `ApplicationContext` instance itself which also\nimplements the `ResourcePatternResolver` interface and delegates to the default\n`PathMatchingResourcePatternResolver`.\n====\n\n[[resources-resourceloaderaware]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "The `ResourcePatternResolver` Interface", "heading_level": 2, "file_order": 106, "section_index": 12, "content_hash": "8becee6854d0919f001da52aad0b4c3e3003e6dd19337e1d7b8ad4cc7ff25cec", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:9f6ce2084569d5fced0ec34b857886eef89ee86e7b18612f41360b17223e2a66", "content": "The `ResourceLoaderAware` interface is a special callback interface which identifies\ncomponents that expect to be provided a `ResourceLoader` reference. The following listing\nshows the definition of the `ResourceLoaderAware` interface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface ResourceLoaderAware {\n\n void setResourceLoader(ResourceLoader resourceLoader);\n\t}\n----\n\nWhen a class implements `ResourceLoaderAware` and is deployed into an application context\n(as a Spring-managed bean), it is recognized as `ResourceLoaderAware` by the application\ncontext. The application context then invokes `setResourceLoader(ResourceLoader)`,\nsupplying itself as the argument (remember, all application contexts in Spring implement\nthe `ResourceLoader` interface).\n\nSince an `ApplicationContext` is a `ResourceLoader`, the bean could also implement the\n`ApplicationContextAware` interface and use the supplied application context directly to\nload resources. However, in general, it is better to use the specialized `ResourceLoader`\ninterface if that is all you need. The code would be coupled only to the resource loading\ninterface (which can be considered a utility interface) and not to the whole Spring\n`ApplicationContext` interface.\n\nIn application components, you may also rely upon autowiring of the `ResourceLoader` as\nan alternative to implementing the `ResourceLoaderAware` interface. The _traditional_\n`constructor` and `byType` autowiring modes (as described in xref:core/beans/dependencies/factory-autowire.adoc[Autowiring Collaborators])\nare capable of providing a `ResourceLoader` for either a constructor argument or a\nsetter method parameter, respectively. For more flexibility (including the ability to\nautowire fields and multiple parameter methods), consider using the annotation-based\nautowiring features. In that case, the `ResourceLoader` is autowired into a field,\nconstructor argument, or method parameter that expects the `ResourceLoader` type as long\nas the field, constructor, or method in question carries the `@Autowired` annotation.\nFor more information, see xref:core/beans/annotation-config/autowired.adoc[Using `@Autowired`].\n\nNOTE: To load one or more `Resource` objects for a resource path that contains wildcards\nor makes use of the special `classpath*:` resource prefix, consider having an instance of\nxref:core/resources.adoc#resources-resourcepatternresolver[`ResourcePatternResolver`] autowired into your\napplication components instead of `ResourceLoader`.\n\n[[resources-as-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "The `ResourceLoaderAware` Interface", "heading_level": 2, "file_order": 106, "section_index": 13, "content_hash": "9f6ce2084569d5fced0ec34b857886eef89ee86e7b18612f41360b17223e2a66", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:2386c011d0e1b374f4108b5bfff47af13d9b5b726b9ef0a42e94085e316b691b", "content": "If the bean itself is going to determine and supply the resource path through some sort\nof dynamic process, it probably makes sense for the bean to use the `ResourceLoader` or\n`ResourcePatternResolver` interface to load resources. For example, consider the loading\nof a template of some sort, where the specific resource that is needed depends on the\nrole of the user. If the resources are static, it makes sense to eliminate the use of the\n`ResourceLoader` interface (or `ResourcePatternResolver` interface) completely, have the\nbean expose the `Resource` properties it needs, and expect them to be injected into it.\n\nWhat makes it trivial to then inject these properties is that all application contexts\nregister and use a special JavaBeans `PropertyEditor`, which can convert `String` paths\nto `Resource` objects. For example, the following `MyBean` class has a `template`\nproperty of type `Resource`.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpackage example;\n\n\tpublic class MyBean {\n\n private Resource template;\n\n public setTemplate(Resource template) {\n this.template = template;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MyBean(var template: Resource)\n----\n======\n\nIn an XML configuration file, the `template` property can be configured with a simple\nstring for that resource, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"myBean\" class=\"example.MyBean\">\n <property name=\"template\" value=\"some/resource/path/myTemplate.txt\"/>\n\t</bean>\n----\n\nNote that the resource path has no prefix. Consequently, because the application context\nitself is going to be used as the `ResourceLoader`, the resource is loaded through a\n`ClassPathResource`, a `FileSystemResource`, or a `ServletContextResource`, depending on\nthe exact type of the application context.\n\nIf you need to force a specific `Resource` type to be used, you can use a prefix. The\nfollowing two examples show how to force a `ClassPathResource` and a `UrlResource` (the\nlatter being used to access a file in the filesystem):\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<property name=\"template\" value=\"classpath:some/resource/path/myTemplate.txt\">\n----\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<property name=\"template\" value=\"file:///some/resource/path/myTemplate.txt\"/>\n----\n\nIf the `MyBean` class is refactored for use with annotation-driven configuration, the\npath to `myTemplate.txt` can be stored under a key named `template.path` -- for example,\nin a properties file made available to the Spring `Environment` (see\nxref:core/beans/environment.adoc[Environment Abstraction]). The template path can then be referenced via the `@Value`\nannotation using a property placeholder (see xref:core/beans/annotation-config/value-annotations.adoc[Using `@Value`]). Spring will\nretrieve the value of the template path as a string, and a special `PropertyEditor` will\nconvert the string to a `Resource` object to be injected into the `MyBean` constructor.\nThe following example demonstrates how to achieve this.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tpublic class MyBean {\n\n private final Resource template;\n\n public MyBean(@Value(\"${template.path}\") Resource template) {\n this.template = template;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tclass MyBean(@Value(\"\\${template.path}\") private val template: Resource)\n----\n======\n\nIf we want to support multiple templates discovered under the same path in multiple\nlocations in the classpath -- for example, in multiple jars in the classpath -- we can\nuse the special `classpath*:` prefix and wildcarding to define a `templates.path` key as\n`classpath*:/config/templates/*.txt`. If we redefine the `MyBean` class as follows,\nSpring will convert the template path pattern into an array of `Resource` objects that\ncan be injected into the `MyBean` constructor.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tpublic class MyBean {\n\n private final Resource[] templates;\n\n public MyBean(@Value(\"${templates.path}\") Resource[] templates) {\n this.templates = templates;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tclass MyBean(@Value(\"\\${templates.path}\") private val templates: Resource[])\n----\n======\n\n[[resources-app-ctx]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "Resources as Dependencies", "heading_level": 2, "file_order": 106, "section_index": 14, "content_hash": "2386c011d0e1b374f4108b5bfff47af13d9b5b726b9ef0a42e94085e316b691b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:bddba6ddc630ebecd2f87966ee7941cc6420d3155e17a917ebcd65193e2adb14", "content": "This section covers how to create application contexts with resources, including shortcuts\nthat work with XML, how to use wildcards, and other details.\n\n[[resources-app-ctx-construction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "Application Contexts and Resource Paths", "heading_level": 2, "file_order": 106, "section_index": 15, "content_hash": "bddba6ddc630ebecd2f87966ee7941cc6420d3155e17a917ebcd65193e2adb14", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:41c71e50726f90d20864c45401bb99ea419b58929d3a2746594fbc0a3f966766", "content": "An application context constructor (for a specific application context type) generally\ntakes a string or array of strings as the location paths of the resources, such as\nXML files that make up the definition of the context.\n\nWhen such a location path does not have a prefix, the specific `Resource` type built from\nthat path and used to load the bean definitions depends on and is appropriate to the\nspecific application context. For example, consider the following example, which creates a\n`ClassPathXmlApplicationContext`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext ctx = new ClassPathXmlApplicationContext(\"conf/appContext.xml\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ctx = ClassPathXmlApplicationContext(\"conf/appContext.xml\")\n----\n======\n\nThe bean definitions are loaded from the classpath, because a `ClassPathResource` is\nused. However, consider the following example, which creates a `FileSystemXmlApplicationContext`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext ctx =\n new FileSystemXmlApplicationContext(\"conf/appContext.xml\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ctx = FileSystemXmlApplicationContext(\"conf/appContext.xml\")\n----\n======\n\nNow the bean definitions are loaded from a filesystem location (in this case, relative to\nthe current working directory).\n\nNote that the use of the special `classpath` prefix or a standard URL prefix on the\nlocation path overrides the default type of `Resource` created to load the bean\ndefinitions. Consider the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext ctx =\n new FileSystemXmlApplicationContext(\"classpath:conf/appContext.xml\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ctx = FileSystemXmlApplicationContext(\"classpath:conf/appContext.xml\")\n----\n======\n\nUsing `FileSystemXmlApplicationContext` loads the bean definitions from the classpath.\nHowever, it is still a `FileSystemXmlApplicationContext`. If it is subsequently used as a\n`ResourceLoader`, any unprefixed paths are still treated as filesystem paths.\n\n[[resources-app-ctx-classpathxml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "Constructing Application Contexts", "heading_level": 3, "file_order": 106, "section_index": 16, "content_hash": "41c71e50726f90d20864c45401bb99ea419b58929d3a2746594fbc0a3f966766", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:96e4e8525c72736831363b48aadeb75afdda2f119541b06d0987cd38e2a573f8", "content": "The `ClassPathXmlApplicationContext` exposes a number of constructors to enable\nconvenient instantiation. The basic idea is that you can supply merely a string array\nthat contains only the filenames of the XML files themselves (without the leading path\ninformation) and also supply a `Class`. The `ClassPathXmlApplicationContext` then derives\nthe path information from the supplied class.\n\nConsider the following directory layout:\n\n[literal,subs=\"verbatim,quotes\"]\n----\ncom/\n example/\n services.xml\n repositories.xml\n MessengerService.class\n----\n\nThe following example shows how a `ClassPathXmlApplicationContext` instance composed of\nthe beans defined in files named `services.xml` and `repositories.xml` (which are on the\nclasspath) can be instantiated:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext ctx = new ClassPathXmlApplicationContext(\n new String[] {\"services.xml\", \"repositories.xml\"}, MessengerService.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ctx = ClassPathXmlApplicationContext(arrayOf(\"services.xml\", \"repositories.xml\"), MessengerService::class.java)\n----\n======\n\nSee the {spring-framework-api}/context/support/ClassPathXmlApplicationContext.html[`ClassPathXmlApplicationContext`]\njavadoc for details on the various constructors.\n\n[[resources-app-ctx-wildcards-in-resource-paths]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "Constructing `ClassPathXmlApplicationContext` Instances -- Shortcuts", "heading_level": 4, "file_order": 106, "section_index": 17, "content_hash": "96e4e8525c72736831363b48aadeb75afdda2f119541b06d0987cd38e2a573f8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:675cd782ed85fb6f2cf352bf50ced503ec893fe8c5135f7afc2924df0634b30e", "content": "The resource paths in application context constructor values may be simple paths (as\nshown earlier), each of which has a one-to-one mapping to a target `Resource` or,\nalternately, may contain the special `classpath*:` prefix or internal Ant-style patterns\n(matched by using Spring's `PathMatcher` utility). Both of the latter are effectively\nwildcards.\n\nOne use for this mechanism is when you need to do component-style application assembly. All\ncomponents can _publish_ context definition fragments to a well-known location path, and,\nwhen the final application context is created using the same path prefixed with\n`classpath*:`, all component fragments are automatically picked up.\n\nNote that this wildcarding is specific to the use of resource paths in application context\nconstructors (or when you use the `PathMatcher` utility class hierarchy directly) and is\nresolved at construction time. It has nothing to do with the `Resource` type itself.\nYou cannot use the `classpath*:` prefix to construct an actual `Resource`, as\na resource points to just one resource at a time.\n\n[[resources-app-ctx-ant-patterns-in-paths]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "Wildcards in Application Context Constructor Resource Paths", "heading_level": 3, "file_order": 106, "section_index": 18, "content_hash": "675cd782ed85fb6f2cf352bf50ced503ec893fe8c5135f7afc2924df0634b30e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:96b5ba5433bca6a764afd26418dac3be87759710a5edebef00d787df7a36f56d", "content": "Path locations can contain Ant-style patterns, as the following example shows:\n\n[literal,subs=\"verbatim,quotes\"]\n----\n/WEB-INF/\\*-context.xml\ncom/mycompany/\\**/applicationContext.xml\nfile:C:/some/path/\\*-context.xml\nclasspath:com/mycompany/**/applicationContext.xml\n----\n\nWhen the path location contains an Ant-style pattern, the resolver follows a more complex\nprocedure to try to resolve the wildcard. It produces a `Resource` for the path up to the\nlast non-wildcard segment and obtains a URL from it. If this URL is not a `jar:` URL or\ncontainer-specific variant (such as `zip:` in WebLogic, `wsjar` in WebSphere, and so on),\na `java.io.File` is obtained from it and used to resolve the wildcard by traversing the\nfilesystem. In the case of a jar URL, the resolver either gets a\n`java.net.JarURLConnection` from it or manually parses the jar URL and then traverses the\ncontents of the jar file to resolve the wildcards.\n\n[[resources-app-ctx-portability]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "Ant-style Patterns", "heading_level": 4, "file_order": 106, "section_index": 19, "content_hash": "96b5ba5433bca6a764afd26418dac3be87759710a5edebef00d787df7a36f56d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:15e73d93e6173231f659d45c43ffbcebbff0b956f32cf44ae3d68a040e0a961c", "content": "If the specified path is already a `file` URL (either implicitly because the base\n`ResourceLoader` is a filesystem one or explicitly), wildcarding is guaranteed to\nwork in a completely portable fashion.\n\nIf the specified path is a `classpath` location, the resolver must obtain the last\nnon-wildcard path segment URL by making a `Classloader.getResource()` call. Since this\nis just a node of the path (not the file at the end), it is actually undefined (in the\n`ClassLoader` javadoc) exactly what sort of a URL is returned in this case. In practice,\nit is always a `java.io.File` representing the directory (where the classpath resource\nresolves to a filesystem location) or a jar URL of some sort (where the classpath resource\nresolves to a jar location). Still, there is a portability concern on this operation.\n\nIf a jar URL is obtained for the last non-wildcard segment, the resolver must be able to\nget a `java.net.JarURLConnection` from it or manually parse the jar URL, to be able to\nwalk the contents of the jar and resolve the wildcard. This does work in most environments\nbut fails in others, and we strongly recommend that the wildcard resolution of resources\ncoming from jars be thoroughly tested in your specific environment before you rely on it.\n\n[[resources-classpath-wildcards]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "Implications on Portability", "heading_level": 5, "file_order": 106, "section_index": 20, "content_hash": "15e73d93e6173231f659d45c43ffbcebbff0b956f32cf44ae3d68a040e0a961c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:895ef724c5b765fd8e6a1d036e603642dd43f69b8811ec84d583e999c4ed75f4", "content": "When constructing an XML-based application context, a location string may use the\nspecial `classpath*:` prefix, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext ctx =\n new ClassPathXmlApplicationContext(\"classpath*:conf/appContext.xml\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ctx = ClassPathXmlApplicationContext(\"classpath*:conf/appContext.xml\")\n----\n======\n\nThis special prefix specifies that all classpath resources that match the given name\nmust be obtained (internally, this essentially happens through a call to\n`ClassLoader.getResources(...)`) and then merged to form the final application\ncontext definition.\n\nNOTE: The wildcard classpath relies on the `getResources()` method of the underlying\n`ClassLoader`. As most application servers nowadays supply their own `ClassLoader`\nimplementation, the behavior might differ, especially when dealing with jar files. A\nsimple test to check if `classpath*` works is to use the `ClassLoader` to load a file from\nwithin a jar on the classpath:\n`getClass().getClassLoader().getResources(\"<someFileInsideTheJar>\")`. Try this test with\nfiles that have the same name but reside in two different locations -- for example, files\nwith the same name and same path but in different jars on the classpath. In case an\ninappropriate result is returned, check the application server documentation for settings\nthat might affect the `ClassLoader` behavior.\n\nYou can also combine the `classpath*:` prefix with a `PathMatcher` pattern in the\nrest of the location path (for example, `classpath*:META-INF/*-beans.xml`). In this\ncase, the resolution strategy is fairly simple: A `ClassLoader.getResources()` call is\nused on the last non-wildcard path segment to get all the matching resources in the\nclass loader hierarchy and then, off each resource, the same `PathMatcher` resolution\nstrategy described earlier is used for the wildcard subpath.\n\n[[resources-wildcards-in-path-other-stuff]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "The `classpath*:` Prefix", "heading_level": 4, "file_order": 106, "section_index": 21, "content_hash": "895ef724c5b765fd8e6a1d036e603642dd43f69b8811ec84d583e999c4ed75f4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:51ca01f05ce72f21263fe80f9eabc4354e59838c24edae17c1b5e860f4f4f5cd", "content": "Note that `classpath*:`, when combined with Ant-style patterns, only works\nreliably with at least one root directory before the pattern starts, unless the actual\ntarget files reside in the file system. This means that a pattern such as\n`classpath*:*.xml` might not retrieve files from the root of jar files but rather only\nfrom the root of expanded directories.\n\nSpring's ability to retrieve classpath entries originates from the JDK's\n`ClassLoader.getResources()` method, which only returns file system locations for an\nempty string (indicating potential roots to search). Spring evaluates\n`URLClassLoader` runtime configuration and the `java.class.path` manifest in jar files\nas well, but this is not guaranteed to lead to portable behavior.\n\n[NOTE]\n====\nThe scanning of classpath packages requires the presence of corresponding directory\nentries in the classpath. When you build JARs with Ant, do not activate the `files-only`\nswitch of the JAR task. Also, classpath directories may not get exposed based on security\npolicies in some environments -- for example, stand-alone applications on JDK 1.7.0_45\nand higher (which requires 'Trusted-Library' to be set up in your manifests. See\n{stackoverflow-questions}/19394570/java-jre-7u45-breaks-classloader-getresources).\n\nOn the module path (Java Module System), Spring's classpath scanning generally works as\nexpected. Putting resources into a dedicated directory is highly recommendable here as well,\navoiding the aforementioned portability problems with searching the jar file root level.\n====\n\nAnt-style patterns with `classpath:` resources are not guaranteed to find matching\nresources if the root package to search is available in multiple classpath locations.\nConsider the following example of a resource location:\n\n[literal,subs=\"verbatim,quotes\"]\n----\ncom/mycompany/package1/service-context.xml\n----\n\nNow consider an Ant-style path that someone might use to try to find that file:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nclasspath:com/mycompany/**/service-context.xml\n----\n\nSuch a resource may exist in only one location in the classpath, but when a path such as\nthe preceding example is used to try to resolve it, the resolver works off the (first)\nURL returned by `getResource(\"com/mycompany\");`. If this base package node exists in\nmultiple `ClassLoader` locations, the desired resource may not exist in the first\nlocation found. Therefore, in such cases you should prefer using `classpath*:` with the\nsame Ant-style pattern, which searches all classpath locations that contain the\n`com.mycompany` base package: `classpath*:com/mycompany/**/service-context.xml`.\n\n[[resources-filesystemresource-caveats]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "Other Notes Relating to Wildcards", "heading_level": 4, "file_order": 106, "section_index": 22, "content_hash": "51ca01f05ce72f21263fe80f9eabc4354e59838c24edae17c1b5e860f4f4f5cd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:699963d355b442be9d9c7024f8d9257f79ba9c1f7e0324c935c8e3b920756c9b", "content": "A `FileSystemResource` that is not attached to a `FileSystemApplicationContext` (that\nis, when a `FileSystemApplicationContext` is not the actual `ResourceLoader`) treats\nabsolute and relative paths as you would expect. Relative paths are relative to the\ncurrent working directory, while absolute paths are relative to the root of the\nfilesystem.\n\nFor backwards compatibility (historical) reasons however, this changes when the\n`FileSystemApplicationContext` is the `ResourceLoader`. The\n`FileSystemApplicationContext` forces all attached `FileSystemResource` instances\nto treat all location paths as relative, whether they start with a leading slash or not.\nIn practice, this means the following examples are equivalent:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext ctx =\n new FileSystemXmlApplicationContext(\"conf/context.xml\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ctx = FileSystemXmlApplicationContext(\"conf/context.xml\")\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext ctx =\n new FileSystemXmlApplicationContext(\"/conf/context.xml\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ctx = FileSystemXmlApplicationContext(\"/conf/context.xml\")\n----\n======\n\nThe following examples are also equivalent (even though it would make sense for them to be different, as one\ncase is relative and the other absolute):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tFileSystemXmlApplicationContext ctx = ...;\n\tctx.getResource(\"some/resource/path/myTemplate.txt\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ctx: FileSystemXmlApplicationContext = ...\n\tctx.getResource(\"some/resource/path/myTemplate.txt\")\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tFileSystemXmlApplicationContext ctx = ...;\n\tctx.getResource(\"/some/resource/path/myTemplate.txt\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ctx: FileSystemXmlApplicationContext = ...\n\tctx.getResource(\"/some/resource/path/myTemplate.txt\")\n----\n======\n\nIn practice, if you need true absolute filesystem paths, you should avoid using\nabsolute paths with `FileSystemResource` or `FileSystemXmlApplicationContext` and\nforce the use of a `UrlResource` by using the `file:` URL prefix. The following examples\nshow how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// actual context type doesn't matter, the Resource will always be UrlResource\n\tctx.getResource(\"file:///some/resource/path/myTemplate.txt\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// actual context type doesn't matter, the Resource will always be UrlResource\n\tctx.getResource(\"file:///some/resource/path/myTemplate.txt\")\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// force this FileSystemXmlApplicationContext to load its definition via a UrlResource\n\tApplicationContext ctx =\n new FileSystemXmlApplicationContext(\"file:///conf/context.xml\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// force this FileSystemXmlApplicationContext to load its definition via a UrlResource\n\tval ctx = FileSystemXmlApplicationContext(\"file:///conf/context.xml\")\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/resources.adoc", "title": "resources", "heading": "`FileSystemResource` Caveats", "heading_level": 3, "file_order": 106, "section_index": 23, "content_hash": "699963d355b442be9d9c7024f8d9257f79ba9c1f7e0324c935c8e3b920756c9b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/resources.adoc"}}
{"id": "sha256:49b7ea1328d9d94d9c20ba66c4c805711834b7c299b13b343b58b6055b967257", "content": "[[validation]]\n\nThere are pros and cons for considering validation as business logic, and Spring offers\na design for validation and data binding that does not exclude either one of them.\nSpecifically, validation should not be tied to the web tier and should be easy to localize,\nand it should be possible to plug in any available validator. Considering these concerns,\nSpring provides a `Validator` contract that is both basic and eminently usable\nin every layer of an application.\n\nData binding is useful for letting user input be dynamically bound to the domain\nmodel of an application (or whatever objects you use to process user input). Spring\nprovides the aptly named `DataBinder` to do exactly that. The `Validator` and the\n`DataBinder` make up the `validation` package, which is primarily used in but not\nlimited to the web layer.\n\nThe `BeanWrapper` is a fundamental concept in the Spring Framework and is used in a lot\nof places. However, you probably do not need to use the `BeanWrapper` directly. Because\nthis is reference documentation, however, we feel that some explanation might be in\norder. We explain the `BeanWrapper` in this chapter, since, if you are going to use it at\nall, you are most likely do so when trying to bind data to objects.\n\nSpring's `DataBinder` and the lower-level `BeanWrapper` both use `PropertyEditorSupport`\nimplementations to parse and format property values. The `PropertyEditor` and\n`PropertyEditorSupport` types are part of the JavaBeans specification and are also\nexplained in this chapter. Spring's `core.convert` package provides a general type\nconversion facility, as well as a higher-level `format` package for formatting UI field\nvalues. You can use these packages as simpler alternatives to `PropertyEditorSupport`\nimplementations. They are also discussed in this chapter.\n\nSpring supports Java Bean Validation through setup infrastructure and an adaptor to\nSpring's own `Validator` contract. Applications can enable Bean Validation once globally,\nas described in xref:core/validation/beanvalidation.adoc[Java Bean Validation], and use\nit exclusively for all validation needs. In the web layer, applications can further\nregister controller-local Spring `Validator` instances per `DataBinder`, as described in\nxref:core/validation/beanvalidation.adoc#validation-binder[Configuring a `DataBinder`],\nwhich can be useful for plugging in custom validation logic.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core/validation.adoc", "title": "validation", "heading": "validation", "heading_level": 1, "file_order": 107, "section_index": 0, "content_hash": "49b7ea1328d9d94d9c20ba66c4c805711834b7c299b13b343b58b6055b967257", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core/validation.adoc"}}
{"id": "sha256:f8b9af99467673e56e025037801be508dd8bf3f6259d110910d25892db061a06", "content": "[[jdbc-advanced-jdbc]]\n\nMost JDBC drivers provide improved performance if you batch multiple calls to the same\nprepared statement. By grouping updates into batches, you limit the number of round trips\nto the database.\n\n[[jdbc-batch-classic]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/advanced.adoc", "title": "advanced", "heading": "advanced", "heading_level": 1, "file_order": 108, "section_index": 0, "content_hash": "f8b9af99467673e56e025037801be508dd8bf3f6259d110910d25892db061a06", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/advanced.adoc"}}
{"id": "sha256:d48960ee8fb55e3f2006a4fe4544befb1c14ef7842846173ab09c07f01268652", "content": "You accomplish `JdbcTemplate` batch processing by implementing two methods of a special interface,\n`BatchPreparedStatementSetter`, and passing that implementation in as the second parameter\nin your `batchUpdate` method call. You can use the `getBatchSize` method to provide the size of\nthe current batch. You can use the `setValues` method to set the values for the parameters of\nthe prepared statement. This method is called the number of times that you specified in the\n`getBatchSize` call. The following example updates the `t_actor` table based on entries in a list,\nand the entire list is used as the batch:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private JdbcTemplate jdbcTemplate;\n\n public void setDataSource(DataSource dataSource) {\n this.jdbcTemplate = new JdbcTemplate(dataSource);\n }\n\n public int[] batchUpdate(final List<Actor> actors) {\n return this.jdbcTemplate.batchUpdate(\n \"update t_actor set first_name = ?, last_name = ? where id = ?\",\n new BatchPreparedStatementSetter() {\n public void setValues(PreparedStatement ps, int i) throws SQLException {\n Actor actor = actors.get(i);\n ps.setString(1, actor.getFirstName());\n ps.setString(2, actor.getLastName());\n ps.setLong(3, actor.getId().longValue());\n }\n public int getBatchSize() {\n return actors.size();\n }\n });\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val jdbcTemplate = JdbcTemplate(dataSource)\n\n fun batchUpdate(actors: List<Actor>): IntArray {\n return jdbcTemplate.batchUpdate(\n \"update t_actor set first_name = ?, last_name = ? where id = ?\",\n object: BatchPreparedStatementSetter {\n override fun setValues(ps: PreparedStatement, i: Int) {\n ps.setString(1, actors[i].firstName)\n ps.setString(2, actors[i].lastName)\n ps.setLong(3, actors[i].id)\n }\n\n override fun getBatchSize() = actors.size\n })\n }\n\n // ... additional methods\n\t}\n----\n======\n\nIf you process a stream of updates or reading from a file, you might have a\npreferred batch size, but the last batch might not have that number of entries. In this\ncase, you can use the `InterruptibleBatchPreparedStatementSetter` interface, which lets\nyou interrupt a batch once the input source is exhausted. The `isBatchExhausted` method\nlets you signal the end of the batch.\n\n[[jdbc-batch-list]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/advanced.adoc", "title": "advanced", "heading": "Basic Batch Operations with `JdbcTemplate`", "heading_level": 2, "file_order": 108, "section_index": 1, "content_hash": "d48960ee8fb55e3f2006a4fe4544befb1c14ef7842846173ab09c07f01268652", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/advanced.adoc"}}
{"id": "sha256:ae4f0b29f4aa63a4ece888a3c7eca3f0aeaf644003c0fb937f288d7507dd6790", "content": "Both the `JdbcTemplate` and the `NamedParameterJdbcTemplate` provides an alternate way\nof providing the batch update. Instead of implementing a special batch interface, you\nprovide all parameter values in the call as a list. The framework loops over these\nvalues and uses an internal prepared statement setter. The API varies, depending on\nwhether you use named parameters. For the named parameters, you provide an array of\n`SqlParameterSource`, one entry for each member of the batch. You can use the\n`SqlParameterSourceUtils.createBatch` convenience methods to create this array, passing\nin an array of bean-style objects (with getter methods corresponding to parameters),\n`String`-keyed `Map` instances (containing the corresponding parameters as values), or a mix of both.\n\nThe following example shows a batch update using named parameters:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private NamedParameterTemplate namedParameterJdbcTemplate;\n\n public void setDataSource(DataSource dataSource) {\n this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n }\n\n public int[] batchUpdate(List<Actor> actors) {\n return this.namedParameterJdbcTemplate.batchUpdate(\n \"update t_actor set first_name = :firstName, last_name = :lastName where id = :id\",\n SqlParameterSourceUtils.createBatch(actors));\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)\n\n fun batchUpdate(actors: List<Actor>): IntArray {\n return this.namedParameterJdbcTemplate.batchUpdate(\n \"update t_actor set first_name = :firstName, last_name = :lastName where id = :id\",\n SqlParameterSourceUtils.createBatch(actors));\n }\n\n // ... additional methods\n\t}\n----\n======\n\nFor an SQL statement that uses the classic `?` placeholders, you pass in a list\ncontaining an object array with the update values. This object array must have one entry\nfor each placeholder in the SQL statement, and they must be in the same order as they are\ndefined in the SQL statement.\n\nThe following example is the same as the preceding example, except that it uses classic\nJDBC `?` placeholders:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private JdbcTemplate jdbcTemplate;\n\n public void setDataSource(DataSource dataSource) {\n this.jdbcTemplate = new JdbcTemplate(dataSource);\n }\n\n public int[] batchUpdate(final List<Actor> actors) {\n List<Object[]> batch = new ArrayList<>();\n for (Actor actor : actors) {\n Object[] values = new Object[] {\n actor.getFirstName(), actor.getLastName(), actor.getId()};\n batch.add(values);\n }\n return this.jdbcTemplate.batchUpdate(\n \"update t_actor set first_name = ?, last_name = ? where id = ?\",\n batch);\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val jdbcTemplate = JdbcTemplate(dataSource)\n\n fun batchUpdate(actors: List<Actor>): IntArray {\n val batch = mutableListOf<Array<Any>>()\n for (actor in actors) {\n batch.add(arrayOf(actor.firstName, actor.lastName, actor.id))\n }\n return jdbcTemplate.batchUpdate(\n \"update t_actor set first_name = ?, last_name = ? where id = ?\", batch)\n }\n\n // ... additional methods\n\t}\n----\n======\n\nAll of the batch update methods that we described earlier return an `int` array\ncontaining the number of affected rows for each batch entry. This count is reported by\nthe JDBC driver. If the count is not available, the JDBC driver returns a value of `-2`.\n\n[NOTE]\n====\nIn such a scenario, with automatic setting of values on an underlying `PreparedStatement`,\nthe corresponding JDBC type for each value needs to be derived from the given Java type.\nWhile this usually works well, there is a potential for issues (for example, with\nMap-contained `null` values). Spring, by default, calls `ParameterMetaData.getParameterType`\nin such a case, which can be expensive with your JDBC driver. You should use a recent driver\nversion and consider setting the `spring.jdbc.getParameterType.ignore` property to `true`\n(as a JVM system property or via the\nxref:appendix.adoc#appendix-spring-properties[`SpringProperties`] mechanism)\nif you encounter a specific performance issue for your application.\n\nAs of 6.1.2, Spring bypasses the default `getParameterType` resolution on PostgreSQL and\nMS SQL Server. This is a common optimization to avoid further roundtrips to the DBMS just\nfor parameter type resolution which is known to make a very significant difference on\nPostgreSQL and MS SQL Server specifically, in particular for batch operations. If you\nhappen to see a side effect, for example, when setting a byte array to null without specific type\nindication, you may explicitly set the `spring.jdbc.getParameterType.ignore=false` flag\nas a system property (see above) to restore full `getParameterType` resolution.\n\nAlternatively, you could consider specifying the corresponding JDBC types explicitly,\neither through a `BatchPreparedStatementSetter` (as shown earlier), through an explicit\ntype array given to a `List<Object[]>` based call, through `registerSqlType` calls on a\ncustom `MapSqlParameterSource` instance, through a `BeanPropertySqlParameterSource`\nthat derives the SQL type from the Java-declared property type even for a null value, or\nthrough providing individual `SqlParameterValue` instances instead of plain null values.\n====\n\n[[jdbc-batch-multi]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/advanced.adoc", "title": "advanced", "heading": "Batch Operations with a List of Objects", "heading_level": 2, "file_order": 108, "section_index": 2, "content_hash": "ae4f0b29f4aa63a4ece888a3c7eca3f0aeaf644003c0fb937f288d7507dd6790", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/advanced.adoc"}}
{"id": "sha256:24377bd9405865a58cd2193706352b39b6b9f195c8fe1ff8d3d238d692893a26", "content": "The preceding example of a batch update deals with batches that are so large that you want to\nbreak them up into several smaller batches. You can do this with the methods\nmentioned earlier by making multiple calls to the `batchUpdate` method, but there is now a\nmore convenient method. This method takes, in addition to the SQL statement, a\n`Collection` of objects that contain the parameters, the number of updates to make for each\nbatch, and a `ParameterizedPreparedStatementSetter` to set the values for the parameters\nof the prepared statement. The framework loops over the provided values and breaks the\nupdate calls into batches of the size specified.\n\nThe following example shows a batch update that uses a batch size of 100:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private JdbcTemplate jdbcTemplate;\n\n public void setDataSource(DataSource dataSource) {\n this.jdbcTemplate = new JdbcTemplate(dataSource);\n }\n\n public int[][] batchUpdate(final Collection<Actor> actors) {\n int[][] updateCounts = jdbcTemplate.batchUpdate(\n \"update t_actor set first_name = ?, last_name = ? where id = ?\",\n actors,\n 100,\n (PreparedStatement ps, Actor actor) -> {\n ps.setString(1, actor.getFirstName());\n ps.setString(2, actor.getLastName());\n ps.setLong(3, actor.getId().longValue());\n });\n return updateCounts;\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val jdbcTemplate = JdbcTemplate(dataSource)\n\n fun batchUpdate(actors: List<Actor>): Array<IntArray> {\n return jdbcTemplate.batchUpdate(\n \"update t_actor set first_name = ?, last_name = ? where id = ?\",\n actors, 100) { ps, argument ->\n ps.setString(1, argument.firstName)\n ps.setString(2, argument.lastName)\n ps.setLong(3, argument.id)\n }\n }\n\n // ... additional methods\n\t}\n----\n======\n\nThe batch update method for this call returns an array of `int` arrays that contains an\narray entry for each batch with an array of the number of affected rows for each update.\nThe top-level array's length indicates the number of batches run, and the second level\narray's length indicates the number of updates in that batch. The number of updates in\neach batch should be the batch size provided for all batches (except that the last one\nthat might be less), depending on the total number of update objects provided. The update\ncount for each update statement is the one reported by the JDBC driver. If the count is\nnot available, the JDBC driver returns a value of `-2`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/advanced.adoc", "title": "advanced", "heading": "Batch Operations with Multiple Batches", "heading_level": 2, "file_order": 108, "section_index": 3, "content_hash": "24377bd9405865a58cd2193706352b39b6b9f195c8fe1ff8d3d238d692893a26", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/advanced.adoc"}}
{"id": "sha256:1bb9a0549ff47cf7631820b104678d327131e76ba7fb5cf08ecb573fd30529cc", "content": "[[jdbc-choose-style]]\n\nYou can choose among several approaches to form the basis for your JDBC database access.\nIn addition to three flavors of `JdbcTemplate`, a `SimpleJdbcInsert` and `SimpleJdbcCall`\napproach optimizes database metadata, and the RDBMS Object style results in a more\nobject-oriented approach. Once you start using one of these approaches, you can still mix\nand match to include a feature from a different approach.\n\n* `JdbcTemplate` is the classic and most popular Spring JDBC approach. This\n \"`lowest-level`\" approach and all others use a `JdbcTemplate` under the covers.\n* `NamedParameterJdbcTemplate` wraps a `JdbcTemplate` to provide named parameters\n instead of the traditional JDBC `?` placeholders. This approach provides better\n documentation and ease of use when you have multiple parameters for an SQL statement.\n* `SimpleJdbcInsert` and `SimpleJdbcCall` optimize database metadata to limit the amount\n of necessary configuration. This approach simplifies coding so that you only need to\n provide the name of the table or procedure and a map of parameters matching the column\n names. This works only if the database provides adequate metadata. If the database does\n not provide this metadata, you have to provide explicit configuration of the parameters.\n* RDBMS objects â€” including `MappingSqlQuery`, `SqlUpdate`, and `StoredProcedure` â€”\n require you to create reusable and thread-safe objects during initialization of your\n data-access layer. This approach allows you to define your query string, declare\n parameters, and compile the query. Once you do that, `execute(...)`, `update(...)`, and\n `findObject(...)` methods can be called multiple times with various parameter values.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/choose-style.adoc", "title": "choose-style", "heading": "choose-style", "heading_level": 1, "file_order": 109, "section_index": 0, "content_hash": "1bb9a0549ff47cf7631820b104678d327131e76ba7fb5cf08ecb573fd30529cc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/choose-style.adoc"}}
{"id": "sha256:68db7845135ffae104526b7fc009050f727857080c3bf70492c693f64f15320c", "content": "[[jdbc-connections]]\n\nThis section covers:\n\n* xref:data-access/jdbc/connections.adoc#jdbc-datasource[Using `DataSource`]\n* xref:data-access/jdbc/connections.adoc#jdbc-DataSourceUtils[Using `DataSourceUtils`]\n* xref:data-access/jdbc/connections.adoc#jdbc-SmartDataSource[Implementing `SmartDataSource`]\n* xref:data-access/jdbc/connections.adoc#jdbc-AbstractDataSource[Extending `AbstractDataSource`]\n* xref:data-access/jdbc/connections.adoc#jdbc-SingleConnectionDataSource[Using `SingleConnectionDataSource`]\n* xref:data-access/jdbc/connections.adoc#jdbc-DriverManagerDataSource[Using `DriverManagerDataSource`]\n* xref:data-access/jdbc/connections.adoc#jdbc-TransactionAwareDataSourceProxy[Using `TransactionAwareDataSourceProxy`]\n* xref:data-access/jdbc/connections.adoc#jdbc-DataSourceTransactionManager[Using `DataSourceTransactionManager` / `JdbcTransactionManager`]\n\n[[jdbc-datasource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc", "title": "connections", "heading": "connections", "heading_level": 1, "file_order": 110, "section_index": 0, "content_hash": "68db7845135ffae104526b7fc009050f727857080c3bf70492c693f64f15320c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc"}}
{"id": "sha256:1407c5fc4f00c099704595b4f7ae43169f8045db1ea96edaa609725d1c136a97", "content": "Spring obtains a connection to the database through a `DataSource`. A `DataSource` is\npart of the JDBC specification and is a generalized connection factory. It lets a\ncontainer or a framework hide connection pooling and transaction management issues\nfrom the application code. As a developer, you need not know details about how to\nconnect to the database. That is the responsibility of the administrator who sets up\nthe datasource. You most likely fill both roles as you develop and test code, but you\ndo not necessarily have to know how the production data source is configured.\n\nWhen you use Spring's JDBC layer, you can obtain a data source from JNDI, or you can\nconfigure your own with a connection pool implementation provided by a third party.\nTraditional choices are Apache Commons DBCP and C3P0 with bean-style `DataSource` classes;\nfor a modern JDBC connection pool, consider HikariCP with its builder-style API instead.\n\nNOTE: You should use the `DriverManagerDataSource` and `SimpleDriverDataSource` classes\n(as included in the Spring distribution) only for testing purposes! Those variants do not\nprovide pooling and perform poorly when multiple requests for a connection are made.\n\nThe following section uses Spring's `DriverManagerDataSource` implementation.\nSeveral other `DataSource` variants are covered later.\n\nTo configure a `DriverManagerDataSource`:\n\n. Obtain a connection with `DriverManagerDataSource` as you typically obtain a JDBC\n connection.\n. Specify the fully qualified class name of the JDBC driver so that the `DriverManager`\n can load the driver class.\n. Provide a URL that varies between JDBC drivers. (See the documentation for your driver\n for the correct value.)\n. Provide a username and a password to connect to the database.\n\nThe following example shows how to configure a `DriverManagerDataSource`:\n\ninclude-code::./DriverManagerDataSourceConfiguration[tag=snippet,indent=0]\n\nThe next two examples show the basic connectivity and configuration for DBCP and C3P0.\nTo learn about more options that help control the pooling features, see the product\ndocumentation for the respective connection pooling implementations.\n\nThe following example shows DBCP configuration:\n\ninclude-code::./BasicDataSourceConfiguration[tag=snippet,indent=0]\n\nThe following example shows C3P0 configuration:\n\ninclude-code::./ComboPooledDataSourceConfiguration[tag=snippet,indent=0]\n\n[[jdbc-DataSourceUtils]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc", "title": "connections", "heading": "Using `DataSource`", "heading_level": 2, "file_order": 110, "section_index": 1, "content_hash": "1407c5fc4f00c099704595b4f7ae43169f8045db1ea96edaa609725d1c136a97", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc"}}
{"id": "sha256:f98c821a0e34b08dff46b6cb3bf3b72834e64b5e31c8578490d6bae621fccc2a", "content": "The `DataSourceUtils` class is a convenient and powerful helper class that provides\n`static` methods to obtain connections from JNDI and close connections if necessary.\nIt supports a thread-bound JDBC `Connection` with `DataSourceTransactionManager` but\nalso with `JtaTransactionManager` and `JpaTransactionManager`.\n\nNote that `JdbcTemplate` implies `DataSourceUtils` connection access, using it\nbehind every JDBC operation, implicitly participating in an ongoing transaction.\n\n[[jdbc-SmartDataSource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc", "title": "connections", "heading": "Using `DataSourceUtils`", "heading_level": 2, "file_order": 110, "section_index": 2, "content_hash": "f98c821a0e34b08dff46b6cb3bf3b72834e64b5e31c8578490d6bae621fccc2a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc"}}
{"id": "sha256:24357a3950100c80a97557c416bdadafdb9f248680270de1accd8c94976ab162", "content": "The `SmartDataSource` interface should be implemented by classes that can provide a\nconnection to a relational database. It extends the `DataSource` interface to let\nclasses that use it query whether the connection should be closed after a given\noperation. This usage is efficient when you know that you need to reuse a connection.\n\n[[jdbc-AbstractDataSource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc", "title": "connections", "heading": "Implementing `SmartDataSource`", "heading_level": 2, "file_order": 110, "section_index": 3, "content_hash": "24357a3950100c80a97557c416bdadafdb9f248680270de1accd8c94976ab162", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc"}}
{"id": "sha256:44d1c6c5b029da628b3571f9832e8f7dcfc5bede4d4b3c4b3f17e46ad807b123", "content": "`AbstractDataSource` is an `abstract` base class for Spring's `DataSource`\nimplementations. It implements code that is common to all `DataSource` implementations.\nYou should extend the `AbstractDataSource` class if you write your own `DataSource`\nimplementation.\n\n[[jdbc-SingleConnectionDataSource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc", "title": "connections", "heading": "Extending `AbstractDataSource`", "heading_level": 2, "file_order": 110, "section_index": 4, "content_hash": "44d1c6c5b029da628b3571f9832e8f7dcfc5bede4d4b3c4b3f17e46ad807b123", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc"}}
{"id": "sha256:02d327f9a964983a34deb07334326cae224b1753f57ac487c885cbd11533a3c9", "content": "The `SingleConnectionDataSource` class is an implementation of the `SmartDataSource`\ninterface that wraps a single `Connection` that is not closed after each use.\nThis is not multi-threading capable.\n\nIf any client code calls `close` on the assumption of a pooled connection (as when using\npersistence tools), you should set the `suppressClose` property to `true`. This setting\nreturns a close-suppressing proxy that wraps the physical connection. Note that you can\nno longer cast this to a native Oracle `Connection` or a similar object.\n\n`SingleConnectionDataSource` is primarily a test class. It typically enables easy testing\nof code outside an application server, in conjunction with a simple JNDI environment.\nIn contrast to `DriverManagerDataSource`, it reuses the same connection all the time,\navoiding excessive creation of physical connections.\n\n[[jdbc-DriverManagerDataSource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc", "title": "connections", "heading": "Using `SingleConnectionDataSource`", "heading_level": 2, "file_order": 110, "section_index": 5, "content_hash": "02d327f9a964983a34deb07334326cae224b1753f57ac487c885cbd11533a3c9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc"}}
{"id": "sha256:3ce207ad094ab649402d19e5beba8af6a5883bc999f3e18ecb95fc61dce38a47", "content": "The `DriverManagerDataSource` class is an implementation of the standard `DataSource`\ninterface that configures a plain JDBC driver through bean properties and returns a new\n`Connection` every time.\n\nThis implementation is useful for test and stand-alone environments outside of a Jakarta EE\ncontainer, either as a `DataSource` bean in a Spring IoC container or in conjunction\nwith a simple JNDI environment. Pool-assuming `Connection.close()` calls\nclose the connection, so any `DataSource`-aware persistence code should work. However,\nusing JavaBean-style connection pools (such as `commons-dbcp`) is so easy, even in a test\nenvironment, that it is almost always preferable to use such a connection pool over\n`DriverManagerDataSource`.\n\n[[jdbc-TransactionAwareDataSourceProxy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc", "title": "connections", "heading": "Using `DriverManagerDataSource`", "heading_level": 2, "file_order": 110, "section_index": 6, "content_hash": "3ce207ad094ab649402d19e5beba8af6a5883bc999f3e18ecb95fc61dce38a47", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc"}}
{"id": "sha256:3860e34c4b3b89342f18ed3b3dd57610638ba634ad6a10f93e44689a688983a7", "content": "`TransactionAwareDataSourceProxy` is a proxy for a target `DataSource`. The proxy wraps that\ntarget `DataSource` to add awareness of Spring-managed transactions. In this respect, it\nis similar to a transactional JNDI `DataSource`, as provided by a Jakarta EE server.\n\nNOTE: It is rarely desirable to use this class, except when already existing code must be\ncalled and passed a standard JDBC `DataSource` interface implementation. In this case,\nyou can still have this code be usable and, at the same time, have this code\nparticipating in Spring managed transactions. It is generally preferable to write your\nown new code by using the higher level abstractions for resource management, such as\n`JdbcTemplate` or `DataSourceUtils`.\n\nSee the {spring-framework-api}/jdbc/datasource/TransactionAwareDataSourceProxy.html[`TransactionAwareDataSourceProxy`]\njavadoc for more details.\n\n[[jdbc-DataSourceTransactionManager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc", "title": "connections", "heading": "Using `TransactionAwareDataSourceProxy`", "heading_level": 2, "file_order": 110, "section_index": 7, "content_hash": "3860e34c4b3b89342f18ed3b3dd57610638ba634ad6a10f93e44689a688983a7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc"}}
{"id": "sha256:932ef6292435dc1bdbcf549a6a8809f4acce623f1db0e4eece7a363e78c889a5", "content": "The `DataSourceTransactionManager` class is a `PlatformTransactionManager`\nimplementation for a single JDBC `DataSource`. It binds a JDBC `Connection`\nfrom the specified `DataSource` to the currently executing thread, potentially\nallowing for one thread-bound `Connection` per `DataSource`.\n\nApplication code is required to retrieve the JDBC `Connection` through\n`DataSourceUtils.getConnection(DataSource)` instead of Java EE's standard\n`DataSource.getConnection`. It throws unchecked `org.springframework.dao` exceptions\ninstead of checked `SQLExceptions`. All framework classes (such as `JdbcTemplate`) use\nthis strategy implicitly. If not used with a transaction manager, the lookup strategy\nbehaves exactly like `DataSource.getConnection` and can therefore be used in any case.\n\nThe `DataSourceTransactionManager` class supports savepoints (`PROPAGATION_NESTED`),\ncustom isolation levels, and timeouts that get applied as appropriate JDBC statement\nquery timeouts. To support the latter, application code must either use `JdbcTemplate` or\ncall the `DataSourceUtils.applyTransactionTimeout(..)` method for each created statement.\n\nYou can use `DataSourceTransactionManager` instead of `JtaTransactionManager` in the\nsingle-resource case, as it does not require the container to support a JTA transaction\ncoordinator. Switching between these transaction managers is just a matter of configuration,\nprovided you stick to the required connection lookup pattern. Note that JTA does not support\nsavepoints or custom isolation levels and has a different timeout mechanism but otherwise\nexposes similar behavior in terms of JDBC resources and JDBC commit/rollback management.\n\nFor JTA-style lazy retrieval of actual resource connections, Spring provides a\ncorresponding `DataSource` proxy class for the target connection pool: see\n{spring-framework-api}/jdbc/datasource/LazyConnectionDataSourceProxy.html[`LazyConnectionDataSourceProxy`].\nThis is particularly useful for potentially empty transactions without actual statement\nexecution (never fetching an actual resource in such a scenario), and also in front of\na routing `DataSource` which means to take the transaction-synchronized read-only flag\nand/or isolation level into account (for example, `IsolationLevelDataSourceRouter`).\n\n`LazyConnectionDataSourceProxy` also provides special support for a read-only connection\npool to use during a read-only transaction, avoiding the overhead of switching the JDBC\nConnection's read-only flag at the beginning and end of every transaction when fetching\nit from the primary connection pool (which may be costly depending on the JDBC driver).\n\nNOTE: As of 5.3, Spring provides an extended `JdbcTransactionManager` variant which adds\nexception translation capabilities on commit/rollback (aligned with `JdbcTemplate`).\nWhere `DataSourceTransactionManager` will only ever throw `TransactionSystemException`\n(analogous to JTA), `JdbcTransactionManager` translates database locking failures etc to\ncorresponding `DataAccessException` subclasses. Note that application code needs to be\nprepared for such exceptions, not exclusively expecting `TransactionSystemException`.\nIn scenarios where that is the case, `JdbcTransactionManager` is the recommended choice.\n\nIn terms of exception behavior, `JdbcTransactionManager` is roughly equivalent to\n`JpaTransactionManager` and also to `R2dbcTransactionManager`, serving as an immediate\ncompanion/replacement for each other. `DataSourceTransactionManager` on the other hand\nis equivalent to `JtaTransactionManager` and can serve as a direct replacement there.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc", "title": "connections", "heading": "Using `DataSourceTransactionManager` / `JdbcTransactionManager`", "heading_level": 2, "file_order": 110, "section_index": 8, "content_hash": "932ef6292435dc1bdbcf549a6a8809f4acce623f1db0e4eece7a363e78c889a5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/connections.adoc"}}
{"id": "sha256:6474fbacbcb130c60849986f14b3f7368c93ba79f7d876c058f51a40d1cec2fe", "content": "[[jdbc-core]]\n\nThis section covers how to use the JDBC core classes to control basic JDBC processing,\nincluding error handling. It includes the following topics:\n\n* xref:data-access/jdbc/core.adoc#jdbc-JdbcTemplate[Using `JdbcTemplate`]\n* xref:data-access/jdbc/core.adoc#jdbc-NamedParameterJdbcTemplate[Using `NamedParameterJdbcTemplate`]\n* xref:data-access/jdbc/core.adoc#jdbc-JdbcClient[Unified JDBC Query/Update Operations: `JdbcClient`]\n* xref:data-access/jdbc/core.adoc#jdbc-SQLExceptionTranslator[Using `SQLExceptionTranslator`]\n* xref:data-access/jdbc/core.adoc#jdbc-statements-executing[Running Statements]\n* xref:data-access/jdbc/core.adoc#jdbc-statements-querying[Running Queries]\n* xref:data-access/jdbc/core.adoc#jdbc-updates[Updating the Database]\n* xref:data-access/jdbc/core.adoc#jdbc-auto-generated-keys[Retrieving Auto-generated Keys]\n\n[[jdbc-JdbcTemplate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "core", "heading_level": 1, "file_order": 111, "section_index": 0, "content_hash": "6474fbacbcb130c60849986f14b3f7368c93ba79f7d876c058f51a40d1cec2fe", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:ec06245dfc0b5a1361979bf6600b2a4833df8ad2231a961f864a7b3c83543889", "content": "`JdbcTemplate` is the central class in the JDBC core package. It handles the\ncreation and release of resources, which helps you avoid common errors, such as\nforgetting to close the connection. It performs the basic tasks of the core JDBC\nworkflow (such as statement creation and execution), leaving application code to provide\nSQL and extract results. The `JdbcTemplate` class:\n\n* Runs SQL queries\n* Updates statements and stored procedure calls\n* Performs iteration over `ResultSet` instances and extraction of returned parameter values.\n* Catches JDBC exceptions and translates them to the generic, more informative, exception\nhierarchy defined in the `org.springframework.dao` package. (See xref:data-access/dao.adoc#dao-exceptions[Consistent Exception Hierarchy].)\n\nWhen you use the `JdbcTemplate` for your code, you need only to implement callback\ninterfaces, giving them a clearly defined contract. Given a `Connection` provided by the\n`JdbcTemplate` class, the `PreparedStatementCreator` callback interface creates a prepared\nstatement, providing SQL and any necessary parameters. The same is true for the\n`CallableStatementCreator` interface, which creates callable statements. The\n`RowCallbackHandler` interface extracts values from each row of a `ResultSet`.\n\nYou can use `JdbcTemplate` within a DAO implementation through direct instantiation\nwith a `DataSource` reference, or you can configure it in a Spring IoC container and give it to\nDAOs as a bean reference.\n\nNOTE: The `DataSource` should always be configured as a bean in the Spring IoC container. In\nthe first case the bean is given to the service directly; in the second case it is given\nto the prepared template.\n\nAll SQL issued by this class is logged at the `DEBUG` level under the category\ncorresponding to the fully qualified class name of the template instance (typically\n`JdbcTemplate`, but it may be different if you use a custom subclass of the\n`JdbcTemplate` class).\n\nThe following sections provide some examples of `JdbcTemplate` usage. These examples\nare not an exhaustive list of all of the functionality exposed by the `JdbcTemplate`.\nSee the attendant {spring-framework-api}/jdbc/core/JdbcTemplate.html[javadoc] for that.\n\n[[jdbc-JdbcTemplate-examples-query]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "Using `JdbcTemplate`", "heading_level": 2, "file_order": 111, "section_index": 1, "content_hash": "ec06245dfc0b5a1361979bf6600b2a4833df8ad2231a961f864a7b3c83543889", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:fdfa0744c9c4879b92d1de357ff5cb41bb4745773dd9753da586d5042e86ff1e", "content": "The following query gets the number of rows in a relation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tint rowCount = this.jdbcTemplate.queryForObject(\"select count(*) from t_actor\", Integer.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval rowCount = jdbcTemplate.queryForObject<Int>(\"select count(*) from t_actor\")!!\n----\n======\n\nThe following query uses a bind variable:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tint countOfActorsNamedJoe = this.jdbcTemplate.queryForObject(\n \"select count(*) from t_actor where first_name = ?\", Integer.class, \"Joe\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval countOfActorsNamedJoe = jdbcTemplate.queryForObject<Int>(\n \"select count(*) from t_actor where first_name = ?\", arrayOf(\"Joe\"))!!\n----\n======\n\nThe following query looks for a `String`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString lastName = this.jdbcTemplate.queryForObject(\n \"select last_name from t_actor where id = ?\",\n String.class, 1212L);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval lastName = this.jdbcTemplate.queryForObject<String>(\n \"select last_name from t_actor where id = ?\",\n arrayOf(1212L))!!\n----\n======\n\nThe following query finds and populates a single domain object:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tActor actor = jdbcTemplate.queryForObject(\n \"select first_name, last_name from t_actor where id = ?\",\n (resultSet, rowNum) -> {\n Actor newActor = new Actor();\n newActor.setFirstName(resultSet.getString(\"first_name\"));\n newActor.setLastName(resultSet.getString(\"last_name\"));\n return newActor;\n },\n 1212L);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval actor = jdbcTemplate.queryForObject(\n \"select first_name, last_name from t_actor where id = ?\",\n arrayOf(1212L)) { rs, _ ->\n Actor(rs.getString(\"first_name\"), rs.getString(\"last_name\"))\n }\n----\n======\n\nThe following query finds and populates a list of domain objects:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tList<Actor> actors = this.jdbcTemplate.query(\n \"select first_name, last_name from t_actor\",\n (resultSet, rowNum) -> {\n Actor actor = new Actor();\n actor.setFirstName(resultSet.getString(\"first_name\"));\n actor.setLastName(resultSet.getString(\"last_name\"));\n return actor;\n });\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval actors = jdbcTemplate.query(\"select first_name, last_name from t_actor\") { rs, _ ->\n Actor(rs.getString(\"first_name\"), rs.getString(\"last_name\"))\n----\n======\n\nIf the last two snippets of code actually existed in the same application, it would make\nsense to remove the duplication present in the two `RowMapper` lambda expressions and\nextract them out into a single field that could then be referenced by DAO methods as needed.\nFor example, it may be better to write the preceding code snippet as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tprivate final RowMapper<Actor> actorRowMapper = (resultSet, rowNum) -> {\n Actor actor = new Actor();\n actor.setFirstName(resultSet.getString(\"first_name\"));\n actor.setLastName(resultSet.getString(\"last_name\"));\n return actor;\n\t};\n\n\tpublic List<Actor> findAllActors() {\n return this.jdbcTemplate.query(\"select first_name, last_name from t_actor\", actorRowMapper);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval actorMapper = RowMapper<Actor> { rs: ResultSet, rowNum: Int ->\n Actor(rs.getString(\"first_name\"), rs.getString(\"last_name\"))\n\t}\n\n\tfun findAllActors(): List<Actor> {\n return jdbcTemplate.query(\"select first_name, last_name from t_actor\", actorMapper)\n\t}\n----\n======\n\n[[jdbc-JdbcTemplate-examples-update]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "Querying (`SELECT`)", "heading_level": 3, "file_order": 111, "section_index": 2, "content_hash": "fdfa0744c9c4879b92d1de357ff5cb41bb4745773dd9753da586d5042e86ff1e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:517b05f2675c5f0501cf1940f10766553ac84b7cb82705b2490c33e9b5fd1f0a", "content": "You can use the `update(..)` method to perform insert, update, and delete operations.\nParameter values are usually provided as variable arguments or, alternatively, as an object array.\n\nThe following example inserts a new entry:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tthis.jdbcTemplate.update(\n \"insert into t_actor (first_name, last_name) values (?, ?)\",\n \"Leonor\", \"Watling\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tjdbcTemplate.update(\n \"insert into t_actor (first_name, last_name) values (?, ?)\",\n \"Leonor\", \"Watling\")\n----\n======\n\nThe following example updates an existing entry:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tthis.jdbcTemplate.update(\n \"update t_actor set last_name = ? where id = ?\",\n \"Banjo\", 5276L);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tjdbcTemplate.update(\n \"update t_actor set last_name = ? where id = ?\",\n \"Banjo\", 5276L)\n----\n======\n\nThe following example deletes an entry:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tthis.jdbcTemplate.update(\n \"delete from t_actor where id = ?\",\n Long.valueOf(actorId));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tjdbcTemplate.update(\"delete from t_actor where id = ?\", actorId.toLong())\n----\n======\n\n[[jdbc-JdbcTemplate-examples-other]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "Updating (`INSERT`, `UPDATE`, and `DELETE`) with `JdbcTemplate`", "heading_level": 3, "file_order": 111, "section_index": 3, "content_hash": "517b05f2675c5f0501cf1940f10766553ac84b7cb82705b2490c33e9b5fd1f0a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:dec3c787d0af4e21e5013f6d10322caf8356a07020199ca541f415b6cd52f4ce", "content": "You can use the `execute(..)` method to run any arbitrary SQL. Consequently, the\nmethod is often used for DDL statements. It is heavily overloaded with variants that take\ncallback interfaces, binding variable arrays, and so on. The following example creates a\ntable:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tthis.jdbcTemplate.execute(\"create table mytable (id integer, name varchar(100))\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tjdbcTemplate.execute(\"create table mytable (id integer, name varchar(100))\")\n----\n======\n\nThe following example invokes a stored procedure:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tthis.jdbcTemplate.update(\n \"call SUPPORT.REFRESH_ACTORS_SUMMARY(?)\",\n Long.valueOf(unionId));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tjdbcTemplate.update(\n \"call SUPPORT.REFRESH_ACTORS_SUMMARY(?)\",\n unionId.toLong())\n----\n======\n\nMore sophisticated stored procedure support is xref:data-access/jdbc/object.adoc#jdbc-StoredProcedure[covered later].\n\n[[jdbc-jdbctemplate-idioms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "Other `JdbcTemplate` Operations", "heading_level": 3, "file_order": 111, "section_index": 4, "content_hash": "dec3c787d0af4e21e5013f6d10322caf8356a07020199ca541f415b6cd52f4ce", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:c4aa94cb03f9ffb2c1ca93fe67f3d561b3867d9bffb68340372e2205ce48e2c2", "content": "Instances of the `JdbcTemplate` class are thread-safe, once configured. This is\nimportant because it means that you can configure a single instance of a `JdbcTemplate`\nand then safely inject this shared reference into multiple DAOs (or repositories).\nThe `JdbcTemplate` is stateful, in that it maintains a reference to a `DataSource`, but\nthis state is not conversational state.\n\nA common practice when using the `JdbcTemplate` class (and the associated\nxref:data-access/jdbc/core.adoc#jdbc-NamedParameterJdbcTemplate[`NamedParameterJdbcTemplate`] class) is to\nconfigure a `DataSource` in your Spring configuration file and then dependency-inject\nthat shared `DataSource` bean into your DAO classes. The `JdbcTemplate` is created in\nthe setter for the `DataSource` or in the constructor. This leads to DAOs that resemble the following:\n\ninclude-code::./JdbcCorporateEventDao[tag=snippet,indent=0]\n\nThe following example shows the corresponding configuration:\n\ninclude-code::./JdbcCorporateEventDaoConfiguration[tag=snippet,indent=0]\n\nAn alternative to explicit configuration is to use component-scanning and annotation\nsupport for dependency injection. In this case, you can annotate the class with `@Repository`\n(which makes it a candidate for component-scanning). The following example shows how to do so:\n\ninclude-code::./JdbcCorporateEventRepository[tag=snippet,indent=0]\n\nThe following example shows the corresponding configuration:\n\ninclude-code::./JdbcCorporateEventRepositoryConfiguration[tag=snippet,indent=0]\n\nIf you use Spring's `JdbcDaoSupport` class and your various JDBC-backed DAO classes\nextend from it, your sub-class inherits a `setDataSource(..)` method from the\n`JdbcDaoSupport` class. You can choose whether to inherit from this class. The\n`JdbcDaoSupport` class is provided as a convenience only.\n\nRegardless of which of the above template initialization styles you choose to use (or\nnot), it is seldom necessary to create a new instance of a `JdbcTemplate` class each\ntime you want to run SQL. Once configured, a `JdbcTemplate` instance is thread-safe.\nIf your application accesses multiple databases, you may want multiple `JdbcTemplate`\ninstances, which requires multiple `DataSources` and, subsequently, multiple differently\nconfigured `JdbcTemplate` instances.\n\n[[jdbc-NamedParameterJdbcTemplate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "`JdbcTemplate` Best Practices", "heading_level": 3, "file_order": 111, "section_index": 5, "content_hash": "c4aa94cb03f9ffb2c1ca93fe67f3d561b3867d9bffb68340372e2205ce48e2c2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:6e99eb055babaaee2ce9ead7ebdb5c7f7031c194790022011ee17e24ee3d0603", "content": "The `NamedParameterJdbcTemplate` class adds support for programming JDBC statements\nby using named parameters, as opposed to programming JDBC statements using only classic\nplaceholder ( `'?'`) arguments. The `NamedParameterJdbcTemplate` class wraps a\n`JdbcTemplate` and delegates to the wrapped `JdbcTemplate` to do much of its work. This\nsection describes only those areas of the `NamedParameterJdbcTemplate` class that differ\nfrom the `JdbcTemplate` itself -- namely, programming JDBC statements by using named\nparameters. The following example shows how to use `NamedParameterJdbcTemplate`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// some JDBC-backed DAO class...\n\tprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\n\tpublic void setDataSource(DataSource dataSource) {\n this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n\t}\n\n\tpublic int countOfActorsByFirstName(String firstName) {\n String sql = \"select count(*) from t_actor where first_name = :first_name\";\n SqlParameterSource namedParameters = new MapSqlParameterSource(\"first_name\", firstName);\n return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tprivate val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)\n\n\tfun countOfActorsByFirstName(firstName: String): Int {\n val sql = \"select count(*) from t_actor where first_name = :first_name\"\n val namedParameters = MapSqlParameterSource(\"first_name\", firstName)\n return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!!\n\t}\n----\n======\n\nNotice the use of the named parameter notation in the value assigned to the `sql`\nvariable and the corresponding value that is plugged into the `namedParameters`\nvariable (of type `MapSqlParameterSource`).\n\nAlternatively, you can pass along named parameters and their corresponding values to a\n`NamedParameterJdbcTemplate` instance by using the `Map`-based style. The remaining\nmethods exposed by the `NamedParameterJdbcOperations` and implemented by the\n`NamedParameterJdbcTemplate` class follow a similar pattern and are not covered here.\n\nThe following example shows the use of the `Map`-based style:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// some JDBC-backed DAO class...\n\tprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\n\tpublic void setDataSource(DataSource dataSource) {\n this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n\t}\n\n\tpublic int countOfActorsByFirstName(String firstName) {\n String sql = \"select count(*) from t_actor where first_name = :first_name\";\n Map<String, String> namedParameters = Collections.singletonMap(\"first_name\", firstName);\n return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// some JDBC-backed DAO class...\n\tprivate val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)\n\n\tfun countOfActorsByFirstName(firstName: String): Int {\n val sql = \"select count(*) from t_actor where first_name = :first_name\"\n val namedParameters = mapOf(\"first_name\" to firstName)\n return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!!\n\t}\n----\n======\n\nOne nice feature related to the `NamedParameterJdbcTemplate` (and existing in the same\nJava package) is the `SqlParameterSource` interface. You have already seen an example of\nan implementation of this interface in one of the previous code snippets (the\n`MapSqlParameterSource` class). An `SqlParameterSource` is a source of named parameter\nvalues to a `NamedParameterJdbcTemplate`. The `MapSqlParameterSource` class is a\nsimple implementation that is an adapter around a `java.util.Map`, where the keys\nare the parameter names and the values are the parameter values.\n\nAnother `SqlParameterSource` implementation is the `BeanPropertySqlParameterSource`\nclass. This class wraps an arbitrary JavaBean (that is, an instance of a class that\nadheres to https://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html[the\nJavaBean conventions]) and uses the properties of the wrapped JavaBean as the source\nof named parameter values.\n\nThe following example shows a typical JavaBean:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class Actor {\n\n private Long id;\n private String firstName;\n private String lastName;\n\n public String getFirstName() {\n return this.firstName;\n }\n\n public String getLastName() {\n return this.lastName;\n }\n\n public Long getId() {\n return this.id;\n }\n\n // setters omitted...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tdata class Actor(val id: Long, val firstName: String, val lastName: String)\n----\n======\n\nThe following example uses a `NamedParameterJdbcTemplate` to return the count of the\nmembers of the class shown in the preceding example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// some JDBC-backed DAO class...\n\tprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;\n\n\tpublic void setDataSource(DataSource dataSource) {\n this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\n\t}\n\n\tpublic int countOfActors(Actor exampleActor) {\n // notice how the named parameters match the properties of the above 'Actor' class\n String sql = \"select count(*) from t_actor where first_name = :firstName and last_name = :lastName\";\n SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);\n return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// some JDBC-backed DAO class...\n\tprivate val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)\n\n\tprivate val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)\n\n\tfun countOfActors(exampleActor: Actor): Int {\n // notice how the named parameters match the properties of the above 'Actor' class\n val sql = \"select count(*) from t_actor where first_name = :firstName and last_name = :lastName\"\n val namedParameters = BeanPropertySqlParameterSource(exampleActor)\n return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!!\n\t}\n----\n======\n\nRemember that the `NamedParameterJdbcTemplate` class wraps a classic `JdbcTemplate`\ntemplate. If you need access to the wrapped `JdbcTemplate` instance to access\nfunctionality that is present only in the `JdbcTemplate` class, you can use the\n`getJdbcOperations()` method to access the wrapped `JdbcTemplate` through the\n`JdbcOperations` interface.\n\nSee also xref:data-access/jdbc/core.adoc#jdbc-jdbctemplate-idioms[`JdbcTemplate` Best Practices]\nfor guidelines on using the `NamedParameterJdbcTemplate` class in the context of an application.\n\n[[jdbc-JdbcClient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "Using `NamedParameterJdbcTemplate`", "heading_level": 2, "file_order": 111, "section_index": 6, "content_hash": "6e99eb055babaaee2ce9ead7ebdb5c7f7031c194790022011ee17e24ee3d0603", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:89ada8dfdd09528cb6d674daddc0b25a2bcd97e248dc23fbd8b759d74414c950", "content": "As of 6.1, the named parameter statements of `NamedParameterJdbcTemplate` and the positional\nparameter statements of a regular `JdbcTemplate` are available through a unified client API\nwith a fluent interaction model.\n\nFor example, with positional parameters:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tprivate JdbcClient jdbcClient = JdbcClient.create(dataSource);\n\n\tpublic int countOfActorsByFirstName(String firstName) {\n return this.jdbcClient.sql(\"select count(*) from t_actor where first_name = ?\")\n .param(firstName)\n .query(Integer.class).single();\n\t}\n----\n\nFor example, with named parameters:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tprivate JdbcClient jdbcClient = JdbcClient.create(dataSource);\n\n\tpublic int countOfActorsByFirstName(String firstName) {\n return this.jdbcClient.sql(\"select count(*) from t_actor where first_name = :firstName\")\n .param(\"firstName\", firstName)\n .query(Integer.class).single();\n\t}\n----\n\n`RowMapper` capabilities are available as well, with flexible result resolution:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tList<Actor> actors = this.jdbcClient.sql(\"select first_name, last_name from t_actor\")\n .query((rs, rowNum) -> new Actor(rs.getString(\"first_name\"), rs.getString(\"last_name\")))\n .list();\n----\n\nInstead of a custom `RowMapper`, you may also specify a class to map to.\nFor example, assuming that `Actor` has `firstName` and `lastName` properties\nas a record class, a custom constructor, bean properties, or plain fields:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tList<Actor> actors = this.jdbcClient.sql(\"select first_name, last_name from t_actor\")\n .query(Actor.class)\n .list();\n----\n\nWith a required single object result:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tActor actor = this.jdbcClient.sql(\"select first_name, last_name from t_actor where id = ?\")\n .param(1212L)\n .query(Actor.class)\n .single();\n----\n\nWith a `java.util.Optional` result:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tOptional<Actor> actor = this.jdbcClient.sql(\"select first_name, last_name from t_actor where id = ?\")\n .param(1212L)\n .query(Actor.class)\n .optional();\n----\n\nAnd for an update statement:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tthis.jdbcClient.sql(\"insert into t_actor (first_name, last_name) values (?, ?)\")\n .param(\"Leonor\").param(\"Watling\")\n .update();\n----\n\nOr an update statement with named parameters:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tthis.jdbcClient.sql(\"insert into t_actor (first_name, last_name) values (:firstName, :lastName)\")\n .param(\"firstName\", \"Leonor\").param(\"lastName\", \"Watling\")\n .update();\n----\n\nInstead of individual named parameters, you may also specify a parameter source object â€“\nfor example, a record class, a class with bean properties, or a plain field holder which\nprovides `firstName` and `lastName` properties, such as the `Actor` class from above:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tthis.jdbcClient.sql(\"insert into t_actor (first_name, last_name) values (:firstName, :lastName)\")\n .paramSource(new Actor(\"Leonor\", \"Watling\"))\n .update();\n----\n\nThe automatic `Actor` class mapping for parameters as well as the query results above is\nprovided through implicit `SimplePropertySqlParameterSource` and `SimplePropertyRowMapper`\nstrategies which are also available for direct use. They can serve as a common replacement\nfor `BeanPropertySqlParameterSource` and `BeanPropertyRowMapper`/`DataClassRowMapper`,\nalso with `JdbcTemplate` and `NamedParameterJdbcTemplate` themselves.\n\nNOTE: `JdbcClient` is a flexible but simplified facade for JDBC query/update statements.\nAdvanced capabilities such as batch inserts and stored procedure calls typically require\nextra customization: consider Spring's `SimpleJdbcInsert` and `SimpleJdbcCall` classes or\nplain direct `JdbcTemplate` usage for any such capabilities not available in `JdbcClient`.\n\n[[jdbc-SQLExceptionTranslator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "Unified JDBC Query/Update Operations: `JdbcClient`", "heading_level": 2, "file_order": 111, "section_index": 7, "content_hash": "89ada8dfdd09528cb6d674daddc0b25a2bcd97e248dc23fbd8b759d74414c950", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:f7f1e570fe79448a1ffca5fa507bea03d08f0e533ff3e2c93dd21a224d02ed77", "content": "`SQLExceptionTranslator` is an interface to be implemented by classes that can translate\nbetween ``SQLException``s and Spring's own `org.springframework.dao.DataAccessException`,\nwhich is agnostic in regard to data access strategy. Implementations can be generic (for\nexample, using SQLState codes for JDBC) or proprietary (for example, using Oracle error\ncodes) for greater precision. This exception translation mechanism is used behind the\ncommon `JdbcTemplate` and `JdbcTransactionManager` entry points which do not\npropagate `SQLException` but rather `DataAccessException`.\n\nNOTE: As of 6.0, the default exception translator is `SQLExceptionSubclassTranslator`,\ndetecting JDBC 4 `SQLException` subclasses with a few extra checks, and with a fallback\nto `SQLState` introspection through `SQLStateSQLExceptionTranslator`. This is usually\nsufficient for common database access and does not require vendor-specific detection.\nFor backwards compatibility, consider using `SQLErrorCodeSQLExceptionTranslator` as\ndescribed below, potentially with custom error code mappings.\n\n`SQLErrorCodeSQLExceptionTranslator` is the implementation of `SQLExceptionTranslator`\nthat is used by default when a file named `sql-error-codes.xml` is present in the root\nof the classpath. This implementation uses specific vendor codes. It is more precise than\n`SQLState` or `SQLException` subclass translation. The error code translations are based\non codes held in a JavaBean type class called `SQLErrorCodes`. This class is created and\npopulated by an `SQLErrorCodesFactory`, which (as the name suggests) is a factory for\ncreating `SQLErrorCodes` based on the contents of a configuration file named\n`sql-error-codes.xml`. This file is populated with vendor codes and based on the\n`DatabaseProductName` taken from `DatabaseMetaData`. The codes for the actual\ndatabase you are using are used.\n\nThe `SQLErrorCodeSQLExceptionTranslator` applies matching rules in the following sequence:\n\n. Any custom translation implemented by a subclass. Normally, the provided concrete\n `SQLErrorCodeSQLExceptionTranslator` is used, so this rule does not apply. It\n applies only if you have actually provided a subclass implementation.\n. Any custom implementation of the `SQLExceptionTranslator` interface that is provided\n as the `customSqlExceptionTranslator` property of the `SQLErrorCodes` class.\n. The list of instances of the `CustomSQLErrorCodesTranslation` class (provided for the\n `customTranslations` property of the `SQLErrorCodes` class) are searched for a match.\n. Error code matching is applied.\n. Use the fallback translator. `SQLExceptionSubclassTranslator` is the default fallback\n translator. If this translation is not available, the next fallback translator is\n the `SQLStateSQLExceptionTranslator`.\n\nNOTE: The `SQLErrorCodesFactory` is used by default to define error codes and custom\nexception translations. They are looked up in a file named `sql-error-codes.xml` from the\nclasspath, and the matching `SQLErrorCodes` instance is located based on the database\nname from the database metadata of the database in use.\n\nYou can extend `SQLErrorCodeSQLExceptionTranslator`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {\n\n protected DataAccessException customTranslate(String task, String sql, SQLException sqlEx) {\n if (sqlEx.getErrorCode() == -12345) {\n return new DeadlockLoserDataAccessException(task, sqlEx);\n }\n return null;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass CustomSQLErrorCodesTranslator : SQLErrorCodeSQLExceptionTranslator() {\n\n override fun customTranslate(task: String, sql: String?, sqlEx: SQLException): DataAccessException? {\n if (sqlEx.errorCode == -12345) {\n return DeadlockLoserDataAccessException(task, sqlEx)\n }\n return null\n }\n\t}\n----\n======\n\nIn the preceding example, the specific error code (`-12345`) is translated while\nother errors are left to be translated by the default translator implementation.\nTo use this custom translator, you must pass it to the `JdbcTemplate` through the\nmethod `setExceptionTranslator`, and you must use this `JdbcTemplate` for all of the\ndata access processing where this translator is needed. The following example shows\nhow you can use this custom translator:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tprivate JdbcTemplate jdbcTemplate;\n\n\tpublic void setDataSource(DataSource dataSource) {\n // create a JdbcTemplate and set data source\n this.jdbcTemplate = new JdbcTemplate();\n this.jdbcTemplate.setDataSource(dataSource);\n\n // create a custom translator and set the DataSource for the default translation lookup\n CustomSQLErrorCodesTranslator tr = new CustomSQLErrorCodesTranslator();\n tr.setDataSource(dataSource);\n this.jdbcTemplate.setExceptionTranslator(tr);\n\t}\n\n\tpublic void updateShippingCharge(long orderId, long pct) {\n // use the prepared JdbcTemplate for this update\n this.jdbcTemplate.update(\"update orders\" +\n \" set shipping_charge = shipping_charge * ? / 100\" +\n \" where id = ?\", pct, orderId);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// create a JdbcTemplate and set data source\n\tprivate val jdbcTemplate = JdbcTemplate(dataSource).apply {\n // create a custom translator and set the DataSource for the default translation lookup\n exceptionTranslator = CustomSQLErrorCodesTranslator().apply {\n this.dataSource = dataSource\n }\n\t}\n\n\tfun updateShippingCharge(orderId: Long, pct: Long) {\n // use the prepared JdbcTemplate for this update\n this.jdbcTemplate!!.update(\"update orders\" +\n \" set shipping_charge = shipping_charge * ? / 100\" +\n \" where id = ?\", pct, orderId)\n\t}\n----\n======\n\nThe custom translator is passed a data source in order to look up the error codes in\n`sql-error-codes.xml`.\n\n[[jdbc-statements-executing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "Using `SQLExceptionTranslator`", "heading_level": 2, "file_order": 111, "section_index": 8, "content_hash": "f7f1e570fe79448a1ffca5fa507bea03d08f0e533ff3e2c93dd21a224d02ed77", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:c1d81c9103583d5cd652955fbf2959abc032a84ec84d3577079488b2b0d290d2", "content": "Running an SQL statement requires very little code. You need a `DataSource` and a\n`JdbcTemplate`, including the convenience methods that are provided with the\n`JdbcTemplate`. The following example shows what you need to include for a minimal but\nfully functional class that creates a new table:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport javax.sql.DataSource;\n\timport org.springframework.jdbc.core.JdbcTemplate;\n\n\tpublic class ExecuteAStatement {\n\n private JdbcTemplate jdbcTemplate;\n\n public void setDataSource(DataSource dataSource) {\n this.jdbcTemplate = new JdbcTemplate(dataSource);\n }\n\n public void doExecute() {\n this.jdbcTemplate.execute(\"create table mytable (id integer, name varchar(100))\");\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport javax.sql.DataSource\n\timport org.springframework.jdbc.core.JdbcTemplate\n\n\tclass ExecuteAStatement(dataSource: DataSource) {\n\n private val jdbcTemplate = JdbcTemplate(dataSource)\n\n fun doExecute() {\n jdbcTemplate.execute(\"create table mytable (id integer, name varchar(100))\")\n }\n\t}\n----\n======\n\n[[jdbc-statements-querying]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "Running Statements", "heading_level": 2, "file_order": 111, "section_index": 9, "content_hash": "c1d81c9103583d5cd652955fbf2959abc032a84ec84d3577079488b2b0d290d2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:770c29a4de4540278b625af667573f7ff36b3a1e59871261e9e2bb119ecdcb1c", "content": "Some query methods return a single value. To retrieve a count or a specific value from\none row, use `queryForObject(..)`. The latter converts the returned JDBC `Type` to the\nJava class that is passed in as an argument. If the type conversion is invalid, an\n`InvalidDataAccessApiUsageException` is thrown. The following example contains two\nquery methods, one for an `int` and one that queries for a `String`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport javax.sql.DataSource;\n\timport org.springframework.jdbc.core.JdbcTemplate;\n\n\tpublic class RunAQuery {\n\n private JdbcTemplate jdbcTemplate;\n\n public void setDataSource(DataSource dataSource) {\n this.jdbcTemplate = new JdbcTemplate(dataSource);\n }\n\n public int getCount() {\n return this.jdbcTemplate.queryForObject(\"select count(*) from mytable\", Integer.class);\n }\n\n public String getName() {\n return this.jdbcTemplate.queryForObject(\"select name from mytable\", String.class);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nimport javax.sql.DataSource\nimport org.springframework.jdbc.core.JdbcTemplate\n\nclass RunAQuery(dataSource: DataSource) {\n\n\tprivate val jdbcTemplate = JdbcTemplate(dataSource)\n\n\tval count: Int\n get() = jdbcTemplate.queryForObject(\"select count(*) from mytable\")!!\n\n\tval name: String?\n get() = jdbcTemplate.queryForObject(\"select name from mytable\")\n}\n----\n======\n\nIn addition to the single result query methods, several methods return a list with an\nentry for each row that the query returned. The most generic method is `queryForList(..)`,\nwhich returns a `List` where each element is a `Map` containing one entry for each column,\nusing the column name as the key. If you add a method to the preceding example to retrieve a\nlist of all the rows, it might be as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tprivate JdbcTemplate jdbcTemplate;\n\n\tpublic void setDataSource(DataSource dataSource) {\n this.jdbcTemplate = new JdbcTemplate(dataSource);\n\t}\n\n\tpublic List<Map<String, Object>> getList() {\n return this.jdbcTemplate.queryForList(\"select * from mytable\");\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tprivate val jdbcTemplate = JdbcTemplate(dataSource)\n\n\tfun getList(): List<Map<String, Any>> {\n return jdbcTemplate.queryForList(\"select * from mytable\")\n\t}\n----\n======\n\nThe returned list would resemble the following:\n\n[literal,subs=\"verbatim,quotes\"]\n----\n[{name=Bob, id=1}, {name=Mary, id=2}]\n----\n\n[[jdbc-updates]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "Running Queries", "heading_level": 2, "file_order": 111, "section_index": 10, "content_hash": "770c29a4de4540278b625af667573f7ff36b3a1e59871261e9e2bb119ecdcb1c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:45c55683a754110e53dee2cf6f3cfec06e7f731ddd5bbf7d629fbee4fe56bd48", "content": "The following example updates a column for a certain primary key:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport javax.sql.DataSource;\n\timport org.springframework.jdbc.core.JdbcTemplate;\n\n\tpublic class ExecuteAnUpdate {\n\n private JdbcTemplate jdbcTemplate;\n\n public void setDataSource(DataSource dataSource) {\n this.jdbcTemplate = new JdbcTemplate(dataSource);\n }\n\n public void setName(int id, String name) {\n this.jdbcTemplate.update(\"update mytable set name = ? where id = ?\", name, id);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport javax.sql.DataSource\n\timport org.springframework.jdbc.core.JdbcTemplate\n\n\tclass ExecuteAnUpdate(dataSource: DataSource) {\n\n private val jdbcTemplate = JdbcTemplate(dataSource)\n\n fun setName(id: Int, name: String) {\n jdbcTemplate.update(\"update mytable set name = ? where id = ?\", name, id)\n }\n\t}\n----\n======\n\nIn the preceding example,\nan SQL statement has placeholders for row parameters. You can pass the parameter values\nin as varargs or, alternatively, as an array of objects. Thus, you should explicitly wrap primitives\nin the primitive wrapper classes, or you should use auto-boxing.\n\n[[jdbc-auto-generated-keys]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "Updating the Database", "heading_level": 2, "file_order": 111, "section_index": 11, "content_hash": "45c55683a754110e53dee2cf6f3cfec06e7f731ddd5bbf7d629fbee4fe56bd48", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:282dbf393475aa5dd440b807570352bebce260f88e3dc61ca035787ea350a191", "content": "An `update()` convenience method supports the retrieval of primary keys generated by the\ndatabase. This support is part of the JDBC 3.0 standard. See Chapter 13.6 of the\nspecification for details. The method takes a `PreparedStatementCreator` as its first\nargument, and this is the way the required insert statement is specified. The other\nargument is a `KeyHolder`, which contains the generated key on successful return from the\nupdate. There is no standard single way to create an appropriate `PreparedStatement`\n(which explains why the method signature is the way it is). The following example works\non Oracle but may not work on other platforms:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfinal String INSERT_SQL = \"insert into my_test (name) values(?)\";\n\tfinal String name = \"Rob\";\n\n\tKeyHolder keyHolder = new GeneratedKeyHolder();\n\tjdbcTemplate.update(connection -> {\n PreparedStatement ps = connection.prepareStatement(INSERT_SQL, new String[] { \"id\" });\n ps.setString(1, name);\n return ps;\n\t}, keyHolder);\n\n\t// keyHolder.getKey() now contains the generated key\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval INSERT_SQL = \"insert into my_test (name) values(?)\"\n\tval name = \"Rob\"\n\n\tval keyHolder = GeneratedKeyHolder()\n\tjdbcTemplate.update({\n it.prepareStatement (INSERT_SQL, arrayOf(\"id\")).apply { setString(1, name) }\n\t}, keyHolder)\n\n\t// keyHolder.getKey() now contains the generated key\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc", "title": "core", "heading": "Retrieving Auto-generated Keys", "heading_level": 2, "file_order": 111, "section_index": 12, "content_hash": "282dbf393475aa5dd440b807570352bebce260f88e3dc61ca035787ea350a191", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/core.adoc"}}
{"id": "sha256:ee91742319caf45be4a858eb9233c116217d7752bfdbc441de6868701cefce99", "content": "[[jdbc-embedded-database-support]]\n\nThe `org.springframework.jdbc.datasource.embedded` package provides support for embedded\nJava database engines. Support for https://www.hsqldb.org[HSQL],\nhttps://www.h2database.com[H2], and https://db.apache.org/derby[Derby] is provided\nnatively. You can also use an extensible API to plug in new embedded database types and\n`DataSource` implementations.\n\n[[jdbc-why-embedded-database]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc", "title": "embedded-database-support", "heading": "embedded-database-support", "heading_level": 1, "file_order": 112, "section_index": 0, "content_hash": "ee91742319caf45be4a858eb9233c116217d7752bfdbc441de6868701cefce99", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc"}}
{"id": "sha256:f402a8670430a5328cab00576c6000286ce4554715238a1fcdd66451cb6727c1", "content": "An embedded database can be useful during the development phase of a project because of its\nlightweight nature. Benefits include ease of configuration, quick startup time,\ntestability, and the ability to rapidly evolve your SQL during development.\n\n[[jdbc-embedded-database]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc", "title": "embedded-database-support", "heading": "Why Use an Embedded Database?", "heading_level": 2, "file_order": 112, "section_index": 1, "content_hash": "f402a8670430a5328cab00576c6000286ce4554715238a1fcdd66451cb6727c1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc"}}
{"id": "sha256:00be789b53067ec1338311ace0086baee7ab8f72e2ce5c12a851311a10ff5ab7", "content": "You can expose an embedded database instance as a bean as the following example shows:\n\ninclude-code::./JdbcEmbeddedDatabaseConfiguration[tag=snippet,indent=0]\n\nThe preceding configuration creates an embedded H2 database that is populated with SQL from\nthe `schema.sql` and `test-data.sql` resources in the root of the classpath. In addition, as\na best practice, the embedded database is assigned a uniquely generated name. The\nembedded database is made available to the Spring container as a bean of type\n`javax.sql.DataSource` that can then be injected into data access objects as needed.\n\nSee the {spring-framework-api}/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html[javadoc for `EmbeddedDatabaseBuilder`]\nfor further details on all supported options.\n\n[[jdbc-embedded-database-types]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc", "title": "embedded-database-support", "heading": "Creating an Embedded Database", "heading_level": 2, "file_order": 112, "section_index": 2, "content_hash": "00be789b53067ec1338311ace0086baee7ab8f72e2ce5c12a851311a10ff5ab7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc"}}
{"id": "sha256:ce778aac428719dbb31ba0174a0376df9c15420359658eec7ea82eddb71dd882", "content": "This section covers how to select one of the three embedded databases that Spring\nsupports. It includes the following topics:\n\n* xref:data-access/jdbc/embedded-database-support.adoc#jdbc-embedded-database-using-HSQL[Using HSQL]\n* xref:data-access/jdbc/embedded-database-support.adoc#jdbc-embedded-database-using-H2[Using H2]\n* xref:data-access/jdbc/embedded-database-support.adoc#jdbc-embedded-database-using-Derby[Using Derby]\n\n[[jdbc-embedded-database-using-HSQL]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc", "title": "embedded-database-support", "heading": "Selecting the Embedded Database Type", "heading_level": 2, "file_order": 112, "section_index": 3, "content_hash": "ce778aac428719dbb31ba0174a0376df9c15420359658eec7ea82eddb71dd882", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc"}}
{"id": "sha256:2178dfba386dfb9e897e5c2f91088e3aa4bb3ddc8e1c2c3da57cc77a8e66e0b9", "content": "Spring supports HSQL 1.8.0 and above. HSQL is the default embedded database if no type is\nexplicitly specified. To specify HSQL explicitly, set the `type` attribute of the\n`embedded-database` tag to `HSQL`. If you use the builder API, call the\n`setType(EmbeddedDatabaseType)` method with `EmbeddedDatabaseType.HSQL`.\n\n[[jdbc-embedded-database-using-H2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc", "title": "embedded-database-support", "heading": "Using HSQL", "heading_level": 3, "file_order": 112, "section_index": 4, "content_hash": "2178dfba386dfb9e897e5c2f91088e3aa4bb3ddc8e1c2c3da57cc77a8e66e0b9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc"}}
{"id": "sha256:044db806996602ac3b45f6cdec9048ba779ccd58fa4296e778615dd2afdb26b1", "content": "Spring supports the H2 database. To enable H2, set the `type` attribute of the\n`embedded-database` tag to `H2`. If you use the builder API, call the\n`setType(EmbeddedDatabaseType)` method with `EmbeddedDatabaseType.H2`.\n\n[[jdbc-embedded-database-using-Derby]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc", "title": "embedded-database-support", "heading": "Using H2", "heading_level": 3, "file_order": 112, "section_index": 5, "content_hash": "044db806996602ac3b45f6cdec9048ba779ccd58fa4296e778615dd2afdb26b1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc"}}
{"id": "sha256:d85596c46d93ec9010705e3aa63cf1c19fd8a7b6c8a7e0be783bc09812cdad56", "content": "Spring supports Apache Derby 10.5 and above. To enable Derby, set the `type`\nattribute of the `embedded-database` tag to `DERBY`. If you use the builder API,\ncall the `setType(EmbeddedDatabaseType)` method with `EmbeddedDatabaseType.DERBY`.\n\n[[jdbc-embedded-database-types-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc", "title": "embedded-database-support", "heading": "Using Derby", "heading_level": 3, "file_order": 112, "section_index": 6, "content_hash": "d85596c46d93ec9010705e3aa63cf1c19fd8a7b6c8a7e0be783bc09812cdad56", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc"}}
{"id": "sha256:c3b7b6f3e15b37961ee07bcbde35b76e02a02f0ef462f10908df876ed4b56ffb", "content": "While each supported type comes with default connection settings, it is possible\nto customize them if necessary. The following example uses H2 with a custom driver:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class DataSourceConfig {\n\n @Bean\n public DataSource dataSource() {\n return new EmbeddedDatabaseBuilder()\n .setDatabaseConfigurer(EmbeddedDatabaseConfigurers\n .customizeConfigurer(H2, this::customize))\n .addScript(\"schema.sql\")\n .build();\n }\n\n private EmbeddedDatabaseConfigurer customize(EmbeddedDatabaseConfigurer defaultConfigurer) {\n return new EmbeddedDatabaseConfigurerDelegate(defaultConfigurer) {\n @Override\n public void configureConnectionProperties(ConnectionProperties properties, String databaseName) {\n super.configureConnectionProperties(properties, databaseName);\n properties.setDriverClass(CustomDriver.class);\n }\n };\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass DataSourceConfig {\n\n @Bean\n fun dataSource(): DataSource {\n return EmbeddedDatabaseBuilder()\n .setDatabaseConfigurer(EmbeddedDatabaseConfigurers\n .customizeConfigurer(EmbeddedDatabaseType.H2) { this.customize(it) })\n .addScript(\"schema.sql\")\n .build()\n }\n\n private fun customize(defaultConfigurer: EmbeddedDatabaseConfigurer): EmbeddedDatabaseConfigurer {\n return object : EmbeddedDatabaseConfigurerDelegate(defaultConfigurer) {\n override fun configureConnectionProperties(\n properties: ConnectionProperties,\n databaseName: String\n ) {\n super.configureConnectionProperties(properties, databaseName)\n properties.setDriverClass(CustomDriver::class.java)\n }\n }\n }\n\t}\n----\n======\n\n[[jdbc-embedded-database-dao-testing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc", "title": "embedded-database-support", "heading": "Customizing the Embedded Database Type", "heading_level": 2, "file_order": 112, "section_index": 7, "content_hash": "c3b7b6f3e15b37961ee07bcbde35b76e02a02f0ef462f10908df876ed4b56ffb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc"}}
{"id": "sha256:c47b252a9e3eb0da739f3eda8aac91991431541da378a39171f552b718dada98", "content": "Embedded databases provide a lightweight way to test data access code. The next example is a\ndata access integration test template that uses an embedded database. Using such a template\ncan be useful for one-offs when the embedded database does not need to be reused across test\nclasses. However, if you wish to create an embedded database that is shared within a test suite,\nconsider using the xref:testing/testcontext-framework.adoc[Spring TestContext Framework] and\nconfiguring the embedded database as a bean in the Spring `ApplicationContext` as described\nin xref:data-access/jdbc/embedded-database-support.adoc#jdbc-embedded-database[Creating an Embedded Database].\nThe following listing shows the test template:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class DataAccessIntegrationTestTemplate {\n\n private EmbeddedDatabase db;\n\n @BeforeEach\n public void setUp() {\n // creates an HSQL in-memory database populated from default scripts\n // classpath:schema.sql and classpath:data.sql\n db = new EmbeddedDatabaseBuilder()\n .generateUniqueName(true)\n .addDefaultScripts()\n .build();\n }\n\n @Test\n public void testDataAccess() {\n JdbcTemplate template = new JdbcTemplate(db);\n template.query( /* ... */ );\n }\n\n @AfterEach\n public void tearDown() {\n db.shutdown();\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass DataAccessIntegrationTestTemplate {\n\n private lateinit var db: EmbeddedDatabase\n\n @BeforeEach\n fun setUp() {\n // creates an HSQL in-memory database populated from default scripts\n // classpath:schema.sql and classpath:data.sql\n db = EmbeddedDatabaseBuilder()\n .generateUniqueName(true)\n .addDefaultScripts()\n .build()\n }\n\n @Test\n fun testDataAccess() {\n val template = JdbcTemplate(db)\n template.query( /* ... */)\n }\n\n @AfterEach\n fun tearDown() {\n db.shutdown()\n }\n\t}\n----\n======\n\n[[jdbc-embedded-database-unique-names]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc", "title": "embedded-database-support", "heading": "Testing Data Access Logic with an Embedded Database", "heading_level": 2, "file_order": 112, "section_index": 8, "content_hash": "c47b252a9e3eb0da739f3eda8aac91991431541da378a39171f552b718dada98", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc"}}
{"id": "sha256:415533c98e753a1fb4575345e0eb832eab179ae06d3720cd11ce28c8c39bb491", "content": "Development teams often encounter errors with embedded databases if their test suite\ninadvertently attempts to recreate additional instances of the same database. This can\nhappen quite easily if an XML configuration file or `@Configuration` class is responsible\nfor creating an embedded database and the corresponding configuration is then reused\nacross multiple testing scenarios within the same test suite (that is, within the same JVM\nprocess) -- for example, integration tests against embedded databases whose\n`ApplicationContext` configuration differs only with regard to which bean definition\nprofiles are active.\n\nThe root cause of such errors is the fact that Spring's `EmbeddedDatabaseFactory` (used\ninternally by both the `<jdbc:embedded-database>` XML namespace element and the\n`EmbeddedDatabaseBuilder` for Java configuration) sets the name of the embedded database to\n`testdb` if not otherwise specified. For the case of `<jdbc:embedded-database>`, the\nembedded database is typically assigned a name equal to the bean's `id` (often,\nsomething like `dataSource`). Thus, subsequent attempts to create an embedded database\ndo not result in a new database. Instead, the same JDBC connection URL is reused,\nand attempts to create a new embedded database actually point to an existing\nembedded database created from the same configuration.\n\nTo address this common issue, Spring Framework 4.2 provides support for generating\nunique names for embedded databases. To enable the use of generated names, use one of\nthe following options.\n\n* `EmbeddedDatabaseFactory.setGenerateUniqueDatabaseName()`\n* `EmbeddedDatabaseBuilder.generateUniqueName()`\n* `<jdbc:embedded-database generate-name=\"true\" ... >`\n\n[[jdbc-embedded-database-extension]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc", "title": "embedded-database-support", "heading": "Generating Unique Names for Embedded Databases", "heading_level": 2, "file_order": 112, "section_index": 9, "content_hash": "415533c98e753a1fb4575345e0eb832eab179ae06d3720cd11ce28c8c39bb491", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc"}}
{"id": "sha256:cdaed940067c4addd207fd52c5781879545e19d7ab9cc45acc7eb4a554f90743", "content": "You can extend Spring JDBC embedded database support in two ways:\n\n* Implement `EmbeddedDatabaseConfigurer` to support a new embedded database type.\n* Implement `DataSourceFactory` to support a new `DataSource` implementation, such as a\n connection pool to manage embedded database connections.\n\nWe encourage you to contribute extensions to the Spring community at\n{spring-framework-issues}[GitHub Issues].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc", "title": "embedded-database-support", "heading": "Extending the Embedded Database Support", "heading_level": 2, "file_order": 112, "section_index": 10, "content_hash": "cdaed940067c4addd207fd52c5781879545e19d7ab9cc45acc7eb4a554f90743", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/embedded-database-support.adoc"}}
{"id": "sha256:181cf985b4c006f015b8a9cbec2d286570dd5b5aaf5952cdf49c9bdce3219795", "content": "[[jdbc-initializing-datasource]]\n\nThe `org.springframework.jdbc.datasource.init` package provides support for initializing\nan existing `DataSource`. The embedded database support provides one option for creating\nand initializing a `DataSource` for an application. However, you may sometimes need to initialize\nan instance that runs on a server somewhere.\n\n[[jdbc-initializing-datasource-xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/initializing-datasource.adoc", "title": "initializing-datasource", "heading": "initializing-datasource", "heading_level": 1, "file_order": 113, "section_index": 0, "content_hash": "181cf985b4c006f015b8a9cbec2d286570dd5b5aaf5952cdf49c9bdce3219795", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/initializing-datasource.adoc"}}
{"id": "sha256:867151425476cda76dfc78ea8d4f131b4d22e28492513d0feaa35b2645c56f91", "content": "If you want to initialize a database and you can provide a reference to a `DataSource`\nbean, you can use the `initialize-database` tag in the `spring-jdbc` namespace:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jdbc:initialize-database data-source=\"dataSource\">\n <jdbc:script location=\"classpath:com/foo/sql/db-schema.sql\"/>\n <jdbc:script location=\"classpath:com/foo/sql/db-test-data.sql\"/>\n\t</jdbc:initialize-database>\n----\n\nThe preceding example runs the two specified scripts against the database. The first\nscript creates a schema, and the second populates tables with a test data set. The script\nlocations can also be patterns with wildcards in the usual Ant style used for resources\nin Spring (for example,\n`classpath{asterisk}:/com/foo/{asterisk}{asterisk}/sql/{asterisk}-data.sql`). If you use a\npattern, the scripts are run in the lexical order of their URL or filename.\n\nThe default behavior of the database initializer is to unconditionally run the provided\nscripts. This may not always be what you want -- for instance, if you run\nthe scripts against a database that already has test data in it. The likelihood\nof accidentally deleting data is reduced by following the common pattern (shown earlier)\nof creating the tables first and then inserting the data. The first step fails if\nthe tables already exist.\n\nHowever, to gain more control over the creation and deletion of existing data, the XML\nnamespace provides a few additional options. The first is a flag to switch the\ninitialization on and off. You can set this according to the environment (such as pulling a\nboolean value from system properties or from an environment bean). The following example gets a value from a system property:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jdbc:initialize-database data-source=\"dataSource\"\n enabled=\"#{systemProperties.INITIALIZE_DATABASE}\"> <1>\n <jdbc:script location=\"...\"/>\n\t</jdbc:initialize-database>\n----\n<1> Get the value for `enabled` from a system property called `INITIALIZE_DATABASE`.\n\nThe second option to control what happens with existing data is to be more tolerant of\nfailures. To this end, you can control the ability of the initializer to ignore certain\nerrors in the SQL it runs from the scripts, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jdbc:initialize-database data-source=\"dataSource\" ignore-failures=\"DROPS\">\n <jdbc:script location=\"...\"/>\n\t</jdbc:initialize-database>\n----\n\nIn the preceding example, we are saying that we expect that, sometimes, the scripts are run\nagainst an empty database, and there are some `DROP` statements in the scripts that\nwould, therefore, fail. So failed SQL `DROP` statements will be ignored, but other failures\nwill cause an exception. This is useful if your SQL dialect doesn't support `DROP ... IF\nEXISTS` (or similar) but you want to unconditionally remove all test data before\nre-creating it. In that case the first script is usually a set of `DROP` statements,\nfollowed by a set of `CREATE` statements.\n\nThe `ignore-failures` option can be set to `NONE` (the default), `DROPS` (ignore failed\ndrops), or `ALL` (ignore all failures).\n\nEach statement should be separated by `;` or a new line if the `;` character is not\npresent at all in the script. You can control that globally or script by script, as the\nfollowing example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jdbc:initialize-database data-source=\"dataSource\" separator=\"@@\"> <1>\n <jdbc:script location=\"classpath:com/myapp/sql/db-schema.sql\" separator=\";\"/> <2>\n <jdbc:script location=\"classpath:com/myapp/sql/db-test-data-1.sql\"/>\n <jdbc:script location=\"classpath:com/myapp/sql/db-test-data-2.sql\"/>\n\t</jdbc:initialize-database>\n----\n<1> Set the separator scripts to `@@`.\n<2> Set the separator for `db-schema.sql` to `;`.\n\nIn this example, the two `test-data` scripts use `@@` as statement separator and only\nthe `db-schema.sql` uses `;`. This configuration specifies that the default separator\nis `@@` and overrides that default for the `db-schema` script.\n\nIf you need more control than you get from the XML namespace, you can use the\n`DataSourceInitializer` directly and define it as a component in your application.\n\n[[jdbc-client-component-initialization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/initializing-datasource.adoc", "title": "initializing-datasource", "heading": "Initializing a Database by Using Spring XML", "heading_level": 2, "file_order": 113, "section_index": 1, "content_hash": "867151425476cda76dfc78ea8d4f131b4d22e28492513d0feaa35b2645c56f91", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/initializing-datasource.adoc"}}
{"id": "sha256:3f3817c7fd00e0aaadb157b8d2f8108349162f933a49bc915859c9d28212acec", "content": "A large class of applications (those that do not use the database until after the Spring context has\nstarted) can use the database initializer with no further\ncomplications. If your application is not one of those, you might need to read the rest\nof this section.\n\nThe database initializer depends on a `DataSource` instance and runs the scripts\nprovided in its initialization callback (analogous to an `init-method` in an XML bean\ndefinition, a `@PostConstruct` method in a component, or the `afterPropertiesSet()`\nmethod in a component that implements `InitializingBean`). If other beans depend on the\nsame data source and use the data source in an initialization callback, there\nmight be a problem because the data has not yet been initialized. A common example of\nthis is a cache that initializes eagerly and loads data from the database on application\nstartup.\n\nTo get around this issue, you have two options: change your cache initialization strategy\nto a later phase or ensure that the database initializer is initialized first.\n\nChanging your cache initialization strategy might be easy if the application is in your control and not otherwise.\nSome suggestions for how to implement this include:\n\n* Make the cache initialize lazily on first usage, which improves application startup\n time.\n* Have your cache or a separate component that initializes the cache implement\n `Lifecycle` or `SmartLifecycle`. When the application context starts, you can\n automatically start a `SmartLifecycle` by setting its `autoStartup` flag, and you can\n manually start a `Lifecycle` by calling `ConfigurableApplicationContext.start()`\n on the enclosing context.\n* Use a Spring `ApplicationEvent` or similar custom observer mechanism to trigger the\n cache initialization. `ContextRefreshedEvent` is always published by the context when\n it is ready for use (after all beans have been initialized), so that is often a useful\n hook (this is how the `SmartLifecycle` works by default).\n\nEnsuring that the database initializer is initialized first can also be easy. Some suggestions on how to implement this include:\n\n* Rely on the default behavior of the Spring `BeanFactory`, which is that beans are\n initialized in registration order. You can easily arrange that by adopting the common\n practice of a set of `<import/>` elements in XML configuration that order your\n application modules and ensuring that the database and database initialization are\n listed first.\n* Separate the `DataSource` and the business components that use it and control their\n startup order by putting them in separate `ApplicationContext` instances (for example, the\n parent context contains the `DataSource`, and the child context contains the business\n components). This structure is common in Spring web applications but can be more\n generally applied.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/initializing-datasource.adoc", "title": "initializing-datasource", "heading": "Initialization of Other Components that Depend on the Database", "heading_level": 3, "file_order": 113, "section_index": 2, "content_hash": "3f3817c7fd00e0aaadb157b8d2f8108349162f933a49bc915859c9d28212acec", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/initializing-datasource.adoc"}}
{"id": "sha256:660769920b5303c38194084807e45792b1ab0fc4d78eeae042c1047d3f12ce5a", "content": "[[jdbc-object]]\n\nThe `org.springframework.jdbc.object` package contains classes that let you access\nthe database in a more object-oriented manner. As an example, you can run queries\nand get the results back as a list that contains business objects with the relational\ncolumn data mapped to the properties of the business object. You can also run stored\nprocedures and run update, delete, and insert statements.\n\n[NOTE]\n====\nMany Spring developers believe that the various RDBMS operation classes described below\n(with the exception of the xref:data-access/jdbc/object.adoc#jdbc-StoredProcedure[`StoredProcedure`] class) can often\nbe replaced with straight `JdbcTemplate` calls. Often, it is simpler to write a DAO\nmethod that calls a method on a `JdbcTemplate` directly (as opposed to\nencapsulating a query as a full-blown class).\n\nHowever, if you are getting measurable value from using the RDBMS operation classes,\nyou should continue to use these classes.\n====\n\n[[jdbc-SqlQuery]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/object.adoc", "title": "object", "heading": "object", "heading_level": 1, "file_order": 114, "section_index": 0, "content_hash": "660769920b5303c38194084807e45792b1ab0fc4d78eeae042c1047d3f12ce5a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/object.adoc"}}
{"id": "sha256:fa9a79873479cd13c6b172fd09588a50467ba3f9c14a06d050eb5d06224511ca", "content": "`SqlQuery` is a reusable, thread-safe class that encapsulates an SQL query. Subclasses\nmust implement the `newRowMapper(..)` method to provide a `RowMapper` instance that can\ncreate one object per row obtained from iterating over the `ResultSet` that is created\nduring the execution of the query. The `SqlQuery` class is rarely used directly, because\nthe `MappingSqlQuery` subclass provides a much more convenient implementation for\nmapping rows to Java classes. Other implementations that extend `SqlQuery` are\n`MappingSqlQueryWithParameters` and `UpdatableSqlQuery`.\n\n[[jdbc-MappingSqlQuery]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/object.adoc", "title": "object", "heading": "Understanding `SqlQuery`", "heading_level": 2, "file_order": 114, "section_index": 1, "content_hash": "fa9a79873479cd13c6b172fd09588a50467ba3f9c14a06d050eb5d06224511ca", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/object.adoc"}}
{"id": "sha256:f083f06fa6370c5990f4a36d299f3b86908b03d69ebf9105ba5873f4eebb558d", "content": "`MappingSqlQuery` is a reusable query in which concrete subclasses must implement the\nabstract `mapRow(..)` method to convert each row of the supplied `ResultSet` into an\nobject of the type specified. The following example shows a custom query that maps the\ndata from the `t_actor` relation to an instance of the `Actor` class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ActorMappingQuery extends MappingSqlQuery<Actor> {\n\n public ActorMappingQuery(DataSource ds) {\n super(ds, \"select id, first_name, last_name from t_actor where id = ?\");\n declareParameter(new SqlParameter(\"id\", Types.INTEGER));\n compile();\n }\n\n @Override\n protected Actor mapRow(ResultSet rs, int rowNumber) throws SQLException {\n Actor actor = new Actor();\n actor.setId(rs.getLong(\"id\"));\n actor.setFirstName(rs.getString(\"first_name\"));\n actor.setLastName(rs.getString(\"last_name\"));\n return actor;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ActorMappingQuery(ds: DataSource) : MappingSqlQuery<Actor>(ds, \"select id, first_name, last_name from t_actor where id = ?\") {\n\n init {\n declareParameter(SqlParameter(\"id\", Types.INTEGER))\n compile()\n }\n\n override fun mapRow(rs: ResultSet, rowNumber: Int) = Actor(\n rs.getLong(\"id\"),\n rs.getString(\"first_name\"),\n rs.getString(\"last_name\")\n )\n\t}\n\n----\n======\n\nThe class extends `MappingSqlQuery` parameterized with the `Actor` type. The constructor\nfor this customer query takes a `DataSource` as the only parameter. In this\nconstructor, you can call the constructor on the superclass with the `DataSource` and the SQL\nthat should be run to retrieve the rows for this query. This SQL is used to\ncreate a `PreparedStatement`, so it may contain placeholders for any parameters to be\npassed in during execution. You must declare each parameter by using the `declareParameter`\nmethod passing in an `SqlParameter`. The `SqlParameter` takes a name, and the JDBC type\nas defined in `java.sql.Types`. After you define all parameters, you can call the\n`compile()` method so that the statement can be prepared and later run. This class is\nthread-safe after it is compiled, so, as long as these instances are created when the DAO\nis initialized, they can be kept as instance variables and be reused. The following\nexample shows how to define such a class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tprivate ActorMappingQuery actorMappingQuery;\n\n\t@Autowired\n\tpublic void setDataSource(DataSource dataSource) {\n this.actorMappingQuery = new ActorMappingQuery(dataSource);\n\t}\n\n\tpublic Actor getActor(Long id) {\n return actorMappingQuery.findObject(id);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tprivate val actorMappingQuery = ActorMappingQuery(dataSource)\n\n\tfun getActor(id: Long) = actorMappingQuery.findObject(id)\n----\n======\n\nThe method in the preceding example retrieves the actor with the `id` that is passed in as the\nonly parameter. Since we want only one object to be returned, we call the `findObject` convenience\nmethod with the `id` as the parameter. If we had instead a query that returned a\nlist of objects and took additional parameters, we would use one of the `execute`\nmethods that takes an array of parameter values passed in as varargs. The following\nexample shows such a method:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic List<Actor> searchForActors(int age, String namePattern) {\n return actorSearchMappingQuery.execute(age, namePattern);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun searchForActors(age: Int, namePattern: String) =\n actorSearchMappingQuery.execute(age, namePattern)\n----\n======\n\n[[jdbc-SqlUpdate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/object.adoc", "title": "object", "heading": "Using `MappingSqlQuery`", "heading_level": 2, "file_order": 114, "section_index": 2, "content_hash": "f083f06fa6370c5990f4a36d299f3b86908b03d69ebf9105ba5873f4eebb558d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/object.adoc"}}
{"id": "sha256:7d30f07dea55dce81316888a0489ff987b2b4cb47e427f1f6fda18332409b409", "content": "The `SqlUpdate` class encapsulates an SQL update. As with a query, an update object is\nreusable, and, as with all `RdbmsOperation` classes, an update can have parameters and is\ndefined in SQL. This class provides a number of `update(..)` methods analogous to the\n`execute(..)` methods of query objects. The `SqlUpdate` class is concrete. It can be\nsubclassed -- for example, to add a custom update method.\nHowever, you do not have to subclass the `SqlUpdate`\nclass, since it can easily be parameterized by setting SQL and declaring parameters.\nThe following example creates a custom update method named `execute`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.sql.Types;\n\timport javax.sql.DataSource;\n\timport org.springframework.jdbc.core.SqlParameter;\n\timport org.springframework.jdbc.object.SqlUpdate;\n\n\tpublic class UpdateCreditRating extends SqlUpdate {\n\n public UpdateCreditRating(DataSource ds) {\n setDataSource(ds);\n setSql(\"update customer set credit_rating = ? where id = ?\");\n declareParameter(new SqlParameter(\"creditRating\", Types.NUMERIC));\n declareParameter(new SqlParameter(\"id\", Types.NUMERIC));\n compile();\n }\n\n /**\n * @param id for the Customer to be updated\n * @param rating the new value for credit rating\n * @return number of rows updated\n */\n public int execute(int id, int rating) {\n return update(rating, id);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.sql.Types\n\timport javax.sql.DataSource\n\timport org.springframework.jdbc.core.SqlParameter\n\timport org.springframework.jdbc.`object`.SqlUpdate\n\n\tclass UpdateCreditRating(ds: DataSource) : SqlUpdate() {\n\n init {\n setDataSource(ds)\n sql = \"update customer set credit_rating = ? where id = ?\"\n declareParameter(SqlParameter(\"creditRating\", Types.NUMERIC))\n declareParameter(SqlParameter(\"id\", Types.NUMERIC))\n compile()\n }\n\n /**\n * @param id for the Customer to be updated\n * @param rating the new value for credit rating\n * @return number of rows updated\n */\n fun execute(id: Int, rating: Int): Int {\n return update(rating, id)\n }\n\t}\n----\n======\n\n[[jdbc-StoredProcedure]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/object.adoc", "title": "object", "heading": "Using `SqlUpdate`", "heading_level": 2, "file_order": 114, "section_index": 3, "content_hash": "7d30f07dea55dce81316888a0489ff987b2b4cb47e427f1f6fda18332409b409", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/object.adoc"}}
{"id": "sha256:6111af8c1b0196971f578dd6b19c9cf0ba1182c8e48acb36ee6a86344914374c", "content": "The `StoredProcedure` class is an `abstract` superclass for object abstractions of RDBMS\nstored procedures.\n\nThe inherited `sql` property is the name of the stored procedure in the RDBMS.\n\nTo define a parameter for the `StoredProcedure` class, you can use an `SqlParameter` or one\nof its subclasses. You must specify the parameter name and SQL type in the constructor,\nas the following code snippet shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tnew SqlParameter(\"in_id\", Types.NUMERIC),\n\tnew SqlOutParameter(\"out_first_name\", Types.VARCHAR),\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tSqlParameter(\"in_id\", Types.NUMERIC),\n\tSqlOutParameter(\"out_first_name\", Types.VARCHAR),\n----\n======\n\nThe SQL type is specified using the `java.sql.Types` constants.\n\nThe first line (with the `SqlParameter`) declares an IN parameter. You can use IN parameters\nboth for stored procedure calls and for queries using the `SqlQuery` and its\nsubclasses (covered in xref:data-access/jdbc/object.adoc#jdbc-SqlQuery[Understanding `SqlQuery`]).\n\nThe second line (with the `SqlOutParameter`) declares an `out` parameter to be used in the\nstored procedure call. There is also an `SqlInOutParameter` for `InOut` parameters\n(parameters that provide an `in` value to the procedure and that also return a value).\n\nFor `in` parameters, in addition to the name and the SQL type, you can specify a\nscale for numeric data or a type name for custom database types. For `out` parameters,\nyou can provide a `RowMapper` to handle mapping of rows returned from a `REF` cursor.\nAnother option is to specify an `SqlReturnType` that lets you define customized\nhandling of the return values.\n\nThe next example of a simple DAO uses a `StoredProcedure` to call a function\n(`sysdate()`), which comes with any Oracle database. To use the stored procedure\nfunctionality, you have to create a class that extends `StoredProcedure`. In this\nexample, the `StoredProcedure` class is an inner class. However, if you need to reuse the\n`StoredProcedure`, you can declare it as a top-level class. This example has no input\nparameters, but an output parameter is declared as a date type by using the\n`SqlOutParameter` class. The `execute()` method runs the procedure and extracts the\nreturned date from the results `Map`. The results `Map` has an entry for each declared\noutput parameter (in this case, only one) by using the parameter name as the key.\nThe following listing shows our custom StoredProcedure class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.sql.Types;\n\timport java.util.Date;\n\timport java.util.HashMap;\n\timport java.util.Map;\n\timport javax.sql.DataSource;\n\timport org.springframework.beans.factory.annotation.Autowired;\n\timport org.springframework.jdbc.core.SqlOutParameter;\n\timport org.springframework.jdbc.object.StoredProcedure;\n\n\tpublic class StoredProcedureDao {\n\n private GetSysdateProcedure getSysdate;\n\n @Autowired\n public void init(DataSource dataSource) {\n this.getSysdate = new GetSysdateProcedure(dataSource);\n }\n\n public Date getSysdate() {\n return getSysdate.execute();\n }\n\n private class GetSysdateProcedure extends StoredProcedure {\n\n private static final String SQL = \"sysdate\";\n\n public GetSysdateProcedure(DataSource dataSource) {\n setDataSource(dataSource);\n setFunction(true);\n setSql(SQL);\n declareParameter(new SqlOutParameter(\"date\", Types.DATE));\n compile();\n }\n\n public Date execute() {\n // the 'sysdate' sproc has no input parameters, so an empty Map is supplied...\n Map<String, Object> results = execute(new HashMap<String, Object>());\n Date sysdate = (Date) results.get(\"date\");\n return sysdate;\n }\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.sql.Types\n\timport java.util.Date\n\timport java.util.Map\n\timport javax.sql.DataSource\n\timport org.springframework.jdbc.core.SqlOutParameter\n\timport org.springframework.jdbc.object.StoredProcedure\n\n\tclass StoredProcedureDao(dataSource: DataSource) {\n\n private val SQL = \"sysdate\"\n\n private val getSysdate = GetSysdateProcedure(dataSource)\n\n val sysdate: Date\n get() = getSysdate.execute()\n\n private inner class GetSysdateProcedure(dataSource: DataSource) : StoredProcedure() {\n\n init {\n setDataSource(dataSource)\n isFunction = true\n sql = SQL\n declareParameter(SqlOutParameter(\"date\", Types.DATE))\n compile()\n }\n\n fun execute(): Date {\n // the 'sysdate' sproc has no input parameters, so an empty Map is supplied...\n val results = execute(mutableMapOf<String, Any>())\n return results[\"date\"] as Date\n }\n }\n\t}\n----\n======\n\nThe following example of a `StoredProcedure` has two output parameters (in this case,\nOracle REF cursors):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.util.HashMap;\n\timport java.util.Map;\n\timport javax.sql.DataSource;\n\timport oracle.jdbc.OracleTypes;\n\timport org.springframework.jdbc.core.SqlOutParameter;\n\timport org.springframework.jdbc.object.StoredProcedure;\n\n\tpublic class TitlesAndGenresStoredProcedure extends StoredProcedure {\n\n private static final String SPROC_NAME = \"AllTitlesAndGenres\";\n\n public TitlesAndGenresStoredProcedure(DataSource dataSource) {\n super(dataSource, SPROC_NAME);\n declareParameter(new SqlOutParameter(\"titles\", OracleTypes.CURSOR, new TitleMapper()));\n declareParameter(new SqlOutParameter(\"genres\", OracleTypes.CURSOR, new GenreMapper()));\n compile();\n }\n\n public Map<String, Object> execute() {\n // again, this sproc has no input parameters, so an empty Map is supplied\n return super.execute(new HashMap<String, Object>());\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.util.HashMap\n\timport javax.sql.DataSource\n\timport oracle.jdbc.OracleTypes\n\timport org.springframework.jdbc.core.SqlOutParameter\n\timport org.springframework.jdbc.`object`.StoredProcedure\n\n\tclass TitlesAndGenresStoredProcedure(dataSource: DataSource) : StoredProcedure(dataSource, SPROC_NAME) {\n\n companion object {\n private const val SPROC_NAME = \"AllTitlesAndGenres\"\n }\n\n init {\n declareParameter(SqlOutParameter(\"titles\", OracleTypes.CURSOR, TitleMapper()))\n declareParameter(SqlOutParameter(\"genres\", OracleTypes.CURSOR, GenreMapper()))\n compile()\n }\n\n fun execute(): Map<String, Any> {\n // again, this sproc has no input parameters, so an empty Map is supplied\n return super.execute(HashMap<String, Any>())\n }\n\t}\n----\n======\n\nNotice how the overloaded variants of the `declareParameter(..)` method that have been\nused in the `TitlesAndGenresStoredProcedure` constructor are passed `RowMapper`\nimplementation instances. This is a very convenient and powerful way to reuse existing\nfunctionality. The next two examples provide code for the two `RowMapper` implementations.\n\nThe `TitleMapper` class maps a `ResultSet` to a `Title` domain object for each row in\nthe supplied `ResultSet`, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.sql.ResultSet;\n\timport java.sql.SQLException;\n\timport com.foo.domain.Title;\n\timport org.springframework.jdbc.core.RowMapper;\n\n\tpublic final class TitleMapper implements RowMapper<Title> {\n\n public Title mapRow(ResultSet rs, int rowNum) throws SQLException {\n Title title = new Title();\n title.setId(rs.getLong(\"id\"));\n title.setName(rs.getString(\"name\"));\n return title;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.sql.ResultSet\n\timport com.foo.domain.Title\n\timport org.springframework.jdbc.core.RowMapper\n\n\tclass TitleMapper : RowMapper<Title> {\n\n override fun mapRow(rs: ResultSet, rowNum: Int) =\n Title(rs.getLong(\"id\"), rs.getString(\"name\"))\n\t}\n----\n======\n\nThe `GenreMapper` class maps a `ResultSet` to a `Genre` domain object for each row in\nthe supplied `ResultSet`, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.sql.ResultSet;\n\timport java.sql.SQLException;\n\timport com.foo.domain.Genre;\n\timport org.springframework.jdbc.core.RowMapper;\n\n\tpublic final class GenreMapper implements RowMapper<Genre> {\n\n public Genre mapRow(ResultSet rs, int rowNum) throws SQLException {\n return new Genre(rs.getString(\"name\"));\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.sql.ResultSet\n\timport com.foo.domain.Genre\n\timport org.springframework.jdbc.core.RowMapper\n\n\tclass GenreMapper : RowMapper<Genre> {\n\n override fun mapRow(rs: ResultSet, rowNum: Int): Genre {\n return Genre(rs.getString(\"name\"))\n }\n\t}\n----\n======\n\nTo pass parameters to a stored procedure that has one or more input parameters in its\ndefinition in the RDBMS, you can code a strongly typed `execute(..)` method that would\ndelegate to the untyped `execute(Map)` method in the superclass, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.sql.Types;\n\timport java.util.Date;\n\timport java.util.HashMap;\n\timport java.util.Map;\n\timport javax.sql.DataSource;\n\timport oracle.jdbc.OracleTypes;\n\timport org.springframework.jdbc.core.SqlOutParameter;\n\timport org.springframework.jdbc.core.SqlParameter;\n\timport org.springframework.jdbc.object.StoredProcedure;\n\n\tpublic class TitlesAfterDateStoredProcedure extends StoredProcedure {\n\n private static final String SPROC_NAME = \"TitlesAfterDate\";\n private static final String CUTOFF_DATE_PARAM = \"cutoffDate\";\n\n public TitlesAfterDateStoredProcedure(DataSource dataSource) {\n super(dataSource, SPROC_NAME);\n declareParameter(new SqlParameter(CUTOFF_DATE_PARAM, Types.DATE);\n declareParameter(new SqlOutParameter(\"titles\", OracleTypes.CURSOR, new TitleMapper()));\n compile();\n }\n\n public Map<String, Object> execute(Date cutoffDate) {\n Map<String, Object> inputs = new HashMap<String, Object>();\n inputs.put(CUTOFF_DATE_PARAM, cutoffDate);\n return super.execute(inputs);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.sql.Types\n\timport java.util.Date\n\timport javax.sql.DataSource\n\timport oracle.jdbc.OracleTypes\n\timport org.springframework.jdbc.core.SqlOutParameter\n\timport org.springframework.jdbc.core.SqlParameter\n\timport org.springframework.jdbc.`object`.StoredProcedure\n\n\tclass TitlesAfterDateStoredProcedure(dataSource: DataSource) : StoredProcedure(dataSource, SPROC_NAME) {\n\n companion object {\n private const val SPROC_NAME = \"TitlesAfterDate\"\n private const val CUTOFF_DATE_PARAM = \"cutoffDate\"\n }\n\n init {\n declareParameter(SqlParameter(CUTOFF_DATE_PARAM, Types.DATE))\n declareParameter(SqlOutParameter(\"titles\", OracleTypes.CURSOR, TitleMapper()))\n compile()\n }\n\n fun execute(cutoffDate: Date) = super.execute(\n mapOf<String, Any>(CUTOFF_DATE_PARAM to cutoffDate))\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/object.adoc", "title": "object", "heading": "Using `StoredProcedure`", "heading_level": 2, "file_order": 114, "section_index": 4, "content_hash": "6111af8c1b0196971f578dd6b19c9cf0ba1182c8e48acb36ee6a86344914374c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/object.adoc"}}
{"id": "sha256:61129203f4777cf0d997ab2a13da355731807262fa0cbad2b53b752cefb971a5", "content": "[[jdbc-packages]]\n\nThe Spring Framework's JDBC abstraction framework consists of four different packages:\n\n* `core`: The `org.springframework.jdbc.core` package contains the `JdbcTemplate` class\nand its various callback interfaces, plus a variety of related classes. A subpackage\nnamed `org.springframework.jdbc.core.simple` contains the `SimpleJdbcInsert` and\n`SimpleJdbcCall` classes. Another subpackage named\n`org.springframework.jdbc.core.namedparam` contains the `NamedParameterJdbcTemplate`\nclass and the related support classes. See\nxref:data-access/jdbc/core.adoc[Using the JDBC Core Classes to Control Basic JDBC Processing and Error Handling],\nxref:data-access/jdbc/advanced.adoc[JDBC Batch Operations], and\nxref:data-access/jdbc/simple.adoc[Simplifying JDBC Operations with the `SimpleJdbc` Classes].\n\n* `datasource`: The `org.springframework.jdbc.datasource` package contains a utility class\nfor easy `DataSource` access and various simple `DataSource` implementations that you can\nuse for testing and running unmodified JDBC code outside of a Jakarta EE container. A subpackage\nnamed `org.springframework.jdbc.datasource.embedded` provides support for creating\nembedded databases by using Java database engines, such as HSQL, H2, and Derby. See\nxref:data-access/jdbc/connections.adoc[Controlling Database Connections] and\nxref:data-access/jdbc/embedded-database-support.adoc[Embedded Database Support].\n\n* `object`: The `org.springframework.jdbc.object` package contains classes that represent\nRDBMS queries, updates, and stored procedures as thread-safe, reusable objects. See\nxref:data-access/jdbc/object.adoc[Modeling JDBC Operations as Java Objects]. This style\nresults in a more object-oriented approach, although objects returned by queries are\nnaturally disconnected from the database. This higher-level of JDBC abstraction depends\non the lower-level abstraction in the `org.springframework.jdbc.core` package.\n\n* `support`: The `org.springframework.jdbc.support` package provides `SQLException`\ntranslation functionality and some utility classes. Exceptions thrown during JDBC processing\nare translated to exceptions defined in the `org.springframework.dao` package. This means\nthat code using the Spring JDBC abstraction layer does not need to implement JDBC or\nRDBMS-specific error handling. All translated exceptions are unchecked, which gives you\nthe option of catching the exceptions from which you can recover while letting other\nexceptions be propagated to the caller. See\nxref:data-access/jdbc/core.adoc#jdbc-SQLExceptionTranslator[Using `SQLExceptionTranslator`].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/packages.adoc", "title": "packages", "heading": "packages", "heading_level": 1, "file_order": 115, "section_index": 0, "content_hash": "61129203f4777cf0d997ab2a13da355731807262fa0cbad2b53b752cefb971a5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/packages.adoc"}}
{"id": "sha256:c99d6179cf2eea5b7f661b170e59e1f2cc226644d85ab07aecda08bc97043e5a", "content": "[[jdbc-parameter-handling]]\n\nCommon problems with parameters and data values exist in the different approaches\nprovided by Spring Framework's JDBC support. This section covers how to address them.\n\n[[jdbc-type-information]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/parameter-handling.adoc", "title": "parameter-handling", "heading": "parameter-handling", "heading_level": 1, "file_order": 116, "section_index": 0, "content_hash": "c99d6179cf2eea5b7f661b170e59e1f2cc226644d85ab07aecda08bc97043e5a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/parameter-handling.adoc"}}
{"id": "sha256:72f7971a600fe57561bc7f85702ade8a1e0f853a8f870eb0075d3210ec057b0f", "content": "Usually, Spring determines the SQL type of the parameters based on the type of parameter\npassed in. It is possible to explicitly provide the SQL type to be used when setting\nparameter values. This is sometimes necessary to correctly set `NULL` values.\n\nYou can provide SQL type information in several ways:\n\n* Many update and query methods of the `JdbcTemplate` take an additional parameter in\n the form of an `int` array. This array is used to indicate the SQL type of the\n corresponding parameter by using constant values from the `java.sql.Types` class. Provide\n one entry for each parameter.\n* You can use the `SqlParameterValue` class to wrap the parameter value that needs this\n additional information. To do so, create a new instance for each value and pass in the SQL type\n and the parameter value in the constructor. You can also provide an optional scale\n parameter for numeric values.\n* For methods that work with named parameters, you can use the `SqlParameterSource` classes,\n `BeanPropertySqlParameterSource` or `MapSqlParameterSource`. They both have methods\n for registering the SQL type for any of the named parameter values.\n\n[[jdbc-lob]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/parameter-handling.adoc", "title": "parameter-handling", "heading": "Providing SQL Type Information for Parameters", "heading_level": 2, "file_order": 116, "section_index": 1, "content_hash": "72f7971a600fe57561bc7f85702ade8a1e0f853a8f870eb0075d3210ec057b0f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/parameter-handling.adoc"}}
{"id": "sha256:9efb365a88fb4d7d5ff1a02973bfc366b4c551019e2f88900ea7a67b594c843f", "content": "You can store images, other binary data, and large chunks of text in the database. These\nlarge objects are called BLOBs (Binary Large OBject) for binary data and CLOBs (Character\nLarge OBject) for character data. In Spring, you can handle these large objects by using\nthe `JdbcTemplate` directly and also when using the higher abstractions provided by RDBMS\nObjects and the `SimpleJdbc` classes. All of these approaches use an implementation of\nthe `LobHandler` interface for the actual management of the LOB (Large OBject) data.\n`LobHandler` provides access to a `LobCreator` class, through the `getLobCreator` method,\nthat is used for creating new LOB objects to be inserted.\n\n`LobCreator` and `LobHandler` provide the following support for LOB input and output:\n\n* BLOB\n** `byte[]`: `getBlobAsBytes` and `setBlobAsBytes`\n** `InputStream`: `getBlobAsBinaryStream` and `setBlobAsBinaryStream`\n* CLOB\n** `String`: `getClobAsString` and `setClobAsString`\n** `InputStream`: `getClobAsAsciiStream` and `setClobAsAsciiStream`\n** `Reader`: `getClobAsCharacterStream` and `setClobAsCharacterStream`\n\nThe next example shows how to create and insert a BLOB. Later we show how to read\nit back from the database.\n\nThis example uses a `JdbcTemplate` and an implementation of the\n`AbstractLobCreatingPreparedStatementCallback`. It implements one method,\n`setValues`. This method provides a `LobCreator` that we use to set the values for the\nLOB columns in your SQL insert statement.\n\nFor this example, we assume that there is a variable, `lobHandler`, that is already\nset to an instance of a `DefaultLobHandler`. You typically set this value through\ndependency injection.\n\nThe following example shows how to create and insert a BLOB:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfinal File blobIn = new File(\"spring2004.jpg\");\n\tfinal InputStream blobIs = new FileInputStream(blobIn);\n\tfinal File clobIn = new File(\"large.txt\");\n\tfinal InputStream clobIs = new FileInputStream(clobIn);\n\tfinal InputStreamReader clobReader = new InputStreamReader(clobIs);\n\n\tjdbcTemplate.execute(\n \"INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)\",\n new AbstractLobCreatingPreparedStatementCallback(lobHandler) { // <1>\n protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {\n ps.setLong(1, 1L);\n lobCreator.setClobAsCharacterStream(ps, 2, clobReader, (int)clobIn.length()); // <2>\n lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, (int)blobIn.length()); // <3>\n }\n }\n\t);\n\n\tblobIs.close();\n\tclobReader.close();\n----\n<1> Pass in the `lobHandler` that (in this example) is a plain `DefaultLobHandler`.\n<2> Using the method `setClobAsCharacterStream` to pass in the contents of the CLOB.\n<3> Using the method `setBlobAsBinaryStream` to pass in the contents of the BLOB.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval blobIn = File(\"spring2004.jpg\")\n\tval blobIs = FileInputStream(blobIn)\n\tval clobIn = File(\"large.txt\")\n\tval clobIs = FileInputStream(clobIn)\n\tval clobReader = InputStreamReader(clobIs)\n\n\tjdbcTemplate.execute(\n \"INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)\",\n object: AbstractLobCreatingPreparedStatementCallback(lobHandler) { // <1>\n override fun setValues(ps: PreparedStatement, lobCreator: LobCreator) {\n ps.setLong(1, 1L)\n lobCreator.setClobAsCharacterStream(ps, 2, clobReader, clobIn.length().toInt()) // <2>\n lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, blobIn.length().toInt()) // <3>\n }\n }\n\t)\n\tblobIs.close()\n\tclobReader.close()\n----\n<1> Pass in the `lobHandler` that (in this example) is a plain `DefaultLobHandler`.\n<2> Using the method `setClobAsCharacterStream` to pass in the contents of the CLOB.\n<3> Using the method `setBlobAsBinaryStream` to pass in the contents of the BLOB.\n======\n\n[NOTE]\n====\nIf you invoke the `setBlobAsBinaryStream`, `setClobAsAsciiStream`, or\n`setClobAsCharacterStream` method on the `LobCreator` returned from\n`DefaultLobHandler.getLobCreator()`, you can optionally specify a negative value\nfor the `contentLength` argument. If the specified content length is negative, the\n`DefaultLobHandler` uses the JDBC 4.0 variants of the set-stream methods without a\nlength parameter. Otherwise, it passes the specified length on to the driver.\n\nSee the documentation for the JDBC driver you use to verify that it supports streaming\na LOB without providing the content length.\n====\n\nNow it is time to read the LOB data from the database. Again, you use a `JdbcTemplate`\nwith the same instance variable `lobHandler` and a reference to a `DefaultLobHandler`.\nThe following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tList<Map<String, Object>> l = jdbcTemplate.query(\"select id, a_clob, a_blob from lob_table\",\n new RowMapper<Map<String, Object>>() {\n public Map<String, Object> mapRow(ResultSet rs, int i) throws SQLException {\n Map<String, Object> results = new HashMap<String, Object>();\n String clobText = lobHandler.getClobAsString(rs, \"a_clob\"); // <1>\n results.put(\"CLOB\", clobText);\n byte[] blobBytes = lobHandler.getBlobAsBytes(rs, \"a_blob\"); // <2>\n results.put(\"BLOB\", blobBytes);\n return results;\n }\n });\n----\n<1> Using the method `getClobAsString` to retrieve the contents of the CLOB.\n<2> Using the method `getBlobAsBytes` to retrieve the contents of the BLOB.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval l = jdbcTemplate.query(\"select id, a_clob, a_blob from lob_table\") { rs, _ ->\n val clobText = lobHandler.getClobAsString(rs, \"a_clob\") // <1>\n val blobBytes = lobHandler.getBlobAsBytes(rs, \"a_blob\") // <2>\n mapOf(\"CLOB\" to clobText, \"BLOB\" to blobBytes)\n\t}\n----\n<1> Using the method `getClobAsString` to retrieve the contents of the CLOB.\n<2> Using the method `getBlobAsBytes` to retrieve the contents of the BLOB.\n======\n\n[[jdbc-in-clause]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/parameter-handling.adoc", "title": "parameter-handling", "heading": "Handling BLOB and CLOB objects", "heading_level": 2, "file_order": 116, "section_index": 2, "content_hash": "9efb365a88fb4d7d5ff1a02973bfc366b4c551019e2f88900ea7a67b594c843f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/parameter-handling.adoc"}}
{"id": "sha256:8456fb050601683400a58fb591d5feebe6cd556df97faad4afc1386d79217463", "content": "The SQL standard allows for selecting rows based on an expression that includes a\nvariable list of values. A typical example would be `select * from T_ACTOR where id in\n(1, 2, 3)`. This variable list is not directly supported for prepared statements by the\nJDBC standard. You cannot declare a variable number of placeholders. You need a number\nof variations with the desired number of placeholders prepared, or you need to generate\nthe SQL string dynamically once you know how many placeholders are required. The named\nparameter support provided in the `NamedParameterJdbcTemplate` takes the latter approach.\nYou can pass in the values as a `java.util.List` (or any `Iterable`) of simple values.\nThis list is used to insert the required placeholders into the actual SQL statement\nand pass in the values during statement execution.\n\nNOTE: Be careful when passing in many values. The JDBC standard does not guarantee that\nyou can use more than 100 values for an `IN` expression list. Various databases exceed\nthis number, but they usually have a hard limit for how many values are allowed.\nFor example, Oracle's limit is 1000.\n\nIn addition to the primitive values in the value list, you can create a `java.util.List`\nof object arrays. This list can support multiple expressions being defined for the `in`\nclause, such as `+++select * from T_ACTOR where (id, last_name) in ((1, 'Johnson'), (2,\n'Harrop'))+++`. This, of course, requires that your database supports this syntax.\n\n[[jdbc-complex-types]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/parameter-handling.adoc", "title": "parameter-handling", "heading": "Passing in Lists of Values for IN Clause", "heading_level": 2, "file_order": 116, "section_index": 3, "content_hash": "8456fb050601683400a58fb591d5feebe6cd556df97faad4afc1386d79217463", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/parameter-handling.adoc"}}
{"id": "sha256:5de1ab383b8f80af4461b00fc947786ffa82e4a5ab212e48dc10e99deda4ae2b", "content": "When you call stored procedures, you can sometimes use complex types specific to the\ndatabase. To accommodate these types, Spring provides a `SqlReturnType` for handling\nthem when they are returned from the stored procedure call and `SqlTypeValue` when they\nare passed in as a parameter to the stored procedure.\n\nThe `SqlReturnType` interface has a single method (named `getTypeValue`) that must be\nimplemented. This interface is used as part of the declaration of an `SqlOutParameter`.\nThe following example shows returning the value of a `java.sql.Struct` object of the user\ndeclared type `ITEM_TYPE`:\n\ninclude-code::./TestItemStoredProcedure[]\n\nYou can use `SqlTypeValue` to pass the value of a Java object (such as `TestItem`) to a\nstored procedure. The `SqlTypeValue` interface has a single method (named\n`createTypeValue`) that you must implement. The active connection is passed in, and you\ncan use it to create database-specific objects, such as `java.sql.Struct` instances\nor `java.sql.Array` instances. The following example creates a `java.sql.Struct` instance:\n\ninclude-code::./SqlTypeValueFactory[tag=struct,indent=0]\n\nYou can now add this `SqlTypeValue` to the `Map` that contains the input parameters for the\n`execute` call of the stored procedure.\n\nAnother use for the `SqlTypeValue` is passing in an array of values to an Oracle stored\nprocedure. Oracle has an `createOracleArray` method on `OracleConnection` that you can\naccess by unwrapping it. You can use the `SqlTypeValue` to create an array and populate\nit with values from the Java `java.sql.Array`, as the following example shows:\n\ninclude-code::./SqlTypeValueFactory[tag=oracle-array,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/parameter-handling.adoc", "title": "parameter-handling", "heading": "Handling Complex Types for Stored Procedure Calls", "heading_level": 2, "file_order": 116, "section_index": 4, "content_hash": "5de1ab383b8f80af4461b00fc947786ffa82e4a5ab212e48dc10e99deda4ae2b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/parameter-handling.adoc"}}
{"id": "sha256:cf912805b5d770a6bf96f416bce4443931c37f75c876d5b7556c67d48158939d", "content": "[[jdbc-simple-jdbc]]\n\nThe `SimpleJdbcInsert` and `SimpleJdbcCall` classes provide a simplified configuration\nby taking advantage of database metadata that can be retrieved through the JDBC driver.\nThis means that you have less to configure up front, although you can override or turn off\nthe metadata processing if you prefer to provide all the details in your code.\n\n[[jdbc-simple-jdbc-insert-1]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc", "title": "simple", "heading": "simple", "heading_level": 1, "file_order": 117, "section_index": 0, "content_hash": "cf912805b5d770a6bf96f416bce4443931c37f75c876d5b7556c67d48158939d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc"}}
{"id": "sha256:5adf3ca13fc7cace17a07bbd28bfbbf116ce965a785ddfdb8eab6525438b2d69", "content": "We start by looking at the `SimpleJdbcInsert` class with the minimal amount of\nconfiguration options. You should instantiate the `SimpleJdbcInsert` in the data access\nlayer's initialization method. For this example, the initializing method is the\n`setDataSource` method. You do not need to subclass the `SimpleJdbcInsert` class. Instead,\nyou can create a new instance and set the table name by using the `withTableName` method.\nConfiguration methods for this class follow the `fluent` style that returns the instance\nof the `SimpleJdbcInsert`, which lets you chain all configuration methods. The following\nexample uses only one configuration method (we show examples of multiple methods later):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private SimpleJdbcInsert insertActor;\n\n public void setDataSource(DataSource dataSource) {\n this.insertActor = new SimpleJdbcInsert(dataSource).withTableName(\"t_actor\");\n }\n\n public void add(Actor actor) {\n Map<String, Object> parameters = new HashMap<>(3);\n parameters.put(\"id\", actor.getId());\n parameters.put(\"first_name\", actor.getFirstName());\n parameters.put(\"last_name\", actor.getLastName());\n insertActor.execute(parameters);\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val insertActor = SimpleJdbcInsert(dataSource).withTableName(\"t_actor\")\n\n fun add(actor: Actor) {\n val parameters = mutableMapOf<String, Any>()\n parameters[\"id\"] = actor.id\n parameters[\"first_name\"] = actor.firstName\n parameters[\"last_name\"] = actor.lastName\n insertActor.execute(parameters)\n }\n\n // ... additional methods\n\t}\n----\n======\n\nThe `execute` method used here takes a plain `java.util.Map` as its only parameter. The\nimportant thing to note here is that the keys used for the `Map` must match the column\nnames of the table, as defined in the database. This is because we read the metadata\nto construct the actual insert statement.\n\n[[jdbc-simple-jdbc-insert-2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc", "title": "simple", "heading": "Inserting Data by Using `SimpleJdbcInsert`", "heading_level": 2, "file_order": 117, "section_index": 1, "content_hash": "5adf3ca13fc7cace17a07bbd28bfbbf116ce965a785ddfdb8eab6525438b2d69", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc"}}
{"id": "sha256:8189eda8bc7a8ef6da083a8167f1c2c935f7ad7779a8a5fab15adaa653b8fd51", "content": "The next example uses the same insert as the preceding example, but, instead of passing in the `id`, it\nretrieves the auto-generated key and sets it on the new `Actor` object. When it creates\nthe `SimpleJdbcInsert`, in addition to specifying the table name, it specifies the name\nof the generated key column with the `usingGeneratedKeyColumns` method. The following\nlisting shows how it works:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private SimpleJdbcInsert insertActor;\n\n public void setDataSource(DataSource dataSource) {\n this.insertActor = new SimpleJdbcInsert(dataSource)\n .withTableName(\"t_actor\")\n .usingGeneratedKeyColumns(\"id\");\n }\n\n public void add(Actor actor) {\n Map<String, Object> parameters = new HashMap<>(2);\n parameters.put(\"first_name\", actor.getFirstName());\n parameters.put(\"last_name\", actor.getLastName());\n Number newId = insertActor.executeAndReturnKey(parameters);\n actor.setId(newId.longValue());\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val insertActor = SimpleJdbcInsert(dataSource)\n .withTableName(\"t_actor\").usingGeneratedKeyColumns(\"id\")\n\n fun add(actor: Actor): Actor {\n val parameters = mapOf(\n \"first_name\" to actor.firstName,\n \"last_name\" to actor.lastName)\n val newId = insertActor.executeAndReturnKey(parameters);\n return actor.copy(id = newId.toLong())\n }\n\n // ... additional methods\n\t}\n----\n======\n\nThe main difference when you run the insert by using this second approach is that you do not\nadd the `id` to the `Map`, and you call the `executeAndReturnKey` method. This returns a\n`java.lang.Number` object with which you can create an instance of the numerical type that\nis used in your domain class. You cannot rely on all databases to return a specific Java\nclass here. `java.lang.Number` is the base class that you can rely on. If you have\nmultiple auto-generated columns or the generated values are non-numeric, you can\nuse a `KeyHolder` that is returned from the `executeAndReturnKeyHolder` method.\n\n[[jdbc-simple-jdbc-insert-3]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc", "title": "simple", "heading": "Retrieving Auto-generated Keys by Using `SimpleJdbcInsert`", "heading_level": 2, "file_order": 117, "section_index": 2, "content_hash": "8189eda8bc7a8ef6da083a8167f1c2c935f7ad7779a8a5fab15adaa653b8fd51", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc"}}
{"id": "sha256:a74b6e4bd39cd50b31a204e3aacdedda0847dcd03cd75bc157618aa7e48a987b", "content": "You can limit the columns for an insert by specifying a list of column names with the\n`usingColumns` method, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private SimpleJdbcInsert insertActor;\n\n public void setDataSource(DataSource dataSource) {\n this.insertActor = new SimpleJdbcInsert(dataSource)\n .withTableName(\"t_actor\")\n .usingColumns(\"first_name\", \"last_name\")\n .usingGeneratedKeyColumns(\"id\");\n }\n\n public void add(Actor actor) {\n Map<String, Object> parameters = new HashMap<>(2);\n parameters.put(\"first_name\", actor.getFirstName());\n parameters.put(\"last_name\", actor.getLastName());\n Number newId = insertActor.executeAndReturnKey(parameters);\n actor.setId(newId.longValue());\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val insertActor = SimpleJdbcInsert(dataSource)\n .withTableName(\"t_actor\")\n .usingColumns(\"first_name\", \"last_name\")\n .usingGeneratedKeyColumns(\"id\")\n\n fun add(actor: Actor): Actor {\n val parameters = mapOf(\n \"first_name\" to actor.firstName,\n \"last_name\" to actor.lastName)\n val newId = insertActor.executeAndReturnKey(parameters);\n return actor.copy(id = newId.toLong())\n }\n\n // ... additional methods\n\t}\n----\n======\n\nThe execution of the insert is the same as if you had relied on the metadata to determine\nwhich columns to use.\n\n[[jdbc-simple-jdbc-parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc", "title": "simple", "heading": "Specifying Columns for a `SimpleJdbcInsert`", "heading_level": 2, "file_order": 117, "section_index": 3, "content_hash": "a74b6e4bd39cd50b31a204e3aacdedda0847dcd03cd75bc157618aa7e48a987b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc"}}
{"id": "sha256:cdef0dc59ed11d423a857f29af7756a1dd5190beae03951b9ce48466c1ce4556", "content": "Using a `Map` to provide parameter values works fine, but it is not the most convenient\nclass to use. Spring provides a couple of implementations of the `SqlParameterSource`\ninterface that you can use instead. The first one is `BeanPropertySqlParameterSource`,\nwhich is a very convenient class if you have a JavaBean-compliant class that contains\nyour values. It uses the corresponding getter method to extract the parameter\nvalues. The following example shows how to use `BeanPropertySqlParameterSource`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private SimpleJdbcInsert insertActor;\n\n public void setDataSource(DataSource dataSource) {\n this.insertActor = new SimpleJdbcInsert(dataSource)\n .withTableName(\"t_actor\")\n .usingGeneratedKeyColumns(\"id\");\n }\n\n public void add(Actor actor) {\n SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor);\n Number newId = insertActor.executeAndReturnKey(parameters);\n actor.setId(newId.longValue());\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val insertActor = SimpleJdbcInsert(dataSource)\n .withTableName(\"t_actor\")\n .usingGeneratedKeyColumns(\"id\")\n\n fun add(actor: Actor): Actor {\n val parameters = BeanPropertySqlParameterSource(actor)\n val newId = insertActor.executeAndReturnKey(parameters)\n return actor.copy(id = newId.toLong())\n }\n\n // ... additional methods\n\t}\n----\n======\n\nAnother option is the `MapSqlParameterSource` that resembles a `Map` but provides a more\nconvenient `addValue` method that can be chained. The following example shows how to use it:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private SimpleJdbcInsert insertActor;\n\n public void setDataSource(DataSource dataSource) {\n this.insertActor = new SimpleJdbcInsert(dataSource)\n .withTableName(\"t_actor\")\n .usingGeneratedKeyColumns(\"id\");\n }\n\n public void add(Actor actor) {\n SqlParameterSource parameters = new MapSqlParameterSource()\n .addValue(\"first_name\", actor.getFirstName())\n .addValue(\"last_name\", actor.getLastName());\n Number newId = insertActor.executeAndReturnKey(parameters);\n actor.setId(newId.longValue());\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val insertActor = SimpleJdbcInsert(dataSource)\n .withTableName(\"t_actor\")\n .usingGeneratedKeyColumns(\"id\")\n\n fun add(actor: Actor): Actor {\n val parameters = MapSqlParameterSource()\n .addValue(\"first_name\", actor.firstName)\n .addValue(\"last_name\", actor.lastName)\n val newId = insertActor.executeAndReturnKey(parameters)\n return actor.copy(id = newId.toLong())\n }\n\n // ... additional methods\n\t}\n----\n======\n\nAs you can see, the configuration is the same. Only the executing code has to change to\nuse these alternative input classes.\n\n[[jdbc-simple-jdbc-call-1]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc", "title": "simple", "heading": "Using `SqlParameterSource` to Provide Parameter Values", "heading_level": 2, "file_order": 117, "section_index": 4, "content_hash": "cdef0dc59ed11d423a857f29af7756a1dd5190beae03951b9ce48466c1ce4556", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc"}}
{"id": "sha256:f1ca59d482395e4f8722601eba4062c2521437ce0bf77f9676b159e49d947363", "content": "The `SimpleJdbcCall` class uses metadata in the database to look up names of `in`\nand `out` parameters so that you do not have to explicitly declare them. You can\ndeclare parameters if you prefer to do that or if you have parameters that do not\nhave an automatic mapping to a Java class. The first example shows a simple procedure\nthat returns only scalar values in `VARCHAR` and `DATE` format from a MySQL database.\nThe example procedure reads a specified actor entry and returns `first_name`,\n`last_name`, and `birth_date` columns in the form of `out` parameters. The following\nlisting shows the first example:\n\n[source,sql,indent=0,subs=\"verbatim,quotes\"]\n----\n\tCREATE PROCEDURE read_actor (\n IN in_id INTEGER,\n OUT out_first_name VARCHAR(100),\n OUT out_last_name VARCHAR(100),\n OUT out_birth_date DATE)\n\tBEGIN\n SELECT first_name, last_name, birth_date\n INTO out_first_name, out_last_name, out_birth_date\n FROM t_actor where id = in_id;\n\tEND;\n----\n\nThe `in_id` parameter contains the `id` of the actor that you are looking up. The `out`\nparameters return the data read from the table.\n\nYou can declare `SimpleJdbcCall` in a manner similar to declaring `SimpleJdbcInsert`. You\nshould instantiate and configure the class in the initialization method of your data-access\nlayer. In contrast to the `StoredProcedure` class, you do not need to create a subclass,\nand you do not need to declare parameters that can be looked up in the database metadata.\nThe following `SimpleJdbcCall` configuration example uses the preceding stored procedure.\nThe only configuration option (other than the `DataSource`) is the name of the stored\nprocedure.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private SimpleJdbcCall procReadActor;\n\n public void setDataSource(DataSource dataSource) {\n this.procReadActor = new SimpleJdbcCall(dataSource)\n .withProcedureName(\"read_actor\");\n }\n\n public Actor readActor(Long id) {\n SqlParameterSource in = new MapSqlParameterSource()\n .addValue(\"in_id\", id);\n Map out = procReadActor.execute(in);\n Actor actor = new Actor();\n actor.setId(id);\n actor.setFirstName((String) out.get(\"out_first_name\"));\n actor.setLastName((String) out.get(\"out_last_name\"));\n actor.setBirthDate((Date) out.get(\"out_birth_date\"));\n return actor;\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val procReadActor = SimpleJdbcCall(dataSource)\n .withProcedureName(\"read_actor\")\n\n fun readActor(id: Long): Actor {\n val source = MapSqlParameterSource().addValue(\"in_id\", id)\n val output = procReadActor.execute(source)\n return Actor(\n id,\n output[\"out_first_name\"] as String,\n output[\"out_last_name\"] as String,\n output[\"out_birth_date\"] as Date)\n }\n\n // ... additional methods\n\t}\n----\n======\n\nThe code you write for the execution of the call involves creating an `SqlParameterSource`\ncontaining the IN parameter. You must match the name provided for the input value\nwith that of the parameter name declared in the stored procedure. The case does not have\nto match because you use metadata to determine how database objects should be referred to\nin a stored procedure. What is specified in the source for the stored procedure is not\nnecessarily the way it is stored in the database. Some databases transform names to all\nupper case, while others use lower case or use the case as specified.\n\nThe `execute` method takes the IN parameters and returns a `Map` that contains any `out`\nparameters keyed by the name, as specified in the stored procedure. In this case, they are\n`out_first_name`, `out_last_name`, and `out_birth_date`.\n\nThe last part of the `execute` method creates an `Actor` instance to use to return the\ndata retrieved. Again, it is important to use the names of the `out` parameters as they\nare declared in the stored procedure. Also, the case in the names of the `out`\nparameters stored in the results map matches that of the `out` parameter names in the\ndatabase, which could vary between databases. To make your code more portable, you should\ndo a case-insensitive lookup or instruct Spring to use a `LinkedCaseInsensitiveMap`.\nTo do the latter, you can create your own `JdbcTemplate` and set the `setResultsMapCaseInsensitive`\nproperty to `true`. Then you can pass this customized `JdbcTemplate` instance into\nthe constructor of your `SimpleJdbcCall`. The following example shows this configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private SimpleJdbcCall procReadActor;\n\n public void setDataSource(DataSource dataSource) {\n JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n jdbcTemplate.setResultsMapCaseInsensitive(true);\n this.procReadActor = new SimpleJdbcCall(jdbcTemplate)\n .withProcedureName(\"read_actor\");\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private var procReadActor = SimpleJdbcCall(JdbcTemplate(dataSource).apply {\n isResultsMapCaseInsensitive = true\n }).withProcedureName(\"read_actor\")\n\n // ... additional methods\n\t}\n----\n======\n\nBy taking this action, you avoid conflicts in the case used for the names of your\nreturned `out` parameters.\n\n[[jdbc-simple-jdbc-call-2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc", "title": "simple", "heading": "Calling a Stored Procedure with `SimpleJdbcCall`", "heading_level": 2, "file_order": 117, "section_index": 5, "content_hash": "f1ca59d482395e4f8722601eba4062c2521437ce0bf77f9676b159e49d947363", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc"}}
{"id": "sha256:f950e80ebda84b0a2a15749e9f6d7698985c2e233d20455fb96c65e49d95f018", "content": "Earlier in this chapter, we described how parameters are deduced from metadata, but you can declare them\nexplicitly if you wish. You can do so by creating and configuring `SimpleJdbcCall` with\nthe `declareParameters` method, which takes a variable number of `SqlParameter` objects\nas input. See the xref:data-access/jdbc/simple.adoc#jdbc-params[next section] for details on how to define an `SqlParameter`.\n\nNOTE: Explicit declarations are necessary if the database you use is not a Spring-supported\ndatabase. Currently, Spring supports metadata lookup of stored procedure calls for the\nfollowing databases: Apache Derby, DB2, MySQL, Microsoft SQL Server, Oracle, and Sybase.\nWe also support metadata lookup of stored functions for MySQL, Microsoft SQL Server,\nand Oracle.\n\nYou can opt to explicitly declare one, some, or all of the parameters. The parameter\nmetadata is still used where you do not explicitly declare parameters. To bypass all\nprocessing of metadata lookups for potential parameters and use only the declared\nparameters, you can call the method `withoutProcedureColumnMetaDataAccess` as part of the\ndeclaration. Suppose that you have two or more different call signatures declared for a\ndatabase function. In this case, you call `useInParameterNames` to specify the list\nof IN parameter names to include for a given signature.\n\nThe following example shows a fully declared procedure call and uses the information from\nthe preceding example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private SimpleJdbcCall procReadActor;\n\n public void setDataSource(DataSource dataSource) {\n JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n jdbcTemplate.setResultsMapCaseInsensitive(true);\n this.procReadActor = new SimpleJdbcCall(jdbcTemplate)\n .withProcedureName(\"read_actor\")\n .withoutProcedureColumnMetaDataAccess()\n .useInParameterNames(\"in_id\")\n .declareParameters(\n new SqlParameter(\"in_id\", Types.NUMERIC),\n new SqlOutParameter(\"out_first_name\", Types.VARCHAR),\n new SqlOutParameter(\"out_last_name\", Types.VARCHAR),\n new SqlOutParameter(\"out_birth_date\", Types.DATE)\n );\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val procReadActor = SimpleJdbcCall(JdbcTemplate(dataSource).apply {\n isResultsMapCaseInsensitive = true\n }).withProcedureName(\"read_actor\")\n .withoutProcedureColumnMetaDataAccess()\n .useInParameterNames(\"in_id\")\n .declareParameters(\n SqlParameter(\"in_id\", Types.NUMERIC),\n SqlOutParameter(\"out_first_name\", Types.VARCHAR),\n SqlOutParameter(\"out_last_name\", Types.VARCHAR),\n SqlOutParameter(\"out_birth_date\", Types.DATE)\n )\n\n // ... additional methods\n\t}\n----\n======\n\nThe execution and end results of the two examples are the same. The second example specifies all\ndetails explicitly rather than relying on metadata.\n\n[[jdbc-params]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc", "title": "simple", "heading": "Explicitly Declaring Parameters to Use for a `SimpleJdbcCall`", "heading_level": 2, "file_order": 117, "section_index": 6, "content_hash": "f950e80ebda84b0a2a15749e9f6d7698985c2e233d20455fb96c65e49d95f018", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc"}}
{"id": "sha256:eac12471ff719f0dd323f221ffdac48b493efb2589f8394a08f233843e9a0bc9", "content": "To define a parameter for the `SimpleJdbc` classes and also for the RDBMS operations\nclasses (covered in xref:data-access/jdbc/object.adoc[Modeling JDBC Operations as Java Objects]) you can use `SqlParameter` or one of its subclasses.\nTo do so, you typically specify the parameter name and SQL type in the constructor. The SQL type\nis specified by using the `java.sql.Types` constants. Earlier in this chapter, we saw declarations\nsimilar to the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tnew SqlParameter(\"in_id\", Types.NUMERIC),\n\tnew SqlOutParameter(\"out_first_name\", Types.VARCHAR),\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tSqlParameter(\"in_id\", Types.NUMERIC),\n\tSqlOutParameter(\"out_first_name\", Types.VARCHAR),\n----\n======\n\nThe first line with the `SqlParameter` declares an IN parameter. You can use IN parameters\nfor both stored procedure calls and for queries by using the `SqlQuery` and its\nsubclasses (covered in xref:data-access/jdbc/object.adoc#jdbc-SqlQuery[Understanding `SqlQuery`]).\n\nThe second line (with the `SqlOutParameter`) declares an `out` parameter to be used in a\nstored procedure call. There is also an `SqlInOutParameter` for `InOut` parameters\n(parameters that provide an IN value to the procedure and that also return a value).\n\nNOTE: Only parameters declared as `SqlParameter` and `SqlInOutParameter` are used to\nprovide input values. This is different from the `StoredProcedure` class, which (for\nbackwards compatibility reasons) lets input values be provided for parameters\ndeclared as `SqlOutParameter`.\n\nFor IN parameters, in addition to the name and the SQL type, you can specify a scale for\nnumeric data or a type name for custom database types. For `out` parameters, you can\nprovide a `RowMapper` to handle mapping of rows returned from a `REF` cursor. Another\noption is to specify an `SqlReturnType` that provides an opportunity to define\ncustomized handling of the return values.\n\n[[jdbc-simple-jdbc-call-3]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc", "title": "simple", "heading": "How to Define `SqlParameters`", "heading_level": 2, "file_order": 117, "section_index": 7, "content_hash": "eac12471ff719f0dd323f221ffdac48b493efb2589f8394a08f233843e9a0bc9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc"}}
{"id": "sha256:ec84b90d8662f90a918d6ba44c6816f28f0e68e7d81ef5d44d6206abe1647249", "content": "You can call a stored function in almost the same way as you call a stored procedure, except\nthat you provide a function name rather than a procedure name. You use the\n`withFunctionName` method as part of the configuration to indicate that you want to make\na call to a function, and the corresponding string for a function call is generated. A\nspecialized call (`executeFunction`) is used to run the function, and it\nreturns the function return value as an object of a specified type, which means you do\nnot have to retrieve the return value from the results map. A similar convenience method\n(named `executeObject`) is also available for stored procedures that have only one `out`\nparameter. The following example (for MySQL) is based on a stored function named `get_actor_name`\nthat returns an actor's full name:\n\n[source,sql,indent=0,subs=\"verbatim,quotes\"]\n----\n\tCREATE FUNCTION get_actor_name (in_id INTEGER)\n\tRETURNS VARCHAR(200) READS SQL DATA\n\tBEGIN\n DECLARE out_name VARCHAR(200);\n SELECT concat(first_name, ' ', last_name)\n INTO out_name\n FROM t_actor where id = in_id;\n RETURN out_name;\n\tEND;\n----\n\nTo call this function, we again create a `SimpleJdbcCall` in the initialization method,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private SimpleJdbcCall funcGetActorName;\n\n public void setDataSource(DataSource dataSource) {\n JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n jdbcTemplate.setResultsMapCaseInsensitive(true);\n this.funcGetActorName = new SimpleJdbcCall(jdbcTemplate)\n .withFunctionName(\"get_actor_name\");\n }\n\n public String getActorName(Long id) {\n SqlParameterSource in = new MapSqlParameterSource()\n .addValue(\"in_id\", id);\n String name = funcGetActorName.executeFunction(String.class, in);\n return name;\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val jdbcTemplate = JdbcTemplate(dataSource).apply {\n isResultsMapCaseInsensitive = true\n }\n private val funcGetActorName = SimpleJdbcCall(jdbcTemplate)\n .withFunctionName(\"get_actor_name\")\n\n fun getActorName(id: Long): String {\n val source = MapSqlParameterSource().addValue(\"in_id\", id)\n return funcGetActorName.executeFunction(String::class.java, source)\n }\n\n // ... additional methods\n\t}\n----\n======\n\nThe `executeFunction` method used returns a `String` that contains the return value from the\nfunction call.\n\n[[jdbc-simple-jdbc-call-4]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc", "title": "simple", "heading": "Calling a Stored Function by Using `SimpleJdbcCall`", "heading_level": 2, "file_order": 117, "section_index": 8, "content_hash": "ec84b90d8662f90a918d6ba44c6816f28f0e68e7d81ef5d44d6206abe1647249", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc"}}
{"id": "sha256:ce1752f6b2ac62d436d76583b451f9d1113c021ed3869a85ce27f372b45e48fd", "content": "Calling a stored procedure or function that returns a result set is a bit tricky. Some\ndatabases return result sets during the JDBC results processing, while others require an\nexplicitly registered `out` parameter of a specific type. Both approaches need\nadditional processing to loop over the result set and process the returned rows. With\nthe `SimpleJdbcCall`, you can use the `returningResultSet` method and declare a `RowMapper`\nimplementation to be used for a specific parameter. If the result set is\nreturned during the results processing, there are no names defined, so the returned\nresults must match the order in which you declare the `RowMapper`\nimplementations. The name specified is still used to store the processed list of results\nin the results map that is returned from the `execute` statement.\n\nThe next example (for MySQL) uses a stored procedure that takes no IN parameters and returns\nall rows from the `t_actor` table:\n\n[source,sql,indent=0,subs=\"verbatim,quotes\"]\n----\n\tCREATE PROCEDURE read_all_actors()\n\tBEGIN\n SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a;\n\tEND;\n----\n\nTo call this procedure, you can declare the `RowMapper`. Because the class to which you want\nto map follows the JavaBean rules, you can use a `BeanPropertyRowMapper` that is created by\npassing in the required class to map to in the `newInstance` method.\nThe following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class JdbcActorDao implements ActorDao {\n\n private SimpleJdbcCall procReadAllActors;\n\n public void setDataSource(DataSource dataSource) {\n JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n jdbcTemplate.setResultsMapCaseInsensitive(true);\n this.procReadAllActors = new SimpleJdbcCall(jdbcTemplate)\n .withProcedureName(\"read_all_actors\")\n .returningResultSet(\"actors\",\n BeanPropertyRowMapper.newInstance(Actor.class));\n }\n\n public List getActorsList() {\n Map m = procReadAllActors.execute(new HashMap<String, Object>(0));\n return (List) m.get(\"actors\");\n }\n\n // ... additional methods\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass JdbcActorDao(dataSource: DataSource) : ActorDao {\n\n private val procReadAllActors = SimpleJdbcCall(JdbcTemplate(dataSource).apply {\n isResultsMapCaseInsensitive = true\n }).withProcedureName(\"read_all_actors\")\n .returningResultSet(\"actors\",\n BeanPropertyRowMapper.newInstance(Actor::class.java))\n\n fun getActorsList(): List<Actor> {\n val m = procReadAllActors.execute(mapOf<String, Any>())\n return m[\"actors\"] as List<Actor>\n }\n\n // ... additional methods\n\t}\n----\n======\n\nThe `execute` call passes in an empty `Map`, because this call does not take any parameters.\nThe list of actors is then retrieved from the results map and returned to the caller.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc", "title": "simple", "heading": "Returning a `ResultSet` or REF Cursor from a `SimpleJdbcCall`", "heading_level": 2, "file_order": 117, "section_index": 9, "content_hash": "ce1752f6b2ac62d436d76583b451f9d1113c021ed3869a85ce27f372b45e48fd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc/simple.adoc"}}
{"id": "sha256:10f776cf1d18acf925030ba8f0745a905688dd4297f8144234b3e41380518dd6", "content": "[[orm-general]]\n\nThis section highlights considerations that apply to all ORM technologies.\nThe xref:data-access/orm/hibernate.adoc[Hibernate] section provides more details and also show these features and\nconfigurations in a concrete context.\n\nThe major goal of Spring's ORM integration is clear application layering (with any data\naccess and transaction technology) and for loose coupling of application objects -- no\nmore business service dependencies on the data access or transaction strategy, no more\nhard-coded resource lookups, no more hard-to-replace singletons, no more custom service\nregistries. The goal is to have one simple and consistent approach to wiring up application objects, keeping\nthem as reusable and free from container dependencies as possible. All the individual\ndata access features are usable on their own but integrate nicely with Spring's\napplication context concept, providing XML-based configuration and cross-referencing of\nplain JavaBean instances that need not be Spring-aware. In a typical Spring application,\nmany important objects are JavaBeans: data access templates, data access objects,\ntransaction managers, business services that use the data access objects and transaction\nmanagers, web view resolvers, web controllers that use the business services, and so on.\n\n[[orm-resource-mngmnt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/general.adoc", "title": "general", "heading": "general", "heading_level": 1, "file_order": 118, "section_index": 0, "content_hash": "10f776cf1d18acf925030ba8f0745a905688dd4297f8144234b3e41380518dd6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/general.adoc"}}
{"id": "sha256:1fcf52316df8d50ee9f3d85732f52309f800690211c2b357c6feb639d73f3358", "content": "Typical business applications are cluttered with repetitive resource management code.\nMany projects try to invent their own solutions, sometimes sacrificing proper handling\nof failures for programming convenience. Spring advocates simple solutions for proper\nresource handling, namely IoC through templating in the case of JDBC and applying AOP\ninterceptors for the ORM technologies.\n\nThe infrastructure provides proper resource handling and appropriate conversion of\nspecific API exceptions to an unchecked infrastructure exception hierarchy. Spring\nintroduces a DAO exception hierarchy, applicable to any data access strategy. For direct\nJDBC, the `JdbcTemplate` class mentioned in a xref:data-access/jdbc/core.adoc#jdbc-JdbcTemplate[previous section]\nprovides connection handling and proper conversion of `SQLException` to the\n`DataAccessException` hierarchy, including translation of database-specific SQL error\ncodes to meaningful exception classes. For ORM technologies, see the\nxref:data-access/orm/general.adoc#orm-exception-translation[next section] for how to get the same exception\ntranslation benefits.\n\nWhen it comes to transaction management, the `JdbcTemplate` class hooks in to the Spring\ntransaction support and supports both JTA and JDBC transactions, through respective\nSpring transaction managers. For the supported ORM technologies, Spring offers Hibernate\nand JPA support through the Hibernate and JPA transaction managers as well as JTA support.\nFor details on transaction support, see the xref:data-access/transaction.adoc[Transaction Management] chapter.\n\n[[orm-exception-translation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/general.adoc", "title": "general", "heading": "Resource and Transaction Management", "heading_level": 2, "file_order": 118, "section_index": 1, "content_hash": "1fcf52316df8d50ee9f3d85732f52309f800690211c2b357c6feb639d73f3358", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/general.adoc"}}
{"id": "sha256:171f942aa862e709749c24080aafad159e9072c36652b71574f5c46ad8d8aed8", "content": "When you use Hibernate or JPA in a DAO, you must decide how to handle the persistence\ntechnology's native exception classes. The DAO throws a subclass of a `HibernateException`\nor `PersistenceException`, depending on the technology. These exceptions are all runtime\nexceptions and do not have to be declared or caught. You may also have to deal with\n`IllegalArgumentException` and `IllegalStateException`. This means that callers can only\ntreat exceptions as being generally fatal, unless they want to depend on the persistence\ntechnology's own exception structure. Catching specific causes (such as an optimistic\nlocking failure) is not possible without tying the caller to the implementation strategy.\nThis trade-off might be acceptable to applications that are strongly ORM-based or\ndo not need any special exception treatment (or both). However, Spring lets exception\ntranslation be applied transparently through the `@Repository` annotation. The following\nexamples (one for Java configuration and one for XML configuration) show how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository\n\tpublic class ProductDaoImpl implements ProductDao {\n\n // class body here...\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository\n\tclass ProductDaoImpl : ProductDao {\n\n // class body here...\n\n\t}\n----\n======\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <!-- Exception translation bean post processor -->\n <bean class=\"org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor\"/>\n\n <bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"/>\n\n\t</beans>\n----\n\nThe postprocessor automatically looks for all exception translators (implementations of\nthe `PersistenceExceptionTranslator` interface) and advises all beans marked with the\n`@Repository` annotation so that the discovered translators can intercept and apply the\nappropriate translation on the thrown exceptions.\n\nIn summary, you can implement DAOs based on the plain persistence technology's API and\nannotations while still benefiting from Spring-managed transactions, dependency\ninjection, and transparent exception conversion (if desired) to Spring's custom\nexception hierarchies.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/general.adoc", "title": "general", "heading": "Exception Translation", "heading_level": 2, "file_order": 118, "section_index": 2, "content_hash": "171f942aa862e709749c24080aafad159e9072c36652b71574f5c46ad8d8aed8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/general.adoc"}}
{"id": "sha256:c17c1094cf7f811c8de96a4b4422d3a52b64695a8b8c75830e0183a8775247ee", "content": "[[orm-hibernate]]\n\nWe start with a coverage of https://hibernate.org/[Hibernate] in a Spring environment,\nusing it to demonstrate the approach that Spring takes towards integrating OR mappers.\nThis section covers many issues in detail and shows different variations of DAO\nimplementations and transaction demarcation. Most of these patterns can be directly\ntranslated to all other supported ORM tools. The later sections in this chapter then\ncover the other ORM technologies and show brief examples.\n\n[NOTE]\n====\nAs of Spring Framework 7.0, Spring requires Hibernate ORM 7.x for Spring's\n`HibernateJpaVendorAdapter`.\n\nThe `org.springframework.orm.jpa.hibernate` package supersedes the former `orm.hibernate5`:\nnow for use with Hibernate ORM 7.x, tightly integrated with `HibernateJpaVendorAdapter`\nas well as supporting Hibernate's native `SessionFactory.getCurrentSession()` style.\n====\n\n[[orm-session-factory-setup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc", "title": "hibernate", "heading": "hibernate", "heading_level": 1, "file_order": 119, "section_index": 0, "content_hash": "c17c1094cf7f811c8de96a4b4422d3a52b64695a8b8c75830e0183a8775247ee", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc"}}
{"id": "sha256:424aac5447afc0dd901bb4faf095e4bdc737707043852d1b2da46b91a9894c45", "content": "To avoid tying application objects to hard-coded resource lookups, you can define\nresources (such as a JDBC `DataSource` or a Hibernate `SessionFactory`) as beans in the\nSpring container. Application objects that need to access resources receive references\nto such predefined instances through bean references, as illustrated in the DAO\ndefinition in the xref:data-access/orm/hibernate.adoc#orm-hibernate-straight[next section].\n\nThe following excerpt from an XML application context definition shows how to set up a\nJDBC `DataSource` and a Hibernate `SessionFactory` on top of it:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"myDataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n <property name=\"driverClassName\" value=\"org.hsqldb.jdbcDriver\"/>\n <property name=\"url\" value=\"jdbc:hsqldb:hsql://localhost:9001\"/>\n <property name=\"username\" value=\"sa\"/>\n <property name=\"password\" value=\"\"/>\n </bean>\n\n <bean id=\"mySessionFactory\" class=\"org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean\">\n <property name=\"dataSource\" ref=\"myDataSource\"/>\n <property name=\"mappingResources\">\n <list>\n <value>product.hbm.xml</value>\n </list>\n </property>\n <property name=\"hibernateProperties\">\n <value>\n hibernate.dialect=org.hibernate.dialect.HSQLDialect\n </value>\n </property>\n </bean>\n\n\t</beans>\n----\n\nSwitching from a local Jakarta Commons DBCP `BasicDataSource` to a JNDI-located\n`DataSource` (usually managed by an application server) is only a matter of\nconfiguration, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <jee:jndi-lookup id=\"myDataSource\" jndi-name=\"java:comp/env/jdbc/myds\"/>\n\t</beans>\n----\n\nYou can also access a JNDI-located `SessionFactory`, using Spring's\n`JndiObjectFactoryBean` / `<jee:jndi-lookup>` to retrieve and expose it.\nHowever, that is typically not common outside of an EJB context.\n\n[NOTE]\n====\nSpring also provides a `LocalSessionFactoryBuilder` variant, seamlessly integrating\nwith `@Bean` style configuration and programmatic setup (no `FactoryBean` involved).\n\nBoth `LocalSessionFactoryBean` and `LocalSessionFactoryBuilder` support background\nbootstrapping, with Hibernate initialization running in parallel to the application\nbootstrap thread on a given bootstrap executor (such as a `SimpleAsyncTaskExecutor`).\nOn `LocalSessionFactoryBean`, this is available through the `bootstrapExecutor`\nproperty. On the programmatic `LocalSessionFactoryBuilder`, there is an overloaded\n`buildSessionFactory` method that takes a bootstrap executor argument.\n\nSuch a native Hibernate setup can also expose a JPA `EntityManagerFactory` for standard\nJPA interaction next to native Hibernate access.\nSee xref:data-access/orm/jpa.adoc#orm-jpa-hibernate[Native Hibernate Setup for JPA] for details.\n====\n\n[[orm-hibernate-straight]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc", "title": "hibernate", "heading": "`SessionFactory` Setup in a Spring Container", "heading_level": 2, "file_order": 119, "section_index": 1, "content_hash": "424aac5447afc0dd901bb4faf095e4bdc737707043852d1b2da46b91a9894c45", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc"}}
{"id": "sha256:96b635380f32b2de3044834e0c4d2e4e26eb4cbc9d02200945673e9e8e72694b", "content": "Hibernate has a feature called contextual sessions, wherein Hibernate itself manages\none current `Session` per transaction. This is roughly equivalent to Spring's\nsynchronization of one Hibernate `Session` per transaction. A corresponding DAO\nimplementation resembles the following example, based on the plain Hibernate API:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ProductDaoImpl implements ProductDao {\n\n private SessionFactory sessionFactory;\n\n public void setSessionFactory(SessionFactory sessionFactory) {\n this.sessionFactory = sessionFactory;\n }\n\n public Collection loadProductsByCategory(String category) {\n return this.sessionFactory.getCurrentSession()\n .createQuery(\"from test.Product product where product.category=?\")\n .setParameter(0, category)\n .list();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ProductDaoImpl(private val sessionFactory: SessionFactory) : ProductDao {\n\n fun loadProductsByCategory(category: String): Collection<*> {\n return sessionFactory.currentSession\n .createQuery(\"from test.Product product where product.category=?\")\n .setParameter(0, category)\n .list()\n }\n\t}\n----\n======\n\nThis style is similar to that of the Hibernate reference documentation and examples,\nexcept for holding the `SessionFactory` in an instance variable. We strongly recommend\nsuch an instance-based setup over the old-school `static` `HibernateUtil` class from\nHibernate's CaveatEmptor sample application. (In general, do not keep any resources in\n`static` variables unless absolutely necessary.)\n\nThe preceding DAO example follows the dependency injection pattern. It fits nicely into a Spring IoC\ncontainer, as it would if coded against Spring's `HibernateTemplate`.\nYou can also set up such a DAO in plain Java (for example, in unit tests). To do so,\ninstantiate it and call `setSessionFactory(..)` with the desired factory reference. As a\nSpring bean definition, the DAO would resemble the following:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"myProductDao\" class=\"product.ProductDaoImpl\">\n <property name=\"sessionFactory\" ref=\"mySessionFactory\"/>\n </bean>\n\n\t</beans>\n----\n\nThe main advantage of this DAO style is that it depends on Hibernate API only. No import\nof any Spring class is required. This is appealing from a non-invasiveness\nperspective and may feel more natural to Hibernate developers.\n\nHowever, the DAO throws plain `HibernateException` (which is unchecked, so it does not have\nto be declared or caught), which means that callers can treat exceptions only as being\ngenerally fatal -- unless they want to depend on Hibernate's own exception hierarchy.\nCatching specific causes (such as an optimistic locking failure) is not possible without\ntying the caller to the implementation strategy. This trade off might be acceptable to\napplications that are strongly Hibernate-based, do not need any special exception\ntreatment, or both.\n\nFortunately, Spring's `LocalSessionFactoryBean` supports Hibernate's\n`SessionFactory.getCurrentSession()` method for any Spring transaction strategy,\nreturning the current Spring-managed transactional `Session`, even with\n`HibernateTransactionManager`. The standard behavior of that method remains\nto return the current `Session` associated with the ongoing JTA transaction, if any.\nThis behavior applies regardless of whether you use Spring's\n`JtaTransactionManager`, EJB container managed transactions (CMTs), or JTA.\n\nIn summary, you can implement DAOs based on the plain Hibernate API, while still being\nable to participate in Spring-managed transactions.\n\n[[orm-hibernate-tx-declarative]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc", "title": "hibernate", "heading": "Implementing DAOs Based on the Plain Hibernate API", "heading_level": 2, "file_order": 119, "section_index": 2, "content_hash": "96b635380f32b2de3044834e0c4d2e4e26eb4cbc9d02200945673e9e8e72694b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc"}}
{"id": "sha256:86606c3f21b8971a14cf2994c0d0c5d397bdf0cb5e21af1974ce96a28aad10a5", "content": "We recommend that you use Spring's declarative transaction support, which lets you\nreplace explicit transaction demarcation API calls in your Java code with an AOP\ntransaction interceptor. You can configure this transaction interceptor in a Spring\ncontainer by using either Java annotations or XML. This declarative transaction capability\nlets you keep business services free of repetitive transaction demarcation code and\nfocus on adding business logic, which is the real value of your application.\n\nNOTE: Before you continue, we are strongly encourage you to read xref:data-access/transaction/declarative.adoc[Declarative Transaction Management]\nif you have not already done so.\n\nYou can annotate the service layer with `@Transactional` annotations and instruct the\nSpring container to find these annotations and provide transactional semantics for\nthese annotated methods. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ProductServiceImpl implements ProductService {\n\n private ProductDao productDao;\n\n public void setProductDao(ProductDao productDao) {\n this.productDao = productDao;\n }\n\n @Transactional\n public void increasePriceOfAllProductsInCategory(final String category) {\n List productsToChange = this.productDao.loadProductsByCategory(category);\n // ...\n }\n\n @Transactional(readOnly = true)\n public List<Product> findAllProducts() {\n return this.productDao.findAllProducts();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ProductServiceImpl(private val productDao: ProductDao) : ProductService {\n\n @Transactional\n fun increasePriceOfAllProductsInCategory(category: String) {\n val productsToChange = productDao.loadProductsByCategory(category)\n // ...\n }\n\n @Transactional(readOnly = true)\n fun findAllProducts() = productDao.findAllProducts()\n\t}\n----\n======\n\nIn the container, you need to set up the `PlatformTransactionManager` implementation\n(as a bean) and a `<tx:annotation-driven/>` entry, opting into `@Transactional`\nprocessing at runtime. The following example shows how to do so:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:aop=\"http://www.springframework.org/schema/aop\"\n xmlns:tx=\"http://www.springframework.org/schema/tx\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/tx\n https://www.springframework.org/schema/tx/spring-tx.xsd\n http://www.springframework.org/schema/aop\n https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n <!-- SessionFactory, DataSource, etc. omitted -->\n\n <bean id=\"transactionManager\"\n class=\"org.springframework.orm.jpa.hibernate.HibernateTransactionManager\">\n <property name=\"sessionFactory\" ref=\"sessionFactory\"/>\n </bean>\n\n <tx:annotation-driven/>\n\n <bean id=\"myProductService\" class=\"product.SimpleProductService\">\n <property name=\"productDao\" ref=\"myProductDao\"/>\n </bean>\n\n\t</beans>\n----\n\n[[orm-hibernate-tx-programmatic]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc", "title": "hibernate", "heading": "Declarative Transaction Demarcation", "heading_level": 2, "file_order": 119, "section_index": 3, "content_hash": "86606c3f21b8971a14cf2994c0d0c5d397bdf0cb5e21af1974ce96a28aad10a5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc"}}
{"id": "sha256:a98bcadb72328d10d86e8013b04dd8e94cdf518458fe90b846bab5b05802cdcb", "content": "You can demarcate transactions in a higher level of the application, on top of\nlower-level data access services that span any number of operations. Nor do restrictions\nexist on the implementation of the surrounding business service. It needs only a Spring\n`PlatformTransactionManager`. Again, the latter can come from anywhere, but preferably\nas a bean reference through a `setTransactionManager(..)` method. Also, the\n`productDAO` should be set by a `setProductDao(..)` method. The following pair of snippets show\na transaction manager and a business service definition in a Spring application context\nand an example for a business method implementation:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"myTxManager\" class=\"org.springframework.orm.jpa.hibernate.HibernateTransactionManager\">\n <property name=\"sessionFactory\" ref=\"mySessionFactory\"/>\n </bean>\n\n <bean id=\"myProductService\" class=\"product.ProductServiceImpl\">\n <property name=\"transactionManager\" ref=\"myTxManager\"/>\n <property name=\"productDao\" ref=\"myProductDao\"/>\n </bean>\n\n\t</beans>\n----\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ProductServiceImpl implements ProductService {\n\n private TransactionTemplate transactionTemplate;\n private ProductDao productDao;\n\n public void setTransactionManager(PlatformTransactionManager transactionManager) {\n this.transactionTemplate = new TransactionTemplate(transactionManager);\n }\n\n public void setProductDao(ProductDao productDao) {\n this.productDao = productDao;\n }\n\n public void increasePriceOfAllProductsInCategory(final String category) {\n this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {\n public void doInTransactionWithoutResult(TransactionStatus status) {\n List productsToChange = this.productDao.loadProductsByCategory(category);\n // do the price increase...\n }\n });\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ProductServiceImpl(transactionManager: PlatformTransactionManager,\n private val productDao: ProductDao) : ProductService {\n\n private val transactionTemplate = TransactionTemplate(transactionManager)\n\n fun increasePriceOfAllProductsInCategory(category: String) {\n transactionTemplate.execute {\n val productsToChange = productDao.loadProductsByCategory(category)\n // do the price increase...\n }\n }\n\t}\n----\n======\n\nSpring's `TransactionInterceptor` lets any checked application exception be thrown\nwith the callback code, while `TransactionTemplate` is restricted to unchecked\nexceptions within the callback. `TransactionTemplate` triggers a rollback in case of\nan unchecked application exception or if the transaction is marked rollback-only by\nthe application (by setting `TransactionStatus`). By default, `TransactionInterceptor`\nbehaves the same way but allows configurable rollback policies per method.\n\n[[orm-hibernate-tx-strategies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc", "title": "hibernate", "heading": "Programmatic Transaction Demarcation", "heading_level": 2, "file_order": 119, "section_index": 4, "content_hash": "a98bcadb72328d10d86e8013b04dd8e94cdf518458fe90b846bab5b05802cdcb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc"}}
{"id": "sha256:a72b32af0844ff71dd0d23f22cc153172cba5504fed608451f84cea5c7742574", "content": "Both `TransactionTemplate` and `TransactionInterceptor` delegate the actual transaction\nhandling to a `PlatformTransactionManager` instance (which can be a\n`HibernateTransactionManager` (for a single Hibernate `SessionFactory`) by using a\n`ThreadLocal` `Session` under the hood) or a `JtaTransactionManager` (delegating to the\nJTA subsystem of the container) for Hibernate applications. You can even use a custom\n`PlatformTransactionManager` implementation. Switching from native Hibernate transaction\nmanagement to JTA (such as when facing distributed transaction requirements for certain\ndeployments of your application) is only a matter of configuration. You can replace\nthe Hibernate transaction manager with Spring's JTA transaction implementation. Both\ntransaction demarcation and data access code work without changes, because they\nuse the generic transaction management APIs.\n\nFor distributed transactions across multiple Hibernate session factories, you can combine\n`JtaTransactionManager` as a transaction strategy with multiple\n`LocalSessionFactoryBean` definitions. Each DAO then gets one specific `SessionFactory`\nreference passed into its corresponding bean property. If all underlying JDBC data\nsources are transactional container ones, a business service can demarcate transactions\nacross any number of DAOs and any number of session factories without special regard, as\nlong as it uses `JtaTransactionManager` as the strategy.\n\nBoth `HibernateTransactionManager` and `JtaTransactionManager` allow for proper\nJVM-level cache handling with Hibernate, without container-specific transaction manager\nlookup or a JCA connector (if you do not use EJB to initiate transactions).\n\n`HibernateTransactionManager` can export the Hibernate JDBC `Connection` to plain JDBC\naccess code for a specific `DataSource`. This ability allows for high-level\ntransaction demarcation with mixed Hibernate and JDBC data access completely without\nJTA, provided you access only one database. `HibernateTransactionManager` automatically\nexposes the Hibernate transaction as a JDBC transaction if you have set up the passed-in\n`SessionFactory` with a `DataSource` through the `dataSource` property of the\n`LocalSessionFactoryBean` class. Alternatively, you can specify explicitly the\n`DataSource` for which the transactions are supposed to be exposed through the\n`dataSource` property of the `HibernateTransactionManager` class.\n\nFor JTA-style lazy retrieval of actual resource connections, Spring provides a\ncorresponding `DataSource` proxy class for the target connection pool: see\n{spring-framework-api}/jdbc/datasource/LazyConnectionDataSourceProxy.html[`LazyConnectionDataSourceProxy`].\nThis is particularly useful for Hibernate read-only transactions which can often\nbe processed from a local cache rather than hitting the database.\n\n[[orm-hibernate-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc", "title": "hibernate", "heading": "Transaction Management Strategies", "heading_level": 2, "file_order": 119, "section_index": 5, "content_hash": "a72b32af0844ff71dd0d23f22cc153172cba5504fed608451f84cea5c7742574", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc"}}
{"id": "sha256:d2ff25a55ff70fb28e54c3b5c2c3619511d4c75c9746fe09b4bd3766a35a7819", "content": "You can switch between a container-managed JNDI `SessionFactory` and a locally defined\none without having to change a single line of application code. Whether to keep\nresource definitions in the container or locally within the application is mainly a\nmatter of the transaction strategy that you use. Compared to a Spring-defined local\n`SessionFactory`, a manually registered JNDI `SessionFactory` does not provide any\nbenefits. Deploying a `SessionFactory` through Hibernate's JCA connector provides the\nadded value of participating in the Jakarta EE server's management infrastructure, but does\nnot add actual value beyond that.\n\nSpring's transaction support is not bound to a container. When configured with any strategy\nother than JTA, transaction support also works in a stand-alone or test environment.\nEspecially in the typical case of single-database transactions, Spring's single-resource\nlocal transaction support is a lightweight and powerful alternative to JTA. When you use\nlocal EJB stateless session beans to drive transactions, you depend both on an EJB\ncontainer and on JTA, even if you access only a single database and use only stateless\nsession beans to provide declarative transactions through container-managed\ntransactions. Direct use of JTA programmatically also requires a Jakarta EE environment.\n\nSpring-driven transactions can work as well with a locally defined Hibernate\n`SessionFactory` as they do with a local JDBC `DataSource`, provided they access a\nsingle database. Thus, you need only use Spring's JTA transaction strategy when you\nhave distributed transaction requirements. A JCA connector requires container-specific\ndeployment steps, and (obviously) JCA support in the first place. This configuration\nrequires more work than deploying a simple web application with local resource\ndefinitions and Spring-driven transactions.\n\nAll things considered, if you do not use EJBs, stick with local `SessionFactory` setup\nand Spring's `HibernateTransactionManager` or `JtaTransactionManager`. You get all of\nthe benefits, including proper transactional JVM-level caching and distributed\ntransactions, without the inconvenience of container deployment. JNDI registration of a\nHibernate `SessionFactory` through the JCA connector adds value only when used in\nconjunction with EJBs.\n\n[[orm-hibernate-invalid-jdbc-access-error]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc", "title": "hibernate", "heading": "Comparing Container-managed and Locally Defined Resources", "heading_level": 2, "file_order": 119, "section_index": 6, "content_hash": "d2ff25a55ff70fb28e54c3b5c2c3619511d4c75c9746fe09b4bd3766a35a7819", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc"}}
{"id": "sha256:741ea951e921964781f499929cd7338502bddac286b9cf6380125c362ee14219", "content": "In some JTA environments with very strict `XADataSource` implementations (currently\nsome WebLogic Server and WebSphere versions), when Hibernate is configured without\nregard to the JTA transaction manager for that environment, spurious warnings or\nexceptions can show up in the application server log. These warnings or exceptions\nindicate that the connection being accessed is no longer valid or JDBC access is no\nlonger valid, possibly because the transaction is no longer active. As an example,\nhere is an actual exception from WebLogic:\n\n[literal]\n[subs=\"verbatim,quotes\"]\n----\njava.sql.SQLException: The transaction is no longer active - status: 'Committed'. No\nfurther JDBC access is allowed within this transaction.\n----\n\nAnother common problem is a connection leak after JTA transactions, with Hibernate\nsessions (and potentially underlying JDBC connections) not getting closed properly.\n\nYou can resolve such issues by making Hibernate aware of the JTA transaction manager,\nto which it synchronizes (along with Spring). You have two options for doing this:\n\n* Pass your Spring `JtaTransactionManager` bean to your Hibernate setup. The easiest\n way is a bean reference into the `jtaTransactionManager` property for your\n `LocalSessionFactoryBean` bean (see xref:data-access/transaction/strategies.adoc#transaction-strategies-hibernate[Hibernate Transaction Setup]).\n Spring then makes the corresponding JTA strategies available to Hibernate.\n* You may also configure Hibernate's JTA-related properties explicitly, in particular\n \"hibernate.transaction.coordinator_class\", \"hibernate.connection.handling_mode\"\n and potentially \"hibernate.transaction.jta.platform\" in your \"hibernateProperties\"\n on `LocalSessionFactoryBean` (see Hibernate's manual for details on those properties).\n\nThe remainder of this section describes the sequence of events that occur with and\nwithout Hibernate's awareness of the JTA `PlatformTransactionManager`.\n\nWhen Hibernate is not configured with any awareness of the JTA transaction manager,\nthe following events occur when a JTA transaction commits:\n\n* The JTA transaction commits.\n* Spring's `JtaTransactionManager` is synchronized to the JTA transaction, so it is\n called back through an `afterCompletion` callback by the JTA transaction manager.\n* Among other activities, this synchronization can trigger a callback by Spring to\n Hibernate, through Hibernate's `afterTransactionCompletion` callback (used to clear\n the Hibernate cache), followed by an explicit `close()` call on the Hibernate session,\n which causes Hibernate to attempt to `close()` the JDBC Connection.\n* In some environments, this `Connection.close()` call then triggers the warning or\n error, as the application server no longer considers the `Connection` to be usable,\n because the transaction has already been committed.\n\nWhen Hibernate is configured with awareness of the JTA transaction manager,\nthe following events occur when a JTA transaction commits:\n\n* The JTA transaction is ready to commit.\n* Spring's `JtaTransactionManager` is synchronized to the JTA transaction, so the\n transaction is called back through a `beforeCompletion` callback by the JTA\n transaction manager.\n* Spring is aware that Hibernate itself is synchronized to the JTA transaction and\n behaves differently than in the previous scenario. In particular, it aligns with\n Hibernate's transactional resource management.\n* The JTA transaction commits.\n* Hibernate is synchronized to the JTA transaction, so the transaction is called back\n through an `afterCompletion` callback by the JTA transaction manager and can\n properly clear its cache.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc", "title": "hibernate", "heading": "Spurious Application Server Warnings with Hibernate", "heading_level": 2, "file_order": 119, "section_index": 7, "content_hash": "741ea951e921964781f499929cd7338502bddac286b9cf6380125c362ee14219", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/hibernate.adoc"}}
{"id": "sha256:53cd51f91610c0c2c990d83c0e4a24542fff7ca1bb312c3e4fa1de4132dd8634", "content": "[[orm-introduction]]\n\nThe Spring Framework supports integration with the Java Persistence API (JPA) and\nsupports native Hibernate for resource management, data access object (DAO) implementations,\nand transaction strategies. For example, for Hibernate, there is first-class support with\nseveral convenient IoC features that address many typical Hibernate integration issues.\nYou can configure all of the supported features for OR (object relational) mapping\ntools through Dependency Injection. They can participate in Spring's resource and\ntransaction management, and they comply with Spring's generic transaction and DAO\nexception hierarchies. The recommended integration style is to code DAOs against plain\nHibernate or JPA APIs.\n\nSpring adds significant enhancements to the ORM layer of your choice when you create\ndata access applications. You can leverage as much of the integration support as you\nwish, and you should compare this integration effort with the cost and risk of building\na similar infrastructure in-house. You can use much of the ORM support as you would a\nlibrary, regardless of technology, because everything is designed as a set of reusable\nJavaBeans. ORM in a Spring IoC container facilitates configuration and deployment. Thus,\nmost examples in this section show configuration inside a Spring container.\n\nThe benefits of using the Spring Framework to create your ORM DAOs include:\n\n* *Easier testing.* Spring's IoC approach makes it easy to swap the implementations\n and configuration locations of Hibernate `SessionFactory` instances, JDBC `DataSource`\n instances, transaction managers, and mapped object implementations (if needed). This\n in turn makes it much easier to test each piece of persistence-related code in\n isolation.\n* *Common data access exceptions.* Spring can wrap exceptions from your ORM tool,\n converting them from proprietary (potentially checked) exceptions to a common runtime\n `DataAccessException` hierarchy. This feature lets you handle most persistence\n exceptions, which are non-recoverable, only in the appropriate layers, without\n annoying boilerplate catches, throws, and exception declarations. You can still trap\n and handle exceptions as necessary. Remember that JDBC exceptions (including\n DB-specific dialects) are also converted to the same hierarchy, meaning that you can\n perform some operations with JDBC within a consistent programming model.\n* *General resource management.* Spring application contexts can handle the location\n and configuration of Hibernate `SessionFactory` instances, JPA `EntityManagerFactory`\n instances, JDBC `DataSource` instances, and other related resources. This makes these\n values easy to manage and change. Spring offers efficient, easy, and safe handling of\n persistence resources. For example, related code that uses Hibernate generally needs to\n use the same Hibernate `Session` to ensure efficiency and proper transaction handling.\n Spring makes it easy to create and bind a `Session` to the current thread transparently,\n by exposing a current `Session` through the Hibernate `SessionFactory`. Thus, Spring\n solves many chronic problems of typical Hibernate usage, for any local or JTA\n transaction environment.\n* *Integrated transaction management.* You can wrap your ORM code with a declarative,\n aspect-oriented programming (AOP) style method interceptor either through the\n `@Transactional` annotation or by explicitly configuring the transaction AOP advice in\n an XML configuration file. In both cases, transaction semantics and exception handling\n (rollback and so on) are handled for you. As discussed in\n xref:data-access/orm/general.adoc#orm-resource-mngmnt[Resource and Transaction Management],\n you can also swap various transaction managers, without affecting your ORM-related code.\n For example, you can swap between local transactions and JTA, with the same full services\n (such as declarative transactions) available in both scenarios. Additionally,\n JDBC-related code can fully integrate transactionally with the code you use to do ORM.\n This is useful for data access that is not suitable for ORM (such as batch processing and\n BLOB streaming) but that still needs to share common transactions with ORM operations.\n\nTIP: For more comprehensive ORM support, including support for alternative database\ntechnologies such as MongoDB, you might want to check out the\n{spring-site-projects}/spring-data/[Spring Data] suite of projects. If you are\na JPA user, the {spring-site-guides}/gs/accessing-data-jpa/[Getting Started Accessing\nData with JPA] guide from https://spring.io provides a great introduction.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/introduction.adoc", "title": "introduction", "heading": "introduction", "heading_level": 1, "file_order": 120, "section_index": 0, "content_hash": "53cd51f91610c0c2c990d83c0e4a24542fff7ca1bb312c3e4fa1de4132dd8634", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/introduction.adoc"}}
{"id": "sha256:e816d619585c7c62597eabf0d021d0fdb776a5c9367a3eef0cfe25e212c7edde", "content": "[[orm-jpa]]\n\nThe Spring JPA, available under the `org.springframework.orm.jpa` package, offers\ncomprehensive support for the\nhttps://www.oracle.com/technetwork/articles/javaee/jpa-137156.html[Java Persistence\nAPI] in a manner similar to the integration with Hibernate while being aware of\nthe underlying implementation in order to provide additional features.\n\n[[orm-jpa-setup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "jpa", "heading_level": 1, "file_order": 121, "section_index": 0, "content_hash": "e816d619585c7c62597eabf0d021d0fdb776a5c9367a3eef0cfe25e212c7edde", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:f23a8840cc68548d723328d77488917926dd40016cc8b51abc6566b97650b76d", "content": "The Spring JPA support offers three ways of setting up the JPA `EntityManagerFactory`\nthat is used by the application to obtain an entity manager.\n\n* xref:data-access/orm/jpa.adoc#orm-jpa-setup-lemfb[Using `LocalEntityManagerFactoryBean`]\n* xref:data-access/orm/jpa.adoc#orm-jpa-setup-jndi[Obtaining an EntityManagerFactory from JNDI]\n* xref:data-access/orm/jpa.adoc#orm-jpa-setup-lcemfb[Using `LocalContainerEntityManagerFactoryBean`]\n\n[[orm-jpa-setup-lemfb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "Three Options for JPA Setup in a Spring Environment", "heading_level": 2, "file_order": 121, "section_index": 1, "content_hash": "f23a8840cc68548d723328d77488917926dd40016cc8b51abc6566b97650b76d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:5c0a63872f880b9a2b2b17fa954a74b963a42d6d7123000ad33c1527cc25d86e", "content": "You can use this option only in simple deployment environments such as stand-alone\napplications and integration tests.\n\nThe `LocalEntityManagerFactoryBean` creates an `EntityManagerFactory` suitable for\nsimple deployment environments where the application uses only JPA for data access.\nThe factory bean uses the JPA `PersistenceProvider` auto-detection mechanism (according\nto JPA's Java SE bootstrapping) and, in most cases, requires you to specify only the\npersistence unit name. The following XML example configures such a bean:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"myEmf\" class=\"org.springframework.orm.jpa.LocalEntityManagerFactoryBean\">\n <property name=\"persistenceUnitName\" value=\"myPersistenceUnit\"/>\n </bean>\n\t</beans>\n----\n\nThis form of JPA deployment is the simplest and the most limited. You cannot refer to an\nexisting JDBC `DataSource` bean definition, and no support for global transactions\nexists. Furthermore, weaving (byte-code transformation) of persistent classes is\nprovider-specific, often requiring a specific JVM agent to be specified on startup. This\noption is sufficient only for stand-alone applications and test environments, for which\nthe JPA specification is designed.\n\n[[orm-jpa-setup-jndi]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "Using `LocalEntityManagerFactoryBean`", "heading_level": 3, "file_order": 121, "section_index": 2, "content_hash": "5c0a63872f880b9a2b2b17fa954a74b963a42d6d7123000ad33c1527cc25d86e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:2f4cdfb7096af0ef763a6bbc0aa055174e74372767d533bd6016cbc48ad154d8", "content": "You can use this option when deploying to a Jakarta EE server. Check your server's documentation\non how to deploy a custom JPA provider into your server, allowing for a different\nprovider than the server's default.\n\nObtaining an `EntityManagerFactory` from JNDI (for example in a Jakarta EE environment),\nis a matter of changing the XML configuration, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <jee:jndi-lookup id=\"myEmf\" jndi-name=\"persistence/myPersistenceUnit\"/>\n\t</beans>\n----\n\nThis action assumes standard Jakarta EE bootstrapping. The Jakarta EE server auto-detects\npersistence units (in effect, `META-INF/persistence.xml` files in application jars) and\n`persistence-unit-ref` entries in the Jakarta EE deployment descriptor (for example,\n`web.xml`) and defines environment naming context locations for those persistence units.\n\nIn such a scenario, the entire persistence unit deployment, including the weaving\n(byte-code transformation) of persistent classes, is up to the Jakarta EE server. The JDBC\n`DataSource` is defined through a JNDI location in the `META-INF/persistence.xml` file.\n`EntityManager` transactions are integrated with the server's JTA subsystem. Spring merely\nuses the obtained `EntityManagerFactory`, passing it on to application objects through\ndependency injection and managing transactions for the persistence unit (typically\nthrough `JtaTransactionManager`).\n\nIf you use multiple persistence units in the same application, the bean names of such\nJNDI-retrieved persistence units should match the persistence unit names that the\napplication uses to refer to them (for example, in `@PersistenceUnit` and\n`@PersistenceContext` annotations).\n\n[[orm-jpa-setup-lcemfb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "Obtaining an EntityManagerFactory from JNDI", "heading_level": 3, "file_order": 121, "section_index": 3, "content_hash": "2f4cdfb7096af0ef763a6bbc0aa055174e74372767d533bd6016cbc48ad154d8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:97303867bb949efcd0b6eeadd63840e988704a467c88dda63a0f931d64d6b257", "content": "You can use this option for full JPA capabilities in a Spring-based application environment.\nThis includes web containers such as Tomcat, stand-alone applications, and\nintegration tests with sophisticated persistence requirements.\n\nThe `LocalContainerEntityManagerFactoryBean` gives full control over\n`EntityManagerFactory` configuration and is appropriate for environments where\nfine-grained customization is required. The `LocalContainerEntityManagerFactoryBean`\ncreates a `PersistenceUnitInfo` instance based on the `persistence.xml` file, the\nsupplied `dataSourceLookup` strategy, and the specified `loadTimeWeaver`. It is, thus,\npossible to work with custom data sources outside of JNDI and to control the weaving\nprocess. The following example shows a typical bean definition for a\n`LocalContainerEntityManagerFactoryBean`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"myEmf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n <property name=\"dataSource\" ref=\"someDataSource\"/>\n <property name=\"loadTimeWeaver\">\n <bean class=\"org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver\"/>\n </property>\n </bean>\n\t</beans>\n----\n\nThe following example shows a typical `persistence.xml` file:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<persistence xmlns=\"http://java.sun.com/xml/ns/persistence\" version=\"1.0\">\n <persistence-unit name=\"myUnit\" transaction-type=\"RESOURCE_LOCAL\">\n <mapping-file>META-INF/orm.xml</mapping-file>\n <exclude-unlisted-classes/>\n </persistence-unit>\n\t</persistence>\n----\n\nNOTE: The `<exclude-unlisted-classes/>` shortcut indicates that no scanning for\nannotated entity classes is supposed to occur. An explicit 'true' value\n(`<exclude-unlisted-classes>true</exclude-unlisted-classes/>`) also means no scan.\n`<exclude-unlisted-classes>false</exclude-unlisted-classes/>` does trigger a scan.\nHowever, we recommend omitting the `exclude-unlisted-classes` element\nif you want entity class scanning to occur.\n\nUsing the `LocalContainerEntityManagerFactoryBean` is the most powerful JPA setup\noption, allowing for flexible local configuration within the application. It supports\nlinks to an existing JDBC `DataSource`, supports both local and global transactions, and\nso on. However, it also imposes requirements on the runtime environment, such as the\navailability of a weaving-capable class loader if the persistence provider demands\nbyte-code transformation.\n\nThis option may conflict with the built-in JPA capabilities of a Jakarta EE server. In a\nfull Jakarta EE environment, consider obtaining your `EntityManagerFactory` from JNDI.\nAlternatively, specify a custom `persistenceXmlLocation` on your\n`LocalContainerEntityManagerFactoryBean` definition (for example,\nMETA-INF/my-persistence.xml) and include only a descriptor with that name in your\napplication jar files. Because the Jakarta EE server looks only for default\n`META-INF/persistence.xml` files, it ignores such custom persistence units and, hence,\navoids conflicts with a Spring-driven JPA setup upfront.\n\n.When is load-time weaving required?\n****\nNot all JPA providers require a JVM agent. Hibernate is an example of one that does not.\nIf your provider does not require an agent or you have other alternatives, such as\napplying enhancements at build time through a custom compiler or an Ant task, you should not use the\nload-time weaver.\n****\n\nThe `LoadTimeWeaver` interface is a Spring-provided class that lets JPA\n`ClassTransformer` instances be plugged in a specific manner, depending on whether the\nenvironment is a web container or application server. Hooking `ClassTransformers`\nthrough an\n{java-api}/java.instrument/java/lang/instrument/package-summary.html[agent]\nis typically not efficient. The agents work against the entire virtual machine and\ninspect every class that is loaded, which is usually undesirable in a production\nserver environment.\n\nSpring provides a number of `LoadTimeWeaver` implementations for various environments,\nletting `ClassTransformer` instances be applied only for each class loader and not\nfor each VM.\n\nSee the xref:core/aop/using-aspectj.adoc#aop-aj-ltw-spring[Spring configuration] in the AOP chapter for\nmore insight regarding the `LoadTimeWeaver` implementations and their setup, either\ngeneric or customized to various platforms (such as Tomcat, JBoss and WebSphere).\n\nAs described in xref:core/aop/using-aspectj.adoc#aop-aj-ltw-spring[Spring configuration], you can configure\na context-wide `LoadTimeWeaver` by using the `@EnableLoadTimeWeaving` annotation or the\n`context:load-time-weaver` XML element. Such a global weaver is automatically picked up\nby all JPA `LocalContainerEntityManagerFactoryBean` instances. The following example\nshows the preferred way of setting up a load-time weaver, delivering auto-detection\nof the platform (for example, Tomcat's weaving-capable class loader or Spring's JVM agent)\nand automatic propagation of the weaver to all weaver-aware beans:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<context:load-time-weaver/>\n\n\t<bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n ...\n\t</bean>\n----\n\nHowever, you can, if needed, manually specify a dedicated weaver through the\n`loadTimeWeaver` property, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n <property name=\"loadTimeWeaver\">\n <bean class=\"org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver\"/>\n </property>\n\t</bean>\n----\n\nNo matter how the LTW is configured, by using this technique, JPA applications relying on\ninstrumentation can run in the target platform (for example, Tomcat) without needing an agent.\nThis is especially important when the hosting applications rely on different JPA\nimplementations, because the JPA transformers are applied only at the class-loader level and\nare, thus, isolated from each other.\n\n[[orm-jpa-setup-multiple]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "Using `LocalContainerEntityManagerFactoryBean`", "heading_level": 3, "file_order": 121, "section_index": 4, "content_hash": "97303867bb949efcd0b6eeadd63840e988704a467c88dda63a0f931d64d6b257", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:2f7fa2d10f3ea051f9bd5ce21d1e519f2baec0a02637c498d9b1573ecc2a96f1", "content": "For applications that rely on multiple persistence units locations (stored in various\nJARS in the classpath, for example), Spring offers the `PersistenceUnitManager` to act as\na central repository and to avoid the persistence units discovery process, which can be\nexpensive. The default implementation lets multiple locations be specified. These locations are\nparsed and later retrieved through the persistence unit name. (By default, the classpath\nis searched for `META-INF/persistence.xml` files.) The following example configures\nmultiple locations:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<bean id=\"pum\" class=\"org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager\">\n <property name=\"persistenceXmlLocations\">\n <list>\n <value>org/springframework/orm/jpa/domain/persistence-multi.xml</value>\n <value>classpath:/my/package/**/custom-persistence.xml</value>\n <value>classpath*:META-INF/persistence.xml</value>\n </list>\n </property>\n <property name=\"dataSources\">\n <map>\n <entry key=\"localDataSource\" value-ref=\"local-db\"/>\n <entry key=\"remoteDataSource\" value-ref=\"remote-db\"/>\n </map>\n </property>\n <!-- if no datasource is specified, use this one -->\n <property name=\"defaultDataSource\" ref=\"remoteDataSource\"/>\n\t</bean>\n\n\t<bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n <property name=\"persistenceUnitManager\" ref=\"pum\"/>\n <property name=\"persistenceUnitName\" value=\"myCustomUnit\"/>\n\t</bean>\n----\n\nThe default implementation allows customization of the `PersistenceUnitInfo` instances\n(before they are fed to the JPA provider) either declaratively (through its properties, which\naffect all hosted units) or programmatically (through the\n`PersistenceUnitPostProcessor`, which allows persistence unit selection). If no\n`PersistenceUnitManager` is specified, one is created and used internally by\n`LocalContainerEntityManagerFactoryBean`.\n\n[[orm-jpa-setup-background]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "Dealing with Multiple Persistence Units", "heading_level": 3, "file_order": 121, "section_index": 5, "content_hash": "2f7fa2d10f3ea051f9bd5ce21d1e519f2baec0a02637c498d9b1573ecc2a96f1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:0429cf25b61ec0248e8bbfb3981044d8aa8b9d7580554ddbe68912bc2d13a908", "content": "`LocalContainerEntityManagerFactoryBean` supports background bootstrapping through\nthe `bootstrapExecutor` property, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n <property name=\"bootstrapExecutor\">\n <bean class=\"org.springframework.core.task.SimpleAsyncTaskExecutor\"/>\n </property>\n\t</bean>\n----\n\nThe actual JPA provider bootstrapping is handed off to the specified executor and then,\nrunning in parallel, to the application bootstrap thread. The exposed `EntityManagerFactory`\nproxy can be injected into other application components and is even able to respond to\n`EntityManagerFactoryInfo` configuration inspection. However, once the actual JPA provider\nis being accessed by other components (for example, calling `createEntityManager`), those\ncalls block until the background bootstrapping has completed. In particular, when you use\nSpring Data JPA, make sure to set up deferred bootstrapping for its repositories as well.\n\nAs of 6.2, JPA initialization is enforced before context refresh completion, waiting for\nasynchronous bootstrapping to complete by then. This makes the availability of the fully\ninitialized database infrastructure predictable and allows for custom post-initialization\nlogic in `ContextRefreshedEvent` listeners etc. Putting such application-level database\ninitialization into `@PostConstruct` methods or the like is not recommended; this is\nbetter placed in `Lifecycle.start` (if applicable) or a `ContextRefreshedEvent` listener.\n\n[[orm-jpa-dao]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "Background Bootstrapping", "heading_level": 3, "file_order": 121, "section_index": 6, "content_hash": "0429cf25b61ec0248e8bbfb3981044d8aa8b9d7580554ddbe68912bc2d13a908", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:2c015b18fcf680eb54895670a09b3ef2537fd47cc9455f2b6203eb5e526388a2", "content": "NOTE: Although `EntityManagerFactory` instances are thread-safe, `EntityManager` instances\nare not. The injected JPA `EntityManager` behaves like an `EntityManager` fetched from an\napplication server's JNDI environment, as defined by the JPA specification. It delegates\nall calls to the current transactional `EntityManager`, if any. Otherwise, it falls back\nto a newly created `EntityManager` per operation, in effect making its usage thread-safe.\n\nIt is possible to write code against the plain JPA without any Spring dependencies, by\nusing an injected `EntityManagerFactory` or `EntityManager`. Spring can understand the\n`@PersistenceUnit` and `@PersistenceContext` annotations both at the field and the method\nlevel if a `PersistenceAnnotationBeanPostProcessor` is enabled. The following example\nshows a plain JPA DAO implementation that uses the `@PersistenceUnit` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ProductDaoImpl implements ProductDao {\n\n private EntityManagerFactory emf;\n\n @PersistenceUnit\n public void setEntityManagerFactory(EntityManagerFactory emf) {\n this.emf = emf;\n }\n\n public Collection loadProductsByCategory(String category) {\n EntityManager em = this.emf.createEntityManager();\n try {\n Query query = em.createQuery(\"from Product as p where p.category = ?1\");\n query.setParameter(1, category);\n return query.getResultList();\n }\n finally {\n if (em != null) {\n em.close();\n }\n }\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ProductDaoImpl : ProductDao {\n\n private lateinit var emf: EntityManagerFactory\n\n @PersistenceUnit\n fun setEntityManagerFactory(emf: EntityManagerFactory) {\n this.emf = emf\n }\n\n fun loadProductsByCategory(category: String): Collection<*> {\n val em = this.emf.createEntityManager()\n val query = em.createQuery(\"from Product as p where p.category = ?1\");\n query.setParameter(1, category);\n return query.resultList;\n }\n\t}\n----\n======\n\nThe preceding DAO has no dependency on Spring and still fits nicely into a Spring\napplication context. Moreover, the DAO takes advantage of annotations to require the\ninjection of the default `EntityManagerFactory`, as the following example bean definition shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <!-- bean post-processor for JPA annotations -->\n <bean class=\"org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor\"/>\n\n <bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"/>\n\n\t</beans>\n----\n\nAs an alternative to explicitly defining a `PersistenceAnnotationBeanPostProcessor`,\nconsider using the Spring `context:annotation-config` XML element in your application\ncontext configuration. Doing so automatically registers all Spring standard\npost-processors for annotation-based configuration, including\n`CommonAnnotationBeanPostProcessor` and so on.\n\nConsider the following example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <!-- post-processors for all standard config annotations -->\n <context:annotation-config/>\n\n <bean id=\"myProductDao\" class=\"product.ProductDaoImpl\"/>\n\n\t</beans>\n----\n\nThe main problem with such a DAO is that it always creates a new `EntityManager` through\nthe factory. You can avoid this by requesting a transactional `EntityManager` (also called a\n\"`shared EntityManager`\" because it is a shared, thread-safe proxy for the actual transactional\nEntityManager) to be injected instead of the factory. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ProductDaoImpl implements ProductDao {\n\n @PersistenceContext\n private EntityManager em;\n\n public Collection loadProductsByCategory(String category) {\n Query query = em.createQuery(\"from Product as p where p.category = :category\");\n query.setParameter(\"category\", category);\n return query.getResultList();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ProductDaoImpl : ProductDao {\n\n @PersistenceContext\n private lateinit var em: EntityManager\n\n fun loadProductsByCategory(category: String): Collection<*> {\n val query = em.createQuery(\"from Product as p where p.category = :category\")\n query.setParameter(\"category\", category)\n return query.resultList\n }\n\t}\n----\n======\n\nThe `@PersistenceContext` annotation has an optional attribute called `type`, which defaults\nto `PersistenceContextType.TRANSACTION`. You can use this default to receive a shared\n`EntityManager` proxy. The alternative, `PersistenceContextType.EXTENDED`, is a completely\ndifferent affair. This results in a so-called extended `EntityManager`, which is not\nthread-safe and, hence, must not be used in a concurrently accessed component, such as a\nSpring-managed singleton bean. Extended `EntityManager` instances are only supposed to be used\nin stateful components that, for example, reside in a session, with the lifecycle of the\n`EntityManager` not tied to a current transaction but rather being completely up to the\napplication.\n\n.Method- and field-level Injection\n****\nYou can apply annotations that indicate dependency injections (such as `@PersistenceUnit`\nand `@PersistenceContext`) on field or methods inside a class -- hence the expressions\n\"`method-level injection`\" and \"`field-level injection`\". Field-level annotations are\nconcise and easier to use while method-level annotations allow for further processing of the\ninjected dependency. In both cases, the member visibility (public, protected, or private)\ndoes not matter.\n\nWhat about class-level annotations?\n\nOn the Jakarta EE platform, they are used for dependency declaration and not for resource\ninjection.\n****\n\nThe injected `EntityManager` is Spring-managed (aware of the ongoing transaction).\nEven though the new DAO implementation uses method-level injection of an `EntityManager`\ninstead of an `EntityManagerFactory`, no change is required in the bean definition\ndue to annotation usage.\n\nThe main advantage of this DAO style is that it depends only on the Java Persistence API.\nNo import of any Spring class is required. Moreover, as the JPA annotations are understood,\nthe injections are applied automatically by the Spring container. This is appealing from\na non-invasiveness perspective and can feel more natural to JPA developers.\n\n[[orm-jpa-dao-autowired]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "Implementing DAOs Based on JPA: `EntityManagerFactory` and `EntityManager`", "heading_level": 2, "file_order": 121, "section_index": 7, "content_hash": "2c015b18fcf680eb54895670a09b3ef2537fd47cc9455f2b6203eb5e526388a2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:9e00a5b78fefd33aa24570685c12bed7d9065fafcea85b51bb81e4b589b181b5", "content": "`@PersistenceUnit` and `@PersistenceContext` can only be declared on methods and fields.\nWhat about providing JPA resources via constructors and other `@Autowired` injection points?\n\n`EntityManagerFactory` can easily be injected via constructors and `@Autowired` fields/methods\nas long as the target is defined as a bean, for example, via `LocalContainerEntityManagerFactoryBean`.\nThe injection point matches the original `EntityManagerFactory` definition by type as-is.\n\nHowever, an `@PersistenceContext`-style shared `EntityManager` reference is not available for\nregular dependency injection out of the box. In order to make it available for type-based\nmatching as required by `@Autowired`, consider defining a `SharedEntityManagerBean` as a\ncompanion for your `EntityManagerFactory` definition:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"emf\" class=\"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean\">\n ...\n\t</bean>\n\n\t<bean id=\"em\" class=\"org.springframework.orm.jpa.support.SharedEntityManagerBean\">\n <property name=\"entityManagerFactory\" ref=\"emf\"/>\n\t</bean>\n----\n\nAlternatively, you may define an `@Bean` method based on `SharedEntityManagerCreator`:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean(\"em\")\n\tpublic static EntityManager sharedEntityManager(EntityManagerFactory emf) {\n return SharedEntityManagerCreator.createSharedEntityManager(emf);\n\t}\n----\n\nIn case of multiple persistence units, each `EntityManagerFactory` definition needs to be\naccompanied by a corresponding `EntityManager` bean definition, ideally with qualifiers\nthat match with the distinct `EntityManagerFactory` definition in order to distinguish\nthe persistence units via `@Autowired @Qualifier(\"...\")`.\n\n[[orm-jpa-tx]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "Implementing DAOs Based on `@Autowired` (typically with constructor-based injection)", "heading_level": 3, "file_order": 121, "section_index": 8, "content_hash": "9e00a5b78fefd33aa24570685c12bed7d9065fafcea85b51bb81e4b589b181b5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:591d246c6225874ce11a576a6590d3d3820c4b31da3a83c57262bb9010df8337", "content": "NOTE: We strongly encourage you to read xref:data-access/transaction/declarative.adoc[Declarative Transaction Management],\nif you have not already done so, to get more detailed coverage of Spring's declarative transaction support.\n\nThe recommended strategy for JPA is local transactions through JPA's native transaction\nsupport. Spring's `JpaTransactionManager` provides many capabilities known from local\nJDBC transactions (such as transaction-specific isolation levels and resource-level\nread-only optimizations) against any regular JDBC connection pool, without requiring\na JTA transaction coordinator and XA-capable resources.\n\nSpring JPA also lets a configured `JpaTransactionManager` expose a JPA transaction\nto JDBC access code that accesses the same `DataSource`, provided that the registered\n`JpaDialect` supports retrieval of the underlying JDBC `Connection`. Spring provides\ndialects for the EclipseLink and Hibernate JPA implementations. See the\nxref:data-access/orm/jpa.adoc#orm-jpa-dialect[next section] for details on `JpaDialect`.\n\nFor JTA-style lazy retrieval of actual resource connections, Spring provides a\ncorresponding `DataSource` proxy class for the target connection pool: see\n{spring-framework-api}/jdbc/datasource/LazyConnectionDataSourceProxy.html[`LazyConnectionDataSourceProxy`].\nThis is particularly useful for JPA read-only transactions which can often\nbe processed from a local cache rather than hitting the database.\n\n[[orm-jpa-dialect]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "Spring-driven JPA Transactions", "heading_level": 2, "file_order": 121, "section_index": 9, "content_hash": "591d246c6225874ce11a576a6590d3d3820c4b31da3a83c57262bb9010df8337", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:86f7906c324bc8841f6010da6f7fdbcc250c289e5450c7f25b4bb6be6938f1bd", "content": "As an advanced feature, `JpaTransactionManager` and subclasses of\n`AbstractEntityManagerFactoryBean` allow a custom `JpaDialect` to be passed into the\n`jpaDialect` bean property. A `JpaDialect` implementation can enable the following advanced\nfeatures supported by Spring, usually in a vendor-specific manner:\n\n* Applying specific transaction semantics (such as custom isolation level or transaction\n timeout)\n* Retrieving the transactional JDBC `Connection` (for exposure to JDBC-based DAOs)\n* Advanced translation of `PersistenceException` to Spring's `DataAccessException`\n\nThis is particularly valuable for special transaction semantics and for advanced\ntranslation of exception. The default implementation (`DefaultJpaDialect`) does\nnot provide any special abilities and, if the features listed earlier are required, you have\nto specify the appropriate dialect.\n\nTIP: As an even broader provider adaptation facility primarily for Spring's full-featured\n`LocalContainerEntityManagerFactoryBean` setup, `JpaVendorAdapter` combines the\ncapabilities of `JpaDialect` with other provider-specific defaults. Specifying a\n`HibernateJpaVendorAdapter` or `EclipseLinkJpaVendorAdapter` is the most convenient\nway of auto-configuring an `EntityManagerFactory` setup for Hibernate or EclipseLink,\nrespectively. Note that those provider adapters are primarily designed for use with\nSpring-driven transaction management (that is, for use with `JpaTransactionManager`).\n\nSee the {spring-framework-api}/orm/jpa/JpaDialect.html[`JpaDialect`] and\n{spring-framework-api}/orm/jpa/JpaVendorAdapter.html[`JpaVendorAdapter`] javadoc for\nmore details of its operations and how they are used within Spring's JPA support.\n\n[[orm-jpa-jta]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "Understanding `JpaDialect` and `JpaVendorAdapter`", "heading_level": 2, "file_order": 121, "section_index": 10, "content_hash": "86f7906c324bc8841f6010da6f7fdbcc250c289e5450c7f25b4bb6be6938f1bd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:037540e1d2e082c2073f884d5543e872deedb4d20a09b0b9137f4b7cffc95154", "content": "As an alternative to `JpaTransactionManager`, Spring also allows for multi-resource\ntransaction coordination through JTA, either in a Jakarta EE environment or with a\nstand-alone transaction coordinator, such as Atomikos. Aside from choosing Spring's\n`JtaTransactionManager` instead of `JpaTransactionManager`, you need to take few further\nsteps:\n\n* The underlying JDBC connection pools need to be XA-capable and be integrated with\nyour transaction coordinator. This is usually straightforward in a Jakarta EE environment,\nexposing a different kind of `DataSource` through JNDI. See your application server\ndocumentation for details. Analogously, a standalone transaction coordinator usually\ncomes with special XA-integrated `DataSource` variants. Again, check its documentation.\n\n* The JPA `EntityManagerFactory` setup needs to be configured for JTA. This is\nprovider-specific, typically through special properties to be specified as `jpaProperties`\non `LocalContainerEntityManagerFactoryBean`. In the case of Hibernate, these properties\nare even version-specific. See your Hibernate documentation for details.\n\n* Spring's `HibernateJpaVendorAdapter` enforces certain Spring-oriented defaults, such\nas the connection release mode, `on-close`, which matches Hibernate's own default in\nHibernate 5.0 but not any more in Hibernate 5.1+. For a JTA setup, make sure to declare\nyour persistence unit transaction type as \"JTA\". Alternatively, set Hibernate 5.2's\n`hibernate.connection.handling_mode` property to\n`DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT` to restore Hibernate's own default.\nSee xref:data-access/orm/hibernate.adoc#orm-hibernate-invalid-jdbc-access-error[Spurious Application Server Warnings with Hibernate] for related notes.\n\n* Alternatively, consider obtaining the `EntityManagerFactory` from your application\nserver itself (that is, through a JNDI lookup instead of a locally declared\n`LocalContainerEntityManagerFactoryBean`). A server-provided `EntityManagerFactory`\nmight require special definitions in your server configuration (making the deployment\nless portable) but is set up for the server's JTA environment.\n\n[[orm-jpa-hibernate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "Setting up JPA with JTA Transaction Management", "heading_level": 2, "file_order": 121, "section_index": 11, "content_hash": "037540e1d2e082c2073f884d5543e872deedb4d20a09b0b9137f4b7cffc95154", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:f2d63dbc8d18760bd5cbd653e1ac6c8d78259132baaeef29617d74d697f4eb9c", "content": "A native `LocalSessionFactoryBean` setup in combination with `HibernateTransactionManager`\nallows for interaction with `@PersistenceContext` and other JPA access code. A Hibernate\n`SessionFactory` natively implements JPA's `EntityManagerFactory` interface now\nand a Hibernate `Session` handle natively is a JPA `EntityManager`.\nSpring's JPA support facilities automatically detect native Hibernate sessions.\n\nSuch native Hibernate setup can, therefore, serve as a replacement for a standard JPA\n`LocalContainerEntityManagerFactoryBean` and `JpaTransactionManager` combination\nin many scenarios, allowing for interaction with `SessionFactory.getCurrentSession()`\n(and also `HibernateTemplate`) next to `@PersistenceContext EntityManager` within\nthe same local transaction. Such a setup also provides stronger Hibernate integration\nand more configuration flexibility, because it is not constrained by JPA bootstrap contracts.\n\nYou do not need `HibernateJpaVendorAdapter` configuration in such a scenario,\nsince Spring's native Hibernate setup provides even more features\n(for example, custom Hibernate Integrator setup, Hibernate 5.3 bean container integration,\nand stronger optimizations for read-only transactions). Last but not least, you can also\nexpress native Hibernate setup through `LocalSessionFactoryBuilder`,\nseamlessly integrating with `@Bean` style configuration (no `FactoryBean` involved).\n\n[NOTE]\n====\n`LocalSessionFactoryBean` and `LocalSessionFactoryBuilder` support background\nbootstrapping, just as the JPA `LocalContainerEntityManagerFactoryBean` does.\nSee xref:data-access/orm/jpa.adoc#orm-jpa-setup-background[Background Bootstrapping] for an introduction.\n\nOn `LocalSessionFactoryBean`, this is available through the `bootstrapExecutor`\nproperty. On the programmatic `LocalSessionFactoryBuilder`, an overloaded\n`buildSessionFactory` method takes a bootstrap executor argument.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc", "title": "jpa", "heading": "Native Hibernate Setup and Native Hibernate Transactions for JPA Interaction", "heading_level": 2, "file_order": 121, "section_index": 12, "content_hash": "f2d63dbc8d18760bd5cbd653e1ac6c8d78259132baaeef29617d74d697f4eb9c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm/jpa.adoc"}}
{"id": "sha256:dbd2d1ba13358ab5049812cbd7c0637612fbc78bafee5a33fb05d6cde0098c49", "content": "[[transaction-declarative-annotations]]\n\nIn addition to the XML-based declarative approach to transaction configuration, you can\nuse an annotation-based approach. Declaring transaction semantics directly in the Java\nsource code puts the declarations much closer to the affected code. There is not much\ndanger of undue coupling, because code that is meant to be used transactionally is\nalmost always deployed that way anyway.\n\nNOTE: The standard `jakarta.transaction.Transactional` annotation is also supported as\na drop-in replacement to Spring's own annotation. Please refer to the JTA documentation\nfor more details.\n\nThe ease-of-use afforded by the use of the `@Transactional` annotation is best\nillustrated with an example, which is explained in the text that follows.\nConsider the following class definition:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// the service class that we want to make transactional\n\t@Transactional\n\tpublic class DefaultFooService implements FooService {\n\n @Override\n public Foo getFoo(String fooName) {\n // ...\n }\n\n @Override\n public Foo getFoo(String fooName, String barName) {\n // ...\n }\n\n @Override\n public void insertFoo(Foo foo) {\n // ...\n }\n\n @Override\n public void updateFoo(Foo foo) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// the service class that we want to make transactional\n\t@Transactional\n\tclass DefaultFooService : FooService {\n\n override fun getFoo(fooName: String): Foo {\n // ...\n }\n\n override fun getFoo(fooName: String, barName: String): Foo {\n // ...\n }\n\n override fun insertFoo(foo: Foo) {\n // ...\n }\n\n override fun updateFoo(foo: Foo) {\n // ...\n }\n\t}\n----\n======\n\nUsed at the class level as above, the annotation indicates a default for all methods\nof the declaring class (as well as its subclasses). Alternatively, each method can be\nannotated individually. See\nxref:data-access/transaction/declarative/annotations.adoc#transaction-declarative-annotations-method-visibility[method visibility]\nfor further details on which methods Spring considers transactional. Note that a class-level\nannotation does not apply to ancestor classes up the class hierarchy; in such a scenario,\ninherited methods need to be locally redeclared in order to participate in a\nsubclass-level annotation.\n\nWhen a POJO class such as the one above is defined as a bean in a Spring context,\nyou can make the bean instance transactional through an `@EnableTransactionManagement`\nannotation in a `@Configuration` class. See the\n{spring-framework-api}/transaction/annotation/EnableTransactionManagement.html[javadoc]\nfor full details.\n\nIn XML configuration, the `<tx:annotation-driven/>` tag provides similar convenience:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- from the file 'context.xml' -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:aop=\"http://www.springframework.org/schema/aop\"\n xmlns:tx=\"http://www.springframework.org/schema/tx\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/tx\n https://www.springframework.org/schema/tx/spring-tx.xsd\n http://www.springframework.org/schema/aop\n https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n <!-- this is the service object that we want to make transactional -->\n <bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\n\n <!-- enable the configuration of transactional behavior based on annotations -->\n <!-- a TransactionManager is still required -->\n <tx:annotation-driven transaction-manager=\"txManager\"/> <1>\n\n <bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n <!-- (this dependency is defined somewhere else) -->\n <property name=\"dataSource\" ref=\"dataSource\"/>\n </bean>\n\n <!-- other <bean/> definitions here -->\n\n\t</beans>\n----\n<1> The line that makes the bean instance transactional.\n\nTIP: You can omit the `transaction-manager` attribute in the `<tx:annotation-driven/>`\ntag if the bean name of the `TransactionManager` that you want to wire in has the name\n`transactionManager`. If the `TransactionManager` bean that you want to dependency-inject\nhas any other name, you have to use the `transaction-manager` attribute, as in the\npreceding example.\n\nReactive transactional methods use reactive return types in contrast to imperative\nprogramming arrangements as the following listing shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// the reactive service class that we want to make transactional\n\t@Transactional\n\tpublic class DefaultFooService implements FooService {\n\n @Override\n public Publisher<Foo> getFoo(String fooName) {\n // ...\n }\n\n @Override\n public Mono<Foo> getFoo(String fooName, String barName) {\n // ...\n }\n\n @Override\n public Mono<Void> insertFoo(Foo foo) {\n // ...\n }\n\n @Override\n public Mono<Void> updateFoo(Foo foo) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// the reactive service class that we want to make transactional\n\t@Transactional\n\tclass DefaultFooService : FooService {\n\n override fun getFoo(fooName: String): Flow<Foo> {\n // ...\n }\n\n override fun getFoo(fooName: String, barName: String): Mono<Foo> {\n // ...\n }\n\n override fun insertFoo(foo: Foo): Mono<Void> {\n // ...\n }\n\n override fun updateFoo(foo: Foo): Mono<Void> {\n // ...\n }\n\t}\n----\n======\n\nNote that there are special considerations for the returned `Publisher` with regards to\nReactive Streams cancellation signals. See the\nxref:data-access/transaction/programmatic.adoc#tx-prog-operator-cancel[Cancel Signals]\nsection under \"Using the TransactionalOperator\" for more details.\n\n[[transaction-declarative-annotations-method-visibility]]\n.Method visibility and `@Transactional` in proxy mode\n[NOTE]\n====\nThe `@Transactional` annotation is typically used on methods with `public` visibility.\nAs of 6.0, `protected` or package-visible methods can also be made transactional for\nclass-based proxies by default. Note that transactional methods in interface-based\nproxies must always be `public` and defined in the proxied interface. For both kinds\nof proxies, only external method calls coming in through the proxy are intercepted.\n\nIf you prefer consistent treatment of method visibility across the different kinds of\nproxies (which was the default up until 5.3), consider specifying `publicMethodsOnly`:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t/**\n * Register a custom AnnotationTransactionAttributeSource with the\n * publicMethodsOnly flag set to true to consistently ignore non-public methods.\n * @see ProxyTransactionManagementConfiguration#transactionAttributeSource()\n */\n\t@Bean\n\tTransactionAttributeSource transactionAttributeSource() {\n return new AnnotationTransactionAttributeSource(true);\n\t}\n----\n\nThe _Spring TestContext Framework_ supports non-private `@Transactional` test methods\nby default as well. See xref:testing/testcontext-framework/tx.adoc[Transaction Management]\nin the testing chapter for examples.\n====\n\nYou can apply the `@Transactional` annotation to an interface definition, a method\non an interface, a class definition, or a method on a class. However, the mere presence\nof the `@Transactional` annotation is not enough to activate the transactional behavior.\nThe `@Transactional` annotation is merely metadata that can be consumed by corresponding\nruntime infrastructure which uses that metadata to configure the appropriate beans with\ntransactional behavior. In the preceding example, the `<tx:annotation-driven/>` element\nswitches on actual transaction management at runtime.\n\nTIP: The Spring team recommends that you annotate methods of concrete classes with the\n`@Transactional` annotation, rather than relying on annotated methods in interfaces,\neven if the latter does work for interface-based and target-class proxies as of 5.0.\nSince Java annotations are not inherited from interfaces, interface-declared annotations\nare still not recognized by the weaving infrastructure when using AspectJ mode, so the\naspect does not get applied. As a consequence, your transaction annotations may be\nsilently ignored: Your code might appear to \"work\" until you test a rollback scenario.\n\nNOTE: In proxy mode (which is the default), only external method calls coming in through\nthe proxy are intercepted. This means that self-invocation (in effect, a method within\nthe target object calling another method of the target object) does not lead to an actual\ntransaction at runtime even if the invoked method is marked with `@Transactional`. Also,\nthe proxy must be fully initialized to provide the expected behavior, so you should not\nrely on this feature in your initialization code -- for example, in a `@PostConstruct` method.\n\nConsider using AspectJ mode (see the `mode` attribute in the following table) if you\nexpect self-invocations to be wrapped with transactions as well. In this case, there is\nno proxy in the first place. Instead, the target class is woven (that is, its byte code\nis modified) to support `@Transactional` runtime behavior on any kind of method.\n\n[[tx-annotation-driven-settings]]\n.Annotation driven transaction settings\n|===\n| XML Attribute| Annotation Attribute| Default| Description\n\n| `transaction-manager`\n| N/A (see {spring-framework-api}/transaction/annotation/TransactionManagementConfigurer.html[`TransactionManagementConfigurer`] javadoc)\n| `transactionManager`\n| Name of the transaction manager to use. Required only if the name of the transaction\n manager is not `transactionManager`, as in the preceding example.\n\n| `mode`\n| `mode`\n| `proxy`\n| The default mode (`proxy`) processes annotated beans to be proxied by using Spring's AOP\n framework (following proxy semantics, as discussed earlier, applying to method calls\n coming in through the proxy only). The alternative mode (`aspectj`) instead weaves the\n affected classes with Spring's AspectJ transaction aspect, modifying the target class\n byte code to apply to any kind of method call. AspectJ weaving requires `spring-aspects.jar`\n in the classpath as well as having load-time weaving (or compile-time weaving) enabled.\n (See xref:core/aop/using-aspectj.adoc#aop-aj-ltw-spring[Spring configuration] for details\n on how to set up load-time weaving.)\n\n| `proxy-target-class`\n| `proxyTargetClass`\n| `false`\n| Applies to `proxy` mode only. Controls what type of transactional proxies are created\n for classes annotated with the `@Transactional` annotation. If the `proxy-target-class`\n attribute is set to `true`, class-based proxies are created. If `proxy-target-class` is\n `false` or if the attribute is omitted, then standard JDK interface-based proxies are\n created. (See xref:core/aop/proxying.adoc[Proxying Mechanisms] for a detailed examination\n of the different proxy types.)\n\n| `order`\n| `order`\n| `Ordered.LOWEST_PRECEDENCE`\n| Defines the order of the transaction advice that is applied to beans annotated with\n `@Transactional`. (For more information about the rules related to ordering of AOP\n advice, see xref:core/aop/ataspectj/advice.adoc#aop-ataspectj-advice-ordering[Advice Ordering].)\n No specified ordering means that the AOP subsystem determines the order of the advice.\n|===\n\nNOTE: The default advice mode for processing `@Transactional` annotations is `proxy`,\nwhich allows for interception of calls through the proxy only. Local calls within the\nsame class cannot get intercepted that way. For a more advanced mode of interception,\nconsider switching to `aspectj` mode in combination with compile-time or load-time weaving.\n\nNOTE: The `proxy-target-class` attribute controls what type of transactional proxies are\ncreated for classes annotated with the `@Transactional` annotation. If\n`proxy-target-class` is set to `true`, class-based proxies are created. If\n`proxy-target-class` is `false` or if the attribute is omitted, standard JDK\ninterface-based proxies are created. (See xref:core/aop/proxying.adoc[Proxying Mechanisms]\nfor a discussion of the different proxy types.)\n\nNOTE: `@EnableTransactionManagement` and `<tx:annotation-driven/>` look for\n`@Transactional` only on beans in the same application context in which they are defined.\nThis means that, if you put annotation-driven configuration in a `WebApplicationContext`\nfor a `DispatcherServlet`, it checks for `@Transactional` beans only in your controllers\nand not in your services. See xref:web/webmvc/mvc-servlet.adoc[MVC] for more information.\n\nThe most derived location takes precedence when evaluating the transactional settings\nfor a method. In the case of the following example, the `DefaultFooService` class is\nannotated at the class level with the settings for a read-only transaction, but the\n`@Transactional` annotation on the `updateFoo(Foo)` method in the same class takes\nprecedence over the transactional settings defined at the class level.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Transactional(readOnly = true)\n\tpublic class DefaultFooService implements FooService {\n\n public Foo getFoo(String fooName) {\n // ...\n }\n\n // these settings have precedence for this method\n @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)\n public void updateFoo(Foo foo) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Transactional(readOnly = true)\n\tclass DefaultFooService : FooService {\n\n override fun getFoo(fooName: String): Foo {\n // ...\n }\n\n // these settings have precedence for this method\n @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)\n override fun updateFoo(foo: Foo) {\n // ...\n }\n\t}\n----\n======\n\n[[transaction-declarative-attransactional-settings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/annotations.adoc", "title": "annotations", "heading": "annotations", "heading_level": 1, "file_order": 122, "section_index": 0, "content_hash": "dbd2d1ba13358ab5049812cbd7c0637612fbc78bafee5a33fb05d6cde0098c49", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/annotations.adoc"}}
{"id": "sha256:b1b0d65c7cd5005a1143fd61b7fd5613692683438255a02470696702cbd7b298", "content": "The `@Transactional` annotation is metadata that specifies that an interface, class,\nor method must have transactional semantics (for example, \"start a brand new read-only\ntransaction when this method is invoked, suspending any existing transaction\").\nThe default `@Transactional` settings are as follows:\n\n* The propagation setting is `PROPAGATION_REQUIRED.`\n* The isolation level is `ISOLATION_DEFAULT.`\n* The transaction is read-write.\n* The transaction timeout defaults to the default timeout of the underlying transaction\n system, or to none if timeouts are not supported.\n* Any `RuntimeException` or `Error` triggers rollback, and any checked `Exception` does\n not.\n\nYou can change these default settings. The following table summarizes the various\nproperties of the `@Transactional` annotation:\n\n[[tx-attransactional-properties]]\n.@Transactional Settings\n|===\n| Property| Type| Description\n\n| xref:data-access/transaction/declarative/annotations.adoc#tx-multiple-tx-mgrs-with-attransactional[value]\n| `String`\n| Optional qualifier that specifies the transaction manager to be used.\n\n| `transactionManager`\n| `String`\n| Alias for `value`.\n\n| `label`\n| Array of `String` labels to add an expressive description to the transaction.\n| Labels may be evaluated by transaction managers to associate implementation-specific behavior with the actual transaction.\n\n| xref:data-access/transaction/declarative/tx-propagation.adoc[propagation]\n| `enum`: `Propagation`\n| Optional propagation setting.\n\n| `isolation`\n| `enum`: `Isolation`\n| Optional isolation level. Applies only to propagation values of `REQUIRED` or `REQUIRES_NEW`.\n\n| `timeout`\n| `int` (in seconds of granularity)\n| Optional transaction timeout. Applies only to propagation values of `REQUIRED` or `REQUIRES_NEW`.\n\n| `timeoutString`\n| `String` (in seconds of granularity)\n| Alternative for specifying the `timeout` in seconds as a `String` value -- for example, as a placeholder.\n\n| `readOnly`\n| `boolean`\n| Read-write versus read-only transaction. Only applicable to values of `REQUIRED` or `REQUIRES_NEW`.\n\n| `rollbackFor`\n| Array of `Class` objects, which must be derived from `Throwable.`\n| Optional array of exception types that must cause rollback.\n\n| `rollbackForClassName`\n| Array of exception name patterns.\n| Optional array of exception name patterns that must cause rollback.\n\n| `noRollbackFor`\n| Array of `Class` objects, which must be derived from `Throwable.`\n| Optional array of exception types that must not cause rollback.\n\n| `noRollbackForClassName`\n| Array of exception name patterns.\n| Optional array of exception name patterns that must not cause rollback.\n|===\n\nTIP: See\nxref:data-access/transaction/declarative/rolling-back.adoc#transaction-declarative-rollback-rules[Rollback rules]\nfor further details on rollback rule semantics, patterns, and warnings\nregarding possible unintentional matches for pattern-based rollback rules.\n\n[NOTE]\n====\nAs of 6.2, you can globally change the default rollback behavior â€“ for example, through\n`@EnableTransactionManagement(rollbackOn=ALL_EXCEPTIONS)`, leading to a rollback\nfor all exceptions raised within a transaction, including any checked exception.\nFor further customizations, `AnnotationTransactionAttributeSource` provides an\n`addDefaultRollbackRule(RollbackRuleAttribute)` method for custom default rules.\n\nNote that transaction-specific rollback rules override the default behavior but\nretain the chosen default for unspecified exceptions. This is the case for\nSpring's `@Transactional` as well as JTA's `jakarta.transaction.Transactional`\nannotation.\n\nUnless you rely on EJB-style business exceptions with commit behavior, it is\nadvisable to switch to `ALL_EXCEPTIONS` for consistent rollback semantics even\nin case of a (potentially accidental) checked exception. Also, it is advisable\nto make that switch for Kotlin-based applications where there is no enforcement\nof checked exceptions at all.\n====\n\nCurrently, you cannot have explicit control over the name of a transaction, where 'name'\nmeans the transaction name that appears in a transaction monitor and in logging output.\nFor declarative transactions, the transaction name is always the fully-qualified class\nname of the transactionally advised class + `.` + the method name. For example, if the\n`handlePayment(..)` method of the `BusinessService` class started a transaction, the\nname of the transaction would be `com.example.BusinessService.handlePayment`.\n\n[[tx-multiple-tx-mgrs-with-attransactional]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/annotations.adoc", "title": "annotations", "heading": "`@Transactional` Settings", "heading_level": 2, "file_order": 122, "section_index": 1, "content_hash": "b1b0d65c7cd5005a1143fd61b7fd5613692683438255a02470696702cbd7b298", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/annotations.adoc"}}
{"id": "sha256:be46125ad5a9ff75e87e7c1e362f6d6ceba6d1e52a9fd13987eafb10ccfeb946", "content": "Most Spring applications need only a single transaction manager, but there may be\nsituations where you want multiple independent transaction managers in a single\napplication. You can use the `value` or `transactionManager` attribute of the\n`@Transactional` annotation to optionally specify the identity of the\n`TransactionManager` to be used. This can either be the bean name or the qualifier value\nof the transaction manager bean. For example, using the qualifier notation, you can\ncombine the following Java code with the following transaction manager bean declarations\nin the application context:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class TransactionalService {\n\n @Transactional(\"order\")\n public void setSomething(String name) { ... }\n\n @Transactional(\"account\")\n public void doSomething() { ... }\n\n @Transactional(\"reactive-account\")\n public Mono<Void> doSomethingReactive() { ... }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tclass TransactionalService {\n\n @Transactional(\"order\")\n fun setSomething(name: String) {\n // ...\n }\n\n @Transactional(\"account\")\n fun doSomething() {\n // ...\n }\n\n @Transactional(\"reactive-account\")\n fun doSomethingReactive(): Mono<Void> {\n // ...\n }\n\t}\n----\n======\n\nThe following listing shows the bean declarations:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tx:annotation-driven/>\n\n <bean id=\"transactionManager1\" class=\"org.springframework.jdbc.support.JdbcTransactionManager\">\n ...\n <qualifier value=\"order\"/>\n </bean>\n\n <bean id=\"transactionManager2\" class=\"org.springframework.jdbc.support.JdbcTransactionManager\">\n ...\n <qualifier value=\"account\"/>\n </bean>\n\n <bean id=\"transactionManager3\" class=\"org.springframework.data.r2dbc.connection.R2dbcTransactionManager\">\n ...\n <qualifier value=\"reactive-account\"/>\n </bean>\n----\n\nIn this case, the individual methods on `TransactionalService` run under separate\ntransaction managers, differentiated by the `order`, `account`, and `reactive-account`\nqualifiers. The default `<tx:annotation-driven>` target bean name, `transactionManager`,\nis still used if no specifically qualified `TransactionManager` bean is found.\n\n[TIP]\n====\nIf all transactional methods on the same class share the same qualifier, consider\ndeclaring a type-level `org.springframework.beans.factory.annotation.Qualifier`\nannotation instead. If its value matches the qualifier value (or bean name) of a\nspecific transaction manager, that transaction manager is going to be used for\ntransaction definitions without a specific qualifier on `@Transactional` itself.\n\nSuch a type-level qualifier can be declared on the concrete class, applying to\ntransaction definitions from a base class as well. This effectively overrides\nthe default transaction manager choice for any unqualified base class methods.\n\nLast but not least, such a type-level bean qualifier can serve multiple purposes,\nfor example, with a value of \"order\" it can be used for autowiring purposes (identifying\nthe order repository) as well as transaction manager selection, as long as the\ntarget beans for autowiring as well as the associated transaction manager\ndefinitions declare the same qualifier value. Such a qualifier value only needs\nto be unique within a set of type-matching beans, not having to serve as an ID.\n====\n\n[[tx-custom-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/annotations.adoc", "title": "annotations", "heading": "Multiple Transaction Managers with `@Transactional`", "heading_level": 2, "file_order": 122, "section_index": 2, "content_hash": "be46125ad5a9ff75e87e7c1e362f6d6ceba6d1e52a9fd13987eafb10ccfeb946", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/annotations.adoc"}}
{"id": "sha256:343b444bc00d66532a66bb7a72a614a8402157f89dc041442f480f6702b967d6", "content": "If you find you repeatedly use the same attributes with `@Transactional` on many different methods,\nxref:core/beans/classpath-scanning.adoc#beans-meta-annotations[Spring's meta-annotation support]\nlets you define custom composed annotations for your specific use cases. For example, consider the\nfollowing annotation definitions:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target({ElementType.METHOD, ElementType.TYPE})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Transactional(transactionManager = \"order\", label = \"causal-consistency\")\n\tpublic @interface OrderTx {\n\t}\n\n\t@Target({ElementType.METHOD, ElementType.TYPE})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Transactional(transactionManager = \"account\", label = \"retryable\")\n\tpublic @interface AccountTx {\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@Transactional(transactionManager = \"order\", label = [\"causal-consistency\"])\n\tannotation class OrderTx\n\n\t@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@Transactional(transactionManager = \"account\", label = [\"retryable\"])\n\tannotation class AccountTx\n----\n======\n\nThe preceding annotations let us write the example from the previous section as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class TransactionalService {\n\n @OrderTx\n public void setSomething(String name) {\n // ...\n }\n\n @AccountTx\n public void doSomething() {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tclass TransactionalService {\n\n @OrderTx\n fun setSomething(name: String) {\n // ...\n }\n\n @AccountTx\n fun doSomething() {\n // ...\n }\n\t}\n----\n======\n\nIn the preceding example, we used the syntax to define the transaction manager qualifier\nand transactional labels, but we could also have included propagation behavior,\nrollback rules, timeouts, and other features.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/annotations.adoc", "title": "annotations", "heading": "Custom Composed Annotations", "heading_level": 2, "file_order": 122, "section_index": 3, "content_hash": "343b444bc00d66532a66bb7a72a614a8402157f89dc041442f480f6702b967d6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/annotations.adoc"}}
{"id": "sha256:d6e79c28e19b153c5d5b0567a465b824738a29c99c04bd6095cab7facba6b39e", "content": "[[transaction-declarative-applying-more-than-just-tx-advice]]\n\nSuppose you want to run both transactional operations and some basic profiling advice.\nHow do you effect this in the context of `<tx:annotation-driven/>`?\n\nWhen you invoke the `updateFoo(Foo)` method, you want to see the following actions:\n\n* The configured profiling aspect starts.\n* The transactional advice runs.\n* The method on the advised object runs.\n* The transaction commits.\n* The profiling aspect reports the exact duration of the whole transactional method invocation.\n\nNOTE: This chapter is not concerned with explaining AOP in any great detail (except as it\napplies to transactions). See xref:core/aop.adoc[AOP] for detailed coverage of the AOP\nconfiguration and AOP in general.\n\nThe following code shows the simple profiling aspect discussed earlier:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage x.y;\n\n\timport org.aspectj.lang.ProceedingJoinPoint;\n\timport org.springframework.util.StopWatch;\n\timport org.springframework.core.Ordered;\n\n\tpublic class SimpleProfiler implements Ordered {\n\n private int order;\n\n // allows us to control the ordering of advice\n public int getOrder() {\n return this.order;\n }\n\n public void setOrder(int order) {\n this.order = order;\n }\n\n // this method is the around advice\n public Object profile(ProceedingJoinPoint call) throws Throwable {\n Object returnValue;\n StopWatch clock = new StopWatch(getClass().getName());\n try {\n clock.start(call.toShortString());\n returnValue = call.proceed();\n } finally {\n clock.stop();\n System.out.println(clock.prettyPrint());\n }\n return returnValue;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\",chomp=\"-packages\"]\n----\n\tpackage x.y\n\n\timport org.aspectj.lang.ProceedingJoinPoint\n\timport org.springframework.util.StopWatch\n\timport org.springframework.core.Ordered\n\n\tclass SimpleProfiler : Ordered {\n\n private var order: Int = 0\n\n // allows us to control the ordering of advice\n override fun getOrder(): Int {\n return this.order\n }\n\n fun setOrder(order: Int) {\n this.order = order\n }\n\n // this method is the around advice\n fun profile(call: ProceedingJoinPoint): Any {\n var returnValue: Any\n val clock = StopWatch(javaClass.name)\n try {\n clock.start(call.toShortString())\n returnValue = call.proceed()\n } finally {\n clock.stop()\n println(clock.prettyPrint())\n }\n return returnValue\n }\n\t}\n----\n======\n\nThe ordering of advice\nis controlled through the `Ordered` interface. For full details on advice ordering, see\nxref:core/aop/ataspectj/advice.adoc#aop-ataspectj-advice-ordering[Advice ordering].\n\nThe following configuration creates a `fooService` bean that has profiling and\ntransactional aspects applied to it in the desired order:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:aop=\"http://www.springframework.org/schema/aop\"\n xmlns:tx=\"http://www.springframework.org/schema/tx\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/tx\n https://www.springframework.org/schema/tx/spring-tx.xsd\n http://www.springframework.org/schema/aop\n https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n <bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\n\n <!-- this is the aspect -->\n <bean id=\"profiler\" class=\"x.y.SimpleProfiler\">\n <!-- run before the transactional advice (hence the lower order number) -->\n <property name=\"order\" value=\"1\"/>\n </bean>\n\n <tx:annotation-driven transaction-manager=\"txManager\" order=\"200\"/>\n\n <aop:config>\n <!-- this advice runs around the transactional advice -->\n <aop:aspect id=\"profilingAspect\" ref=\"profiler\">\n <aop:pointcut id=\"serviceMethodWithReturnValue\"\n expression=\"execution(!void x.y..*Service.*(..))\"/>\n <aop:around method=\"profile\" pointcut-ref=\"serviceMethodWithReturnValue\"/>\n </aop:aspect>\n </aop:config>\n\n <bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n <property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\"/>\n <property name=\"url\" value=\"jdbc:oracle:thin:@rj-t42:1521:elvis\"/>\n <property name=\"username\" value=\"scott\"/>\n <property name=\"password\" value=\"tiger\"/>\n </bean>\n\n <bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n <property name=\"dataSource\" ref=\"dataSource\"/>\n </bean>\n\n\t</beans>\n----\n\nYou can configure any number\nof additional aspects in similar fashion.\n\nThe following example creates the same setup as the previous two examples but uses the purely XML\ndeclarative approach:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:aop=\"http://www.springframework.org/schema/aop\"\n xmlns:tx=\"http://www.springframework.org/schema/tx\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/tx\n https://www.springframework.org/schema/tx/spring-tx.xsd\n http://www.springframework.org/schema/aop\n https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n <bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\n\n <!-- the profiling advice -->\n <bean id=\"profiler\" class=\"x.y.SimpleProfiler\">\n <!-- run before the transactional advice (hence the lower order number) -->\n <property name=\"order\" value=\"1\"/>\n </bean>\n\n <aop:config>\n <aop:pointcut id=\"entryPointMethod\" expression=\"execution(* x.y..*Service.*(..))\"/>\n <!-- runs after the profiling advice (cf. the order attribute) -->\n\n <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"entryPointMethod\" order=\"2\"/>\n <!-- order value is higher than the profiling aspect -->\n\n <aop:aspect id=\"profilingAspect\" ref=\"profiler\">\n <aop:pointcut id=\"serviceMethodWithReturnValue\"\n expression=\"execution(!void x.y..*Service.*(..))\"/>\n <aop:around method=\"profile\" pointcut-ref=\"serviceMethodWithReturnValue\"/>\n </aop:aspect>\n\n </aop:config>\n\n <tx:advice id=\"txAdvice\" transaction-manager=\"txManager\">\n <tx:attributes>\n <tx:method name=\"get*\" read-only=\"true\"/>\n <tx:method name=\"*\"/>\n </tx:attributes>\n </tx:advice>\n\n <!-- other <bean/> definitions such as a DataSource and a TransactionManager here -->\n\n\t</beans>\n----\n\nThe result of the preceding configuration is a `fooService` bean that has profiling and\ntransactional aspects applied to it in that order. If you want the profiling advice\nto run after the transactional advice on the way in and before the\ntransactional advice on the way out, you can swap the value of the profiling\naspect bean's `order` property so that it is higher than the transactional advice's\norder value.\n\nYou can configure additional aspects in similar fashion.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/applying-more-than-just-tx-advice.adoc", "title": "applying-more-than-just-tx-advice", "heading": "applying-more-than-just-tx-advice", "heading_level": 1, "file_order": 123, "section_index": 0, "content_hash": "d6e79c28e19b153c5d5b0567a465b824738a29c99c04bd6095cab7facba6b39e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/applying-more-than-just-tx-advice.adoc"}}
{"id": "sha256:a91cf225d3462c211be3d69fc1cb351daaab32ca8d94ba95fb36ff30514fa8a8", "content": "[[transaction-declarative-aspectj]]\n\nYou can also use the Spring Framework's `@Transactional` support outside of a Spring\ncontainer by means of an AspectJ aspect. To do so, first annotate your classes\n(and optionally your classes' methods) with the `@Transactional` annotation,\nand then link (weave) your application with the\n`org.springframework.transaction.aspectj.AnnotationTransactionAspect` defined in the\n`spring-aspects.jar` file. You must also configure the aspect with a transaction\nmanager. You can use the Spring Framework's IoC container to take care of\ndependency-injecting the aspect. The simplest way to configure the transaction\nmanagement aspect is to use the `<tx:annotation-driven/>` element and specify the\n`mode` attribute to `aspectj` as described in\nxref:data-access/transaction/declarative/annotations.adoc[Using `@Transactional`].\nBecause we focus here on applications that run outside of a Spring container,\nwe show you how to do it programmatically.\n\nNOTE: Prior to continuing, you may want to read\nxref:data-access/transaction/declarative/annotations.adoc[Using `@Transactional`] and\nxref:core/aop.adoc[AOP] respectively.\n\nThe following example shows how to create a transaction manager and configure the\n`AnnotationTransactionAspect` to use it:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// construct an appropriate transaction manager\n\tDataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());\n\n\t// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods\n\tAnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// construct an appropriate transaction manager\n\tval txManager = DataSourceTransactionManager(getDataSource())\n\n\t// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods\n\tAnnotationTransactionAspect.aspectOf().transactionManager = txManager\n----\n======\n\nNOTE: When you use this aspect, you must annotate the implementation class (or the methods\nwithin that class or both), not the interface (if any) that the class implements. AspectJ\nfollows Java's rule that annotations on interfaces are not inherited.\n\nThe `@Transactional` annotation on a class specifies the default transaction semantics\nfor the execution of any public method in the class.\n\nThe `@Transactional` annotation on a method within the class overrides the default\ntransaction semantics given by the class annotation (if present). You can annotate any method,\nregardless of visibility.\n\nTo weave your applications with the `AnnotationTransactionAspect`, you must either build\nyour application with AspectJ (see the {aspectj-docs-devguide}/index.html[AspectJ Development\nGuide]) or use load-time weaving. See\nxref:core/aop/using-aspectj.adoc#aop-aj-ltw[Load-time weaving with AspectJ in the Spring Framework]\nfor a discussion of load-time weaving with AspectJ.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/aspectj.adoc", "title": "aspectj", "heading": "aspectj", "heading_level": 1, "file_order": 124, "section_index": 0, "content_hash": "a91cf225d3462c211be3d69fc1cb351daaab32ca8d94ba95fb36ff30514fa8a8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/aspectj.adoc"}}
{"id": "sha256:9240674e699729150c0aab7a1d77ceaddaaec7739df15f055ef88042acaf43cd", "content": "[[transaction-declarative-diff-tx]]\n\nConsider the scenario where you have a number of service layer objects, and you want to\napply a totally different transactional configuration to each of them. You can do so\nby defining distinct `<aop:advisor/>` elements with differing `pointcut` and\n`advice-ref` attribute values.\n\nAs a point of comparison, first assume that all of your service layer classes are\ndefined in a root `x.y.service` package. To make all beans that are instances of classes\ndefined in that package (or in subpackages) and that have names ending in `Service` have\nthe default transactional configuration, you could write the following:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:aop=\"http://www.springframework.org/schema/aop\"\n xmlns:tx=\"http://www.springframework.org/schema/tx\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/tx\n https://www.springframework.org/schema/tx/spring-tx.xsd\n http://www.springframework.org/schema/aop\n https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n <aop:config>\n\n <aop:pointcut id=\"serviceOperation\"\n expression=\"execution(* x.y.service..*Service.*(..))\"/>\n\n <aop:advisor pointcut-ref=\"serviceOperation\" advice-ref=\"txAdvice\"/>\n\n </aop:config>\n\n <!-- these two beans will be transactional... -->\n <bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\n <bean id=\"barService\" class=\"x.y.service.extras.SimpleBarService\"/>\n\n <!-- ... and these two beans won't -->\n <bean id=\"anotherService\" class=\"org.xyz.SomeService\"/> <!-- (not in the right package) -->\n <bean id=\"barManager\" class=\"x.y.service.SimpleBarManager\"/> <!-- (doesn't end in 'Service') -->\n\n <tx:advice id=\"txAdvice\">\n <tx:attributes>\n <tx:method name=\"get*\" read-only=\"true\"/>\n <tx:method name=\"*\"/>\n </tx:attributes>\n </tx:advice>\n\n <!-- other transaction infrastructure beans such as a TransactionManager omitted... -->\n\n\t</beans>\n----\n\nThe following example shows how to configure two distinct beans with totally different\ntransactional settings:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:aop=\"http://www.springframework.org/schema/aop\"\n xmlns:tx=\"http://www.springframework.org/schema/tx\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/tx\n https://www.springframework.org/schema/tx/spring-tx.xsd\n http://www.springframework.org/schema/aop\n https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n <aop:config>\n\n <aop:pointcut id=\"defaultServiceOperation\"\n expression=\"execution(* x.y.service.*Service.*(..))\"/>\n\n <aop:pointcut id=\"noTxServiceOperation\"\n expression=\"execution(* x.y.service.ddl.DefaultDdlManager.*(..))\"/>\n\n <aop:advisor pointcut-ref=\"defaultServiceOperation\" advice-ref=\"defaultTxAdvice\"/>\n\n <aop:advisor pointcut-ref=\"noTxServiceOperation\" advice-ref=\"noTxAdvice\"/>\n\n </aop:config>\n\n <!-- this bean will be transactional (see the 'defaultServiceOperation' pointcut) -->\n <bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\n\n <!-- this bean will also be transactional, but with totally different transactional settings -->\n <bean id=\"anotherFooService\" class=\"x.y.service.ddl.DefaultDdlManager\"/>\n\n <tx:advice id=\"defaultTxAdvice\">\n <tx:attributes>\n <tx:method name=\"get*\" read-only=\"true\"/>\n <tx:method name=\"*\"/>\n </tx:attributes>\n </tx:advice>\n\n <tx:advice id=\"noTxAdvice\">\n <tx:attributes>\n <tx:method name=\"*\" propagation=\"NEVER\"/>\n </tx:attributes>\n </tx:advice>\n\n <!-- other transaction infrastructure beans such as a TransactionManager omitted... -->\n\n\t</beans>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/diff-tx.adoc", "title": "diff-tx", "heading": "diff-tx", "heading_level": 1, "file_order": 125, "section_index": 0, "content_hash": "9240674e699729150c0aab7a1d77ceaddaaec7739df15f055ef88042acaf43cd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/diff-tx.adoc"}}
{"id": "sha256:1a4399fe7d4fe939818285e6e26f6a648652a770fbb0200db2210334e7f7d061", "content": "[[transaction-declarative-first-example]]\n\nConsider the following interface and its attendant implementation. This example uses\n`Foo` and `Bar` classes as placeholders so that you can concentrate on the transaction\nusage without focusing on a particular domain model. For the purposes of this example,\nthe fact that the `DefaultFooService` class throws `UnsupportedOperationException`\ninstances in the body of each implemented method is good. That behavior lets you see\ntransactions being created and then rolled back in response to the\n`UnsupportedOperationException` instance. The following listing shows the `FooService`\ninterface:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\t// the service interface that we want to make transactional\n\n\tpackage x.y.service;\n\n\tpublic interface FooService {\n\n Foo getFoo(String fooName);\n\n Foo getFoo(String fooName, String barName);\n\n void insertFoo(Foo foo);\n\n void updateFoo(Foo foo);\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\t// the service interface that we want to make transactional\n\n\tpackage x.y.service\n\n\tinterface FooService {\n\n fun getFoo(fooName: String): Foo\n\n fun getFoo(fooName: String, barName: String): Foo\n\n fun insertFoo(foo: Foo)\n\n fun updateFoo(foo: Foo)\n\t}\n----\n======\n\nThe following example shows an implementation of the preceding interface:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage x.y.service;\n\n\tpublic class DefaultFooService implements FooService {\n\n @Override\n public Foo getFoo(String fooName) {\n // ...\n }\n\n @Override\n public Foo getFoo(String fooName, String barName) {\n // ...\n }\n\n @Override\n public void insertFoo(Foo foo) {\n // ...\n }\n\n @Override\n public void updateFoo(Foo foo) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage x.y.service\n\n\tclass DefaultFooService : FooService {\n\n override fun getFoo(fooName: String): Foo {\n // ...\n }\n\n override fun getFoo(fooName: String, barName: String): Foo {\n // ...\n }\n\n override fun insertFoo(foo: Foo) {\n // ...\n }\n\n override fun updateFoo(foo: Foo) {\n // ...\n }\n\t}\n----\n======\n\nAssume that the first two methods of the `FooService` interface, `getFoo(String)` and\n`getFoo(String, String)`, must run in the context of a transaction with read-only\nsemantics and that the other methods, `insertFoo(Foo)` and `updateFoo(Foo)`, must\nrun in the context of a transaction with read-write semantics. The following\nconfiguration is explained in detail in the next few paragraphs:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<!-- from the file 'context.xml' -->\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:aop=\"http://www.springframework.org/schema/aop\"\n xmlns:tx=\"http://www.springframework.org/schema/tx\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/tx\n https://www.springframework.org/schema/tx/spring-tx.xsd\n http://www.springframework.org/schema/aop\n https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n <!-- this is the service object that we want to make transactional -->\n <bean id=\"fooService\" class=\"x.y.service.DefaultFooService\"/>\n\n <!-- the transactional advice (what 'happens'; see the <aop:advisor/> bean below) -->\n <tx:advice id=\"txAdvice\" transaction-manager=\"txManager\">\n <!-- the transactional semantics... -->\n <tx:attributes>\n <!-- all methods starting with 'get' are read-only -->\n <tx:method name=\"get*\" read-only=\"true\"/>\n <!-- other methods use the default transaction settings (see below) -->\n <tx:method name=\"*\"/>\n </tx:attributes>\n </tx:advice>\n\n <!-- ensure that the above transactional advice runs for any execution\n of an operation defined by the FooService interface -->\n <aop:config>\n <aop:pointcut id=\"fooServiceOperation\" expression=\"execution(* x.y.service.FooService.*(..))\"/>\n <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"fooServiceOperation\"/>\n </aop:config>\n\n <!-- don't forget the DataSource -->\n <bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n <property name=\"driverClassName\" value=\"oracle.jdbc.driver.OracleDriver\"/>\n <property name=\"url\" value=\"jdbc:oracle:thin:@rj-t42:1521:elvis\"/>\n <property name=\"username\" value=\"scott\"/>\n <property name=\"password\" value=\"tiger\"/>\n </bean>\n\n <!-- similarly, don't forget the TransactionManager -->\n <bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n <property name=\"dataSource\" ref=\"dataSource\"/>\n </bean>\n\n <!-- other <bean/> definitions here -->\n\n\t</beans>\n----\n\nExamine the preceding configuration. It assumes that you want to make a service object,\nthe `fooService` bean, transactional. The transaction semantics to apply are encapsulated\nin the `<tx:advice/>` definition. The `<tx:advice/>` definition reads as \"all methods\nstarting with `get` are to run in the context of a read-only transaction, and all\nother methods are to run with the default transaction semantics\". The\n`transaction-manager` attribute of the `<tx:advice/>` tag is set to the name of the\n`TransactionManager` bean that is going to drive the transactions (in this case, the\n`txManager` bean).\n\nTIP: You can omit the `transaction-manager` attribute in the transactional advice\n(`<tx:advice/>`) if the bean name of the `TransactionManager` that you want to\nwire in has the name `transactionManager`. If the `TransactionManager` bean that\nyou want to wire in has any other name, you must use the `transaction-manager`\nattribute explicitly, as in the preceding example.\n\nThe `<aop:config/>` definition ensures that the transactional advice defined by the\n`txAdvice` bean runs at the appropriate points in the program. First, you define a\npointcut that matches the execution of any operation defined in the `FooService` interface\n(`fooServiceOperation`). Then you associate the pointcut with the `txAdvice` by using an\nadvisor. The result indicates that, at the execution of a `fooServiceOperation`,\nthe advice defined by `txAdvice` is run.\n\nThe expression defined within the `<aop:pointcut/>` element is an AspectJ pointcut\nexpression. See xref:core/aop.adoc[the AOP section] for more details on pointcut\nexpressions in Spring.\n\nA common requirement is to make an entire service layer transactional. The best way to\ndo this is to change the pointcut expression to match any operation in your\nservice layer. The following example shows how to do so:\n\n[source,xml,indent=0,subs=\"verbatim\"]\n----\n\t<aop:config>\n <aop:pointcut id=\"fooServiceMethods\" expression=\"execution(* x.y.service.*.*(..))\"/>\n <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"fooServiceMethods\"/>\n\t</aop:config>\n----\n\nNOTE: In the preceding example, it is assumed that all your service interfaces are defined\nin the `x.y.service` package. See xref:core/aop.adoc[the AOP section] for more details.\n\nNow that we have analyzed the configuration, you may be asking yourself,\n\"What does all this configuration actually do?\"\n\nThe configuration shown earlier is used to create a transactional proxy around the object\nthat is created from the `fooService` bean definition. The proxy is configured with\nthe transactional advice so that, when an appropriate method is invoked on the proxy,\na transaction is started, suspended, marked as read-only, and so on, depending on the\ntransaction configuration associated with that method. Consider the following program\nthat test drives the configuration shown earlier:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic final class Boot {\n\n public static void main(final String[] args) throws Exception {\n ApplicationContext ctx = new ClassPathXmlApplicationContext(\"context.xml\");\n FooService fooService = ctx.getBean(FooService.class);\n fooService.insertFoo(new Foo());\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\tfun main() {\n val ctx = ClassPathXmlApplicationContext(\"context.xml\")\n val fooService = ctx.getBean<FooService>(\"fooService\")\n fooService.insertFoo(Foo())\n\t}\n----\n======\n\nThe output from running the preceding program should resemble the following (the Log4J\noutput and the stack trace from the `UnsupportedOperationException` thrown by the\n`insertFoo(..)` method of the `DefaultFooService` class have been truncated for clarity):\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- the Spring container is starting up... -->\n\t[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy for bean 'fooService' with 0 common interceptors and 1 specific interceptors\n\n\t<!-- the DefaultFooService is actually proxied -->\n\t[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]\n\n\t<!-- ... the insertFoo(..) method is now being invoked on the proxy -->\n\t[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo\n\n\t<!-- the transactional advice kicks in here... -->\n\t[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]\n\t[DataSourceTransactionManager] - Acquired Connection [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction\n\n\t<!-- the insertFoo(..) method from DefaultFooService throws an exception... -->\n\t[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should rollback on java.lang.UnsupportedOperationException\n\t[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo due to throwable [java.lang.UnsupportedOperationException]\n\n\t<!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) -->\n\t[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection [org.apache.commons.dbcp.PoolableConnection@a53de4]\n\t[DataSourceTransactionManager] - Releasing JDBC Connection after transaction\n\t[DataSourceUtils] - Returning JDBC Connection to DataSource\n\n\tException in thread \"main\" java.lang.UnsupportedOperationException at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)\n\t<!-- AOP infrastructure stack trace elements removed for clarity -->\n\tat $Proxy0.insertFoo(Unknown Source)\n\tat Boot.main(Boot.java:11)\n----\n\nTo use reactive transaction management the code has to use reactive types.\n\nNOTE: Spring Framework uses the `ReactiveAdapterRegistry` to determine whether a method\nreturn type is reactive.\n\nThe following listing shows a modified version of the previously used `FooService`, but\nthis time the code uses reactive types:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\t// the reactive service interface that we want to make transactional\n\n\tpackage x.y.service;\n\n\tpublic interface FooService {\n\n Flux<Foo> getFoo(String fooName);\n\n Publisher<Foo> getFoo(String fooName, String barName);\n\n Mono<Void> insertFoo(Foo foo);\n\n Mono<Void> updateFoo(Foo foo);\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\t// the reactive service interface that we want to make transactional\n\n\tpackage x.y.service\n\n\tinterface FooService {\n\n fun getFoo(fooName: String): Flow<Foo>\n\n fun getFoo(fooName: String, barName: String): Publisher<Foo>\n\n fun insertFoo(foo: Foo) : Mono<Void>\n\n fun updateFoo(foo: Foo) : Mono<Void>\n\t}\n----\n======\n\nThe following example shows an implementation of the preceding interface:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage x.y.service;\n\n\tpublic class DefaultFooService implements FooService {\n\n @Override\n public Flux<Foo> getFoo(String fooName) {\n // ...\n }\n\n @Override\n public Publisher<Foo> getFoo(String fooName, String barName) {\n // ...\n }\n\n @Override\n public Mono<Void> insertFoo(Foo foo) {\n // ...\n }\n\n @Override\n public Mono<Void> updateFoo(Foo foo) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage x.y.service\n\n\tclass DefaultFooService : FooService {\n\n override fun getFoo(fooName: String): Flow<Foo> {\n // ...\n }\n\n override fun getFoo(fooName: String, barName: String): Publisher<Foo> {\n // ...\n }\n\n override fun insertFoo(foo: Foo): Mono<Void> {\n // ...\n }\n\n override fun updateFoo(foo: Foo): Mono<Void> {\n // ...\n }\n\t}\n----\n======\n\nImperative and reactive transaction management share the same semantics for transaction\nboundary and transaction attribute definitions. The main difference between imperative\nand reactive transactions is the deferred nature of the latter. `TransactionInterceptor`\ndecorates the returned reactive type with a transactional operator to begin and clean up\nthe transaction. Therefore, calling a transactional reactive method defers the actual\ntransaction management to a subscription type that activates processing of the reactive\ntype.\n\nAnother aspect of reactive transaction management relates to data escaping which is a\nnatural consequence of the programming model.\n\nMethod return values of imperative transactions are returned from transactional methods\nupon successful termination of a method so that partially computed results do not escape\nthe method closure.\n\nReactive transaction methods return a reactive wrapper type which represents a\ncomputation sequence along with a promise to begin and complete the computation.\n\nA `Publisher` can emit data while a transaction is ongoing but not necessarily completed.\nTherefore, methods that depend upon successful completion of an entire transaction need\nto ensure completion and buffer results in the calling code.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/first-example.adoc", "title": "first-example", "heading": "first-example", "heading_level": 1, "file_order": 126, "section_index": 0, "content_hash": "1a4399fe7d4fe939818285e6e26f6a648652a770fbb0200db2210334e7f7d061", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/first-example.adoc"}}
{"id": "sha256:59dda5a08b02d6b56068931a0e1d9ab295f23f76339caf76168f813fbaa30479", "content": "[[transaction-declarative-rolling-back]]\n\nThe previous section outlined the basics of how to specify transactional settings for\nclasses, typically service layer classes, declaratively in your application. This section\ndescribes how you can control the rollback of transactions in a simple, declarative\nfashion in XML configuration. For details on controlling rollback semantics declaratively\nwith the `@Transactional` annotation, see\nxref:data-access/transaction/declarative/annotations.adoc#transaction-declarative-attransactional-settings[`@Transactional` Settings].\n\nThe recommended way to indicate to the Spring Framework's transaction infrastructure\nthat a transaction's work is to be rolled back is to throw an `Exception` from code that\nis currently executing in the context of a transaction. The Spring Framework's\ntransaction infrastructure code catches any unhandled `Exception` as it bubbles up\nthe call stack and makes a determination whether to mark the transaction for rollback.\n\nIn its default configuration, the Spring Framework's transaction infrastructure code\nmarks a transaction for rollback only in the case of runtime, unchecked exceptions.\nThat is, when the thrown exception is an instance or subclass of `RuntimeException`.\n(`Error` instances also, by default, result in a rollback).\n\nThe default configuration also provides support for Vavr's `Try` method to trigger\ntransaction rollbacks when it returns a 'Failure'.\nThis allows you to handle functional-style errors using Try and have the transaction\nautomatically rolled back in case of a failure. For more information on Vavr's Try,\nrefer to the {vavr-docs}/#_try[official Vavr documentation].\nHere's an example of how to use Vavr's Try with a transactional method:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Transactional\n\tpublic Try<String> myTransactionalMethod() {\n // If myDataAccessOperation throws an exception, it will be caught by the\n // Try instance created with Try.of() and wrapped inside the Failure class\n // which can be checked using the isFailure() method on the Try instance.\n return Try.of(delegate::myDataAccessOperation);\n\t}\n----\n======\n\nAs of Spring Framework 6.1, there is also special treatment of `CompletableFuture`\n(and general `Future`) return values, triggering a rollback for such a handle if it\nwas exceptionally completed at the time of being returned from the original method.\nThis is intended for `@Async` methods where the actual method implementation may\nneed to comply with a `CompletableFuture` signature (auto-adapted to an actual\nasynchronous handle for a call to the proxy by `@Async` processing at runtime),\npreferring exposure in the returned handle rather than rethrowing an exception:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Transactional @Async\n\tpublic CompletableFuture<String> myTransactionalMethod() {\n try {\n return CompletableFuture.completedFuture(delegate.myDataAccessOperation());\n }\n catch (DataAccessException ex) {\n return CompletableFuture.failedFuture(ex);\n }\n\t}\n----\n======\n\nChecked exceptions that are thrown from a transactional method do not result in a rollback\nin the default configuration. You can configure exactly which `Exception` types mark a\ntransaction for rollback, including checked exceptions by specifying _rollback rules_.\n\n.Rollback rules\n[[transaction-declarative-rollback-rules]]\n[NOTE]\n====\nRollback rules determine if a transaction should be rolled back when a given exception is\nthrown, and the rules are based on exception types or exception patterns.\n\nRollback rules may be configured in XML via the `rollback-for` and `no-rollback-for`\nattributes, which allow rules to be defined as patterns. When using\nxref:data-access/transaction/declarative/annotations.adoc#transaction-declarative-attransactional-settings[`@Transactional`],\nrollback rules may be configured via the `rollbackFor`/`noRollbackFor` and\n`rollbackForClassName`/`noRollbackForClassName` attributes, which allow rules to be\ndefined based on exception types or patterns, respectively.\n\nWhen a rollback rule is defined with an exception type â€“ for example, via `rollbackFor` â€“\nthat type will be used to match against the type of a thrown exception. Specifically,\ngiven a configured exception type `C`, a thrown exception of type `T` will be considered\na match against `C` if `T` is equal to `C` or a subclass of `C`. This provides type\nsafety and avoids any unintentional matches that may occur when using a pattern. For\nexample, a value of `jakarta.servlet.ServletException.class` will only match thrown\nexceptions of type `jakarta.servlet.ServletException` and its subclasses.\n\nWhen a rollback rule is defined with an exception pattern, the pattern can be a fully\nqualified class name or a substring of a fully qualified class name for an exception type\n(which must be a subclass of `Throwable`), with no wildcard support at present. For\nexample, a value of `\"jakarta.servlet.ServletException\"` or `\"ServletException\"` will\nmatch `jakarta.servlet.ServletException` and its subclasses.\n\n[WARNING]\n=====\nYou must carefully consider how specific a pattern is and whether to include package\ninformation (which isn't mandatory). For example, `\"Exception\"` will match nearly\nanything and will probably hide other rules. `\"java.lang.Exception\"` would be correct if\n`\"Exception\"` were meant to define a rule for all checked exceptions. With more unique\nexception names such as `\"BaseBusinessException\"` there is likely no need to use the\nfully qualified class name for the exception pattern.\n\nFurthermore, pattern-based rollback rules may result in unintentional matches for\nsimilarly named exceptions and nested classes. This is due to the fact that a thrown\nexception is considered to be a match for a given pattern-based rollback rule if the name\nof the thrown exception contains the exception pattern configured for the rollback rule.\nFor example, given a rule configured to match on `\"com.example.CustomException\"`, that\nrule will match against an exception named `com.example.CustomExceptionV2` (an exception\nin the same package as `CustomException` but with an additional suffix) or an exception\nnamed `com.example.CustomException$AnotherException` (an exception declared as a nested\nclass in `CustomException`).\n=====\n====\n\nThe following XML snippet demonstrates how to configure rollback for a checked,\napplication-specific `Exception` type by supplying an _exception pattern_ via the\n`rollback-for` attribute:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tx:advice id=\"txAdvice\" transaction-manager=\"txManager\">\n <tx:attributes>\n <tx:method name=\"get*\" read-only=\"true\" rollback-for=\"NoProductInStockException\"/>\n <tx:method name=\"*\"/>\n </tx:attributes>\n\t</tx:advice>\n----\n\nIf you do not want a transaction rolled back when an exception is thrown, you can also\nspecify 'no rollback' rules. The following example tells the Spring Framework's\ntransaction infrastructure to commit the attendant transaction even in the face of an\nunhandled `InstrumentNotFoundException`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tx:advice id=\"txAdvice\">\n <tx:attributes>\n <tx:method name=\"updateStock\" no-rollback-for=\"InstrumentNotFoundException\"/>\n <tx:method name=\"*\"/>\n </tx:attributes>\n\t</tx:advice>\n----\n\nWhen the Spring Framework's transaction infrastructure catches an exception and consults\nthe configured rollback rules to determine whether to mark the transaction for rollback,\nthe strongest matching rule wins. So, in the case of the following configuration, any\nexception other than an `InstrumentNotFoundException` results in a rollback of the\nattendant transaction:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tx:advice id=\"txAdvice\">\n <tx:attributes>\n <tx:method name=\"*\" rollback-for=\"Throwable\" no-rollback-for=\"InstrumentNotFoundException\"/>\n </tx:attributes>\n\t</tx:advice>\n----\n\nYou can also indicate a required rollback programmatically. Although simple, this process\nis quite invasive and tightly couples your code to the Spring Framework's transaction\ninfrastructure. The following example shows how to programmatically indicate a required\nrollback:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic void resolvePosition() {\n try {\n // some business logic...\n } catch (NoProductInStockException ex) {\n // trigger rollback programmatically\n TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun resolvePosition() {\n try {\n // some business logic...\n } catch (ex: NoProductInStockException) {\n // trigger rollback programmatically\n TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n }\n\t}\n----\n======\n\nYou are strongly encouraged to use the declarative approach to rollback, if at all\npossible. Programmatic rollback is available should you absolutely need it, but its\nusage flies in the face of achieving a clean POJO-based architecture.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/rolling-back.adoc", "title": "rolling-back", "heading": "rolling-back", "heading_level": 1, "file_order": 127, "section_index": 0, "content_hash": "59dda5a08b02d6b56068931a0e1d9ab295f23f76339caf76168f813fbaa30479", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/rolling-back.adoc"}}
{"id": "sha256:2a6e546faaee4752e1d264b897d899168075e25029285db5c333a76f5ea0458f", "content": "[[tx-decl-explained]]\n\nIt is not sufficient merely to tell you to annotate your classes with the\n`@Transactional` annotation, add `@EnableTransactionManagement` to your configuration,\nand expect you to understand how it all works. To provide a deeper understanding, this\nsection explains the inner workings of the Spring Framework's declarative transaction\ninfrastructure in the context of transaction-related issues.\n\nThe most important concepts to grasp with regard to the Spring Framework's declarative\ntransaction support are that this support is enabled\nxref:core/aop/proxying.adoc#aop-understanding-aop-proxies[via AOP proxies] and that the transactional\nadvice is driven by metadata (currently XML- or annotation-based). The combination of AOP\nwith transactional metadata yields an AOP proxy that uses a `TransactionInterceptor` in\nconjunction with an appropriate `TransactionManager` implementation to drive transactions\naround method invocations.\n\nNOTE: Spring AOP is covered in xref:core/aop.adoc[the AOP section].\n\nSpring Framework's `TransactionInterceptor` provides transaction management for\nimperative and reactive programming models. The interceptor detects the desired flavor of\ntransaction management by inspecting the method return type. Methods returning a reactive\ntype such as `Publisher` or Kotlin `Flow` (or a subtype of those) qualify for reactive\ntransaction management. All other return types including `void` use the code path for\nimperative transaction management.\n\nTransaction management flavors impact which transaction manager is required. Imperative\ntransactions require a `PlatformTransactionManager`, while reactive transactions use\n`ReactiveTransactionManager` implementations.\n\n[NOTE]\n====\n`@Transactional` commonly works with thread-bound transactions managed by\n`PlatformTransactionManager`, exposing a transaction to all data access operations within\nthe current execution thread. Note: This does _not_ propagate to newly started threads\nwithin the method.\n\nA reactive transaction managed by `ReactiveTransactionManager` uses the Reactor context\ninstead of thread-local attributes. As a consequence, all participating data access\noperations need to execute within the same Reactor context in the same reactive pipeline.\n\nWhen configured with a `ReactiveTransactionManager`, all transaction-demarcated methods\nare expected to return a reactive pipeline. Void methods or regular return types need\nto be associated with a regular `PlatformTransactionManager`, for example, through the\n`transactionManager` attribute of the corresponding `@Transactional` declarations.\n====\n\nThe following image shows a conceptual view of calling a method on a transactional proxy:\n\nimage::tx.png[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/tx-decl-explained.adoc", "title": "tx-decl-explained", "heading": "tx-decl-explained", "heading_level": 1, "file_order": 128, "section_index": 0, "content_hash": "2a6e546faaee4752e1d264b897d899168075e25029285db5c333a76f5ea0458f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/tx-decl-explained.adoc"}}
{"id": "sha256:cd65cf0fd6eaa968507d1c785e4e36c365e5e02cbc060bafb94ee49b56ddb0f0", "content": "[[tx-propagation]]\n\nThis section describes some semantics of transaction propagation in Spring. Note\nthat this section is not a proper introduction to transaction propagation. Rather, it\ndetails some of the semantics regarding transaction propagation in Spring.\n\nIn Spring-managed transactions, be aware of the difference between physical and\nlogical transactions, and how the propagation setting applies to this difference.\n\n[[tx-propagation-required]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/tx-propagation.adoc", "title": "tx-propagation", "heading": "tx-propagation", "heading_level": 1, "file_order": 129, "section_index": 0, "content_hash": "cd65cf0fd6eaa968507d1c785e4e36c365e5e02cbc060bafb94ee49b56ddb0f0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/tx-propagation.adoc"}}
{"id": "sha256:a6db4f291d3e6b738923db1e8c937ab2f147253b8b308b317b27a7bfa45eb929", "content": "image::tx_prop_required.png[]\n\n`PROPAGATION_REQUIRED` enforces a physical transaction, either locally for the current\nscope if no transaction exists yet or participating in an existing 'outer' transaction\ndefined for a larger scope. This is a fine default in common call stack arrangements\nwithin the same thread (for example, a service facade that delegates to several repository methods\nwhere all the underlying resources have to participate in the service-level transaction).\n\nNOTE: By default, a participating transaction joins the characteristics of the outer scope,\nsilently ignoring the local isolation level, timeout value, or read-only flag (if any).\nConsider switching the `validateExistingTransactions` flag to `true` on your transaction\nmanager if you want isolation level declarations to be rejected when participating in\nan existing transaction with a different isolation level. This non-lenient mode also\nrejects read-only mismatches (that is, an inner read-write transaction that tries to participate\nin a read-only outer scope).\n\nWhen the propagation setting is `PROPAGATION_REQUIRED`, a logical transaction scope\nis created for each method upon which the setting is applied. Each such logical\ntransaction scope can determine rollback-only status individually, with an outer\ntransaction scope being logically independent from the inner transaction scope.\nIn the case of standard `PROPAGATION_REQUIRED` behavior, all these scopes are\nmapped to the same physical transaction. So a rollback-only marker set in the inner\ntransaction scope does affect the outer transaction's chance to actually commit.\n\nHowever, in the case where an inner transaction scope sets the rollback-only marker, the\nouter transaction has not decided on the rollback itself, so the rollback (silently\ntriggered by the inner transaction scope) is unexpected. A corresponding\n`UnexpectedRollbackException` is thrown at that point. This is expected behavior so\nthat the caller of a transaction can never be misled to assume that a commit was\nperformed when it really was not. So, if an inner transaction (of which the outer caller\nis not aware) silently marks a transaction as rollback-only, the outer caller still\ncalls commit. The outer caller needs to receive an `UnexpectedRollbackException` to\nindicate clearly that a rollback was performed instead.\n\n[[tx-propagation-requires_new]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/tx-propagation.adoc", "title": "tx-propagation", "heading": "Understanding `PROPAGATION_REQUIRED`", "heading_level": 2, "file_order": 129, "section_index": 1, "content_hash": "a6db4f291d3e6b738923db1e8c937ab2f147253b8b308b317b27a7bfa45eb929", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/tx-propagation.adoc"}}
{"id": "sha256:e2bf3cd2c6f54ce2c6c48fd801c2bb669ce0a1c6b1f829e986fc4dadb3c7c1ee", "content": "image::tx_prop_requires_new.png[]\n\n`PROPAGATION_REQUIRES_NEW`, in contrast to `PROPAGATION_REQUIRED`, always uses an\nindependent physical transaction for each affected transaction scope, never\nparticipating in an existing transaction for an outer scope. In such an arrangement,\nthe underlying resource transactions are different and, hence, can commit or roll back\nindependently, with an outer transaction not affected by an inner transaction's rollback\nstatus and with an inner transaction's locks released immediately after its completion.\nSuch an independent inner transaction can also declare its own isolation level, timeout,\nand read-only settings and not inherit an outer transaction's characteristics.\n\nNOTE: The resources attached to the outer transaction will remain bound there while\nthe inner transaction acquires its own resources such as a new database connection.\nThis may lead to exhaustion of the connection pool and potentially to a deadlock if\nseveral threads have an active outer transaction and wait to acquire a new connection\nfor their inner transaction, with the pool not being able to hand out any such inner\nconnection anymore. Do not use `PROPAGATION_REQUIRES_NEW` unless your connection pool\nis appropriately sized, exceeding the number of concurrent threads by at least 1.\n\n[[tx-propagation-nested]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/tx-propagation.adoc", "title": "tx-propagation", "heading": "Understanding `PROPAGATION_REQUIRES_NEW`", "heading_level": 2, "file_order": 129, "section_index": 2, "content_hash": "e2bf3cd2c6f54ce2c6c48fd801c2bb669ce0a1c6b1f829e986fc4dadb3c7c1ee", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/tx-propagation.adoc"}}
{"id": "sha256:80f6afa1b1a660a985dbadcda6bdbf9973963b49162a3bf615d6b2004607099c", "content": "`PROPAGATION_NESTED` uses a single physical transaction with multiple savepoints\nthat it can roll back to. Such partial rollbacks let an inner transaction scope\ntrigger a rollback for its scope, with the outer transaction being able to continue\nthe physical transaction despite some operations having been rolled back. This setting\nis typically mapped onto JDBC savepoints, so it works only with JDBC resource\ntransactions. See Spring's\n{spring-framework-api}/jdbc/datasource/DataSourceTransactionManager.html[`DataSourceTransactionManager`].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/tx-propagation.adoc", "title": "tx-propagation", "heading": "Understanding `PROPAGATION_NESTED`", "heading_level": 2, "file_order": 129, "section_index": 3, "content_hash": "80f6afa1b1a660a985dbadcda6bdbf9973963b49162a3bf615d6b2004607099c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/tx-propagation.adoc"}}
{"id": "sha256:e9a5759b3d80aba73267f4e128e4a48c313836b3c31a98bba43434ac257b1b7f", "content": "[[transaction-declarative-txadvice-settings]]\n\nThis section summarizes the various transactional settings that you can specify by using\nthe `<tx:advice/>` tag. The default `<tx:advice/>` settings are:\n\n* The xref:data-access/transaction/declarative/tx-propagation.adoc[propagation setting] is `REQUIRED.`\n* The isolation level is `DEFAULT.`\n* The transaction is read-write.\n* The transaction timeout defaults to the default timeout of the underlying transaction\n system or none if timeouts are not supported.\n* Any `RuntimeException` triggers rollback, and any checked `Exception` does not.\n\nYou can change these default settings. The following table summarizes the various attributes of the `<tx:method/>` tags\nthat are nested within `<tx:advice/>` and `<tx:attributes/>` tags:\n\n[[tx-method-settings]]\n.<tx:method/> settings\n|===\n| Attribute| Required?| Default| Description\n\n| `name`\n| Yes\n|\n| Method names with which the transaction attributes are to be associated. The\n wildcard ({asterisk}) character can be used to associate the same transaction attribute\n settings with a number of methods (for example, `get*`, `handle*`, `on*Event`, and so\n forth).\n\n| `propagation`\n| No\n| `REQUIRED`\n| Transaction propagation behavior.\n\n| `isolation`\n| No\n| `DEFAULT`\n| Transaction isolation level. Only applicable to propagation settings of `REQUIRED` or `REQUIRES_NEW`.\n\n| `timeout`\n| No\n| -1\n| Transaction timeout (seconds). Only applicable to propagation `REQUIRED` or `REQUIRES_NEW`.\n\n| `read-only`\n| No\n| false\n| Read-write versus read-only transaction. Applies only to `REQUIRED` or `REQUIRES_NEW`.\n\n| `rollback-for`\n| No\n|\n| Comma-delimited list of `Exception` instances that trigger rollback. For example,\n `com.foo.MyBusinessException,ServletException`.\n\n| `no-rollback-for`\n| No\n|\n| Comma-delimited list of `Exception` instances that do not trigger rollback. For example,\n `com.foo.MyBusinessException,ServletException`.\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative/txadvice-settings.adoc", "title": "txadvice-settings", "heading": "txadvice-settings", "heading_level": 1, "file_order": 130, "section_index": 0, "content_hash": "e9a5759b3d80aba73267f4e128e4a48c313836b3c31a98bba43434ac257b1b7f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative/txadvice-settings.adoc"}}
{"id": "sha256:1c31ca56a9b1c16ac9e82ee14007a42923299a7cebc4420e78f7d604bb9c58ee", "content": "[[transaction-application-server-integration]]\n\nSpring's transaction abstraction is generally application server-agnostic. Additionally,\nSpring's `JtaTransactionManager` class (which can optionally perform a JNDI lookup for\nthe JTA `UserTransaction` and `TransactionManager` objects) autodetects the location for\nthe latter object, which varies by application server. Having access to the JTA\n`TransactionManager` allows for enhanced transaction semantics -- in particular,\nsupporting transaction suspension. See the\n{spring-framework-api}/transaction/jta/JtaTransactionManager.html[`JtaTransactionManager`]\njavadoc for details.\n\nSpring's `JtaTransactionManager` is the standard choice to run on Jakarta EE application\nservers and is known to work on all common servers. Advanced functionality, such as\ntransaction suspension, works on many servers as well (including GlassFish, JBoss and\nGeronimo) without any special configuration required.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/application-server-integration.adoc", "title": "application-server-integration", "heading": "application-server-integration", "heading_level": 1, "file_order": 131, "section_index": 0, "content_hash": "1c31ca56a9b1c16ac9e82ee14007a42923299a7cebc4420e78f7d604bb9c58ee", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/application-server-integration.adoc"}}
{"id": "sha256:cb7c37324d5016b42d34da0b3c31239a64a2288f49173d062597bd7c04b979a5", "content": "[[transaction-declarative]]\n\nNOTE: Most Spring Framework users choose declarative transaction management. This option has\nthe least impact on application code and, hence, is most consistent with the ideals of a\nnon-invasive lightweight container.\n\nThe Spring Framework's declarative transaction management is made possible with Spring\naspect-oriented programming (AOP). However, as the transactional aspects code comes\nwith the Spring Framework distribution and may be used in a boilerplate fashion, AOP\nconcepts do not generally have to be understood to make effective use of this code.\n\nThe Spring Framework's declarative transaction management is similar to EJB CMT, in that\nyou can specify transaction behavior (or lack of it) down to the individual method level.\nYou can make a `setRollbackOnly()` call within a transaction context, if\nnecessary. The differences between the two types of transaction management are:\n\n* Unlike EJB CMT, which is tied to JTA, the Spring Framework's declarative transaction\n management works in any environment. It can work with JTA transactions or local\n transactions by using JDBC, JPA, or Hibernate by adjusting the configuration\n files.\n* You can apply the Spring Framework declarative transaction management to any class,\n not merely special classes such as EJBs.\n* The Spring Framework offers declarative\n xref:data-access/transaction/declarative/rolling-back.adoc[rollback rules], a feature with no EJB\n equivalent. Both programmatic and declarative support for rollback rules is provided.\n* The Spring Framework lets you customize transactional behavior by using AOP.\n For example, you can insert custom behavior in the case of transaction rollback. You\n can also add arbitrary advice, along with transactional advice. With EJB CMT, you\n cannot influence the container's transaction management, except with\n `setRollbackOnly()`.\n* The Spring Framework does not support propagation of transaction contexts across\n remote calls, as high-end application servers do. If you need this feature, we\n recommend that you use EJB. However, consider carefully before using such a feature,\n because, normally, one does not want transactions to span remote calls.\n\nThe concept of rollback rules is important. They let you specify which exceptions\n(and throwables) should cause automatic rollback. You can specify this declaratively, in\nconfiguration, not in Java code. So, although you can still call `setRollbackOnly()` on\nthe `TransactionStatus` object to roll back the current transaction back, most often you\ncan specify a rule that `MyApplicationException` must always result in rollback. The\nsignificant advantage to this option is that business objects do not depend on the\ntransaction infrastructure. For example, they typically do not need to import Spring\ntransaction APIs or other Spring APIs.\n\nAlthough EJB container default behavior automatically rolls back the transaction on a\nsystem exception (usually a runtime exception), EJB CMT does not roll back the\ntransaction automatically on an application exception (that is, a checked exception\nother than `java.rmi.RemoteException`). While the Spring default behavior for\ndeclarative transaction management follows EJB convention (roll back is automatic only\non unchecked exceptions), it is often useful to customize this behavior.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/declarative.adoc", "title": "declarative", "heading": "declarative", "heading_level": 1, "file_order": 132, "section_index": 0, "content_hash": "cb7c37324d5016b42d34da0b3c31239a64a2288f49173d062597bd7c04b979a5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/declarative.adoc"}}
{"id": "sha256:0f7d300873bfaef9b100e89c05f41a716367d18d0b2b8b58fda48f77b0946b90", "content": "[[transaction-event]]\n\nAs of Spring 4.2, the listener of an event can be bound to a phase of the transaction.\nThe typical example is to handle the event when the transaction has completed successfully.\nDoing so lets events be used with more flexibility when the outcome of the current\ntransaction actually matters to the listener.\n\nYou can register a regular event listener by using the `@EventListener` annotation.\nIf you need to bind it to the transaction, use `@TransactionalEventListener`.\nWhen you do so, the listener is bound to the commit phase of the transaction by default.\n\nThe next example shows this concept. Assume that a component publishes an order-created\nevent and that we want to define a listener that should only handle that event once the\ntransaction in which it has been published has committed successfully. The following\nexample sets up such an event listener:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tpublic class MyComponent {\n\n @TransactionalEventListener\n public void handleOrderCreatedEvent(CreationEvent<Order> creationEvent) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tclass MyComponent {\n\n @TransactionalEventListener\n fun handleOrderCreatedEvent(creationEvent: CreationEvent<Order>) {\n // ...\n }\n\t}\n----\n======\n\nThe `@TransactionalEventListener` annotation exposes a `phase` attribute that lets you\ncustomize the phase of the transaction to which the listener should be bound.\nThe valid phases are `BEFORE_COMMIT`, `AFTER_COMMIT` (default), `AFTER_ROLLBACK`, as well as\n`AFTER_COMPLETION` which aggregates the transaction completion (be it a commit or a rollback).\n\nIf no transaction is running, the listener is not invoked at all, since we cannot honor the\nrequired semantics. You can, however, override that behavior by setting the `fallbackExecution`\nattribute of the annotation to `true`.\n\n[NOTE]\n====\nAs of 6.1, `@TransactionalEventListener` can work with thread-bound transactions managed by\n`PlatformTransactionManager` as well as reactive transactions managed by `ReactiveTransactionManager`.\nFor the former, listeners are guaranteed to see the current thread-bound transaction.\nSince the latter uses the Reactor context instead of thread-local variables, the transaction\ncontext needs to be included in the published event instance as the event source.\nSee the\n{spring-framework-api}/transaction/reactive/TransactionalEventPublisher.html[`TransactionalEventPublisher`]\njavadoc for details.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/event.adoc", "title": "event", "heading": "event", "heading_level": 1, "file_order": 133, "section_index": 0, "content_hash": "0f7d300873bfaef9b100e89c05f41a716367d18d0b2b8b58fda48f77b0946b90", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/event.adoc"}}
{"id": "sha256:b914f43f38dea5cca774b4ec68c1a2bcf4188e9fe0e89335998017c24001be7f", "content": "[[transaction-motivation]]\n\nTraditionally, EE application developers have had two choices for transaction management:\nglobal or local transactions, both of which have profound limitations. Global\nand local transaction management is reviewed in the next two sections, followed by a\ndiscussion of how the Spring Framework's transaction management support addresses the\nlimitations of the global and local transaction models.\n\n[[transaction-global]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/motivation.adoc", "title": "motivation", "heading": "motivation", "heading_level": 1, "file_order": 134, "section_index": 0, "content_hash": "b914f43f38dea5cca774b4ec68c1a2bcf4188e9fe0e89335998017c24001be7f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/motivation.adoc"}}
{"id": "sha256:c10401155c2431ce5dbccb511d8db1035c05ad4d53b8f13fe1007a32199c383e", "content": "Global transactions let you work with multiple transactional resources, typically\nrelational databases and message queues. The application server manages global\ntransactions through the JTA, which is a cumbersome API (partly due to its\nexception model). Furthermore, a JTA `UserTransaction` normally needs to be sourced from\nJNDI, meaning that you also need to use JNDI in order to use JTA. The use\nof global transactions limits any potential reuse of application code, as JTA is\nnormally only available in an application server environment.\n\nPreviously, the preferred way to use global transactions was through EJB CMT\n(Container Managed Transaction). CMT is a form of declarative transaction\nmanagement (as distinguished from programmatic transaction management). EJB CMT\nremoves the need for transaction-related JNDI lookups, although the use of EJB\nitself necessitates the use of JNDI. It removes most but not all of the need to write\nJava code to control transactions. The significant downside is that CMT is tied to JTA\nand an application server environment. Also, it is only available if one chooses to\nimplement business logic in EJBs (or at least behind a transactional EJB facade). The\nnegatives of EJB in general are so great that this is not an attractive proposition,\nespecially in the face of compelling alternatives for declarative transaction management.\n\n[[transaction-local]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/motivation.adoc", "title": "motivation", "heading": "Global Transactions", "heading_level": 2, "file_order": 134, "section_index": 1, "content_hash": "c10401155c2431ce5dbccb511d8db1035c05ad4d53b8f13fe1007a32199c383e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/motivation.adoc"}}
{"id": "sha256:350c8562d9be5b9827d7396894e9348bbc53875dc627b2c8bbdb5f5dd224cbb5", "content": "Local transactions are resource-specific, such as a transaction associated with a JDBC\nconnection. Local transactions may be easier to use but have a significant disadvantage:\nThey cannot work across multiple transactional resources. For example, code that manages\ntransactions by using a JDBC connection cannot run within a global JTA transaction. Because\nthe application server is not involved in transaction management, it cannot help ensure\ncorrectness across multiple resources. (It is worth noting that most applications use a\nsingle transaction resource.) Another downside is that local transactions are invasive\nto the programming model.\n\n[[transaction-programming-model]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/motivation.adoc", "title": "motivation", "heading": "Local Transactions", "heading_level": 2, "file_order": 134, "section_index": 2, "content_hash": "350c8562d9be5b9827d7396894e9348bbc53875dc627b2c8bbdb5f5dd224cbb5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/motivation.adoc"}}
{"id": "sha256:0e3cabccff1983e69e8fa9351d31c49f7c55e174e3b3875c410a414df804c165", "content": "Spring resolves the disadvantages of global and local transactions. It lets\napplication developers use a consistent programming model in any environment.\nYou write your code once, and it can benefit from different transaction management\nstrategies in different environments. The Spring Framework provides both declarative and\nprogrammatic transaction management. Most users prefer declarative transaction\nmanagement, which we recommend in most cases.\n\nWith programmatic transaction management, developers work with the Spring Framework\ntransaction abstraction, which can run over any underlying transaction infrastructure.\nWith the preferred declarative model, developers typically write little or no code\nrelated to transaction management and, hence, do not depend on the Spring Framework\ntransaction API or any other transaction API.\n\n.Do you need an application server for transaction management?\n****\nThe Spring Framework's transaction management support changes traditional rules as to\nwhen an enterprise Java application requires an application server.\n\nIn particular, you do not need an application server purely for declarative transactions\nthrough EJBs. In fact, even if your application server has powerful JTA capabilities,\nyou may decide that the Spring Framework's declarative transactions offer more power and\na more productive programming model than EJB CMT.\n\nTypically, you need an application server's JTA capability only if your application needs\nto handle transactions across multiple resources, which is not a requirement for many\napplications. Many high-end applications use a single, highly scalable database (such as\nOracle RAC) instead. Stand-alone transaction managers (such as\nhttps://www.atomikos.com/[Atomikos Transactions])\nare other options. Of course, you may need other application server capabilities, such as\nJava Message Service (JMS) and Jakarta EE Connector Architecture (JCA).\n\nThe Spring Framework gives you the choice of when to scale your application to a fully\nloaded application server. Gone are the days when the only alternative to using EJB\nCMT or JTA was to write code with local transactions (such as those on JDBC connections)\nand face a hefty rework if you need that code to run within global, container-managed\ntransactions. With the Spring Framework, only some of the bean definitions in your\nconfiguration file need to change (rather than your code).\n****", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/motivation.adoc", "title": "motivation", "heading": "Spring Framework's Consistent Programming Model", "heading_level": 2, "file_order": 134, "section_index": 3, "content_hash": "0e3cabccff1983e69e8fa9351d31c49f7c55e174e3b3875c410a414df804c165", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/motivation.adoc"}}
{"id": "sha256:16c19704004e71465aa8816487462abe8afbca7be9d6f9cd881be10be14ca32d", "content": "[[transaction-programmatic]]\n\nThe Spring Framework provides two means of programmatic transaction management, by using:\n\n* The `TransactionTemplate` or `TransactionalOperator`.\n* A `TransactionManager` implementation directly.\n\nThe Spring team generally recommends the `TransactionTemplate` for programmatic\ntransaction management in imperative flows and `TransactionalOperator` for reactive code.\nThe second approach is similar to using the JTA `UserTransaction` API, although exception\nhandling is less cumbersome.\n\n[[tx-prog-template]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc", "title": "programmatic", "heading": "programmatic", "heading_level": 1, "file_order": 135, "section_index": 0, "content_hash": "16c19704004e71465aa8816487462abe8afbca7be9d6f9cd881be10be14ca32d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc"}}
{"id": "sha256:2061a559270529f628a8d66bc30cde388f1d9c86d86613fe93217eeb9ccb2454", "content": "The `TransactionTemplate` adopts the same approach as other Spring templates, such as\nthe `JdbcTemplate`. It uses a callback approach (to free application code from having to\ndo the boilerplate acquisition and release transactional resources) and results in\ncode that is intention driven, in that your code focuses solely on what\nyou want to do.\n\nNOTE: As the examples that follow show, using the `TransactionTemplate` absolutely\ncouples you to Spring's transaction infrastructure and APIs. Whether or not programmatic\ntransaction management is suitable for your development needs is a decision that you\nhave to make yourself.\n\nApplication code that must run in a transactional context and that explicitly uses the\n`TransactionTemplate` resembles the next example. You, as an application\ndeveloper, can write a `TransactionCallback` implementation (typically expressed as an\nanonymous inner class) that contains the code that you need to run in the context of\na transaction. You can then pass an instance of your custom `TransactionCallback` to the\n`execute(..)` method exposed on the `TransactionTemplate`. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SimpleService implements Service {\n\n // single TransactionTemplate shared amongst all methods in this instance\n private final TransactionTemplate transactionTemplate;\n\n // use constructor-injection to supply the PlatformTransactionManager\n public SimpleService(PlatformTransactionManager transactionManager) {\n this.transactionTemplate = new TransactionTemplate(transactionManager);\n }\n\n public Object someServiceMethod() {\n return transactionTemplate.execute(new TransactionCallback() {\n // the code in this method runs in a transactional context\n public Object doInTransaction(TransactionStatus status) {\n updateOperation1();\n return resultOfUpdateOperation2();\n }\n });\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// use constructor-injection to supply the PlatformTransactionManager\n\tclass SimpleService(transactionManager: PlatformTransactionManager) : Service {\n\n // single TransactionTemplate shared amongst all methods in this instance\n private val transactionTemplate = TransactionTemplate(transactionManager)\n\n fun someServiceMethod() = transactionTemplate.execute<Any?> {\n updateOperation1()\n resultOfUpdateOperation2()\n }\n\t}\n----\n======\n\nIf there is no return value, you can use the convenient `TransactionCallbackWithoutResult` class\nwith an anonymous class, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\ttransactionTemplate.execute(new TransactionCallbackWithoutResult() {\n protected void doInTransactionWithoutResult(TransactionStatus status) {\n updateOperation1();\n updateOperation2();\n }\n\t});\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\ttransactionTemplate.execute(object : TransactionCallbackWithoutResult() {\n override fun doInTransactionWithoutResult(status: TransactionStatus) {\n updateOperation1()\n updateOperation2()\n }\n\t})\n----\n======\n\nCode within the callback can roll the transaction back by calling the\n`setRollbackOnly()` method on the supplied `TransactionStatus` object, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\ttransactionTemplate.execute(new TransactionCallbackWithoutResult() {\n\n protected void doInTransactionWithoutResult(TransactionStatus status) {\n try {\n updateOperation1();\n updateOperation2();\n } catch (SomeBusinessException ex) {\n status.setRollbackOnly();\n }\n }\n\t});\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\ttransactionTemplate.execute(object : TransactionCallbackWithoutResult() {\n\n override fun doInTransactionWithoutResult(status: TransactionStatus) {\n try {\n updateOperation1()\n updateOperation2()\n } catch (ex: SomeBusinessException) {\n status.setRollbackOnly()\n }\n }\n\t})\n----\n======\n\n[[tx-prog-template-settings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc", "title": "programmatic", "heading": "Using the `TransactionTemplate`", "heading_level": 2, "file_order": 135, "section_index": 1, "content_hash": "2061a559270529f628a8d66bc30cde388f1d9c86d86613fe93217eeb9ccb2454", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc"}}
{"id": "sha256:e4eba5b9b820cdecff075df9f251ce8a4955c2e3b25c0de0b5f64603d909b12f", "content": "You can specify transaction settings (such as the propagation mode, the isolation level,\nthe timeout, and so forth) on the `TransactionTemplate` either programmatically or in\nconfiguration. By default, `TransactionTemplate` instances have the\nxref:data-access/transaction/declarative/txadvice-settings.adoc[default transactional settings]. The\nfollowing example shows the programmatic customization of the transactional settings for\na specific `TransactionTemplate:`\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SimpleService implements Service {\n\n private final TransactionTemplate transactionTemplate;\n\n public SimpleService(PlatformTransactionManager transactionManager) {\n this.transactionTemplate = new TransactionTemplate(transactionManager);\n\n // the transaction settings can be set here explicitly if so desired\n this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);\n this.transactionTemplate.setTimeout(30); // 30 seconds\n // and so forth...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass SimpleService(transactionManager: PlatformTransactionManager) : Service {\n\n private val transactionTemplate = TransactionTemplate(transactionManager).apply {\n // the transaction settings can be set here explicitly if so desired\n isolationLevel = TransactionDefinition.ISOLATION_READ_UNCOMMITTED\n timeout = 30 // 30 seconds\n // and so forth...\n }\n\t}\n----\n======\n\nThe following example defines a `TransactionTemplate` with some custom transactional\nsettings by using Spring XML configuration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"sharedTransactionTemplate\"\n class=\"org.springframework.transaction.support.TransactionTemplate\">\n <property name=\"isolationLevelName\" value=\"ISOLATION_READ_UNCOMMITTED\"/>\n <property name=\"timeout\" value=\"30\"/>\n\t</bean>\n----\n\nYou can then inject the `sharedTransactionTemplate`\ninto as many services as are required.\n\nFinally, instances of the `TransactionTemplate` class are thread-safe, in that instances\ndo not maintain any conversational state. `TransactionTemplate` instances do, however,\nmaintain configuration state. So, while a number of classes may share a single instance\nof a `TransactionTemplate`, if a class needs to use a `TransactionTemplate` with\ndifferent settings (for example, a different isolation level), you need to create\ntwo distinct `TransactionTemplate` instances.\n\n[[tx-prog-operator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc", "title": "programmatic", "heading": "Specifying Transaction Settings", "heading_level": 3, "file_order": 135, "section_index": 2, "content_hash": "e4eba5b9b820cdecff075df9f251ce8a4955c2e3b25c0de0b5f64603d909b12f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc"}}
{"id": "sha256:2afcab6ec655e7e6d99aeff3965d64d7a7acb030e8f33c340dd646d99dc51c56", "content": "The `TransactionalOperator` follows an operator design that is similar to other reactive\noperators. It uses a callback approach (to free application code from having to do the\nboilerplate acquisition and release transactional resources) and results in code that is\nintention driven, in that your code focuses solely on what you want to do.\n\nNOTE: As the examples that follow show, using the `TransactionalOperator` absolutely\ncouples you to Spring's transaction infrastructure and APIs. Whether or not programmatic\ntransaction management is suitable for your development needs is a decision that you have\nto make yourself.\n\nApplication code that must run in a transactional context and that explicitly uses\nthe `TransactionalOperator` resembles the next example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SimpleService implements Service {\n\n // single TransactionalOperator shared amongst all methods in this instance\n private final TransactionalOperator transactionalOperator;\n\n // use constructor-injection to supply the ReactiveTransactionManager\n public SimpleService(ReactiveTransactionManager transactionManager) {\n this.transactionalOperator = TransactionalOperator.create(transactionManager);\n }\n\n public Mono<Object> someServiceMethod() {\n\n // the code in this method runs in a transactional context\n\n Mono<Object> update = updateOperation1();\n\n return update.then(resultOfUpdateOperation2).as(transactionalOperator::transactional);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// use constructor-injection to supply the ReactiveTransactionManager\n\tclass SimpleService(transactionManager: ReactiveTransactionManager) : Service {\n\n // single TransactionalOperator shared amongst all methods in this instance\n private val transactionalOperator = TransactionalOperator.create(transactionManager)\n\n suspend fun someServiceMethod() = transactionalOperator.executeAndAwait<Any?> {\n updateOperation1()\n resultOfUpdateOperation2()\n }\n\t}\n----\n======\n\n`TransactionalOperator` can be used in two ways:\n\n* Operator-style using Project Reactor types (`mono.as(transactionalOperator::transactional)`)\n* Callback-style for every other case (`transactionalOperator.execute(TransactionCallback<T>)`)\n\nCode within the callback can roll the transaction back by calling the `setRollbackOnly()`\nmethod on the supplied `ReactiveTransaction` object, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\ttransactionalOperator.execute(new TransactionCallback<>() {\n\n public Mono<Object> doInTransaction(ReactiveTransaction status) {\n return updateOperation1().then(updateOperation2)\n .doOnError(SomeBusinessException.class, e -> status.setRollbackOnly());\n }\n }\n\t});\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\ttransactionalOperator.execute(object : TransactionCallback() {\n\n override fun doInTransactionWithoutResult(status: ReactiveTransaction) {\n updateOperation1().then(updateOperation2)\n .doOnError(SomeBusinessException.class, e -> status.setRollbackOnly())\n }\n\t})\n----\n======\n\n[[tx-prog-operator-cancel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc", "title": "programmatic", "heading": "Using the `TransactionalOperator`", "heading_level": 2, "file_order": 135, "section_index": 3, "content_hash": "2afcab6ec655e7e6d99aeff3965d64d7a7acb030e8f33c340dd646d99dc51c56", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc"}}
{"id": "sha256:294daa0833bb9fc4c4d4a7758dea918ca90e1c34d0d01afafa760928da11b446", "content": "In Reactive Streams, a `Subscriber` can cancel its `Subscription` and stop its\n`Publisher`. Operators in Project Reactor, as well as in other libraries, such as `next()`,\n`take(long)`, `timeout(Duration)`, and others can issue cancellations. There is no way to\nknow the reason for the cancellation, whether it is due to an error or a simply lack of\ninterest to consume further. Since version 5.3 cancel signals lead to a roll back.\nAs a result it is important to consider the operators used downstream from a transaction\n`Publisher`. In particular in the case of a `Flux` or other multi-value `Publisher`,\nthe full output must be consumed to allow the transaction to complete.\n\n[[tx-prog-operator-settings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc", "title": "programmatic", "heading": "Cancel Signals", "heading_level": 3, "file_order": 135, "section_index": 4, "content_hash": "294daa0833bb9fc4c4d4a7758dea918ca90e1c34d0d01afafa760928da11b446", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc"}}
{"id": "sha256:915c9944b02f233d4de1c2d9dd6014c5478284c3a71943a7792e85241e7c9fd8", "content": "You can specify transaction settings (such as the propagation mode, the isolation level,\nthe timeout, and so forth) for the `TransactionalOperator`. By default,\n`TransactionalOperator` instances have\nxref:data-access/transaction/declarative/txadvice-settings.adoc[default transactional settings]. The\nfollowing example shows customization of the transactional settings for a specific\n`TransactionalOperator:`\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SimpleService implements Service {\n\n private final TransactionalOperator transactionalOperator;\n\n public SimpleService(ReactiveTransactionManager transactionManager) {\n DefaultTransactionDefinition definition = new DefaultTransactionDefinition();\n\n // the transaction settings can be set here explicitly if so desired\n definition.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);\n definition.setTimeout(30); // 30 seconds\n // and so forth...\n\n this.transactionalOperator = TransactionalOperator.create(transactionManager, definition);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass SimpleService(transactionManager: ReactiveTransactionManager) : Service {\n\n private val definition = DefaultTransactionDefinition().apply {\n // the transaction settings can be set here explicitly if so desired\n isolationLevel = TransactionDefinition.ISOLATION_READ_UNCOMMITTED\n timeout = 30 // 30 seconds\n // and so forth...\n }\n private val transactionalOperator = TransactionalOperator(transactionManager, definition)\n\t}\n----\n======\n\n[[transaction-programmatic-tm]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc", "title": "programmatic", "heading": "Specifying Transaction Settings", "heading_level": 3, "file_order": 135, "section_index": 5, "content_hash": "915c9944b02f233d4de1c2d9dd6014c5478284c3a71943a7792e85241e7c9fd8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc"}}
{"id": "sha256:2522d674919977cf07e8ed76373295857cc4471203d864c324233333cf30a19e", "content": "The following sections explain programmatic usage of imperative and reactive transaction\nmanagers.\n\n[[transaction-programmatic-ptm]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc", "title": "programmatic", "heading": "Using the `TransactionManager`", "heading_level": 2, "file_order": 135, "section_index": 6, "content_hash": "2522d674919977cf07e8ed76373295857cc4471203d864c324233333cf30a19e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc"}}
{"id": "sha256:1175f36c7d6f1f44398cbcf3a57494b48056b1316d6306efa82214efa1cfac79", "content": "For imperative transactions, you can use a\n`org.springframework.transaction.PlatformTransactionManager` directly to manage your\ntransaction. To do so, pass the implementation of the `PlatformTransactionManager` you\nuse to your bean through a bean reference. Then, by using the `TransactionDefinition` and\n`TransactionStatus` objects, you can initiate transactions, roll back, and commit. The\nfollowing example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tDefaultTransactionDefinition def = new DefaultTransactionDefinition();\n\t// explicitly setting the transaction name is something that can be done only programmatically\n\tdef.setName(\"SomeTxName\");\n\tdef.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n\n\tTransactionStatus status = txManager.getTransaction(def);\n\ttry {\n // put your business logic here\n\t} catch (MyException ex) {\n txManager.rollback(status);\n throw ex;\n\t}\n\ttxManager.commit(status);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval def = DefaultTransactionDefinition()\n\t// explicitly setting the transaction name is something that can be done only programmatically\n\tdef.setName(\"SomeTxName\")\n\tdef.propagationBehavior = TransactionDefinition.PROPAGATION_REQUIRED\n\n\tval status = txManager.getTransaction(def)\n\ttry {\n // put your business logic here\n\t} catch (ex: MyException) {\n txManager.rollback(status)\n throw ex\n\t}\n\n\ttxManager.commit(status)\n----\n======\n\n[[transaction-programmatic-rtm]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc", "title": "programmatic", "heading": "Using the `PlatformTransactionManager`", "heading_level": 3, "file_order": 135, "section_index": 7, "content_hash": "1175f36c7d6f1f44398cbcf3a57494b48056b1316d6306efa82214efa1cfac79", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc"}}
{"id": "sha256:e621851ed63dffc1a8375d1a7b2ddb6a933cc387cb3261e073109a83cbe34553", "content": "When working with reactive transactions, you can use a\n`org.springframework.transaction.ReactiveTransactionManager` directly to manage your\ntransaction. To do so, pass the implementation of the `ReactiveTransactionManager` you\nuse to your bean through a bean reference. Then, by using the `TransactionDefinition` and\n`ReactiveTransaction` objects, you can initiate transactions, roll back, and commit. The\nfollowing example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tDefaultTransactionDefinition def = new DefaultTransactionDefinition();\n\t// explicitly setting the transaction name is something that can be done only programmatically\n\tdef.setName(\"SomeTxName\");\n\tdef.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n\n\tMono<ReactiveTransaction> reactiveTx = txManager.getReactiveTransaction(def);\n\n\treactiveTx.flatMap(status -> {\n\n Mono<Object> tx = ...; // put your business logic here\n\n return tx.then(txManager.commit(status))\n .onErrorResume(ex -> txManager.rollback(status).then(Mono.error(ex)));\n\t});\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval def = DefaultTransactionDefinition()\n\t// explicitly setting the transaction name is something that can be done only programmatically\n\tdef.setName(\"SomeTxName\")\n\tdef.propagationBehavior = TransactionDefinition.PROPAGATION_REQUIRED\n\n\tval reactiveTx = txManager.getReactiveTransaction(def)\n\treactiveTx.flatMap { status ->\n\n val tx = ... // put your business logic here\n\n tx.then(txManager.commit(status))\n .onErrorResume { ex -> txManager.rollback(status).then(Mono.error(ex)) }\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc", "title": "programmatic", "heading": "Using the `ReactiveTransactionManager`", "heading_level": 3, "file_order": 135, "section_index": 8, "content_hash": "e621851ed63dffc1a8375d1a7b2ddb6a933cc387cb3261e073109a83cbe34553", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/programmatic.adoc"}}
{"id": "sha256:b8a06fb6206237f152b68681b371a2ed2cbd58b5b208382b1dc45d1c40faa423", "content": "[[transaction-resources]]\n\nFor more information about the Spring Framework's transaction support, see:\n\n* link:++https://www.infoworld.com/article/2077963/distributed-transactions-in-spring--with-and-without-xa.html++[\n Distributed transactions in Spring, with and without XA] is a JavaWorld presentation in\n which Spring's David Syer guides you through seven patterns for distributed transactions\n in Spring applications, three of them with XA and four without.\n* https://www.infoq.com/minibooks/JTDS[_Java Transaction Design Strategies_] is a book\n available from https://www.infoq.com/[InfoQ] that provides a well-paced introduction\n to transactions in Java. It also includes side-by-side examples of how to configure\n and use transactions with both the Spring Framework and EJB3.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/resources.adoc", "title": "resources", "heading": "resources", "heading_level": 1, "file_order": 136, "section_index": 0, "content_hash": "b8a06fb6206237f152b68681b371a2ed2cbd58b5b208382b1dc45d1c40faa423", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/resources.adoc"}}
{"id": "sha256:e8aed96fc6cddb023e4de9ceb07f00b2c75d240a5694ef02a368ca0687264d8a", "content": "[[transaction-solutions-to-common-problems]]\n\nThis section describes solutions to some common problems.\n\n[[transaction-solutions-to-common-problems-wrong-ptm]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/solutions-to-common-problems.adoc", "title": "solutions-to-common-problems", "heading": "solutions-to-common-problems", "heading_level": 1, "file_order": 137, "section_index": 0, "content_hash": "e8aed96fc6cddb023e4de9ceb07f00b2c75d240a5694ef02a368ca0687264d8a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/solutions-to-common-problems.adoc"}}
{"id": "sha256:35838fb7d44775324f4f8b0f70c443abc496222db996bbf170c885be387005b0", "content": "Use the correct `PlatformTransactionManager` implementation based on your choice of\ntransactional technologies and requirements. Used properly, the Spring Framework merely\nprovides a straightforward and portable abstraction. If you use global\ntransactions, you must use the\n`org.springframework.transaction.jta.JtaTransactionManager` class (or an\nxref:data-access/transaction/application-server-integration.adoc[application server-specific subclass] of\nit) for all your transactional operations. Otherwise, the transaction infrastructure\ntries to perform local transactions on such resources as container `DataSource`\ninstances. Such local transactions do not make sense, and a good application server\ntreats them as errors.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/solutions-to-common-problems.adoc", "title": "solutions-to-common-problems", "heading": "Using the Wrong Transaction Manager for a Specific `DataSource`", "heading_level": 2, "file_order": 137, "section_index": 1, "content_hash": "35838fb7d44775324f4f8b0f70c443abc496222db996bbf170c885be387005b0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/solutions-to-common-problems.adoc"}}
{"id": "sha256:8615d81923fed2f22ab73fe7ff25c9051e40d1470da8d604003c305b05267069", "content": "[[transaction-strategies]]\n\nThe key to the Spring transaction abstraction is the notion of a transaction strategy. A\ntransaction strategy is defined by a `TransactionManager`, specifically the\n`org.springframework.transaction.PlatformTransactionManager` interface for imperative\ntransaction management and the\n`org.springframework.transaction.ReactiveTransactionManager` interface for reactive\ntransaction management. The following listing shows the definition of the\n`PlatformTransactionManager` API:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface PlatformTransactionManager extends TransactionManager {\n\n TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;\n\n void commit(TransactionStatus status) throws TransactionException;\n\n void rollback(TransactionStatus status) throws TransactionException;\n\t}\n----\n\nThis is primarily a service provider interface (SPI), although you can use it\nxref:data-access/transaction/programmatic.adoc#transaction-programmatic-ptm[programmatically] from your application code. Because\n`PlatformTransactionManager` is an interface, it can be easily mocked or stubbed as\nnecessary. It is not tied to a lookup strategy, such as JNDI.\n`PlatformTransactionManager` implementations are defined like any other object (or bean)\nin the Spring Framework IoC container. This benefit alone makes Spring Framework\ntransactions a worthwhile abstraction, even when you work with JTA. You can test\ntransactional code much more easily than if it used JTA directly.\n\nAgain, in keeping with Spring's philosophy, the `TransactionException` that can be thrown\nby any of the `PlatformTransactionManager` interface's methods is unchecked (that\nis, it extends the `java.lang.RuntimeException` class). Transaction infrastructure\nfailures are almost invariably fatal. In rare cases where application code can actually\nrecover from a transaction failure, the application developer can still choose to catch\nand handle `TransactionException`. The salient point is that developers are not\n_forced_ to do so.\n\nThe `getTransaction(..)` method returns a `TransactionStatus` object, depending on a\n`TransactionDefinition` parameter. The returned `TransactionStatus` might represent a\nnew transaction or can represent an existing transaction, if a matching transaction\nexists in the current call stack. The implication in this latter case is that, as with\nJakarta EE transaction contexts, a `TransactionStatus` is associated with a thread of\nexecution.\n\nSpring also provides a transaction management abstraction for reactive applications that\nmake use of reactive types or Kotlin Coroutines. The following listing shows the\ntransaction strategy defined by\n`org.springframework.transaction.ReactiveTransactionManager`:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface ReactiveTransactionManager extends TransactionManager {\n\n Mono<ReactiveTransaction> getReactiveTransaction(TransactionDefinition definition) throws TransactionException;\n\n Mono<Void> commit(ReactiveTransaction status) throws TransactionException;\n\n Mono<Void> rollback(ReactiveTransaction status) throws TransactionException;\n\t}\n----\n\nThe reactive transaction manager is primarily a service provider interface (SPI),\nalthough you can use it xref:data-access/transaction/programmatic.adoc#transaction-programmatic-rtm[programmatically] from your\napplication code. Because `ReactiveTransactionManager` is an interface, it can be easily\nmocked or stubbed as necessary.\n\nThe `TransactionDefinition` interface specifies:\n\n* Propagation: Typically, all code within a transaction scope runs in\n that transaction. However, you can specify the behavior if\n a transactional method is run when a transaction context already exists. For\n example, code can continue running in the existing transaction (the common case), or\n the existing transaction can be suspended and a new transaction created. Spring\n offers all of the transaction propagation options familiar from EJB CMT. To read\n about the semantics of transaction propagation in Spring, see xref:data-access/transaction/declarative/tx-propagation.adoc[Transaction Propagation].\n* Isolation: The degree to which this transaction is isolated from the work of other\n transactions. For example, can this transaction see uncommitted writes from other\n transactions?\n* Timeout: How long this transaction runs before timing out and being automatically rolled back\n by the underlying transaction infrastructure.\n* Read-only status: You can use a read-only transaction when your code reads but\n does not modify data. Read-only transactions can be a useful optimization in some\n cases, such as when you use Hibernate.\n\nThese settings reflect standard transactional concepts. If necessary, refer to resources\nthat discuss transaction isolation levels and other core transaction concepts.\nUnderstanding these concepts is essential to using the Spring Framework or any\ntransaction management solution.\n\nThe `TransactionStatus` interface provides a simple way for transactional code to\ncontrol transaction execution and query transaction status. The concepts should be\nfamiliar, as they are common to all transaction APIs. The following listing shows the\n`TransactionStatus` interface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable {\n\n @Override\n boolean isNewTransaction();\n\n boolean hasSavepoint();\n\n @Override\n void setRollbackOnly();\n\n @Override\n boolean isRollbackOnly();\n\n void flush();\n\n @Override\n boolean isCompleted();\n\t}\n----\n\nRegardless of whether you opt for declarative or programmatic transaction management in\nSpring, defining the correct `TransactionManager` implementation is absolutely essential.\nYou typically define this implementation through dependency injection.\n\n`TransactionManager` implementations normally require knowledge of the environment in\nwhich they work: JDBC, JTA, Hibernate, and so on. The following examples show how you can\ndefine a local `PlatformTransactionManager` implementation (in this case, with plain\nJDBC.)\n\nYou can define a JDBC `DataSource` by creating a bean similar to the following:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\" />\n <property name=\"url\" value=\"${jdbc.url}\" />\n <property name=\"username\" value=\"${jdbc.username}\" />\n <property name=\"password\" value=\"${jdbc.password}\" />\n\t</bean>\n----\n\nThe related `PlatformTransactionManager` bean definition then has a reference to the\n`DataSource` definition. It should resemble the following example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n <property name=\"dataSource\" ref=\"dataSource\"/>\n\t</bean>\n----\n\nIf you use JTA in a Jakarta EE container, then you use a container `DataSource`, obtained\nthrough JNDI, in conjunction with Spring's `JtaTransactionManager`. The following example\nshows what the JTA and JNDI lookup version would look like:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:jee=\"http://www.springframework.org/schema/jee\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/jee\n https://www.springframework.org/schema/jee/spring-jee.xsd\">\n\n <jee:jndi-lookup id=\"dataSource\" jndi-name=\"jdbc/jpetstore\"/>\n\n <bean id=\"txManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\" />\n\n <!-- other <bean/> definitions here -->\n\n\t</beans>\n----\n\nThe `JtaTransactionManager` does not need to know about the `DataSource` (or any other\nspecific resources) because it uses the container's global transaction management\ninfrastructure.\n\nNOTE: The preceding definition of the `dataSource` bean uses the `<jndi-lookup/>` tag\nfrom the `jee` namespace. For more information see\nxref:integration/appendix.adoc#xsd-schemas-jee[The JEE Schema].\n\nNOTE: If you use JTA, your transaction manager definition should look the same, regardless\nof what data access technology you use, be it JDBC, Hibernate JPA, or any other supported\ntechnology. This is due to the fact that JTA transactions are global transactions, which\ncan enlist any transactional resource.\n\nIn all Spring transaction setups, application code does not need to change. You can change\nhow transactions are managed merely by changing configuration, even if that change means\nmoving from local to global transactions or vice versa.\n\n[[transaction-strategies-hibernate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/strategies.adoc", "title": "strategies", "heading": "strategies", "heading_level": 1, "file_order": 138, "section_index": 0, "content_hash": "8615d81923fed2f22ab73fe7ff25c9051e40d1470da8d604003c305b05267069", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/strategies.adoc"}}
{"id": "sha256:576a7b807aa54ac7b035455ddd06a634c6f89ba51e4256666d2de5e166db9d07", "content": "You can also easily use Hibernate local transactions, as shown in the following examples.\nIn this case, you need to define a Hibernate `LocalSessionFactoryBean`, which your\napplication code can use to obtain Hibernate `Session` instances.\n\nThe `DataSource` bean definition is similar to the local JDBC example shown previously\nand, thus, is not shown in the following example.\n\nNOTE: If the `DataSource` (used by any non-JTA transaction manager) is looked up through\nJNDI and managed by a Jakarta EE container, it should be non-transactional, because the\nSpring Framework (rather than the Jakarta EE container) manages the transactions.\n\nThe `txManager` bean in this case is of the `HibernateTransactionManager` type. In the\nsame way as the `DataSourceTransactionManager` needs a reference to the `DataSource`, the\n`HibernateTransactionManager` needs a reference to the `SessionFactory`. The following\nexample declares `sessionFactory` and `txManager` beans:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"sessionFactory\" class=\"org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean\">\n <property name=\"dataSource\" ref=\"dataSource\"/>\n <property name=\"mappingResources\">\n <list>\n <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>\n </list>\n </property>\n <property name=\"hibernateProperties\">\n <value>\n hibernate.dialect=${hibernate.dialect}\n </value>\n </property>\n\t</bean>\n\n\t<bean id=\"txManager\" class=\"org.springframework.orm.jpa.hibernate.HibernateTransactionManager\">\n <property name=\"sessionFactory\" ref=\"sessionFactory\"/>\n\t</bean>\n----\n\nIf you use Hibernate and Jakarta EE container-managed JTA transactions, you should use the\nsame `JtaTransactionManager` as in the previous JTA example for JDBC, as the following\nexample shows. Also, it is recommended to make Hibernate aware of JTA through its\ntransaction coordinator and possibly also its connection release mode configuration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"sessionFactory\" class=\"org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean\">\n <property name=\"dataSource\" ref=\"dataSource\"/>\n <property name=\"mappingResources\">\n <list>\n <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>\n </list>\n </property>\n <property name=\"hibernateProperties\">\n <value>\n hibernate.dialect=${hibernate.dialect}\n hibernate.transaction.coordinator_class=jta\n hibernate.connection.handling_mode=DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT\n </value>\n </property>\n\t</bean>\n\n\t<bean id=\"txManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\"/>\n----\n\nOr alternatively, you may pass the `JtaTransactionManager` into your `LocalSessionFactoryBean`\nfor enforcing the same defaults:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"sessionFactory\" class=\"org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean\">\n <property name=\"dataSource\" ref=\"dataSource\"/>\n <property name=\"mappingResources\">\n <list>\n <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>\n </list>\n </property>\n <property name=\"hibernateProperties\">\n <value>\n hibernate.dialect=${hibernate.dialect}\n </value>\n </property>\n <property name=\"jtaTransactionManager\" ref=\"txManager\"/>\n\t</bean>\n\n\t<bean id=\"txManager\" class=\"org.springframework.transaction.jta.JtaTransactionManager\"/>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/strategies.adoc", "title": "strategies", "heading": "Hibernate Transaction Setup", "heading_level": 2, "file_order": 138, "section_index": 1, "content_hash": "576a7b807aa54ac7b035455ddd06a634c6f89ba51e4256666d2de5e166db9d07", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/strategies.adoc"}}
{"id": "sha256:574007207082e5f0d747a3ee0179be53e4caf7aa48292f8e4e8c4ae3914f7d48", "content": "[[tx-decl-vs-prog]]\n\nProgrammatic transaction management is usually a good idea only if you have a small\nnumber of transactional operations. For example, if you have a web application that\nrequires transactions only for certain update operations, you may not want to set up\ntransactional proxies by using Spring or any other technology. In this case, using the\n`TransactionTemplate` may be a good approach. Being able to set the transaction name\nexplicitly is also something that can be done only by using the programmatic approach\nto transaction management.\n\nOn the other hand, if your application has numerous transactional operations,\ndeclarative transaction management is usually worthwhile. It keeps transaction\nmanagement out of business logic and is not difficult to configure. When using the\nSpring Framework, rather than EJB CMT, the configuration cost of declarative transaction\nmanagement is greatly reduced.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/tx-decl-vs-prog.adoc", "title": "tx-decl-vs-prog", "heading": "tx-decl-vs-prog", "heading_level": 1, "file_order": 139, "section_index": 0, "content_hash": "574007207082e5f0d747a3ee0179be53e4caf7aa48292f8e4e8c4ae3914f7d48", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/tx-decl-vs-prog.adoc"}}
{"id": "sha256:7e0ea3edd3f61a213bbd0465144b8d8c057dcb22111deec7e1bb8f7833b4a130", "content": "[[tx-resource-synchronization]]\n\nHow to create different transaction managers and how they are linked to related resources\nthat need to be synchronized to transactions (for example `DataSourceTransactionManager`\nto a JDBC `DataSource`, `HibernateTransactionManager` to a Hibernate `SessionFactory`,\nand so forth) should now be clear. This section describes how the application code\n(directly or indirectly, by using a persistence API such as JDBC, Hibernate, or JPA)\nensures that these resources are created, reused, and cleaned up properly. The section\nalso discusses how transaction synchronization is (optionally) triggered through the\nrelevant `TransactionManager`.\n\n[[tx-resource-synchronization-high]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/tx-resource-synchronization.adoc", "title": "tx-resource-synchronization", "heading": "tx-resource-synchronization", "heading_level": 1, "file_order": 140, "section_index": 0, "content_hash": "7e0ea3edd3f61a213bbd0465144b8d8c057dcb22111deec7e1bb8f7833b4a130", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/tx-resource-synchronization.adoc"}}
{"id": "sha256:61357cdaebdb825b69b2202c51fb0d17ab5647555f050d54f9bb6841903e877c", "content": "The preferred approach is to use Spring's highest-level template-based persistence\nintegration APIs or to use native ORM APIs with transaction-aware factory beans or\nproxies for managing the native resource factories. These transaction-aware solutions\ninternally handle resource creation and reuse, cleanup, optional transaction\nsynchronization of the resources, and exception mapping. Thus, user data access code does\nnot have to address these tasks but can focus purely on non-boilerplate\npersistence logic. Generally, you use the native ORM API or take a template approach\nfor JDBC access by using the `JdbcTemplate`. These solutions are detailed in subsequent\nsections of this reference documentation.\n\n[[tx-resource-synchronization-low]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/tx-resource-synchronization.adoc", "title": "tx-resource-synchronization", "heading": "High-level Synchronization Approach", "heading_level": 2, "file_order": 140, "section_index": 1, "content_hash": "61357cdaebdb825b69b2202c51fb0d17ab5647555f050d54f9bb6841903e877c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/tx-resource-synchronization.adoc"}}
{"id": "sha256:20104954367652e1721792307594371fee43fbdf8d57a025fcd01d608aad0929", "content": "Classes such as `DataSourceUtils` (for JDBC), `EntityManagerFactoryUtils` (for JPA),\n`SessionFactoryUtils` (for Hibernate), and so on exist at a lower level. When you want the\napplication code to deal directly with the resource types of the native persistence APIs,\nyou use these classes to ensure that proper Spring Framework-managed instances are obtained,\ntransactions are (optionally) synchronized, and exceptions that occur in the process are\nproperly mapped to a consistent API.\n\nFor example, in the case of JDBC, instead of the traditional JDBC approach of calling\nthe `getConnection()` method on the `DataSource`, you can instead use Spring's\n`org.springframework.jdbc.datasource.DataSourceUtils` class, as follows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tConnection conn = DataSourceUtils.getConnection(dataSource);\n----\n\nIf an existing transaction already has a connection synchronized (linked) to it, that\ninstance is returned. Otherwise, the method call triggers the creation of a new\nconnection, which is (optionally) synchronized to any existing transaction and made\navailable for subsequent reuse in that same transaction. As mentioned earlier, any\n`SQLException` is wrapped in a Spring Framework `CannotGetJdbcConnectionException`, one\nof the Spring Framework's hierarchy of unchecked `DataAccessException` types. This approach\ngives you more information than can be obtained easily from the `SQLException` and\nensures portability across databases and even across different persistence technologies.\n\nThis approach also works without Spring transaction management (transaction\nsynchronization is optional), so you can use it whether or not you use Spring for\ntransaction management.\n\nOf course, once you have used Spring's JDBC support, JPA support, or Hibernate support,\nyou generally prefer not to use `DataSourceUtils` or the other helper classes,\nbecause you are much happier working through the Spring abstraction than directly\nwith the relevant APIs. For example, if you use the Spring `JdbcTemplate` or\n`jdbc.object` package to simplify your use of JDBC, correct connection retrieval occurs\nbehind the scenes and you need not write any special code.\n\n[[tx-resource-synchronization-tadsp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/tx-resource-synchronization.adoc", "title": "tx-resource-synchronization", "heading": "Low-level Synchronization Approach", "heading_level": 2, "file_order": 140, "section_index": 2, "content_hash": "20104954367652e1721792307594371fee43fbdf8d57a025fcd01d608aad0929", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/tx-resource-synchronization.adoc"}}
{"id": "sha256:df79591afc7e0ffc2bc0063aa9e23f97170b96702a96bbc77c23373746eb8853", "content": "At the very lowest level exists the `TransactionAwareDataSourceProxy` class. This is a\nproxy for a target `DataSource`, which wraps the target `DataSource` to add awareness of\nSpring-managed transactions. In this respect, it is similar to a transactional JNDI\n`DataSource`, as provided by a Jakarta EE server.\n\nYou should almost never need or want to use this class, except when existing\ncode must be called and passed a standard JDBC `DataSource` interface implementation. In\nthat case, it is possible that this code is usable but is participating in Spring-managed\ntransactions. You can write your new code by using the higher-level\nabstractions mentioned earlier.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction/tx-resource-synchronization.adoc", "title": "tx-resource-synchronization", "heading": "`TransactionAwareDataSourceProxy`", "heading_level": 2, "file_order": 140, "section_index": 3, "content_hash": "df79591afc7e0ffc2bc0063aa9e23f97170b96702a96bbc77c23373746eb8853", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction/tx-resource-synchronization.adoc"}}
{"id": "sha256:d586d8c6e4dc943fc35f60a5c7e79a9e57cf22fc6540cd48e8d6b3b50511ede9", "content": "[[appendix]]\n\n[[xsd-schemas]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/appendix.adoc", "title": "appendix", "heading": "appendix", "heading_level": 1, "file_order": 141, "section_index": 0, "content_hash": "d586d8c6e4dc943fc35f60a5c7e79a9e57cf22fc6540cd48e8d6b3b50511ede9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/appendix.adoc"}}
{"id": "sha256:5042bc50b4a0307f0018e47b1fd87721088e808aaf458c6c126f78439b346470", "content": "This part of the appendix lists XML schemas for data access, including the following:\n\n* xref:data-access/appendix.adoc#xsd-schemas-tx[The `tx` Schema]\n* xref:data-access/appendix.adoc#xsd-schemas-jdbc[The `jdbc` Schema]\n\n[[xsd-schemas-tx]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/appendix.adoc", "title": "appendix", "heading": "XML Schemas", "heading_level": 2, "file_order": 141, "section_index": 1, "content_hash": "5042bc50b4a0307f0018e47b1fd87721088e808aaf458c6c126f78439b346470", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/appendix.adoc"}}
{"id": "sha256:09a39f73f457f82d7a34a5bd15ab019eeedbd37a28bf28a68fc38cf0642db487", "content": "The `tx` tags deal with configuring all of those beans in Spring's comprehensive support\nfor transactions. These tags are covered in the chapter entitled\nxref:data-access/transaction.adoc[Transaction Management].\n\nTIP: We strongly encourage you to look at the `'spring-tx.xsd'` file that ships with the\nSpring distribution. This file contains the XML Schema for Spring's transaction\nconfiguration and covers all of the various elements in the `tx` namespace, including\nattribute defaults and similar information. This file is documented inline, and, thus,\nthe information is not repeated here in the interests of adhering to the DRY (Don't\nRepeat Yourself) principle.\n\nIn the interest of completeness, to use the elements in the `tx` schema, you need to have\nthe following preamble at the top of your Spring XML configuration file. The text in the\nfollowing snippet references the correct schema so that the tags in the `tx` namespace\nare available to you:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:tx=\"http://www.springframework.org/schema/tx\" <1>\n xmlns:aop=\"http://www.springframework.org/schema/aop\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/tx\n https://www.springframework.org/schema/tx/spring-tx.xsd <2>\n http://www.springframework.org/schema/aop\n https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n <!-- bean definitions here -->\n\n\t</beans>\n----\n<1> Declare usage of the `tx` namespace.\n<2> Specify the location (with other schema locations).\n\nNOTE: Often, when you use the elements in the `tx` namespace, you are also using the\nelements from the `aop` namespace (since the declarative transaction support in Spring is\nimplemented by using AOP). The preceding XML snippet contains the relevant lines needed\nto reference the `aop` schema so that the elements in the `aop` namespace are available\nto you.\n\n[[xsd-schemas-jdbc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/appendix.adoc", "title": "appendix", "heading": "The `tx` Schema", "heading_level": 3, "file_order": 141, "section_index": 2, "content_hash": "09a39f73f457f82d7a34a5bd15ab019eeedbd37a28bf28a68fc38cf0642db487", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/appendix.adoc"}}
{"id": "sha256:24d4914f124a69b5aa58eaf232222260bff12aa5dfe28b9e04c2f570d0903105", "content": "The `jdbc` elements let you quickly configure an embedded database or initialize an\nexisting data source. These elements are documented in\nxref:data-access/jdbc/embedded-database-support.adoc[Embedded Database Support] and\nxref:data-access/jdbc/initializing-datasource.adoc[Initializing a DataSource], respectively.\n\nTo use the elements in the `jdbc` schema, you need to have the following preamble at the\ntop of your Spring XML configuration file. The text in the following snippet references\nthe correct schema so that the elements in the `jdbc` namespace are available to you:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" <1>\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/jdbc\n https://www.springframework.org/schema/jdbc/spring-jdbc.xsd\"> <2>\n\n <!-- bean definitions here -->\n\n\t</beans>\n----\n<1> Declare usage of the `jdbc` namespace.\n<2> Specify the location (with other schema locations).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/appendix.adoc", "title": "appendix", "heading": "The `jdbc` Schema", "heading_level": 3, "file_order": 141, "section_index": 3, "content_hash": "24d4914f124a69b5aa58eaf232222260bff12aa5dfe28b9e04c2f570d0903105", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/appendix.adoc"}}
{"id": "sha256:3cd30d1cc05566e5828df211a6ffeda73638eb563773755b4f5b6c5259266212", "content": "[[dao]]\n\nThe Data Access Object (DAO) support in Spring is aimed at making it easy to work with\ndata access technologies (such as JDBC, Hibernate, or JPA) in a consistent way. This\nlets you switch between the aforementioned persistence technologies fairly easily,\nand it also lets you code without worrying about catching exceptions that are\nspecific to each technology.\n\n[[dao-exceptions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/dao.adoc", "title": "dao", "heading": "dao", "heading_level": 1, "file_order": 142, "section_index": 0, "content_hash": "3cd30d1cc05566e5828df211a6ffeda73638eb563773755b4f5b6c5259266212", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/dao.adoc"}}
{"id": "sha256:73fdfbd1f057b47fdb375fafa7c75ef325d65005a0448b264b004d707780481a", "content": "Spring provides a convenient translation from technology-specific exceptions, such as\n`SQLException` to its own exception class hierarchy, which has `DataAccessException` as\nthe root exception. These exceptions wrap the original exception so that there is never\nany risk that you might lose any information about what might have gone wrong.\n\nIn addition to JDBC exceptions, Spring can also wrap JPA- and Hibernate-specific exceptions,\nconverting them to a set of focused runtime exceptions. This lets you handle most\nnon-recoverable persistence exceptions in only the appropriate layers, without having\nannoying boilerplate catch-and-throw blocks and exception declarations in your DAOs.\n(You can still trap and handle exceptions anywhere you need to though.) As mentioned above,\nJDBC exceptions (including database-specific dialects) are also converted to the same\nhierarchy, meaning that you can perform some operations with JDBC within a consistent\nprogramming model.\n\nThe preceding discussion holds true for the various template classes in Spring's support\nfor various ORM frameworks. If you use the interceptor-based classes, the application must\ncare about handling `HibernateExceptions` and `PersistenceExceptions` itself, preferably by\ndelegating to the `convertHibernateAccessException(..)` or `convertJpaAccessException(..)`\nmethods, respectively, of `SessionFactoryUtils`. These methods convert the exceptions\nto exceptions that are compatible with the exceptions in the `org.springframework.dao`\nexception hierarchy. As `PersistenceExceptions` are unchecked, they can get thrown, too\n(sacrificing generic DAO abstraction in terms of exceptions, though).\n\nThe following image shows the exception hierarchy that Spring provides.\n(Note that the class hierarchy detailed in the image shows only a subset of the entire\n`DataAccessException` hierarchy.)\n\nimage::DataAccessException.png[]\n\n[[dao-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/dao.adoc", "title": "dao", "heading": "Consistent Exception Hierarchy", "heading_level": 2, "file_order": 142, "section_index": 1, "content_hash": "73fdfbd1f057b47fdb375fafa7c75ef325d65005a0448b264b004d707780481a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/dao.adoc"}}
{"id": "sha256:9b51035dbd30781e33332ea2eea0c21541de67f8044701f22acbb5a6fdc712b0", "content": "The best way to guarantee that your Data Access Objects (DAOs) or repositories provide\nexception translation is to use the `@Repository` annotation. This annotation also\nlets the component scanning support find and configure your DAOs and repositories\nwithout having to provide XML configuration entries for them. The following example shows\nhow to use the `@Repository` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository // <1>\n\tpublic class SomeMovieFinder implements MovieFinder {\n // ...\n\t}\n----\n<1> The `@Repository` annotation.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository // <1>\n\tclass SomeMovieFinder : MovieFinder {\n // ...\n\t}\n----\n<1> The `@Repository` annotation.\n======\n\nAny DAO or repository implementation needs access to a persistence resource,\ndepending on the persistence technology used. For example, a JDBC-based repository\nneeds access to a JDBC `DataSource`, and a JPA-based repository needs access to an\n`EntityManager`. The easiest way to accomplish this is to have this resource dependency\ninjected by using one of the `@Autowired`, `@Inject`, `@Resource` or `@PersistenceContext`\nannotations. The following example works for a JPA repository:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository\n\tpublic class JpaMovieFinder implements MovieFinder {\n\n @PersistenceContext\n private EntityManager entityManager;\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository\n\tclass JpaMovieFinder : MovieFinder {\n\n @PersistenceContext\n private lateinit var entityManager: EntityManager\n\n // ...\n\t}\n----\n======\n\nIf you use the classic Hibernate APIs, you can inject `SessionFactory`, as the following\nexample shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository\n\tpublic class HibernateMovieFinder implements MovieFinder {\n\n private SessionFactory sessionFactory;\n\n @Autowired\n public void setSessionFactory(SessionFactory sessionFactory) {\n this.sessionFactory = sessionFactory;\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository\n\tclass HibernateMovieFinder(private val sessionFactory: SessionFactory) : MovieFinder {\n // ...\n\t}\n----\n======\n\nThe last example we show here is for typical JDBC support. You could have the `DataSource`\ninjected into an initialization method or a constructor, where you would create a `JdbcTemplate`\nand other data access support classes (such as `SimpleJdbcCall` and others) by using this\n`DataSource`. The following example autowires a `DataSource`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository\n\tpublic class JdbcMovieFinder implements MovieFinder {\n\n private JdbcTemplate jdbcTemplate;\n\n @Autowired\n public void init(DataSource dataSource) {\n this.jdbcTemplate = new JdbcTemplate(dataSource);\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repository\n\tclass JdbcMovieFinder(dataSource: DataSource) : MovieFinder {\n\n private val jdbcTemplate = JdbcTemplate(dataSource)\n\n // ...\n\t}\n----\n======\n\nNOTE: See the specific coverage of each persistence technology for details on how to\nconfigure the application context to take advantage of these annotations.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/dao.adoc", "title": "dao", "heading": "Annotations Used to Configure DAO or Repository Classes", "heading_level": 2, "file_order": 142, "section_index": 2, "content_hash": "9b51035dbd30781e33332ea2eea0c21541de67f8044701f22acbb5a6fdc712b0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/dao.adoc"}}
{"id": "sha256:9b01c522ae694b3848ba37573dfd652780d5089d2b4416afc8629f42b67441b4", "content": "[[jdbc]]\n\nThe value provided by the Spring Framework JDBC abstraction is perhaps best shown by\nthe sequence of actions outlined in the following table below. The table shows which actions Spring\ntakes care of and which actions are your responsibility.\n\n[[jdbc-who-does-what]]\n.Spring JDBC - who does what?\n|===\n| Action| Spring| You\n\n| Define connection parameters.\n|\n| X\n\n| Open the connection.\n| X\n|\n\n| Specify the SQL statement.\n|\n| X\n\n| Declare parameters and provide parameter values\n|\n| X\n\n| Prepare and run the statement.\n| X\n|\n\n| Set up the loop to iterate through the results (if any).\n| X\n|\n\n| Do the work for each iteration.\n|\n| X\n\n| Process any exception.\n| X\n|\n\n| Handle transactions.\n| X\n|\n\n| Close the connection, the statement, and the resultset.\n| X\n|\n|===\n\nThe Spring Framework takes care of all the low-level details that can make JDBC such a\ntedious API.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/jdbc.adoc", "title": "jdbc", "heading": "jdbc", "heading_level": 1, "file_order": 143, "section_index": 0, "content_hash": "9b01c522ae694b3848ba37573dfd652780d5089d2b4416afc8629f42b67441b4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/jdbc.adoc"}}
{"id": "sha256:b2d76f3975a489c5787c083d10ebde231a50bddb7670d7e5503881de9fc74a2d", "content": "[[orm]]\n\nThis section covers data access when you use Object Relational Mapping (ORM).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/orm.adoc", "title": "orm", "heading": "orm", "heading_level": 1, "file_order": 144, "section_index": 0, "content_hash": "b2d76f3975a489c5787c083d10ebde231a50bddb7670d7e5503881de9fc74a2d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/orm.adoc"}}
{"id": "sha256:53afda00a5ac7f9c04442ec487cb12c334e2d9a1d519b90caa2708ece0934838", "content": "[[oxm]]\n\n[[oxm-introduction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "oxm", "heading_level": 1, "file_order": 145, "section_index": 0, "content_hash": "53afda00a5ac7f9c04442ec487cb12c334e2d9a1d519b90caa2708ece0934838", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:659204b4f9c05e660f7953524dbf70ff24933fb34a77dcacfab56c9cc8cd4e24", "content": "This chapter, describes Spring's Object-XML Mapping support. Object-XML\nMapping (O-X mapping for short) is the act of converting an XML document to and from\nan object. This conversion process is also known as XML Marshalling, or XML\nSerialization. This chapter uses these terms interchangeably.\n\nWithin the field of O-X mapping, a marshaller is responsible for serializing an\nobject (graph) to XML. In similar fashion, an unmarshaller deserializes the XML to\nan object graph. This XML can take the form of a DOM document, an input or output\nstream, or a SAX handler.\n\nSome of the benefits of using Spring for your O/X mapping needs are:\n\n* xref:data-access/oxm.adoc#oxm-ease-of-configuration[Ease of configuration]\n* xref:data-access/oxm.adoc#oxm-consistent-interfaces[Consistent Interfaces]\n* xref:data-access/oxm.adoc#oxm-consistent-exception-hierarchy[Consistent Exception Hierarchy]\n\n[[oxm-ease-of-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "Introduction", "heading_level": 2, "file_order": 145, "section_index": 1, "content_hash": "659204b4f9c05e660f7953524dbf70ff24933fb34a77dcacfab56c9cc8cd4e24", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:91ebacb786eabc3cf958a7c8e6a62f7ff45605b325dce499a5ce21619b5033bc", "content": "Spring's bean factory makes it easy to configure marshallers, without needing to\nconstruct JAXB context, JiBX binding factories, and so on. You can configure the marshallers\nas you would any other bean in your application context. Additionally, XML namespace-based\nconfiguration is available for a number of marshallers, making the configuration even\nsimpler.\n\n[[oxm-consistent-interfaces]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "Ease of configuration", "heading_level": 3, "file_order": 145, "section_index": 2, "content_hash": "91ebacb786eabc3cf958a7c8e6a62f7ff45605b325dce499a5ce21619b5033bc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:af80c1dd37195c539f47075b524f50948edbcdbf563a1138cd15b76412cc1054", "content": "Spring's O-X mapping operates through two global interfaces: {spring-framework-api}/oxm/Marshaller.html[`Marshaller`] and\n{spring-framework-api}/oxm/Unmarshaller.html[`Unmarshaller`]. These abstractions let you switch O-X mapping frameworks\nwith relative ease, with little or no change required on the classes that do the\nmarshalling. This approach has the additional benefit of making it possible to do XML\nmarshalling with a mix-and-match approach (for example, some marshalling performed using JAXB\nand some by XStream) in a non-intrusive fashion, letting you use the strength of each\ntechnology.\n\n[[oxm-consistent-exception-hierarchy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "Consistent Interfaces", "heading_level": 3, "file_order": 145, "section_index": 3, "content_hash": "af80c1dd37195c539f47075b524f50948edbcdbf563a1138cd15b76412cc1054", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:2cf3857c2cbb2cfbe36418c36f1497de4d93f19d4fcc5c31d0ff123ecfbc98e0", "content": "Spring provides a conversion from exceptions from the underlying O-X mapping tool to its\nown exception hierarchy with the `XmlMappingException` as the root exception.\nThese runtime exceptions wrap the original exception so that no information is lost.\n\n[[oxm-marshaller-unmarshaller]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "Consistent Exception Hierarchy", "heading_level": 3, "file_order": 145, "section_index": 4, "content_hash": "2cf3857c2cbb2cfbe36418c36f1497de4d93f19d4fcc5c31d0ff123ecfbc98e0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:60d876969c35ca9152c56f1ca50337fe5dfabfd41e64a3deece69c9bac00d7bf", "content": "As stated in the xref:data-access/oxm.adoc#oxm-introduction[introduction], a marshaller serializes an object\nto XML, and an unmarshaller deserializes XML stream to an object. This section describes\nthe two Spring interfaces used for this purpose.\n\n[[oxm-marshaller]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "`Marshaller` and `Unmarshaller`", "heading_level": 2, "file_order": 145, "section_index": 5, "content_hash": "60d876969c35ca9152c56f1ca50337fe5dfabfd41e64a3deece69c9bac00d7bf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:610f6a12796ae0f5f14c6493de9ad3eb9f86a14aa3604504ba63792cc440c743", "content": "Spring abstracts all marshalling operations behind the\n`org.springframework.oxm.Marshaller` interface, the main method of which follows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface Marshaller {\n\n /**\n * Marshal the object graph with the given root into the provided Result.\n */\n void marshal(Object graph, Result result) throws XmlMappingException, IOException;\n\t}\n----\n\nThe `Marshaller` interface has one main method, which marshals the given object to a\ngiven `javax.xml.transform.Result`. The result is a tagging interface that basically\nrepresents an XML output abstraction. Concrete implementations wrap various XML\nrepresentations, as the following table indicates:\n\n[[oxm-marshaller-tbl]]\n|===\n| Result implementation| Wraps XML representation\n\n| `DOMResult`\n| `org.w3c.dom.Node`\n\n| `SAXResult`\n| `org.xml.sax.ContentHandler`\n\n| `StreamResult`\n| `java.io.File`, `java.io.OutputStream`, or `java.io.Writer`\n|===\n\nNOTE: Although the `marshal()` method accepts a plain object as its first parameter, most\n`Marshaller` implementations cannot handle arbitrary objects. Instead, an object class\nmust be mapped in a mapping file, be marked with an annotation, be registered with the\nmarshaller, or have a common base class. Refer to the later sections in this chapter\nto determine how your O-X technology manages this.\n\n[[oxm-unmarshaller]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "Understanding `Marshaller`", "heading_level": 3, "file_order": 145, "section_index": 6, "content_hash": "610f6a12796ae0f5f14c6493de9ad3eb9f86a14aa3604504ba63792cc440c743", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:d4fd43900bbc415b15bdb4600129b2d3e6b94bc6f6a0436e098246c2470f40e0", "content": "Similar to the `Marshaller`, we have the `org.springframework.oxm.Unmarshaller`\ninterface, which the following listing shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface Unmarshaller {\n\n /**\n * Unmarshal the given provided Source into an object graph.\n */\n Object unmarshal(Source source) throws XmlMappingException, IOException;\n\t}\n----\n\nThis interface also has one method, which reads from the given\n`javax.xml.transform.Source` (an XML input abstraction) and returns the object read. As\nwith `Result`, `Source` is a tagging interface that has three concrete implementations. Each\nwraps a different XML representation, as the following table indicates:\n\n[[oxm-unmarshaller-tbl]]\n|===\n| Source implementation| Wraps XML representation\n\n| `DOMSource`\n| `org.w3c.dom.Node`\n\n| `SAXSource`\n| `org.xml.sax.InputSource`, and `org.xml.sax.XMLReader`\n\n| `StreamSource`\n| `java.io.File`, `java.io.InputStream`, or `java.io.Reader`\n|===\n\nEven though there are two separate marshalling interfaces (`Marshaller` and\n`Unmarshaller`), all implementations in Spring-WS implement both in one class.\nThis means that you can wire up one marshaller class and refer to it both as a\nmarshaller and as an unmarshaller in your `applicationContext.xml`.\n\n[[oxm-xmlmappingexception]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "Understanding `Unmarshaller`", "heading_level": 3, "file_order": 145, "section_index": 7, "content_hash": "d4fd43900bbc415b15bdb4600129b2d3e6b94bc6f6a0436e098246c2470f40e0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:a39a4381921671648fcde47757d24992093122d8cc5d5180248f550229a32f9c", "content": "Spring converts exceptions from the underlying O-X mapping tool to its own exception\nhierarchy with the `XmlMappingException` as the root exception.\nThese runtime exceptions wrap the original exception so that no information will be lost.\n\nAdditionally, the `MarshallingFailureException` and `UnmarshallingFailureException`\nprovide a distinction between marshalling and unmarshalling operations, even though the\nunderlying O-X mapping tool does not do so.\n\nThe O-X Mapping exception hierarchy is shown in the following figure:\n\nimage::oxm-exceptions.png[]\n\n[[oxm-usage]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "Understanding `XmlMappingException`", "heading_level": 3, "file_order": 145, "section_index": 8, "content_hash": "a39a4381921671648fcde47757d24992093122d8cc5d5180248f550229a32f9c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:6adaa373b46383ae3767dcda2b64be258ace4c269beac010d533545fd5d11856", "content": "You can use Spring's OXM for a wide variety of situations. In the following example, we\nuse it to marshal the settings of a Spring-managed application as an XML file. In the following example, we\nuse a simple JavaBean to represent the settings:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class Settings {\n\n private boolean fooEnabled;\n\n public boolean isFooEnabled() {\n return fooEnabled;\n }\n\n public void setFooEnabled(boolean fooEnabled) {\n this.fooEnabled = fooEnabled;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Settings {\n var isFooEnabled: Boolean = false\n\t}\n----\n======\n\nThe application class uses this bean to store its settings. Besides a main method, the\nclass has two methods: `saveSettings()` saves the settings bean to a file named\n`settings.xml`, and `loadSettings()` loads these settings again. The following `main()` method\nconstructs a Spring application context and calls these two methods:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport java.io.FileInputStream;\n\timport java.io.FileOutputStream;\n\timport java.io.IOException;\n\timport javax.xml.transform.stream.StreamResult;\n\timport javax.xml.transform.stream.StreamSource;\n\timport org.springframework.context.ApplicationContext;\n\timport org.springframework.context.support.ClassPathXmlApplicationContext;\n\timport org.springframework.oxm.Marshaller;\n\timport org.springframework.oxm.Unmarshaller;\n\n\tpublic class Application {\n\n private static final String FILE_NAME = \"settings.xml\";\n private Settings settings = new Settings();\n private Marshaller marshaller;\n private Unmarshaller unmarshaller;\n\n public void setMarshaller(Marshaller marshaller) {\n this.marshaller = marshaller;\n }\n\n public void setUnmarshaller(Unmarshaller unmarshaller) {\n this.unmarshaller = unmarshaller;\n }\n\n public void saveSettings() throws IOException {\n try (FileOutputStream os = new FileOutputStream(FILE_NAME)) {\n this.marshaller.marshal(settings, new StreamResult(os));\n }\n }\n\n public void loadSettings() throws IOException {\n try (FileInputStream is = new FileInputStream(FILE_NAME)) {\n this.settings = (Settings) this.unmarshaller.unmarshal(new StreamSource(is));\n }\n }\n\n public static void main(String[] args) throws IOException {\n ApplicationContext appContext =\n new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n Application application = (Application) appContext.getBean(\"application\");\n application.saveSettings();\n application.loadSettings();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Application {\n\n lateinit var marshaller: Marshaller\n\n lateinit var unmarshaller: Unmarshaller\n\n fun saveSettings() {\n FileOutputStream(FILE_NAME).use { outputStream -> marshaller.marshal(settings, StreamResult(outputStream)) }\n }\n\n fun loadSettings() {\n FileInputStream(FILE_NAME).use { inputStream -> settings = unmarshaller.unmarshal(StreamSource(inputStream)) as Settings }\n }\n\t}\n\n\tprivate const val FILE_NAME = \"settings.xml\"\n\n\tfun main(args: Array<String>) {\n val appContext = ClassPathXmlApplicationContext(\"applicationContext.xml\")\n val application = appContext.getBean(\"application\") as Application\n application.saveSettings()\n application.loadSettings()\n\t}\n----\n======\n\nThe `Application` requires both a `marshaller` and an `unmarshaller` property to be set. We\ncan do so by using the following `applicationContext.xml`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"application\" class=\"Application\">\n <property name=\"marshaller\" ref=\"xstreamMarshaller\" />\n <property name=\"unmarshaller\" ref=\"xstreamMarshaller\" />\n </bean>\n <bean id=\"xstreamMarshaller\" class=\"org.springframework.oxm.xstream.XStreamMarshaller\"/>\n\t</beans>\n----\n\nThis application context uses XStream, but we could have used any of the other marshaller\ninstances described later in this chapter. Note that, by default, XStream does not require\nany further configuration, so the bean definition is rather simple. Also note that the\n`XStreamMarshaller` implements both `Marshaller` and `Unmarshaller`, so we can refer to the\n`xstreamMarshaller` bean in both the `marshaller` and `unmarshaller` property of the\napplication.\n\nThis sample application produces the following `settings.xml` file:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<settings foo-enabled=\"false\"/>\n----\n\n[[oxm-schema-based-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "Using `Marshaller` and `Unmarshaller`", "heading_level": 2, "file_order": 145, "section_index": 9, "content_hash": "6adaa373b46383ae3767dcda2b64be258ace4c269beac010d533545fd5d11856", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:8733574bca94f4def049ca87fc69b15ed6fc532a7a3503685c3fafe47ad6e8c8", "content": "You can configure marshallers more concisely by using tags from the OXM namespace.\nTo make these tags available, you must first reference the appropriate schema in the\npreamble of the XML configuration file. The following example shows how to do so:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:oxm=\"http://www.springframework.org/schema/oxm\" <1>\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/oxm\n https://www.springframework.org/schema/oxm/spring-oxm.xsd\"> <2>\n----\n<1> Reference the `oxm` schema.\n<2> Specify the `oxm` schema location.\n\nThe schema makes the following elements available:\n\n* xref:data-access/oxm.adoc#oxm-jaxb2-xsd[`jaxb2-marshaller`]\n* xref:data-access/oxm.adoc#oxm-jibx-xsd[`jibx-marshaller`]\n\nEach tag is explained in its respective marshaller's section. As an example, though,\nthe configuration of a JAXB2 marshaller might resemble the following:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<oxm:jaxb2-marshaller id=\"marshaller\" contextPath=\"org.springframework.ws.samples.airline.schema\"/>\n----\n\n[[oxm-jaxb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "XML Configuration Namespace", "heading_level": 2, "file_order": 145, "section_index": 10, "content_hash": "8733574bca94f4def049ca87fc69b15ed6fc532a7a3503685c3fafe47ad6e8c8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:9805ba884a943c8294804373b4bc841d0d4c18b14f8443385ff88a8878e5362a", "content": "The JAXB binding compiler translates a W3C XML Schema into one or more Java classes, a\n`jaxb.properties` file, and possibly some resource files. JAXB also offers a way to\ngenerate a schema from annotated Java classes.\n\nSpring supports the JAXB 2.0 API as XML marshalling strategies, following the\n`Marshaller` and `Unmarshaller` interfaces described in xref:data-access/oxm.adoc#oxm-marshaller-unmarshaller[`Marshaller` and `Unmarshaller`].\nThe corresponding integration classes reside in the `org.springframework.oxm.jaxb`\npackage.\n\n[[oxm-jaxb2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "JAXB", "heading_level": 2, "file_order": 145, "section_index": 11, "content_hash": "9805ba884a943c8294804373b4bc841d0d4c18b14f8443385ff88a8878e5362a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:804e719acb4b19ca76d375c1f8bdb7a52831de345af00568295782bc4ccfcb33", "content": "The `Jaxb2Marshaller` class implements both of Spring's `Marshaller` and `Unmarshaller`\ninterfaces. It requires a context path to operate. You can set the context path by setting the\n`contextPath` property. The context path is a list of colon-separated Java package\nnames that contain schema derived classes. It also offers a `classesToBeBound` property,\nwhich allows you to set an array of classes to be supported by the marshaller. Schema\nvalidation is performed by specifying one or more schema resources to the bean, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"jaxb2Marshaller\" class=\"org.springframework.oxm.jaxb.Jaxb2Marshaller\">\n <property name=\"classesToBeBound\">\n <list>\n <value>org.springframework.oxm.jaxb.Flight</value>\n <value>org.springframework.oxm.jaxb.Flights</value>\n </list>\n </property>\n <property name=\"schema\" value=\"classpath:org/springframework/oxm/schema.xsd\"/>\n </bean>\n\n ...\n\n\t</beans>\n----\n\n[[oxm-jaxb2-xsd]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "Using `Jaxb2Marshaller`", "heading_level": 3, "file_order": 145, "section_index": 12, "content_hash": "804e719acb4b19ca76d375c1f8bdb7a52831de345af00568295782bc4ccfcb33", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:304ace28b74ab048f0af05b727d641f5e19f0b880277340008033f36379da919", "content": "The `jaxb2-marshaller` element configures a `org.springframework.oxm.jaxb.Jaxb2Marshaller`,\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<oxm:jaxb2-marshaller id=\"marshaller\" contextPath=\"org.springframework.ws.samples.airline.schema\"/>\n----\n\nAlternatively, you can provide the list of classes to bind to the marshaller by using the\n`class-to-be-bound` child element:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<oxm:jaxb2-marshaller id=\"marshaller\">\n <oxm:class-to-be-bound name=\"org.springframework.ws.samples.airline.schema.Airport\"/>\n <oxm:class-to-be-bound name=\"org.springframework.ws.samples.airline.schema.Flight\"/>\n ...\n\t</oxm:jaxb2-marshaller>\n----\n\nThe following table describes the available attributes:\n\n|===\n| Attribute| Description| Required\n\n| `id`\n| The ID of the marshaller\n| No\n\n| `contextPath`\n| The JAXB Context path\n| No\n|===\n\n[[oxm-jibx]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "XML Configuration Namespace", "heading_level": 4, "file_order": 145, "section_index": 13, "content_hash": "304ace28b74ab048f0af05b727d641f5e19f0b880277340008033f36379da919", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:15cf45d181916ef75545d90a34a7998e4f17ae523dbe3f186850966cbd8cb228", "content": "The JiBX framework offers a solution similar to that which Hibernate provides for ORM: A\nbinding definition defines the rules for how your Java objects are converted to or from\nXML. After preparing the binding and compiling the classes, a JiBX binding compiler\nenhances the class files and adds code to handle converting instances of the classes\nfrom or to XML.\n\nFor more information on JiBX, see the http://jibx.sourceforge.net/[JiBX web\nsite]. The Spring integration classes reside in the `org.springframework.oxm.jibx`\npackage.\n\n[[oxm-jibx-marshaller]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "JiBX", "heading_level": 2, "file_order": 145, "section_index": 14, "content_hash": "15cf45d181916ef75545d90a34a7998e4f17ae523dbe3f186850966cbd8cb228", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:9b0f8fea5f8b87f566276794850a969fac4ae49e8a937fab2c1cc4e4802b072b", "content": "The `JibxMarshaller` class implements both the `Marshaller` and `Unmarshaller`\ninterface. To operate, it requires the name of the class to marshal in, which you can\nset using the `targetClass` property. Optionally, you can set the binding name by setting the\n`bindingName` property. In the following example, we bind the `Flights` class:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"jibxFlightsMarshaller\" class=\"org.springframework.oxm.jibx.JibxMarshaller\">\n <property name=\"targetClass\">org.springframework.oxm.jibx.Flights</property>\n </bean>\n ...\n\t</beans>\n----\n\nA `JibxMarshaller` is configured for a single class. If you want to marshal multiple\nclasses, you have to configure multiple `JibxMarshaller` instances with different `targetClass`\nproperty values.\n\n[[oxm-jibx-xsd]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "Using `JibxMarshaller`", "heading_level": 3, "file_order": 145, "section_index": 15, "content_hash": "9b0f8fea5f8b87f566276794850a969fac4ae49e8a937fab2c1cc4e4802b072b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:c942b8e72340d90d9c35c05c796fa597074910ca33ebbac4b297372ca031c367", "content": "The `jibx-marshaller` tag configures a `org.springframework.oxm.jibx.JibxMarshaller`,\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<oxm:jibx-marshaller id=\"marshaller\" target-class=\"org.springframework.ws.samples.airline.schema.Flight\"/>\n----\n\nThe following table describes the available attributes:\n\n|===\n| Attribute| Description| Required\n\n| `id`\n| The ID of the marshaller\n| No\n\n| `target-class`\n| The target class for this marshaller\n| Yes\n\n| `bindingName`\n| The binding name used by this marshaller\n| No\n|===\n\n[[oxm-xstream]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "XML Configuration Namespace", "heading_level": 4, "file_order": 145, "section_index": 16, "content_hash": "c942b8e72340d90d9c35c05c796fa597074910ca33ebbac4b297372ca031c367", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:a365097ff349f0fb53235e7c35beae56db183deeccdbea6ac5138ce388ddbc9a", "content": "XStream is a simple library to serialize objects to XML and back again. It does not\nrequire any mapping and generates clean XML.\n\nFor more information on XStream, see the https://x-stream.github.io/[XStream\nweb site]. The Spring integration classes reside in the\n`org.springframework.oxm.xstream` package.\n\n[[oxm-xstream-marshaller]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "XStream", "heading_level": 2, "file_order": 145, "section_index": 17, "content_hash": "a365097ff349f0fb53235e7c35beae56db183deeccdbea6ac5138ce388ddbc9a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:a294388fe30a85f607e4930bb2d2dd395dc0ce48fe8d8bda76b24e48048b059d", "content": "The `XStreamMarshaller` does not require any configuration and can be configured in an\napplication context directly. To further customize the XML, you can set an alias map,\nwhich consists of string aliases mapped to classes, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"xstreamMarshaller\" class=\"org.springframework.oxm.xstream.XStreamMarshaller\">\n <property name=\"aliases\">\n <props>\n <prop key=\"Flight\">org.springframework.oxm.xstream.Flight</prop>\n </props>\n </property>\n </bean>\n ...\n\t</beans>\n----\n\n[WARNING]\n=====\nBy default, XStream lets arbitrary classes be unmarshalled, which can lead to\nunsafe Java serialization effects. As such, we do not recommend using the\n`XStreamMarshaller` to unmarshal XML from external sources (that is, the Web), as this can\nresult in security vulnerabilities.\n\nIf you choose to use the `XStreamMarshaller` to unmarshal XML from an external source,\nset the `supportedClasses` property on the `XStreamMarshaller`, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"xstreamMarshaller\" class=\"org.springframework.oxm.xstream.XStreamMarshaller\">\n <property name=\"supportedClasses\" value=\"org.springframework.oxm.xstream.Flight\"/>\n ...\n\t</bean>\n----\n\nDoing so ensures that only the registered classes are eligible for unmarshalling.\n\nAdditionally, you can register\n{spring-framework-api}/oxm/xstream/XStreamMarshaller.html#setConverters(com.thoughtworks.xstream.converters.ConverterMatcher...)[custom converters]\nto make sure that only your supported classes can be unmarshalled. You might want\nto add a `CatchAllConverter` as the last converter in the list, in addition to\nconverters that explicitly support the domain classes that should be supported.\nAs a result, default XStream converters with lower priorities and possible security\nvulnerabilities do not get invoked.\n=====\n\nNOTE: Note that XStream is an XML serialization library, not a data binding library.\nTherefore, it has limited namespace support. As a result, it is rather unsuitable for usage\nwithin Web Services.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/oxm.adoc", "title": "oxm", "heading": "Using `XStreamMarshaller`", "heading_level": 3, "file_order": 145, "section_index": 18, "content_hash": "a294388fe30a85f607e4930bb2d2dd395dc0ce48fe8d8bda76b24e48048b059d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/oxm.adoc"}}
{"id": "sha256:e1d25c7833c3d8f9b6f56197f76a821d36a6dd09d5a19c55f2ab2a5ee45aea26", "content": "[[r2dbc]]\n\nhttps://r2dbc.io[R2DBC] (\"Reactive Relational Database Connectivity\") is a community-driven\nspecification effort to standardize access to SQL databases using reactive patterns.\n\n[[r2dbc-packages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "r2dbc", "heading_level": 1, "file_order": 146, "section_index": 0, "content_hash": "e1d25c7833c3d8f9b6f56197f76a821d36a6dd09d5a19c55f2ab2a5ee45aea26", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:70213bd9c57de5e33ec3e4cecc8d9bcbdbbbf2ea82c21fef107db05058d35901", "content": "The Spring Framework's R2DBC abstraction framework consists of two different packages:\n\n* `core`: The `org.springframework.r2dbc.core` package contains the `DatabaseClient`\nclass plus a variety of related classes. See\nxref:data-access/r2dbc.adoc#r2dbc-core[Using the R2DBC Core Classes to Control Basic R2DBC Processing and Error Handling].\n\n* `connection`: The `org.springframework.r2dbc.connection` package contains a utility class\nfor easy `ConnectionFactory` access and various simple `ConnectionFactory` implementations\nthat you can use for testing and running unmodified R2DBC. See\nxref:data-access/r2dbc.adoc#r2dbc-connections[Controlling Database Connections].\n\n[[r2dbc-core]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Package Hierarchy", "heading_level": 2, "file_order": 146, "section_index": 1, "content_hash": "70213bd9c57de5e33ec3e4cecc8d9bcbdbbbf2ea82c21fef107db05058d35901", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:1c64ef8dad5f760ca6785e26e343549f3ee0e264094e5b3fd74068579383b341", "content": "This section covers how to use the R2DBC core classes to control basic R2DBC processing,\nincluding error handling. It includes the following topics:\n\n* xref:data-access/r2dbc.adoc#r2dbc-DatabaseClient[Using `DatabaseClient`]\n* xref:data-access/r2dbc.adoc#r2dbc-DatabaseClient-examples-statement[Executing Statements]\n* xref:data-access/r2dbc.adoc#r2dbc-DatabaseClient-examples-query[Querying (`SELECT`)]\n* xref:data-access/r2dbc.adoc#r2dbc-DatabaseClient-examples-update[Updating (`INSERT`, `UPDATE`, and `DELETE`) with `DatabaseClient`]\n* xref:data-access/r2dbc.adoc#r2dbc-DatabaseClient-filter[Statement Filters]\n* xref:data-access/r2dbc.adoc#r2dbc-auto-generated-keys[Retrieving Auto-generated Keys]\n\n[[r2dbc-DatabaseClient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Using the R2DBC Core Classes to Control Basic R2DBC Processing and Error Handling", "heading_level": 2, "file_order": 146, "section_index": 2, "content_hash": "1c64ef8dad5f760ca6785e26e343549f3ee0e264094e5b3fd74068579383b341", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:fca8e8ca41a7f3f63992a063cb486262e54a880381d9ee43f3250c75c565fab4", "content": "`DatabaseClient` is the central class in the R2DBC core package. It handles the\ncreation and release of resources, which helps to avoid common errors, such as\nforgetting to close the connection. It performs the basic tasks of the core R2DBC\nworkflow (such as statement creation and execution), leaving application code to provide\nSQL and extract results. The `DatabaseClient` class:\n\n* Runs SQL queries\n* Update statements and stored procedure calls\n* Performs iteration over `Result` instances\n* Catches R2DBC exceptions and translates them to the generic, more informative,\nexception hierarchy defined in the `org.springframework.dao` package.\n(See xref:data-access/dao.adoc#dao-exceptions[Consistent Exception Hierarchy].)\n\nThe client has a functional, fluent API using reactive types for declarative composition.\n\nWhen you use the `DatabaseClient` for your code, you need only to implement\n`java.util.function` interfaces, giving them a clearly defined contract.\nGiven a `Connection` provided by the `DatabaseClient` class, a `Function`\ncallback creates a `Publisher`. The same is true for mapping functions that\nextract a `Row` result.\n\nYou can use `DatabaseClient` within a DAO implementation through direct instantiation\nwith a `ConnectionFactory` reference, or you can configure it in a Spring IoC container\nand give it to DAOs as a bean reference.\n\nThe simplest way to create a `DatabaseClient` object is through a static factory method, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tDatabaseClient client = DatabaseClient.create(connectionFactory);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval client = DatabaseClient.create(connectionFactory)\n----\n======\n\nNOTE: The `ConnectionFactory` should always be configured as a bean in the Spring IoC\ncontainer.\n\nThe preceding method creates a `DatabaseClient` with default settings.\n\nYou can also obtain a `Builder` instance from `DatabaseClient.builder()`.\nYou can customize the client by calling the following methods:\n\n* `â€¦.bindMarkers(â€¦)`: Supply a specific `BindMarkersFactory` to configure named\nparameter to database bind marker translation.\n* `â€¦.executeFunction(â€¦)`: Set the `ExecuteFunction` how `Statement` objects get\n run.\n* `â€¦.namedParameters(false)`: Disable named parameter expansion. Enabled by default.\n\nTIP: Dialects are resolved by {spring-framework-api}/r2dbc/core/binding/BindMarkersFactoryResolver.html[`BindMarkersFactoryResolver`]\n from a `ConnectionFactory`, typically by inspecting `ConnectionFactoryMetadata`.\n +\nYou can let Spring auto-discover your `BindMarkersFactory` by registering a\nclass that implements `org.springframework.r2dbc.core.binding.BindMarkersFactoryResolver$BindMarkerFactoryProvider`\nthrough `META-INF/spring.factories`.\n`BindMarkersFactoryResolver` discovers bind marker provider implementations from\nthe class path using Spring's `SpringFactoriesLoader`.\n +\n\nCurrently supported databases are:\n\n* H2\n* MariaDB\n* Microsoft SQL Server\n* MySQL\n* Postgres\n\nAll SQL issued by this class is logged at the `DEBUG` level under the category\ncorresponding to the fully qualified class name of the client instance (typically\n`DefaultDatabaseClient`). Additionally, each execution registers a checkpoint in\nthe reactive sequence to aid debugging.\n\nThe following sections provide some examples of `DatabaseClient` usage. These examples\nare not an exhaustive list of all of the functionality exposed by the `DatabaseClient`.\nSee the attendant {spring-framework-api}/r2dbc/core/DatabaseClient.html[javadoc] for that.\n\n[[r2dbc-DatabaseClient-examples-statement]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Using `DatabaseClient`", "heading_level": 3, "file_order": 146, "section_index": 3, "content_hash": "fca8e8ca41a7f3f63992a063cb486262e54a880381d9ee43f3250c75c565fab4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:f1810eb2d1dcbc87fc4415cd97f89b3e456bf951cf2d77b218c0d5a5d5ad38c8", "content": "`DatabaseClient` provides the basic functionality of running a statement.\nThe following example shows what you need to include for minimal but fully functional\ncode that creates a new table:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMono<Void> completion = client.sql(\"CREATE TABLE person (id VARCHAR(255) PRIMARY KEY, name VARCHAR(255), age INTEGER);\")\n .then();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.sql(\"CREATE TABLE person (id VARCHAR(255) PRIMARY KEY, name VARCHAR(255), age INTEGER);\")\n .await()\n----\n======\n\n`DatabaseClient` is designed for convenient, fluent usage.\nIt exposes intermediate, continuation, and terminal methods at each stage of the\nexecution specification. The preceding example above uses `then()` to return a completion\n`Publisher` that completes as soon as the query (or queries, if the SQL query contains\nmultiple statements) completes.\n\nNOTE: `execute(â€¦)` accepts either the SQL query string or a query `Supplier<String>`\nto defer the actual query creation until execution.\n\n[[r2dbc-DatabaseClient-examples-query]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Executing Statements", "heading_level": 4, "file_order": 146, "section_index": 4, "content_hash": "f1810eb2d1dcbc87fc4415cd97f89b3e456bf951cf2d77b218c0d5a5d5ad38c8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:6e6a7aa8718b5974d5a786b9b542551fe88b6ec354f1090096626e8246f8fcc0", "content": "SQL queries can return values through `Row` objects or the number of affected rows.\n`DatabaseClient` can return the number of updated rows or the rows themselves,\ndepending on the issued query.\n\nThe following query gets the `id` and `name` columns from a table:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMono<Map<String, Object>> first = client.sql(\"SELECT id, name FROM person\")\n .fetch().first();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval first = client.sql(\"SELECT id, name FROM person\")\n .fetch().awaitSingle()\n----\n======\n\nThe following query uses a bind variable:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMono<Map<String, Object>> first = client.sql(\"SELECT id, name FROM person WHERE first_name = :fn\")\n .bind(\"fn\", \"Joe\")\n .fetch().first();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval first = client.sql(\"SELECT id, name FROM person WHERE first_name = :fn\")\n .bind(\"fn\", \"Joe\")\n .fetch().awaitSingle()\n----\n======\n\nYou might have noticed the use of `fetch()` in the example above. `fetch()` is a\ncontinuation operator that lets you specify how much data you want to consume.\n\nCalling `first()` returns the first row from the result and discards remaining rows.\nYou can consume data with the following operators:\n\n* `first()` return the first row of the entire result. Its Kotlin Coroutine variant\nis named `awaitSingle()` for non-nullable return values and `awaitSingleOrNull()`\nif the value is optional.\n* `one()` returns exactly one result and fails if the result contains more rows.\nUsing Kotlin Coroutines, `awaitOne()` for exactly one value or `awaitOneOrNull()`\nif the value may be `null`.\n* `all()` returns all rows of the result. When using Kotlin Coroutines, use `flow()`.\n* `rowsUpdated()` returns the number of affected rows (`INSERT`/`UPDATE`/`DELETE`\ncount). Its Kotlin Coroutine variant is named `awaitRowsUpdated()`.\n\nWithout specifying further mapping details, queries return tabular results\nas `Map` whose keys are case-insensitive column names that map to their column value.\n\nYou can take control over result mapping by supplying a `Function<Row, T>` that gets\ncalled for each `Row` so it can return arbitrary values (singular values,\ncollections and maps, and objects).\n\nThe following example extracts the `name` column and emits its value:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tFlux<String> names = client.sql(\"SELECT name FROM person\")\n .map(row -> row.get(\"name\", String.class))\n .all();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval names = client.sql(\"SELECT name FROM person\")\n .map{ row: Row -> row.get(\"name\", String.class) }\n .flow()\n----\n======\n\nAlternatively, there is a shortcut for mapping to a single value:\n\n[source,java]\n----\n\tFlux<String> names = client.sql(\"SELECT name FROM person\")\n .mapValue(String.class)\n .all();\n----\n\nOr you may map to a result object with bean properties or record components:\n\n[source,java]\n----\n\t// assuming a name property on Person\n\tFlux<Person> persons = client.sql(\"SELECT name FROM person\")\n .mapProperties(Person.class)\n .all();\n----\n\n[[r2dbc-DatabaseClient-mapping-null]]\n.What about `null`?\n****\nRelational database results can contain `null` values.\nThe Reactive Streams specification forbids the emission of `null` values.\nThat requirement mandates proper `null` handling in the extractor function.\nWhile you can obtain `null` values from a `Row`, you must not emit a `null`\nvalue. You must wrap any `null` values in an object (for example, `Optional`\nfor singular values) to make sure a `null` value is never returned directly\nby your extractor function.\n****\n\n[[r2dbc-DatabaseClient-examples-update]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Querying (`SELECT`)", "heading_level": 4, "file_order": 146, "section_index": 5, "content_hash": "6e6a7aa8718b5974d5a786b9b542551fe88b6ec354f1090096626e8246f8fcc0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:12f35cffbc5e55192068d011ab7881d51cc3728c45b4ffdd72e4a1359bc182de", "content": "The only difference of modifying statements is that these statements typically\ndo not return tabular data so you use `rowsUpdated()` to consume results.\n\nThe following example shows an `UPDATE` statement that returns the number\nof updated rows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMono<Integer> affectedRows = client.sql(\"UPDATE person SET first_name = :fn\")\n .bind(\"fn\", \"Joe\")\n .fetch().rowsUpdated();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval affectedRows = client.sql(\"UPDATE person SET first_name = :fn\")\n .bind(\"fn\", \"Joe\")\n .fetch().awaitRowsUpdated()\n----\n======\n\n[[r2dbc-DatabaseClient-named-parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Updating (`INSERT`, `UPDATE`, and `DELETE`) with `DatabaseClient`", "heading_level": 4, "file_order": 146, "section_index": 6, "content_hash": "12f35cffbc5e55192068d011ab7881d51cc3728c45b4ffdd72e4a1359bc182de", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:71a4362bb3ee497a7fc13f0a286238d349473271613cee061866e1887e9cf776", "content": "A typical application requires parameterized SQL statements to select or\nupdate rows according to some input. These are typically `SELECT` statements\nconstrained by a `WHERE` clause or `INSERT` and `UPDATE` statements that accept\ninput parameters. Parameterized statements bear the risk of SQL injection if\nparameters are not escaped properly. `DatabaseClient` leverages R2DBC's\n`bind` API to eliminate the risk of SQL injection for query parameters.\nYou can provide a parameterized SQL statement with the `execute(â€¦)` operator\nand bind parameters to the actual `Statement`. Your R2DBC driver then runs\nthe statement by using prepared statements and parameter substitution.\n\nParameter binding supports two binding strategies:\n\n* By Index, using zero-based parameter indexes.\n* By Name, using the placeholder name.\n\nThe following example shows parameter binding for a query:\n\n[source,java]\n----\n\tdb.sql(\"INSERT INTO person (id, name, age) VALUES(:id, :name, :age)\")\n .bind(\"id\", \"joe\")\n .bind(\"name\", \"Joe\")\n .bind(\"age\", 34);\n----\n\nAlternatively, you may pass in a map of names and values:\n\n[source,java]\n----\n\tMap<String, Object> params = new LinkedHashMap<>();\n\tparams.put(\"id\", \"joe\");\n\tparams.put(\"name\", \"Joe\");\n\tparams.put(\"age\", 34);\n\tdb.sql(\"INSERT INTO person (id, name, age) VALUES(:id, :name, :age)\")\n .bindValues(params);\n----\n\nOr you may pass in a parameter object with bean properties or record components:\n\n[source,java]\n----\n\t// assuming id, name, age properties on Person\n\tdb.sql(\"INSERT INTO person (id, name, age) VALUES(:id, :name, :age)\")\n .bindProperties(new Person(\"joe\", \"Joe\", 34);\n----\n\nAlternatively, you can use positional parameters for binding values to statements.\nIndices are zero based.\n\n[source,java]\n----\n\tdb.sql(\"INSERT INTO person (id, name, age) VALUES(:id, :name, :age)\")\n .bind(0, \"joe\")\n .bind(1, \"Joe\")\n .bind(2, 34);\n----\n\nIn case your application is binding to many parameters, the same can be achieved with a single call:\n\n[source,java]\n----\n\tList<?> values = List.of(\"joe\", \"Joe\", 34);\n\tdb.sql(\"INSERT INTO person (id, name, age) VALUES(:id, :name, :age)\")\n .bindValues(values);\n----\n\n.R2DBC Native Bind Markers\n****\nR2DBC uses database-native bind markers that depend on the actual database vendor.\nAs an example, Postgres uses indexed markers, such as `$1`, `$2`, `$n`.\nAnother example is SQL Server, which uses named bind markers prefixed with `@`.\n\nThis is different from JDBC which requires `?` as bind markers.\nIn JDBC, the actual drivers translate `?` bind markers to database-native\nmarkers as part of their statement execution.\n\nSpring Framework's R2DBC support lets you use native bind markers or named bind\nmarkers with the `:name` syntax.\n\nNamed parameter support leverages a `BindMarkersFactory` instance to expand named\nparameters to native bind markers at the time of query execution, which gives you\na certain degree of query portability across various database vendors.\n****\n\nThe query-preprocessor unrolls named `Collection` parameters into a series of bind\nmarkers to remove the need of dynamic query creation based on the number of arguments.\nNested object arrays are expanded to allow usage of (for example) select lists.\n\nConsider the following query:\n\n[source,sql]\n----\nSELECT id, name, state FROM table WHERE (name, age) IN (('John', 35), ('Ann', 50))\n----\n\nThe preceding query can be parameterized and run as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tList<Object[]> tuples = new ArrayList<>();\n\ttuples.add(new Object[] {\"John\", 35});\n\ttuples.add(new Object[] {\"Ann\", 50});\n\n\tclient.sql(\"SELECT id, name, state FROM table WHERE (name, age) IN (:tuples)\")\n .bind(\"tuples\", tuples);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval tuples: MutableList<Array<Any>> = ArrayList()\n\ttuples.add(arrayOf(\"John\", 35))\n\ttuples.add(arrayOf(\"Ann\", 50))\n\n\tclient.sql(\"SELECT id, name, state FROM table WHERE (name, age) IN (:tuples)\")\n .bind(\"tuples\", tuples)\n----\n======\n\nNOTE: Usage of select lists is vendor-dependent.\n\nThe following example shows a simpler variant using `IN` predicates:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.sql(\"SELECT id, name, state FROM table WHERE age IN (:ages)\")\n .bind(\"ages\", Arrays.asList(35, 50));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.sql(\"SELECT id, name, state FROM table WHERE age IN (:ages)\")\n .bind(\"ages\", arrayOf(35, 50))\n----\n======\n\nNOTE: R2DBC itself does not support Collection-like values. Nevertheless,\nexpanding a given `List` in the example above works for named parameters\nin Spring's R2DBC support, for example, for use in `IN` clauses as shown above.\nHowever, inserting or updating array-typed columns (for example, in Postgres)\nrequires an array type that is supported by the underlying R2DBC driver:\ntypically a Java array, for example, `String[]` to update a `text[]` column.\nDo not pass `Collection<String>` or the like as an array parameter.\n\n[[r2dbc-DatabaseClient-filter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Binding Values to Queries", "heading_level": 4, "file_order": 146, "section_index": 7, "content_hash": "71a4362bb3ee497a7fc13f0a286238d349473271613cee061866e1887e9cf776", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:3d7da9fdea99d824af4e4e2897ab8cc5386709e19d013253a1c8ccf2ebdc83bd", "content": "Sometimes you need to fine-tune options on the actual `Statement`\nbefore it gets run. To do so, register a `Statement` filter\n(`StatementFilterFunction`) with the `DatabaseClient` to intercept and\nmodify statements in their execution, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\")\n .filter((s, next) -> next.execute(s.returnGeneratedValues(\"id\")))\n .bind(\"name\", â€¦)\n .bind(\"state\", â€¦);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\")\n .filter { s: Statement, next: ExecuteFunction -> next.execute(s.returnGeneratedValues(\"id\")) }\n .bind(\"name\", â€¦)\n .bind(\"state\", â€¦)\n----\n======\n\n`DatabaseClient` also exposes a simplified `filter(â€¦)` overload that accepts\na `Function<Statement, Statement>`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\")\n .filter(statement -> s.returnGeneratedValues(\"id\"));\n\n\tclient.sql(\"SELECT id, name, state FROM table\")\n .filter(statement -> s.fetchSize(25));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\")\n .filter { statement -> s.returnGeneratedValues(\"id\") }\n\n\tclient.sql(\"SELECT id, name, state FROM table\")\n .filter { statement -> s.fetchSize(25) }\n----\n======\n\n`StatementFilterFunction` implementations allow filtering of the\n`Statement` and filtering of `Result` objects.\n\n[[r2dbc-DatabaseClient-idioms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Statement Filters", "heading_level": 4, "file_order": 146, "section_index": 8, "content_hash": "3d7da9fdea99d824af4e4e2897ab8cc5386709e19d013253a1c8ccf2ebdc83bd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:a50bfe8af581dbb9cfa81b8bc6d16f98e965f16b3d2e5605636439a26d22c15f", "content": "Instances of the `DatabaseClient` class are thread-safe, once configured. This is\nimportant because it means that you can configure a single instance of a `DatabaseClient`\nand then safely inject this shared reference into multiple DAOs (or repositories).\nThe `DatabaseClient` is stateful, in that it maintains a reference to a `ConnectionFactory`,\nbut this state is not conversational state.\n\nA common practice when using the `DatabaseClient` class is to configure a `ConnectionFactory`\nin your Spring configuration file and then dependency-inject\nthat shared `ConnectionFactory` bean into your DAO classes. The `DatabaseClient` is created in\nthe setter for the `ConnectionFactory`. This leads to DAOs that resemble the following:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class R2dbcCorporateEventDao implements CorporateEventDao {\n\n private DatabaseClient databaseClient;\n\n public void setConnectionFactory(ConnectionFactory connectionFactory) {\n this.databaseClient = DatabaseClient.create(connectionFactory);\n }\n\n // R2DBC-backed implementations of the methods on the CorporateEventDao follow...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass R2dbcCorporateEventDao(connectionFactory: ConnectionFactory) : CorporateEventDao {\n\n private val databaseClient = DatabaseClient.create(connectionFactory)\n\n // R2DBC-backed implementations of the methods on the CorporateEventDao follow...\n\t}\n----\n======\n--\n\nAn alternative to explicit configuration is to use component-scanning and annotation\nsupport for dependency injection. In this case, you can annotate the class with `@Component`\n(which makes it a candidate for component-scanning) and annotate the `ConnectionFactory` setter\nmethod with `@Autowired`. The following example shows how to do so:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component // <1>\n\tpublic class R2dbcCorporateEventDao implements CorporateEventDao {\n\n private DatabaseClient databaseClient;\n\n @Autowired // <2>\n public void setConnectionFactory(ConnectionFactory connectionFactory) {\n this.databaseClient = DatabaseClient.create(connectionFactory); // <3>\n }\n\n // R2DBC-backed implementations of the methods on the CorporateEventDao follow...\n\t}\n----\n<1> Annotate the class with `@Component`.\n<2> Annotate the `ConnectionFactory` setter method with `@Autowired`.\n<3> Create a new `DatabaseClient` with the `ConnectionFactory`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component // <1>\n\tclass R2dbcCorporateEventDao(connectionFactory: ConnectionFactory) : CorporateEventDao { // <2>\n\n private val databaseClient = DatabaseClient(connectionFactory) // <3>\n\n // R2DBC-backed implementations of the methods on the CorporateEventDao follow...\n\t}\n----\n<1> Annotate the class with `@Component`.\n<2> Constructor injection of the `ConnectionFactory`.\n<3> Create a new `DatabaseClient` with the `ConnectionFactory`.\n======\n--\n\nRegardless of which of the above template initialization styles you choose to use (or\nnot), it is seldom necessary to create a new instance of a `DatabaseClient` class each\ntime you want to run SQL. Once configured, a `DatabaseClient` instance is thread-safe.\nIf your application accesses multiple\ndatabases, you may want multiple `DatabaseClient` instances, which requires multiple\n`ConnectionFactory` and, subsequently, multiple differently configured `DatabaseClient`\ninstances.\n\n[[r2dbc-auto-generated-keys]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "`DatabaseClient` Best Practices", "heading_level": 4, "file_order": 146, "section_index": 9, "content_hash": "a50bfe8af581dbb9cfa81b8bc6d16f98e965f16b3d2e5605636439a26d22c15f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:078bb319bad28d388d249274e7f7106b5e7e9f586bf21e3d329c646693753b7c", "content": "`INSERT` statements may generate keys when inserting rows into a table\nthat defines an auto-increment or identity column. To get full control over\nthe column name to generate, simply register a `StatementFilterFunction` that\nrequests the generated key for the desired column.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMono<Integer> generatedId = client.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\")\n .filter(statement -> s.returnGeneratedValues(\"id\"))\n .map(row -> row.get(\"id\", Integer.class))\n .first();\n\n\t// generatedId emits the generated key once the INSERT statement has finished\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval generatedId = client.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\")\n .filter { statement -> s.returnGeneratedValues(\"id\") }\n .map { row -> row.get(\"id\", Integer.class) }\n .awaitOne()\n\n\t// generatedId emits the generated key once the INSERT statement has finished\n----\n======\n\n[[r2dbc-connections]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Retrieving Auto-generated Keys", "heading_level": 2, "file_order": 146, "section_index": 10, "content_hash": "078bb319bad28d388d249274e7f7106b5e7e9f586bf21e3d329c646693753b7c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:4f8e49e6cf4ccf07805abfa4123722147910b68933b8fe4cf57785003f068e4e", "content": "This section covers:\n\n* xref:data-access/r2dbc.adoc#r2dbc-ConnectionFactory[Using `ConnectionFactory`]\n* xref:data-access/r2dbc.adoc#r2dbc-ConnectionFactoryUtils[Using `ConnectionFactoryUtils`]\n* xref:data-access/r2dbc.adoc#r2dbc-SingleConnectionFactory[Using `SingleConnectionFactory`]\n* xref:data-access/r2dbc.adoc#r2dbc-TransactionAwareConnectionFactoryProxy[Using `TransactionAwareConnectionFactoryProxy`]\n* xref:data-access/r2dbc.adoc#r2dbc-R2dbcTransactionManager[Using `R2dbcTransactionManager`]\n\n[[r2dbc-ConnectionFactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Controlling Database Connections", "heading_level": 2, "file_order": 146, "section_index": 11, "content_hash": "4f8e49e6cf4ccf07805abfa4123722147910b68933b8fe4cf57785003f068e4e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:3cb0268d87ab3980f5f74893b4a0b2589bf2667bc0240ee38cc89cf309cf6fe7", "content": "Spring obtains an R2DBC connection to the database through a `ConnectionFactory`.\nA `ConnectionFactory` is part of the R2DBC specification and is a common entry-point\nfor drivers. It lets a container or a framework hide connection pooling\nand transaction management issues from the application code. As a developer,\nyou need not know details about how to connect to the database. That is the\nresponsibility of the administrator who sets up the `ConnectionFactory`. You\nmost likely fill both roles as you develop and test code, but you do not\nnecessarily have to know how the production data source is configured.\n\nWhen you use Spring's R2DBC layer, you can configure your own with a\nconnection pool implementation provided by a third party. A popular\nimplementation is R2DBC Pool (`r2dbc-pool`). Implementations in the Spring\ndistribution are meant only for testing purposes and do not provide pooling.\n\nTo configure a `ConnectionFactory`:\n\n. Obtain a connection with `ConnectionFactory` as you typically obtain an R2DBC `ConnectionFactory`.\n. Provide an R2DBC URL\n(See the documentation for your driver for the correct value).\n\nThe following example shows how to configure a `ConnectionFactory`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tConnectionFactory factory = ConnectionFactories.get(\"r2dbc:h2:mem:///test?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval factory = ConnectionFactories.get(\"r2dbc:h2:mem:///test?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE\");\n----\n======\n\n[[r2dbc-ConnectionFactoryUtils]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Using `ConnectionFactory`", "heading_level": 3, "file_order": 146, "section_index": 12, "content_hash": "3cb0268d87ab3980f5f74893b4a0b2589bf2667bc0240ee38cc89cf309cf6fe7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:cd8235d151a28f3284b4cf96a497f8e97bc59fa7a333e9f478fc93c3578e41b7", "content": "The `ConnectionFactoryUtils` class is a convenient and powerful helper class\nthat provides `static` methods to obtain connections from `ConnectionFactory`\nand close connections (if necessary).\n\nIt supports subscriber ``Context``-bound connections with, for example\n`R2dbcTransactionManager`.\n\n[[r2dbc-SingleConnectionFactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Using `ConnectionFactoryUtils`", "heading_level": 3, "file_order": 146, "section_index": 13, "content_hash": "cd8235d151a28f3284b4cf96a497f8e97bc59fa7a333e9f478fc93c3578e41b7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:9a26e08077767fb7b8352650018724d53799cdfc297375a3e80322a92ad06cd6", "content": "The `SingleConnectionFactory` class is an implementation of `DelegatingConnectionFactory`\ninterface that wraps a single `Connection` that is not closed after each use.\n\nIf any client code calls `close` on the assumption of a pooled connection (as when using\npersistence tools), you should set the `suppressClose` property to `true`. This setting\nreturns a close-suppressing proxy that wraps the physical connection. Note that you can\nno longer cast this to a native `Connection` or a similar object.\n\n`SingleConnectionFactory` is primarily a test class and may be used for specific requirements\nsuch as pipelining if your R2DBC driver permits for such use.\nIn contrast to a pooled `ConnectionFactory`, it reuses the same connection all the time, avoiding\nexcessive creation of physical connections.\n\n[[r2dbc-TransactionAwareConnectionFactoryProxy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Using `SingleConnectionFactory`", "heading_level": 3, "file_order": 146, "section_index": 14, "content_hash": "9a26e08077767fb7b8352650018724d53799cdfc297375a3e80322a92ad06cd6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:4e2448d3ae65f8390d8d0d751f6450558fd128dd542eac4e40a3c299ddacd58c", "content": "`TransactionAwareConnectionFactoryProxy` is a proxy for a target `ConnectionFactory`.\nThe proxy wraps that target `ConnectionFactory` to add awareness of Spring-managed transactions.\n\nNOTE: Using this class is required if you use a R2DBC client that is not integrated otherwise\nwith Spring's R2DBC support. In this case, you can still use this client and, at\nthe same time, have this client participating in Spring managed transactions. It is generally\npreferable to integrate a R2DBC client with proper access to `ConnectionFactoryUtils`\nfor resource management.\n\nSee the {spring-framework-api}/r2dbc/connection/TransactionAwareConnectionFactoryProxy.html[`TransactionAwareConnectionFactoryProxy`]\njavadoc for more details.\n\n[[r2dbc-R2dbcTransactionManager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Using `TransactionAwareConnectionFactoryProxy`", "heading_level": 3, "file_order": 146, "section_index": 15, "content_hash": "4e2448d3ae65f8390d8d0d751f6450558fd128dd542eac4e40a3c299ddacd58c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:d2a0cc6b3825f022e235a8816ecbedc4a986b284d8ebb20ea0d1be915dba3543", "content": "The `R2dbcTransactionManager` class is a `ReactiveTransactionManager` implementation for\na single R2DBC `ConnectionFactory`. It binds an R2DBC `Connection` from the specified\n`ConnectionFactory` to the subscriber `Context`, potentially allowing for one subscriber\n`Connection` for each `ConnectionFactory`.\n\nApplication code is required to retrieve the R2DBC `Connection` through\n`ConnectionFactoryUtils.getConnection(ConnectionFactory)`, instead of R2DBC's standard\n`ConnectionFactory.create()`. All framework classes (such as `DatabaseClient`) use this\nstrategy implicitly. If not used with a transaction manager, the lookup strategy behaves\nexactly like `ConnectionFactory.create()` and can therefore be used in any case.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc", "title": "r2dbc", "heading": "Using `R2dbcTransactionManager`", "heading_level": 3, "file_order": 146, "section_index": 16, "content_hash": "d2a0cc6b3825f022e235a8816ecbedc4a986b284d8ebb20ea0d1be915dba3543", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/r2dbc.adoc"}}
{"id": "sha256:3f9257ddead4f435f1a6cc836f0709ba684c1f2d44f3b9836d134951b9fa7533", "content": "[[transaction]]\n\nComprehensive transaction support is among the most compelling reasons to use the Spring\nFramework. The Spring Framework provides a consistent abstraction for transaction\nmanagement that delivers the following benefits:\n\n* A consistent programming model across different transaction APIs, such as Java\n Transaction API (JTA), JDBC, Hibernate, and the Java Persistence API (JPA).\n* Support for xref:data-access/transaction/declarative.adoc[declarative transaction management].\n* A simpler API for xref:data-access/transaction/programmatic.adoc[programmatic] transaction management\n than complex transaction APIs, such as JTA.\n* Excellent integration with Spring's data access abstractions.\n\nThe following sections describe the Spring Framework's transaction features and technologies:\n\n* xref:data-access/transaction/motivation.adoc[Advantages of the Spring Framework's transaction support model]\n describes why you would use the Spring Framework's transaction abstraction instead of EJB\n Container-Managed Transactions (CMT) or choosing to drive transactions through a proprietary API.\n* xref:data-access/transaction/strategies.adoc[Understanding the Spring Framework transaction abstraction]\n outlines the core classes and describes how to configure and obtain `DataSource` instances\n from a variety of sources.\n* xref:data-access/transaction/tx-resource-synchronization.adoc[Synchronizing resources with transactions]\n describes how the application code ensures that resources are created, reused, and cleaned up properly.\n* xref:data-access/transaction/declarative.adoc[Declarative transaction management] describes support for\n declarative transaction management.\n* xref:data-access/transaction/programmatic.adoc[Programmatic transaction management] covers support for\n programmatic (that is, explicitly coded) transaction management.\n* xref:data-access/transaction/event.adoc[Transaction bound event] describes how you could use application\n events within a transaction.\n\nThe chapter also includes discussions of best practices,\nxref:data-access/transaction/application-server-integration.adoc[application server integration],\nand xref:data-access/transaction/solutions-to-common-problems.adoc[solutions to common problems].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access/transaction.adoc", "title": "transaction", "heading": "transaction", "heading_level": 1, "file_order": 147, "section_index": 0, "content_hash": "3f9257ddead4f435f1a6cc836f0709ba684c1f2d44f3b9836d134951b9fa7533", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access/transaction.adoc"}}
{"id": "sha256:ddc4b4dbc4f9a58a095d3a9502089f2ad31c2e919611fd0e32381558bac6340e", "content": "[[cache-annotations]]\n\nFor caching declaration, Spring's caching abstraction provides a set of Java annotations:\n\n* `@Cacheable`: Triggers cache population.\n* `@CacheEvict`: Triggers cache eviction.\n* `@CachePut`: Updates the cache without interfering with the method execution.\n* `@Caching`: Regroups multiple cache operations to be applied on a method.\n* `@CacheConfig`: Shares some common cache-related settings at class-level.\n\n[[cache-annotations-cacheable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "annotations", "heading_level": 1, "file_order": 148, "section_index": 0, "content_hash": "ddc4b4dbc4f9a58a095d3a9502089f2ad31c2e919611fd0e32381558bac6340e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:c609e926514b185ba9a1a587d370233edc137623cb183eb524afea6fcedf78ac", "content": "As the name implies, you can use `@Cacheable` to demarcate methods that are cacheable --\nthat is, methods for which the result is stored in the cache so that, on subsequent\ninvocations (with the same arguments), the value in the cache is returned without\nhaving to actually invoke the method. In its simplest form, the annotation declaration\nrequires the name of the cache associated with the annotated method, as the following\nexample shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(\"books\")\n\tpublic Book findBook(ISBN isbn) {...}\n----\n\nIn the preceding snippet, the `findBook` method is associated with the cache named `books`.\nEach time the method is called, the cache is checked to see whether the invocation has\nalready been run and does not have to be repeated. While in most cases, only one\ncache is declared, the annotation lets multiple names be specified so that more than one\ncache is being used. In this case, each of the caches is checked before invoking the\nmethod -- if at least one cache is hit, the associated value is returned.\n\nNOTE: All the other caches that do not contain the value are also updated, even though\nthe cached method was not actually invoked.\n\nThe following example uses `@Cacheable` on the `findBook` method with multiple caches:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable({\"books\", \"isbns\"})\n\tpublic Book findBook(ISBN isbn) {...}\n----\n\n[[cache-annotations-cacheable-default-key]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "The `@Cacheable` Annotation", "heading_level": 2, "file_order": 148, "section_index": 1, "content_hash": "c609e926514b185ba9a1a587d370233edc137623cb183eb524afea6fcedf78ac", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:c2c946685e1fa245269235dfbffe54767fbb8f76da1b24cda86469bfc3fb7b49", "content": "Since caches are essentially key-value stores, each invocation of a cached method\nneeds to be translated into a suitable key for cache access. The caching abstraction\nuses a simple `KeyGenerator` based on the following algorithm:\n\n* If no parameters are given, return `SimpleKey.EMPTY`.\n* If only one parameter is given, return that instance.\n* If more than one parameter is given, return a `SimpleKey` that contains all parameters.\n\nThis approach works well for most use-cases, as long as parameters have natural keys\nand implement valid `hashCode()` and `equals()` methods. If that is not the case,\nyou need to change the strategy.\n\nTo provide a different default key generator, you need to implement the\n`org.springframework.cache.interceptor.KeyGenerator` interface.\n\n[NOTE]\n====\nThe default key generation strategy changed with the release of Spring 4.0. Earlier\nversions of Spring used a key generation strategy that, for multiple key parameters,\nconsidered only the `hashCode()` of parameters and not `equals()`. This could cause\nunexpected key collisions (see {spring-framework-issues}/14870[spring-framework#14870]\nfor background). The new `SimpleKeyGenerator` uses a compound key for such scenarios.\n\nIf you want to keep using the previous key strategy, you can configure the deprecated\n`org.springframework.cache.interceptor.DefaultKeyGenerator` class or create a custom\nhash-based `KeyGenerator` implementation.\n====\n\n[[cache-annotations-cacheable-key]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "Default Key Generation", "heading_level": 3, "file_order": 148, "section_index": 2, "content_hash": "c2c946685e1fa245269235dfbffe54767fbb8f76da1b24cda86469bfc3fb7b49", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:9527a2803450bf1346b7d9ed1d44dcfaa80f4bc31c71d6a74e202fa65aa73d06", "content": "Since caching is generic, the target methods are quite likely to have various signatures\nthat cannot be readily mapped on top of the cache structure. This tends to become obvious\nwhen the target method has multiple arguments out of which only some are suitable for\ncaching (while the rest are used only by the method logic). Consider the following example:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(\"books\")\n\tpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\n----\n\nAt first glance, while the two `boolean` arguments influence the way the book is found,\nthey are no use for the cache. Furthermore, what if only one of the two is important\nwhile the other is not?\n\nFor such cases, the `@Cacheable` annotation lets you specify how the key is generated\nthrough its `key` attribute. You can use xref:core/expressions.adoc[SpEL] to pick the\narguments of interest (or their nested properties), perform operations, or even\ninvoke arbitrary methods without having to write any code or implement any interface.\nThis is the recommended approach over the\nxref:integration/cache/annotations.adoc#cache-annotations-cacheable-default-key[default generator],\nsince methods tend to be quite different in signatures as the code base grows. While the\ndefault strategy might work for some methods, it rarely works for all methods.\n\nThe following examples use various SpEL declarations (if you are not familiar with SpEL,\ndo yourself a favor and read xref:core/expressions.adoc[Spring Expression Language]):\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(cacheNames=\"books\", key=\"#isbn\")\n\tpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\n\n\t@Cacheable(cacheNames=\"books\", key=\"#isbn.rawNumber\")\n\tpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\n\n\t@Cacheable(cacheNames=\"books\", key=\"T(someType).hash(#isbn)\")\n\tpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\n----\n\nThe preceding snippets show how easy it is to select a certain argument, one of its\nproperties, or even an arbitrary (static) method.\n\nIf the algorithm responsible for generating the key is too specific or if it needs\nto be shared, you can define a custom `keyGenerator` on the operation. To do so,\nspecify the name of the `KeyGenerator` bean implementation to use, as the following\nexample shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(cacheNames=\"books\", keyGenerator=\"myKeyGenerator\")\n\tpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\n----\n\nNOTE: The `key` and `keyGenerator` parameters are mutually exclusive and an operation\nthat specifies both results in an exception.\n\n[[cache-annotations-cacheable-default-cache-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "Custom Key Generation Declaration", "heading_level": 3, "file_order": 148, "section_index": 3, "content_hash": "9527a2803450bf1346b7d9ed1d44dcfaa80f4bc31c71d6a74e202fa65aa73d06", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:e79c6f1b4b05cc85e4c8138edab5efc44b66378244e7ccee9ac6cdcd46e9c4c9", "content": "The caching abstraction uses a simple `CacheResolver` that retrieves the caches\ndefined at the operation level by using the configured `CacheManager`.\n\nTo provide a different default cache resolver, you need to implement the\n`org.springframework.cache.interceptor.CacheResolver` interface.\n\n[[cache-annotations-cacheable-cache-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "Default Cache Resolution", "heading_level": 3, "file_order": 148, "section_index": 4, "content_hash": "e79c6f1b4b05cc85e4c8138edab5efc44b66378244e7ccee9ac6cdcd46e9c4c9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:f56089cbabb40bc6326c03e5b3361c06c97a1848d0ac50fa2f45ef959b8eb0fa", "content": "The default cache resolution fits well for applications that work with a\nsingle `CacheManager` and have no complex cache resolution requirements.\n\nFor applications that work with several cache managers, you can set the\n`cacheManager` to use for each operation, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(cacheNames=\"books\", cacheManager=\"anotherCacheManager\") <1>\n\tpublic Book findBook(ISBN isbn) {...}\n----\n<1> Specifying `anotherCacheManager`.\n\nYou can also replace the `CacheResolver` entirely in a fashion similar to that of\nreplacing xref:integration/cache/annotations.adoc#cache-annotations-cacheable-key[key generation].\nThe resolution is requested for every cache operation, letting the implementation\nactually resolve the caches to use based on runtime arguments. The following example\nshows how to specify a `CacheResolver`:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(cacheResolver=\"runtimeCacheResolver\") <1>\n\tpublic Book findBook(ISBN isbn) {...}\n----\n<1> Specifying the `CacheResolver`.\n\n[NOTE]\n====\nSince Spring 4.1, the `value` attribute of the cache annotations are no longer\nmandatory, since this particular information can be provided by the `CacheResolver`\nregardless of the content of the annotation.\n\nSimilarly to `key` and `keyGenerator`, the `cacheManager` and `cacheResolver`\nparameters are mutually exclusive, and an operation specifying both\nresults in an exception, as a custom `CacheManager` is ignored by the\n`CacheResolver` implementation. This is probably not what you expect.\n====\n\n[[cache-annotations-cacheable-synchronized]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "Custom Cache Resolution", "heading_level": 3, "file_order": 148, "section_index": 5, "content_hash": "f56089cbabb40bc6326c03e5b3361c06c97a1848d0ac50fa2f45ef959b8eb0fa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:565a23da78a152ec2157196bf001c3dab4c3913e298f80c8494d389fb4f6cdd0", "content": "In a multi-threaded environment, certain operations might be concurrently invoked for\nthe same argument (typically on startup). By default, the cache abstraction does not\nlock anything, and the same value may be computed several times, defeating the purpose\nof caching.\n\nFor those particular cases, you can use the `sync` attribute to instruct the underlying\ncache provider to lock the cache entry while the value is being computed. As a result,\nonly one thread is busy computing the value, while the others are blocked until the entry\nis updated in the cache. The following example shows how to use the `sync` attribute:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(cacheNames=\"foos\", sync=true) <1>\n\tpublic Foo executeExpensiveOperation(String id) {...}\n----\n<1> Using the `sync` attribute.\n\nNOTE: This is an optional feature, and your favorite cache library may not support it.\nAll `CacheManager` implementations provided by the core framework support it. See the\ndocumentation of your cache provider for more details.\n\n[[cache-annotations-cacheable-reactive]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "Synchronized Caching", "heading_level": 3, "file_order": 148, "section_index": 6, "content_hash": "565a23da78a152ec2157196bf001c3dab4c3913e298f80c8494d389fb4f6cdd0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:3b7f0e090f8e1b9cfda75cb99db56acb0cac61e463f341d28688e017269eb365", "content": "As of 6.1, cache annotations take `CompletableFuture` and reactive return types\ninto account, automatically adapting the cache interaction accordingly.\n\nFor a method returning a `CompletableFuture`, the object produced by that future\nwill be cached whenever it is complete, and the cache lookup for a cache hit will\nbe retrieved via a `CompletableFuture`:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(\"books\")\n\tpublic CompletableFuture<Book> findBook(ISBN isbn) {...}\n----\n\nFor a method returning a Reactor `Mono`, the object emitted by that Reactive Streams\npublisher will be cached whenever it is available, and the cache lookup for a cache\nhit will be retrieved as a `Mono` (backed by a `CompletableFuture`):\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(\"books\")\n\tpublic Mono<Book> findBook(ISBN isbn) {...}\n----\n\nFor a method returning a Reactor `Flux`, the objects emitted by that Reactive Streams\npublisher will be collected into a `List` and cached whenever that list is complete,\nand the cache lookup for a cache hit will be retrieved as a `Flux` (backed by a\n`CompletableFuture` for the cached `List` value):\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(\"books\")\n\tpublic Flux<Book> findBooks(String author) {...}\n----\n\nSuch `CompletableFuture` and reactive adaptation also works for synchronized caching,\ncomputing the value only once in case of a concurrent cache miss:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(cacheNames=\"foos\", sync=true) <1>\n\tpublic CompletableFuture<Foo> executeExpensiveOperation(String id) {...}\n----\n<1> Using the `sync` attribute.\n\nNOTE: In order for such an arrangement to work at runtime, the configured cache\nneeds to be capable of `CompletableFuture`-based retrieval. The Spring-provided\n`ConcurrentMapCacheManager` automatically adapts to that retrieval style, and\n`CaffeineCacheManager` natively supports it when its asynchronous cache mode is\nenabled: set `setAsyncCacheMode(true)` on your `CaffeineCacheManager` instance.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tCacheManager cacheManager() {\n CaffeineCacheManager cacheManager = new CaffeineCacheManager();\n cacheManager.setCacheSpecification(...);\n cacheManager.setAsyncCacheMode(true);\n return cacheManager;\n\t}\n----\n\nLast but not least, be aware that annotation-driven caching is not appropriate\nfor sophisticated reactive interactions involving composition and back pressure.\nIf you choose to declare `@Cacheable` on specific reactive methods, consider the\nimpact of the rather coarse-granular cache interaction which simply stores the\nemitted object for a `Mono` or even a pre-collected list of objects for a `Flux`.\n\n[[cache-annotations-cacheable-condition]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "Caching with CompletableFuture and Reactive Return Types", "heading_level": 3, "file_order": 148, "section_index": 7, "content_hash": "3b7f0e090f8e1b9cfda75cb99db56acb0cac61e463f341d28688e017269eb365", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:20e623f45f0b03e3e3f38a0b0cc7a9cbbd98e1b4f4cdb6d9a60c877afeca5859", "content": "Sometimes, a method might not be suitable for caching all the time (for example, it might\ndepend on the given arguments). The cache annotations support such use cases through the\n`condition` parameter, which takes a `SpEL` expression that is evaluated to either `true`\nor `false`. If `true`, the method is cached. If not, it behaves as if the method is not\ncached (that is, the method is invoked every time no matter what values are in the cache\nor what arguments are used). For example, the following method is cached only if the\nargument `name` has a length shorter than 32:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(cacheNames=\"book\", condition=\"#name.length() < 32\") <1>\n\tpublic Book findBook(String name)\n----\n<1> Setting a condition on `@Cacheable`.\n\nIn addition to the `condition` parameter, you can use the `unless` parameter to veto the\nadding of a value to the cache. Unlike `condition`, `unless` expressions are evaluated\nafter the method has been invoked. To expand on the previous example, perhaps we only\nwant to cache paperback books, as the following example does:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(cacheNames=\"book\", condition=\"#name.length() < 32\", unless=\"#result.hardback\") <1>\n\tpublic Book findBook(String name)\n----\n<1> Using the `unless` attribute to block hardbacks.\n\nThe cache abstraction supports `java.util.Optional` return types. If an `Optional` value\nis _present_, it will be stored in the associated cache. If an `Optional` value is not\npresent, `null` will be stored in the associated cache. `#result` always refers to the\nbusiness entity and never a supported wrapper, so the previous example can be rewritten\nas follows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(cacheNames=\"book\", condition=\"#name.length() < 32\", unless=\"#result?.hardback\")\n\tpublic Optional<Book> findBook(String name)\n----\n\nNote that `#result` still refers to `Book` and not `Optional<Book>`. Since it might be\n`null`, we use SpEL's xref:core/expressions/language-ref/operator-safe-navigation.adoc[safe navigation operator].\n\n[[cache-spel-context]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "Conditional Caching", "heading_level": 3, "file_order": 148, "section_index": 8, "content_hash": "20e623f45f0b03e3e3f38a0b0cc7a9cbbd98e1b4f4cdb6d9a60c877afeca5859", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:f728fbe7cf16b3a1ae11ef4349f0a43fbbc56e6f68562e1f890ad9e9b1499666", "content": "Each `SpEL` expression evaluates against a dedicated xref:core/expressions/language-ref.adoc[`context`].\nIn addition to the built-in parameters, the framework provides dedicated caching-related\nmetadata, such as the argument names. The following table describes the items made\navailable to the context so that you can use them for key and conditional computations:\n\n[[cache-spel-context-tbl]]\n.Cache metadata available in SpEL expressions\n|===\n| Name| Location| Description| Example\n\n| `methodName`\n| Root object\n| The name of the method being invoked\n| `#root.methodName`\n\n| `method`\n| Root object\n| The method being invoked\n| `#root.method.name`\n\n| `target`\n| Root object\n| The target object being invoked\n| `#root.target`\n\n| `targetClass`\n| Root object\n| The class of the target being invoked\n| `#root.targetClass`\n\n| `args`\n| Root object\n| The arguments (as an object array) used for invoking the target\n| `#root.args[0]`\n\n| `caches`\n| Root object\n| Collection of caches against which the current method is run\n| `#root.caches[0].name`\n\n| Argument name\n| Evaluation context\n| The name of a particular method argument. If the names are not available\n (for example, because the code was compiled without the `-parameters` flag), individual\n arguments are also available using the `#a<#arg>` syntax where `<#arg>` stands for the\n argument index (starting from 0).\n| `#iban` or `#a0` (you can also use `#p0` or `#p<#arg>` notation as an alias).\n\n| `result`\n| Evaluation context\n| The result of the method call (the value to be cached). Only available in `unless`\n expressions, `cache put` expressions (to compute the `key`), or `cache evict`\n expressions (when `beforeInvocation` is `false`). For supported wrappers (such as\n `Optional`), `#result` refers to the actual object, not the wrapper.\n| `#result`\n|===\n\n[[cache-annotations-put]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "Available Caching SpEL Evaluation Context", "heading_level": 3, "file_order": 148, "section_index": 9, "content_hash": "f728fbe7cf16b3a1ae11ef4349f0a43fbbc56e6f68562e1f890ad9e9b1499666", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:275de2e68a2936019dc25704d042613aba84cf50418618b0653508ab03211db0", "content": "When the cache needs to be updated without interfering with the method execution,\nyou can use the `@CachePut` annotation. That is, the method is always invoked and its\nresult is placed into the cache (according to the `@CachePut` options). It supports\nthe same options as `@Cacheable` and should be used for cache population rather than\nmethod flow optimization. The following example uses the `@CachePut` annotation:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@CachePut(cacheNames=\"book\", key=\"#isbn\")\n\tpublic Book updateBook(ISBN isbn, BookDescriptor descriptor)\n----\n\nIMPORTANT: Using `@CachePut` and `@Cacheable` annotations on the same method is generally\nstrongly discouraged because they have different behaviors. While the latter causes the\nmethod invocation to be skipped by using the cache, the former forces the invocation in\norder to run a cache update. This leads to unexpected behavior and, with the exception\nof specific corner-cases (such as annotations having conditions that exclude them from each\nother), such declarations should be avoided. Note also that such conditions should not rely\non the result object (that is, the `#result` variable), as these are validated up-front to\nconfirm the exclusion.\n\nAs of 6.1, `@CachePut` takes `CompletableFuture` and reactive return types into account,\nperforming the put operation whenever the produced object is available.\n\n[[cache-annotations-evict]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "The `@CachePut` Annotation", "heading_level": 2, "file_order": 148, "section_index": 10, "content_hash": "275de2e68a2936019dc25704d042613aba84cf50418618b0653508ab03211db0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:fd3738ca14b9e0e24d13cfe239d60dc5a8cb4677be35c422c061c886b0468631", "content": "The cache abstraction allows not just population of a cache store but also eviction.\nThis process is useful for removing stale or unused data from the cache. As opposed to\n`@Cacheable`, `@CacheEvict` demarcates methods that perform cache\neviction (that is, methods that act as triggers for removing data from the cache).\nSimilarly to its sibling, `@CacheEvict` requires specifying one or more caches\nthat are affected by the action, allows a custom cache and key resolution or a\ncondition to be specified, and features an extra parameter\n(`allEntries`) that indicates whether a cache-wide eviction needs to be performed\nrather than just an entry eviction (based on the key). The following example evicts\nall entries from the `books` cache:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@CacheEvict(cacheNames=\"books\", allEntries=true) <1>\n\tpublic void loadBooks(InputStream batch)\n----\n<1> Using the `allEntries` attribute to evict all entries from the cache.\n\nThis option comes in handy when an entire cache region needs to be cleared out.\nRather than evicting each entry (which would take a long time, since it is inefficient),\nall the entries are removed in one operation, as the preceding example shows.\nNote that the framework ignores any key specified in this scenario as it does not apply\n(the entire cache is evicted, not only one entry).\n\nYou can also indicate whether the eviction should occur after (the default) or before\nthe method is invoked by using the `beforeInvocation` attribute. The former provides the\nsame semantics as the rest of the annotations: Once the method completes successfully,\nan action (in this case, eviction) on the cache is run. If the method does not\nrun (as it might be cached) or an exception is thrown, the eviction does not occur.\nThe latter (`beforeInvocation=true`) causes the eviction to always occur before the\nmethod is invoked. This is useful in cases where the eviction does not need to be tied\nto the method outcome.\n\nNote that `void` methods can be used with `@CacheEvict` - as the methods act as a\ntrigger, the return values are ignored (as they do not interact with the cache). This is\nnot the case with `@Cacheable` which adds data to the cache or updates data in the cache\nand, thus, requires a result.\n\nAs of 6.1, `@CacheEvict` takes `CompletableFuture` and reactive return types into account,\nperforming an after-invocation evict operation whenever processing has completed.\n\n[[cache-annotations-caching]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "The `@CacheEvict` Annotation", "heading_level": 2, "file_order": 148, "section_index": 11, "content_hash": "fd3738ca14b9e0e24d13cfe239d60dc5a8cb4677be35c422c061c886b0468631", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:37308839f7932e80cdee726bbd10915a96c067ff1388edf8f14ddd6656ad712c", "content": "Sometimes, multiple annotations of the same type (such as `@CacheEvict` or\n`@CachePut`) need to be specified -- for example, because the condition or the key\nexpression is different between different caches. `@Caching` lets multiple nested\n`@Cacheable`, `@CachePut`, and `@CacheEvict` annotations be used on the same method.\nThe following example uses two `@CacheEvict` annotations:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Caching(evict = { @CacheEvict(\"primary\"), @CacheEvict(cacheNames=\"secondary\", key=\"#p0\") })\n\tpublic Book importBooks(String deposit, Date date)\n----\n\n[[cache-annotations-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "The `@Caching` Annotation", "heading_level": 2, "file_order": 148, "section_index": 12, "content_hash": "37308839f7932e80cdee726bbd10915a96c067ff1388edf8f14ddd6656ad712c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:d53bf316a853cccd81d7f64ac93585b41f8e7d8b1e95f6b2c8c0fe2541e723e1", "content": "So far, we have seen that caching operations offer many customization options and that\nyou can set these options for each operation. However, some of the customization options\ncan be tedious to configure if they apply to all operations of the class. For\ninstance, specifying the name of the cache to use for every cache operation of the\nclass can be replaced by a single class-level definition. This is where `@CacheConfig`\ncomes into play. The following examples uses `@CacheConfig` to set the name of the cache:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@CacheConfig(\"books\") <1>\n\tpublic class BookRepositoryImpl implements BookRepository {\n\n @Cacheable\n public Book findBook(ISBN isbn) {...}\n\t}\n----\n<1> Using `@CacheConfig` to set the name of the cache.\n\n`@CacheConfig` is a class-level annotation that allows sharing the cache names,\nthe custom `KeyGenerator`, the custom `CacheManager`, and the custom `CacheResolver`.\nPlacing this annotation on the class does not turn on any caching operation.\n\nAn operation-level customization always overrides a customization set on `@CacheConfig`.\nTherefore, this gives three levels of customizations for each cache operation:\n\n* Globally configured, for example, through `CachingConfigurer`: see next section.\n* At the class level, using `@CacheConfig`.\n* At the operation level.\n\nNOTE: Provider-specific settings are typically available on the `CacheManager` bean,\nfor example, on `CaffeineCacheManager`. These are effectively also global.\n\n[[cache-annotation-enable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "The `@CacheConfig` Annotation", "heading_level": 2, "file_order": 148, "section_index": 13, "content_hash": "d53bf316a853cccd81d7f64ac93585b41f8e7d8b1e95f6b2c8c0fe2541e723e1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:114ae3c3c7d77a5854b2992b0df86e54094ead944d171dc57f6bb2ebbef437d1", "content": "It is important to note that even though declaring the cache annotations does not\nautomatically trigger their actions - like many things in Spring, the feature has to be\ndeclaratively enabled (which means if you ever suspect caching is to blame, you can\ndisable it by removing only one configuration line rather than all the annotations in\nyour code).\n\nTo enable caching annotations add the annotation `@EnableCaching` to one of your\n`@Configuration` classes or use the `cache:annotation-driven` element with XML:\n\ninclude-code::./CacheConfiguration[tag=snippet,indent=0]\n\nBoth the `cache:annotation-driven` element and the `@EnableCaching` annotation let you\nspecify various options that influence the way the caching behavior is added to the\napplication through AOP. The configuration is intentionally similar with that of\nxref:data-access/transaction/declarative/annotations.adoc#tx-annotation-driven-settings[`@Transactional`].\n\nNOTE: The default advice mode for processing caching annotations is `proxy`, which allows\nfor interception of calls through the proxy only. Local calls within the same class\ncannot get intercepted that way. For a more advanced mode of interception, consider\nswitching to `aspectj` mode in combination with compile-time or load-time weaving.\n\nNOTE: For more detail about advanced customizations (using Java configuration) that are\nrequired to implement `CachingConfigurer`, see the\n{spring-framework-api}/cache/annotation/CachingConfigurer.html[javadoc].\n\n[[cache-annotation-driven-settings]]\n.Cache annotation settings\n[cols=\"1,1,1,3\"]\n|===\n| XML Attribute | Annotation Attribute | Default | Description\n\n| `cache-manager`\n| N/A (see the {spring-framework-api}/cache/annotation/CachingConfigurer.html[`CachingConfigurer`] javadoc)\n| `cacheManager`\n| The name of the cache manager to use. A default `CacheResolver` is initialized behind\n the scenes with this cache manager (or `cacheManager` if not set). For more\n fine-grained management of the cache resolution, consider setting the 'cache-resolver'\n attribute.\n\n| `cache-resolver`\n| N/A (see the {spring-framework-api}/cache/annotation/CachingConfigurer.html[`CachingConfigurer`] javadoc)\n| A `SimpleCacheResolver` using the configured `cacheManager`.\n| The bean name of the CacheResolver that is to be used to resolve the backing caches.\n This attribute is not required and needs to be specified only as an alternative to\n the 'cache-manager' attribute.\n\n| `key-generator`\n| N/A (see the {spring-framework-api}/cache/annotation/CachingConfigurer.html[`CachingConfigurer`] javadoc)\n| `SimpleKeyGenerator`\n| Name of the custom key generator to use.\n\n| `error-handler`\n| N/A (see the {spring-framework-api}/cache/annotation/CachingConfigurer.html[`CachingConfigurer`] javadoc)\n| `SimpleCacheErrorHandler`\n| The name of the custom cache error handler to use. By default, any exception thrown during\n a cache related operation is thrown back at the client.\n\n| `mode`\n| `mode`\n| `proxy`\n| The default mode (`proxy`) processes annotated beans to be proxied by using Spring's AOP\n framework (following proxy semantics, as discussed earlier, applying to method calls\n coming in through the proxy only). The alternative mode (`aspectj`) instead weaves the\n affected classes with Spring's AspectJ caching aspect, modifying the target class byte\n code to apply to any kind of method call. AspectJ weaving requires `spring-aspects.jar`\n in the classpath as well as load-time weaving (or compile-time weaving) enabled. (See\n xref:core/aop/using-aspectj.adoc#aop-aj-ltw-spring[Spring configuration] for details on how to set up\n load-time weaving.)\n\n| `proxy-target-class`\n| `proxyTargetClass`\n| `false`\n| Applies to proxy mode only. Controls what type of caching proxies are created for\n classes annotated with the `@Cacheable` or `@CacheEvict` annotations. If the\n `proxy-target-class` attribute is set to `true`, class-based proxies are created.\n If `proxy-target-class` is `false` or if the attribute is omitted, standard JDK\n interface-based proxies are created. (See xref:core/aop/proxying.adoc[Proxying Mechanisms]\n for a detailed examination of the different proxy types.)\n\n| `order`\n| `order`\n| Ordered.LOWEST_PRECEDENCE\n| Defines the order of the cache advice that is applied to beans annotated with\n `@Cacheable` or `@CacheEvict`. (For more information about the rules related to\n ordering AOP advice, see xref:core/aop/ataspectj/advice.adoc#aop-ataspectj-advice-ordering[Advice Ordering].)\n No specified ordering means that the AOP subsystem determines the order of the advice.\n|===\n\nNOTE: `<cache:annotation-driven/>` looks for `@Cacheable/@CachePut/@CacheEvict/@Caching`\nonly on beans in the same application context in which it is defined. This means that,\nif you put `<cache:annotation-driven/>` in a `WebApplicationContext` for a\n`DispatcherServlet`, it checks for beans only in your controllers, not your services.\nSee xref:web/webmvc/mvc-servlet.adoc[the MVC section] for more information.\n\n.Method visibility and cache annotations\n****\nWhen you use proxies, you should apply the cache annotations only to methods with\npublic visibility. If you do annotate protected, private, or package-visible methods\nwith these annotations, no error is raised, but the annotated method does not exhibit\nthe configured caching settings. Consider using AspectJ (see the rest of this section)\nif you need to annotate non-public methods, as it changes the bytecode itself.\n****\n\nTIP: Spring recommends that you only annotate concrete classes (and methods of concrete\nclasses) with the `@Cache{asterisk}` annotations, as opposed to annotating interfaces.\nYou certainly can place an `@Cache{asterisk}` annotation on an interface (or an interface\nmethod), but this works only if you use the proxy mode (`mode=\"proxy\"`). If you use the\nweaving-based aspect (`mode=\"aspectj\"`), the caching settings are not recognized on\ninterface-level declarations by the weaving infrastructure.\n\nNOTE: In proxy mode (the default), only external method calls coming in through the\nproxy are intercepted. This means that self-invocation (in effect, a method within the\ntarget object that calls another method of the target object) does not lead to actual\ncaching at runtime even if the invoked method is marked with `@Cacheable`. Consider\nusing the `aspectj` mode in this case. Also, the proxy must be fully initialized to\nprovide the expected behavior, so you should not rely on this feature in your\ninitialization code (that is, `@PostConstruct`).\n\n[[cache-annotation-stereotype]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "Enabling Caching Annotations", "heading_level": 2, "file_order": 148, "section_index": 14, "content_hash": "114ae3c3c7d77a5854b2992b0df86e54094ead944d171dc57f6bb2ebbef437d1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:cec57a91339c0bddf6fd4716b16823df049168013913d25f0c93dc658eb97dca", "content": ".Custom annotation and AspectJ\n****\nThis feature works only with the proxy-based approach but can be enabled\nwith a bit of extra effort by using AspectJ.\n\nThe `spring-aspects` module defines an aspect for the standard annotations only.\nIf you have defined your own annotations, you also need to define an aspect for\nthose. Check `AnnotationCacheAspect` for an example.\n****\n\nThe caching abstraction lets you use your own annotations to identify what method\ntriggers cache population or eviction. This is quite handy as a template mechanism,\nas it eliminates the need to duplicate cache annotation declarations, which is\nespecially useful if the key or condition are specified or if the foreign imports\n(`org.springframework`) are not allowed in your code base. Similarly to the rest\nof the xref:core/beans/classpath-scanning.adoc#beans-stereotype-annotations[stereotype]\nannotations, you can use `@Cacheable`, `@CachePut`, `@CacheEvict`, and `@CacheConfig`\nas xref:core/beans/classpath-scanning.adoc#beans-meta-annotations[meta-annotations]\n(that is, annotations that can annotate other annotations). In the following example,\nwe replace a common `@Cacheable` declaration with our own custom annotation:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Target({ElementType.METHOD})\n\t@Cacheable(cacheNames=\"books\", key=\"#isbn\")\n\tpublic @interface SlowService {\n\t}\n----\n\nIn the preceding example, we have defined our own `SlowService` annotation,\nwhich itself is annotated with `@Cacheable`. Now we can replace the following code:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(cacheNames=\"books\", key=\"#isbn\")\n\tpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\n----\n\nThe following example shows the custom annotation with which we can replace the\npreceding code:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SlowService\n\tpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\n----\n\nEven though `@SlowService` is not a Spring annotation, the container automatically picks\nup its declaration at runtime and understands its meaning. Note that, as mentioned\nxref:integration/cache/annotations.adoc#cache-annotation-enable[earlier],\nannotation-driven behavior needs to be enabled.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc", "title": "annotations", "heading": "Using Custom Annotations", "heading_level": 2, "file_order": 148, "section_index": 15, "content_hash": "cec57a91339c0bddf6fd4716b16823df049168013913d25f0c93dc658eb97dca", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/annotations.adoc"}}
{"id": "sha256:a525c59d2ff39d353592214e4e2abe929940762d7937debd5f32f349de0543a1", "content": "[[cache-declarative-xml]]\n\nIf annotations are not an option (perhaps due to having no access to the sources\nor no external code), you can use XML for declarative caching. So, instead of\nannotating the methods for caching, you can specify the target method and the\ncaching directives externally (similar to the declarative transaction management\nxref:data-access/transaction/declarative/first-example.adoc[advice]). The example\nfrom the previous section can be translated into the following example:\n\n[source,xml,indent=0]\n[subs=\"verbatim\"]\n----\n\t<!-- the service we want to make cacheable -->\n\t<bean id=\"bookService\" class=\"x.y.service.DefaultBookService\"/>\n\n\t<!-- cache definitions -->\n\t<cache:advice id=\"cacheAdvice\" cache-manager=\"cacheManager\">\n <cache:caching cache=\"books\">\n <cache:cacheable method=\"findBook\" key=\"#isbn\"/>\n <cache:cache-evict method=\"loadBooks\" all-entries=\"true\"/>\n </cache:caching>\n\t</cache:advice>\n\n\t<!-- apply the cacheable behavior to all BookService interfaces -->\n\t<aop:config>\n <aop:advisor advice-ref=\"cacheAdvice\" pointcut=\"execution(* x.y.BookService.*(..))\"/>\n\t</aop:config>\n\n\t<!-- cache manager definition omitted -->\n----\n\nIn the preceding configuration, the `bookService` is made cacheable. The caching semantics\nto apply are encapsulated in the `cache:advice` definition, which causes the `findBooks`\nmethod to be used for putting data into the cache and the `loadBooks` method for evicting\ndata. Both definitions work against the `books` cache.\n\nThe `aop:config` definition applies the cache advice to the appropriate points in the\nprogram by using the AspectJ pointcut expression (more information is available in\nxref:core/aop.adoc[Aspect Oriented Programming with Spring]). In the preceding example,\nall methods from the `BookService` are considered and the cache advice is applied to them.\n\nThe declarative XML caching supports all of the annotation-based model, so moving between\nthe two should be fairly easy. Furthermore, both can be used inside the same application.\nThe XML-based approach does not touch the target code. However, it is inherently more\nverbose. When dealing with classes that have overloaded methods that are targeted for\ncaching, identifying the proper methods does take an extra effort, since the `method`\nargument is not a good discriminator. In these cases, you can use the AspectJ pointcut\nto cherry pick the target methods and apply the appropriate caching functionality.\nHowever, through XML, it is easier to apply package or group or interface-wide caching\n(again, due to the AspectJ pointcut) and to create template-like definitions (as we did\nin the preceding example by defining the target cache through the `cache:definitions`\n`cache` attribute).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/declarative-xml.adoc", "title": "declarative-xml", "heading": "declarative-xml", "heading_level": 1, "file_order": 149, "section_index": 0, "content_hash": "a525c59d2ff39d353592214e4e2abe929940762d7937debd5f32f349de0543a1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/declarative-xml.adoc"}}
{"id": "sha256:6ac843cbd003f97991f0b953fe5f93094da1fddd26d8c13910293f7bd08be14d", "content": "[[cache-jsr-107]]\n\nSince version 4.1, Spring's caching abstraction fully supports the JCache standard\n(JSR-107) annotations: `@CacheResult`, `@CachePut`, `@CacheRemove`, and `@CacheRemoveAll`\nas well as the `@CacheDefaults`, `@CacheKey`, and `@CacheValue` companions.\nYou can use these annotations even without migrating your cache store to JSR-107.\nThe internal implementation uses Spring's caching abstraction and provides default\n`CacheResolver` and `KeyGenerator` implementations that are compliant with the\nspecification. In other words, if you are already using Spring's caching abstraction,\nyou can switch to these standard annotations without changing your cache storage\n(or configuration, for that matter).\n\n[[cache-jsr-107-summary]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/jsr-107.adoc", "title": "jsr-107", "heading": "jsr-107", "heading_level": 1, "file_order": 150, "section_index": 0, "content_hash": "6ac843cbd003f97991f0b953fe5f93094da1fddd26d8c13910293f7bd08be14d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/jsr-107.adoc"}}
{"id": "sha256:f6a94542af9cee408e00237691ae506e9be62d9eb83ec73ada3a9a9b03deb4d1", "content": "For those who are familiar with Spring's caching annotations, the following table\ndescribes the main differences between the Spring annotations and their JSR-107\ncounterparts:\n\n.Spring vs. JSR-107 caching annotations\n[cols=\"1,1,3\"]\n|===\n| Spring | JSR-107 | Remark\n\n| `@Cacheable`\n| `@CacheResult`\n| Fairly similar. `@CacheResult` can cache specific exceptions and force the\n execution of the method regardless of the content of the cache.\n\n| `@CachePut`\n| `@CachePut`\n| While Spring updates the cache with the result of the method invocation, JCache\n requires that it be passed it as an argument that is annotated with `@CacheValue`.\n Due to this difference, JCache allows updating the cache before or after the\n actual method invocation.\n\n| `@CacheEvict`\n| `@CacheRemove`\n| Fairly similar. `@CacheRemove` supports conditional eviction when the\n method invocation results in an exception.\n\n| `@CacheEvict(allEntries=true)`\n| `@CacheRemoveAll`\n| See `@CacheRemove`.\n\n| `@CacheConfig`\n| `@CacheDefaults`\n| Lets you configure the same concepts, in a similar fashion.\n|===\n\nJCache has the notion of `javax.cache.annotation.CacheResolver`, which is identical\nto the Spring's `CacheResolver` interface, except that JCache supports only a single\ncache. By default, a simple implementation retrieves the cache to use based on the\nname declared on the annotation. It should be noted that, if no cache name is\nspecified on the annotation, a default is automatically generated. See the javadoc\nof `@CacheResult#cacheName()` for more information.\n\n`CacheResolver` instances are retrieved by a `CacheResolverFactory`. It is possible\nto customize the factory for each cache operation, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@CacheResult(cacheNames=\"books\", cacheResolverFactory=MyCacheResolverFactory.class) <1>\n\tpublic Book findBook(ISBN isbn)\n----\n<1> Customizing the factory for this operation.\n\nNOTE: For all referenced classes, Spring tries to locate a bean with the given type.\nIf more than one match exists, a new instance is created and can use the regular\nbean lifecycle callbacks, such as dependency injection.\n\nKeys are generated by a `javax.cache.annotation.CacheKeyGenerator` that serves the\nsame purpose as Spring's `KeyGenerator`. By default, all method arguments are taken\ninto account, unless at least one parameter is annotated with `@CacheKey`. This is\nsimilar to Spring's xref:integration/cache/annotations.adoc#cache-annotations-cacheable-key[custom key generation declaration]\n. For instance, the following are identical operations, one using\nSpring's abstraction and the other using JCache:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Cacheable(cacheNames=\"books\", key=\"#isbn\")\n\tpublic Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)\n\n\t@CacheResult(cacheName=\"books\")\n\tpublic Book findBook(@CacheKey ISBN isbn, boolean checkWarehouse, boolean includeUsed)\n----\n\nYou can also specify the `CacheKeyResolver` on the operation, similar to how you can\nspecify the `CacheResolverFactory`.\n\nJCache can manage exceptions thrown by annotated methods. This can prevent an update of\nthe cache, but it can also cache the exception as an indicator of the failure instead of\ncalling the method again. Assume that `InvalidIsbnNotFoundException` is thrown if the\nstructure of the ISBN is invalid. This is a permanent failure (no book could ever be\nretrieved with such a parameter). The following caches the exception so that further\ncalls with the same, invalid, ISBN throw the cached exception directly instead of\ninvoking the method again:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@CacheResult(cacheName=\"books\", exceptionCacheName=\"failures\"\n cachedExceptions = InvalidIsbnNotFoundException.class)\n\tpublic Book findBook(ISBN isbn)\n----\n\n[[enabling-jsr-107-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/jsr-107.adoc", "title": "jsr-107", "heading": "Feature Summary", "heading_level": 2, "file_order": 150, "section_index": 1, "content_hash": "f6a94542af9cee408e00237691ae506e9be62d9eb83ec73ada3a9a9b03deb4d1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/jsr-107.adoc"}}
{"id": "sha256:8bd8555e2597d91a218a795799867876f8bd62a1b0173c34c9b39b718235ece2", "content": "You do not need to do anything specific to enable the JSR-107 support alongside Spring's\ndeclarative annotation support. Both `@EnableCaching` and the `cache:annotation-driven`\nXML element automatically enable the JCache support if both the JSR-107 API and the\n`spring-context-support` module are present in the classpath.\n\nNOTE: Depending on your use case, the choice is basically yours. You can even mix and\nmatch services by using the JSR-107 API on some and using Spring's own annotations on\nothers. However, if these services impact the same caches, you should use a consistent\nand identical key generation implementation.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/jsr-107.adoc", "title": "jsr-107", "heading": "Enabling JSR-107 Support", "heading_level": 2, "file_order": 150, "section_index": 2, "content_hash": "8bd8555e2597d91a218a795799867876f8bd62a1b0173c34c9b39b718235ece2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/jsr-107.adoc"}}
{"id": "sha256:d531a2c68819c03899a8fff4ae461b0f2d369ebf901ba779b7cfa992ce8310d9", "content": "[[cache-plug]]\n\nClearly, there are plenty of caching products out there that you can use as a backing\nstore. For those that do not support JSR-107 you need to provide a `CacheManager` and a\n`Cache` implementation. This may sound harder than it is, since, in practice, the classes\ntend to be simple https://en.wikipedia.org/wiki/Adapter_pattern[adapters] that map the\ncaching abstraction framework on top of the storage API, as the _Caffeine_ classes do.\nMost `CacheManager` classes can use the classes in the\n`org.springframework.cache.support` package (such as `AbstractCacheManager` which takes\ncare of the boiler-plate code, leaving only the actual mapping to be completed).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/plug.adoc", "title": "plug", "heading": "plug", "heading_level": 1, "file_order": 151, "section_index": 0, "content_hash": "d531a2c68819c03899a8fff4ae461b0f2d369ebf901ba779b7cfa992ce8310d9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/plug.adoc"}}
{"id": "sha256:7c3692273e5f5fb2b703756d74ab1b0155c480d09f2f73264287a9245217231c", "content": "[[cache-specific-config]]\n\nDirectly through your cache provider. The cache abstraction is an abstraction,\nnot a cache implementation. The solution you use might support various data\npolicies and different topologies that other solutions do not support (for example,\nthe JDK `ConcurrentHashMap` -- exposing that in the cache abstraction would be useless\nbecause there would no backing support). Such functionality should be controlled\ndirectly through the backing cache (when configuring it) or through its native API.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/specific-config.adoc", "title": "specific-config", "heading": "specific-config", "heading_level": 1, "file_order": 152, "section_index": 0, "content_hash": "7c3692273e5f5fb2b703756d74ab1b0155c480d09f2f73264287a9245217231c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/specific-config.adoc"}}
{"id": "sha256:b46ba5f5ba628c6977002a5807a11a655381204d102bf13e665d76c55ecfa0bd", "content": "[[cache-store-configuration]]\n\nThe cache abstraction provides several storage integration options. To use them, you need\nto declare an appropriate `CacheManager` (an entity that controls and manages `Cache`\ninstances and that can be used to retrieve these for storage).\n\n[[cache-store-configuration-jdk]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc", "title": "store-configuration", "heading": "store-configuration", "heading_level": 1, "file_order": 153, "section_index": 0, "content_hash": "b46ba5f5ba628c6977002a5807a11a655381204d102bf13e665d76c55ecfa0bd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc"}}
{"id": "sha256:884f61d092858cc6e7a3f94b2ed33400768fc436384d986e966b3fb0313d3562", "content": "The JDK-based `Cache` implementation resides under\n`org.springframework.cache.concurrent` package. It lets you use `ConcurrentHashMap`\nas a backing `Cache` store. The following example shows how to configure two caches:\n\ninclude-code::./CacheConfiguration[tag=snippet,indent=0]\n\nThe preceding snippet uses the `SimpleCacheManager` to create a `CacheManager` for the\ntwo nested `ConcurrentMapCache` instances named `default` and `books`. Note that the\nnames are configured directly for each cache.\n\nAs the cache is created by the application, it is bound to its lifecycle, making it\nsuitable for basic use cases, tests, or simple applications. The cache scales well\nand is very fast, but it does not provide any management, persistence capabilities,\nor eviction contracts.\n\n[[cache-store-configuration-eviction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc", "title": "store-configuration", "heading": "JDK `ConcurrentMap`-based Cache", "heading_level": 2, "file_order": 153, "section_index": 1, "content_hash": "884f61d092858cc6e7a3f94b2ed33400768fc436384d986e966b3fb0313d3562", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc"}}
{"id": "sha256:359e2293a3d69236580fdb106884d623b36af22daf77cbd0436049ea1a809603", "content": "Ehcache 3.x is fully JSR-107 compliant and no dedicated support is required for it. See\nxref:integration/cache/store-configuration.adoc#cache-store-configuration-jsr107[JSR-107 Cache] for details.\n\n[[cache-store-configuration-caffeine]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc", "title": "store-configuration", "heading": "Ehcache-based Cache", "heading_level": 2, "file_order": 153, "section_index": 2, "content_hash": "359e2293a3d69236580fdb106884d623b36af22daf77cbd0436049ea1a809603", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc"}}
{"id": "sha256:5804218ec915489d2b895920fdff84bdcd20f199ec7058c90f273e86af3ee7ee", "content": "Caffeine is a rewrite of Guava's cache, and its implementation is located in the\n`org.springframework.cache.caffeine` package and provides access to several features\nof Caffeine.\n\nThe following example configures a `CacheManager` that creates the cache on demand:\n\ninclude-code::./CacheConfiguration[tag=snippet,indent=0]\n\nYou can also provide the caches to use explicitly. In that case, only those\nare made available by the manager. The following example shows how to do so:\n\ninclude-code::./CustomCacheConfiguration[tag=snippet,indent=0]\n\nThe Caffeine `CacheManager` also supports custom `Caffeine` and `CacheLoader`.\nSee the https://github.com/ben-manes/caffeine/wiki[Caffeine documentation]\nfor more information about those.\n\n[[cache-store-configuration-gemfire]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc", "title": "store-configuration", "heading": "Caffeine Cache", "heading_level": 2, "file_order": 153, "section_index": 3, "content_hash": "5804218ec915489d2b895920fdff84bdcd20f199ec7058c90f273e86af3ee7ee", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc"}}
{"id": "sha256:1504132c5854e60c197c05b74060170da3f87a23bebf6641038bb87dfce97e48", "content": "GemFire is a memory-oriented, disk-backed, elastically scalable, continuously available,\nactive (with built-in pattern-based subscription notifications), globally replicated\ndatabase and provides fully-featured edge caching. For further information on how to\nuse GemFire as a `CacheManager` (and more), see the\n{docs-spring-gemfire}/html/[Spring Data GemFire reference documentation].\n\n[[cache-store-configuration-jsr107]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc", "title": "store-configuration", "heading": "GemFire-based Cache", "heading_level": 2, "file_order": 153, "section_index": 4, "content_hash": "1504132c5854e60c197c05b74060170da3f87a23bebf6641038bb87dfce97e48", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc"}}
{"id": "sha256:7c3ba2ea56c153621222ff498f37e33d786a772798a679db579f69866cc2d0cf", "content": "Spring's caching abstraction can also use JSR-107-compliant caches. The JCache\nimplementation is located in the `org.springframework.cache.jcache` package.\n\nAgain, to use it, you need to declare the appropriate `CacheManager`.\nThe following example shows how to do so:\n\ninclude-code::./CacheConfiguration[tag=snippet,indent=0]\n\n[[cache-store-configuration-noop]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc", "title": "store-configuration", "heading": "JSR-107 Cache", "heading_level": 2, "file_order": 153, "section_index": 5, "content_hash": "7c3ba2ea56c153621222ff498f37e33d786a772798a679db579f69866cc2d0cf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc"}}
{"id": "sha256:786251ccfd40472a8698e541136822f61b4497015c3ebcf4a640f81cb6566f6e", "content": "Sometimes, when switching environments or doing testing, you might have cache\ndeclarations without having an actual backing cache configured. As this is an invalid\nconfiguration, an exception is thrown at runtime, since the caching infrastructure\nis unable to find a suitable store. In situations like this, rather than removing the\ncache declarations (which can prove tedious), you can wire in a simple dummy cache that\nperforms no caching -- that is, it forces the cached methods to be invoked every time.\nThe following example shows how to do so:\n\ninclude-code::./CacheConfiguration[tag=snippet,indent=0]\n\nThe `CompositeCacheManager` in the preceding chains multiple `CacheManager` instances and,\nthrough the `fallbackToNoOpCache` flag, adds a no-op cache for all the definitions not\nhandled by the configured cache managers. That is, every cache definition not found in\neither `jdkCache` or `gemfireCache` (configured earlier in the example) is handled by\nthe no-op cache, which does not store any information, causing the target method to be\ninvoked every time.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc", "title": "store-configuration", "heading": "Dealing with Caches without a Backing Store", "heading_level": 2, "file_order": 153, "section_index": 6, "content_hash": "786251ccfd40472a8698e541136822f61b4497015c3ebcf4a640f81cb6566f6e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/store-configuration.adoc"}}
{"id": "sha256:794672b213907807e32e2f2c83c37576a992238b2be60415b344e5e7749654a1", "content": "[[cache-strategies]]\n\n.Cache vs Buffer\n****\n\nThe terms, \"`buffer`\" and \"`cache,`\" tend to be used interchangeably. Note, however,\nthat they represent different things. Traditionally, a buffer is used as an intermediate\ntemporary store for data between a fast and a slow entity. As one party would have to wait\nfor the other (which affects performance), the buffer alleviates this by allowing entire\nblocks of data to move at once rather than in small chunks. The data is written and read\nonly once from the buffer. Furthermore, the buffers are visible to at least one party\nthat is aware of it.\n\nA cache, on the other hand, is, by definition, hidden, and neither party is aware that\ncaching occurs. It also improves performance but does so by letting the same data be\nread multiple times in a fast fashion.\n\nYou can find a further explanation of the differences between a buffer and a cache\nhttps://en.wikipedia.org/wiki/Cache_(computing)#The_difference_between_buffer_and_cache[here].\n****\n\nAt its core, the cache abstraction applies caching to Java methods, thus reducing the\nnumber of executions based on the information available in the cache. That is, each time\na targeted method is invoked, the abstraction applies a caching behavior that checks\nwhether the method has been already invoked for the given arguments. If it has been\ninvoked, the cached result is returned without having to invoke the actual method.\nIf the method has not been invoked, then it is invoked, and the result is cached and\nreturned to the user so that, the next time the method is invoked, the cached result is\nreturned. This way, expensive methods (whether CPU- or IO-bound) can be invoked only\nonce for a given set of parameters and the result reused without having to actually\ninvoke the method again. The caching logic is applied transparently without any\ninterference to the invoker.\n\nIMPORTANT: This approach works only for methods that are guaranteed to return the same\noutput (result) for a given input (or arguments) no matter how many times they are invoked.\n\nThe caching abstraction provides other cache-related operations, such as the ability\nto update the content of the cache or to remove one or all entries. These are useful if\nthe cache deals with data that can change during the course of the application.\n\nAs with other services in the Spring Framework, the caching service is an abstraction\n(not a cache implementation) and requires the use of actual storage to store the cache data --\nthat is, the abstraction frees you from having to write the caching logic but does not\nprovide the actual data store. This abstraction is materialized by the\n`org.springframework.cache.Cache` and `org.springframework.cache.CacheManager` interfaces.\n\nSpring provides xref:integration/cache/store-configuration.adoc[a few implementations]\nof that abstraction: JDK `java.util.concurrent.ConcurrentMap` based caches, Gemfire cache,\nhttps://github.com/ben-manes/caffeine/wiki[Caffeine], and JSR-107 compliant caches (such\nas Ehcache 3.x). See xref:integration/cache/plug.adoc[Plugging-in Different Back-end Caches]\nfor more information on plugging in other cache stores and providers.\n\nIMPORTANT: The caching abstraction has no special handling for multi-threaded and\nmulti-process environments, as such features are handled by the cache implementation.\n\nIf you have a multi-process environment (that is, an application deployed on several nodes),\nyou need to configure your cache provider accordingly. Depending on your use cases, a copy\nof the same data on several nodes can be enough. However, if you change the data during\nthe course of the application, you may need to enable other propagation mechanisms.\n\nCaching a particular item is a direct equivalent of the typical\nget-if-not-found-then-proceed-and-put-eventually code blocks\nfound with programmatic cache interaction.\nNo locks are applied, and several threads may try to load the same item concurrently.\nThe same applies to eviction. If several threads are trying to update or evict data\nconcurrently, you may use stale data. Certain cache providers offer advanced features\nin that area. See the documentation of your cache provider for more details.\n\nTo use the cache abstraction, you need to take care of two aspects:\n\n* Caching declaration: Identify the methods that need to be cached and their policies.\n* Cache configuration: The backing cache where the data is stored and from which it is read.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache/strategies.adoc", "title": "strategies", "heading": "strategies", "heading_level": 1, "file_order": 154, "section_index": 0, "content_hash": "794672b213907807e32e2f2c83c37576a992238b2be60415b344e5e7749654a1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache/strategies.adoc"}}
{"id": "sha256:fcce473fc367a05e2c6a58e32d43df492ec463b4a17b6dece511ebe62503fb8b", "content": "[[jms-annotated]]\n\nThe easiest way to receive a message asynchronously is to use the annotated listener\nendpoint infrastructure. In a nutshell, it lets you expose a method of a managed\nbean as a JMS listener endpoint. The following example shows how to use it:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tpublic class MyService {\n\n @JmsListener(destination = \"myDestination\")\n public void processOrder(String data) { ... }\n\t}\n----\n\nThe idea of the preceding example is that, whenever a message is available on the\n`jakarta.jms.Destination` `myDestination`, the `processOrder` method is invoked\naccordingly (in this case, with the content of the JMS message, similar to\nwhat the xref:integration/jms/receiving.adoc#jms-receiving-async-message-listener-adapter[`MessageListenerAdapter`]\nprovides).\n\nThe annotated endpoint infrastructure creates a message listener container\nbehind the scenes for each annotated method, by using a `JmsListenerContainerFactory`.\nSuch a container is not registered against the application context but can be easily\nlocated for management purposes by using the `JmsListenerEndpointRegistry` bean.\n\nTIP: `@JmsListener` is a repeatable annotation, so you can associate\nseveral JMS destinations with the same method by adding additional `@JmsListener`\ndeclarations to it.\n\n[[jms-annotated-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/annotated.adoc", "title": "annotated", "heading": "annotated", "heading_level": 1, "file_order": 155, "section_index": 0, "content_hash": "fcce473fc367a05e2c6a58e32d43df492ec463b4a17b6dece511ebe62503fb8b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/annotated.adoc"}}
{"id": "sha256:613f1a3aaa7841e643d4b585b104fa8c9b0aea58a98e989f077d9d527cdef809", "content": "To enable support for `@JmsListener` annotations, you can add `@EnableJms` to one of\nyour `@Configuration` classes, as the following example shows:\n\ninclude-code::./JmsConfiguration[tag=snippet,indent=0]\n\nBy default, the infrastructure looks for a bean named `jmsListenerContainerFactory`\nas the source for the factory to use to create message listener containers. In this\ncase (and ignoring the JMS infrastructure setup), you can invoke the `processOrder`\nmethod with a core pool size of three threads and a maximum pool size of ten threads.\n\nYou can customize the listener container factory to use for each annotation or you can\nconfigure an explicit default by implementing the `JmsListenerConfigurer` interface.\nThe default is required only if at least one endpoint is registered without a specific\ncontainer factory. See the javadoc of classes that implement\n{spring-framework-api}/jms/annotation/JmsListenerConfigurer.html[`JmsListenerConfigurer`]\nfor details and examples.\n\n[[jms-annotated-programmatic-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/annotated.adoc", "title": "annotated", "heading": "Enable Listener Endpoint Annotations", "heading_level": 2, "file_order": 155, "section_index": 1, "content_hash": "613f1a3aaa7841e643d4b585b104fa8c9b0aea58a98e989f077d9d527cdef809", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/annotated.adoc"}}
{"id": "sha256:a3498b8fe50d24857641ab767b09f2c92f7bc1308db060cae5503bef559ce838", "content": "`JmsListenerEndpoint` provides a model of a JMS endpoint and is responsible for configuring\nthe container for that model. The infrastructure lets you programmatically configure endpoints\nin addition to the ones that are detected by the `JmsListener` annotation.\nThe following example shows how to do so:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@EnableJms\n\tpublic class AppConfig implements JmsListenerConfigurer {\n\n @Override\n public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {\n SimpleJmsListenerEndpoint endpoint = new SimpleJmsListenerEndpoint();\n endpoint.setId(\"myJmsEndpoint\");\n endpoint.setDestination(\"anotherQueue\");\n endpoint.setMessageListener(message -> {\n // processing\n });\n registrar.registerEndpoint(endpoint);\n }\n\t}\n----\n\nIn the preceding example, we used `SimpleJmsListenerEndpoint`, which provides the actual\n`MessageListener` to invoke. However, you could also build your own endpoint variant\nto describe a custom invocation mechanism.\n\nNote that you could skip the use of `@JmsListener` altogether\nand programmatically register only your endpoints through `JmsListenerConfigurer`.\n\n[[jms-annotated-method-signature]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/annotated.adoc", "title": "annotated", "heading": "Programmatic Endpoint Registration", "heading_level": 2, "file_order": 155, "section_index": 2, "content_hash": "a3498b8fe50d24857641ab767b09f2c92f7bc1308db060cae5503bef559ce838", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/annotated.adoc"}}
{"id": "sha256:c2e2b7f8d3df64baf197d658bd4c118078e3db9ddbd23352198ede1f95e9a9a3", "content": "So far, we have been injecting a simple `String` in our endpoint, but it can actually\nhave a very flexible method signature. In the following example, we rewrite it to inject the `Order` with\na custom header:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\tpublic class MyService {\n\n @JmsListener(destination = \"myDestination\")\n public void processOrder(Order order, @Header(\"order_type\") String orderType) {\n ...\n }\n\t}\n----\n\nThe main elements you can inject in JMS listener endpoints are as follows:\n\n* The raw `jakarta.jms.Message` or any of its subclasses (provided that it\n matches the incoming message type).\n* The `jakarta.jms.Session` for optional access to the native JMS API (for example, for sending\n a custom reply).\n* The `org.springframework.messaging.Message` that represents the incoming JMS message.\n Note that this message holds both the custom and the standard headers (as defined\n by `JmsHeaders`).\n* `@Header`-annotated method arguments to extract a specific header value, including\n standard JMS headers.\n* A `@Headers`-annotated argument that must also be assignable to `java.util.Map` for\n getting access to all headers.\n* A non-annotated element that is not one of the supported types (`Message` or\n `Session`) is considered to be the payload. You can make that explicit by annotating\n the parameter with `@Payload`. You can also turn on validation by adding an extra\n `@Valid`.\n\nThe ability to inject Spring's `Message` abstraction is particularly useful to benefit\nfrom all the information stored in the transport-specific message without relying on\ntransport-specific API. The following example shows how to do so:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@JmsListener(destination = \"myDestination\")\n\tpublic void processOrder(Message<Order> order) { ... }\n----\n\nHandling of method arguments is provided by `DefaultMessageHandlerMethodFactory`, which you can\nfurther customize to support additional method arguments. You can customize the conversion and validation\nsupport there as well.\n\nFor instance, if we want to make sure our `Order` is valid before processing it, we can\nannotate the payload with `@Valid` and configure the necessary validator, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@EnableJms\n\tpublic class AppConfig implements JmsListenerConfigurer {\n\n @Override\n public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) {\n registrar.setMessageHandlerMethodFactory(myJmsHandlerMethodFactory());\n }\n\n @Bean\n public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {\n DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();\n factory.setValidator(myValidator());\n return factory;\n }\n\t}\n----\n\n[[jms-annotated-response]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/annotated.adoc", "title": "annotated", "heading": "Annotated Endpoint Method Signature", "heading_level": 2, "file_order": 155, "section_index": 3, "content_hash": "c2e2b7f8d3df64baf197d658bd4c118078e3db9ddbd23352198ede1f95e9a9a3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/annotated.adoc"}}
{"id": "sha256:496358e8847e89e88d02e6696c2513a7a723043437c89d3f30296de1a40868cf", "content": "The existing support in xref:integration/jms/receiving.adoc#jms-receiving-async-message-listener-adapter[`MessageListenerAdapter`]\nalready lets your method have a non-`void` return type. When that is the case, the result of\nthe invocation is encapsulated in a `jakarta.jms.Message`, sent either in the destination specified\nin the `JMSReplyTo` header of the original message or in the default destination configured on\nthe listener. You can now set that default destination by using the `@SendTo` annotation of the\nmessaging abstraction.\n\nAssuming that our `processOrder` method should now return an `OrderStatus`, we can write it\nto automatically send a response, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@JmsListener(destination = \"myDestination\")\n\t@SendTo(\"status\")\n\tpublic OrderStatus processOrder(Order order) {\n // order processing\n return status;\n\t}\n----\n\nTIP: If you have several `@JmsListener`-annotated methods, you can also place the `@SendTo`\nannotation at the class level to share a default reply destination.\n\nIf you need to set additional headers in a transport-independent manner, you can return a\n`Message` instead, with a method similar to the following:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@JmsListener(destination = \"myDestination\")\n\t@SendTo(\"status\")\n\tpublic Message<OrderStatus> processOrder(Order order) {\n // order processing\n return MessageBuilder\n .withPayload(status)\n .setHeader(\"code\", 1234)\n .build();\n\t}\n----\n\nIf you need to compute the response destination at runtime, you can encapsulate your response\nin a `JmsResponse` instance that also provides the destination to use at runtime. We can rewrite the previous\nexample as follows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@JmsListener(destination = \"myDestination\")\n\tpublic JmsResponse<Message<OrderStatus>> processOrder(Order order) {\n // order processing\n Message<OrderStatus> response = MessageBuilder\n .withPayload(status)\n .setHeader(\"code\", 1234)\n .build();\n return JmsResponse.forQueue(response, \"status\");\n\t}\n----\n\nFinally, if you need to specify some QoS values for the response such as the priority or\nthe time to live, you can configure the `JmsListenerContainerFactory` accordingly,\nas the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@EnableJms\n\tpublic class AppConfig {\n\n @Bean\n public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() {\n DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();\n factory.setConnectionFactory(connectionFactory());\n QosSettings replyQosSettings = new QosSettings();\n replyQosSettings.setPriority(2);\n replyQosSettings.setTimeToLive(10000);\n factory.setReplyQosSettings(replyQosSettings);\n return factory;\n }\n\t}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/annotated.adoc", "title": "annotated", "heading": "Response Management", "heading_level": 2, "file_order": 155, "section_index": 4, "content_hash": "496358e8847e89e88d02e6696c2513a7a723043437c89d3f30296de1a40868cf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/annotated.adoc"}}
{"id": "sha256:e7c00c020dba70c7a098af590fb57a6c06a3b4305b0b2e358422de2177c7bb38", "content": "[[jms-jca-message-endpoint-manager]]\n\nBeginning with version 2.5, Spring also provides support for a JCA-based\n`MessageListener` container. The `JmsMessageEndpointManager` tries to\nautomatically determine the `ActivationSpec` class name from the provider's\n`ResourceAdapter` class name. Therefore, it is typically possible to provide\nSpring's generic `JmsActivationSpecConfig`, as the following example shows:\n\ninclude-code::./JmsConfiguration[tag=snippet,indent=0]\n\nAlternatively, you can set up a `JmsMessageEndpointManager` with a given\n`ActivationSpec` object. The `ActivationSpec` object may also come from a JNDI lookup\n(using `<jee:jndi-lookup>`). The following example shows how to do so:\n\ninclude-code::./AlternativeJmsConfiguration[tag=snippet,indent=0]\n\nSee the javadoc for {spring-framework-api}/jms/listener/endpoint/JmsMessageEndpointManager.html[`JmsMessageEndpointManager`],\n{spring-framework-api}/jms/listener/endpoint/JmsActivationSpecConfig.html[`JmsActivationSpecConfig`],\nand {spring-framework-api}/jca/support/ResourceAdapterFactoryBean.html[`ResourceAdapterFactoryBean`]\nfor more details.\n\nSpring also provides a generic JCA message endpoint manager that is not tied to JMS:\n`org.springframework.jca.endpoint.GenericMessageEndpointManager`. This component allows\nfor using any message listener type (such as a JMS `MessageListener`) and any\nprovider-specific `ActivationSpec` object. See your JCA provider's documentation to\nfind out about the actual capabilities of your connector, and see the\n{spring-framework-api}/jca/endpoint/GenericMessageEndpointManager.html[`GenericMessageEndpointManager`]\njavadoc for the Spring-specific configuration details.\n\nNOTE: JCA-based message endpoint management is very analogous to EJB 2.1 Message-Driven Beans.\nIt uses the same underlying resource provider contract. As with EJB 2.1 MDBs, you can use any\nmessage listener interface supported by your JCA provider in the Spring context as well.\nSpring nevertheless provides explicit \"`convenience`\" support for JMS, because JMS is the\nmost common endpoint API used with the JCA endpoint management contract.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/jca-message-endpoint-manager.adoc", "title": "jca-message-endpoint-manager", "heading": "jca-message-endpoint-manager", "heading_level": 1, "file_order": 156, "section_index": 0, "content_hash": "e7c00c020dba70c7a098af590fb57a6c06a3b4305b0b2e358422de2177c7bb38", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/jca-message-endpoint-manager.adoc"}}
{"id": "sha256:0f3ff5d39da4f997b4ea3d8f3e16fd6073507090e4e076f5d8960126ffadca0b", "content": "[[jms-namespace]]\n\nSpring provides an XML namespace for simplifying JMS configuration. To use the JMS\nnamespace elements, you need to reference the JMS schema, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:jms=\"http://www.springframework.org/schema/jms\" <1>\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/jms\n https://www.springframework.org/schema/jms/spring-jms.xsd\">\n\n <!-- bean definitions here -->\n\n\t</beans>\n----\n<1> Referencing the JMS schema.\n\nThe namespace consists of three top-level elements: `<annotation-driven/>`, `<listener-container/>`\nand `<jca-listener-container/>`. `<annotation-driven/>` enables the use of xref:integration/jms/annotated.adoc[annotation-driven listener endpoints]\n. `<listener-container/>` and `<jca-listener-container/>`\ndefine shared listener container configuration and can contain `<listener/>` child elements.\nThe following example shows a basic configuration for two listeners:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jms:listener-container>\n\n <jms:listener destination=\"queue.orders\" ref=\"orderService\" method=\"placeOrder\"/>\n\n <jms:listener destination=\"queue.confirmations\" ref=\"confirmationLogger\" method=\"log\"/>\n\n\t</jms:listener-container>\n----\n\nThe preceding example is equivalent to creating two distinct listener container bean\ndefinitions and two distinct `MessageListenerAdapter` bean definitions, as shown\nin xref:integration/jms/receiving.adoc#jms-receiving-async-message-listener-adapter[Using `MessageListenerAdapter`]. In addition to the attributes shown\nin the preceding example, the `listener` element can contain several optional ones.\nThe following table describes all of the available attributes:\n\n[[jms-namespace-listener-tbl]]\n.Attributes of the JMS <listener> element\n[cols=\"1,6\"]\n|===\n| Attribute | Description\n\n| `id`\n| A bean name for the hosting listener container. If not specified, a bean name is\n automatically generated.\n\n| `destination` (required)\n| The destination name for this listener, resolved through the `DestinationResolver`\n strategy.\n\n| `ref` (required)\n| The bean name of the handler object.\n\n| `method`\n| The name of the handler method to invoke. If the `ref` attribute points to a `MessageListener`\n or Spring `SessionAwareMessageListener`, you can omit this attribute.\n\n| `response-destination`\n| The name of the default response destination to which to send response messages. This is\n applied in case of a request message that does not carry a `JMSReplyTo` field. The\n type of this destination is determined by the listener-container's\n `response-destination-type` attribute. Note that this applies only to a listener method with a\n return value, for which each result object is converted into a response message.\n\n| `subscription`\n| The name of the durable subscription, if any.\n\n| `selector`\n| An optional message selector for this listener.\n\n| `concurrency`\n| The number of concurrent sessions or consumers to start for this listener. This value can either be\n a simple number indicating the maximum number (for example, `5`) or a range indicating the lower\n as well as the upper limit (for example, `3-5`). Note that a specified minimum is only a hint\n and might be ignored at runtime. The default is the value provided by the container.\n|===\n\nThe `<listener-container/>` element also accepts several optional attributes. This\nallows for customization of the various strategies (for example, `taskExecutor` and\n`destinationResolver`) as well as basic JMS settings and resource references. By using\nthese attributes, you can define highly-customized listener containers while\nstill benefiting from the convenience of the namespace.\n\nYou can automatically expose such settings as a `JmsListenerContainerFactory` by\nspecifying the `id` of the bean to expose through the `factory-id` attribute,\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jms:listener-container connection-factory=\"myConnectionFactory\"\n task-executor=\"myTaskExecutor\"\n destination-resolver=\"myDestinationResolver\"\n transaction-manager=\"myTransactionManager\"\n concurrency=\"10\">\n\n <jms:listener destination=\"queue.orders\" ref=\"orderService\" method=\"placeOrder\"/>\n\n <jms:listener destination=\"queue.confirmations\" ref=\"confirmationLogger\" method=\"log\"/>\n\n\t</jms:listener-container>\n----\n\nThe following table describes all available attributes. See the class-level javadoc\nof the {spring-framework-api}/jms/listener/AbstractMessageListenerContainer.html[`AbstractMessageListenerContainer`]\nand its concrete subclasses for more details on the individual properties. The javadoc\nalso provides a discussion of transaction choices and message redelivery scenarios.\n\n[[jms-namespace-listener-container-tbl]]\n.Attributes of the JMS <listener-container> element\n[cols=\"1,6\"]\n|===\n| Attribute | Description\n\n| `container-type`\n| The type of this listener container. The available options are `default`, `simple`,\n `default102`, or `simple102` (the default option is `default`).\n\n| `container-class`\n| A custom listener container implementation class as a fully qualified class name.\n The default is Spring's standard `DefaultMessageListenerContainer` or\n `SimpleMessageListenerContainer`, according to the `container-type` attribute.\n\n| `factory-id`\n| Exposes the settings defined by this element as a `JmsListenerContainerFactory`\n with the specified `id` so that they can be reused with other endpoints.\n\n| `connection-factory`\n| A reference to the JMS `ConnectionFactory` bean (the default bean name is\n `connectionFactory`).\n\n| `task-executor`\n| A reference to the Spring `TaskExecutor` for the JMS listener invokers.\n\n| `destination-resolver`\n| A reference to the `DestinationResolver` strategy for resolving JMS `Destination` instances.\n\n| `message-converter`\n| A reference to the `MessageConverter` strategy for converting JMS Messages to listener\n method arguments. The default is a `SimpleMessageConverter`.\n\n| `error-handler`\n| A reference to an `ErrorHandler` strategy for handling any uncaught exceptions that\n may occur during the execution of the `MessageListener`.\n\n| `destination-type`\n| The JMS destination type for this listener: `queue`, `topic`, `durableTopic`, `sharedTopic`,\n or `sharedDurableTopic`. This potentially enables the `pubSubDomain`, `subscriptionDurable`\n and `subscriptionShared` properties of the container. The default is `queue` (which disables\n those three properties).\n\n| `response-destination-type`\n| The JMS destination type for responses: `queue` or `topic`. The default is the value of the\n `destination-type` attribute.\n\n| `client-id`\n| The JMS client ID for this listener container. You must specify it when you use\n durable subscriptions.\n\n| `cache`\n| The cache level for JMS resources: `none`, `connection`, `session`, `consumer`, or\n `auto`. By default (`auto`), the cache level is effectively `consumer`, unless\n an external transaction manager has been specified -- in which case, the effective\n default will be `none` (assuming Jakarta EE-style transaction management, where the given\n ConnectionFactory is an XA-aware pool).\n\n| `acknowledge`\n| The native JMS acknowledge mode: `auto`, `client`, `dups-ok`, or `transacted`. A value\n of `transacted` activates a locally transacted `Session`. As an alternative, you can specify\n the `transaction-manager` attribute, described later in table. The default is `auto`.\n\n| `transaction-manager`\n| A reference to an external `PlatformTransactionManager` (typically an XA-based\n transaction coordinator, such as Spring's `JtaTransactionManager`). If not specified,\n native acknowledging is used (see the `acknowledge` attribute).\n\n| `concurrency`\n| The number of concurrent sessions or consumers to start for each listener. It can either be\n a simple number indicating the maximum number (for example, `5`) or a range indicating the\n lower as well as the upper limit (for example, `3-5`). Note that a specified minimum is just a\n hint and might be ignored at runtime. The default is `1`. You should keep concurrency limited to `1` in\n case of a topic listener or if queue ordering is important. Consider raising it for\n general queues.\n\n| `prefetch`\n| The maximum number of messages to load into a single session. Note that raising this\n number might lead to starvation of concurrent consumers.\n\n| `receive-timeout`\n| The timeout (in milliseconds) to use for receive calls. The default is `1000` (one\n second). `-1` indicates no timeout.\n\n| `back-off`\n| Specifies the `BackOff` instance to use to compute the interval between recovery\n attempts. If the `BackOffExecution` implementation returns `BackOffExecution#STOP`,\n the listener container does not further try to recover. The `recovery-interval`\n value is ignored when this property is set. The default is a `FixedBackOff` with\n an interval of 5000 milliseconds (that is, five seconds).\n\n| `recovery-interval`\n| Specifies the interval between recovery attempts, in milliseconds. It offers a convenient\n way to create a `FixedBackOff` with the specified interval. For more recovery\n options, consider specifying a `BackOff` instance instead. The default is 5000 milliseconds\n (that is, five seconds).\n\n| `phase`\n| The lifecycle phase within which this container should start and stop. The lower the\n value, the earlier this container starts and the later it stops. The default is\n `Integer.MAX_VALUE`, meaning that the container starts as late as possible and stops as\n soon as possible.\n|===\n\nConfiguring a JCA-based listener container with the `jms` schema support is very similar,\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jms:jca-listener-container resource-adapter=\"myResourceAdapter\"\n destination-resolver=\"myDestinationResolver\"\n transaction-manager=\"myTransactionManager\"\n concurrency=\"10\">\n\n <jms:listener destination=\"queue.orders\" ref=\"myMessageListener\"/>\n\n\t</jms:jca-listener-container>\n----\n\nThe following table describes the available configuration options for the JCA variant:\n\n[[jms-namespace-jca-listener-container-tbl]]\n.Attributes of the JMS <jca-listener-container/> element\n[cols=\"1,6\"]\n|===\n| Attribute | Description\n\n| `factory-id`\n| Exposes the settings defined by this element as a `JmsListenerContainerFactory`\n with the specified `id` so that they can be reused with other endpoints.\n\n| `resource-adapter`\n| A reference to the JCA `ResourceAdapter` bean (the default bean name is\n `resourceAdapter`).\n\n| `activation-spec-factory`\n| A reference to the `JmsActivationSpecFactory`. The default is to autodetect the JMS\n provider and its `ActivationSpec` class (see {spring-framework-api}/jms/listener/endpoint/DefaultJmsActivationSpecFactory.html[`DefaultJmsActivationSpecFactory`]).\n\n| `destination-resolver`\n| A reference to the `DestinationResolver` strategy for resolving JMS `Destinations`.\n\n| `message-converter`\n| A reference to the `MessageConverter` strategy for converting JMS Messages to listener\n method arguments. The default is `SimpleMessageConverter`.\n\n| `destination-type`\n| The JMS destination type for this listener: `queue`, `topic`, `durableTopic`, `sharedTopic`.\n or `sharedDurableTopic`. This potentially enables the `pubSubDomain`, `subscriptionDurable`,\n and `subscriptionShared` properties of the container. The default is `queue` (which disables\n those three properties).\n\n| `response-destination-type`\n| The JMS destination type for responses: `queue` or `topic`. The default is the value of the\n `destination-type` attribute.\n\n| `client-id`\n| The JMS client ID for this listener container. It needs to be specified when using\n durable subscriptions.\n\n| `acknowledge`\n| The native JMS acknowledge mode: `auto`, `client`, `dups-ok`, or `transacted`. A value\n of `transacted` activates a locally transacted `Session`. As an alternative, you can specify\n the `transaction-manager` attribute described later. The default is `auto`.\n\n| `transaction-manager`\n| A reference to a Spring `JtaTransactionManager` or a\n `jakarta.transaction.TransactionManager` for kicking off an XA transaction for each\n incoming message. If not specified, native acknowledging is used (see the\n `acknowledge` attribute).\n\n| `concurrency`\n| The number of concurrent sessions or consumers to start for each listener. It can either be\n a simple number indicating the maximum number (for example `5`) or a range indicating the\n lower as well as the upper limit (for example, `3-5`). Note that a specified minimum is only a\n hint and is typically ignored at runtime when you use a JCA listener container.\n The default is 1.\n\n| `prefetch`\n| The maximum number of messages to load into a single session. Note that raising this\n number might lead to starvation of concurrent consumers.\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/namespace.adoc", "title": "namespace", "heading": "namespace", "heading_level": 1, "file_order": 157, "section_index": 0, "content_hash": "0f3ff5d39da4f997b4ea3d8f3e16fd6073507090e4e076f5d8960126ffadca0b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/namespace.adoc"}}
{"id": "sha256:b4e89b238bde641877a6d27d010fa6b926691c2d955e575d58981c561d09dae6", "content": "[[jms-receiving]]\n\nThis describes how to receive messages with JMS in Spring.\n\n[[jms-receiving-sync]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/receiving.adoc", "title": "receiving", "heading": "receiving", "heading_level": 1, "file_order": 158, "section_index": 0, "content_hash": "b4e89b238bde641877a6d27d010fa6b926691c2d955e575d58981c561d09dae6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/receiving.adoc"}}
{"id": "sha256:79cba1aca2ec39b5e4e85abc0103a494b5a547ba5cf32da3cd7438ff753c19ac", "content": "While JMS is typically associated with asynchronous processing, you can consume messages\nsynchronously. The `receive(..)` methods on `JmsTemplate` and `JmsClient` provide this\nfunctionality. During a synchronous receive, the calling thread blocks until a message\nbecomes available. This can be a dangerous operation, since the calling thread can\npotentially be blocked indefinitely. The `receiveTimeout` property specifies how long\nthe receiver should wait before giving up waiting for a message.\n\n[[jms-receiving-async]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/receiving.adoc", "title": "receiving", "heading": "Synchronous Receipt", "heading_level": 2, "file_order": 158, "section_index": 1, "content_hash": "79cba1aca2ec39b5e4e85abc0103a494b5a547ba5cf32da3cd7438ff753c19ac", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/receiving.adoc"}}
{"id": "sha256:34c955be39b542a6423635f957a55402289a349ce28638149d7070c4f4f562a2", "content": "NOTE: Spring also supports annotated-listener endpoints through the use of the `@JmsListener`\nannotation and provides open infrastructure to register endpoints programmatically.\nThis is, by far, the most convenient way to set up an asynchronous receiver.\nSee xref:integration/jms/annotated.adoc#jms-annotated-support[Enable Listener Endpoint Annotations] for more details.\n\nIn a fashion similar to a Message-Driven Bean (MDB) in the EJB world, the Message-Driven\nPOJO (MDP) acts as a receiver for JMS messages. The one restriction (but see\nxref:integration/jms/receiving.adoc#jms-receiving-async-message-listener-adapter[Using `MessageListenerAdapter`])\non an MDP is that it must implement the `jakarta.jms.MessageListener` interface.\nNote that, if your POJO receives messages on multiple threads, it is important to\nensure that your implementation is thread-safe.\n\nThe following example shows a simple implementation of an MDP:\n\ninclude-code::./ExampleListener[tag=snippet,indent=0]\n\nOnce you have implemented your `MessageListener`, it is time to create a message listener\ncontainer.\n\nThe following example shows how to define and configure one of the message listener\ncontainers that ships with Spring (in this case, `DefaultMessageListenerContainer`):\n\ninclude-code::./JmsConfiguration[tag=snippet,indent=0]\n\nSee the Spring javadoc of the various message listener containers (all of which implement\n{spring-framework-api}/jms/listener/MessageListenerContainer.html[MessageListenerContainer])\nfor a full description of the features supported by each implementation.\n\n[[jms-receiving-async-session-aware-message-listener]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/receiving.adoc", "title": "receiving", "heading": "Asynchronous Receipt: Message-Driven POJOs", "heading_level": 2, "file_order": 158, "section_index": 2, "content_hash": "34c955be39b542a6423635f957a55402289a349ce28638149d7070c4f4f562a2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/receiving.adoc"}}
{"id": "sha256:155973227e3e40fad0cd4cc6259c25c5b0f2b697a49b8c853c151521e635ae83", "content": "The `SessionAwareMessageListener` interface is a Spring-specific interface that provides\na similar contract to the JMS `MessageListener` interface but also gives the message-handling\nmethod access to the JMS `Session` from which the `Message` was received.\nThe following listing shows the definition of the `SessionAwareMessageListener` interface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.jms.listener;\n\n\tpublic interface SessionAwareMessageListener {\n\n void onMessage(Message message, Session session) throws JMSException;\n\t}\n----\n\nYou can choose to have your MDPs implement this interface (in preference to the standard\nJMS `MessageListener` interface) if you want your MDPs to be able to respond to any\nreceived messages (by using the `Session` supplied in the `onMessage(Message, Session)`\nmethod). All of the message listener container implementations that ship with Spring\nhave support for MDPs that implement either the `MessageListener` or\n`SessionAwareMessageListener` interface. Classes that implement the\n`SessionAwareMessageListener` come with the caveat that they are then tied to Spring\nthrough the interface. The choice of whether or not to use it is left entirely up to you\nas an application developer or architect.\n\nNote that the `onMessage(..)` method of the `SessionAwareMessageListener`\ninterface throws `JMSException`. In contrast to the standard JMS `MessageListener`\ninterface, when using the `SessionAwareMessageListener` interface, it is the\nresponsibility of the client code to handle any thrown exceptions.\n\n[[jms-receiving-async-message-listener-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/receiving.adoc", "title": "receiving", "heading": "Using the `SessionAwareMessageListener` Interface", "heading_level": 2, "file_order": 158, "section_index": 3, "content_hash": "155973227e3e40fad0cd4cc6259c25c5b0f2b697a49b8c853c151521e635ae83", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/receiving.adoc"}}
{"id": "sha256:7eb60ed96bc2bcf3f418dcc8700b1e09a0f856e0c29e5b8beda07c87de2474f3", "content": "The `MessageListenerAdapter` class is the final component in Spring's asynchronous\nmessaging support. In a nutshell, it lets you expose almost any class as an MDP\n(though there are some constraints).\n\nConsider the following interface definition:\n\ninclude-code::./MessageDelegate[tag=snippet,indent=0]\n\nNotice that, although the interface extends neither the `MessageListener` nor the\n`SessionAwareMessageListener` interface, you can still use it as an MDP by using the\n`MessageListenerAdapter` class. Notice also how the various message handling methods are\nstrongly typed according to the contents of the various `Message` types that they can\nreceive and handle.\n\nNow consider the following implementation of the `MessageDelegate` interface:\n\ninclude-code::./DefaultMessageDelegate[tag=snippet,indent=0]\n\nIn particular, note how the preceding implementation of the `MessageDelegate` interface (the\n`DefaultMessageDelegate` class) has no JMS dependencies at all. It truly is a\nPOJO that we can make into an MDP through the following configuration:\n\ninclude-code::./JmsConfiguration[tag=snippet,indent=0]\n\nThe next example shows another MDP that can handle only receiving JMS\n`TextMessage` messages. Notice how the message handling method is actually called\n`receive` (the name of the message handling method in a `MessageListenerAdapter`\ndefaults to `handleMessage`), but it is configurable (as you can see later in this section). Notice\nalso how the `receive(..)` method is strongly typed to receive and respond only to JMS\n`TextMessage` messages.\nThe following listing shows the definition of the `TextMessageDelegate` interface:\n\ninclude-code::./TextMessageDelegate[tag=snippet,indent=0]\n\nThe following listing shows a class that implements the `TextMessageDelegate` interface:\n\ninclude-code::./DefaultTextMessageDelegate[tag=snippet,indent=0]\n\nThe configuration of the attendant `MessageListenerAdapter` would then be as follows:\n\ninclude-code::./MessageListenerConfiguration[tag=snippet,indent=0]\n\nNote that, if the `messageListener` receives a JMS `Message` of a type\nother than `TextMessage`, an `IllegalStateException` is thrown (and subsequently\nswallowed). Another of the capabilities of the `MessageListenerAdapter` class is the\nability to automatically send back a response `Message` if a handler method returns a\nnon-void value. Consider the following interface and class:\n\ninclude-code::./ResponsiveTextMessageDelegate[tag=snippet,indent=0]\n\ninclude-code::./DefaultResponsiveTextMessageDelegate[tag=snippet,indent=0]\n\nIf you use the `DefaultResponsiveTextMessageDelegate` in conjunction with a\n`MessageListenerAdapter`, any non-null value that is returned from the execution of\nthe `'receive(..)'` method is (in the default configuration) converted into a\n`TextMessage`. The resulting `TextMessage` is then sent to the `Destination` (if\none exists) defined in the JMS `Reply-To` property of the original `Message` or the\ndefault `Destination` set on the `MessageListenerAdapter` (if one has been configured).\nIf no `Destination` is found, an `InvalidDestinationException` is thrown\n(note that this exception is not swallowed and propagates up the\ncall stack).\n\n[[jms-tx-participation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/receiving.adoc", "title": "receiving", "heading": "Using `MessageListenerAdapter`", "heading_level": 2, "file_order": 158, "section_index": 4, "content_hash": "7eb60ed96bc2bcf3f418dcc8700b1e09a0f856e0c29e5b8beda07c87de2474f3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/receiving.adoc"}}
{"id": "sha256:87252e672ac0fccb5d883a65c106d8aa14f4cf77c200dd5199551d6e23bf4415", "content": "Invoking a message listener within a transaction requires only reconfiguration of the\nlistener container.\n\nYou can activate local resource transactions through the `sessionTransacted` flag\non the listener container definition. Each message listener invocation then operates\nwithin an active JMS transaction, with message receipt rolled back in case of listener\nexecution failure. Sending a response message (through `SessionAwareMessageListener`) is\npart of the same local transaction, but any other resource operations (such as\ndatabase access) operate independently. This usually requires duplicate message\ndetection in the listener implementation, to cover the case where database processing\nhas committed but message processing failed to commit.\n\nConsider the following bean definition:\n\ninclude-code::./JmsConfiguration[tag=snippet,indent=0]\n\nTo participate in an externally managed transaction, you need to configure a\ntransaction manager and use a listener container that supports externally managed\ntransactions (typically, `DefaultMessageListenerContainer`).\n\nTo configure a message listener container for XA transaction participation, you want\nto configure a `JtaTransactionManager` (which, by default, delegates to the Jakarta EE\nserver's transaction subsystem). Note that the underlying JMS `ConnectionFactory` needs to\nbe XA-capable and properly registered with your JTA transaction coordinator. (Check your\nJakarta EE server's configuration of JNDI resources.) This lets message receipt as well\nas (for example) database access be part of the same transaction (with unified commit\nsemantics, at the expense of XA transaction log overhead).\n\nThe following bean definition creates a transaction manager:\n\ninclude-code::./ExternalTxJmsConfiguration[tag=transactionManagerSnippet,indent=0]\n\nThen we need to add it to our earlier container configuration. The container\ntakes care of the rest. The following example shows how to do so:\n\ninclude-code::./ExternalTxJmsConfiguration[tag=jmsContainerSnippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/receiving.adoc", "title": "receiving", "heading": "Processing Messages Within Transactions", "heading_level": 2, "file_order": 158, "section_index": 5, "content_hash": "87252e672ac0fccb5d883a65c106d8aa14f4cf77c200dd5199551d6e23bf4415", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/receiving.adoc"}}
{"id": "sha256:767ecf5d154bced353f2dacba8ced7b8385f9794f92f0af8b98f840765f7081f", "content": "[[jms-sending]]\n\nThe `JmsTemplate` contains many convenience methods to send a message. Send\nmethods specify the destination by using a `jakarta.jms.Destination` object, and others\nspecify the destination by using a `String` in a JNDI lookup. The `send` method\nthat takes no destination argument uses the default destination.\n\nThe following example uses the `MessageCreator` callback to create a text message from the\nsupplied `Session` object:\n\ninclude-code::./JmsQueueSender[]\n\nIn the preceding example, the `JmsTemplate` is constructed by passing a reference to a\n`ConnectionFactory`. As an alternative, a zero-argument constructor and\n`connectionFactory` is provided and can be used for constructing the instance in\nJavaBean style (using a `BeanFactory` or plain Java code). Alternatively, consider\nderiving from Spring's `JmsGatewaySupport` convenience base class, which provides\npre-built bean properties for JMS configuration.\n\nThe `send(String destinationName, MessageCreator creator)` method lets you send a\nmessage by using the string name of the destination. If these names are registered in JNDI,\nyou should set the `destinationResolver` property of the template to an instance of\n`JndiDestinationResolver`.\n\nIf you created the `JmsTemplate` and specified a default destination, the\n`send(MessageCreator c)` sends a message to that destination.\n\n[[jms-sending-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/sending.adoc", "title": "sending", "heading": "sending", "heading_level": 1, "file_order": 159, "section_index": 0, "content_hash": "767ecf5d154bced353f2dacba8ced7b8385f9794f92f0af8b98f840765f7081f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/sending.adoc"}}
{"id": "sha256:13aa0acf79c34b690e2063633df9fc5f39c1d8dfd90a695c04c1ef3074c0b5a3", "content": "To facilitate the sending of domain model objects, the `JmsTemplate` has\nvarious send methods that take a Java object as an argument for a message's data\ncontent. The overloaded methods `convertAndSend()` and `receiveAndConvert()` methods in\n`JmsTemplate` delegate the conversion process to an instance of the `MessageConverter`\ninterface. This interface defines a simple contract to convert between Java objects and\nJMS messages. The default implementation (`SimpleMessageConverter`) supports conversion\nbetween `String` and `TextMessage`, `byte[]` and `BytesMessage`, and `java.util.Map`\nand `MapMessage`. By using the converter, you and your application code can focus on the\nbusiness object that is being sent or received through JMS and not be concerned with the\ndetails of how it is represented as a JMS message.\n\nThe sandbox currently includes a `MapMessageConverter`, which uses reflection to convert\nbetween a JavaBean and a `MapMessage`. Other popular implementation choices you might\nimplement yourself are converters that use an existing XML marshalling package (such as\nJAXB or XStream) to create a `TextMessage` that represents the object.\n\nTo accommodate the setting of a message's properties, headers, and body that can not be\ngenerically encapsulated inside a converter class, the `MessagePostProcessor` interface\ngives you access to the message after it has been converted but before it is sent. The\nfollowing example shows how to modify a message header and a property after a\n`java.util.Map` is converted to a message:\n\ninclude-code::./JmsSenderWithConversion[]\n\nThis results in a message of the following form:\n\n[literal]\n[subs=\"verbatim,quotes\"]\n----\nMapMessage={\n\tHeader={\n ... standard headers ...\n CorrelationID={123-00001}\n\t}\n\tProperties={\n AccountID={Integer:1234}\n\t}\n\tFields={\n Name={String:Mark}\n Age={Integer:47}\n\t}\n}\n----\n\nNOTE: This JMS-specific `org.springframework.jms.support.converter.MessageConverter`\narrangement operates on JMS message types and is responsible for immediate conversion\nto `jakarta.jms.TextMessage`, `jakarta.jms.BytesMessage`, etc. For a contract supporting\ngeneric message payloads, use `org.springframework.messaging.converter.MessageConverter`\nwith `JmsMessagingTemplate` or preferably `JmsClient` as your central delegate instead.\n\n[[jms-sending-callbacks]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/sending.adoc", "title": "sending", "heading": "Using JMS Message Converters", "heading_level": 2, "file_order": 159, "section_index": 1, "content_hash": "13aa0acf79c34b690e2063633df9fc5f39c1d8dfd90a695c04c1ef3074c0b5a3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/sending.adoc"}}
{"id": "sha256:5cb0bc9bd6909772f85e5eb3780e06546cff8d7511d5ea00405f214d8234d191", "content": "While the send operations cover many common usage scenarios, you might sometimes\nwant to perform multiple operations on a JMS `Session` or `MessageProducer`. The\n`SessionCallback` and `ProducerCallback` expose the JMS `Session` and `Session` /\n`MessageProducer` pair, respectively. The `execute()` methods on `JmsTemplate` run\nthese callback methods.\n\n[[jms-sending-jmsclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/sending.adoc", "title": "sending", "heading": "Using `SessionCallback` and `ProducerCallback` on `JmsTemplate`", "heading_level": 2, "file_order": 159, "section_index": 2, "content_hash": "5cb0bc9bd6909772f85e5eb3780e06546cff8d7511d5ea00405f214d8234d191", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/sending.adoc"}}
{"id": "sha256:5a959c7a456437e67e43c8864275e66b5a07cdb444c7791b0e472ca0038dd539", "content": "include-code::./JmsClientSample[]\n\n[[jms-sending-postprocessor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/sending.adoc", "title": "sending", "heading": "Sending a Message with `JmsClient`", "heading_level": 2, "file_order": 159, "section_index": 3, "content_hash": "5a959c7a456437e67e43c8864275e66b5a07cdb444c7791b0e472ca0038dd539", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/sending.adoc"}}
{"id": "sha256:2cfcdae84be2cae4d5d928570c346656f057b9f9d1be1c65be51752c4936c3b1", "content": "Applications often need to intercept messages before they are sent out, for example to add message properties to all outgoing messages.\nThe `org.springframework.messaging.core.MessagePostProcessor` based on the spring-messaging `Message` can do that,\nwhen configured on the `JmsClient`. It will be used for all outgoing messages sent with the `send` and `sendAndReceive` methods.\n\nHere is an example of an interceptor adding a \"tenantId\" property to all outgoing messages.\n\ninclude-code::./JmsClientWithPostProcessor[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/sending.adoc", "title": "sending", "heading": "Post-processing outgoing messages", "heading_level": 2, "file_order": 159, "section_index": 4, "content_hash": "2cfcdae84be2cae4d5d928570c346656f057b9f9d1be1c65be51752c4936c3b1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/sending.adoc"}}
{"id": "sha256:610652a8f9fbaa18b129cc380f445a0db80797a7be4d89ff566d20fe90ce72ad", "content": "[[jms-using]]\n\nThis section describes how to use Spring's JMS components.\n\n[[jms-jmstemplate-jmsclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "using", "heading_level": 1, "file_order": 160, "section_index": 0, "content_hash": "610652a8f9fbaa18b129cc380f445a0db80797a7be4d89ff566d20fe90ce72ad", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:f5fce3dd9ef8dad923d65a50498fa1f901567b081d7fd5a195d81c6892ab165a", "content": "The `JmsTemplate` class is the central class in the JMS core package. It simplifies the\nuse of JMS, since it handles the creation and release of resources when sending or\nsynchronously receiving messages.\n\n`JmsClient` is a new API variant in Spring Framework 7.0, following the design of\n`JdbcClient` and co. `JmsClient` builds on `JmsTemplate` for straightforward send\nand receive operations with customization options per operation.\n\n[[jms-jmstemplate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "`JmsTemplate` and `JmsClient`", "heading_level": 2, "file_order": 160, "section_index": 1, "content_hash": "f5fce3dd9ef8dad923d65a50498fa1f901567b081d7fd5a195d81c6892ab165a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:562617176785a85d6fba6b922b70a8c3f4bace1ce03c0c3ef2b49be1435b23e3", "content": "Code that uses the `JmsTemplate` needs only to implement callback interfaces that give them\na clearly defined high-level contract. The `MessageCreator` callback interface creates a\nmessage when given a `Session` provided by the calling code in `JmsTemplate`. To\nallow for more complex usage of the JMS API, `SessionCallback` provides the\nJMS session, and `ProducerCallback` exposes a `Session` and\n`MessageProducer` pair.\n\nThe JMS API exposes two types of send methods, one that takes delivery mode, priority,\nand time-to-live as Quality of Service (QOS) parameters and one that takes no QOS\nparameters and uses default values. Since `JmsTemplate` has many send methods,\nsetting the QOS parameters have been exposed as bean properties to\navoid duplication in the number of send methods. Similarly, the timeout value for\nsynchronous receive calls is set by using the `setReceiveTimeout` property.\n\nSome JMS providers allow the setting of default QOS values administratively through the\nconfiguration of the `ConnectionFactory`. This has the effect that a call to a\n`MessageProducer` instance's `send` method (`send(Destination destination, Message message)`)\nuses different QOS default values than those specified in the JMS specification. In order\nto provide consistent management of QOS values, the `JmsTemplate` must, therefore, be\nspecifically enabled to use its own QOS values by setting the boolean property\n`isExplicitQosEnabled` to `true`.\n\nFor convenience, `JmsTemplate` also exposes a basic request-reply operation that allows\nfor sending a message and waiting for a reply on a temporary queue that is created as part of\nthe operation.\n\nIMPORTANT: Instances of the `JmsTemplate` class are thread-safe, once configured. This is\nimportant, because it means that you can configure a single instance of a `JmsTemplate`\nand then safely inject this shared reference into multiple collaborators. To be\nclear, the `JmsTemplate` is stateful, in that it maintains a reference to a\n`ConnectionFactory`, but this state is not conversational state.\n\n[[jms-jmsclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "Using `JmsTemplate`", "heading_level": 3, "file_order": 160, "section_index": 2, "content_hash": "562617176785a85d6fba6b922b70a8c3f4bace1ce03c0c3ef2b49be1435b23e3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:3d434912f14e299fe5e780cd9c31bb054ba6ab82c29cfab6d2fc89c86ce8117d", "content": "As of Spring Framework 4.1, `JmsMessagingTemplate` is built on top of `JmsTemplate`\nand provides an integration with the Spring's common messaging abstraction -- that is,\nhandling `org.springframework.messaging.Message` for sending and receiving,\nthrowing `org.springframework.messaging.MessagingException` and with payload conversion\ngoing through `org.springframework.messaging.converter.MessageConverter` (with many\ncommon converter implementations available).\n\nAs of Spring Framework 7.0, a fluent API called `JmsClient` is available. This provides\ncustomizable operations around `org.springframework.messaging.Message` and throwing\n`org.springframework.messaging.MessagingException`, similar to `JmsMessagingTemplate`,\nas well as integration with `org.springframework.messaging.converter.MessageConverter`.\nA `JmsClient can either be created for a given `ConnectionFactory` or for a given\n`JmsTemplate`, in the latter case reusing its settings by default. See\n{spring-framework-api}/jms/core/JmsClient.html[`JmsClient`] for usage examples.\n\n[[jms-connections]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "Using `JmsClient`", "heading_level": 3, "file_order": 160, "section_index": 3, "content_hash": "3d434912f14e299fe5e780cd9c31bb054ba6ab82c29cfab6d2fc89c86ce8117d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:bd99633a187c73300904e388cdf74b4f87e43f25ef3a255b5d56be66bec68706", "content": "The `JmsTemplate` requires a reference to a `ConnectionFactory`. The `ConnectionFactory`\nis part of the JMS specification and serves as the entry point for working with JMS. It\nis used by the client application as a factory to create connections with the JMS\nprovider and encapsulates various configuration parameters, many of which are\nvendor-specific, such as SSL configuration options.\n\nWhen using JMS inside an EJB, the vendor provides implementations of the JMS interfaces\nso that they can participate in declarative transaction management and perform pooling\nof connections and sessions. In order to use this implementation, Jakarta EE containers\ntypically require that you declare a JMS connection factory as a `resource-ref` inside\nthe EJB or servlet deployment descriptors. To ensure the use of these features with the\n`JmsTemplate` inside an EJB, the client application should ensure that it references the\nmanaged implementation of the `ConnectionFactory`.\n\n[[jms-caching-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "Connections", "heading_level": 2, "file_order": 160, "section_index": 4, "content_hash": "bd99633a187c73300904e388cdf74b4f87e43f25ef3a255b5d56be66bec68706", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:e1f0927440a1154ab2d1cb91acd2703678e589ba31ac0ab482d742671cc054ea", "content": "The standard API involves creating many intermediate objects. To send a message, the\nfollowing 'API' walk is performed:\n\n[literal]\n[subs=\"verbatim,quotes\"]\n----\nConnectionFactory->Connection->Session->MessageProducer->send\n----\n\nBetween the `ConnectionFactory` and the `Send` operation, three intermediate\nobjects are created and destroyed. To optimize the resource usage and increase\nperformance, Spring provides two implementations of `ConnectionFactory`.\n\n[[jms-connection-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "Caching Messaging Resources", "heading_level": 3, "file_order": 160, "section_index": 5, "content_hash": "e1f0927440a1154ab2d1cb91acd2703678e589ba31ac0ab482d742671cc054ea", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:477398f2022f500982e4c5342947ef0c4424c3b5ac1dd32904d90dff946847bc", "content": "Spring provides an implementation of the `ConnectionFactory` interface,\n`SingleConnectionFactory`, that returns the same `Connection` on all\n`createConnection()` calls and ignores calls to `close()`. This is useful for testing and\nstandalone environments so that the same connection can be used for multiple\n`JmsTemplate` calls that may span any number of transactions. `SingleConnectionFactory`\ntakes a reference to a standard `ConnectionFactory` that would typically come from JNDI.\n\n[[jdbc-connection-factory-caching]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "Using `SingleConnectionFactory`", "heading_level": 3, "file_order": 160, "section_index": 6, "content_hash": "477398f2022f500982e4c5342947ef0c4424c3b5ac1dd32904d90dff946847bc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:e0c1f832c973b774aaf0a121beb6a50b11ed2964ca7b9d0e0a13e6ec64b6d483", "content": "The `CachingConnectionFactory` extends the functionality of `SingleConnectionFactory`\nand adds the caching of `Session`, `MessageProducer`, and `MessageConsumer` instances.\nThe initial cache size is set to `1`. You can use the `sessionCacheSize` property to\nincrease the number of cached sessions. Note that the number of actual cached sessions\nis more than that number, as sessions are cached based on their acknowledgment mode,\nso there can be up to four cached session instances (one for each acknowledgment mode)\nwhen `sessionCacheSize` is set to one. `MessageProducer` and `MessageConsumer` instances\nare cached within their owning session and also take into account the unique properties\nof the producers and consumers when caching. MessageProducers are cached based on their\ndestination. MessageConsumers are cached based on a key composed of the destination, selector,\nnoLocal delivery flag, and the durable subscription name (if creating durable consumers).\n\n[NOTE]\n====\nMessageProducers and MessageConsumers for temporary queues and topics\n(TemporaryQueue/TemporaryTopic) will never be cached. Unfortunately, WebLogic JMS happens\nto implement the temporary queue/topic interfaces on its regular destination implementation,\nmis-indicating that none of its destinations can be cached. Please use a different connection\npool/cache on WebLogic, or customize `CachingConnectionFactory` for WebLogic purposes.\n====\n\n[[jms-destinations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "Using `CachingConnectionFactory`", "heading_level": 3, "file_order": 160, "section_index": 7, "content_hash": "e0c1f832c973b774aaf0a121beb6a50b11ed2964ca7b9d0e0a13e6ec64b6d483", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:522bfbb6e720edeadb77161636eab2d7b945bf6472509a357dd8b1ae3d0785c4", "content": "Destinations, as `ConnectionFactory` instances, are JMS administered objects that you can store\nand retrieve in JNDI. When configuring a Spring application context, you can use the\nJNDI `JndiObjectFactoryBean` factory class or `<jee:jndi-lookup>` to perform dependency\ninjection on your object's references to JMS destinations. However, this strategy\nis often cumbersome if there are a large number of destinations in the application or if there\nare advanced destination management features unique to the JMS provider. Examples of\nsuch advanced destination management include the creation of dynamic destinations or\nsupport for a hierarchical namespace of destinations. The `JmsTemplate` delegates the\nresolution of a destination name to a JMS destination object that implements the\n`DestinationResolver` interface. `DynamicDestinationResolver` is the default\nimplementation used by `JmsTemplate` and accommodates resolving dynamic destinations. A\n`JndiDestinationResolver` is also provided to act as a service locator for\ndestinations contained in JNDI and optionally falls back to the behavior contained in\n`DynamicDestinationResolver`.\n\nQuite often, the destinations used in a JMS application are only known at runtime and,\ntherefore, cannot be administratively created when the application is deployed. This is\noften because there is shared application logic between interacting system components\nthat create destinations at runtime according to a well-known naming convention. Even\nthough the creation of dynamic destinations is not part of the JMS specification, most\nvendors have provided this functionality. Dynamic destinations are created with a user-defined name,\nwhich differentiates them from temporary destinations, and are often\nnot registered in JNDI. The API used to create dynamic destinations varies from provider\nto provider since the properties associated with the destination are vendor-specific.\nHowever, a simple implementation choice that is sometimes made by vendors is to\ndisregard the warnings in the JMS specification and to use the method `TopicSession`\n`createTopic(String topicName)` or the `QueueSession` `createQueue(String\nqueueName)` method to create a new destination with default destination properties. Depending\non the vendor implementation, `DynamicDestinationResolver` can then also create a\nphysical destination instead of only resolving one.\n\nThe boolean property `pubSubDomain` is used to configure the `JmsTemplate` with\nknowledge of what JMS domain is being used. By default, the value of this property is\nfalse, indicating that the point-to-point domain, `Queues`, is to be used. This property\n(used by `JmsTemplate`) determines the behavior of dynamic destination resolution through\nimplementations of the `DestinationResolver` interface.\n\nYou can also configure the `JmsTemplate` with a default destination through the\nproperty `defaultDestination`. The default destination is with send and receive\noperations that do not refer to a specific destination.\n\n[[jms-mdp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "Destination Management", "heading_level": 2, "file_order": 160, "section_index": 8, "content_hash": "522bfbb6e720edeadb77161636eab2d7b945bf6472509a357dd8b1ae3d0785c4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:45c66fa00603adf4de1744925c423ef8528b4183e8893f471bf7cb9fdd55ec56", "content": "One of the most common uses of JMS messages in the EJB world is to drive message-driven\nbeans (MDBs). Spring offers a solution to create message-driven POJOs (MDPs) in a way\nthat does not tie a user to an EJB container. (See\nxref:integration/jms/receiving.adoc#jms-receiving-async[Asynchronous Receipt: Message-Driven POJOs]\nfor detailed coverage of Spring's MDP support.) Endpoint methods can be annotated with\n`@JmsListener` -- see xref:integration/jms/annotated.adoc[Annotation-driven Listener Endpoints]\nfor more details.\n\nA message listener container is used to receive messages from a JMS message queue and\ndrive the `MessageListener` that is injected into it. The listener container is\nresponsible for all threading of message receipt and dispatches into the listener for\nprocessing. A message listener container is the intermediary between an MDP and a\nmessaging provider and takes care of registering to receive messages, participating in\ntransactions, resource acquisition and release, exception conversion, and so on. This\nlets you write the (possibly complex) business logic\nassociated with receiving a message (and possibly respond to it), and delegates\nboilerplate JMS infrastructure concerns to the framework.\n\nThere are two standard JMS message listener containers packaged with Spring, each with\nits specialized feature set.\n\n* xref:integration/jms/using.adoc#jms-mdp-simple[`SimpleMessageListenerContainer`]\n* xref:integration/jms/using.adoc#jms-mdp-default[`DefaultMessageListenerContainer`]\n\n[[jms-mdp-simple]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "Message Listener Containers", "heading_level": 2, "file_order": 160, "section_index": 9, "content_hash": "45c66fa00603adf4de1744925c423ef8528b4183e8893f471bf7cb9fdd55ec56", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:e77ecd58692c047e25495eefae692036722b6e50d275fef519f53f0270b0365c", "content": "This message listener container is the simpler of the two standard flavors. It creates\na fixed number of JMS sessions and consumers at startup, registers the listener by using\nthe standard JMS `MessageConsumer.setMessageListener()` method, and leaves it up the JMS\nprovider to perform listener callbacks. This variant does not allow for dynamic adaption\nto runtime demands or for participation in externally managed transactions.\nCompatibility-wise, it stays very close to the spirit of the standalone JMS\nspecification, but is generally not compatible with Jakarta EE's JMS restrictions.\n\nNOTE: While `SimpleMessageListenerContainer` does not allow for participation in externally\nmanaged transactions, it does support native JMS transactions. To enable this feature,\nyou can switch the `sessionTransacted` flag to `true` or, in the XML namespace, set the\n`acknowledge` attribute to `transacted`. Exceptions thrown from your listener then lead\nto a rollback, with the message getting redelivered. Alternatively, consider using\n`CLIENT_ACKNOWLEDGE` mode, which provides redelivery in case of an exception as well but\ndoes not use transacted `Session` instances and, therefore, does not include any other\n`Session` operations (such as sending response messages) in the transaction protocol.\n\nIMPORTANT: The default `AUTO_ACKNOWLEDGE` mode does not provide proper reliability guarantees.\nMessages can get lost when listener execution fails (since the provider automatically\nacknowledges each message after listener invocation, with no exceptions to be propagated to\nthe provider) or when the listener container shuts down (you can configure this by setting\nthe `acceptMessagesWhileStopping` flag). Make sure to use transacted sessions in case of\nreliability needs (for example, for reliable queue handling and durable topic subscriptions).\n\n[[jms-mdp-default]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "Using `SimpleMessageListenerContainer`", "heading_level": 3, "file_order": 160, "section_index": 10, "content_hash": "e77ecd58692c047e25495eefae692036722b6e50d275fef519f53f0270b0365c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:43a083ad400478775139ad7e4e67fed2c53dc02bc0d8a624df997b25b78b2de6", "content": "This message listener container is used in most cases. In contrast to\n`SimpleMessageListenerContainer`, this container variant allows for dynamic adaptation\nto runtime demands and is able to participate in externally managed transactions.\nEach received message is registered with an XA transaction when configured with a\n`JtaTransactionManager`. As a result, processing may take advantage of XA transaction\nsemantics. This listener container strikes a good balance between low requirements on\nthe JMS provider, advanced functionality (such as participation in externally managed\ntransactions), and compatibility with Jakarta EE environments.\n\nYou can customize the cache level of the container. Note that, when no caching is enabled,\na new connection and a new session is created for each message receipt. Combining this\nwith a non-durable subscription with high loads may lead to message loss. Make sure to\nuse a proper cache level in such a case.\n\nThis container also has recoverable capabilities when the broker goes down. By default,\na simple `BackOff` implementation retries every five seconds. You can specify\na custom `BackOff` implementation for more fine-grained recovery options. See\n{spring-framework-api}/util/backoff/ExponentialBackOff.html[`ExponentialBackOff`] for an example.\n\nNOTE: Like its sibling (xref:integration/jms/using.adoc#jms-mdp-simple[`SimpleMessageListenerContainer`]),\n`DefaultMessageListenerContainer` supports native JMS transactions and allows for\ncustomizing the acknowledgment mode. If feasible for your scenario, This is strongly\nrecommended over externally managed transactions -- that is, if you can live with\noccasional duplicate messages in case of the JVM dying. Custom duplicate message\ndetection steps in your business logic can cover such situations -- for example,\nin the form of a business entity existence check or a protocol table check.\nAny such arrangements are significantly more efficient than the alternative:\nwrapping your entire processing with an XA transaction (through configuring your\n`DefaultMessageListenerContainer` with an `JtaTransactionManager`) to cover the\nreceipt of the JMS message as well as the execution of the business logic in your\nmessage listener (including database operations, etc.).\n\nIMPORTANT: The default `AUTO_ACKNOWLEDGE` mode does not provide proper reliability guarantees.\nMessages can get lost when listener execution fails (since the provider automatically\nacknowledges each message after listener invocation, with no exceptions to be propagated to\nthe provider) or when the listener container shuts down (you can configure this by setting\nthe `acceptMessagesWhileStopping` flag). Make sure to use transacted sessions in case of\nreliability needs (for example, for reliable queue handling and durable topic subscriptions).\n\n[[jms-tx]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "Using `DefaultMessageListenerContainer`", "heading_level": 3, "file_order": 160, "section_index": 11, "content_hash": "43a083ad400478775139ad7e4e67fed2c53dc02bc0d8a624df997b25b78b2de6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:7591c86aff0168b814ea0c9bfb39bf6f390988f30f54a45ba60c91e7588d9e26", "content": "Spring provides a `JmsTransactionManager` that manages transactions for a single JMS\n`ConnectionFactory`. This lets JMS applications leverage the managed-transaction\nfeatures of Spring, as described in\nxref:data-access/transaction.adoc[Transaction Management section of the Data Access chapter].\nThe `JmsTransactionManager` performs local resource transactions, binding a JMS\nConnection/Session pair from the specified `ConnectionFactory` to the thread.\n`JmsTemplate` automatically detects such transactional resources and operates\non them accordingly.\n\nIn a Jakarta EE environment, the `ConnectionFactory` pools Connection and Session instances,\nso those resources are efficiently reused across transactions. In a standalone environment,\nusing Spring's `SingleConnectionFactory` result in a shared JMS `Connection`, with\neach transaction having its own independent `Session`. Alternatively, consider the use\nof a provider-specific pooling adapter, such as ActiveMQ's `PooledConnectionFactory`\nclass.\n\nYou can also use `JmsTemplate` with the `JtaTransactionManager` and an XA-capable JMS\n`ConnectionFactory` to perform distributed transactions. Note that this requires the\nuse of a JTA transaction manager as well as a properly XA-configured ConnectionFactory.\n(Check your Jakarta EE server's or JMS provider's documentation.)\n\nReusing code across a managed and unmanaged transactional environment can be confusing\nwhen using the JMS API to create a `Session` from a `Connection`. This is because the\nJMS API has only one factory method to create a `Session`, and it requires values for the\ntransaction and acknowledgment modes. In a managed environment, setting these values is\nthe responsibility of the environment's transactional infrastructure, so these values\nare ignored by the vendor's wrapper to the JMS Connection. When you use the `JmsTemplate`\nin an unmanaged environment, you can specify these values through the use of the\nproperties `sessionTransacted` and `sessionAcknowledgeMode`. When you use a\n`PlatformTransactionManager` with `JmsTemplate`, the template is always given a\ntransactional JMS `Session`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms/using.adoc", "title": "using", "heading": "Transaction Management", "heading_level": 2, "file_order": 160, "section_index": 12, "content_hash": "7591c86aff0168b814ea0c9bfb39bf6f390988f30f54a45ba60c91e7588d9e26", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms/using.adoc"}}
{"id": "sha256:198c9edf1beb73750bb2386953b6d9f6c3ec93c1b657a8f20109413a7520b809", "content": "[[jmx-exporting]]\n\nThe core class in Spring's JMX framework is the `MBeanExporter`. This class is\nresponsible for taking your Spring beans and registering them with a JMX `MBeanServer`.\nFor example, consider the following class:\n\ninclude-code::./JmxTestBean[tag=snippet,indent=0]\n\nTo expose the properties and methods of this bean as attributes and operations of an\nMBean, you can configure an instance of the `MBeanExporter` class in your\nconfiguration file and pass in the bean, as the following example shows:\n\ninclude-code::./JmxConfiguration[tag=snippet,indent=0]\n\nThe pertinent bean definition from the preceding configuration snippet is the `exporter`\nbean. The `beans` property tells the `MBeanExporter` exactly which of your beans must be\nexported to the JMX `MBeanServer`. In the default configuration, the key of each entry\nin the `beans` `Map` is used as the `ObjectName` for the bean referenced by the\ncorresponding entry value. You can change this behavior, as described in xref:integration/jmx/naming.adoc[Controlling `ObjectName` Instances for Your Beans].\n\nWith this configuration, the `testBean` bean is exposed as an MBean under the\n`ObjectName` `bean:name=testBean1`. By default, all `public` properties of the bean\nare exposed as attributes and all `public` methods (except those inherited from the\n`Object` class) are exposed as operations.\n\nNOTE: `MBeanExporter` is a `Lifecycle` bean (see xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-processor[Startup and Shutdown Callbacks]\n). By default, MBeans are exported as late as possible during\nthe application lifecycle. You can configure the `phase` at which\nthe export happens or disable automatic registration by setting the `autoStartup` flag.\n\n[[jmx-exporting-mbeanserver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/exporting.adoc", "title": "exporting", "heading": "exporting", "heading_level": 1, "file_order": 161, "section_index": 0, "content_hash": "198c9edf1beb73750bb2386953b6d9f6c3ec93c1b657a8f20109413a7520b809", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/exporting.adoc"}}
{"id": "sha256:b04e5a49a3295d69cdf8fac13bd13e9a908b94dee82c4002e80fbaceb5f13cc2", "content": "The configuration shown in the xref:integration/jmx/exporting.adoc[preceding section] assumes that the\napplication is running in an environment that has one (and only one) `MBeanServer`\nalready running. In this case, Spring tries to locate the running `MBeanServer` and\nregister your beans with that server (if any). This behavior is useful when your\napplication runs inside a container (such as Tomcat or IBM WebSphere) that has its\nown `MBeanServer`.\n\nHowever, this approach is of no use in a standalone environment or when running inside\na container that does not provide an `MBeanServer`. To address this, you can create an\n`MBeanServer` instance declaratively by adding an instance of the\n`org.springframework.jmx.support.MBeanServerFactoryBean` class to your configuration.\nYou can also ensure that a specific `MBeanServer` is used by setting the value of the\n`MBeanExporter` instance's `server` property to the `MBeanServer` value returned by an\n`MBeanServerFactoryBean`, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"mbeanServer\" class=\"org.springframework.jmx.support.MBeanServerFactoryBean\"/>\n\n <!--\n this bean needs to be eagerly pre-instantiated in order for the exporting to occur;\n this means that it must not be marked as lazily initialized\n -->\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"beans\">\n <map>\n <entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/>\n </map>\n </property>\n <property name=\"server\" ref=\"mbeanServer\"/>\n </bean>\n\n <bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\">\n <property name=\"name\" value=\"TEST\"/>\n <property name=\"age\" value=\"100\"/>\n </bean>\n\n\t</beans>\n----\n\nIn the preceding example, an instance of `MBeanServer` is created by the `MBeanServerFactoryBean` and is\nsupplied to the `MBeanExporter` through the `server` property. When you supply your own\n`MBeanServer` instance, the `MBeanExporter` does not try to locate a running\n`MBeanServer` and uses the supplied `MBeanServer` instance. For this to work\ncorrectly, you must have a JMX implementation on your classpath.\n\n[[jmx-mbean-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/exporting.adoc", "title": "exporting", "heading": "Creating an MBeanServer", "heading_level": 2, "file_order": 161, "section_index": 1, "content_hash": "b04e5a49a3295d69cdf8fac13bd13e9a908b94dee82c4002e80fbaceb5f13cc2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/exporting.adoc"}}
{"id": "sha256:68e06c336ed25c7cefa60cd8de4a116205d47269ba2b116415b7b15c368a4644", "content": "If no server is specified, the `MBeanExporter` tries to automatically detect a running\n`MBeanServer`. This works in most environments, where only one `MBeanServer` instance is\nused. However, when multiple instances exist, the exporter might pick the wrong server.\nIn such cases, you should use the `MBeanServer` `agentId` to indicate which instance to\nbe used, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"mbeanServer\" class=\"org.springframework.jmx.support.MBeanServerFactoryBean\">\n <!-- indicate to first look for a server -->\n <property name=\"locateExistingServerIfPossible\" value=\"true\"/>\n <!-- search for the MBeanServer instance with the given agentId -->\n <property name=\"agentId\" value=\"MBeanServer_instance_agentId>\"/>\n </bean>\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"server\" ref=\"mbeanServer\"/>\n ...\n </bean>\n\t</beans>\n----\n\nFor platforms or cases where the existing `MBeanServer` has a dynamic (or unknown)\n`agentId` that is retrieved through lookup methods, you should use\nxref:core/beans/definition.adoc#beans-factory-class-static-factory-method[factory-method],\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"server\">\n <!-- Custom MBeanServerLocator -->\n <bean class=\"platform.package.MBeanServerLocator\" factory-method=\"locateMBeanServer\"/>\n </property>\n </bean>\n\n <!-- other beans here -->\n\n\t</beans>\n----\n\n[[jmx-exporting-lazy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/exporting.adoc", "title": "exporting", "heading": "Reusing an Existing `MBeanServer`", "heading_level": 2, "file_order": 161, "section_index": 2, "content_hash": "68e06c336ed25c7cefa60cd8de4a116205d47269ba2b116415b7b15c368a4644", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/exporting.adoc"}}
{"id": "sha256:48a07bd671d963e871238f55e93a568bce04b3f820c61bed569b530c796912e5", "content": "If you configure a bean with an `MBeanExporter` that is also configured for lazy\ninitialization, the `MBeanExporter` does not break this contract and avoids\ninstantiating the bean. Instead, it registers a proxy with the `MBeanServer` and defers\nobtaining the bean from the container until the first invocation on the proxy occurs.\n\nThis also affects `FactoryBean` resolution where `MBeanExporter` will regularly\nintrospect the produced object, effectively triggering `FactoryBean.getObject()`.\nIn order to avoid this, mark the corresponding bean definition as lazy-init.\n\n[[jmx-exporting-auto]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/exporting.adoc", "title": "exporting", "heading": "Lazily Initialized MBeans", "heading_level": 2, "file_order": 161, "section_index": 3, "content_hash": "48a07bd671d963e871238f55e93a568bce04b3f820c61bed569b530c796912e5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/exporting.adoc"}}
{"id": "sha256:9c0e875ad341c71438beec463a4b395b08e6915560897a9a114d72f5a9b98fb7", "content": "Any beans that are exported through the `MBeanExporter` and are already valid MBeans\nare registered as-is with the `MBeanServer` without further intervention from Spring.\nYou can cause MBeans to be automatically detected by the `MBeanExporter` by setting\nthe `autodetect` property to `true`, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"autodetect\" value=\"true\"/>\n\t</bean>\n\n\t<bean name=\"spring:mbean=true\" class=\"org.springframework.jmx.export.TestDynamicMBean\"/>\n----\n\nIn the preceding example, the bean called `spring:mbean=true` is already a valid JMX MBean\nand is automatically registered by Spring. By default, a bean that is autodetected for JMX\nregistration has its bean name used as the `ObjectName`. You can override this behavior,\nas detailed in xref:integration/jmx/naming.adoc[Controlling `ObjectName` Instances for Your Beans].\n\n[[jmx-exporting-registration-behavior]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/exporting.adoc", "title": "exporting", "heading": "Automatic Registration of MBeans", "heading_level": 2, "file_order": 161, "section_index": 4, "content_hash": "9c0e875ad341c71438beec463a4b395b08e6915560897a9a114d72f5a9b98fb7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/exporting.adoc"}}
{"id": "sha256:64dc3f975ac5b39f0994d39a0ff3060d2dc9a75a40d13cc30247d90a76dc3365", "content": "Consider the scenario where a Spring `MBeanExporter` attempts to register an `MBean`\nwith an `MBeanServer` by using the `ObjectName` `bean:name=testBean1`. If an `MBean`\ninstance has already been registered under that same `ObjectName`, the default behavior\nis to fail (and throw an `InstanceAlreadyExistsException`).\n\nYou can control exactly what happens when an `MBean` is\nregistered with an `MBeanServer`. Spring's JMX support allows for three different\nregistration behaviors to control the registration behavior when the registration\nprocess finds that an `MBean` has already been registered under the same `ObjectName`.\nThe following table summarizes these registration behaviors:\n\n[[jmx-registration-behaviors]]\n.Registration Behaviors\n[cols=\"1,4\"]\n|===\n| Registration behavior | Explanation\n\n| `FAIL_ON_EXISTING`\n| This is the default registration behavior. If an `MBean` instance has already been\n registered under the same `ObjectName`, the `MBean` that is being registered is not\n registered, and an `InstanceAlreadyExistsException` is thrown. The existing\n `MBean` is unaffected.\n\n| `IGNORE_EXISTING`\n| If an `MBean` instance has already been registered under the same `ObjectName`, the\n `MBean` that is being registered is not registered. The existing `MBean` is\n unaffected, and no `Exception` is thrown. This is useful in settings where\n multiple applications want to share a common `MBean` in a shared `MBeanServer`.\n\n| `REPLACE_EXISTING`\n| If an `MBean` instance has already been registered under the same `ObjectName`, the\n existing `MBean` that was previously registered is unregistered, and the new\n `MBean` is registered in its place (the new `MBean` effectively replaces the\n previous instance).\n|===\n\nThe values in the preceding table are defined as enums on the `RegistrationPolicy` class.\nIf you want to change the default registration behavior, you need to set the value of the\n`registrationPolicy` property on your `MBeanExporter` definition to one of those\nvalues.\n\nThe following example shows how to change from the default registration\nbehavior to the `REPLACE_EXISTING` behavior:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"beans\">\n <map>\n <entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/>\n </map>\n </property>\n <property name=\"registrationPolicy\" value=\"REPLACE_EXISTING\"/>\n </bean>\n\n <bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\">\n <property name=\"name\" value=\"TEST\"/>\n <property name=\"age\" value=\"100\"/>\n </bean>\n\n\t</beans>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/exporting.adoc", "title": "exporting", "heading": "Controlling the Registration Behavior", "heading_level": 2, "file_order": 161, "section_index": 5, "content_hash": "64dc3f975ac5b39f0994d39a0ff3060d2dc9a75a40d13cc30247d90a76dc3365", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/exporting.adoc"}}
{"id": "sha256:065568414b70818c459ff49856d045773d11e9dc357019cfd940792c8072e1cd", "content": "[[jmx-interface]]\n\nIn the example in the xref:integration/jmx/exporting.adoc#jmx-exporting-registration-behavior[preceding section],\nyou had little control over the management interface of your bean. All of the `public`\nproperties and methods of each exported bean were exposed as JMX attributes and\noperations, respectively. To exercise finer-grained control over exactly which\nproperties and methods of your exported beans are actually exposed as JMX attributes\nand operations, Spring JMX provides a comprehensive and extensible mechanism for\ncontrolling the management interfaces of your beans.\n\n[[jmx-interface-assembler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc", "title": "interface", "heading": "interface", "heading_level": 1, "file_order": 162, "section_index": 0, "content_hash": "065568414b70818c459ff49856d045773d11e9dc357019cfd940792c8072e1cd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc"}}
{"id": "sha256:3cc7675bd3b7277c06c8903b0a1157435a2e91f74e4267493c5b3424e002497d", "content": "Behind the scenes, the `MBeanExporter` delegates to an implementation of the\n`org.springframework.jmx.export.assembler.MBeanInfoAssembler` API, which is\nresponsible for defining the management interface of each bean that is exposed.\nThe default implementation,\n`org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler`,\ndefines a management interface that exposes all public properties and methods\n(as you saw in the examples in the preceding sections). Spring provides two\nadditional implementations of the `MBeanInfoAssembler` interface that let you\ncontrol the generated management interface by using either source-level metadata\nor any arbitrary interface.\n\n[[jmx-interface-metadata]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc", "title": "interface", "heading": "Using the `MBeanInfoAssembler` API", "heading_level": 2, "file_order": 162, "section_index": 1, "content_hash": "3cc7675bd3b7277c06c8903b0a1157435a2e91f74e4267493c5b3424e002497d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc"}}
{"id": "sha256:9e06b25482c2ccf08b340a92aafa96c4c562bc9ed5ac3296f1de68317ec25441", "content": "By using the `MetadataMBeanInfoAssembler`, you can define the management interfaces for\nyour beans by using source-level metadata. The reading of metadata is encapsulated by the\n`org.springframework.jmx.export.metadata.JmxAttributeSource` interface. Spring JMX\nprovides a default implementation that uses Java annotations, namely\n`org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource`. You must\nconfigure the `MetadataMBeanInfoAssembler` with an implementation instance of the\n`JmxAttributeSource` interface for it to function correctly, since there is no default.\n\nTo mark a bean for export to JMX, you should annotate the bean class with the\n`@ManagedResource` annotation. You must annotate each method you wish to expose as an\noperation with the `@ManagedOperation` annotation and annotate each property you wish to\nexpose with the `@ManagedAttribute` annotation. When annotating properties, you can omit\neither the annotation of the getter or the setter to create a write-only or read-only\nattribute, respectively.\n\nNOTE: A `@ManagedResource`-annotated bean must be public, as must the methods exposing\noperations or attributes.\n\nThe following example shows an annotated version of the `JmxTestBean` class that we\nused in xref:integration/jmx/exporting.adoc#jmx-exporting-mbeanserver[Creating an MBeanServer].\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.jmx;\n\n\t@ManagedResource(\n objectName=\"bean:name=testBean4\",\n description=\"My Managed Bean\",\n log=true,\n logFile=\"jmx.log\",\n currencyTimeLimit=15,\n persistPolicy=\"OnUpdate\",\n persistPeriod=200,\n persistLocation=\"foo\",\n persistName=\"bar\")\n\tpublic class AnnotationTestBean {\n\n private int age;\n private String name;\n\n public void setAge(int age) {\n this.age = age;\n }\n\n @ManagedAttribute(description=\"The Age Attribute\", currencyTimeLimit=15)\n public int getAge() {\n return this.age;\n }\n\n @ManagedAttribute(description=\"The Name Attribute\",\n currencyTimeLimit=20,\n defaultValue=\"bar\",\n persistPolicy=\"OnUpdate\")\n public void setName(String name) {\n this.name = name;\n }\n\n @ManagedAttribute(defaultValue=\"foo\", persistPeriod=300)\n public String getName() {\n return this.name;\n }\n\n @ManagedOperation(description=\"Add two numbers\")\n @ManagedOperationParameter(name = \"x\", description = \"The first number\")\n @ManagedOperationParameter(name = \"y\", description = \"The second number\")\n public int add(int x, int y) {\n return x + y;\n }\n\n public void dontExposeMe() {\n throw new RuntimeException();\n }\n\n\t}\n----\n\nIn the preceding example, you can see that the `AnnotationTestBean` class is annotated\nwith `@ManagedResource` and that this `@ManagedResource` annotation is configured\nwith a set of attributes. These attributes can be used to configure various aspects\nof the MBean that is generated by the `MBeanExporter` and are explained in greater\ndetail later in xref:integration/jmx/interface.adoc#jmx-interface-metadata-types[Spring JMX Annotations].\n\nBoth the `age` and `name` properties are annotated with `@ManagedAttribute`,\nbut, in the case of the `age` property, only the getter method is annotated.\nThis causes both of these properties to be included in the management interface\nas managed attributes, but the `age` attribute is read-only.\n\nFinally, the `add(int, int)` method is annotated with `@ManagedOperation`,\nwhereas the `dontExposeMe()` method is not. This causes the management interface to\ncontain only one operation (`add(int, int)`) when you use the `MetadataMBeanInfoAssembler`.\n\nNOTE: The `AnnotationTestBean` class is not required to implement any Java interfaces,\nsince the JMX management interface is derived solely from annotations.\n\nThe following configuration shows how you can configure the `MBeanExporter` to use the\n`MetadataMBeanInfoAssembler`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"assembler\" ref=\"assembler\"/>\n <property name=\"namingStrategy\" ref=\"namingStrategy\"/>\n <property name=\"autodetect\" value=\"true\"/>\n </bean>\n\n <!-- will create management interface using annotation metadata -->\n <bean id=\"assembler\"\n class=\"org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler\">\n <property name=\"attributeSource\" ref=\"jmxAttributeSource\"/>\n </bean>\n\n <!-- will pick up the ObjectName from the annotation -->\n <bean id=\"namingStrategy\"\n class=\"org.springframework.jmx.export.naming.MetadataNamingStrategy\">\n <property name=\"attributeSource\" ref=\"jmxAttributeSource\"/>\n </bean>\n\n <bean id=\"jmxAttributeSource\"\n class=\"org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource\"/>\n\n <bean id=\"testBean\" class=\"org.springframework.jmx.AnnotationTestBean\">\n <property name=\"name\" value=\"TEST\"/>\n <property name=\"age\" value=\"100\"/>\n </bean>\n\n\t</beans>\n----\n\nIn the preceding example, a `MetadataMBeanInfoAssembler` bean has been configured with an\ninstance of the `AnnotationJmxAttributeSource` class and passed to the `MBeanExporter`\nthrough the assembler property. This is all that is required to take advantage of\nannotation-driven management interfaces for your Spring-exposed MBeans.\n\n[[jmx-interface-metadata-types]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc", "title": "interface", "heading": "Using Source-level Metadata: Java Annotations", "heading_level": 2, "file_order": 162, "section_index": 2, "content_hash": "9e06b25482c2ccf08b340a92aafa96c4c562bc9ed5ac3296f1de68317ec25441", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc"}}
{"id": "sha256:8dbeb71a3a38b9f360a3d7d0887c2640398614e18e5342e0fbf1881c8b4334b1", "content": "The following table describes the annotations that are available for use in Spring JMX:\n\n[[jmx-metadata-types]]\n.Spring JMX annotations\n[cols=\"1,1,3\"]\n|===\n| Annotation | Applies to | Description\n\n| `@ManagedResource`\n| Classes\n| Marks all instances of a `Class` as JMX managed resources.\n\n| `@ManagedNotification`\n| Classes\n| Indicates a JMX notification emitted by a managed resource.\n\n| `@ManagedAttribute`\n| Methods (only getters and setters)\n| Marks a getter or setter as one half of a JMX attribute.\n\n| `@ManagedMetric`\n| Methods (only getters)\n| Marks a getter as a JMX attribute, with added descriptor properties to indicate that it is a metric.\n\n| `@ManagedOperation`\n| Methods\n| Marks a method as a JMX operation.\n\n| `@ManagedOperationParameter`\n| Methods\n| Defines a description for an operation parameter.\n|===\n\nThe following table describes some of the common attributes that are available for use in\nthese annotations. Consult the Javadoc for each annotation for further details.\n\n[[jmx-metadata-parameters]]\n.Spring JMX annotation attributes\n[cols=\"1,1,3\"]\n|===\n| Attribute | Applies to | Description\n\n| `objectName`\n| `@ManagedResource`\n| Used by `MetadataNamingStrategy` to determine the `ObjectName` of a managed resource.\n\n| `description`\n| `@ManagedResource`, `@ManagedNotification`, `@ManagedAttribute`, `@ManagedMetric`,\n `@ManagedOperation`, `@ManagedOperationParameter`\n| Sets the description of the resource, notification, attribute, metric, or operation.\n\n| `currencyTimeLimit`\n| `@ManagedResource`, `@ManagedAttribute`, `@ManagedMetric`\n| Sets the value of the `currencyTimeLimit` descriptor field.\n\n| `defaultValue`\n| `@ManagedAttribute`\n| Sets the value of the `defaultValue` descriptor field.\n\n| `log`\n| `@ManagedResource`\n| Sets the value of the `log` descriptor field.\n\n| `logFile`\n| `@ManagedResource`\n| Sets the value of the `logFile` descriptor field.\n\n| `persistPolicy`\n| `@ManagedResource`, `@ManagedMetric`\n| Sets the value of the `persistPolicy` descriptor field.\n\n| `persistPeriod`\n| `@ManagedResource`, `@ManagedMetric`\n| Sets the value of the `persistPeriod` descriptor field.\n\n| `persistLocation`\n| `@ManagedResource`\n| Sets the value of the `persistLocation` descriptor field.\n\n| `persistName`\n| `@ManagedResource`\n| Sets the value of the `persistName` descriptor field.\n\n| `name`\n| `@ManagedOperationParameter`\n| Sets the display name of an operation parameter.\n\n| `index`\n| `@ManagedOperationParameter`\n| Sets the index of an operation parameter.\n|===\n\n[[jmx-interface-autodetect]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc", "title": "interface", "heading": "Spring JMX Annotations", "heading_level": 2, "file_order": 162, "section_index": 3, "content_hash": "8dbeb71a3a38b9f360a3d7d0887c2640398614e18e5342e0fbf1881c8b4334b1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc"}}
{"id": "sha256:cd41a572272e36064ec9feb57294a9e0ac64355db34f5600aa9bb79c0f8edc03", "content": "To simplify configuration even further, Spring includes the\n`AutodetectCapableMBeanInfoAssembler` interface, which extends the `MBeanInfoAssembler`\ninterface to add support for auto-detection of MBean resources. If you configure the\n`MBeanExporter` with an instance of `AutodetectCapableMBeanInfoAssembler`, it is\nallowed to \"vote\" on the inclusion of beans for exposure to JMX.\n\nThe only implementation of the `AutodetectCapableMBeanInfo` interface is\nthe `MetadataMBeanInfoAssembler`, which votes to include any bean that is marked\nwith the `ManagedResource` attribute. The default approach in this case is to use the\nbean name as the `ObjectName`, which results in configuration similar to the following:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <!-- notice how no 'beans' are explicitly configured here -->\n <property name=\"autodetect\" value=\"true\"/>\n <property name=\"assembler\" ref=\"assembler\"/>\n </bean>\n\n <bean id=\"assembler\" class=\"org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler\">\n <property name=\"attributeSource\">\n <bean class=\"org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource\"/>\n </property>\n </bean>\n\n <bean id=\"testBean\" class=\"org.springframework.jmx.AnnotationTestBean\">\n <property name=\"name\" value=\"TEST\"/>\n <property name=\"age\" value=\"100\"/>\n </bean>\n\n\t</beans>\n----\n\nNotice that, in the preceding configuration, no beans are passed to the `MBeanExporter`.\nHowever, the `AnnotationTestBean` is still registered, since it is annotated with\n`@ManagedResource` and the `MetadataMBeanInfoAssembler` detects this and votes to include\nit. The only downside with this approach is that the name of the `AnnotationTestBean` now\nhas business meaning. You can address this issue by configuring an `ObjectNamingStrategy`\nas explained in xref:integration/jmx/naming.adoc[Controlling `ObjectName` Instances for\nYour Beans]. You can also see an example which uses the `MetadataNamingStrategy` in\nxref:integration/jmx/interface.adoc#jmx-interface-metadata[Using Source-level Metadata: Java Annotations].\n\n[[jmx-interface-java]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc", "title": "interface", "heading": "Using the `AutodetectCapableMBeanInfoAssembler` Interface", "heading_level": 2, "file_order": 162, "section_index": 4, "content_hash": "cd41a572272e36064ec9feb57294a9e0ac64355db34f5600aa9bb79c0f8edc03", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc"}}
{"id": "sha256:f10324b3e1f5c0e05580d987f67712c3d45559d50157439fd7e940e832a3b7a2", "content": "In addition to the `MetadataMBeanInfoAssembler`, Spring also includes the\n`InterfaceBasedMBeanInfoAssembler`, which lets you constrain the methods and\nproperties that are exposed based on the set of methods defined in a collection of\ninterfaces.\n\nAlthough the standard mechanism for exposing MBeans is to use interfaces and a simple\nnaming scheme, `InterfaceBasedMBeanInfoAssembler` extends this functionality by\nremoving the need for naming conventions, letting you use more than one interface\nand removing the need for your beans to implement the MBean interfaces.\n\nConsider the following interface, which is used to define a management interface for the\n`JmxTestBean` class that we showed earlier:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface IJmxTestBean {\n\n public int add(int x, int y);\n\n public long myOperation();\n\n public int getAge();\n\n public void setAge(int age);\n\n public void setName(String name);\n\n public String getName();\n\n\t}\n----\n\nThis interface defines the methods and properties that are exposed as operations and\nattributes on the JMX MBean. The following code shows how to configure Spring JMX to use\nthis interface as the definition for the management interface:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"beans\">\n <map>\n <entry key=\"bean:name=testBean5\" value-ref=\"testBean\"/>\n </map>\n </property>\n <property name=\"assembler\">\n <bean class=\"org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler\">\n <property name=\"managedInterfaces\">\n <value>org.springframework.jmx.IJmxTestBean</value>\n </property>\n </bean>\n </property>\n </bean>\n\n <bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\">\n <property name=\"name\" value=\"TEST\"/>\n <property name=\"age\" value=\"100\"/>\n </bean>\n\n\t</beans>\n----\n\nIn the preceding example, the `InterfaceBasedMBeanInfoAssembler` is configured to use the\n`IJmxTestBean` interface when constructing the management interface for any bean. It is\nimportant to understand that beans processed by the `InterfaceBasedMBeanInfoAssembler`\nare not required to implement the interface used to generate the JMX management\ninterface.\n\nIn the preceding case, the `IJmxTestBean` interface is used to construct all management\ninterfaces for all beans. In many cases, this is not the desired behavior, and you may\nwant to use different interfaces for different beans. In this case, you can pass\n`InterfaceBasedMBeanInfoAssembler` a `Properties` instance through the `interfaceMappings`\nproperty, where the key of each entry is the bean name and the value of each entry is a\ncomma-separated list of interface names to use for that bean.\n\nIf no management interface is specified through either the `managedInterfaces` or\n`interfaceMappings` properties, the `InterfaceBasedMBeanInfoAssembler` reflects\non the bean and uses all of the interfaces implemented by that bean to create the\nmanagement interface.\n\n[[jmx-interface-methodnames]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc", "title": "interface", "heading": "Defining Management Interfaces by Using Java Interfaces", "heading_level": 2, "file_order": 162, "section_index": 5, "content_hash": "f10324b3e1f5c0e05580d987f67712c3d45559d50157439fd7e940e832a3b7a2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc"}}
{"id": "sha256:d85eaee002f51053c3ceeb8bf02e562ffd22a6dd47e49454b56754b24d41cc9a", "content": "`MethodNameBasedMBeanInfoAssembler` lets you specify a list of method names\nthat are exposed to JMX as attributes and operations. The following code shows a sample\nconfiguration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"beans\">\n <map>\n <entry key=\"bean:name=testBean5\" value-ref=\"testBean\"/>\n </map>\n </property>\n <property name=\"assembler\">\n <bean class=\"org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler\">\n <property name=\"managedMethods\">\n <value>add,myOperation,getName,setName,getAge</value>\n </property>\n </bean>\n </property>\n\t</bean>\n----\n\nIn the preceding example, you can see that the `add` and `myOperation` methods are exposed as JMX\noperations, and `getName()`, `setName(String)`, and `getAge()` are exposed as the\nappropriate half of a JMX attribute. In the preceding code, the method mappings apply to\nbeans that are exposed to JMX. To control method exposure on a bean-by-bean basis, you can use\nthe `methodMappings` property of `MethodNameMBeanInfoAssembler` to map bean names to\nlists of method names.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc", "title": "interface", "heading": "Using `MethodNameBasedMBeanInfoAssembler`", "heading_level": 2, "file_order": 162, "section_index": 6, "content_hash": "d85eaee002f51053c3ceeb8bf02e562ffd22a6dd47e49454b56754b24d41cc9a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/interface.adoc"}}
{"id": "sha256:7a07426583e331bb286e69872c0fdc0af6608c98599d745e975e56df565733df", "content": "[[jmx-jsr160]]\n\nFor remote access, Spring JMX module offers two `FactoryBean` implementations inside the\n`org.springframework.jmx.support` package for creating both server- and client-side\nconnectors.\n\n[[jmx-jsr160-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/jsr160.adoc", "title": "jsr160", "heading": "jsr160", "heading_level": 1, "file_order": 163, "section_index": 0, "content_hash": "7a07426583e331bb286e69872c0fdc0af6608c98599d745e975e56df565733df", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/jsr160.adoc"}}
{"id": "sha256:c0b186af5eebde5c559f2a8d3973208c1d1fdec31a15bec7a6b79f8fbc0d350b", "content": "To have Spring JMX create, start, and expose a JSR-160 `JMXConnectorServer`, you can use the\nfollowing configuration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"serverConnector\" class=\"org.springframework.jmx.support.ConnectorServerFactoryBean\"/>\n----\n\nBy default, `ConnectorServerFactoryBean` creates a `JMXConnectorServer` bound to\n`service:jmx:jmxmp://localhost:9875`. The `serverConnector` bean thus exposes the\nlocal `MBeanServer` to clients through the JMXMP protocol on localhost, port 9875. Note\nthat the JMXMP protocol is marked as optional by the JSR 160 specification. Currently,\nthe main open-source JMX implementation, MX4J, and the one provided with the JDK\ndo not support JMXMP.\n\nTo specify another URL and register the `JMXConnectorServer` itself with the\n`MBeanServer`, you can use the `serviceUrl` and `ObjectName` properties, respectively,\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"serverConnector\"\n class=\"org.springframework.jmx.support.ConnectorServerFactoryBean\">\n <property name=\"objectName\" value=\"connector:name=rmi\"/>\n <property name=\"serviceUrl\"\n value=\"service:jmx:rmi://localhost/jndi/rmi://localhost:1099/myconnector\"/>\n\t</bean>\n----\n\nIf the `ObjectName` property is set, Spring automatically registers your connector\nwith the `MBeanServer` under that `ObjectName`. The following example shows the full set of\nparameters that you can pass to the `ConnectorServerFactoryBean` when creating a\n`JMXConnector`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"serverConnector\"\n class=\"org.springframework.jmx.support.ConnectorServerFactoryBean\">\n <property name=\"objectName\" value=\"connector:name=iiop\"/>\n <property name=\"serviceUrl\"\n value=\"service:jmx:iiop://localhost/jndi/iiop://localhost:900/myconnector\"/>\n <property name=\"threaded\" value=\"true\"/>\n <property name=\"daemon\" value=\"true\"/>\n <property name=\"environment\">\n <map>\n <entry key=\"someKey\" value=\"someValue\"/>\n </map>\n </property>\n\t</bean>\n----\n\nNote that, when you use a RMI-based connector, you need the lookup service (`tnameserv` or\n`rmiregistry`) to be started in order for the name registration to complete.\n\n[[jmx-jsr160-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/jsr160.adoc", "title": "jsr160", "heading": "Server-side Connectors", "heading_level": 2, "file_order": 163, "section_index": 1, "content_hash": "c0b186af5eebde5c559f2a8d3973208c1d1fdec31a15bec7a6b79f8fbc0d350b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/jsr160.adoc"}}
{"id": "sha256:217e54386e6527c6cba4d018ad7c93f56e234f6fd3c3b8e4764add2cd1d47b9f", "content": "To create an `MBeanServerConnection` to a remote JSR-160-enabled `MBeanServer`, you can use the\n`MBeanServerConnectionFactoryBean`, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"clientConnector\" class=\"org.springframework.jmx.support.MBeanServerConnectionFactoryBean\">\n <property name=\"serviceUrl\" value=\"service:jmx:rmi://localhost/jndi/rmi://localhost:1099/jmxrmi\"/>\n\t</bean>\n----\n\n[[jmx-jsr160-protocols]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/jsr160.adoc", "title": "jsr160", "heading": "Client-side Connectors", "heading_level": 2, "file_order": 163, "section_index": 2, "content_hash": "217e54386e6527c6cba4d018ad7c93f56e234f6fd3c3b8e4764add2cd1d47b9f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/jsr160.adoc"}}
{"id": "sha256:4e48e51942930b2cc6743440dd987c916619b87ff94b446b267633d2c891cab1", "content": "JSR-160 permits extensions to the way in which communication is done between the client\nand the server. The examples shown in the preceding sections use the mandatory RMI-based implementation\nrequired by the JSR-160 specification (IIOP and JRMP) and the (optional) JMXMP. By using\nother providers or JMX implementations (such as http://mx4j.sourceforge.net[MX4J]) you\ncan take advantage of protocols such as SOAP or Hessian over simple HTTP or SSL and others,\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"serverConnector\" class=\"org.springframework.jmx.support.ConnectorServerFactoryBean\">\n <property name=\"objectName\" value=\"connector:name=burlap\"/>\n <property name=\"serviceUrl\" value=\"service:jmx:burlap://localhost:9874\"/>\n\t</bean>\n----\n\nIn the preceding example, we used MX4J 3.0.0. See the official MX4J\ndocumentation for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/jsr160.adoc", "title": "jsr160", "heading": "JMX over Hessian or SOAP", "heading_level": 2, "file_order": 163, "section_index": 3, "content_hash": "4e48e51942930b2cc6743440dd987c916619b87ff94b446b267633d2c891cab1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/jsr160.adoc"}}
{"id": "sha256:ea260ef8e67d2abb38fe0e6dc55c9e391bac9a6af1feda6ec17ed3a9beb6c41d", "content": "[[jmx-naming]]\n\nBehind the scenes, the `MBeanExporter` delegates to an implementation of the\n`ObjectNamingStrategy` to obtain an `ObjectName` instance for each of the beans it registers.\nBy default, the default implementation, `KeyNamingStrategy` uses the key of the\n`beans` `Map` as the `ObjectName`. In addition, the `KeyNamingStrategy` can map the key\nof the `beans` `Map` to an entry in a `Properties` file (or files) to resolve the\n`ObjectName`. In addition to the `KeyNamingStrategy`, Spring provides two additional\n`ObjectNamingStrategy` implementations: the `IdentityNamingStrategy` (which builds an\n`ObjectName` based on the JVM identity of the bean) and the `MetadataNamingStrategy` (which\nuses source-level metadata to obtain the `ObjectName`).\n\n[[jmx-naming-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/naming.adoc", "title": "naming", "heading": "naming", "heading_level": 1, "file_order": 164, "section_index": 0, "content_hash": "ea260ef8e67d2abb38fe0e6dc55c9e391bac9a6af1feda6ec17ed3a9beb6c41d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/naming.adoc"}}
{"id": "sha256:99c28a8ce2d42b3b8bca198a7cdbe4006c19498161c7989711fa510d121d3806", "content": "You can configure your own `KeyNamingStrategy` instance and configure it to read\n`ObjectName` instances from a `Properties` instance rather than use a bean key. The\n`KeyNamingStrategy` tries to locate an entry in the `Properties` with a key\nthat corresponds to the bean key. If no entry is found or if the `Properties` instance is\n`null`, the bean key itself is used.\n\nThe following code shows a sample configuration for the `KeyNamingStrategy`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"beans\">\n <map>\n <entry key=\"testBean\" value-ref=\"testBean\"/>\n </map>\n </property>\n <property name=\"namingStrategy\" ref=\"namingStrategy\"/>\n </bean>\n\n <bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\">\n <property name=\"name\" value=\"TEST\"/>\n <property name=\"age\" value=\"100\"/>\n </bean>\n\n <bean id=\"namingStrategy\" class=\"org.springframework.jmx.export.naming.KeyNamingStrategy\">\n <property name=\"mappings\">\n <props>\n <prop key=\"testBean\">bean:name=testBean1</prop>\n </props>\n </property>\n <property name=\"mappingLocations\">\n <value>names1.properties,names2.properties</value>\n </property>\n </bean>\n\n\t</beans>\n----\n\nThe preceding example configures an instance of `KeyNamingStrategy` with a `Properties` instance that\nis merged from the `Properties` instance defined by the mapping property and the\nproperties files located in the paths defined by the mappings property. In this\nconfiguration, the `testBean` bean is given an `ObjectName` of `bean:name=testBean1`,\nsince this is the entry in the `Properties` instance that has a key corresponding to the\nbean key.\n\nIf no entry in the `Properties` instance can be found, the bean key name is used as\nthe `ObjectName`.\n\n[[jmx-naming-metadata]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/naming.adoc", "title": "naming", "heading": "Reading `ObjectName` Instances from Properties", "heading_level": 2, "file_order": 164, "section_index": 1, "content_hash": "99c28a8ce2d42b3b8bca198a7cdbe4006c19498161c7989711fa510d121d3806", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/naming.adoc"}}
{"id": "sha256:893274b78a6f9f217e36f6f9679bbc292258f9d170ec0749dc1e2ba94011ab1b", "content": "`MetadataNamingStrategy` uses the `objectName` property of the `ManagedResource`\nattribute on each bean to create the `ObjectName`. The following code shows the\nconfiguration for the `MetadataNamingStrategy`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"beans\">\n <map>\n <entry key=\"testBean\" value-ref=\"testBean\"/>\n </map>\n </property>\n <property name=\"namingStrategy\" ref=\"namingStrategy\"/>\n </bean>\n\n <bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\">\n <property name=\"name\" value=\"TEST\"/>\n <property name=\"age\" value=\"100\"/>\n </bean>\n\n <bean id=\"namingStrategy\" class=\"org.springframework.jmx.export.naming.MetadataNamingStrategy\">\n <property name=\"attributeSource\" ref=\"attributeSource\"/>\n </bean>\n\n <bean id=\"attributeSource\"\n class=\"org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource\"/>\n\n\t</beans>\n----\n\nIf no `objectName` has been provided for the `ManagedResource` attribute, an\n`ObjectName` is created with the following\nformat: _[fully-qualified-package-name]:type=[short-classname],name=[bean-name]_. For\nexample, the generated `ObjectName` for the following bean would be\n`com.example:type=MyClass,name=myBean`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"myBean\" class=\"com.example.MyClass\"/>\n----\n\n[[jmx-context-mbeanexport]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/naming.adoc", "title": "naming", "heading": "Using `MetadataNamingStrategy`", "heading_level": 2, "file_order": 164, "section_index": 2, "content_hash": "893274b78a6f9f217e36f6f9679bbc292258f9d170ec0749dc1e2ba94011ab1b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/naming.adoc"}}
{"id": "sha256:a758e4d4380ea786dbb39c5d8b4e626da9813c9d938617de2dfb97f487a29a1e", "content": "If you prefer to use xref:integration/jmx/interface.adoc#jmx-interface-metadata[the annotation-based approach] to define\nyour management interfaces, a convenience subclass of `MBeanExporter` is available:\n`AnnotationMBeanExporter`. When defining an instance of this subclass, you no longer need the\n`namingStrategy`, `assembler`, and `attributeSource` configuration,\nsince it always uses standard Java annotation-based metadata (autodetection is\nalways enabled as well). In fact, rather than defining an `MBeanExporter` bean, an even\nsimpler syntax is supported by the `@EnableMBeanExport` `@Configuration` annotation or the `<context:mbean-export/>`\nelement as the following example shows:\n\ninclude-code::./JmxConfiguration[tag=snippet,indent=0]\n\nIf necessary, you can provide a reference to a particular MBean `server`, and the\n`defaultDomain` attribute (a property of `AnnotationMBeanExporter`) accepts an alternate\nvalue for the generated MBean `ObjectName` domains. This is used in place of the\nfully qualified package name as described in the previous section on\nxref:integration/jmx/naming.adoc#jmx-naming-metadata[MetadataNamingStrategy], as the following example shows:\n\ninclude-code::./CustomJmxConfiguration[tag=snippet,indent=0]\n\nCAUTION: Do not use interface-based AOP proxies in combination with autodetection of JMX\nannotations in your bean classes. Interface-based proxies \"`hide`\" the target class, which\nalso hides the JMX-managed resource annotations. Hence, you should use target-class proxies in that\ncase (through setting the 'proxy-target-class' flag on `<aop:config/>`,\n`<tx:annotation-driven/>` and so on). Otherwise, your JMX beans might be silently ignored at\nstartup.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/naming.adoc", "title": "naming", "heading": "Configuring Annotation-based MBean Export", "heading_level": 2, "file_order": 164, "section_index": 3, "content_hash": "a758e4d4380ea786dbb39c5d8b4e626da9813c9d938617de2dfb97f487a29a1e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/naming.adoc"}}
{"id": "sha256:be9ea78d78f397959bd173352780a4e8ad7fa4c9e01cb7082ec998548bc6ecd4", "content": "[[jmx-notifications]]\n\nSpring's JMX offering includes comprehensive support for JMX notifications.\n\n[[jmx-notifications-listeners]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/notifications.adoc", "title": "notifications", "heading": "notifications", "heading_level": 1, "file_order": 165, "section_index": 0, "content_hash": "be9ea78d78f397959bd173352780a4e8ad7fa4c9e01cb7082ec998548bc6ecd4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/notifications.adoc"}}
{"id": "sha256:a68864ca1bfaa8928068181f02039a4d375bd11316815845a8e06cc43d38732b", "content": "Spring's JMX support makes it easy to register any number of\n`NotificationListeners` with any number of MBeans (this includes MBeans exported by\nSpring's `MBeanExporter` and MBeans registered through some other mechanism). For\nexample, consider the scenario where one would like to be informed (through a\n`Notification`) each and every time an attribute of a target MBean changes. The following\nexample writes notifications to the console:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage com.example;\n\n\timport javax.management.AttributeChangeNotification;\n\timport javax.management.Notification;\n\timport javax.management.NotificationFilter;\n\timport javax.management.NotificationListener;\n\n\tpublic class ConsoleLoggingNotificationListener\n implements NotificationListener, NotificationFilter {\n\n public void handleNotification(Notification notification, Object handback) {\n System.out.println(notification);\n System.out.println(handback);\n }\n\n public boolean isNotificationEnabled(Notification notification) {\n return AttributeChangeNotification.class.isAssignableFrom(notification.getClass());\n }\n\n\t}\n----\n\nThe following example adds `ConsoleLoggingNotificationListener` (defined in the preceding\nexample) to `notificationListenerMappings`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"beans\">\n <map>\n <entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/>\n </map>\n </property>\n <property name=\"notificationListenerMappings\">\n <map>\n <entry key=\"bean:name=testBean1\">\n <bean class=\"com.example.ConsoleLoggingNotificationListener\"/>\n </entry>\n </map>\n </property>\n </bean>\n\n <bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\">\n <property name=\"name\" value=\"TEST\"/>\n <property name=\"age\" value=\"100\"/>\n </bean>\n\n\t</beans>\n----\n\nWith the preceding configuration in place, every time a JMX `Notification` is broadcast from\nthe target MBean (`bean:name=testBean1`), the `ConsoleLoggingNotificationListener` bean\nthat was registered as a listener through the `notificationListenerMappings` property is\nnotified. The `ConsoleLoggingNotificationListener` bean can then take whatever action\nit deems appropriate in response to the `Notification`.\n\nYou can also use straight bean names as the link between exported beans and listeners,\nas the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"beans\">\n <map>\n <entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/>\n </map>\n </property>\n <property name=\"notificationListenerMappings\">\n <map>\n <entry key=\"__testBean__\">\n <bean class=\"com.example.ConsoleLoggingNotificationListener\"/>\n </entry>\n </map>\n </property>\n </bean>\n\n <bean id=\"__testBean__\" class=\"org.springframework.jmx.JmxTestBean\">\n <property name=\"name\" value=\"TEST\"/>\n <property name=\"age\" value=\"100\"/>\n </bean>\n\n\t</beans>\n----\n\nIf you want to register a single `NotificationListener` instance for all of the beans\nthat the enclosing `MBeanExporter` exports, you can use the special wildcard (`{asterisk}`)\nas the key for an entry in the `notificationListenerMappings` property\nmap, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<property name=\"notificationListenerMappings\">\n <map>\n <entry key=\"*\">\n <bean class=\"com.example.ConsoleLoggingNotificationListener\"/>\n </entry>\n </map>\n\t</property>\n----\n\nIf you need to do the inverse (that is, register a number of distinct listeners against\nan MBean), you must instead use the `notificationListeners` list property (in\npreference to the `notificationListenerMappings` property). This time, instead of\nconfiguring a `NotificationListener` for a single MBean, we configure\n`NotificationListenerBean` instances. A `NotificationListenerBean` encapsulates a\n`NotificationListener` and the `ObjectName` (or `ObjectNames`) that it is to be\nregistered against in an `MBeanServer`. The `NotificationListenerBean` also encapsulates\na number of other properties, such as a `NotificationFilter` and an arbitrary handback\nobject that can be used in advanced JMX notification scenarios.\n\nThe configuration when using `NotificationListenerBean` instances is not wildly\ndifferent to what was presented previously, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"beans\">\n <map>\n <entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/>\n </map>\n </property>\n <property name=\"notificationListeners\">\n <list>\n <bean class=\"org.springframework.jmx.export.NotificationListenerBean\">\n <constructor-arg>\n <bean class=\"com.example.ConsoleLoggingNotificationListener\"/>\n </constructor-arg>\n <property name=\"mappedObjectNames\">\n <list>\n <value>bean:name=testBean1</value>\n </list>\n </property>\n </bean>\n </list>\n </property>\n </bean>\n\n <bean id=\"testBean\" class=\"org.springframework.jmx.JmxTestBean\">\n <property name=\"name\" value=\"TEST\"/>\n <property name=\"age\" value=\"100\"/>\n </bean>\n\n\t</beans>\n----\n\nThe preceding example is equivalent to the first notification example. Assume, then, that\nwe want to be given a handback object every time a `Notification` is raised and that\nwe also want to filter out extraneous `Notifications` by supplying a\n`NotificationFilter`. The following example accomplishes these goals:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"exporter\" class=\"org.springframework.jmx.export.MBeanExporter\">\n <property name=\"beans\">\n <map>\n <entry key=\"bean:name=testBean1\" value-ref=\"testBean1\"/>\n <entry key=\"bean:name=testBean2\" value-ref=\"testBean2\"/>\n </map>\n </property>\n <property name=\"notificationListeners\">\n <list>\n <bean class=\"org.springframework.jmx.export.NotificationListenerBean\">\n <constructor-arg ref=\"customerNotificationListener\"/>\n <property name=\"mappedObjectNames\">\n <list>\n <!-- handles notifications from two distinct MBeans -->\n <value>bean:name=testBean1</value>\n <value>bean:name=testBean2</value>\n </list>\n </property>\n <property name=\"handback\">\n <bean class=\"java.lang.String\">\n <constructor-arg value=\"This could be anything...\"/>\n </bean>\n </property>\n <property name=\"notificationFilter\" ref=\"customerNotificationListener\"/>\n </bean>\n </list>\n </property>\n </bean>\n\n <!-- implements both the NotificationListener and NotificationFilter interfaces -->\n <bean id=\"customerNotificationListener\" class=\"com.example.ConsoleLoggingNotificationListener\"/>\n\n <bean id=\"testBean1\" class=\"org.springframework.jmx.JmxTestBean\">\n <property name=\"name\" value=\"TEST\"/>\n <property name=\"age\" value=\"100\"/>\n </bean>\n\n <bean id=\"testBean2\" class=\"org.springframework.jmx.JmxTestBean\">\n <property name=\"name\" value=\"ANOTHER TEST\"/>\n <property name=\"age\" value=\"200\"/>\n </bean>\n\n\t</beans>\n----\n\n(For a full discussion of what a handback object is and,\nindeed, what a `NotificationFilter` is, see the section of the JMX\nspecification (1.2) entitled 'The JMX Notification Model'.)\n\n[[jmx-notifications-publishing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/notifications.adoc", "title": "notifications", "heading": "Registering Listeners for Notifications", "heading_level": 2, "file_order": 165, "section_index": 1, "content_hash": "a68864ca1bfaa8928068181f02039a4d375bd11316815845a8e06cc43d38732b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/notifications.adoc"}}
{"id": "sha256:5c815b1223443610f0275e22ce3adb376e2e148b981f7cca40c5381332cb7557", "content": "Spring provides support not only for registering to receive `Notifications` but also\nfor publishing `Notifications`.\n\nNOTE: This section is really only relevant to Spring-managed beans that have\nbeen exposed as MBeans through an `MBeanExporter`. Any existing user-defined MBeans should\nuse the standard JMX APIs for notification publication.\n\nThe key interface in Spring's JMX notification publication support is the\n`NotificationPublisher` interface (defined in the\n`org.springframework.jmx.export.notification` package). Any bean that is going to be\nexported as an MBean through an `MBeanExporter` instance can implement the related\n`NotificationPublisherAware` interface to gain access to a `NotificationPublisher`\ninstance. The `NotificationPublisherAware` interface supplies an instance of a\n`NotificationPublisher` to the implementing bean through a simple setter method,\nwhich the bean can then use to publish `Notifications`.\n\nAs stated in the javadoc of the\n{spring-framework-api}/jmx/export/notification/NotificationPublisher.html[`NotificationPublisher`]\ninterface, managed beans that publish events through the `NotificationPublisher`\nmechanism are not responsible for the state management of notification listeners.\nSpring's JMX support takes care of handling all the JMX infrastructure issues.\nAll you need to do, as an application developer, is implement the\n`NotificationPublisherAware` interface and start publishing events by using the\nsupplied `NotificationPublisher` instance. Note that the `NotificationPublisher`\nis set after the managed bean has been registered with an `MBeanServer`.\n\nUsing a `NotificationPublisher` instance is quite straightforward. You create a JMX\n`Notification` instance (or an instance of an appropriate `Notification` subclass),\npopulate the notification with the data pertinent to the event that is to be\npublished, and invoke the `sendNotification(Notification)` on the\n`NotificationPublisher` instance, passing in the `Notification`.\n\nIn the following example, exported instances of the `JmxTestBean` publish a\n`NotificationEvent` every time the `add(int, int)` operation is invoked:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage org.springframework.jmx;\n\n\timport org.springframework.jmx.export.notification.NotificationPublisherAware;\n\timport org.springframework.jmx.export.notification.NotificationPublisher;\n\timport javax.management.Notification;\n\n\tpublic class JmxTestBean implements IJmxTestBean, NotificationPublisherAware {\n\n private String name;\n private int age;\n private boolean isSuperman;\n private NotificationPublisher publisher;\n\n // other getters and setters omitted for clarity\n\n public int add(int x, int y) {\n int answer = x + y;\n this.publisher.sendNotification(new Notification(\"add\", this, 0));\n return answer;\n }\n\n public void dontExposeMe() {\n throw new RuntimeException();\n }\n\n public void setNotificationPublisher(NotificationPublisher notificationPublisher) {\n this.publisher = notificationPublisher;\n }\n\n\t}\n----\n\nThe `NotificationPublisher` interface and the machinery to get it all working is one of\nthe nicer features of Spring's JMX support. It does, however, come with the price tag of\ncoupling your classes to both Spring and JMX. As always, the advice here is to be\npragmatic. If you need the functionality offered by the `NotificationPublisher` and\nyou can accept the coupling to both Spring and JMX, then do so.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/notifications.adoc", "title": "notifications", "heading": "Publishing Notifications", "heading_level": 2, "file_order": 165, "section_index": 2, "content_hash": "5c815b1223443610f0275e22ce3adb376e2e148b981f7cca40c5381332cb7557", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/notifications.adoc"}}
{"id": "sha256:61655ec0923749012d95be5195c6020053646ee6645bd3b192e8723aee37c051", "content": "[[jmx-proxy]]\n\nSpring JMX lets you create proxies that re-route calls to MBeans that are registered in a\nlocal or remote `MBeanServer`. These proxies provide you with a standard Java interface,\nthrough which you can interact with your MBeans. The following code shows how to configure a\nproxy for an MBean running in a local `MBeanServer`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"proxy\" class=\"org.springframework.jmx.access.MBeanProxyFactoryBean\">\n <property name=\"objectName\" value=\"bean:name=testBean\"/>\n <property name=\"proxyInterface\" value=\"org.springframework.jmx.IJmxTestBean\"/>\n\t</bean>\n----\n\nIn the preceding example, you can see that a proxy is created for the MBean registered under the\n`ObjectName` of `bean:name=testBean`. The set of interfaces that the proxy implements\nis controlled by the `proxyInterfaces` property, and the rules for mapping methods and\nproperties on these interfaces to operations and attributes on the MBean are the same\nrules used by the `InterfaceBasedMBeanInfoAssembler`.\n\nThe `MBeanProxyFactoryBean` can create a proxy to any MBean that is accessible through an\n`MBeanServerConnection`. By default, the local `MBeanServer` is located and used, but\nyou can override this and provide an `MBeanServerConnection` that points to a remote\n`MBeanServer` to cater for proxies that point to remote MBeans:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"clientConnector\"\n class=\"org.springframework.jmx.support.MBeanServerConnectionFactoryBean\">\n <property name=\"serviceUrl\" value=\"service:jmx:rmi://remotehost:9875\"/>\n\t</bean>\n\n\t<bean id=\"proxy\" class=\"org.springframework.jmx.access.MBeanProxyFactoryBean\">\n <property name=\"objectName\" value=\"bean:name=testBean\"/>\n <property name=\"proxyInterface\" value=\"org.springframework.jmx.IJmxTestBean\"/>\n <property name=\"server\" ref=\"clientConnector\"/>\n\t</bean>\n----\n\nIn the preceding example, we create an `MBeanServerConnection` that points to a remote machine\nthat uses the `MBeanServerConnectionFactoryBean`. This `MBeanServerConnection` is then\npassed to the `MBeanProxyFactoryBean` through the `server` property. The proxy that is\ncreated forwards all invocations to the `MBeanServer` through this\n`MBeanServerConnection`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/proxy.adoc", "title": "proxy", "heading": "proxy", "heading_level": 1, "file_order": 166, "section_index": 0, "content_hash": "61655ec0923749012d95be5195c6020053646ee6645bd3b192e8723aee37c051", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/proxy.adoc"}}
{"id": "sha256:4ef0af74416c7efa8b79ad8eb50bcf97e6db57ab76300801518043b482fb5350", "content": "[[jmx-resources]]\n\nThis section contains links to further resources about JMX:\n\n* The https://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html[JMX\nhomepage] at Oracle.\n* The {JSR}003[JMX specification] (JSR-000003).\n* The {JSR}160[JMX Remote API specification] (JSR-000160).\n* The http://mx4j.sourceforge.net/[MX4J homepage]. (MX4J is an open-source implementation of\n various JMX specs.)", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx/resources.adoc", "title": "resources", "heading": "resources", "heading_level": 1, "file_order": 167, "section_index": 0, "content_hash": "4ef0af74416c7efa8b79ad8eb50bcf97e6db57ab76300801518043b482fb5350", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx/resources.adoc"}}
{"id": "sha256:4a3c74f1623472a291a44fe70e89c89b20129fd25598d736136fe0bf7d27789c", "content": "[[aot-cache]]\n\nThe ahead-of-time cache is a JVM feature introduced in Java 24 via\nhttps://openjdk.org/jeps/483[JEP 483] that can help reduce the startup time and memory\nfootprint of Java applications. AOT cache is a natural evolution of\nhttps://docs.oracle.com/en/java/javase/17/vm/class-data-sharing.html[Class Data Sharing (CDS)].\nSpring Framework supports both CDS and AOT cache, and it is recommended that you use the\nlatter if available in the JVM version you are using (Java 24+).\n\nTo use this feature, an AOT cache should be created for the particular classpath of the\napplication. It is possible to create this cache on the deployed instance, or during a\ntraining run performed for example when packaging the application thanks to a hook-point\nprovided by the Spring Framework to ease such use case. Once the cache is available, users\nshould opt in to use it via a JVM flag.\n\nNOTE: If you are using Spring Boot, it is highly recommended to leverage its\n{spring-boot-docs-ref}/packaging/efficient.html#packaging.efficient.unpacking[executable JAR unpacking support]\nwhich is designed to fulfill the class loading requirements of both the AOT cache and CDS.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/aot-cache.adoc", "title": "aot-cache", "heading": "aot-cache", "heading_level": 1, "file_order": 168, "section_index": 0, "content_hash": "4a3c74f1623472a291a44fe70e89c89b20129fd25598d736136fe0bf7d27789c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/aot-cache.adoc"}}
{"id": "sha256:1358f844c4e15e025711599b245693b5a29d0aaf5ed75e6416ca1d9f9c5d13e6", "content": "An AOT cache can typically be created when the application exits. The Spring Framework\nprovides a mode of operation where the process can exit automatically once the\n`ApplicationContext` has refreshed. In this mode, all non-lazy initialized singletons\nhave been instantiated, and `InitializingBean#afterPropertiesSet` callbacks have been\ninvoked; but the lifecycle has not started, and the `ContextRefreshedEvent` has not yet\nbeen published.\n\nTo create the cache during the training run, it is possible to specify the `-Dspring.context.exit=onRefresh`\nJVM flag to start and then exit your Spring application once the\n`ApplicationContext` has refreshed:\n\n--\n[tabs]\n======\n\nAOT cache (Java 25+)::\n+\n[source,bash,subs=\"verbatim,quotes\"]\n----\njava -XX:AOTCacheOutput=app.aot -Dspring.context.exit=onRefresh -jar application.jar ...\n----\n\nAOT cache (Java 24)::\n+\n[source,bash,subs=\"verbatim,quotes\"]\n----\n# Both commands need to be run with the same classpath\njava -XX:AOTMode=record -XX:AOTConfiguration=app.aotconf -Dspring.context.exit=onRefresh ...\njava -XX:AOTMode=create -XX:AOTConfiguration=app.aotconf -XX:AOTCache=app.aot ...\n----\n\nCDS::\n+\n[source,bash,subs=\"verbatim,quotes\"]\n----\n# To create a CDS archive, your JDK/JRE must have a base image\njava -XX:ArchiveClassesAtExit=app.jsa -Dspring.context.exit=onRefresh ...\n----\n======\n--\n\nNOTE: With Java 25+, AOT cache stores, among other things, the\nhttps://openjdk.org/jeps/515[method profiling information]. Therefore, to benefit of this capability,\nit is recommended to create an AOT cache for an application that experienced a portion of a\nproduction-like workflow instead of using the `-Dspring.context.exit=onRefresh` flag which designed to\noptimize only the startup of your application.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/aot-cache.adoc", "title": "aot-cache", "heading": "Creating the cache", "heading_level": 2, "file_order": 168, "section_index": 1, "content_hash": "1358f844c4e15e025711599b245693b5a29d0aaf5ed75e6416ca1d9f9c5d13e6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/aot-cache.adoc"}}
{"id": "sha256:0e412cce02dfacd169a1ba95e57b8b3cfa4b70deb865b720f6d3078b150b33b3", "content": "Once the cache file has been created, you can use it to start your application faster:\n\n--\n[tabs]\n======\nAOT cache::\n+\n[source,bash,subs=\"verbatim\"]\n----\n# With the same classpath (or a superset) tan the training run\njava -XX:AOTCache=app.aot ...\n----\n\nCDS::\n+\n[source,bash,subs=\"verbatim\"]\n----\n# With the same classpath (or a superset) tan the training run\njava -XX:SharedArchiveFile=app.jsa ...\n----\n======\n--\n\nPay attention to the logs and the startup time to check if the AOT cache is used successfully.\nTo figure out how effective the cache is, you can enable class loading logs by adding\nan extra attribute: `-Xlog:class+load:file=aot-cache.log`. This creates an `aot-cache.log` with\nevery attempt to load a class and its source. Classes that are loaded from the cache should have\na \"shared objects file\" source, as shown in the following example:\n\n[source,shell,subs=\"verbatim\"]\n----\n[0.151s][info][class,load] org.springframework.core.env.EnvironmentCapable source: shared objects file\n[0.151s][info][class,load] org.springframework.beans.factory.BeanFactory source: shared objects file\n[0.151s][info][class,load] org.springframework.beans.factory.ListableBeanFactory source: shared objects file\n[0.151s][info][class,load] org.springframework.beans.factory.HierarchicalBeanFactory source: shared objects file\n[0.151s][info][class,load] org.springframework.context.MessageSource source: shared objects file\n----\n\nIf the AOT cache cannot be enabled or if you have a large number of classes that are not loaded from\nthe cache, make sure that the following conditions are fulfilled when creating and using the cache:\n\n - The very same JVM must be used.\n - The classpath must be specified as a JAR or a list of JARs, and avoid the usage of directories and `*` wildcard characters.\n - The timestamps of the JARs must be preserved.\n - When using the cache, the classpath must be the same as the one used to create it, in the same order.\nAdditional JARs or directories can be specified *at the end* (but will not be cached).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/aot-cache.adoc", "title": "aot-cache", "heading": "Using the cache", "heading_level": 2, "file_order": 168, "section_index": 2, "content_hash": "0e412cce02dfacd169a1ba95e57b8b3cfa4b70deb865b720f6d3078b150b33b3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/aot-cache.adoc"}}
{"id": "sha256:07bc3b90e27c5436a5d09a6c19d6fc89e4782dca36cbb52c5fee293d5f02ec81", "content": "[[appendix]]\n\n[[appendix.xsd-schemas]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "appendix", "heading_level": 1, "file_order": 169, "section_index": 0, "content_hash": "07bc3b90e27c5436a5d09a6c19d6fc89e4782dca36cbb52c5fee293d5f02ec81", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:9291d2a70a3795c7df6f73ddcb5513d7d1749c73f5cab6006b79197ea04d3f1f", "content": "This part of the appendix lists XML schemas related to integration technologies.\n\n[[appendix.xsd-schemas-jee]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "XML Schemas", "heading_level": 2, "file_order": 169, "section_index": 1, "content_hash": "9291d2a70a3795c7df6f73ddcb5513d7d1749c73f5cab6006b79197ea04d3f1f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:9ef2a5d1faad39e535be2d682d55d4823fce70c5344d8acf6e4d2414a8d45b1b", "content": "The `jee` elements deal with issues related to Jakarta EE (Enterprise Edition) configuration,\nsuch as looking up a JNDI object and defining EJB references.\n\nTo use the elements in the `jee` schema, you need to have the following preamble at the top\nof your Spring XML configuration file. The text in the following snippet references the\ncorrect schema so that the elements in the `jee` namespace are available to you:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:jee=\"http://www.springframework.org/schema/jee\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/jee\n https://www.springframework.org/schema/jee/spring-jee.xsd\">\n\n <!-- bean definitions here -->\n\n\t</beans>\n----\n\n[[appendix.xsd-schemas-jee-jndi-lookup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "The `jee` Schema", "heading_level": 3, "file_order": 169, "section_index": 2, "content_hash": "9ef2a5d1faad39e535be2d682d55d4823fce70c5344d8acf6e4d2414a8d45b1b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:1777870377cbbd4283cffe02aefb1826fce98642dd3e5890fe89d9be991791a1", "content": "The following example shows how to use JNDI to look up a data source without the `jee` schema:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"dataSource\" class=\"org.springframework.jndi.JndiObjectFactoryBean\">\n <property name=\"jndiName\" value=\"jdbc/MyDataSource\"/>\n\t</bean>\n\t<bean id=\"userDao\" class=\"com.foo.JdbcUserDao\">\n <!-- Spring will do the cast automatically (as usual) -->\n <property name=\"dataSource\" ref=\"dataSource\"/>\n\t</bean>\n----\n\nThe following example shows how to use JNDI to look up a data source with the `jee`\nschema:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jee:jndi-lookup id=\"dataSource\" jndi-name=\"jdbc/MyDataSource\"/>\n\n\t<bean id=\"userDao\" class=\"com.foo.JdbcUserDao\">\n <!-- Spring will do the cast automatically (as usual) -->\n <property name=\"dataSource\" ref=\"dataSource\"/>\n\t</bean>\n----\n\n[[appendix.xsd-schemas-jee-jndi-lookup-environment-single]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "<jee:jndi-lookup/> (simple)", "heading_level": 4, "file_order": 169, "section_index": 3, "content_hash": "1777870377cbbd4283cffe02aefb1826fce98642dd3e5890fe89d9be991791a1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:49f52d61ed740005c0ca66e8ead271c50ce1f61b8dd37d00f089d98e54e99b41", "content": "The following example shows how to use JNDI to look up an environment variable without\n`jee`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"simple\" class=\"org.springframework.jndi.JndiObjectFactoryBean\">\n <property name=\"jndiName\" value=\"jdbc/MyDataSource\"/>\n <property name=\"jndiEnvironment\">\n <props>\n <prop key=\"ping\">pong</prop>\n </props>\n </property>\n\t</bean>\n----\n\nThe following example shows how to use JNDI to look up an environment variable with `jee`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jee:jndi-lookup id=\"simple\" jndi-name=\"jdbc/MyDataSource\">\n <jee:environment>ping=pong</jee:environment>\n\t</jee:jndi-lookup>\n----\n\n[[appendix.xsd-schemas-jee-jndi-lookup-environment-multiple]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "`<jee:jndi-lookup/>` (with Single JNDI Environment Setting)", "heading_level": 4, "file_order": 169, "section_index": 4, "content_hash": "49f52d61ed740005c0ca66e8ead271c50ce1f61b8dd37d00f089d98e54e99b41", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:3c1aca6ae052385bc0d83ab57df83fd48ea38d9899f018a637a4f1240ff722d6", "content": "The following example shows how to use JNDI to look up multiple environment variables\nwithout `jee`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"simple\" class=\"org.springframework.jndi.JndiObjectFactoryBean\">\n <property name=\"jndiName\" value=\"jdbc/MyDataSource\"/>\n <property name=\"jndiEnvironment\">\n <props>\n <prop key=\"sing\">song</prop>\n <prop key=\"ping\">pong</prop>\n </props>\n </property>\n\t</bean>\n----\n\nThe following example shows how to use JNDI to look up multiple environment variables with\n`jee`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jee:jndi-lookup id=\"simple\" jndi-name=\"jdbc/MyDataSource\">\n <!-- newline-separated, key-value pairs for the environment (standard Properties format) -->\n <jee:environment>\n sing=song\n ping=pong\n </jee:environment>\n\t</jee:jndi-lookup>\n----\n\n[[appendix.xsd-schemas-jee-jndi-lookup-complex]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "`<jee:jndi-lookup/>` (with Multiple JNDI Environment Settings)", "heading_level": 4, "file_order": 169, "section_index": 5, "content_hash": "3c1aca6ae052385bc0d83ab57df83fd48ea38d9899f018a637a4f1240ff722d6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:9e803dbbbec1a9db5031100ab34bad4c0c3bbac7796359c71c01ab1b110a5057", "content": "The following example shows how to use JNDI to look up a data source and a number of\ndifferent properties without `jee`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"simple\" class=\"org.springframework.jndi.JndiObjectFactoryBean\">\n <property name=\"jndiName\" value=\"jdbc/MyDataSource\"/>\n <property name=\"cache\" value=\"true\"/>\n <property name=\"resourceRef\" value=\"true\"/>\n <property name=\"lookupOnStartup\" value=\"false\"/>\n <property name=\"expectedType\" value=\"com.myapp.DefaultThing\"/>\n <property name=\"proxyInterface\" value=\"com.myapp.Thing\"/>\n\t</bean>\n----\n\nThe following example shows how to use JNDI to look up a data source and a number of\ndifferent properties with `jee`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jee:jndi-lookup id=\"simple\"\n jndi-name=\"jdbc/MyDataSource\"\n cache=\"true\"\n resource-ref=\"true\"\n lookup-on-startup=\"false\"\n expected-type=\"com.myapp.DefaultThing\"\n proxy-interface=\"com.myapp.Thing\"/>\n----\n\n[[appendix.xsd-schemas-jee-local-slsb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "`<jee:jndi-lookup/>` (Complex)", "heading_level": 4, "file_order": 169, "section_index": 6, "content_hash": "9e803dbbbec1a9db5031100ab34bad4c0c3bbac7796359c71c01ab1b110a5057", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:f0e7e73ca39020017552cbd0e4c15b8e7d72a203b055a9aea8e9fc249847cac5", "content": "The `<jee:local-slsb/>` element configures a reference to a local EJB Stateless Session Bean.\n\nThe following example shows how to configure a reference to a local EJB Stateless Session Bean\nwithout `jee`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"simple\"\n class=\"org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean\">\n <property name=\"jndiName\" value=\"ejb/RentalServiceBean\"/>\n <property name=\"businessInterface\" value=\"com.foo.service.RentalService\"/>\n\t</bean>\n----\n\nThe following example shows how to configure a reference to a local EJB Stateless Session Bean\nwith `jee`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jee:local-slsb id=\"simpleSlsb\" jndi-name=\"ejb/RentalServiceBean\"\n business-interface=\"com.foo.service.RentalService\"/>\n----\n\n[[appendix.xsd-schemas-jee-local-slsb-complex]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "`<jee:local-slsb/>` (Simple)", "heading_level": 4, "file_order": 169, "section_index": 7, "content_hash": "f0e7e73ca39020017552cbd0e4c15b8e7d72a203b055a9aea8e9fc249847cac5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:b362a6162cf700cf932cf853428d12ab8cbcb907a5a3add52cfaca2571da1e45", "content": "The `<jee:local-slsb/>` element configures a reference to a local EJB Stateless Session Bean.\n\nThe following example shows how to configure a reference to a local EJB Stateless Session Bean\nand a number of properties without `jee`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"complexLocalEjb\"\n class=\"org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean\">\n <property name=\"jndiName\" value=\"ejb/RentalServiceBean\"/>\n <property name=\"businessInterface\" value=\"com.example.service.RentalService\"/>\n <property name=\"cacheHome\" value=\"true\"/>\n <property name=\"lookupHomeOnStartup\" value=\"true\"/>\n <property name=\"resourceRef\" value=\"true\"/>\n\t</bean>\n----\n\nThe following example shows how to configure a reference to a local EJB Stateless Session Bean\nand a number of properties with `jee`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jee:local-slsb id=\"complexLocalEjb\"\n jndi-name=\"ejb/RentalServiceBean\"\n business-interface=\"com.foo.service.RentalService\"\n cache-home=\"true\"\n lookup-home-on-startup=\"true\"\n resource-ref=\"true\">\n----\n\n[[appendix.xsd-schemas-jee-remote-slsb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "`<jee:local-slsb/>` (Complex)", "heading_level": 4, "file_order": 169, "section_index": 8, "content_hash": "b362a6162cf700cf932cf853428d12ab8cbcb907a5a3add52cfaca2571da1e45", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:b0c7e4ce036231578da7444e14db1a8a240c3593ed7de5d3a29ea3c8a751eefa", "content": "The `<jee:remote-slsb/>` element configures a reference to a `remote` EJB Stateless Session Bean.\n\nThe following example shows how to configure a reference to a remote EJB Stateless Session Bean\nwithout `jee`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"complexRemoteEjb\"\n class=\"org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBean\">\n <property name=\"jndiName\" value=\"ejb/MyRemoteBean\"/>\n <property name=\"businessInterface\" value=\"com.foo.service.RentalService\"/>\n <property name=\"cacheHome\" value=\"true\"/>\n <property name=\"lookupHomeOnStartup\" value=\"true\"/>\n <property name=\"resourceRef\" value=\"true\"/>\n <property name=\"homeInterface\" value=\"com.foo.service.RentalService\"/>\n <property name=\"refreshHomeOnConnectFailure\" value=\"true\"/>\n\t</bean>\n----\n\nThe following example shows how to configure a reference to a remote EJB Stateless Session Bean\nwith `jee`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<jee:remote-slsb id=\"complexRemoteEjb\"\n jndi-name=\"ejb/MyRemoteBean\"\n business-interface=\"com.foo.service.RentalService\"\n cache-home=\"true\"\n lookup-home-on-startup=\"true\"\n resource-ref=\"true\"\n home-interface=\"com.foo.service.RentalService\"\n refresh-home-on-connect-failure=\"true\">\n----\n\n[[appendix.xsd-schemas-jms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "<jee:remote-slsb/>", "heading_level": 4, "file_order": 169, "section_index": 9, "content_hash": "b0c7e4ce036231578da7444e14db1a8a240c3593ed7de5d3a29ea3c8a751eefa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:095a4b9dbb925f5f88e78af81c806606c898d9cd81c0716b8dd086486ab5dfbf", "content": "The `jms` elements deal with configuring JMS-related beans, such as Spring's\nxref:integration/jms/using.adoc#jms-mdp[Message Listener Containers]. These elements are detailed in the\nsection of the xref:integration/jms.adoc[JMS chapter] entitled xref:integration/jms/namespace.adoc[JMS Namespace Support]\n. See that chapter for full details on this support\nand the `jms` elements themselves.\n\nIn the interest of completeness, to use the elements in the `jms` schema, you need to have\nthe following preamble at the top of your Spring XML configuration file. The text in the\nfollowing snippet references the correct schema so that the elements in the `jms` namespace\nare available to you:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:jms=\"http://www.springframework.org/schema/jms\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/jms\n https://www.springframework.org/schema/jms/spring-jms.xsd\">\n\n <!-- bean definitions here -->\n\n\t</beans>\n----\n\n[[appendix.xsd-schemas-context-mbe]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "The `jms` Schema", "heading_level": 3, "file_order": 169, "section_index": 10, "content_hash": "095a4b9dbb925f5f88e78af81c806606c898d9cd81c0716b8dd086486ab5dfbf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:c1fbcd871e716cb104186e774d9559fc30a97ea863bfdab4205926ff176cd61c", "content": "This element is detailed in\nxref:integration/jmx/naming.adoc#jmx-context-mbeanexport[Configuring Annotation-based MBean Export].\n\n[[appendix.xsd-schemas-cache]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "Using `<context:mbean-export/>`", "heading_level": 3, "file_order": 169, "section_index": 11, "content_hash": "c1fbcd871e716cb104186e774d9559fc30a97ea863bfdab4205926ff176cd61c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:cd1edf47db83461592fb2ff933922800f508275c00e401c5f28b9bad0527cedd", "content": "You can use the `cache` elements to enable support for Spring's `@CacheEvict`, `@CachePut`,\nand `@Caching` annotations. The `cache` schema also supports declarative XML-based caching. See\nxref:integration/cache/annotations.adoc#cache-annotation-enable[Enabling Caching Annotations] and\nxref:integration/cache/declarative-xml.adoc[Declarative XML-based Caching] for details.\n\nTo use the elements in the `cache` schema, you need to have the following preamble at the\ntop of your Spring XML configuration file. The text in the following snippet references\nthe correct schema so that the elements in the `cache` namespace are available to you:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:cache=\"http://www.springframework.org/schema/cache\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/cache\n https://www.springframework.org/schema/cache/spring-cache.xsd\">\n\n <!-- bean definitions here -->\n\n\t</beans>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/appendix.adoc", "title": "appendix", "heading": "The `cache` Schema", "heading_level": 3, "file_order": 169, "section_index": 12, "content_hash": "cd1edf47db83461592fb2ff933922800f508275c00e401c5f28b9bad0527cedd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/appendix.adoc"}}
{"id": "sha256:125ea526f474a7c2bec53019b234363d03379e5252d700907c45f213706b8b05", "content": "[[cache]]\n\nSince version 3.1, the Spring Framework provides support for transparently adding caching to\nan existing Spring application. Similar to the xref:data-access/transaction.adoc[transaction]\nsupport, the caching abstraction allows consistent use of various caching solutions with\nminimal impact on the code.\n\nIn Spring Framework 4.1, the cache abstraction was significantly extended with support\nfor xref:integration/cache/jsr-107.adoc[JSR-107 annotations] and more customization options.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/cache.adoc", "title": "cache", "heading": "cache", "heading_level": 1, "file_order": 170, "section_index": 0, "content_hash": "125ea526f474a7c2bec53019b234363d03379e5252d700907c45f213706b8b05", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/cache.adoc"}}
{"id": "sha256:ccc0feab6a19e79f1e01316ddfa1f156334fd41dbf55b7ecf2f7cc027e822217", "content": "[[checkpoint-restore]]\n\nThe Spring Framework integrates with checkpoint/restore as implemented by https://github.com/CRaC/docs[Project CRaC] in order to allow implementing systems capable of reducing the startup and warmup times of Spring-based Java applications with the JVM.\n\nUsing this feature requires:\n\n* A checkpoint/restore enabled JVM (Linux only for now).\n* The presence of the https://github.com/CRaC/org.crac[`org.crac:crac`] library (version `1.4.0` and above are supported) in the classpath.\n* Specifying the required `java` command-line parameters like `-XX:CRaCCheckpointTo=PATH` or `-XX:CRaCRestoreFrom=PATH`.\n\nWARNING: The files generated in the path specified by `-XX:CRaCCheckpointTo=PATH` when a checkpoint is requested contain a representation of the memory of the running JVM, which may contain secrets and other sensitive data. Using this feature should be done with the assumption that any value \"seen\" by the JVM, such as configuration properties coming from the environment, will be stored in those CRaC files. As a consequence, the security implications of where and how those files are generated, stored, and accessed should be carefully assessed.\n\nConceptually, checkpoint and restore align with the xref:core/beans/factory-nature.adoc#beans-factory-lifecycle-processor[Spring `Lifecycle` contract] for individual beans.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/checkpoint-restore.adoc", "title": "checkpoint-restore", "heading": "checkpoint-restore", "heading_level": 1, "file_order": 171, "section_index": 0, "content_hash": "ccc0feab6a19e79f1e01316ddfa1f156334fd41dbf55b7ecf2f7cc027e822217", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/checkpoint-restore.adoc"}}
{"id": "sha256:40dfefe6e02981ae4d565adcc29566225995770c10e9d9eeb9eb774d9a20749d", "content": "A checkpoint can be created on demand, for example using a command like `jcmd application.jar JDK.checkpoint`. Before the creation of the checkpoint, Spring stops all the running beans, giving them a chance to close resources if needed by implementing `Lifecycle.stop`. After restore, the same beans are restarted, with `Lifecycle.start` allowing beans to reopen resources when relevant. For libraries that do not depend on Spring, custom checkpoint/restore integration can be provided by implementing `org.crac.Resource` and registering the related instance.\n\nWARNING: Leveraging checkpoint/restore of a running application typically requires additional lifecycle management to gracefully stop and start using resources like files or sockets and stop active threads.\n\nWARNING: Be aware that when defining scheduling tasks at a fixed rate, for example with an annotation like `@Scheduled(fixedRate = 5000)`, all missed executions between checkpoint and restore will be performed when the JVM is restored with on-demand checkpoint/restore. If this is not the behavior you want, it is recommended to schedule tasks at a fixed delay (for example with `@Scheduled(fixedDelay = 5000)`) or with a cron expression as those are calculated after every task execution.\n\nNOTE: If the checkpoint is created on a warmed-up JVM, the restored JVM will be equally warmed-up, allowing potentially peak performance immediately. This method typically requires access to remote services, and thus requires some level of platform integration.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/checkpoint-restore.adoc", "title": "checkpoint-restore", "heading": "On-demand checkpoint/restore of a running application", "heading_level": 2, "file_order": 171, "section_index": 1, "content_hash": "40dfefe6e02981ae4d565adcc29566225995770c10e9d9eeb9eb774d9a20749d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/checkpoint-restore.adoc"}}
{"id": "sha256:a182d4aca7ded6f56f4605040be4241ab8583ab68ad701d78e45f591bc84acc8", "content": "When the `-Dspring.context.checkpoint=onRefresh` JVM system property is set, a checkpoint is created automatically at\nstartup during the `LifecycleProcessor.onRefresh` phase. After this phase has completed, all non-lazy initialized singletons have been instantiated, and\n`InitializingBean#afterPropertiesSet` callbacks have been invoked; but the lifecycle has not started, and the\n`ContextRefreshedEvent` has not yet been published.\n\nFor testing purposes, it is also possible to leverage the `-Dspring.context.exit=onRefresh` JVM system property which\ntriggers similar behavior, but instead of creating a checkpoint, it exits your Spring application at the same lifecycle\nphase without requiring the Project CraC dependency/JVM or Linux. This can be useful to check if connections to remote\nservices are required when the beans are not started, and potentially refine the configuration to avoid that.\n\nWARNING: As mentioned above, and especially in use cases where the CRaC files are shipped as part of a deployable artifact (a container image for example), operate with the assumption that any sensitive data \"seen\" by the JVM ends up in the CRaC files, and assess carefully the related security implications.\n\nNOTE: Automatic checkpoint/restore is a way to \"fast-forward\" the startup of the application to a phase where the application context is about to start, but it does not allow to have a fully warmed-up JVM.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/checkpoint-restore.adoc", "title": "checkpoint-restore", "heading": "Automatic checkpoint/restore at startup", "heading_level": 2, "file_order": 171, "section_index": 2, "content_hash": "a182d4aca7ded6f56f4605040be4241ab8583ab68ad701d78e45f591bc84acc8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/checkpoint-restore.adoc"}}
{"id": "sha256:4e5f81a278d28836dd99571c2221c85cb3324aa2081b9f595f15400aff155c7d", "content": "[[mail]]\n\nThis section describes how to send email with the Spring Framework.\n\n.Library dependencies\n****\nThe following JAR needs to be on the classpath of your application in order to use the\nSpring Framework's email support:\n\n* The https://jakartaee.github.io/mail-api/[Jakarta Mail] library\n\nThis library is freely available on the web -- for example, in Maven Central as\n`org.eclipse.angus:angus-mail`.\n****\n\nThe Spring Framework provides a helpful utility library for sending email that shields\nyou from the specifics of the underlying mailing system and is responsible for\nlow-level resource handling on behalf of the client.\n\nThe `org.springframework.mail` package is the root level package for the Spring\nFramework's email support. The central interface for sending emails is the `MailSender`\ninterface. A simple value object that encapsulates the properties of a simple mail such\nas `from` and `to` (plus many others) is the `SimpleMailMessage` class. This package\nalso contains a hierarchy of checked exceptions that provide a higher level of\nabstraction over the lower level mail system exceptions, with the root exception being\n`MailException`. See the {spring-framework-api}/mail/MailException.html[javadoc]\nfor more information on the rich mail exception hierarchy.\n\nThe `org.springframework.mail.javamail.JavaMailSender` interface adds specialized\nJavaMail features, such as MIME message support to the `MailSender` interface\n(from which it inherits). `JavaMailSender` also provides a callback interface called\n`org.springframework.mail.javamail.MimeMessagePreparator` for preparing a `MimeMessage`.\n\n[[mail-usage]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/email.adoc", "title": "email", "heading": "email", "heading_level": 1, "file_order": 172, "section_index": 0, "content_hash": "4e5f81a278d28836dd99571c2221c85cb3324aa2081b9f595f15400aff155c7d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/email.adoc"}}
{"id": "sha256:f7e535ae18c9fc01120de7c75143b4ceef89533783fb6f33c597dd013967c19f", "content": "Assume that we have a business interface called `OrderManager`, as the following example shows:\n\ninclude-code::./OrderManager[tag=snippet,indent=0]\n\nFurther assume that we have a requirement stating that an email message with an\norder number needs to be generated and sent to a customer who placed the relevant order.\n\n[[mail-usage-simple]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/email.adoc", "title": "email", "heading": "Usage", "heading_level": 2, "file_order": 172, "section_index": 1, "content_hash": "f7e535ae18c9fc01120de7c75143b4ceef89533783fb6f33c597dd013967c19f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/email.adoc"}}
{"id": "sha256:5438790e5498ca874acf4c10b5922b1fde2730a4d55b29056292dd33357f9975", "content": "The following example shows how to use `MailSender` and `SimpleMailMessage` to send an\nemail when someone places an order:\n\ninclude-code::./SimpleOrderManager[tag=snippet,indent=0]\n\nThe following example shows the bean definitions for the preceding code:\n\ninclude-code::./MailConfiguration[tag=snippet,indent=0]\n\n[[mail-usage-mime]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/email.adoc", "title": "email", "heading": "Basic `MailSender` and `SimpleMailMessage` Usage", "heading_level": 3, "file_order": 172, "section_index": 2, "content_hash": "5438790e5498ca874acf4c10b5922b1fde2730a4d55b29056292dd33357f9975", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/email.adoc"}}
{"id": "sha256:5f2dc6d12a47fabf39d7f57cf05be22a702e4a5fe2845ec113215a011223f43c", "content": "This section describes another implementation of `OrderManager` that uses the `MimeMessagePreparator`\ncallback interface. In the following example, the `mailSender` property is of type\n`JavaMailSender` so that we are able to use the JavaMail `MimeMessage` class:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport jakarta.mail.Message;\n\timport jakarta.mail.MessagingException;\n\timport jakarta.mail.internet.InternetAddress;\n\timport jakarta.mail.internet.MimeMessage;\n\n\timport jakarta.mail.internet.MimeMessage;\n\timport org.springframework.mail.MailException;\n\timport org.springframework.mail.javamail.JavaMailSender;\n\timport org.springframework.mail.javamail.MimeMessagePreparator;\n\n\tpublic class SimpleOrderManager implements OrderManager {\n\n private JavaMailSender mailSender;\n\n public void setMailSender(JavaMailSender mailSender) {\n this.mailSender = mailSender;\n }\n\n public void placeOrder(final Order order) {\n // Do the business calculations...\n // Call the collaborators to persist the order...\n\n MimeMessagePreparator preparator = new MimeMessagePreparator() {\n public void prepare(MimeMessage mimeMessage) throws Exception {\n mimeMessage.setRecipient(Message.RecipientType.TO,\n new InternetAddress(order.getCustomer().getEmailAddress()));\n mimeMessage.setFrom(new InternetAddress(\"mail@mycompany.example\"));\n mimeMessage.setText(\"Dear \" + order.getCustomer().getFirstName() + \" \" +\n order.getCustomer().getLastName() + \", thanks for your order. \" +\n \"Your order number is \" + order.getOrderNumber() + \".\");\n }\n };\n\n try {\n this.mailSender.send(preparator);\n }\n catch (MailException ex) {\n // simply log it and go on...\n System.err.println(ex.getMessage());\n }\n }\n\n\t}\n----\n\nNOTE: The mail code is a crosscutting concern and could well be a candidate for\nrefactoring into a xref:core/aop.adoc[custom Spring AOP aspect], which could then\nbe run at appropriate joinpoints on the `OrderManager` target.\n\nThe Spring Framework's mail support ships with the standard JavaMail implementation.\nSee the relevant javadoc for more information.\n\n[[mail-javamail-mime]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/email.adoc", "title": "email", "heading": "Using `JavaMailSender` and `MimeMessagePreparator`", "heading_level": 3, "file_order": 172, "section_index": 3, "content_hash": "5f2dc6d12a47fabf39d7f57cf05be22a702e4a5fe2845ec113215a011223f43c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/email.adoc"}}
{"id": "sha256:64074570c9627f2fd1eba05c71db140aaa1a7ef2298b51bf057a6740b49e38cc", "content": "A class that comes in pretty handy when dealing with JavaMail messages is\n`org.springframework.mail.javamail.MimeMessageHelper`, which shields you from\nhaving to use the verbose JavaMail API. Using the `MimeMessageHelper`, it is\npretty easy to create a `MimeMessage`, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// of course you would use DI in any real-world cases\n\tJavaMailSenderImpl sender = new JavaMailSenderImpl();\n\tsender.setHost(\"mail.host.com\");\n\n\tMimeMessage message = sender.createMimeMessage();\n\tMimeMessageHelper helper = new MimeMessageHelper(message);\n\thelper.setTo(\"test@host.com\");\n\thelper.setText(\"Thank you for ordering!\");\n\n\tsender.send(message);\n----\n\n[[mail-javamail-mime-attachments]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/email.adoc", "title": "email", "heading": "Using the JavaMail `MimeMessageHelper`", "heading_level": 2, "file_order": 172, "section_index": 4, "content_hash": "64074570c9627f2fd1eba05c71db140aaa1a7ef2298b51bf057a6740b49e38cc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/email.adoc"}}
{"id": "sha256:dcf350218fd33ae18bdd401f4a9c3dc498f54b37b9c9afb799e5b005a69ac256", "content": "Multipart email messages allow for both attachments and inline resources. Examples of\ninline resources include an image or a stylesheet that you want to use in your message but\nthat you do not want displayed as an attachment.\n\n[[mail-javamail-mime-attachments-attachment]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/email.adoc", "title": "email", "heading": "Sending Attachments and Inline Resources", "heading_level": 3, "file_order": 172, "section_index": 5, "content_hash": "dcf350218fd33ae18bdd401f4a9c3dc498f54b37b9c9afb799e5b005a69ac256", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/email.adoc"}}
{"id": "sha256:7405ec08a55aa7d3a101da1531b960def154075c4672f8a5c88a21953cb372fb", "content": "The following example shows you how to use the `MimeMessageHelper` to send an email\nwith a single JPEG image attachment:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tJavaMailSenderImpl sender = new JavaMailSenderImpl();\n\tsender.setHost(\"mail.host.com\");\n\n\tMimeMessage message = sender.createMimeMessage();\n\n\t// use the true flag to indicate you need a multipart message\n\tMimeMessageHelper helper = new MimeMessageHelper(message, true);\n\thelper.setTo(\"test@host.com\");\n\n\thelper.setText(\"Check out this image!\");\n\n\t// let's attach the infamous windows Sample file (this time copied to c:/)\n\tFileSystemResource file = new FileSystemResource(new File(\"c:/Sample.jpg\"));\n\thelper.addAttachment(\"CoolImage.jpg\", file);\n\n\tsender.send(message);\n----\n\n[[mail-javamail-mime-attachments-inline]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/email.adoc", "title": "email", "heading": "Attachments", "heading_level": 4, "file_order": 172, "section_index": 6, "content_hash": "7405ec08a55aa7d3a101da1531b960def154075c4672f8a5c88a21953cb372fb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/email.adoc"}}
{"id": "sha256:ba008947fa9881602f029f1da98fcaa458ac906a9b7afa14da75264ec498936c", "content": "The following example shows you how to use the `MimeMessageHelper` to send an email\nwith an inline image:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tJavaMailSenderImpl sender = new JavaMailSenderImpl();\n\tsender.setHost(\"mail.host.com\");\n\n\tMimeMessage message = sender.createMimeMessage();\n\n\t// use the true flag to indicate you need a multipart message\n\tMimeMessageHelper helper = new MimeMessageHelper(message, true);\n\thelper.setTo(\"test@host.com\");\n\n\t// use the true flag to indicate the text included is HTML\n\thelper.setText(\"<html><body><img src='cid:identifier1234'></body></html>\", true);\n\n\t// let's include the infamous windows Sample file (this time copied to c:/)\n\tFileSystemResource res = new FileSystemResource(new File(\"c:/Sample.jpg\"));\n\thelper.addInline(\"identifier1234\", res);\n\n\tsender.send(message);\n----\n\nWARNING: Inline resources are added to the `MimeMessage` by using the specified `Content-ID`\n(`identifier1234` in the above example). The order in which you add the text\nand the resource are very important. Be sure to first add the text and then\nthe resources. If you are doing it the other way around, it does not work.\n\n[[mail-templates]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/email.adoc", "title": "email", "heading": "Inline Resources", "heading_level": 4, "file_order": 172, "section_index": 7, "content_hash": "ba008947fa9881602f029f1da98fcaa458ac906a9b7afa14da75264ec498936c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/email.adoc"}}
{"id": "sha256:87755ec4ab7a8c78749744d3f6dcac095f0983cc417c55a811c186653c11726a", "content": "The code in the examples shown in the previous sections explicitly created the content of the email message,\nby using methods calls such as `message.setText(..)`. This is fine for simple cases, and it\nis okay in the context of the aforementioned examples, where the intent was to show you\nthe very basics of the API.\n\nIn your typical enterprise application, though, developers often do not create the content\nof email messages by using the previously shown approach for a number of reasons:\n\n* Creating HTML-based email content in Java code is tedious and error prone.\n* There is no clear separation between display logic and business logic.\n* Changing the display structure of the email content requires writing Java code,\n recompiling, redeploying, and so on.\n\nTypically, the approach taken to address these issues is to use a template library (such\nas FreeMarker) to define the display structure of email content. This leaves your code\ntasked only with creating the data that is to be rendered in the email template and\nsending the email. It is definitely a best practice when the content of your email messages\nbecomes even moderately complex, and, with the Spring Framework's support classes for\nFreeMarker, it becomes quite easy to do.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/email.adoc", "title": "email", "heading": "Creating Email Content by Using a Templating Library", "heading_level": 3, "file_order": 172, "section_index": 8, "content_hash": "87755ec4ab7a8c78749744d3f6dcac095f0983cc417c55a811c186653c11726a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/email.adoc"}}
{"id": "sha256:e7281379ad6da81ddd99feb35cc4c132c380bd2cb11d34d4cd2e485e4bf24eb7", "content": "[[jms]]\n\nSpring provides a JMS integration framework that simplifies the use of the JMS API in much\nthe same way as Spring's integration does for the JDBC API.\n\nJMS can be roughly divided into two areas of functionality, namely the production and\nconsumption of messages. The `JmsTemplate` class is used for message production and\nsynchronous message receipt. For asynchronous receipt similar to Jakarta EE's\nmessage-driven bean style, Spring provides a number of message-listener containers that\nyou can use to create Message-Driven POJOs (MDPs). Spring also provides a declarative way\nto create message listeners.\n\nThe `org.springframework.jms.core` package provides the core functionality for using\nJMS. It contains JMS template classes that simplify the use of the JMS by handling the\ncreation and release of resources, much like the `JdbcTemplate` does for JDBC. The\ndesign principle common to Spring template classes is to provide helper methods to\nperform common operations and, for more sophisticated usage, delegate the essence of the\nprocessing task to user-implemented callback interfaces. The JMS template follows the\nsame design. The classes offer various convenience methods for sending messages,\nconsuming messages synchronously, and exposing the JMS session and message producer to\nthe user.\n\nThe `org.springframework.jms.support` package provides `JMSException` translation\nfunctionality. The translation converts the checked `JMSException` hierarchy to a\nmirrored hierarchy of unchecked exceptions. If any provider-specific subclasses\nof the checked `jakarta.jms.JMSException` exist, this exception is wrapped in the\nunchecked `UncategorizedJmsException`.\n\nThe `org.springframework.jms.support.converter` package provides a `MessageConverter`\nabstraction to convert between Java objects and JMS messages.\n\nThe `org.springframework.jms.support.destination` package provides various strategies\nfor managing JMS destinations, such as providing a service locator for destinations\nstored in JNDI.\n\nThe `org.springframework.jms.annotation` package provides the necessary infrastructure\nto support annotation-driven listener endpoints by using `@JmsListener`.\n\nThe `org.springframework.jms.config` package provides the parser implementation for the\n`jms` namespace as well as the java config support to configure listener containers and\ncreate listener endpoints.\n\nFinally, the `org.springframework.jms.connection` package provides an implementation of\nthe `ConnectionFactory` suitable for use in standalone applications. It also contains an\nimplementation of Spring's `PlatformTransactionManager` for JMS (the cunningly named\n`JmsTransactionManager`). This allows for seamless integration of JMS as a transactional\nresource into Spring's transaction management mechanisms.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jms.adoc", "title": "jms", "heading": "jms", "heading_level": 1, "file_order": 173, "section_index": 0, "content_hash": "e7281379ad6da81ddd99feb35cc4c132c380bd2cb11d34d4cd2e485e4bf24eb7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jms.adoc"}}
{"id": "sha256:c963dfd22833f555f56c8eb7cb29428dbb0851fdf19faab6e828caee257edced", "content": "[[jmx]]\n\nThe JMX (Java Management Extensions) support in Spring provides features that let you\neasily and transparently integrate your Spring application into a JMX infrastructure.\n\n.JMX?\n****\nThis chapter is not an introduction to JMX. It does not try to explain why you might want\nto use JMX. If you are new to JMX, see xref:integration/jmx/resources.adoc[Further Resources] at the end of this chapter.\n****\n\nSpecifically, Spring's JMX support provides four core features:\n\n* The automatic registration of any Spring bean as a JMX MBean.\n* A flexible mechanism for controlling the management interface of your beans.\n* The declarative exposure of MBeans over remote, JSR-160 connectors.\n* The simple proxying of both local and remote MBean resources.\n\nThese features are designed to work without coupling your application components to\neither Spring or JMX interfaces and classes. Indeed, for the most part, your application\nclasses need not be aware of either Spring or JMX in order to take advantage of the\nSpring JMX features.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/jmx.adoc", "title": "jmx", "heading": "jmx", "heading_level": 1, "file_order": 174, "section_index": 0, "content_hash": "c963dfd22833f555f56c8eb7cb29428dbb0851fdf19faab6e828caee257edced", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/jmx.adoc"}}
{"id": "sha256:66708206f5297cc265b9eb3431cfa02bfd198574bf032ae376a96b16157186e8", "content": "[[observability]]\n\nMicrometer defines an {micrometer-docs}/observation.html[Observation concept that enables both Metrics and Traces] in applications.\nMetrics support offers a way to create timers, gauges, or counters for collecting statistics about the runtime behavior of your application.\nMetrics can help you to track error rates, usage patterns, performance, and more.\nTraces provide a holistic view of an entire system, crossing application boundaries; you can zoom in on particular user requests and follow their entire completion across applications.\n\nSpring Framework instruments various parts of its own codebase to publish observations if an `ObservationRegistry` is configured.\nYou can learn more about {spring-boot-docs-ref}/actuator/observability.html[configuring the observability infrastructure in Spring Boot].\n\n[[observability.list]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "observability", "heading_level": 1, "file_order": 175, "section_index": 0, "content_hash": "66708206f5297cc265b9eb3431cfa02bfd198574bf032ae376a96b16157186e8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:a796a8ff3d7ceb8306f33f8204fc107cedd6acfcd16034a9f7d67383e5d16836", "content": "Spring Framework instruments various features for observability.\nAs outlined xref:integration/observability.adoc[at the beginning of this section], observations can generate timer Metrics and/or Traces depending on the configuration.\n\n.Observations produced by Spring Framework\n[%autowidth]\n|===\n|Observation name |Description\n\n|xref:integration/observability.adoc#observability.http-client[`\"http.client.requests\"`]\n|Time spent for HTTP client exchanges\n\n|xref:integration/observability.adoc#observability.http-server[`\"http.server.requests\"`]\n|Processing time for HTTP server exchanges at the Framework level\n\n|xref:integration/observability.adoc#observability.jms.publish[`\"jms.message.publish\"`]\n|Time spent sending a JMS message to a destination by a message producer.\n\n|xref:integration/observability.adoc#observability.jms.process[`\"jms.message.process\"`]\n|Processing time for a JMS message that was previously received by a message consumer.\n\n|xref:integration/observability.adoc#observability.tasks-scheduled[`\"tasks.scheduled.execution\"`]\n|Processing time for an execution of a `@Scheduled` task\n|===\n\nNOTE: Observations use Micrometer's official naming convention, but Metrics names will be automatically converted\n{micrometer-docs}/concepts/naming.html[to the format preferred by the monitoring system backend]\n(Prometheus, Atlas, Graphite, InfluxDB...).\n\n[[observability.concepts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "List of produced Observations", "heading_level": 2, "file_order": 175, "section_index": 1, "content_hash": "a796a8ff3d7ceb8306f33f8204fc107cedd6acfcd16034a9f7d67383e5d16836", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:bff9b23e5d5d95d09d242dff32d07b36ff93392f266f6a78b9d321ae675270c2", "content": "If you are not familiar with Micrometer Observation, here's a quick summary of the concepts you should know about.\n\n* `Observation` is the actual recording of something happening in your application. This is processed by `ObservationHandler` implementations to produce metrics or traces.\n* Each observation has a corresponding `ObservationContext` implementation; this type holds all the relevant information for extracting metadata for it.\n In the case of an HTTP server observation, the context implementation could hold the HTTP request, the HTTP response, any exception thrown during processing, and so forth.\n* Each `Observation` holds `KeyValues` metadata. In the case of an HTTP server observation, this could be the HTTP request method, the HTTP response status, and so forth.\n This metadata is contributed by `ObservationConvention` implementations which should declare the type of `ObservationContext` they support.\n* `KeyValues` are said to be \"low cardinality\" if there is a low, bounded number of possible values for the `KeyValue` tuple (HTTP method is a good example).\n Low cardinality values are contributed to metrics only.\n Conversely, \"high cardinality\" values are unbounded (for example, HTTP request URIs) and are only contributed to traces.\n* An `ObservationDocumentation` documents all observations in a particular domain, listing the expected key names and their meaning.\n\n[[observability.config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "Micrometer Observation concepts", "heading_level": 2, "file_order": 175, "section_index": 2, "content_hash": "bff9b23e5d5d95d09d242dff32d07b36ff93392f266f6a78b9d321ae675270c2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:382a3d6e44808c5928fd0221abd558f4e2bdc345f00e7b49869744a33df2f83b", "content": "Global configuration options are available at the `ObservationRegistry#observationConfig()` level.\nEach instrumented component will provide two extension points:\n\n* setting the `ObservationRegistry`; if not set, observations will not be recorded and will be no-ops\n* providing a custom `ObservationConvention` to change the default observation name and extracted `KeyValues`\n\n[[observability.config.conventions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "Configuring Observations", "heading_level": 2, "file_order": 175, "section_index": 3, "content_hash": "382a3d6e44808c5928fd0221abd558f4e2bdc345f00e7b49869744a33df2f83b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:49882e366a3e4224c842377b8ac44605ed29371730f0edf2d957e72ac1a22d87", "content": "Let's take the example of the Spring MVC \"http.server.requests\" metrics instrumentation with the `ServerHttpObservationFilter`.\nThis observation uses a `ServerRequestObservationConvention` with a `ServerRequestObservationContext`; custom conventions can be configured on the Servlet filter.\nIf you would like to customize the metadata produced with the observation, you can extend the `DefaultServerRequestObservationConvention` for your requirements:\n\ninclude-code::./ExtendedServerRequestObservationConvention[]\n\nIf you want full control, you can implement the entire convention contract for the observation you're interested in:\n\ninclude-code::./CustomServerRequestObservationConvention[]\n\nYou can also achieve similar goals using a custom `ObservationFilter` â€“ adding or removing key values for an observation.\nFilters do not replace the default convention and are used as a post-processing component.\n\ninclude-code::./ServerRequestObservationFilter[]\n\nYou can configure `ObservationFilter` instances on the `ObservationRegistry`.\n\n[[observability.tasks-scheduled]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "Using custom Observation conventions", "heading_level": 3, "file_order": 175, "section_index": 4, "content_hash": "49882e366a3e4224c842377b8ac44605ed29371730f0edf2d957e72ac1a22d87", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:da47bf1be7924f660f7640ae0d922a858712e34ae2e383645598dccf215bbe80", "content": "An Observation is created for xref:integration/scheduling.adoc#scheduling-enable-annotation-support[each execution of an `@Scheduled` task].\nApplications need to configure the `ObservationRegistry` on the `ScheduledTaskRegistrar` to enable the recording of observations.\nThis can be done by declaring a `SchedulingConfigurer` bean that sets the observation registry:\n\ninclude-code::./ObservationSchedulingConfigurer[]\n\nIt uses the `org.springframework.scheduling.support.DefaultScheduledTaskObservationConvention` by default, backed by the `ScheduledTaskObservationContext`.\nYou can configure a custom implementation on the `ObservationRegistry` directly.\nDuring the execution of the scheduled method, the current observation is restored in the `ThreadLocal` context or the Reactor context (if the scheduled method returns a `Mono` or `Flux` type).\n\nBy default, the following `KeyValues` are created:\n\n.Low cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`code.function` _(required)_|Name of the Java `Method` that is scheduled for execution.\n|`code.namespace` _(required)_|Canonical name of the class of the bean instance that holds the scheduled method, or `\"ANONYMOUS\"` for anonymous classes.\n|`error` _(required)_|Class name of the exception thrown during the execution, or `\"none\"` if no exception happened.\n|`exception` _(deprecated)_|Duplicates the `error` key and might be removed in the future.\n|`outcome` _(required)_|Outcome of the method execution. Can be `\"SUCCESS\"`, `\"ERROR\"` or `\"UNKNOWN\"` (if for example the operation was cancelled during execution).\n|===\n\n[[observability.jms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "@Scheduled tasks instrumentation", "heading_level": 2, "file_order": 175, "section_index": 5, "content_hash": "da47bf1be7924f660f7640ae0d922a858712e34ae2e383645598dccf215bbe80", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:2fd74cdf9e8228ea7b3bb55499308f3b8bfed7e4ec70689790bc64d67c9a8c17", "content": "Spring Framework uses the Jakarta JMS instrumentation provided by Micrometer if the `io.micrometer:micrometer-jakarta9` dependency is on the classpath.\nThe `io.micrometer.jakarta9.instrument.jms.JmsInstrumentation` instruments `jakarta.jms.Session` and records the relevant observations.\n\nThis instrumentation will create 2 types of observations:\n\n* `\"jms.message.publish\"` when a JMS message is sent to the broker, typically with `JmsTemplate`.\n* `\"jms.message.process\"` when a JMS message is processed by the application, typically with a `MessageListener` or a `@JmsListener` annotated method.\n\nNOTE: Currently there is no instrumentation for `\"jms.message.receive\"` observations as there is little value in measuring the time spent waiting for the receipt of a message.\nSuch an integration would typically instrument `MessageConsumer#receive` method calls. But once those return, the processing time is not measured and the trace scope cannot be propagated to the application.\n\nBy default, both observations share the same set of possible `KeyValues`:\n\n.Low cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`error` |Class name of the exception thrown during the messaging operation (or \"none\").\n|`exception` _(deprecated)_|Duplicates the `error` key and might be removed in the future.\n|`messaging.destination.temporary` _(required)_|Whether the destination is a `TemporaryQueue` or `TemporaryTopic` (values: `\"true\"` or `\"false\"`).\n|`messaging.operation` _(required)_|Name of the JMS operation being performed (values: `\"publish\"` or `\"process\"`).\n|===\n\n.High cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`messaging.message.conversation_id` |The correlation ID of the JMS message.\n|`messaging.destination.name` |The name of the destination the current message was sent to.\n|`messaging.message.id` |Value used by the messaging system as an identifier for the message.\n|===\n\n[[observability.jms.publish]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "JMS messaging instrumentation", "heading_level": 2, "file_order": 175, "section_index": 6, "content_hash": "2fd74cdf9e8228ea7b3bb55499308f3b8bfed7e4ec70689790bc64d67c9a8c17", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:a623c9f558d7fe13fe1d45b341f18729d5f5be2df1eaccb794b0d2723484c5a8", "content": "`\"jms.message.publish\"` observations are recorded when a JMS message is sent to the broker.\nThey measure the time spent sending the message and propagate the tracing information with outgoing JMS message headers.\n\nYou will need to configure the `ObservationRegistry` on the `JmsTemplate` to enable observations:\n\ninclude-code::./JmsTemplatePublish[]\n\nIt uses the `io.micrometer.jakarta9.instrument.jms.DefaultJmsPublishObservationConvention` by default, backed by the `io.micrometer.jakarta9.instrument.jms.JmsPublishObservationContext`.\n\nSimilar observations are recorded with `@JmsListener` annotated methods when response messages are returned from the listener method.\n\n[[observability.jms.process]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "JMS message Publication instrumentation", "heading_level": 3, "file_order": 175, "section_index": 7, "content_hash": "a623c9f558d7fe13fe1d45b341f18729d5f5be2df1eaccb794b0d2723484c5a8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:d5aba464eeed24d1e740959b05a6a01dc0beeefe27799bf6fd384b9897593722", "content": "`\"jms.message.process\"` observations are recorded when a JMS message is processed by the application.\nThey measure the time spent processing the message and propagate the tracing context with incoming JMS message headers.\n\nMost applications will use the xref:integration/jms/annotated.adoc#jms-annotated[`@JmsListener` annotated methods] mechanism to process incoming messages.\nYou will need to ensure that the `ObservationRegistry` is configured on the dedicated `JmsListenerContainerFactory`:\n\ninclude-code::./JmsConfiguration[]\n\nA xref:integration/jms/annotated.adoc#jms-annotated-support[default container factory is required to enable the annotation support],\nbut note that `@JmsListener` annotations can refer to specific container factory beans for specific purposes.\nIn all cases, Observations are only recorded if the observation registry is configured on the container factory.\n\nSimilar observations are recorded with `JmsTemplate` when messages are processed by a `MessageListener`.\nSuch listeners are set on a `MessageConsumer` within a session callback (see `JmsTemplate.execute(SessionCallback<T>)`).\n\nThis observation uses the `io.micrometer.jakarta9.instrument.jms.DefaultJmsProcessObservationConvention` by default, backed by the `io.micrometer.jakarta9.instrument.jms.JmsProcessObservationContext`.\n\n[[observability.http-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "JMS message Processing instrumentation", "heading_level": 3, "file_order": 175, "section_index": 8, "content_hash": "d5aba464eeed24d1e740959b05a6a01dc0beeefe27799bf6fd384b9897593722", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:c59004d2429361b4c2689f000324c344d860146eeacaf1a5f4d9d661e30d689f", "content": "HTTP server exchange observations are created with the name `\"http.server.requests\"` for Servlet and Reactive applications,\nor `\"http.server.request.duration\"` if using the OpenTelemetry convention.\n\n[[observability.http-server.servlet]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "HTTP Server instrumentation", "heading_level": 2, "file_order": 175, "section_index": 9, "content_hash": "c59004d2429361b4c2689f000324c344d860146eeacaf1a5f4d9d661e30d689f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:13ab732c42a899ec894464a64021b572b02ce2e888ed5305a5888b78f43d6a19", "content": "Applications need to configure the `org.springframework.web.filter.ServerHttpObservationFilter` Servlet filter in their application.\n\nThis will only record an observation as an error if the `Exception` has not been handled by the web framework and has bubbled up to the Servlet filter.\nTypically, all exceptions handled by Spring MVC's `@ExceptionHandler` and xref:web/webmvc/mvc-ann-rest-exceptions.adoc[`ProblemDetail` support] will not be recorded with the observation.\nYou can, at any point during request processing, set the error field on the `ObservationContext` yourself:\n\ninclude-code::./UserController[]\n\nNOTE: Because the instrumentation is done at the Servlet Filter level, the observation scope only covers the filters ordered after this one as well as the handling of the request.\nTypically, Servlet container error handling is performed at a lower level and won't have any active observation or span.\nFor this use case, a container-specific implementation is required, such as a `org.apache.catalina.Valve` for Tomcat; this is outside the scope of this project.\n\n[[observability.http-server.servlet.default]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "Servlet applications", "heading_level": 3, "file_order": 175, "section_index": 10, "content_hash": "13ab732c42a899ec894464a64021b572b02ce2e888ed5305a5888b78f43d6a19", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:8315ee67905d681f93a8ec9bc875c2c64e2f317ab9a54216255e471b7edf5b21", "content": "It uses the `org.springframework.http.server.observation.DefaultServerRequestObservationConvention` by default, backed by the `ServerRequestObservationContext`.\n\nBy default, the following `KeyValues` are created:\n\n.Low cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`error` _(required)_|Class name of the exception thrown during the exchange, or `\"none\"` if no exception happened.\n|`exception` _(deprecated)_|Duplicates the `error` key and might be removed in the future.\n|`method` _(required)_|Name of the HTTP request method or `\"none\"` if not a well-known method.\n|`outcome` _(required)_|Outcome of the HTTP server exchange.\n|`status` _(required)_|HTTP response raw status code, or `\"UNKNOWN\"` if no response was created.\n|`uri` _(required)_|URI pattern for the matching handler if available, falling back to `REDIRECTION` for 3xx responses, `NOT_FOUND` for 404 responses, `root` for requests with no path info, and `UNKNOWN` for all other requests.\n|===\n\n.High cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`http.url` _(required)_|HTTP request URI.\n|===\n\n[[observability.http-server.servlet.otel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "Default Semantic Convention", "heading_level": 4, "file_order": 175, "section_index": 11, "content_hash": "8315ee67905d681f93a8ec9bc875c2c64e2f317ab9a54216255e471b7edf5b21", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:188d96e5241c6ffa4b23f988bc77a299459663949f10b863023cb0569b9bcbd4", "content": "An OpenTelemetry variant is available with `org.springframework.http.server.observation.OpenTelemetryServerRequestObservationConvention`, backed by the `ServerRequestObservationContext`.\n\nThis variant complies with the https://github.com/open-telemetry/semantic-conventions/blob/v1.36.0/docs/http/http-metrics.md[OpenTelemetry Semantic Conventions for HTTP Metrics (v1.36.0)]\nand the https://github.com/open-telemetry/semantic-conventions/blob/v1.36.0/docs/http/http-spans.md[OpenTelemetry Semantic Conventions for HTTP Spans (v1.36.0)].\n\n[[observability.http-server.reactive]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "OpenTelemetry Semantic Convention", "heading_level": 4, "file_order": 175, "section_index": 12, "content_hash": "188d96e5241c6ffa4b23f988bc77a299459663949f10b863023cb0569b9bcbd4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:cc1ed2535dcd2a0a0708e693289764583140497c73f9e9452315e5ef5e0eb79a", "content": "Applications need to configure the `WebHttpHandlerBuilder` with a `MeterRegistry` to enable server instrumentation.\nThis can be done on the `WebHttpHandlerBuilder`, as follows:\n\ninclude-code::./HttpHandlerConfiguration[]\n\nIt uses the `org.springframework.http.server.reactive.observation.DefaultServerRequestObservationConvention` by default, backed by the `ServerRequestObservationContext`.\n\nThis will only record an observation as an error if the `Exception` has not been handled by an application Controller.\nTypically, all exceptions handled by Spring WebFlux's `@ExceptionHandler` and xref:web/webflux/ann-rest-exceptions.adoc[`ProblemDetail` support] will not be recorded with the observation.\nYou can, at any point during request processing, set the error field on the `ObservationContext` yourself:\n\ninclude-code::./UserController[]\n\nBy default, the following `KeyValues` are created:\n\n.Low cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`error` _(required)_|Class name of the exception thrown during the exchange, or `\"none\"` if no exception happened.\n|`exception` _(deprecated)_|Duplicates the `error` key and might be removed in the future.\n|`method` _(required)_|Name of the HTTP request method or `\"none\"` if not a well-known method.\n|`outcome` _(required)_|Outcome of the HTTP server exchange.\n|`status` _(required)_|HTTP response raw status code, or `\"UNKNOWN\"` if no response was created.\n|`uri` _(required)_|URI pattern for the matching handler if available, falling back to `REDIRECTION` for 3xx responses, `NOT_FOUND` for 404 responses, `root` for requests with no path info, and `UNKNOWN` for all other requests.\n|===\n\n.High cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`http.url` _(required)_|HTTP request URI.\n|===\n\n[[observability.http-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "Reactive applications", "heading_level": 3, "file_order": 175, "section_index": 13, "content_hash": "cc1ed2535dcd2a0a0708e693289764583140497c73f9e9452315e5ef5e0eb79a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:be328ffe9bf5aca6af0b19a638e1084457f71dd6f18a181a1d12efe3642c5960", "content": "HTTP client exchange observations are created with the name `\"http.client.requests\"` for blocking and reactive clients.\nThis observation measures the entire HTTP request/response exchange, from connection establishment up to body deserialization.\nUnlike their server counterparts, the instrumentation is implemented directly in the client so the only required step is to configure an `ObservationRegistry` on the client.\n\n[[observability.http-client.resttemplate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "HTTP Client Instrumentation", "heading_level": 2, "file_order": 175, "section_index": 14, "content_hash": "be328ffe9bf5aca6af0b19a638e1084457f71dd6f18a181a1d12efe3642c5960", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:dd032b10b01e14af76230a470baffa0d031d7dd9c8e6454a220c23a1d17cb13e", "content": "Applications must configure an `ObservationRegistry` on `RestTemplate` instances to enable the instrumentation; without that, observations are \"no-ops\".\nSpring Boot will auto-configure `RestTemplateBuilder` beans with the observation registry already set.\n\nInstrumentation uses the `org.springframework.http.client.observation.ClientRequestObservationConvention` by default, backed by the `ClientRequestObservationContext`.\n\n.Low cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`method` _(required)_|Name of the HTTP request method or `\"none\"` if not a well-known method.\n|`uri` _(required)_|URI template used for HTTP request, or `\"none\"` if none was provided. The protocol, host and port part of the URI are not considered.\n|`client.name` _(required)_|Client name derived from the request URI host.\n|`status` _(required)_|HTTP response raw status code, or `\"IO_ERROR\"` in case of `IOException`, or `\"CLIENT_ERROR\"` if no response was received.\n|`outcome` _(required)_|Outcome of the HTTP client exchange.\n|`error` _(required)_|Class name of the exception thrown during the exchange, or `\"none\"` if no exception happened.\n|`exception` _(deprecated)_|Duplicates the `error` key and might be removed in the future.\n|===\n\n.High cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`http.url` _(required)_|HTTP request URI.\n|===\n\n[[observability.http-client.restclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "RestTemplate", "heading_level": 3, "file_order": 175, "section_index": 15, "content_hash": "dd032b10b01e14af76230a470baffa0d031d7dd9c8e6454a220c23a1d17cb13e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:a2c6eb0c54f8ca4591d00524a91cc9fa398014d171215abf747d48bd07889940", "content": "Applications must configure an `ObservationRegistry` on the `RestClient.Builder` to enable the instrumentation; without that, observations are \"no-ops\".\n\nInstrumentation uses the `org.springframework.http.client.observation.ClientRequestObservationConvention` by default, backed by the `ClientRequestObservationContext`.\n\n.Low cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`method` _(required)_|Name of the HTTP request method or `\"none\"` if the request could not be created.\n|`uri` _(required)_|URI template used for HTTP request, or `\"none\"` if none was provided. The protocol, host and port part of the URI are not considered.\n|`client.name` _(required)_|Client name derived from the request URI host.\n|`status` _(required)_|HTTP response raw status code, or `\"IO_ERROR\"` in case of `IOException`, or `\"CLIENT_ERROR\"` if no response was received.\n|`outcome` _(required)_|Outcome of the HTTP client exchange.\n|`error` _(required)_|Class name of the exception thrown during the exchange, or `\"none\"` if no exception happened.\n|`exception` _(deprecated)_|Duplicates the `error` key and might be removed in the future.\n|===\n\n.High cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`http.url` _(required)_|HTTP request URI.\n|===\n\n[[observability.http-client.webclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "RestClient", "heading_level": 3, "file_order": 175, "section_index": 16, "content_hash": "a2c6eb0c54f8ca4591d00524a91cc9fa398014d171215abf747d48bd07889940", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:c0d529525393deb7901eb7941fc0825501db28b4a64c1d2ecb6989d1307498f2", "content": "Applications must configure an `ObservationRegistry` on the `WebClient.Builder` to enable the instrumentation; without that, observations are \"no-ops\".\nSpring Boot will auto-configure `WebClient.Builder` beans with the observation registry already set.\n\nInstrumentation uses the `org.springframework.web.reactive.function.client.ClientRequestObservationConvention` by default, backed by the `ClientRequestObservationContext`.\n\n.Low cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`method` _(required)_|Name of the HTTP request method or `\"none\"` if not a well-known method.\n|`uri` _(required)_|URI template used for HTTP request, or `\"none\"` if none was provided. The protocol, host and port part of the URI are not considered.\n|`client.name` _(required)_|Client name derived from the request URI host.\n|`status` _(required)_|HTTP response raw status code, or `\"IO_ERROR\"` in case of `IOException`, or `\"CLIENT_ERROR\"` if no response was received.\n|`outcome` _(required)_|Outcome of the HTTP client exchange.\n|`error` _(required)_|Class name of the exception thrown during the exchange, or `\"none\"` if no exception happened.\n|`exception` _(deprecated)_|Duplicates the `error` key and might be removed in the future.\n|===\n\n.High cardinality Keys\n[cols=\"a,a\"]\n|===\n|Name | Description\n|`http.url` _(required)_|HTTP request URI.\n|===\n\n[[observability.application-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "WebClient", "heading_level": 3, "file_order": 175, "section_index": 17, "content_hash": "c0d529525393deb7901eb7941fc0825501db28b4a64c1d2ecb6989d1307498f2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:0a12173b524b397a61380333bade64a8efb300968b3996db75a2afd341e177a6", "content": "Spring Framework does not contribute Observations for xref:core/beans/context-introduction.adoc#context-functionality-events-annotation[`@EventListener` calls],\nas they don't have the right semantics for such instrumentation.\nBy default, event publication and processing are done synchronously and on the same thread.\nThis means that during the execution of that task, the ThreadLocals and logging context will be the same as the event publisher.\n\nIf the application globally configures a custom `ApplicationEventMulticaster` with a strategy that schedules event processing on different threads, this is no longer true.\nAll `@EventListener` methods will be processed on a different thread, outside the main event publication thread.\nIn these cases, the {micrometer-context-propagation-docs}/[Micrometer Context Propagation library] can help propagate such values and better correlate the processing of the events.\nThe application can configure the chosen `TaskExecutor` to use a `ContextPropagatingTaskDecorator` that decorates tasks and propagates context.\nFor this to work, the `io.micrometer:context-propagation` library must be present on the classpath:\n\ninclude-code::./ApplicationEventsConfiguration[]\n\nSimilarly, if that asynchronous choice is made locally for each `@EventListener` annotated method, by adding `@Async` to it,\nyou can choose a `TaskExecutor` that propagates context by referring to it by its qualifier.\nGiven the following `TaskExecutor` bean definition, configured with the dedicated task decorator:\n\ninclude-code::./EventAsyncExecutionConfiguration[]\n\nAnnotating event listeners with `@Async` and the relevant qualifier will achieve similar context propagation results:\n\ninclude-code::./EmailNotificationListener[]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/observability.adoc", "title": "observability", "heading": "Application Events and `@EventListener`", "heading_level": 2, "file_order": 175, "section_index": 18, "content_hash": "0a12173b524b397a61380333bade64a8efb300968b3996db75a2afd341e177a6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/observability.adoc"}}
{"id": "sha256:4098882fe5c65dbbc2227ed5d4bd7ef13e273e6de6241d8f5b60dfb510a8087c", "content": "[[rest-client-access]]\n\nThe Spring Framework provides the following choices for making calls to REST endpoints:\n\n* xref:integration/rest-clients.adoc#rest-restclient[`RestClient`] -- synchronous client with a fluent API\n* xref:integration/rest-clients.adoc#rest-webclient[`WebClient`] -- non-blocking, reactive client with fluent API\n* xref:integration/rest-clients.adoc#rest-resttemplate[`RestTemplate`] -- synchronous client with template method API, now deprecated in favor of `RestClient`\n* xref:integration/rest-clients.adoc#rest-http-service-client[HTTP Service Clients] -- annotated interface backed by generated proxy\n\n[[rest-restclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "rest-clients", "heading_level": 1, "file_order": 176, "section_index": 0, "content_hash": "4098882fe5c65dbbc2227ed5d4bd7ef13e273e6de6241d8f5b60dfb510a8087c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:10000c13a063f44b53a58b4cc31e6dd80528ea2f4fd573a0d188f63d2778afe5", "content": "`RestClient` is a synchronous HTTP client that provides a fluent API to perform requests.\nIt serves as an abstraction over HTTP libraries, and handles conversion of HTTP request and response content to and from higher level Java objects.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "`RestClient`", "heading_level": 2, "file_order": 176, "section_index": 1, "content_hash": "10000c13a063f44b53a58b4cc31e6dd80528ea2f4fd573a0d188f63d2778afe5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:9543bfef04a436e5a316fd7f7e1086a1b2aa5855cd5c867d4afbd0c94fcf0c25", "content": "`RestClient` has static `create` shortcut methods.\nIt also exposes a `builder()` with further options:\n\n- select the HTTP library to use, see <<rest-request-factories>>\n- configure message converters, see <<rest-message-conversion>>\n- set a baseUrl\n- set default request headers, cookies, path variables, API version\n- configure an `ApiVersionInserter`\n- register interceptors\n- register request initializers\n\nOnce created, a `RestClient` is safe to use in multiple threads.\n\nThe below shows how to create or build a `RestClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tRestClient defaultClient = RestClient.create();\n\n\tRestClient customClient = RestClient.builder()\n .requestFactory(new HttpComponentsClientHttpRequestFactory())\n .messageConverters(converters -> converters.add(new MyCustomMessageConverter()))\n .baseUrl(\"https://example.com\")\n .defaultUriVariables(Map.of(\"variable\", \"foo\"))\n .defaultHeader(\"My-Header\", \"Foo\")\n .defaultCookie(\"My-Cookie\", \"Bar\")\n .defaultVersion(\"1.2\")\n .apiVersionInserter(ApiVersionInserter.fromHeader(\"API-Version\").build())\n .requestInterceptor(myCustomInterceptor)\n .requestInitializer(myCustomInitializer)\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tval defaultClient = RestClient.create()\n\n\tval customClient = RestClient.builder()\n .requestFactory(HttpComponentsClientHttpRequestFactory())\n .messageConverters { converters -> converters.add(MyCustomMessageConverter()) }\n .baseUrl(\"https://example.com\")\n .defaultUriVariables(mapOf(\"variable\" to \"foo\"))\n .defaultHeader(\"My-Header\", \"Foo\")\n .defaultCookie(\"My-Cookie\", \"Bar\")\n .defaultVersion(\"1.2\")\n .apiVersionInserter(ApiVersionInserter.fromHeader(\"API-Version\").build())\n .requestInterceptor(myCustomInterceptor)\n .requestInitializer(myCustomInitializer)\n .build()\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Create a `RestClient`", "heading_level": 3, "file_order": 176, "section_index": 2, "content_hash": "9543bfef04a436e5a316fd7f7e1086a1b2aa5855cd5c867d4afbd0c94fcf0c25", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:17d4e08865dc0371076431d96f936c9a6069e544545f46bfffe92f5af8a07daa", "content": "To perform an HTTP request, first specify the HTTP method to use.\nUse the convenience methods like `get()`, `head()`, `post()`, and others, or `method(HttpMethod)`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Use the `RestClient`", "heading_level": 3, "file_order": 176, "section_index": 3, "content_hash": "17d4e08865dc0371076431d96f936c9a6069e544545f46bfffe92f5af8a07daa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:c0c623cd87504ba98fcd370d0363fc433f1153c5c8c12debe430ca5dd28dd6a8", "content": "Next, specify the request URI with the `uri` methods.\nThis is optional, and you can skip this step if you configured a baseUrl through the builder.\nThe URL is typically specified as a `String`, with optional URI template variables.\nThe following shows how to perform a request:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tint id = 42;\n\trestClient.get()\n .uri(\"https://example.com/orders/{id}\", id)\n // ...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval id = 42\n\trestClient.get()\n .uri(\"https://example.com/orders/{id}\", id)\n // ...\n----\n======\n\nA function can also be used for more controls, such as specifying xref:web/webmvc/mvc-uri-building.adoc[request parameters].\n\nString URLs are encoded by default, but this can be changed by building a client with a custom `uriBuilderFactory`.\nThe URL can also be provided with a function or as a `java.net.URI`, both of which are not encoded.\nFor more details on working with and encoding URIs, see xref:web/webmvc/mvc-uri-building.adoc[URI Links].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Request URL", "heading_level": 4, "file_order": 176, "section_index": 4, "content_hash": "c0c623cd87504ba98fcd370d0363fc433f1153c5c8c12debe430ca5dd28dd6a8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:5643061fee7319cf123fd27367f19eb0e5cd5219b5ede41fdd23bd33e8b95238", "content": "If necessary, the HTTP request can be manipulated by adding request headers with `header(String, String)`, `headers(Consumer<HttpHeaders>`, or with the convenience methods `accept(MediaType...)`, `acceptCharset(Charset...)` and so on.\nFor HTTP requests that can contain a body (`POST`, `PUT`, and `PATCH`), additional methods are available: `contentType(MediaType)`, and `contentLength(long)`.\nYou can set an API version for the request if the client is configured with `ApiVersionInserter`.\n\nThe request body itself can be set by `body(Object)`, which internally uses <<rest-message-conversion>>.\nAlternatively, the request body can be set using a `ParameterizedTypeReference`, allowing you to use generics.\nFinally, the body can be set to a callback function that writes to an `OutputStream`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Request headers and body", "heading_level": 4, "file_order": 176, "section_index": 5, "content_hash": "5643061fee7319cf123fd27367f19eb0e5cd5219b5ede41fdd23bd33e8b95238", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:59811ea57ddf56c647061595dcd9473e36a4a18cec7f370272a3041f64ed24f5", "content": "Once the request has been set up, it can be sent by chaining method calls after `retrieve()`.\nFor example, the response body can be accessed by using `retrieve().body(Class)` or `retrieve().body(ParameterizedTypeReference)` for parameterized types like lists.\nThe `body` method converts the response contents into various types â€“ for instance, bytes can be converted into a `String`, JSON can be converted into objects using Jackson, and so on (see <<rest-message-conversion>>).\n\nThe response can also be converted into a `ResponseEntity`, giving access to the response headers as well as the body, with `retrieve().toEntity(Class)`\n\nNOTE: Calling `retrieve()` by itself is a no-op and returns a `ResponseSpec`.\nApplications must invoke a terminal operation on the `ResponseSpec` to have any side effect.\nIf consuming the response has no interest for your use case, you can use `retrieve().toBodilessEntity()`.\n\nThis sample shows how `RestClient` can be used to perform a simple `GET` request.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString result = restClient.get() <1>\n .uri(\"https://example.com\") <2>\n .retrieve() <3>\n .body(String.class); <4>\n\n\tSystem.out.println(result); <5>\n----\n<1> Set up a GET request\n<2> Specify the URL to connect to\n<3> Retrieve the response\n<4> Convert the response into a string\n<5> Print the result\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval result= restClient.get() <1>\n .uri(\"https://example.com\") <2>\n .retrieve() <3>\n .body<String>() <4>\n\n\tprintln(result) <5>\n----\n<1> Set up a GET request\n<2> Specify the URL to connect to\n<3> Retrieve the response\n<4> Convert the response into a string\n<5> Print the result\n======\n\nAccess to the response status code and headers is provided through `ResponseEntity`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tResponseEntity<String> result = restClient.get() <1>\n .uri(\"https://example.com\") <1>\n .retrieve()\n .toEntity(String.class); <2>\n\n\tSystem.out.println(\"Response status: \" + result.getStatusCode()); <3>\n\tSystem.out.println(\"Response headers: \" + result.getHeaders()); <3>\n\tSystem.out.println(\"Contents: \" + result.getBody()); <3>\n----\n<1> Set up a GET request for the specified URL\n<2> Convert the response into a `ResponseEntity`\n<3> Print the result\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval result = restClient.get() <1>\n .uri(\"https://example.com\") <1>\n .retrieve()\n .toEntity<String>() <2>\n\n\tprintln(\"Response status: \" + result.statusCode) <3>\n\tprintln(\"Response headers: \" + result.headers) <3>\n\tprintln(\"Contents: \" + result.body) <3>\n----\n<1> Set up a GET request for the specified URL\n<2> Convert the response into a `ResponseEntity`\n<3> Print the result\n======\n\n`RestClient` can convert JSON to objects, using the Jackson library.\nNote the usage of URI variables in this sample and that the `Accept` header is set to JSON.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tint id = ...;\n\tPet pet = restClient.get()\n .uri(\"https://petclinic.example.com/pets/{id}\", id) <1>\n .accept(APPLICATION_JSON) <2>\n .retrieve()\n .body(Pet.class); <3>\n----\n<1> Using URI variables\n<2> Set the `Accept` header to `application/json`\n<3> Convert the JSON response into a `Pet` domain object\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval id = ...\n\tval pet = restClient.get()\n .uri(\"https://petclinic.example.com/pets/{id}\", id) <1>\n .accept(APPLICATION_JSON) <2>\n .retrieve()\n .body<Pet>() <3>\n----\n<1> Using URI variables\n<2> Set the `Accept` header to `application/json`\n<3> Convert the JSON response into a `Pet` domain object\n======\n\nIn the next sample, `RestClient` is used to perform a POST request that contains JSON, which again is converted using Jackson.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tPet pet = ... <1>\n\tResponseEntity<Void> response = restClient.post() <2>\n .uri(\"https://petclinic.example.com/pets/new\") <2>\n .contentType(APPLICATION_JSON) <3>\n .body(pet) <4>\n .retrieve()\n .toBodilessEntity(); <5>\n----\n<1> Create a `Pet` domain object\n<2> Set up a POST request, and the URL to connect to\n<3> Set the `Content-Type` header to `application/json`\n<4> Use `pet` as the request body\n<5> Convert the response into a response entity with no body.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval pet: Pet = ... <1>\n\tval response = restClient.post() <2>\n .uri(\"https://petclinic.example.com/pets/new\") <2>\n .contentType(APPLICATION_JSON) <3>\n .body(pet) <4>\n .retrieve()\n .toBodilessEntity() <5>\n----\n<1> Create a `Pet` domain object\n<2> Set up a POST request, and the URL to connect to\n<3> Set the `Content-Type` header to `application/json`\n<4> Use `pet` as the request body\n<5> Convert the response into a response entity with no body.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Retrieving the response", "heading_level": 4, "file_order": 176, "section_index": 6, "content_hash": "59811ea57ddf56c647061595dcd9473e36a4a18cec7f370272a3041f64ed24f5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:84afaeac526b58204ec8de715c79f25521f58f3715f68f1ec6a3da628a32b308", "content": "By default, `RestClient` throws a subclass of `RestClientException` when retrieving a response with a 4xx or 5xx status code.\nThis behavior can be overridden using `onStatus`.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString result = restClient.get() <1>\n .uri(\"https://example.com/this-url-does-not-exist\") <1>\n .retrieve()\n .onStatus(HttpStatusCode::is4xxClientError, (request, response) -> { <2>\n throw new MyCustomRuntimeException(response.getStatusCode(), response.getHeaders()); <3>\n })\n .body(String.class);\n----\n<1> Create a GET request for a URL that returns a 404 status code\n<2> Set up a status handler for all 4xx status codes\n<3> Throw a custom exception\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval result = restClient.get() <1>\n .uri(\"https://example.com/this-url-does-not-exist\") <1>\n .retrieve()\n .onStatus(HttpStatusCode::is4xxClientError) { _, response -> <2>\n throw MyCustomRuntimeException(response.getStatusCode(), response.getHeaders()) } <3>\n .body<String>()\n----\n<1> Create a GET request for a URL that returns a 404 status code\n<2> Set up a status handler for all 4xx status codes\n<3> Throw a custom exception\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Error handling", "heading_level": 4, "file_order": 176, "section_index": 7, "content_hash": "84afaeac526b58204ec8de715c79f25521f58f3715f68f1ec6a3da628a32b308", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:b630f74b71a68aae218802da00caab72cc673262bb145ad7918f1c51efe3fc11", "content": "For more advanced scenarios, the `RestClient` gives access to the underlying HTTP request and response through the `exchange()` method, which can be used instead of `retrieve()`.\nStatus handlers are not applied when use `exchange()`, because the exchange function already provides access to the full response, allowing you to perform any error handling necessary.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tPet result = restClient.get()\n .uri(\"https://petclinic.example.com/pets/{id}\", id)\n .accept(APPLICATION_JSON)\n .exchange((request, response) -> { <1>\n if (response.getStatusCode().is4xxClientError()) { <2>\n throw new MyCustomRuntimeException(response.getStatusCode(), response.getHeaders()); <2>\n }\n else {\n Pet pet = convertResponse(response); <3>\n return pet;\n }\n });\n----\n<1> `exchange` provides the request and response\n<2> Throw an exception when the response has a 4xx status code\n<3> Convert the response into a Pet domain object\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval result = restClient.get()\n .uri(\"https://petclinic.example.com/pets/{id}\", id)\n .accept(MediaType.APPLICATION_JSON)\n .exchange { request, response -> <1>\n if (response.getStatusCode().is4xxClientError()) { <2>\n throw MyCustomRuntimeException(response.getStatusCode(), response.getHeaders()) <2>\n } else {\n val pet: Pet = convertResponse(response) <3>\n pet\n }\n }\n----\n<1> `exchange` provides the request and response\n<2> Throw an exception when the response has a 4xx status code\n<3> Convert the response into a Pet domain object\n======\n\n[[rest-message-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Exchange", "heading_level": 4, "file_order": 176, "section_index": 8, "content_hash": "b630f74b71a68aae218802da00caab72cc673262bb145ad7918f1c51efe3fc11", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:a80a26b679f4b50a6fcef0b154369ef7345dc1e7850fd5f1b11547d32ebb4f64", "content": "xref:web/webmvc/message-converters.adoc#message-converters[See the supported HTTP message converters in the dedicated section].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "HTTP Message Conversion", "heading_level": 3, "file_order": 176, "section_index": 9, "content_hash": "a80a26b679f4b50a6fcef0b154369ef7345dc1e7850fd5f1b11547d32ebb4f64", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:d244dd2600c638a3e4199382bc24a145fa1590d503af06103e9b55a11390018d", "content": "To serialize only a subset of the object properties, you can specify a {baeldung-blog}/jackson-json-view-annotation[Jackson JSON View], as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tMappingJacksonValue value = new MappingJacksonValue(new User(\"eric\", \"7!jd#h23\"));\n\tvalue.setSerializationView(User.WithoutPasswordView.class);\n\n\tResponseEntity<Void> response = restClient.post() // or RestTemplate.postForEntity\n .contentType(APPLICATION_JSON)\n .body(value)\n .retrieve()\n .toBodilessEntity();\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Jackson JSON Views", "heading_level": 4, "file_order": 176, "section_index": 10, "content_hash": "d244dd2600c638a3e4199382bc24a145fa1590d503af06103e9b55a11390018d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:04d35c009868c8dbee1087c25b028363a9724470ee68bc0f83959f264eb4b7f4", "content": "To send multipart data, you need to provide a `MultiValueMap<String, Object>` whose values may be an `Object` for part content, a `Resource` for a file part, or an `HttpEntity` for part content with headers.\nFor example:\n\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tMultiValueMap<String, Object> parts = new LinkedMultiValueMap<>();\n\n\tparts.add(\"fieldPart\", \"fieldValue\");\n\tparts.add(\"filePart\", new FileSystemResource(\"...logo.png\"));\n\tparts.add(\"jsonPart\", new Person(\"Jason\"));\n\n\tHttpHeaders headers = new HttpHeaders();\n\theaders.setContentType(MediaType.APPLICATION_XML);\n\tparts.add(\"xmlPart\", new HttpEntity<>(myBean, headers));\n\n\t// send using RestClient.post or RestTemplate.postForEntity\n----\n\nIn most cases, you do not have to specify the `Content-Type` for each part.\nThe content type is determined automatically based on the `HttpMessageConverter` chosen to serialize it or, in the case of a `Resource`, based on the file extension.\nIf necessary, you can explicitly provide the `MediaType` with an `HttpEntity` wrapper.\n\nOnce the `MultiValueMap` is ready, you can use it as the body of a `POST` request, using `RestClient.post().body(parts)` (or `RestTemplate.postForObject`).\n\nIf the `MultiValueMap` contains at least one non-`String` value, the `Content-Type` is set to `multipart/form-data` by the `FormHttpMessageConverter`.\nIf the `MultiValueMap` has `String` values, the `Content-Type` defaults to `application/x-www-form-urlencoded`.\nIf necessary the `Content-Type` may also be set explicitly.\n\n[[rest-request-factories]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Multipart", "heading_level": 4, "file_order": 176, "section_index": 11, "content_hash": "04d35c009868c8dbee1087c25b028363a9724470ee68bc0f83959f264eb4b7f4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:34cfccefce91cc6daae0577b48e7bc21ce98d3aa3d9b6e750e1ff90593cbc4d9", "content": "To execute the HTTP request, `RestClient` uses a client HTTP library.\nThese libraries are adapted via the `ClientRequestFactory` interface.\nVarious implementations are available:\n\n* `JdkClientHttpRequestFactory` for Java's `HttpClient`\n* `HttpComponentsClientHttpRequestFactory` for use with Apache HTTP Components `HttpClient`\n* `JettyClientHttpRequestFactory` for Jetty's `HttpClient`\n* `ReactorNettyClientRequestFactory` for Reactor Netty's `HttpClient`\n* `SimpleClientHttpRequestFactory` as a simple default\n\nIf no request factory is specified when the `RestClient` was built, it will use the Apache or Jetty `HttpClient` if they are available on the classpath.\nOtherwise, if the `java.net.http` module is loaded, it will use Java's `HttpClient`.\nFinally, it will resort to the simple default.\n\nTIP: Note that the `SimpleClientHttpRequestFactory` may raise an exception when accessing the status of a response that represents an error (for example, 401).\nIf this is an issue, use any of the alternative request factories.\n\n[[rest-webclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Client Request Factories", "heading_level": 3, "file_order": 176, "section_index": 12, "content_hash": "34cfccefce91cc6daae0577b48e7bc21ce98d3aa3d9b6e750e1ff90593cbc4d9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:61388ccdf3f999655db29f34c7d7fe0d411323223b184419dbb2ea9f5c175aec", "content": "`WebClient` is a non-blocking, reactive client to perform HTTP requests. It was\nintroduced in 5.0 and offers an alternative to the `RestTemplate`, with support for\nsynchronous, asynchronous, and streaming scenarios.\n\n`WebClient` supports the following:\n\n* Non-blocking I/O\n* Reactive Streams back pressure\n* High concurrency with fewer hardware resources\n* Functional-style, fluent API that takes advantage of lambda expressions\n* Synchronous and asynchronous interactions\n* Streaming up to or streaming down from a server\n\nSee xref:web/webflux-webclient.adoc[WebClient] for more details.\n\n[[rest-resttemplate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "`WebClient`", "heading_level": 2, "file_order": 176, "section_index": 13, "content_hash": "61388ccdf3f999655db29f34c7d7fe0d411323223b184419dbb2ea9f5c175aec", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:36175710df28f4358f8943aada511cf3b5150f4311bd26ac438405d896326081", "content": "The `RestTemplate` provides a high-level API over HTTP client libraries in the form of a classic Spring Template class.\nIt exposes the following groups of overloaded methods:\n\nWARNING: As of Spring Framework 7.0, `RestTemplate` is deprecated in favor of `RestClient` and will be removed in a future version,\nplease use the xref:integration/rest-clients.adoc#migrating-to-restclient[\"Migrating to RestClient\"] guide.\nFor asynchronous and streaming scenarios, consider the reactive xref:web/webflux-webclient.adoc[WebClient].\n\n[[rest-overview-of-resttemplate-methods-tbl]]\n.RestTemplate methods\n[cols=\"1,3\"]\n|===\n| Method group | Description\n\n| `getForObject`\n| Retrieves a representation via GET.\n\n| `getForEntity`\n| Retrieves a `ResponseEntity` (that is, status, headers, and body) by using GET.\n\n| `headForHeaders`\n| Retrieves all headers for a resource by using HEAD.\n\n| `postForLocation`\n| Creates a new resource by using POST and returns the `Location` header from the response.\n\n| `postForObject`\n| Creates a new resource by using POST and returns the representation from the response.\n\n| `postForEntity`\n| Creates a new resource by using POST and returns the representation from the response.\n\n| `put`\n| Creates or updates a resource by using PUT.\n\n| `patchForObject`\n| Updates a resource by using PATCH and returns the representation from the response.\nNote that the JDK `HttpURLConnection` does not support `PATCH`, but Apache HttpComponents and others do.\n\n| `delete`\n| Deletes the resources at the specified URI by using DELETE.\n\n| `optionsForAllow`\n| Retrieves allowed HTTP methods for a resource by using ALLOW.\n\n| `exchange`\n| More generalized (and less opinionated) version of the preceding methods that provides extra flexibility when needed.\nIt accepts a `RequestEntity` (including HTTP method, URL, headers, and body as input) and returns a `ResponseEntity`.\n\nThese methods allow the use of `ParameterizedTypeReference` instead of `Class` to specify\na response type with generics.\n\n| `execute`\n| The most generalized way to perform a request, with full control over request\npreparation and response extraction through callback interfaces.\n\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "`RestTemplate`", "heading_level": 2, "file_order": 176, "section_index": 14, "content_hash": "36175710df28f4358f8943aada511cf3b5150f4311bd26ac438405d896326081", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:60d8c7aac21c6a1cde4bfa9db5adf6121507845679391cb225682b66b37e13f7", "content": "`RestTemplate` uses the same HTTP library abstraction as `RestClient`.\nBy default, it uses the `SimpleClientHttpRequestFactory`, but this can be changed via the constructor.\nSee <<rest-request-factories>>.\n\nNOTE: `RestTemplate` can be instrumented for observability, in order to produce metrics and traces.\nSee the xref:integration/observability.adoc#http-client.resttemplate[RestTemplate Observability support] section.\n\n[[rest-template-body]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Initialization", "heading_level": 3, "file_order": 176, "section_index": 15, "content_hash": "60d8c7aac21c6a1cde4bfa9db5adf6121507845679391cb225682b66b37e13f7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:258041765855eec64846ee6508daf33799fecce800c228bec04aa5f228793803", "content": "Objects passed into and returned from `RestTemplate` methods are converted to and from HTTP messages\nwith the help of an `HttpMessageConverter`, see <<rest-message-conversion>>.\n\n[[migrating-to-restclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Body", "heading_level": 3, "file_order": 176, "section_index": 16, "content_hash": "258041765855eec64846ee6508daf33799fecce800c228bec04aa5f228793803", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:a619d9dfa6e782c588e2ca5ef2889d8d3aa0da747445b876f005f803c0e307d2", "content": "Applications can adopt `RestClient` in a gradual fashion, first focusing on API usage and then on infrastructure setup.\nYou can consider the following steps:\n\n1. Create one or more `RestClient` from existing `RestTemplate` instances, like: `RestClient restClient = RestClient.create(restTemplate)`.\n Gradually replace `RestTemplate` usage in your application, component by component, by focusing first on issuing requests.\n See the table below for API equivalents.\n2. Once all client requests go through `RestClient` instances, you can now work on replicating your existing\n `RestTemplate` instance creations by using `RestClient.Builder`. Because `RestTemplate` and `RestClient`\n share the same infrastructure, you can reuse custom `ClientHttpRequestFactory` or `ClientHttpRequestInterceptor`\n in your setup. See xref:integration/rest-clients.adoc#rest-restclient[the `RestClient` builder API].\n\nIf no other library is available on the classpath, `RestClient` will choose the `JdkClientHttpRequestFactory`\npowered by the modern JDK `HttpClient`, whereas `RestTemplate` would pick the `SimpleClientHttpRequestFactory` that\nuses `HttpURLConnection`. This can explain subtle behavior difference at runtime at the HTTP level.\n\nThe following table shows `RestClient` equivalents for `RestTemplate` methods.\n\n.RestClient equivalents for RestTemplate methods\n[cols=\"1,1\", options=\"header\"]\n|===\n| `RestTemplate` method | `RestClient` equivalent\n\n| `getForObject(String, Class, Object...)`\n| `get()\n.uri(String, Object...)\n.retrieve()\n.body(Class)`\n\n| `getForObject(String, Class, Map)`\n| `get()\n.uri(String, Map)\n.retrieve()\n.body(Class)`\n\n| `getForObject(URI, Class)`\n| `get()\n.uri(URI)\n.retrieve()\n.body(Class)`\n\n| `getForEntity(String, Class, Object...)`\n| `get()\n.uri(String, Object...)\n.retrieve()\n.toEntity(Class)`\n\n| `getForEntity(String, Class, Map)`\n| `get()\n.uri(String, Map)\n.retrieve()\n.toEntity(Class)`\n\n| `getForEntity(URI, Class)`\n| `get()\n.uri(URI)\n.retrieve()\n.toEntity(Class)`\n\n| `headForHeaders(String, Object...)`\n| `head()\n.uri(String, Object...)\n.retrieve()\n.toBodilessEntity()\n.getHeaders()`\n\n| `headForHeaders(String, Map)`\n| `head()\n.uri(String, Map)\n.retrieve()\n.toBodilessEntity()\n.getHeaders()`\n\n| `headForHeaders(URI)`\n| `head()\n.uri(URI)\n.retrieve()\n.toBodilessEntity()\n.getHeaders()`\n\n| `postForLocation(String, Object, Object...)`\n| `post()\n.uri(String, Object...)\n.body(Object).retrieve()\n.toBodilessEntity()\n.getLocation()`\n\n| `postForLocation(String, Object, Map)`\n| `post()\n.uri(String, Map)\n.body(Object)\n.retrieve()\n.toBodilessEntity()\n.getLocation()`\n\n| `postForLocation(URI, Object)`\n| `post()\n.uri(URI)\n.body(Object)\n.retrieve()\n.toBodilessEntity()\n.getLocation()`\n\n| `postForObject(String, Object, Class, Object...)`\n| `post()\n.uri(String, Object...)\n.body(Object)\n.retrieve()\n.body(Class)`\n\n| `postForObject(String, Object, Class, Map)`\n| `post()\n.uri(String, Map)\n.body(Object)\n.retrieve()\n.body(Class)`\n\n| `postForObject(URI, Object, Class)`\n| `post()\n.uri(URI)\n.body(Object)\n.retrieve()\n.body(Class)`\n\n| `postForEntity(String, Object, Class, Object...)`\n| `post()\n.uri(String, Object...)\n.body(Object)\n.retrieve()\n.toEntity(Class)`\n\n| `postForEntity(String, Object, Class, Map)`\n| `post()\n.uri(String, Map)\n.body(Object)\n.retrieve()\n.toEntity(Class)`\n\n| `postForEntity(URI, Object, Class)`\n| `post()\n.uri(URI)\n.body(Object)\n.retrieve()\n.toEntity(Class)`\n\n| `put(String, Object, Object...)`\n| `put()\n.uri(String, Object...)\n.body(Object)\n.retrieve()\n.toBodilessEntity()`\n\n| `put(String, Object, Map)`\n| `put()\n.uri(String, Map)\n.body(Object)\n.retrieve()\n.toBodilessEntity()`\n\n| `put(URI, Object)`\n| `put()\n.uri(URI)\n.body(Object)\n.retrieve()\n.toBodilessEntity()`\n\n| `patchForObject(String, Object, Class, Object...)`\n| `patch()\n.uri(String, Object...)\n.body(Object)\n.retrieve()\n.body(Class)`\n\n| `patchForObject(String, Object, Class, Map)`\n| `patch()\n.uri(String, Map)\n.body(Object)\n.retrieve()\n.body(Class)`\n\n| `patchForObject(URI, Object, Class)`\n| `patch()\n.uri(URI)\n.body(Object)\n.retrieve()\n.body(Class)`\n\n| `delete(String, Object...)`\n| `delete()\n.uri(String, Object...)\n.retrieve()\n.toBodilessEntity()`\n\n| `delete(String, Map)`\n| `delete()\n.uri(String, Map)\n.retrieve()\n.toBodilessEntity()`\n\n| `delete(URI)`\n| `delete()\n.uri(URI)\n.retrieve()\n.toBodilessEntity()`\n\n| `optionsForAllow(String, Object...)`\n| `options()\n.uri(String, Object...)\n.retrieve()\n.toBodilessEntity()\n.getAllow()`\n\n| `optionsForAllow(String, Map)`\n| `options()\n.uri(String, Map)\n.retrieve()\n.toBodilessEntity()\n.getAllow()`\n\n| `optionsForAllow(URI)`\n| `options()\n.uri(URI)\n.retrieve()\n.toBodilessEntity()\n.getAllow()`\n\n| `exchange(String, HttpMethod, HttpEntity, Class, Object...)`\n| `method(HttpMethod)\n.uri(String, Object...)\n.headers(Consumer<HttpHeaders>)\n.body(Object)\n.retrieve()\n.toEntity(Class)` footnote:http-entity[`HttpEntity` headers and body have to be supplied to the `RestClient` via `headers(Consumer<HttpHeaders>)` and `body(Object)`.]\n\n| `exchange(String, HttpMethod, HttpEntity, Class, Map)`\n| `method(HttpMethod)\n.uri(String, Map)\n.headers(Consumer<HttpHeaders>)\n.body(Object)\n.retrieve()\n.toEntity(Class)` footnote:http-entity[]\n\n| `exchange(URI, HttpMethod, HttpEntity, Class)`\n| `method(HttpMethod)\n.uri(URI)\n.headers(Consumer<HttpHeaders>)\n.body(Object)\n.retrieve()\n.toEntity(Class)` footnote:http-entity[]\n\n| `exchange(String, HttpMethod, HttpEntity, ParameterizedTypeReference, Object...)`\n| `method(HttpMethod)\n.uri(String, Object...)\n.headers(Consumer<HttpHeaders>)\n.body(Object)\n.retrieve()\n.toEntity(ParameterizedTypeReference)` footnote:http-entity[]\n\n| `exchange(String, HttpMethod, HttpEntity, ParameterizedTypeReference, Map)`\n| `method(HttpMethod)\n.uri(String, Map)\n.headers(Consumer<HttpHeaders>)\n.body(Object)\n.retrieve()\n.toEntity(ParameterizedTypeReference)` footnote:http-entity[]\n\n| `exchange(URI, HttpMethod, HttpEntity, ParameterizedTypeReference)`\n| `method(HttpMethod)\n.uri(URI)\n.headers(Consumer<HttpHeaders>)\n.body(Object)\n.retrieve()\n.toEntity(ParameterizedTypeReference)` footnote:http-entity[]\n\n| `exchange(RequestEntity, Class)`\n| `method(HttpMethod)\n.uri(URI)\n.headers(Consumer<HttpHeaders>)\n.body(Object)\n.retrieve()\n.toEntity(Class)` footnote:request-entity[`RequestEntity` method, URI, headers and body have to be supplied to the `RestClient` via `method(HttpMethod)`, `uri(URI)`, `headers(Consumer<HttpHeaders>)` and `body(Object)`.]\n\n| `exchange(RequestEntity, ParameterizedTypeReference)`\n| `method(HttpMethod)\n.uri(URI)\n.headers(Consumer<HttpHeaders>)\n.body(Object)\n.retrieve()\n.toEntity(ParameterizedTypeReference)` footnote:request-entity[]\n\n| `execute(String, HttpMethod, RequestCallback, ResponseExtractor, Object...)`\n| `method(HttpMethod)\n.uri(String, Object...)\n.exchange(ExchangeFunction)`\n\n| `execute(String, HttpMethod, RequestCallback, ResponseExtractor, Map)`\n| `method(HttpMethod)\n.uri(String, Map)\n.exchange(ExchangeFunction)`\n\n| `execute(URI, HttpMethod, RequestCallback, ResponseExtractor)`\n| `method(HttpMethod)\n.uri(URI)\n.exchange(ExchangeFunction)`\n\n|===\n\n`RestClient` and `RestTemplate` instances share the same behavior when it comes to throwing exceptions\n(with the `RestClientException` type being at the top of the hierarchy).\nWhen `RestTemplate` consistently throws `HttpClientErrorException` for \"4xx\" response statues,\n`RestClient` allows for more flexibility with custom xref:integration/rest-clients.adoc#rest-http-service-client-exceptions[\"status handlers\"].\n\n[[rest-http-service-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Migrating to `RestClient`", "heading_level": 3, "file_order": 176, "section_index": 17, "content_hash": "a619d9dfa6e782c588e2ca5ef2889d8d3aa0da747445b876f005f803c0e307d2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:4337c8e1be67a63502be94d9e4943b6b430ba1031cf721e6ac842f034c3ab272", "content": "You can define an HTTP Service as a Java interface with `@HttpExchange` methods, and use\n`HttpServiceProxyFactory` to create a client proxy from it for remote access over HTTP via\n`RestClient`, `WebClient`, or `RestTemplate`. On the server side, an `@Controller` class\ncan implement the same interface to handle requests with\nxref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-httpexchange-annotation[@HttpExchange]\ncontroller methods.\n\nFirst, create the Java interface:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface RepositoryService {\n\n @GetExchange(\"/repos/{owner}/{repo}\")\n Repository getRepository(@PathVariable String owner, @PathVariable String repo);\n\n // more HTTP exchange methods...\n\n\t}\n----\n\nOptionally, use `@HttpExchange` at the type level to declare common attributes for all methods:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@HttpExchange(url = \"/repos/{owner}/{repo}\", accept = \"application/vnd.github.v3+json\")\n\tpublic interface RepositoryService {\n\n @GetExchange\n Repository getRepository(@PathVariable String owner, @PathVariable String repo);\n\n @PatchExchange(contentType = MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n void updateRepository(@PathVariable String owner, @PathVariable String repo,\n @RequestParam String name, @RequestParam String description, @RequestParam String homepage);\n\n\t}\n----\n\nNext, configure the client and create the `HttpServiceProxyFactory`:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Using RestClient...\n\n\tRestClient restClient = RestClient.create(\"...\");\n\tRestClientAdapter adapter = RestClientAdapter.create(restClient);\n\n\t// or WebClient...\n\n\tWebClient webClient = WebClient.create(\"...\");\n\tWebClientAdapter adapter = WebClientAdapter.create(webClient);\n\n\t// or RestTemplate...\n\n\tRestTemplate restTemplate = new RestTemplate();\n\tRestTemplateAdapter adapter = RestTemplateAdapter.create(restTemplate);\n\n\tHttpServiceProxyFactory factory = HttpServiceProxyFactory.builderFor(adapter).build();\n----\n\nNow, you're ready to create client proxies:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRepositoryService service = factory.createClient(RepositoryService.class);\n\t// Use service methods for remote calls...\n----\n\nHTTP service clients is a powerful and expressive choice for remote access over HTTP.\nIt allows one team to own the knowledge of how a REST API works, what parts are relevant\nto a client application, what input and output types to create, what endpoint method\nsignatures are needed, what Javadoc to have, and so on. The resulting Java API guides and\nis ready to use.\n\n[[rest-http-service-client-method-parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "HTTP Service Clients", "heading_level": 2, "file_order": 176, "section_index": 18, "content_hash": "4337c8e1be67a63502be94d9e4943b6b430ba1031cf721e6ac842f034c3ab272", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:83e082e7295bde7e3efbfb55b2dc838f92bc383f6df112454bd9c08bd7fc83ec", "content": "`@HttpExchange` methods support flexible method signatures with the following inputs:\n\n[cols=\"1,2\", options=\"header\"]\n|===\n| Method parameter | Description\n\n| `URI`\n| Dynamically set the URL for the request, overriding the annotation's `url` attribute.\n\n| `UriBuilderFactory`\n| Provide a `UriBuilderFactory` to expand the URI template and URI variables with.\n In effect, replaces the `UriBuilderFactory` (and its base URL) of the underlying client.\n\n| `HttpMethod`\n| Dynamically set the HTTP method for the request, overriding the annotation's `method` attribute\n\n| `@RequestHeader`\n| Add a request header or multiple headers. The argument may be a single value,\n a `Collection<?>` of values, `Map<String, ?>`,`MultiValueMap<String, ?>`.\n Type conversion is supported for non-String values. Header values are added and\n do not override already added header values.\n\n| `@PathVariable`\n| Add a variable for expand a placeholder in the request URL. The argument may be a\n `Map<String, ?>` with multiple variables, or an individual value. Type conversion\n is supported for non-String values.\n\n| `@RequestAttribute`\n| Provide an `Object` to add as a request attribute. Only supported by `RestClient`\n and `WebClient`.\n\n| `@RequestBody`\n| Provide the body of the request either as an Object to be serialized, or a\n Reactive Streams `Publisher` such as `Mono`, `Flux`, or any other async type supported\n through the configured `ReactiveAdapterRegistry`.\n\n| `@RequestParam`\n| Add a request parameter or multiple parameters. The argument may be a `Map<String, ?>`\n or `MultiValueMap<String, ?>` with multiple parameters, a `Collection<?>` of values, or\n an individual value. Type conversion is supported for non-String values.\n\n When `\"content-type\"` is set to `\"application/x-www-form-urlencoded\"`, request\n parameters are encoded in the request body. Otherwise, they are added as URL query\n parameters.\n\n| `@RequestPart`\n| Add a request part, which may be a String (form field), `Resource` (file part),\n Object (entity to be encoded, for example, as JSON), `HttpEntity` (part content and headers),\n a Spring `Part`, or Reactive Streams `Publisher` of any of the above.\n\n| `MultipartFile`\n| Add a request part from a `MultipartFile`, typically used in a Spring MVC controller\n where it represents an uploaded file.\n\n| `@CookieValue`\n| Add a cookie or multiple cookies. The argument may be a `Map<String, ?>` or\n `MultiValueMap<String, ?>` with multiple cookies, a `Collection<?>` of values, or an\n individual value. Type conversion is supported for non-String values.\n\n|===\n\nMethod parameters cannot be `null` unless the `required` attribute (where available on a\nparameter annotation) is set to `false`, or the parameter is marked optional as determined by\n{spring-framework-api}/core/MethodParameter.html#isOptional()[`MethodParameter#isOptional`].\n\n`RestClientAdapter` provides additional support for a method parameter of type\n`StreamingHttpOutputMessage.Body` that allows sending the request body by writing to an\n`OutputStream`.\n\n[[rest-http-service-client.custom-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Method Parameters", "heading_level": 3, "file_order": 176, "section_index": 19, "content_hash": "83e082e7295bde7e3efbfb55b2dc838f92bc383f6df112454bd9c08bd7fc83ec", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:0d24641280a020fefb28acaf2e91fe3544f71c338a4894fe9bf2ef1896039ff2", "content": "You can configure a custom `HttpServiceArgumentResolver`. The example interface below\nuses a custom `Search` method parameter type:\n\ninclude-code::./CustomHttpServiceArgumentResolver[tag=httpserviceclient,indent=0]\n\nA custom argument resolver could be implemented like this:\n\ninclude-code::./CustomHttpServiceArgumentResolver[tag=argumentresolver,indent=0]\n\nTo configure the custom argument resolver:\n\ninclude-code::./CustomHttpServiceArgumentResolver[tag=usage,indent=0]\n\nTIP: By default, `RequestEntity` is not supported as a method parameter, instead encouraging\nthe use of more fine-grained method parameters for individual parts of the request.\n\n[[rest-http-service-client-return-values]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Custom Arguments", "heading_level": 3, "file_order": 176, "section_index": 20, "content_hash": "0d24641280a020fefb28acaf2e91fe3544f71c338a4894fe9bf2ef1896039ff2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:a15c7fc9f05891ca6c2979f4ebc7e3f42b6852702c1a07addc0cfcd4d4e15465", "content": "The supported return values depend on the underlying client.\n\nClients adapted to `HttpExchangeAdapter` such as `RestClient` and `RestTemplate`\nsupport synchronous return values:\n\n[cols=\"1,2\", options=\"header\"]\n|===\n| Method return value | Description\n\n| `void`\n| Perform the given request.\n\n| `HttpHeaders`\n| Perform the given request and return the response headers.\n\n| `<T>`\n| Perform the given request and decode the response content to the declared return type.\n\n| `ResponseEntity<Void>`\n| Perform the given request and return a `ResponseEntity` with the status and headers.\n\n| `ResponseEntity<T>`\n| Perform the given request, decode the response content to the declared return type, and\n return a `ResponseEntity` with the status, headers, and the decoded body.\n\n|===\n\nClients adapted to `ReactorHttpExchangeAdapter` such as `WebClient`, support all of above\nas well as reactive variants. The table below shows Reactor types, but you can also use\nother reactive types that are supported through the `ReactiveAdapterRegistry`:\n\n[cols=\"1,2\", options=\"header\"]\n|===\n| Method return value | Description\n\n| `Mono<Void>`\n| Perform the given request, and release the response content, if any.\n\n| `Mono<HttpHeaders>`\n| Perform the given request, release the response content, if any, and return the\nresponse headers.\n\n| `Mono<T>`\n| Perform the given request and decode the response content to the declared return type.\n\n| `Flux<T>`\n| Perform the given request and decode the response content to a stream of the declared\nelement type.\n\n| `Mono<ResponseEntity<Void>>`\n| Perform the given request, and release the response content, if any, and return a\n`ResponseEntity` with the status and headers.\n\n| `Mono<ResponseEntity<T>>`\n| Perform the given request, decode the response content to the declared return type, and\nreturn a `ResponseEntity` with the status, headers, and the decoded body.\n\n| `Mono<ResponseEntity<Flux<T>>`\n| Perform the given request, decode the response content to a stream of the declared\nelement type, and return a `ResponseEntity` with the status, headers, and the decoded\nresponse body stream.\n\n|===\n\nBy default, the timeout for synchronous return values with `ReactorHttpExchangeAdapter`\ndepends on how the underlying HTTP client is configured. You can set a `blockTimeout`\nvalue on the adapter level as well, but we recommend relying on timeout settings of the\nunderlying HTTP client, which operates at a lower level and provides more control.\n\n`RestClientAdapter` provides supports additional support for a return value of type\n`InputStream` or `ResponseEntity<InputStream>` that provides access to the raw response\nbody content.\n\n[[rest-http-service-client-exceptions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Return Values", "heading_level": 3, "file_order": 176, "section_index": 21, "content_hash": "a15c7fc9f05891ca6c2979f4ebc7e3f42b6852702c1a07addc0cfcd4d4e15465", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:3d5ac0aec58f7b2af06994b3f631dc891198deb7e21ff4beca496888958d0598", "content": "To customize error handling for HTTP Service client proxies, you can configure the\nunderlying client as needed. By default, clients raise an exception for 4xx and 5xx HTTP\nstatus codes. To customize this, register a response status handler that applies to all\nresponses performed through the client as follows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// For RestClient\n\tRestClient restClient = RestClient.builder()\n .defaultStatusHandler(HttpStatusCode::isError, (request, response) -> ...)\n .build();\n\tRestClientAdapter adapter = RestClientAdapter.create(restClient);\n\n\t// or for WebClient...\n\tWebClient webClient = WebClient.builder()\n .defaultStatusHandler(HttpStatusCode::isError, resp -> ...)\n .build();\n\tWebClientAdapter adapter = WebClientAdapter.create(webClient);\n\n\t// or for RestTemplate...\n\tRestTemplate restTemplate = new RestTemplate();\n\trestTemplate.setErrorHandler(myErrorHandler);\n\n\tRestTemplateAdapter adapter = RestTemplateAdapter.create(restTemplate);\n\n\tHttpServiceProxyFactory factory = HttpServiceProxyFactory.builderFor(adapter).build();\n----\n\nFor more details and options such as suppressing error status codes, see the reference\ndocumentation for each client, as well as the Javadoc of `defaultStatusHandler` in\n`RestClient.Builder` or `WebClient.Builder`, and the `setErrorHandler` of `RestTemplate`.\n\n[[rest-http-service-client-adapter-decorator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Error Handling", "heading_level": 3, "file_order": 176, "section_index": 22, "content_hash": "3d5ac0aec58f7b2af06994b3f631dc891198deb7e21ff4beca496888958d0598", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:035113346e215b54a21ee9b90544e89f53e71d49b660d6f68f25a96c4541cb95", "content": "`HttpExchangeAdapter` and `ReactorHttpExchangeAdapter` are contracts that decouple HTTP\nInterface client infrastructure from the details of invoking the underlying\nclient. There are adapter implementations for `RestClient`, `WebClient`, and\n`RestTemplate`.\n\nOccasionally, it may be useful to intercept client invocations through a decorator\nconfigurable in the `HttpServiceProxyFactory.Builder`. For example, you can apply\nbuilt-in decorators to suppress 404 exceptions and return a `ResponseEntity` with\n`NOT_FOUND` and a `null` body:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// For RestClient\n\tHttpServiceProxyFactory factory = HttpServiceProxyFactory.builderFor(restCqlientAdapter)\n .exchangeAdapterDecorator(NotFoundRestClientAdapterDecorator::new)\n .build();\n\n\t// or for WebClient...\n\tHttpServiceProxyFactory proxyFactory = HttpServiceProxyFactory.builderFor(webClientAdapter)\n .exchangeAdapterDecorator(NotFoundWebClientAdapterDecorator::new)\n .build();\n----\n\n[[rest-http-service-client-group-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "Decorating the Adapter", "heading_level": 3, "file_order": 176, "section_index": 23, "content_hash": "035113346e215b54a21ee9b90544e89f53e71d49b660d6f68f25a96c4541cb95", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:e7994a9bd59c0f345f6bb2cfddb1e68d5348b52f42ea6c64d26432cce17da5c6", "content": "It's trivial to create client proxies with `HttpServiceProxyFactory`, but to have them\ndeclared as beans leads to repetitive configuration. You may also have multiple\ntarget hosts, and therefore multiple clients to configure, and even more client proxy\nbeans to create.\n\nTo make it easier to work with interface clients at scale the Spring Framework provides\ndedicated configuration support. It lets applications focus on identifying HTTP Services\nby group, and customizing the client for each group, while the framework transparently\ncreates a registry of client proxies, and declares each proxy as a bean.\n\nAn HTTP Service group is simply a set of interfaces that share the same client setup and\n`HttpServiceProxyFactory` instance to create proxies. Typically, that means one group per\nhost, but you can have more than one group for the same target host in case the\nunderlying client needs to be configured differently.\n\nOne way to declare HTTP Service groups is via `@ImportHttpServices` annotations in\n`@Configuration` classes as shown below:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ImportHttpServices(group = \"echo\", types = {EchoServiceA.class, EchoServiceB.class}) // <1>\n\t@ImportHttpServices(group = \"greeting\", basePackageClasses = GreetServiceA.class) // <2>\n\tpublic class ClientConfig {\n\t}\n\n----\n<1> Manually list interfaces for group \"echo\"\n<2> Detect interfaces for group \"greeting\" under a base package\n\nIt is also possible to declare groups programmatically by creating an HTTP Service\nregistrar and then importing it:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MyHttpServiceRegistrar extends AbstractHttpServiceRegistrar { // <1>\n\n @Override\n protected void registerHttpServices(GroupRegistry registry, AnnotationMetadata metadata) {\n registry.forGroup(\"echo\").register(EchoServiceA.class, EchoServiceB.class); // <2>\n registry.forGroup(\"greeting\").detectInBasePackages(GreetServiceA.class); // <3>\n }\n\t}\n\n\t@Configuration\n\t@Import(MyHttpServiceRegistrar.class) // <4>\n\tpublic class ClientConfig {\n\t}\n\n----\n<1> Create extension class of `AbstractHttpServiceRegistrar`\n<2> Manually list interfaces for group \"echo\"\n<3> Detect interfaces for group \"greeting\" under a base package\n<4> Import the registrar\n\nTIP: You can mix and match `@ImportHttpService` annotations with programmatic registrars,\nand you can spread the imports across multiple configuration classes. All imports\ncontribute collaboratively the same, shared `HttpServiceProxyRegistry` instance.\n\nOnce HTTP Service groups are declared, add an `HttpServiceGroupConfigurer` bean to\ncustomize the client for each group. For example:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ImportHttpServices(group = \"echo\", types = {EchoServiceA.class, EchoServiceB.class})\n\t@ImportHttpServices(group = \"greeting\", basePackageClasses = GreetServiceA.class)\n\tpublic class ClientConfig {\n\n @Bean\n public RestClientHttpServiceGroupConfigurer groupConfigurer() {\n return groups -> {\n // configure client for group \"echo\"\n groups.filterByName(\"echo\").forEachClient((group, clientBuilder) -> ...);\n\n // configure the clients for all groups\n groups.forEachClient((group, clientBuilder) -> ...);\n\n // configure client and proxy factory for each group\n groups.forEachGroup((group, clientBuilder, factoryBuilder) -> ...);\n };\n }\n\t}\n----\n\nTIP: Spring Boot uses an `HttpServiceGroupConfigurer` to add support for client properties\nby HTTP Service group, Spring Security to add OAuth support, and Spring Cloud to add load\nbalancing.\n\nAs a result of the above, each client proxy is available as a bean that you can\nconveniently autowire by type:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\tpublic class EchoController {\n\n private final EchoService echoService;\n\n public EchoController(EchoService echoService) {\n this.echoService = echoService;\n }\n\n // ...\n\t}\n----\n\nHowever, if there are multiple client proxies of the same type, e.g. the same interface\nin multiple groups, then there is no unique bean of that type, and you cannot autowire by\ntype only. For such cases, you can work directly with the `HttpServiceProxyRegistry` that\nholds all proxies, and obtain the ones you need by group:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\tpublic class EchoController {\n\n private final EchoService echoService1;\n\n private final EchoService echoService2;\n\n public EchoController(HttpServiceProxyRegistry registry) {\n this.echoService1 = registry.getClient(\"echo1\", EchoService.class); // <1>\n this.echoService2 = registry.getClient(\"echo2\", EchoService.class); // <2>\n }\n\n // ...\n\t}\n----\n<1> Access the `EchoService` client proxy for group \"echo1\"\n<2> Access the `EchoService` client proxy for group \"echo2\"", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/rest-clients.adoc", "title": "rest-clients", "heading": "HTTP Service Groups", "heading_level": 3, "file_order": 176, "section_index": 24, "content_hash": "e7994a9bd59c0f345f6bb2cfddb1e68d5348b52f42ea6c64d26432cce17da5c6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/rest-clients.adoc"}}
{"id": "sha256:5de0e6e4292e4ff0d3675ce90494a136f6c272b1721900fb604eb03c258838ee", "content": "[[scheduling]]\n\nThe Spring Framework provides abstractions for the asynchronous execution and scheduling of\ntasks with the `TaskExecutor` and `TaskScheduler` interfaces, respectively. Spring also\nfeatures implementations of those interfaces that support thread pools or delegation to\nCommonJ within an application server environment. Ultimately, the use of these\nimplementations behind the common interfaces abstracts away the differences between\nJava SE and Jakarta EE environments.\n\nSpring also features integration classes to support scheduling with the\nhttps://www.quartz-scheduler.org/[Quartz Scheduler].\n\n[[scheduling-task-executor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "scheduling", "heading_level": 1, "file_order": 177, "section_index": 0, "content_hash": "5de0e6e4292e4ff0d3675ce90494a136f6c272b1721900fb604eb03c258838ee", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:7c05293c5aa0250a57f6ddd710f4cee320083200713aa1e3dcb3badc22ccc61f", "content": "Executors are the JDK name for the concept of thread pools. The \"`executor`\" naming is\ndue to the fact that there is no guarantee that the underlying implementation is\nactually a pool. An executor may be single-threaded or even synchronous. Spring's\nabstraction hides implementation details between the Java SE and Jakarta EE environments.\n\nSpring's `TaskExecutor` interface is identical to the `java.util.concurrent.Executor`\ninterface. In fact, originally, its primary reason for existence was to abstract away\nthe need for Java 5 when using thread pools. The interface has a single method\n(`execute(Runnable task)`) that accepts a task for execution based on the semantics\nand configuration of the thread pool.\n\nThe `TaskExecutor` was originally created to give other Spring components an abstraction\nfor thread pooling where needed. Components such as the `ApplicationEventMulticaster`,\nJMS's `AbstractMessageListenerContainer`, and Quartz integration all use the\n`TaskExecutor` abstraction to pool threads. However, if your beans need thread pooling\nbehavior, you can also use this abstraction for your own needs.\n\n[[scheduling-task-executor-types]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "The Spring `TaskExecutor` Abstraction", "heading_level": 2, "file_order": 177, "section_index": 1, "content_hash": "7c05293c5aa0250a57f6ddd710f4cee320083200713aa1e3dcb3badc22ccc61f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:a996bf84040c11cfe3a0267d916159e6da72e9e566a350e6f0587b75dffb7002", "content": "Spring includes a number of pre-built implementations of `TaskExecutor`.\nIn all likelihood, you should never need to implement your own.\nThe variants that Spring provides are as follows:\n\n* `SyncTaskExecutor`:\n This implementation does not run invocations asynchronously. Instead, each\n invocation takes place in the calling thread. It is primarily used in situations\n where multi-threading is not necessary, such as in simple test cases.\n* `SimpleAsyncTaskExecutor`:\n This implementation does not reuse any threads. Rather, it starts up a new thread\n for each invocation. However, it does support a concurrency limit that blocks\n any invocations that are over the limit until a slot has been freed up. If you\n are looking for true pooling, see `ThreadPoolTaskExecutor`, later in this list.\n This will use JDK 21's Virtual Threads, when the \"virtualThreads\"\n option is enabled. This implementation also supports graceful shutdown through\n Spring's lifecycle management.\n* `ConcurrentTaskExecutor`:\n This implementation is an adapter for a `java.util.concurrent.Executor` instance.\n There is an alternative (`ThreadPoolTaskExecutor`) that exposes the `Executor`\n configuration parameters as bean properties. There is rarely a need to use\n `ConcurrentTaskExecutor` directly. However, if the `ThreadPoolTaskExecutor` is not\n flexible enough for your needs, `ConcurrentTaskExecutor` is an alternative.\n* `ThreadPoolTaskExecutor`:\n This implementation is most commonly used. It exposes bean properties for configuring\n a `java.util.concurrent.ThreadPoolExecutor` and wraps it in a `TaskExecutor`.\n If you need to adapt to a different kind of `java.util.concurrent.Executor`,\n we recommend that you use a `ConcurrentTaskExecutor` instead.\n It also provides a pause/resume capability and graceful shutdown through\n Spring's lifecycle management.\n* `DefaultManagedTaskExecutor`:\n This implementation uses a JNDI-obtained `ManagedExecutorService` in a JSR-236\n compatible runtime environment (such as a Jakarta EE application server),\n replacing a CommonJ WorkManager for that purpose.\n\n[[scheduling-task-executor-usage]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "`TaskExecutor` Types", "heading_level": 3, "file_order": 177, "section_index": 2, "content_hash": "a996bf84040c11cfe3a0267d916159e6da72e9e566a350e6f0587b75dffb7002", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:0b48477d7f1dc543cf96e4d06188c71a2ccc4ef8b688797df312a9d84e2e4318", "content": "Spring's `TaskExecutor` implementations are commonly used with dependency injection.\nIn the following example, we define a bean that uses the `ThreadPoolTaskExecutor`\nto asynchronously print out a set of messages:\n\ninclude-code::./TaskExecutorExample[tag=snippet,indent=0]\n\nAs you can see, rather than retrieving a thread from the pool and executing it yourself,\nyou add your `Runnable` to the queue. Then the `TaskExecutor` uses its internal rules to\ndecide when the task gets run.\n\nTo configure the rules that the `TaskExecutor` uses, we expose simple bean properties:\n\ninclude-code::./TaskExecutorConfiguration[tag=snippet,indent=0]\n\nMost `TaskExecutor` implementations provide a way to automatically wrap tasks submitted\nwith a `TaskDecorator`. Decorators should delegate to the task it is wrapping, possibly\nimplementing custom behavior before/after the execution of the task.\n\nLet's consider a simple implementation that will log messages before and after the execution\nor our tasks:\n\ninclude-code::./LoggingTaskDecorator[indent=0]\n\nWe can then configure our decorator on a `TaskExecutor` instance:\n\ninclude-code::./TaskExecutorConfiguration[tag=decorator,indent=0]\n\nIn case multiple decorators are needed, the `org.springframework.core.task.support.CompositeTaskDecorator`\ncan be used to execute sequentially multiple decorators.\n\n[[scheduling-task-scheduler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "Using a `TaskExecutor`", "heading_level": 3, "file_order": 177, "section_index": 3, "content_hash": "0b48477d7f1dc543cf96e4d06188c71a2ccc4ef8b688797df312a9d84e2e4318", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:077a1a402380f46fde2318809423b86bc552c6dbb1a4b6e9896aecfdbe2787af", "content": "In addition to the `TaskExecutor` abstraction, Spring has a `TaskScheduler` SPI with a\nvariety of methods for scheduling tasks to run at some point in the future. The following\nlisting shows the `TaskScheduler` interface definition:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface TaskScheduler {\n\n Clock getClock();\n\n ScheduledFuture schedule(Runnable task, Trigger trigger);\n\n ScheduledFuture schedule(Runnable task, Instant startTime);\n\n ScheduledFuture scheduleAtFixedRate(Runnable task, Instant startTime, Duration period);\n\n ScheduledFuture scheduleAtFixedRate(Runnable task, Duration period);\n\n ScheduledFuture scheduleWithFixedDelay(Runnable task, Instant startTime, Duration delay);\n\n ScheduledFuture scheduleWithFixedDelay(Runnable task, Duration delay);\n\n----\n\nThe simplest method is the one named `schedule` that takes only a `Runnable` and an `Instant`.\nThat causes the task to run once after the specified time. All of the other methods\nare capable of scheduling tasks to run repeatedly. The fixed-rate and fixed-delay\nmethods are for simple, periodic execution, but the method that accepts a `Trigger` is\nmuch more flexible.\n\n[[scheduling-trigger-interface]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "The Spring `TaskScheduler` Abstraction", "heading_level": 2, "file_order": 177, "section_index": 4, "content_hash": "077a1a402380f46fde2318809423b86bc552c6dbb1a4b6e9896aecfdbe2787af", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:5e4620d7c3cdad896763503d5cf26776efca744c47d8e978a0c0371b05833981", "content": "The `Trigger` interface is essentially inspired by JSR-236. The basic idea of the\n`Trigger` is that execution times may be determined based on past execution outcomes or\neven arbitrary conditions. If these determinations take into account the outcome of the\npreceding execution, that information is available within a `TriggerContext`. The\n`Trigger` interface itself is quite simple, as the following listing shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface Trigger {\n\n Instant nextExecution(TriggerContext triggerContext);\n\t}\n----\n\nThe `TriggerContext` is the most important part. It encapsulates all of\nthe relevant data and is open for extension in the future, if necessary. The\n`TriggerContext` is an interface (a `SimpleTriggerContext` implementation is used by\ndefault). The following listing shows the available methods for `Trigger` implementations.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface TriggerContext {\n\n Clock getClock();\n\n Instant lastScheduledExecution();\n\n Instant lastActualExecution();\n\n Instant lastCompletion();\n\t}\n----\n\n[[scheduling-trigger-implementations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "`Trigger` Interface", "heading_level": 3, "file_order": 177, "section_index": 5, "content_hash": "5e4620d7c3cdad896763503d5cf26776efca744c47d8e978a0c0371b05833981", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:8db04f2d5bdcb524945e19664fd5c9af0968197e87bb092bcbb8d25f6c19ecfb", "content": "Spring provides two implementations of the `Trigger` interface. The most interesting one\nis the `CronTrigger`. It enables the scheduling of tasks based on\nxref:integration/scheduling.adoc#scheduling-cron-expression[cron expressions].\nFor example, the following task is scheduled to run 15 minutes past each hour but only\nduring the 9-to-5 \"business hours\" on weekdays:\n\n[source,java,indent=0]\n[subs=\"verbatim\"]\n----\n\tscheduler.schedule(task, new CronTrigger(\"0 15 9-17 * * MON-FRI\"));\n----\n\nThe other implementation is a `PeriodicTrigger` that accepts a fixed\nperiod, an optional initial delay value, and a boolean to indicate whether the period\nshould be interpreted as a fixed-rate or a fixed-delay. Since the `TaskScheduler`\ninterface already defines methods for scheduling tasks at a fixed rate or with a\nfixed delay, those methods should be used directly whenever possible. The value of the\n`PeriodicTrigger` implementation is that you can use it within components that rely on\nthe `Trigger` abstraction. For example, it may be convenient to allow periodic triggers,\ncron-based triggers, and even custom trigger implementations to be used interchangeably.\nSuch a component could take advantage of dependency injection so that you can configure\nsuch `Triggers` externally and, therefore, easily modify or extend them.\n\n[[scheduling-task-scheduler-implementations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "`Trigger` Implementations", "heading_level": 3, "file_order": 177, "section_index": 6, "content_hash": "8db04f2d5bdcb524945e19664fd5c9af0968197e87bb092bcbb8d25f6c19ecfb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:bad8c3d7119893690e8677565e4e1f555276bb5c6e950aa6488b5b60ef2b8e6a", "content": "As with Spring's `TaskExecutor` abstraction, the primary benefit of the `TaskScheduler`\narrangement is that an application's scheduling needs are decoupled from the deployment\nenvironment. This abstraction level is particularly relevant when deploying to an\napplication server environment where threads should not be created directly by the\napplication itself. For such scenarios, Spring provides a `DefaultManagedTaskScheduler`\nthat delegates to a JSR-236 `ManagedScheduledExecutorService` in a Jakarta EE environment.\n\nWhenever external thread management is not a requirement, a simpler alternative is\na local `ScheduledExecutorService` setup within the application, which can be adapted\nthrough Spring's `ConcurrentTaskScheduler`. As a convenience, Spring also provides a\n`ThreadPoolTaskScheduler`, which internally delegates to a `ScheduledExecutorService`\nto provide common bean-style configuration along the lines of `ThreadPoolTaskExecutor`.\nThese variants work perfectly fine for locally embedded thread pool setups in lenient\napplication server environments, as well -- in particular on Tomcat and Jetty.\n\nAs of 6.1, `ThreadPoolTaskScheduler` provides a pause/resume capability and graceful\nshutdown through Spring's lifecycle management. There is also a new option called\n`SimpleAsyncTaskScheduler` which is aligned with JDK 21's Virtual Threads, using a\nsingle scheduler thread but firing up a new thread for every scheduled task execution\n(except for fixed-delay tasks which all operate on a single scheduler thread, so for\nthis virtual-thread-aligned option, fixed rates and cron triggers are recommended).\n\n[[scheduling-annotation-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "`TaskScheduler` implementations", "heading_level": 3, "file_order": 177, "section_index": 7, "content_hash": "bad8c3d7119893690e8677565e4e1f555276bb5c6e950aa6488b5b60ef2b8e6a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:0876d8406bc287cbefab6955e849371adf4709df0b82b07dc212f343603d751a", "content": "Spring provides annotation support for both task scheduling and asynchronous method\nexecution.\n\n[[scheduling-enable-annotation-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "Annotation Support for Scheduling and Asynchronous Execution", "heading_level": 2, "file_order": 177, "section_index": 8, "content_hash": "0876d8406bc287cbefab6955e849371adf4709df0b82b07dc212f343603d751a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:7125f78d21a0e4928e43be91105862d8303d40acba2aa0a25adb857dc59b6a82", "content": "To enable support for `@Scheduled` and `@Async` annotations, you can add `@EnableScheduling`\nand `@EnableAsync` to one of your `@Configuration` classes, or `<task:annotation-driven>` element,\nas the following example shows:\n\ninclude-code::./SchedulingConfiguration[tag=snippet,indent=0]\n\nYou can pick and choose the relevant annotations for your application. For example,\nif you need only support for `@Scheduled`, you can omit `@EnableAsync`. For more\nfine-grained control, you can additionally implement the `SchedulingConfigurer`\ninterface, the `AsyncConfigurer` interface, or both. See the\n{spring-framework-api}/scheduling/annotation/SchedulingConfigurer.html[`SchedulingConfigurer`]\nand {spring-framework-api}/scheduling/annotation/AsyncConfigurer.html[`AsyncConfigurer`]\njavadoc for full details.\n\nNote that, with the preceding XML, an executor reference is provided for handling those\ntasks that correspond to methods with the `@Async` annotation, and the scheduler\nreference is provided for managing those methods annotated with `@Scheduled`.\n\nNOTE: The default advice mode for processing `@Async` annotations is `proxy` which allows\nfor interception of calls through the proxy only. Local calls within the same class\ncannot get intercepted that way. For a more advanced mode of interception, consider\nswitching to `aspectj` mode in combination with compile-time or load-time weaving.\n\n[[scheduling-annotation-support-scheduled]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "Enable Scheduling Annotations", "heading_level": 3, "file_order": 177, "section_index": 9, "content_hash": "7125f78d21a0e4928e43be91105862d8303d40acba2aa0a25adb857dc59b6a82", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:597caa32ddfef32a4666298ead833e3fd79e70117472c002ec9d4825a41aae10", "content": "You can add the `@Scheduled` annotation to a method, along with trigger metadata. For\nexample, the following method is invoked every five seconds (5000 milliseconds) with a\nfixed delay, meaning that the period is measured from the completion time of each\npreceding invocation.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scheduled(fixedDelay = 5000)\n\tpublic void doSomething() {\n // something that should run periodically\n\t}\n----\n\n[NOTE]\n====\nBy default, milliseconds will be used as the time unit for fixed delay, fixed rate, and\ninitial delay values. If you would like to use a different time unit such as seconds or\nminutes, you can configure this via the `timeUnit` attribute in `@Scheduled`.\n\nFor example, the previous example can also be written as follows.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scheduled(fixedDelay = 5, timeUnit = TimeUnit.SECONDS)\n\tpublic void doSomething() {\n // something that should run periodically\n\t}\n----\n====\n\nIf you need a fixed-rate execution, you can use the `fixedRate` attribute within the\nannotation. The following method is invoked every five seconds (measured between the\nsuccessive start times of each invocation):\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scheduled(fixedRate = 5, timeUnit = TimeUnit.SECONDS)\n\tpublic void doSomething() {\n // something that should run periodically\n\t}\n----\n\nFor fixed-delay and fixed-rate tasks, you can specify an initial delay by indicating\nthe amount of time to wait before the first execution of the method, as the following\n`fixedRate` example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scheduled(initialDelay = 1000, fixedRate = 5000)\n\tpublic void doSomething() {\n // something that should run periodically\n\t}\n----\n\nFor one-time tasks, you can just specify an initial delay by indicating the amount\nof time to wait before the intended execution of the method:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scheduled(initialDelay = 1000)\n\tpublic void doSomething() {\n // something that should run only once\n\t}\n----\n\nIf simple periodic scheduling is not expressive enough, you can provide a\nxref:integration/scheduling.adoc#scheduling-cron-expression[cron expression].\nThe following example runs only on weekdays:\n\n[source,java,indent=0]\n[subs=\"verbatim\"]\n----\n\t@Scheduled(cron=\"*/5 * * * * MON-FRI\")\n\tpublic void doSomething() {\n // something that should run on weekdays only\n\t}\n----\n\nTIP: You can also use the `zone` attribute to specify the time zone in which the cron\nexpression is resolved.\n\nNotice that the methods to be scheduled must have void returns and must not accept any\narguments. If the method needs to interact with other objects from the application\ncontext, those would typically have been provided through dependency injection.\n\n`@Scheduled` can be used as a repeatable annotation. If several scheduled declarations\nare found on the same method, each of them will be processed independently, with a\nseparate trigger firing for each of them. As a consequence, such co-located schedules\nmay overlap and execute multiple times in parallel or in immediate succession.\nPlease make sure that your specified cron expressions etc do not accidentally overlap.\n\n[NOTE]\n====\nAs of Spring Framework 4.3, `@Scheduled` methods are supported on beans of any scope.\n\nMake sure that you are not initializing multiple instances of the same `@Scheduled`\nannotation class at runtime, unless you do want to schedule callbacks to each such\ninstance. Related to this, make sure that you do not use `@Configurable` on bean\nclasses that are annotated with `@Scheduled` and registered as regular Spring beans\nwith the container. Otherwise, you would get double initialization (once through the\ncontainer and once through the `@Configurable` aspect), with the consequence of each\n`@Scheduled` method being invoked twice.\n====\n\n[[scheduling-annotation-support-scheduled-reactive]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "The `@Scheduled` annotation", "heading_level": 3, "file_order": 177, "section_index": 10, "content_hash": "597caa32ddfef32a4666298ead833e3fd79e70117472c002ec9d4825a41aae10", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:0dd1e4e4c8e243b80245d36e6cd1e34c2a2219a02c21d963e8f175378cf43c15", "content": "As of Spring Framework 6.1, `@Scheduled` methods are also supported on several types\nof reactive methods:\n\n - methods with a `Publisher` return type (or any concrete implementation of `Publisher`)\nlike in the following example:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scheduled(fixedDelay = 500)\n\tpublic Publisher<Void> reactiveSomething() {\n // return an instance of Publisher\n\t}\n----\n\n - methods with a return type that can be adapted to `Publisher` via the shared instance\nof the `ReactiveAdapterRegistry`, provided the type supports _deferred subscription_ like\nin the following example:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scheduled(fixedDelay = 500)\n\tpublic Single<String> rxjavaNonPublisher() {\n return Single.just(\"example\");\n\t}\n----\n\n[NOTE]\n====\nThe `CompletableFuture` class is an example of a type that can typically be adapted\nto `Publisher` but doesn't support deferred subscription. Its `ReactiveAdapter` in the\nregistry denotes that by having the `getDescriptor().isDeferred()` method return `false`.\n====\n\n - Kotlin suspending functions, like in the following example:\n\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scheduled(fixedDelay = 500)\n\tsuspend fun something() {\n // do something asynchronous\n\t}\n----\n\n - methods that return a Kotlin `Flow` or `Deferred` instance, like in the following example:\n\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scheduled(fixedDelay = 500)\n\tfun something(): Flow<Void> {\n flow {\n // do something asynchronous\n }\n\t}\n----\n\nAll these types of methods must be declared without any arguments. In the case of Kotlin\nsuspending functions, the `kotlinx.coroutines.reactor` bridge must also be present to allow\nthe framework to invoke a suspending function as a `Publisher`.\n\nThe Spring Framework will obtain a `Publisher` for the annotated method once and will\nschedule a `Runnable` in which it subscribes to said `Publisher`. These inner regular\nsubscriptions occur according to the corresponding `cron`/`fixedDelay`/`fixedRate` configuration.\n\nIf the `Publisher` emits `onNext` signal(s), these are ignored and discarded (the same way\nreturn values from synchronous `@Scheduled` methods are ignored).\n\nIn the following example, the `Flux` emits `onNext(\"Hello\")`, `onNext(\"World\")` every 5\nseconds, but these values are unused:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scheduled(initialDelay = 5000, fixedRate = 5000)\n\tpublic Flux<String> reactiveSomething() {\n return Flux.just(\"Hello\", \"World\");\n\t}\n----\n\nIf the `Publisher` emits an `onError` signal, it is logged at `WARN` level and recovered.\nBecause of the asynchronous and lazy nature of `Publisher` instances, exceptions are\nnot thrown from the `Runnable` task: this means that the `ErrorHandler` contract is not\ninvolved for reactive methods.\n\nAs a result, further scheduled subscription occurs despite the error.\n\nIn the following example, the `Mono` subscription fails twice in the first five seconds.\nThen subscriptions start succeeding, printing a message to the standard output every five\nseconds:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Scheduled(initialDelay = 0, fixedRate = 5000)\n\tpublic Mono<Void> reactiveSomething() {\n AtomicInteger countdown = new AtomicInteger(2);\n\n return Mono.defer(() -> {\n if (countDown.get() == 0 || countDown.decrementAndGet() == 0) {\n return Mono.fromRunnable(() -> System.out.println(\"Message\"));\n }\n return Mono.error(new IllegalStateException(\"Cannot deliver message\"));\n })\n\t}\n----\n\n[NOTE]\n====\nWhen destroying the annotated bean or closing the application context, Spring Framework cancels\nscheduled tasks, which includes the next scheduled subscription to the `Publisher` as well\nas any past subscription that is still currently active (for example, for long-running publishers\nor even infinite publishers).\n====\n\n[[scheduling-annotation-support-async]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "The `@Scheduled` annotation on Reactive methods or Kotlin suspending functions", "heading_level": 3, "file_order": 177, "section_index": 11, "content_hash": "0dd1e4e4c8e243b80245d36e6cd1e34c2a2219a02c21d963e8f175378cf43c15", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:98630e5264e63b22c745f6e6e17ef055df88da5d5d629df4300f205e46d69ad4", "content": "You can provide the `@Async` annotation on a method so that invocation of that method\noccurs asynchronously. In other words, the caller returns immediately upon\ninvocation, while the actual execution of the method occurs in a task that has been\nsubmitted to a Spring `TaskExecutor`. In the simplest case, you can apply the annotation\nto a method that returns `void`, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Async\n\tvoid doSomething() {\n // this will be run asynchronously\n\t}\n----\n\nUnlike the methods annotated with the `@Scheduled` annotation, these methods can expect\narguments, because they are invoked in the \"`normal`\" way by callers at runtime rather\nthan from a scheduled task being managed by the container. For example, the following\ncode is a legitimate application of the `@Async` annotation:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Async\n\tvoid doSomething(String s) {\n // this will be run asynchronously\n\t}\n----\n\nEven methods that return a value can be invoked asynchronously. However, such methods\nare required to have a `Future`-typed return value. This still provides the benefit of\nasynchronous execution so that the caller can perform other tasks prior to calling\n`get()` on that `Future`. The following example shows how to use `@Async` on a method\nthat returns a value:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Async\n\tFuture<String> returnSomething(int i) {\n // this will be run asynchronously\n\t}\n----\n\nTIP: `@Async` methods may not only declare a regular `java.util.concurrent.Future` return\ntype but also `java.util.concurrent.CompletableFuture`, for richer interaction with\nthe asynchronous task and for immediate composition with further processing steps.\n\nYou can not use `@Async` in conjunction with lifecycle callbacks such as `@PostConstruct`.\nTo asynchronously initialize Spring beans, you currently have to use a separate\ninitializing Spring bean that then invokes the `@Async` annotated method on the target,\nas the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SampleBeanImpl implements SampleBean {\n\n @Async\n void doSomething() {\n // ...\n }\n\n\t}\n\n\tpublic class SampleBeanInitializer {\n\n private final SampleBean bean;\n\n public SampleBeanInitializer(SampleBean bean) {\n this.bean = bean;\n }\n\n @PostConstruct\n public void initialize() {\n bean.doSomething();\n }\n\n\t}\n----\n\nNOTE: There is no direct XML equivalent for `@Async`, since such methods should be designed\nfor asynchronous execution in the first place, not externally re-declared to be asynchronous.\nHowever, you can manually set up Spring's `AsyncExecutionInterceptor` with Spring AOP,\nin combination with a custom pointcut.\n\n[[scheduling-annotation-support-qualification]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "The `@Async` annotation", "heading_level": 3, "file_order": 177, "section_index": 12, "content_hash": "98630e5264e63b22c745f6e6e17ef055df88da5d5d629df4300f205e46d69ad4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:917c1a26c7b5b919014fce5f80e4bac7095a4a1ccea12e4c2b4ad8c8c40403d7", "content": "By default, when specifying `@Async` on a method, the executor that is used is the\none xref:integration/scheduling.adoc#scheduling-enable-annotation-support[configured when enabling async support],\ni.e. the \"`annotation-driven`\" element if you are using XML or your `AsyncConfigurer`\nimplementation, if any. However, you can use the `value` attribute of the `@Async`\nannotation when you need to indicate that an executor other than the default should be\nused when executing a given method. The following example shows how to do so:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Async(\"otherExecutor\")\n\tvoid doSomething(String s) {\n // this will be run asynchronously by \"otherExecutor\"\n\t}\n----\n\nIn this case, `\"otherExecutor\"` can be the name of any `Executor` bean in the Spring\ncontainer, or it may be the name of a qualifier associated with any `Executor` (for example,\nas specified with the `<qualifier>` element or Spring's `@Qualifier` annotation).\n\n[[scheduling-annotation-support-exception]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "Executor Qualification with `@Async`", "heading_level": 3, "file_order": 177, "section_index": 13, "content_hash": "917c1a26c7b5b919014fce5f80e4bac7095a4a1ccea12e4c2b4ad8c8c40403d7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:b488e7168d96e17ef38c6df0e744919723562e6b7b7da7af4953a02a6b24f6d8", "content": "When an `@Async` method has a `Future`-typed return value, it is easy to manage\nan exception that was thrown during the method execution, as this exception is\nthrown when calling `get` on the `Future` result. With a `void` return type,\nhowever, the exception is uncaught and cannot be transmitted. You can provide an\n`AsyncUncaughtExceptionHandler` to handle such exceptions. The following example shows\nhow to do so:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler {\n\n @Override\n public void handleUncaughtException(Throwable ex, Method method, Object... params) {\n // handle exception\n }\n\t}\n----\n\nBy default, the exception is merely logged. You can define a custom `AsyncUncaughtExceptionHandler`\nby using `AsyncConfigurer` or the `<task:annotation-driven/>` XML element.\n\n[[scheduling-task-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "Exception Management with `@Async`", "heading_level": 3, "file_order": 177, "section_index": 14, "content_hash": "b488e7168d96e17ef38c6df0e744919723562e6b7b7da7af4953a02a6b24f6d8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:d91d7d7d3f2b0577d8e7ff0337e900e54ec77fa45593019f686b3bf504f4e3ed", "content": "As of version 3.0, Spring includes an XML namespace for configuring `TaskExecutor` and\n`TaskScheduler` instances. It also provides a convenient way to configure tasks to be\nscheduled with a trigger.\n\n[[scheduling-task-namespace-scheduler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "The `task` Namespace", "heading_level": 2, "file_order": 177, "section_index": 15, "content_hash": "d91d7d7d3f2b0577d8e7ff0337e900e54ec77fa45593019f686b3bf504f4e3ed", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:0a331dd74e62611909649d2492d70488343ff15bc09e76d9d2676b7f9870e143", "content": "The following element creates a `ThreadPoolTaskScheduler` instance with the\nspecified thread pool size:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<task:scheduler id=\"scheduler\" pool-size=\"10\"/>\n----\n\nThe value provided for the `id` attribute is used as the prefix for thread names\nwithin the pool. The `scheduler` element is relatively straightforward. If you do not\nprovide a `pool-size` attribute, the default thread pool has only a single thread.\nThere are no other configuration options for the scheduler.\n\n[[scheduling-task-namespace-executor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "The `scheduler` Element", "heading_level": 3, "file_order": 177, "section_index": 16, "content_hash": "0a331dd74e62611909649d2492d70488343ff15bc09e76d9d2676b7f9870e143", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:c7d25a3cd8b5852b8a40a99e07950d1f16984ef219ed772769903495a0a63360", "content": "The following creates a `ThreadPoolTaskExecutor` instance:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<task:executor id=\"executor\" pool-size=\"10\"/>\n----\n\nAs with the scheduler shown in the xref:integration/scheduling.adoc#scheduling-task-namespace-scheduler[previous section],\nthe value provided for the `id` attribute is used as the prefix for thread names within\nthe pool. As far as the pool size is concerned, the `executor` element supports more\nconfiguration options than the `scheduler` element. For one thing, the thread pool for\na `ThreadPoolTaskExecutor` is itself more configurable. Rather than only a single size,\nan executor's thread pool can have different values for the core and the max size.\nIf you provide a single value, the executor has a fixed-size thread pool (the core and\nmax sizes are the same). However, the `executor` element's `pool-size` attribute also\naccepts a range in the form of `min-max`. The following example sets a minimum value of\n`5` and a maximum value of `25`:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<task:executor\n id=\"executorWithPoolSizeRange\"\n pool-size=\"5-25\"\n queue-capacity=\"100\"/>\n----\n\nIn the preceding configuration, a `queue-capacity` value has also been provided.\nThe configuration of the thread pool should also be considered in light of the\nexecutor's queue capacity. For the full description of the relationship between pool\nsize and queue capacity, see the documentation for\n{java-api}/java.base/java/util/concurrent/ThreadPoolExecutor.html[`ThreadPoolExecutor`].\nThe main idea is that, when a task is submitted, the executor first tries to use a\nfree thread if the number of active threads is currently less than the core size.\nIf the core size has been reached, the task is added to the queue, as long as its\ncapacity has not yet been reached. Only then, if the queue's capacity has been\nreached, does the executor create a new thread beyond the core size. If the max size\nhas also been reached, then the executor rejects the task.\n\nBy default, the queue is unbounded, but this is rarely the desired configuration,\nbecause it can lead to `OutOfMemoryError` if enough tasks are added to that queue while\nall pool threads are busy. Furthermore, if the queue is unbounded, the max size has\nno effect at all. Since the executor always tries the queue before creating a new\nthread beyond the core size, a queue must have a finite capacity for the thread pool to\ngrow beyond the core size (this is why a fixed-size pool is the only sensible case\nwhen using an unbounded queue).\n\nConsider the case, as mentioned above, when a task is rejected. By default, when a\ntask is rejected, a thread pool executor throws a `TaskRejectedException`. However,\nthe rejection policy is actually configurable. The exception is thrown when using\nthe default rejection policy, which is the `AbortPolicy` implementation.\nFor applications where some tasks can be skipped under heavy load, you can instead\nconfigure either `DiscardPolicy` or `DiscardOldestPolicy`. Another option that works\nwell for applications that need to throttle the submitted tasks under heavy load is\nthe `CallerRunsPolicy`. Instead of throwing an exception or discarding tasks,\nthat policy forces the thread that is calling the submit method to run the task itself.\nThe idea is that such a caller is busy while running that task and not able to submit\nother tasks immediately. Therefore, it provides a simple way to throttle the incoming\nload while maintaining the limits of the thread pool and queue. Typically, this allows\nthe executor to \"`catch up`\" on the tasks it is handling and thereby frees up some\ncapacity on the queue, in the pool, or both. You can choose any of these options from an\nenumeration of values available for the `rejection-policy` attribute on the `executor`\nelement.\n\nThe following example shows an `executor` element with a number of attributes to specify\nvarious behaviors:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<task:executor\n id=\"executorWithCallerRunsPolicy\"\n pool-size=\"5-25\"\n queue-capacity=\"100\"\n rejection-policy=\"CALLER_RUNS\"/>\n----\n\nFinally, the `keep-alive` setting determines the time limit (in seconds) for which threads\nmay remain idle before being stopped. If there are more than the core number of threads\ncurrently in the pool, after waiting this amount of time without processing a task, excess\nthreads get stopped. A time value of zero causes excess threads to stop\nimmediately after executing a task without remaining follow-up work in the task queue.\nThe following example sets the `keep-alive` value to two minutes:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<task:executor\n id=\"executorWithKeepAlive\"\n pool-size=\"5-25\"\n keep-alive=\"120\"/>\n----\n\n[[scheduling-task-namespace-scheduled-tasks]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "The `executor` Element", "heading_level": 3, "file_order": 177, "section_index": 17, "content_hash": "c7d25a3cd8b5852b8a40a99e07950d1f16984ef219ed772769903495a0a63360", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:3f46c10d4c7b77b3b1f92844eb35dbd5eab28d98c82a23c1c0fabc531cb79ed9", "content": "The most powerful feature of Spring's task namespace is the support for configuring\ntasks to be scheduled within a Spring Application Context. This follows an approach\nsimilar to other \"`method-invokers`\" in Spring, such as that provided by the JMS namespace\nfor configuring message-driven POJOs. Basically, a `ref` attribute can point to any\nSpring-managed object, and the `method` attribute provides the name of a method to be\ninvoked on that object. The following listing shows a simple example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<task:scheduled-tasks scheduler=\"myScheduler\">\n <task:scheduled ref=\"beanA\" method=\"methodA\" fixed-delay=\"5000\"/>\n\t</task:scheduled-tasks>\n\n\t<task:scheduler id=\"myScheduler\" pool-size=\"10\"/>\n----\n\nThe scheduler is referenced by the outer element, and each individual\ntask includes the configuration of its trigger metadata. In the preceding example,\nthat metadata defines a periodic trigger with a fixed delay indicating the number of\nmilliseconds to wait after each task execution has completed. Another option is\n`fixed-rate`, indicating how often the method should be run regardless of how long\nany previous execution takes. Additionally, for both `fixed-delay` and `fixed-rate`\ntasks, you can specify an 'initial-delay' parameter, indicating the number of\nmilliseconds to wait before the first execution of the method. For more control,\nyou can instead provide a `cron` attribute to provide a\nxref:integration/scheduling.adoc#scheduling-cron-expression[cron expression].\nThe following example shows these other options:\n\n[source,xml,indent=0]\n[subs=\"verbatim\"]\n----\n\t<task:scheduled-tasks scheduler=\"myScheduler\">\n <task:scheduled ref=\"beanA\" method=\"methodA\" fixed-delay=\"5000\" initial-delay=\"1000\"/>\n <task:scheduled ref=\"beanB\" method=\"methodB\" fixed-rate=\"5000\"/>\n <task:scheduled ref=\"beanC\" method=\"methodC\" cron=\"*/5 * * * * MON-FRI\"/>\n\t</task:scheduled-tasks>\n\n\t<task:scheduler id=\"myScheduler\" pool-size=\"10\"/>\n----\n\n[[scheduling-cron-expression]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "The `scheduled-tasks` Element", "heading_level": 3, "file_order": 177, "section_index": 18, "content_hash": "3f46c10d4c7b77b3b1f92844eb35dbd5eab28d98c82a23c1c0fabc531cb79ed9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:f4458daa4e8dabf573f7ef865e210441d06092417a22625728d9766bc17d7cff", "content": "All Spring cron expressions have to conform to the same format, whether you are using them in\nxref:integration/scheduling.adoc#scheduling-annotation-support-scheduled[`@Scheduled` annotations],\nxref:integration/scheduling.adoc#scheduling-task-namespace-scheduled-tasks[`task:scheduled-tasks` elements],\nor someplace else. A well-formed cron expression, such as `* * * * * *`, consists of six\nspace-separated time and date fields, each with its own range of valid values:\n\n....\n â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ second (0-59)\n â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ minute (0 - 59)\n â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ hour (0 - 23)\n â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ day of the month (1 - 31)\n â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ month (1 - 12) (or JAN-DEC)\n â”‚ â”‚ â”‚ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ day of the week (0 - 7)\n â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ (0 or 7 is Sunday, or MON-SUN)\n â”‚ â”‚ â”‚ â”‚ â”‚ â”‚\n * * * * * *\n....\n\nThere are some rules that apply:\n\n* A field may be an asterisk (`*`), which always stands for \"`first-last`\".\nFor the day-of-the-month or day-of-the-week fields, a question mark (`?`) may be used instead of an\nasterisk.\n* Commas (`,`) are used to separate items of a list.\n* Two numbers separated with a hyphen (`-`) express a range of numbers.\nThe specified range is inclusive.\n* Following a range (or `*`) with `/` specifies the interval of the number's value through the range.\n* English names can also be used for the month and day-of-week fields.\nUse the first three letters of the particular day or month (case does not matter).\n* The day-of-month and day-of-week fields can contain an `L` character, which has a different meaning.\n** In the day-of-month field, `L` stands for _the last day of the month_.\nIf followed by a negative offset (that is, `L-n`), it means _``n``th-to-last day of the month_.\n** In the day-of-week field, `L` stands for _the last day of the week_.\nIf prefixed by a number or three-letter name (`dL` or `DDDL`), it means _the last day of week (`d`\nor `DDD`) in the month_.\n* The day-of-month field can be `nW`, which stands for _the nearest weekday to day of the month ``n``_.\nIf `n` falls on Saturday, this yields the Friday before it.\nIf `n` falls on Sunday, this yields the Monday after, which also happens if `n` is `1` and falls on\na Saturday (that is: `1W` stands for _the first weekday of the month_).\n* If the day-of-month field is `LW`, it means _the last weekday of the month_.\n* The day-of-week field can be `d#n` (or `DDD#n`), which stands for _the ``n``th day of week `d`\n(or ``DDD``) in the month_.\n\nHere are some examples:\n\n|===\n| Cron Expression | Meaning\n\n|`0 0 * * * *` | top of every hour of every day\n|`*/10 * * * * *` | every ten seconds\n| `0 0 8-10 * * *` | 8, 9 and 10 o'clock of every day\n| `0 0 6,19 * * *` | 6:00 AM and 7:00 PM every day\n| `0 0/30 8-10 * * *` | 8:00, 8:30, 9:00, 9:30, 10:00 and 10:30 every day\n| `0 0 9-17 * * MON-FRI`| on the hour nine-to-five weekdays\n| `0 0 0 25 DEC ?` | every Christmas Day at midnight\n| `0 0 0 L * *` | last day of the month at midnight\n| `0 0 0 L-3 * *` | third-to-last day of the month at midnight\n| `0 0 0 * * 5L` | last Friday of the month at midnight\n| `0 0 0 * * THUL` | last Thursday of the month at midnight\n| `0 0 0 1W * *` | first weekday of the month at midnight\n| `0 0 0 LW * *` | last weekday of the month at midnight\n| `0 0 0 ? * 5#2` | the second Friday in the month at midnight\n| `0 0 0 ? * MON#1` | the first Monday in the month at midnight\n|===\n\n[[macros]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "Cron Expressions", "heading_level": 2, "file_order": 177, "section_index": 19, "content_hash": "f4458daa4e8dabf573f7ef865e210441d06092417a22625728d9766bc17d7cff", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:38aa2223745e92e1210ff20968d28bd03c9d81b32f4eb3539ad9ae15f0bcf8c0", "content": "Expressions such as `0 0 * * * *` are hard for humans to parse and are, therefore,\nhard to fix in case of bugs. To improve readability, Spring supports the following\nmacros, which represent commonly used sequences. You can use these macros instead\nof the six-digit value, thus: `@Scheduled(cron = \"@hourly\")`.\n\n|===\n|Macro | Meaning\n\n| `@yearly` (or `@annually`) | once a year (`0 0 0 1 1 *`)\n| `@monthly` | once a month (`0 0 0 1 * *`)\n| `@weekly` | once a week (`0 0 0 * * 0`)\n| `@daily` (or `@midnight`) | once a day (`0 0 0 * * *`), or\n| `@hourly` | once an hour, (`0 0 * * * *`)\n|===\n\n[[scheduling-quartz]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "Macros", "heading_level": 3, "file_order": 177, "section_index": 20, "content_hash": "38aa2223745e92e1210ff20968d28bd03c9d81b32f4eb3539ad9ae15f0bcf8c0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:155eb6f725c48ba64a6365686a4057166df1306248a41e4e8eff9584483afb2f", "content": "Quartz uses `Trigger`, `Job`, and `JobDetail` objects to realize scheduling of all\nkinds of jobs. For the basic concepts behind Quartz, see the\nhttps://www.quartz-scheduler.org/[Quartz Web site]. For convenience purposes, Spring\noffers a couple of classes that simplify using Quartz within Spring-based applications.\n\n[[scheduling-quartz-jobdetail]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "Using the Quartz Scheduler", "heading_level": 2, "file_order": 177, "section_index": 21, "content_hash": "155eb6f725c48ba64a6365686a4057166df1306248a41e4e8eff9584483afb2f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:6aa30fe0806d966d12e84158c210bfd62354a043b3b42b9e39f9e58f49104757", "content": "Quartz `JobDetail` objects contain all the information needed to run a job. Spring\nprovides a `JobDetailFactoryBean`, which provides bean-style properties for XML\nconfiguration purposes. Consider the following example:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean name=\"exampleJob\" class=\"org.springframework.scheduling.quartz.JobDetailFactoryBean\">\n <property name=\"jobClass\" value=\"example.ExampleJob\"/>\n <property name=\"jobDataAsMap\">\n <map>\n <entry key=\"timeout\" value=\"5\"/>\n </map>\n </property>\n\t</bean>\n----\n\nThe job detail configuration has all the information it needs to run the job (`ExampleJob`).\nThe timeout is specified in the job data map. The job data map is available through the\n`JobExecutionContext` (passed to you at execution time), but the `JobDetail` also gets\nits properties from the job data mapped to properties of the job instance. So, in the\nfollowing example, the `ExampleJob` contains a bean property named `timeout`, and the\n`JobDetail` has it applied automatically:\n\n[source,java,indent=0,subs=\"verbatim,quotes\",chomp=\"-packages\"]\n----\n\tpackage example;\n\n\tpublic class ExampleJob extends QuartzJobBean {\n\n private int timeout;\n\n /**\n * Setter called after the ExampleJob is instantiated\n * with the value from the JobDetailFactoryBean.\n */\n public void setTimeout(int timeout) {\n this.timeout = timeout;\n }\n\n protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException {\n // do the actual work\n }\n\t}\n----\n\nAll additional properties from the job data map are available to you as well.\n\nNOTE: By using the `name` and `group` properties, you can modify the name and the group\nof the job, respectively. By default, the name of the job matches the bean name\nof the `JobDetailFactoryBean` (`exampleJob` in the preceding example above).\n\n[[scheduling-quartz-method-invoking-job]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "Using the `JobDetailFactoryBean`", "heading_level": 3, "file_order": 177, "section_index": 22, "content_hash": "6aa30fe0806d966d12e84158c210bfd62354a043b3b42b9e39f9e58f49104757", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:2f0a81bfc3970a79977479fa0d8362216368cfba4630e427de15a8cb4d957d5f", "content": "Often you merely need to invoke a method on a specific object. By using the\n`MethodInvokingJobDetailFactoryBean`, you can do exactly this, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"jobDetail\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\">\n <property name=\"targetObject\" ref=\"exampleBusinessObject\"/>\n <property name=\"targetMethod\" value=\"doIt\"/>\n\t</bean>\n----\n\nThe preceding example results in the `doIt` method being called on the\n`exampleBusinessObject` method, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ExampleBusinessObject {\n\n // properties and collaborators\n\n public void doIt() {\n // do the actual work\n }\n\t}\n----\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"exampleBusinessObject\" class=\"examples.ExampleBusinessObject\"/>\n----\n\nBy using the `MethodInvokingJobDetailFactoryBean`, you need not create one-line jobs\nthat merely invoke a method. You need only create the actual business object and\nwire up the detail object.\n\nBy default, Quartz Jobs are stateless, resulting in the possibility of jobs interfering\nwith each other. If you specify two triggers for the same `JobDetail`, it is possible\nthat the second one starts before the first job has finished. If `JobDetail` classes\nimplement the `Stateful` interface, this does not happen: the second job does not start\nbefore the first one has finished.\n\nTo make jobs resulting from the `MethodInvokingJobDetailFactoryBean` be non-concurrent,\nset the `concurrent` flag to `false`, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean id=\"jobDetail\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\">\n <property name=\"targetObject\" ref=\"exampleBusinessObject\"/>\n <property name=\"targetMethod\" value=\"doIt\"/>\n <property name=\"concurrent\" value=\"false\"/>\n\t</bean>\n----\n\nNOTE: By default, jobs will run in a concurrent fashion.\n\n[[scheduling-quartz-cron]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "Using the `MethodInvokingJobDetailFactoryBean`", "heading_level": 3, "file_order": 177, "section_index": 23, "content_hash": "2f0a81bfc3970a79977479fa0d8362216368cfba4630e427de15a8cb4d957d5f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:8334977dc7d8df90c3d3da57585f986813b0ba2c6470e3a7c46155955c78c4fb", "content": "We have created job details and jobs. We have also reviewed the convenience bean that\nlets you invoke a method on a specific object. Of course, we still need to schedule the\njobs themselves. This is done by using triggers and a `SchedulerFactoryBean`. Several\ntriggers are available within Quartz, and Spring offers two Quartz `FactoryBean`\nimplementations with convenient defaults: `CronTriggerFactoryBean` and\n`SimpleTriggerFactoryBean`.\n\nTriggers need to be scheduled. Spring offers a `SchedulerFactoryBean` that exposes\ntriggers to be set as properties. `SchedulerFactoryBean` schedules the actual jobs with\nthose triggers.\n\nThe following listing uses both a `SimpleTriggerFactoryBean` and a `CronTriggerFactoryBean`:\n\n[source,xml,indent=0]\n[subs=\"verbatim\"]\n----\n\t<bean id=\"simpleTrigger\" class=\"org.springframework.scheduling.quartz.SimpleTriggerFactoryBean\">\n <!-- see the example of method invoking job above -->\n <property name=\"jobDetail\" ref=\"jobDetail\"/>\n <!-- 10 seconds -->\n <property name=\"startDelay\" value=\"10000\"/>\n <!-- repeat every 50 seconds -->\n <property name=\"repeatInterval\" value=\"50000\"/>\n\t</bean>\n\n\t<bean id=\"cronTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\">\n <property name=\"jobDetail\" ref=\"exampleJob\"/>\n <!-- run every morning at 6 AM -->\n <property name=\"cronExpression\" value=\"0 0 6 * * ?\"/>\n\t</bean>\n----\n\nThe preceding example sets up two triggers, one running every 50 seconds with a starting\ndelay of 10 seconds and one running every morning at 6 AM. To finalize everything,\nwe need to set up the `SchedulerFactoryBean`, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<bean class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\">\n <property name=\"triggers\">\n <list>\n <ref bean=\"cronTrigger\"/>\n <ref bean=\"simpleTrigger\"/>\n </list>\n </property>\n\t</bean>\n----\n\nMore properties are available for the `SchedulerFactoryBean`, such as the calendars used by the\njob details, properties to customize Quartz with, and a Spring-provided JDBC DataSource. See\nthe {spring-framework-api}/scheduling/quartz/SchedulerFactoryBean.html[`SchedulerFactoryBean`]\njavadoc for more information.\n\nNOTE: `SchedulerFactoryBean` also recognizes a `quartz.properties` file in the classpath,\nbased on Quartz property keys, as with regular Quartz configuration. Please note that many\n`SchedulerFactoryBean` settings interact with common Quartz settings in the properties file;\nit is therefore not recommended to specify values at both levels. For example, do not set\nan \"org.quartz.jobStore.class\" property if you mean to rely on a Spring-provided DataSource,\nor specify an `org.springframework.scheduling.quartz.LocalDataSourceJobStore` variant which\nis a full-fledged replacement for the standard `org.quartz.impl.jdbcjobstore.JobStoreTX`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration/scheduling.adoc", "title": "scheduling", "heading": "Wiring up Jobs by Using Triggers and `SchedulerFactoryBean`", "heading_level": 3, "file_order": 177, "section_index": 24, "content_hash": "8334977dc7d8df90c3d3da57585f986813b0ba2c6470e3a7c46155955c78c4fb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration/scheduling.adoc"}}
{"id": "sha256:5b4f8c62cdebd827521b1e9aa1f05be327f8935264436029f4dea71742e9a5c8", "content": "[[kotlin-annotations]]\n\nThe Spring Framework also takes advantage of {kotlin-docs}/null-safety.html[Kotlin null-safety]\nto determine if an HTTP parameter is required without having to explicitly\ndefine the `required` attribute. That means `@RequestParam name: String?` is treated\nas not required and, conversely, `@RequestParam name: String` is treated as being required.\nThis feature is also supported on the Spring Messaging `@Header` annotation.\n\nIn a similar fashion, Spring bean injection with `@Autowired`, `@Bean`, or `@Inject` uses\nthis information to determine if a bean is required or not.\n\nFor example, `@Autowired lateinit var thing: Thing` implies that a bean\nof type `Thing` must be registered in the application context, while `@Autowired lateinit var thing: Thing?`\ndoes not raise an error if such a bean does not exist.\n\nFollowing the same principle, `@Bean fun play(toy: Toy, car: Car?) = Baz(toy, car)` implies\nthat a bean of type `Toy` must be registered in the application context, while a bean of\ntype `Car` may or may not exist. The same behavior applies to autowired constructor parameters.\n\nNOTE: If you use bean validation on classes with properties or a primary constructor\nwith parameters, you may need to use\n{kotlin-docs}/annotations.html#annotation-use-site-targets[annotation use-site targets],\nsuch as `@field:NotNull` or `@get:Size(min=5, max=15)`, as described in\n{stackoverflow-site}/a/35853200/1092077[this Stack Overflow response].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/annotations.adoc", "title": "annotations", "heading": "annotations", "heading_level": 1, "file_order": 178, "section_index": 0, "content_hash": "5b4f8c62cdebd827521b1e9aa1f05be327f8935264436029f4dea71742e9a5c8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/annotations.adoc"}}
{"id": "sha256:4b49feb95bc0463109310a7c3a51add1653e98bc932733b05e85b499ed44c2c7", "content": "[[kotlin-bean-registration-dsl]]\n\nSee xref:core/beans/java/programmatic-bean-registration.adoc[Programmatic Bean Registration].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/bean-registration-dsl.adoc", "title": "bean-registration-dsl", "heading": "bean-registration-dsl", "heading_level": 1, "file_order": 179, "section_index": 0, "content_hash": "4b49feb95bc0463109310a7c3a51add1653e98bc932733b05e85b499ed44c2c7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/bean-registration-dsl.adoc"}}
{"id": "sha256:2deed58de08623a72d8d1baa0198f7f1191b149ecadb20929c14c600d8360061", "content": "[[kotlin-classes-interfaces]]\n\nThe Spring Framework supports various Kotlin constructs, such as instantiating Kotlin classes\nthrough primary constructors, data binding for immutable classes, and optional parameters\nwith default values for functions.\n\nKotlin parameter names are recognized through a dedicated `KotlinReflectionParameterNameDiscoverer`,\nwhich allows finding interface method parameter names without requiring the Java `-parameters`\ncompiler flag to be enabled during compilation.\n\nTIP: For completeness, we nevertheless recommend running the Kotlin compiler with its\n`-java-parameters` flag for standard Java parameter exposure.\n\nYou can declare configuration classes as\n{kotlin-docs}/nested-classes.html[top level or nested but not inner],\nsince the latter requires a reference to the outer class.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/classes-interfaces.adoc", "title": "classes-interfaces", "heading": "classes-interfaces", "heading_level": 1, "file_order": 180, "section_index": 0, "content_hash": "2deed58de08623a72d8d1baa0198f7f1191b149ecadb20929c14c600d8360061", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/classes-interfaces.adoc"}}
{"id": "sha256:306d7de75c77acc19590460ba181ac1baddb6f851956dcd89ea54c7b49496ee9", "content": "[[coroutines]]\n\nKotlin {kotlin-docs}/coroutines-overview.html[Coroutines] are instances of\nsuspendable computations allowing to write non-blocking code in an imperative way. On language side,\nsuspending functions provides an abstraction for asynchronous operations while on library side\n{kotlin-github-org}/kotlinx.coroutines[kotlinx.coroutines] provides functions like\n{kotlin-coroutines-api}/kotlinx-coroutines-core/kotlinx.coroutines/async.html[`async { }`]\nand types like {kotlin-coroutines-api}/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html[`Flow`].\n\nSpring Framework provides support for Coroutines on the following scope:\n\n* {kotlin-coroutines-api}/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html[Deferred] and {kotlin-coroutines-api}/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html[Flow] return values support in Spring MVC and WebFlux annotated `@Controller`\n* Suspending function support in Spring MVC and WebFlux annotated `@Controller`\n* Extensions for WebFlux {spring-framework-api-kdoc}/spring-webflux/org.springframework.web.reactive.function.client/index.html[client] and {spring-framework-api-kdoc}/spring-webflux/org.springframework.web.reactive.function.server/index.html[server] functional API.\n* WebFlux.fn {spring-framework-api-kdoc}/spring-webflux/org.springframework.web.reactive.function.server/co-router.html[coRouter { }] DSL\n* WebFlux {spring-framework-api-kdoc}/spring-web/org.springframework.web.server/-co-web-filter/index.html[`CoWebFilter`]\n* Suspending function and `Flow` support in RSocket `@MessageMapping` annotated methods\n* Extensions for {spring-framework-api-kdoc}/spring-messaging/org.springframework.messaging.rsocket/index.html[`RSocketRequester`]\n* Spring AOP\n\n[[dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc", "title": "coroutines", "heading": "coroutines", "heading_level": 1, "file_order": 181, "section_index": 0, "content_hash": "306d7de75c77acc19590460ba181ac1baddb6f851956dcd89ea54c7b49496ee9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc"}}
{"id": "sha256:6261c9b50e3bf603dfd4df4d9f4b97854676e73bc045ad3b1ac0a62de1451635", "content": "Coroutines support is enabled when `kotlinx-coroutines-core` and `kotlinx-coroutines-reactor`\ndependencies are in the classpath:\n\n`build.gradle.kts`\n[source,kotlin,indent=0]\n----\ndependencies {\n\n\timplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:${coroutinesVersion}\")\n\timplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${coroutinesVersion}\")\n}\n----\n\nVersion `1.4.0` and above are supported.\n\n[[how-reactive-translates-to-coroutines]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc", "title": "coroutines", "heading": "Dependencies", "heading_level": 2, "file_order": 181, "section_index": 1, "content_hash": "6261c9b50e3bf603dfd4df4d9f4b97854676e73bc045ad3b1ac0a62de1451635", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc"}}
{"id": "sha256:493853af3c9d2463d21c0c017b6665b3b3d6f525622d01d28ff37bf00826d671", "content": "For return values, the translation from Reactive to Coroutines APIs is the following:\n\n* `fun handler(): Mono<Void>` becomes `suspend fun handler()`\n* `fun handler(): Mono<T>` becomes `suspend fun handler(): T` or `suspend fun handler(): T?` depending on if the `Mono` can be empty or not (with the advantage of being more statically typed)\n* `fun handler(): Flux<T>` becomes `fun handler(): Flow<T>`\n\nFor input parameters:\n\n* If laziness is not needed, `fun handler(mono: Mono<T>)` becomes `fun handler(value: T)` since a suspending functions can be invoked to get the value parameter.\n* If laziness is needed, `fun handler(mono: Mono<T>)` becomes `fun handler(supplier: suspend () -> T)` or `fun handler(supplier: suspend () -> T?)`\n\n{kotlin-coroutines-api}/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html[`Flow`] is `Flux` equivalent in Coroutines world, suitable for hot or cold stream, finite or infinite streams, with the following main differences:\n\n* `Flow` is push-based while `Flux` is push-pull hybrid\n* Backpressure is implemented via suspending functions\n* `Flow` has only a {kotlin-coroutines-api}/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/collect.html[single suspending `collect` method] and operators are implemented as {kotlin-docs}/extensions.html[extensions]\n* {kotlin-github-org}/kotlinx.coroutines/tree/master/kotlinx-coroutines-core/common/src/flow/operators[Operators are easy to implement] thanks to Coroutines\n* Extensions allow to add custom operators to `Flow`\n* Collect operations are suspending functions\n* {kotlin-coroutines-api}/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html[`map` operator] supports asynchronous operation (no need for `flatMap`) since it takes a suspending function parameter\n\nRead this blog post about {spring-site-blog}/2019/04/12/going-reactive-with-spring-coroutines-and-kotlin-flow[Going Reactive with Spring, Coroutines and Kotlin Flow]\nfor more details, including how to run code concurrently with Coroutines.\n\n[[controllers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc", "title": "coroutines", "heading": "How Reactive translates to Coroutines?", "heading_level": 2, "file_order": 181, "section_index": 2, "content_hash": "493853af3c9d2463d21c0c017b6665b3b3d6f525622d01d28ff37bf00826d671", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc"}}
{"id": "sha256:1931d9905471c71742bed20f2158670ab7a308a70497aed06efcf0b6657e6e18", "content": "Here is an example of a Coroutines `@RestController`.\n\n[source,kotlin,indent=0]\n----\n@RestController\nclass CoroutinesRestController(client: WebClient, banner: Banner) {\n\n\t@GetMapping(\"/suspend\")\n\tsuspend fun suspendingEndpoint(): Banner {\n delay(10)\n return banner\n\t}\n\n\t@GetMapping(\"/flow\")\n\tfun flowEndpoint() = flow {\n delay(10)\n emit(banner)\n delay(10)\n emit(banner)\n\t}\n\n\t@GetMapping(\"/deferred\")\n\tfun deferredEndpoint() = GlobalScope.async {\n delay(10)\n banner\n\t}\n\n\t@GetMapping(\"/sequential\")\n\tsuspend fun sequential(): List<Banner> {\n val banner1 = client\n .get()\n .uri(\"/suspend\")\n .accept(MediaType.APPLICATION_JSON)\n .awaitExchange()\n .awaitBody<Banner>()\n val banner2 = client\n .get()\n .uri(\"/suspend\")\n .accept(MediaType.APPLICATION_JSON)\n .awaitExchange()\n .awaitBody<Banner>()\n return listOf(banner1, banner2)\n\t}\n\n\t@GetMapping(\"/parallel\")\n\tsuspend fun parallel(): List<Banner> = coroutineScope {\n val deferredBanner1: Deferred<Banner> = async {\n client\n .get()\n .uri(\"/suspend\")\n .accept(MediaType.APPLICATION_JSON)\n .awaitExchange()\n .awaitBody<Banner>()\n }\n val deferredBanner2: Deferred<Banner> = async {\n client\n .get()\n .uri(\"/suspend\")\n .accept(MediaType.APPLICATION_JSON)\n .awaitExchange()\n .awaitBody<Banner>()\n }\n listOf(deferredBanner1.await(), deferredBanner2.await())\n\t}\n\n\t@GetMapping(\"/error\")\n\tsuspend fun error() {\n throw IllegalStateException()\n\t}\n\n\t@GetMapping(\"/cancel\")\n\tsuspend fun cancel() {\n throw CancellationException()\n\t}\n\n}\n----\n\nView rendering with a `@Controller` is also supported.\n\n[source,kotlin,indent=0]\n----\n@Controller\nclass CoroutinesViewController(banner: Banner) {\n\n\t@GetMapping(\"/\")\n\tsuspend fun render(model: Model): String {\n delay(10)\n model[\"banner\"] = banner\n return \"index\"\n\t}\n}\n----\n\n[[webflux-fn]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc", "title": "coroutines", "heading": "Controllers", "heading_level": 2, "file_order": 181, "section_index": 3, "content_hash": "1931d9905471c71742bed20f2158670ab7a308a70497aed06efcf0b6657e6e18", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc"}}
{"id": "sha256:6f66262be287c909ff2000d5ffcf48621e088945c41c553066b969eb8bffaa27", "content": "Here is an example of Coroutines router defined via the\n{spring-framework-api-kdoc}/spring-webflux/org.springframework.web.reactive.function.server/co-router.html[coRouter { }]\nDSL and related handlers.\n\n[source,kotlin,indent=0]\n----\n@Configuration\nclass RouterConfiguration {\n\n\t@Bean\n\tfun mainRouter(userHandler: UserHandler) = coRouter {\n GET(\"/\", userHandler::listView)\n GET(\"/api/user\", userHandler::listApi)\n\t}\n}\n----\n\n[source,kotlin,indent=0]\n----\nclass UserHandler(builder: WebClient.Builder) {\n\n\tprivate val client = builder.baseUrl(\"...\").build()\n\n\tsuspend fun listView(request: ServerRequest): ServerResponse =\n ServerResponse.ok().renderAndAwait(\"users\", mapOf(\"users\" to\n client.get().uri(\"...\").awaitExchange().awaitBody<User>()))\n\n\tsuspend fun listApi(request: ServerRequest): ServerResponse =\n ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).bodyAndAwait(\n client.get().uri(\"...\").awaitExchange().awaitBody<User>())\n}\n----\n\n[[transactions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc", "title": "coroutines", "heading": "WebFlux.fn", "heading_level": 2, "file_order": 181, "section_index": 4, "content_hash": "6f66262be287c909ff2000d5ffcf48621e088945c41c553066b969eb8bffaa27", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc"}}
{"id": "sha256:c4b356c6eebe1f85c306b62bcb053653ddbdadf29c9085d7c7bc1cc28ecd16ed", "content": "Transactions on Coroutines are supported via the programmatic variant of the Reactive\ntransaction management.\n\nFor suspending functions, a `TransactionalOperator.executeAndAwait` extension is provided.\n\n[source,kotlin,indent=0]\n----\n\timport org.springframework.transaction.reactive.executeAndAwait\n\n\tclass PersonRepository(private val operator: TransactionalOperator) {\n\n suspend fun initDatabase() = operator.executeAndAwait {\n insertPerson1()\n insertPerson2()\n }\n\n private suspend fun insertPerson1() {\n // INSERT SQL statement\n }\n\n private suspend fun insertPerson2() {\n // INSERT SQL statement\n }\n\t}\n----\n\nFor Kotlin `Flow`, a `Flow<T>.transactional` extension is provided.\n\n[source,kotlin,indent=0]\n----\n\timport org.springframework.transaction.reactive.transactional\n\n\tclass PersonRepository(private val operator: TransactionalOperator) {\n\n fun updatePeople() = findPeople().map(::updatePerson).transactional(operator)\n\n private fun findPeople(): Flow<Person> {\n // SELECT SQL statement\n }\n\n private suspend fun updatePerson(person: Person): Person {\n // UPDATE SQL statement\n }\n\t}\n----\n\n[[coroutines.propagation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc", "title": "coroutines", "heading": "Transactions", "heading_level": 2, "file_order": 181, "section_index": 5, "content_hash": "c4b356c6eebe1f85c306b62bcb053653ddbdadf29c9085d7c7bc1cc28ecd16ed", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc"}}
{"id": "sha256:453c51c2831b8971dfbe1ff6562b1536dfed65bc3549bcb8550a4668635ba152", "content": "Spring applications are xref:integration/observability.adoc[instrumented with Micrometer for Observability support].\nFor tracing support, the current observation is propagated through a `ThreadLocal` for blocking code,\nor the Reactor `Context` for reactive pipelines. But the current observation also needs to be made available\nin the execution context of a suspended function. Without that, the current \"traceId\" will not be automatically\nprepended to logged statements from coroutines.\n\nThe {spring-framework-api-kdoc}/spring-core/org.springframework.core/-propagation-context-element/index.html[`PropagationContextElement`] operator generally ensures that the\n{micrometer-context-propagation-docs}/[Micrometer Context Propagation library] works with Kotlin Coroutines.\n\nIt requires the `io.micrometer:context-propagation` dependency and optionally the\n`org.jetbrains.kotlinx:kotlinx-coroutines-reactor` one. Automatic context propagation via\n`CoroutinesUtils#invokeSuspendingFunction` (used by Spring to adapt Coroutines to Reactor `Flux` or `Mono`) can be\nenabled by invoking `Hooks.enableAutomaticContextPropagation()`.\n\nApplications can also use `PropagationContextElement` explicitly to augment the `CoroutineContext`\nwith the context propagation mechanism:\n\ninclude-code::./ContextPropagationSample[tag=context,indent=0]\n\nHere, assuming that Micrometer Tracing is configured, the resulting logging statement will show the current \"traceId\"\nand unlock better observability for your application.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc", "title": "coroutines", "heading": "Context Propagation", "heading_level": 2, "file_order": 181, "section_index": 6, "content_hash": "453c51c2831b8971dfbe1ff6562b1536dfed65bc3549bcb8550a4668635ba152", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/coroutines.adoc"}}
{"id": "sha256:9427bfcd8e85d3738d57a4392108acf60906dc9c4cf1aafdcd538f0f9fba76f0", "content": "[[kotlin-extensions]]\n\nKotlin {kotlin-docs}/extensions.html[extensions] provide the ability\nto extend existing classes with additional functionality. The Spring Framework Kotlin APIs\nuse these extensions to add new Kotlin-specific conveniences to existing Spring APIs.\n\nThe {spring-framework-api-kdoc}/[Spring Framework KDoc API] lists\nand documents all available Kotlin extensions and DSLs.\n\nNOTE: Keep in mind that Kotlin extensions need to be imported to be used. This means,\nfor example, that the `GenericApplicationContext.registerBean` Kotlin extension\nis available only if `org.springframework.context.support.registerBean` is imported.\nThat said, similar to static imports, an IDE should automatically suggest the import in most cases.\n\nFor example, {kotlin-docs}/inline-functions.html#reified-type-parameters[Kotlin reified type parameters]\nprovide a workaround for JVM {java-tutorial}/java/generics/erasure.html[generics type erasure],\nand the Spring Framework provides some extensions to take advantage of this feature.\nThis allows for a better Kotlin API `RestTemplate`, for the new `WebClient` from Spring\nWebFlux, and for various other APIs.\n\nNOTE: Other libraries, such as Reactor and Spring Data, also provide Kotlin extensions\nfor their APIs, thus giving a better Kotlin development experience overall.\n\nTo retrieve a list of `User` objects in Java, you would normally write the following:\n\n[source,java,indent=0]\n----\n\tFlux<User> users = client.get().retrieve().bodyToFlux(User.class)\n----\n\nWith Kotlin and the Spring Framework extensions, you can instead write the following:\n\n[source,kotlin,indent=0]\n----\n\tval users = client.get().retrieve().bodyToFlux<User>()\n\t// or (both are equivalent)\n\tval users : Flux<User> = client.get().retrieve().bodyToFlux()\n----\n\nAs in Java, `users` in Kotlin is strongly typed, but Kotlin's clever type inference allows\nfor shorter syntax.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/extensions.adoc", "title": "extensions", "heading": "extensions", "heading_level": 1, "file_order": 182, "section_index": 0, "content_hash": "9427bfcd8e85d3738d57a4392108acf60906dc9c4cf1aafdcd538f0f9fba76f0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/extensions.adoc"}}
{"id": "sha256:54d042574516b29266749e6adc9730abc9adf55c513233ca6c65ab11fd361ece", "content": "[[kotlin-getting-started]]\n\nThe easiest way to learn how to build a Spring application with Kotlin is to follow\n{spring-site-guides}/tutorials/spring-boot-kotlin/[the dedicated tutorial].\n\n[[start-spring-io]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/getting-started.adoc", "title": "getting-started", "heading": "getting-started", "heading_level": 1, "file_order": 183, "section_index": 0, "content_hash": "54d042574516b29266749e6adc9730abc9adf55c513233ca6c65ab11fd361ece", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/getting-started.adoc"}}
{"id": "sha256:220559a464e7455643e4030a7a95ed7baf5d62841481d322d64a95a5376dfbdb", "content": "The easiest way to start a new Spring Framework project in Kotlin is to create a new Spring\nBoot project on https://start.spring.io/#!language=kotlin&type=gradle-project-kotlin[start.spring.io].\n\n[[choosing-the-web-flavor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/getting-started.adoc", "title": "getting-started", "heading": "`start.spring.io`", "heading_level": 2, "file_order": 183, "section_index": 1, "content_hash": "220559a464e7455643e4030a7a95ed7baf5d62841481d322d64a95a5376dfbdb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/getting-started.adoc"}}
{"id": "sha256:3ea092db8c2bdd38ce4ce4ea277aa5a35393e5eb63af1db67aeb8965cd190ea6", "content": "Spring Framework comes with two different web stacks: xref:web/webmvc.adoc#mvc[Spring MVC] and\nxref:testing/unit.adoc#mock-objects-web-reactive[Spring WebFlux].\n\nSpring WebFlux is recommended if you want to create applications that will deal with latency,\nlong-lived connections or streaming scenarios.\n\nFor other use cases, especially if you are using blocking technologies such as JPA, Spring\nMVC is the recommended choice.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/getting-started.adoc", "title": "getting-started", "heading": "Choosing the Web Flavor", "heading_level": 2, "file_order": 183, "section_index": 2, "content_hash": "3ea092db8c2bdd38ce4ce4ea277aa5a35393e5eb63af1db67aeb8965cd190ea6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/getting-started.adoc"}}
{"id": "sha256:c4f2529638c6555932278f8ed07ee71a3317d50dad946ab1e85497d4cc8f2811", "content": "[[kotlin-null-safety]]\n\nOne of Kotlin's key features is {kotlin-docs}/null-safety.html[null-safety],\nwhich cleanly deals with `null` values at compile time rather than bumping into the famous\n`NullPointerException` at runtime. This makes applications safer through nullability\ndeclarations and expressing \"`value or no value`\" semantics without paying the cost of wrappers, such as `Optional`.\nKotlin allows using functional constructs with nullable values. See this\n{baeldung-blog}/kotlin-null-safety[comprehensive guide to Kotlin null-safety].\n\nAlthough Java does not let you express null-safety in its type-system, the Spring Framework\nprovides xref:core/null-safety.adoc[null-safety of the whole Spring Framework API]\nvia tooling-friendly https://jspecify.dev/[JSpecify] annotations.\n\nAs of Kotlin 2.1, Kotlin enforces strict handling of nullability annotations from `org.jspecify.annotations` package.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/null-safety.adoc", "title": "null-safety", "heading": "null-safety", "heading_level": 1, "file_order": 184, "section_index": 0, "content_hash": "c4f2529638c6555932278f8ed07ee71a3317d50dad946ab1e85497d4cc8f2811", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/null-safety.adoc"}}
{"id": "sha256:06b5ae7ea88be3a4d7c1cd0bd51976f77f16addb02bde9747d982902842f5487", "content": "[[kotlin-requirements]]\n\nSpring Framework supports Kotlin 2.2+ and requires\nhttps://search.maven.org/artifact/org.jetbrains.kotlin/kotlin-stdlib[`kotlin-stdlib`]\nand https://search.maven.org/artifact/org.jetbrains.kotlin/kotlin-reflect[`kotlin-reflect`]\nto be present on the classpath. They are provided by default if you bootstrap a Kotlin project on\nhttps://start.spring.io/#!language=kotlin&type=gradle-project[start.spring.io].\n\nNOTE: The {jackson-github-org}/jackson-module-kotlin[Jackson Kotlin module] is required\nfor serializing or deserializing JSON data for Kotlin classes with Jackson, so make sure to add the\n`com.fasterxml.jackson.module:jackson-module-kotlin` dependency to your project if you have such need.\nIt is automatically registered when found in the classpath.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/requirements.adoc", "title": "requirements", "heading": "requirements", "heading_level": 1, "file_order": 185, "section_index": 0, "content_hash": "06b5ae7ea88be3a4d7c1cd0bd51976f77f16addb02bde9747d982902842f5487", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/requirements.adoc"}}
{"id": "sha256:8f45643a80a4f038b6148e3c487d3e0ab12815a5b314e6e6878dfdcebe669343", "content": "[[kotlin-resources]]\n\nWe recommend the following resources for people learning how to build applications with\nKotlin and the Spring Framework:\n\n* {kotlin-docs}[Kotlin language reference]\n* https://slack.kotlinlang.org/[Kotlin Slack] (with a dedicated #spring channel)\n* {stackoverflow-spring-kotlin-tags}[Stackoverflow, with `spring` and `kotlin` tags]\n* https://play.kotlinlang.org/[Try Kotlin in your browser]\n* https://blog.jetbrains.com/kotlin/[Kotlin blog]\n* https://kotlin.link/[Awesome Kotlin]\n\n[[examples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/resources.adoc", "title": "resources", "heading": "resources", "heading_level": 1, "file_order": 186, "section_index": 0, "content_hash": "8f45643a80a4f038b6148e3c487d3e0ab12815a5b314e6e6878dfdcebe669343", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/resources.adoc"}}
{"id": "sha256:84bd1a953d46007d54bb2de5a90a95c14270e7b48def7754d61ec9985c1753a4", "content": "The following Github projects offer examples that you can learn from and possibly even extend:\n\n* https://github.com/spring-guides/tut-spring-boot-kotlin[tut-spring-boot-kotlin]: Sources of {spring-site}/guides/tutorials/spring-boot-kotlin/[the official Spring + Kotlin tutorial]\n* https://github.com/sdeleuze/spring-boot-kotlin-demo[spring-boot-kotlin-demo]: Regular Spring Boot and Spring Data JPA project\n* https://github.com/mixitconf/mixit[mixit]: Spring Boot, WebFlux, and Reactive Spring Data MongoDB\n* https://github.com/sdeleuze/spring-kotlin-functional[spring-kotlin-functional]: Standalone WebFlux and functional bean definition DSL\n* https://github.com/sdeleuze/spring-kotlin-fullstack[spring-kotlin-fullstack]: WebFlux Kotlin fullstack example with Kotlin2js for frontend instead of JavaScript or TypeScript\n* https://github.com/spring-petclinic/spring-petclinic-kotlin[spring-petclinic-kotlin]: Kotlin version of the Spring PetClinic Sample Application", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/resources.adoc", "title": "resources", "heading": "Examples", "heading_level": 2, "file_order": 186, "section_index": 1, "content_hash": "84bd1a953d46007d54bb2de5a90a95c14270e7b48def7754d61ec9985c1753a4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/resources.adoc"}}
{"id": "sha256:50459045c4a5169b5a00aa848aa11a01e9e2ac2bdfe5f22ece976ebd2977b3eb", "content": "[[kotlin-spring-projects-in-kotlin]]\n\nThis section provides some specific hints and recommendations worth for developing Spring projects\nin Kotlin.\n\n[[final-by-default]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "spring-projects-in", "heading_level": 1, "file_order": 187, "section_index": 0, "content_hash": "50459045c4a5169b5a00aa848aa11a01e9e2ac2bdfe5f22ece976ebd2977b3eb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:19c6b0a1a7843d01f3598b58aef8d383c5a888eba74f6f782f727fb9ead9b5f5", "content": "By default, https://discuss.kotlinlang.org/t/classes-final-by-default/166[all classes and member functions in Kotlin are `final`].\nThe `open` modifier on a class is the opposite of Java's `final`: It allows others to inherit from this\nclass. This also applies to member functions, in that they need to be marked as `open` to be overridden.\n\nWhile Kotlin's JVM-friendly design is generally frictionless with Spring, this specific Kotlin feature\ncan prevent the application from starting, if this fact is not taken into consideration. This is because\nSpring beans (such as `@Configuration` annotated classes which by default need to be extended at runtime for technical\nreasons) are normally proxied by CGLIB. The workaround is to add an `open` keyword on each class and\nmember function of Spring beans that are proxied by CGLIB, which can\nquickly become painful and is against the Kotlin principle of keeping code concise and predictable.\n\nNOTE: It is also possible to avoid CGLIB proxies for configuration classes by using `@Configuration(proxyBeanMethods = false)`.\nSee {spring-framework-api}/context/annotation/Configuration.html#proxyBeanMethods--[`proxyBeanMethods` Javadoc] for more details.\n\nFortunately, Kotlin provides a\n{kotlin-docs}/compiler-plugins.html#kotlin-spring-compiler-plugin[`kotlin-spring`]\nplugin (a preconfigured version of the `kotlin-allopen` plugin) that automatically opens classes\nand their member functions for types that are annotated or meta-annotated with one of the following\nannotations:\n\n* `@Component`\n* `@Async`\n* `@Transactional`\n* `@Cacheable`\n\nMeta-annotation support means that types annotated with `@Configuration`, `@Controller`,\n`@RestController`, `@Service`, or `@Repository` are automatically opened since these\nannotations are meta-annotated with `@Component`.\n\nWARNING: Some use cases involving proxies and automatic generation of final methods by the Kotlin compiler require extra\ncare. For example, a Kotlin class with properties will generate related `final` getters and setters. In order\nto be able to proxy related methods, a type level `@Component` annotation should be preferred to method level `@Bean` in\norder to have those methods opened by the `kotlin-spring` plugin. A typical use case is `@Scope` and its popular\n`@RequestScope` specialization.\n\nhttps://start.spring.io/#!language=kotlin&type=gradle-project[start.spring.io] enables\nthe `kotlin-spring` plugin by default. So, in practice, you can write your Kotlin beans\nwithout any additional `open` keyword, as in Java.\n\nNOTE: The Kotlin code samples in Spring Framework documentation do not explicitly specify\n`open` on the classes and their member functions. The samples are written for projects\nusing the `kotlin-allopen` plugin, since this is the most commonly used setup.\n\n[[using-immutable-class-instances-for-persistence]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "Final by Default", "heading_level": 2, "file_order": 187, "section_index": 1, "content_hash": "19c6b0a1a7843d01f3598b58aef8d383c5a888eba74f6f782f727fb9ead9b5f5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:3838887d37b85f9783771688cce28d4452b0dc5c646d2f08e3739345e82f8808", "content": "In Kotlin, it is convenient and considered to be a best practice to declare read-only properties\nwithin the primary constructor, as in the following example:\n\n[source,kotlin,indent=0]\n----\n\tclass Person(val name: String, val age: Int)\n----\n\nYou can optionally add {kotlin-docs}/data-classes.html[the `data` keyword]\nto make the compiler automatically derive the following members from all properties declared\nin the primary constructor:\n\n* `equals()` and `hashCode()`\n* `toString()` of the form `\"User(name=John, age=42)\"`\n* `componentN()` functions that correspond to the properties in their order of declaration\n* `copy()` function\n\nAs the following example shows, this allows for easy changes to individual properties, even if `Person` properties are read-only:\n\n[source,kotlin,indent=0]\n----\n\tdata class Person(val name: String, val age: Int)\n\n\tval jack = Person(name = \"Jack\", age = 1)\n\tval olderJack = jack.copy(age = 2)\n----\n\nCommon persistence technologies (such as JPA) require a default constructor, preventing this\nkind of design. Fortunately, there is a workaround for this\n{stackoverflow-questions}/32038177/kotlin-with-jpa-default-constructor-hell[\"`default constructor hell`\"],\nsince Kotlin provides a {kotlin-docs}/compiler-plugins.html#kotlin-jpa-compiler-plugin[`kotlin-jpa`]\nplugin that generates synthetic no-arg constructor for classes annotated with JPA annotations.\n\nIf you need to leverage this kind of mechanism for other persistence technologies, you can configure\nthe {kotlin-docs}/compiler-plugins.html#how-to-use-no-arg-plugin[`kotlin-noarg`]\nplugin.\n\nNOTE: As of the Kay release train, Spring Data supports Kotlin immutable class instances and\ndoes not require the `kotlin-noarg` plugin if the module uses Spring Data object mappings\n(such as MongoDB, Redis, Cassandra, and others).\n\n[[injecting-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "Using Immutable Class Instances for Persistence", "heading_level": 2, "file_order": 187, "section_index": 2, "content_hash": "3838887d37b85f9783771688cce28d4452b0dc5c646d2f08e3739345e82f8808", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:a42f44fc85eb9a8579b77e8d335465c39adb40fd5b7bf7a224ac08c9431c6c0e", "content": "[[favor-constructor-injection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "Injecting Dependencies", "heading_level": 2, "file_order": 187, "section_index": 3, "content_hash": "a42f44fc85eb9a8579b77e8d335465c39adb40fd5b7bf7a224ac08c9431c6c0e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:5d815c2289c602d51f7c4391ad3ca6b8e54f224a57c103ca2b36260d7b91dfa6", "content": "Our recommendation is to try to favor constructor injection with `val` read-only (and\nnon-nullable when possible) {kotlin-docs}/properties.html[properties],\nas the following example shows:\n\n[source,kotlin,indent=0]\n----\n\t@Component\n\tclass YourBean(\n private val mongoTemplate: MongoTemplate,\n private val solrClient: SolrClient\n\t)\n----\n\nNOTE: Classes with a single constructor have their parameters automatically autowired.\nThat's why there is no need for an explicit `@Autowired constructor` in the example shown\nabove.\n\nIf you really need to use field injection, you can use the `lateinit var` construct,\nas the following example shows:\n\n[source,kotlin,indent=0]\n----\n\t@Component\n\tclass YourBean {\n\n @Autowired\n lateinit var mongoTemplate: MongoTemplate\n\n @Autowired\n lateinit var solrClient: SolrClient\n\t}\n----\n\n[[internal-functions-name-mangling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "Favor constructor injection", "heading_level": 3, "file_order": 187, "section_index": 4, "content_hash": "5d815c2289c602d51f7c4391ad3ca6b8e54f224a57c103ca2b36260d7b91dfa6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:09d82f727d255436501a6890a97620a05db4dad635224c524cba0843cc0550f0", "content": "Kotlin functions with the `internal` {kotlin-docs}/visibility-modifiers.html#class-members[visibility modifier] have\ntheir names mangled when compiled to JVM bytecode, which has a side effect when injecting dependencies by name.\n\nFor example, this Kotlin class:\n[source,kotlin,indent=0]\n----\n@Configuration\nclass SampleConfiguration {\n\n\t@Bean\n\tinternal fun sampleBean() = SampleBean()\n}\n----\n\nTranslates to this Java representation of the compiled JVM bytecode:\n[source,java,indent=0]\n----\n@Configuration\n@Metadata(/* ... */)\npublic class SampleConfiguration {\n\n\t@Bean\n\t@NotNull\n\tpublic SampleBean sampleBean$demo_kotlin_internal_test() {\n return new SampleBean();\n\t}\n}\n----\n\nAs a consequence, the related bean name represented as a Kotlin string is `\"sampleBean\\$demo_kotlin_internal_test\"`,\ninstead of `\"sampleBean\"` for the regular `public` function use-case. Make sure to use the mangled name when injecting\nsuch bean by name, or add `@JvmName(\"sampleBean\")` to disable name mangling.\n\n[[injecting-configuration-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "Internal functions name mangling", "heading_level": 3, "file_order": 187, "section_index": 5, "content_hash": "09d82f727d255436501a6890a97620a05db4dad635224c524cba0843cc0550f0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:f6867fcaa7dab8cc193afd6884d1f8153b99505376ab56c06a6aea459be39dcc", "content": "In Java, you can inject configuration properties by using annotations (such as pass:q[`@Value(\"${property}\")`)].\nHowever, in Kotlin, `$` is a reserved character that is used for\n{kotlin-docs}/idioms.html#string-interpolation[string interpolation].\n\nTherefore, if you wish to use the `@Value` annotation in Kotlin, you need to escape the `$`\ncharacter by writing pass:q[`@Value(\"\\${property}\")`].\n\nNOTE: If you use Spring Boot, you should probably use\n{spring-boot-docs-ref}/features/external-config.html#features.external-config.typesafe-configuration-properties[`@ConfigurationProperties`]\ninstead of `@Value` annotations.\n\nAs an alternative, you can customize the property placeholder prefix by declaring the\nfollowing `PropertySourcesPlaceholderConfigurer` bean:\n\n[source,kotlin,indent=0]\n----\n\t@Bean\n\tfun propertyConfigurer() = PropertySourcesPlaceholderConfigurer().apply {\n setPlaceholderPrefix(\"%{\")\n\t}\n----\n\nYou can support components (such as Spring Boot actuators or `@LocalServerPort`) that use\nthe standard `${...}` syntax alongside components that use the custom `%{...}` syntax by\ndeclaring multiple `PropertySourcesPlaceholderConfigurer` beans, as the following example\nshows:\n\n[source,kotlin,indent=0]\n----\n\t@Bean\n\tfun kotlinPropertyConfigurer() = PropertySourcesPlaceholderConfigurer().apply {\n setPlaceholderPrefix(\"%{\")\n setIgnoreUnresolvablePlaceholders(true)\n\t}\n\n\t@Bean\n\tfun defaultPropertyConfigurer() = PropertySourcesPlaceholderConfigurer()\n----\n\nIn addition, the default escape character can be changed or disabled globally by setting\nthe `spring.placeholder.escapeCharacter.default` property via a JVM system property (or\nvia the xref:appendix.adoc#appendix-spring-properties[`SpringProperties`] mechanism).\n\n[[checked-exceptions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "Injecting Configuration Properties", "heading_level": 2, "file_order": 187, "section_index": 6, "content_hash": "f6867fcaa7dab8cc193afd6884d1f8153b99505376ab56c06a6aea459be39dcc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:0da979ecf3e7d75f93d179ee93e15120b9d36a4b22a6bf14af72f1d74676d318", "content": "Java and {kotlin-docs}/exceptions.html[Kotlin exception handling]\nare pretty close, with the main difference being that Kotlin treats all exceptions as\nunchecked exceptions. However, when using proxied objects (for example classes or methods\nannotated with `@Transactional`), checked exceptions thrown will be wrapped by default in\nan `UndeclaredThrowableException`.\n\nTo get the original exception thrown like in Java, methods should be annotated with\n{kotlin-api}/jvm/stdlib/kotlin.jvm/-throws/index.html[`@Throws`]\nto specify explicitly the checked exceptions thrown (for example `@Throws(IOException::class)`).\n\n[[annotation-array-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "Checked Exceptions", "heading_level": 2, "file_order": 187, "section_index": 7, "content_hash": "0da979ecf3e7d75f93d179ee93e15120b9d36a4b22a6bf14af72f1d74676d318", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:ed4cd041adbf7153496c979a8b0aee9386419b46777a401b7c7ab518686d1803", "content": "Kotlin annotations are mostly similar to Java annotations, but array attributes (which are\nextensively used in Spring) behave differently. As explained in the\n{kotlin-docs}/annotations.html[Kotlin documentation] you can omit\nthe `value` attribute name, unlike other attributes, and specify it as a `vararg` parameter.\n\nTo understand what that means, consider `@RequestMapping` (which is one of the most widely\nused Spring annotations) as an example. This Java annotation is declared as follows:\n\n[source,java,indent=0]\n----\n\tpublic @interface RequestMapping {\n\n @AliasFor(\"path\")\n String[] value() default {};\n\n @AliasFor(\"value\")\n String[] path() default {};\n\n RequestMethod[] method() default {};\n\n // ...\n\t}\n----\n\nThe typical use case for `@RequestMapping` is to map a handler method to a specific path\nand method. In Java, you can specify a single value for the annotation array attribute,\nand it is automatically converted to an array.\n\nThat is why one can write\n`@RequestMapping(value = \"/toys\", method = RequestMethod.GET)` or\n`@RequestMapping(path = \"/toys\", method = RequestMethod.GET)`.\n\nHowever, in Kotlin, you must write `@RequestMapping(\"/toys\", method = [RequestMethod.GET])`\nor `@RequestMapping(path = [\"/toys\"], method = [RequestMethod.GET])` (square brackets need\nto be specified with named array attributes).\n\nAn alternative for this specific `method` attribute (the most common one) is to\nuse a shortcut annotation, such as `@GetMapping`, `@PostMapping`, and others.\n\nNOTE: If the `@RequestMapping` `method` attribute is not specified, all HTTP methods will\nbe matched, not only the `GET` method.\n\n[[declaration-site-variance]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "Annotation Array Attributes", "heading_level": 2, "file_order": 187, "section_index": 8, "content_hash": "ed4cd041adbf7153496c979a8b0aee9386419b46777a401b7c7ab518686d1803", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:96045c6f88d46ae52490318eead984bde825be14e9dc810c77a9539cc16e280d", "content": "Dealing with generic types in Spring applications written in Kotlin may require, for some use cases, to understand\nKotlin {kotlin-docs}/generics.html#declaration-site-variance[declaration-site variance]\nwhich allows to define the variance when declaring a type, which is not possible in Java which supports only use-site\nvariance.\n\nFor example, declaring `List<Foo>` in Kotlin is conceptually equivalent to `java.util.List<? extends Foo>` because\n`kotlin.collections.List` is declared as\n{kotlin-api}/jvm/stdlib/kotlin.collections/-list/[`interface List<out E> : kotlin.collections.Collection<E>`].\n\nThis needs to be taken into account by using the `out` Kotlin keyword on generic types when using Java classes,\nfor example when writing a `org.springframework.core.convert.converter.Converter` from a Kotlin type to a Java type.\n\n[source,kotlin,indent=0]\n----\n\tclass ListOfFooConverter : Converter<List<Foo>, CustomJavaList<out Foo>> {\n // ...\n\t}\n----\n\nWhen converting any kind of objects, star projection with `*` can be used instead of `out Any`.\n[source,kotlin,indent=0]\n----\n\tclass ListOfAnyConverter : Converter<List<*>, CustomJavaList<*>> {\n // ...\n\t}\n----\n\nNOTE: Spring Framework does not leverage yet declaration-site variance type information for injecting beans,\nsubscribe to {spring-framework-issues}/22313[spring-framework#22313] to track related\nprogresses.\n\n[[testing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "Declaration-site variance", "heading_level": 2, "file_order": 187, "section_index": 9, "content_hash": "96045c6f88d46ae52490318eead984bde825be14e9dc810c77a9539cc16e280d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:dc1013fc3ad97de44c9a01c68c5834dc45d7fa4b0b3d6fdac75a2fdd1578bf31", "content": "This section addresses testing with the combination of Kotlin and Spring Framework.\nThe recommended testing framework is https://junit.org/[JUnit] along with\nhttps://mockk.io/[Mockk] for mocking.\n\n[TIP]\n====\nKotlin lets you specify meaningful test function names between backticks (```).\n\nFor a concrete example, see the `+++`Find all users on HTML page`()+++` test function later\nin this section.\n====\n\nNOTE: If you are using Spring Boot, see\n{spring-boot-docs-ref}/features/kotlin.html#features.kotlin.testing[this related documentation].\n\n[[constructor-injection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "Testing", "heading_level": 2, "file_order": 187, "section_index": 10, "content_hash": "dc1013fc3ad97de44c9a01c68c5834dc45d7fa4b0b3d6fdac75a2fdd1578bf31", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:902f08fc66262eeca5b2529a2bbc57277625e81b0a0d062dfabebdb7b6dac43e", "content": "As described in the xref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-di[dedicated section],\nJUnit Jupiter allows constructor injection of beans which is pretty useful with Kotlin\nin order to use `val` instead of `lateinit var`. You can use\n{spring-framework-api}/test/context/TestConstructor.html[`@TestConstructor(autowireMode = AutowireMode.ALL)`]\nto enable autowiring for all parameters.\n\nNOTE: You can also change the default behavior to `ALL` in a `junit-platform.properties`\nfile with a `spring.test.constructor.autowire.mode = all` property.\n\n[source,kotlin,indent=0]\n----\n\t@SpringJUnitConfig(TestConfig::class)\n\t@TestConstructor(autowireMode = AutowireMode.ALL)\n\tclass OrderServiceIntegrationTests(\n val orderService: OrderService,\n val customerService: CustomerService) {\n\n // tests that use the injected OrderService and CustomerService\n\t}\n----\n\n[[per_class-lifecycle]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "Constructor injection", "heading_level": 3, "file_order": 187, "section_index": 11, "content_hash": "902f08fc66262eeca5b2529a2bbc57277625e81b0a0d062dfabebdb7b6dac43e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:bae535f25e41e283ae2d8d33a6fc07ce9ae2f60c1f2c9767dfd5362ea26c1a36", "content": "With JUnit Jupiter, Kotlin test classes can use the `@TestInstance(TestInstance.Lifecycle.PER_CLASS)`\nannotation to enable single instantiation of test classes, which allows the use of `@BeforeAll`\nand `@AfterAll` annotations on non-static methods, which is a good fit for Kotlin.\n\nNOTE: You can also change the default behavior to `PER_CLASS` in a `junit-platform.properties`\nfile with a `junit.jupiter.testinstance.lifecycle.default = per_class` property.\n\nThe following example demonstrates `@BeforeAll` and `@AfterAll` annotations on non-static methods:\n\n[source,kotlin,indent=0]\n----\n@TestInstance(TestInstance.Lifecycle.PER_CLASS)\nclass IntegrationTests {\n\n\tval application = Application(8181)\n\tval client = WebClient.create(\"http://localhost:8181\")\n\n\t@BeforeAll\n\tfun beforeAll() {\n application.start()\n\t}\n\n\t@Test\n\tfun `Find all users on HTML page`() {\n client.get().uri(\"/users\")\n .accept(TEXT_HTML)\n .retrieve()\n .bodyToMono<String>()\n .test()\n .expectNextMatches { it.contains(\"Foo\") }\n .verifyComplete()\n\t}\n\n\t@AfterAll\n\tfun afterAll() {\n application.stop()\n\t}\n}\n----\n\n[[specification-like-tests]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "`PER_CLASS` Lifecycle", "heading_level": 3, "file_order": 187, "section_index": 12, "content_hash": "bae535f25e41e283ae2d8d33a6fc07ce9ae2f60c1f2c9767dfd5362ea26c1a36", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:32241cf71c55c3ab0eaf9363d5cb2070690002a4febae81eebc1f3229e6a59fb", "content": "You can create specification-like tests with Kotlin and JUnit Jupiter's `@Nested` test\nclass support. The following example shows how to do so:\n\n[source,kotlin,indent=0]\n----\n\tclass SpecificationLikeTests {\n\n @Nested\n @DisplayName(\"a calculator\")\n inner class Calculator {\n\n val calculator = SampleCalculator()\n\n @Test\n fun `should return the result of adding the first number to the second number`() {\n val sum = calculator.sum(2, 4)\n assertEquals(6, sum)\n }\n\n @Test\n fun `should return the result of subtracting the second number from the first number`() {\n val subtract = calculator.subtract(4, 2)\n assertEquals(2, subtract)\n }\n }\n\t}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc", "title": "spring-projects-in", "heading": "Specification-like Tests", "heading_level": 3, "file_order": 187, "section_index": 13, "content_hash": "32241cf71c55c3ab0eaf9363d5cb2070690002a4febae81eebc1f3229e6a59fb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/spring-projects-in.adoc"}}
{"id": "sha256:e91e81671574ba0e6f773b92512eda9d5f6735b49a2e40f02c493a6d2c99a527", "content": "[[kotlin-web]]\n\n[[router-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/web.adoc", "title": "web", "heading": "web", "heading_level": 1, "file_order": 188, "section_index": 0, "content_hash": "e91e81671574ba0e6f773b92512eda9d5f6735b49a2e40f02c493a6d2c99a527", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/web.adoc"}}
{"id": "sha256:127deb9c07cbf26ea33640c54f2bbe49cc534d1d79b1e723a67e38a1e1fe0f2b", "content": "Spring Framework comes with a Kotlin router DSL available in 3 flavors:\n\n* xref:web/webmvc-functional.adoc[WebMvc.fn DSL] with {spring-framework-api-kdoc}/spring-webmvc/org.springframework.web.servlet.function/router.html[router { }]\n* xref:web/webflux-functional.adoc[WebFlux.fn Reactive DSL] with {spring-framework-api-kdoc}/spring-webflux/org.springframework.web.reactive.function.server/router.html[router { }]\n* xref:languages/kotlin/coroutines.adoc[WebFlux.fn Coroutines DSL] with {spring-framework-api-kdoc}/spring-webflux/org.springframework.web.reactive.function.server/co-router.html[coRouter { }]\n\nThese DSL let you write clean and idiomatic Kotlin code to build a `RouterFunction` instance as the following example shows:\n\n[source,kotlin,indent=0]\n----\n\t@Configuration\n\tclass RouterRouterConfiguration {\n\n @Bean\n fun mainRouter(userHandler: UserHandler) = router {\n accept(TEXT_HTML).nest {\n GET(\"/\") { ok().render(\"index\") }\n GET(\"/sse\") { ok().render(\"sse\") }\n GET(\"/users\", userHandler::findAllView)\n }\n \"/api\".nest {\n accept(APPLICATION_JSON).nest {\n GET(\"/users\", userHandler::findAll)\n }\n accept(TEXT_EVENT_STREAM).nest {\n GET(\"/users\", userHandler::stream)\n }\n }\n resources(\"/**\", ClassPathResource(\"static/\"))\n }\n\t}\n----\n\nNOTE: This DSL is programmatic, meaning that it allows custom registration logic of beans\nthrough an `if` expression, a `for` loop, or any other Kotlin constructs. That can be useful\nwhen you need to register routes depending on dynamic data (for example, from a database).\n\nSee https://github.com/mixitconf/mixit/[MiXiT project] for a concrete example.\n\n[[mockmvc-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/web.adoc", "title": "web", "heading": "Router DSL", "heading_level": 2, "file_order": 188, "section_index": 1, "content_hash": "127deb9c07cbf26ea33640c54f2bbe49cc534d1d79b1e723a67e38a1e1fe0f2b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/web.adoc"}}
{"id": "sha256:08a66258b5c6dea5f98d5008257742b2083a1b05b34b0c5c2606b062345d0e76", "content": "A Kotlin DSL is provided via `MockMvc` Kotlin extensions in order to provide a more\nidiomatic Kotlin API and to allow better discoverability (no usage of static methods).\n\n[source,kotlin,indent=0]\n----\n\tval mockMvc: MockMvc = ...\n\tmockMvc.get(\"/person/{name}\", \"Lee\") {\n secure = true\n accept = APPLICATION_JSON\n headers {\n contentLanguage = Locale.FRANCE\n }\n principal = Principal { \"foo\" }\n\t}.andExpect {\n status { isOk }\n content { contentType(APPLICATION_JSON) }\n jsonPath(\"$.name\") { value(\"Lee\") }\n content { json(\"\"\"{\"someBoolean\": false}\"\"\", false) }\n\t}.andDo {\n print()\n\t}\n----\n\n[[kotlin-multiplatform-serialization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/web.adoc", "title": "web", "heading": "MockMvc DSL", "heading_level": 2, "file_order": 188, "section_index": 2, "content_hash": "08a66258b5c6dea5f98d5008257742b2083a1b05b34b0c5c2606b062345d0e76", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/web.adoc"}}
{"id": "sha256:9147487d2a7f73d6b437263ffe3a85b1a45a6af0a59386f73765b252f1354958", "content": "{kotlin-github-org}/kotlinx.serialization[Kotlin multiplatform serialization] is\nsupported in Spring MVC, Spring WebFlux and Spring Messaging (RSocket). The builtin support currently targets CBOR, JSON,\nand ProtoBuf formats.\n\nTo enable it, follow {kotlin-github-org}/kotlinx.serialization#setup[those instructions] to add the related dependencies\nand plugin. With Spring MVC and WebFlux, Kotlin serialization is configured by default if it is in the classpath and\nother variants like Jackson are not. If needed, configure the converters or codecs manually.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin/web.adoc", "title": "web", "heading": "Kotlin multiplatform serialization", "heading_level": 2, "file_order": 188, "section_index": 3, "content_hash": "9147487d2a7f73d6b437263ffe3a85b1a45a6af0a59386f73765b252f1354958", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin/web.adoc"}}
{"id": "sha256:2bdb371ccb54b46b9a48f037c49f7e5844f789239b478fee28b9b144b49215a8", "content": "[[groovy]]\n\nGroovy is a powerful, optionally typed, and dynamic language, with static-typing and static\ncompilation capabilities. It offers a concise syntax and integrates smoothly with any\nexisting Java application.\n\n[[beans-factory-groovy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/groovy.adoc", "title": "groovy", "heading": "groovy", "heading_level": 1, "file_order": 189, "section_index": 0, "content_hash": "2bdb371ccb54b46b9a48f037c49f7e5844f789239b478fee28b9b144b49215a8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/groovy.adoc"}}
{"id": "sha256:80738f554dc90c138604cbcfc9eb5c0f2f935ddee2d03b99595a5b3b506028b5", "content": "The Spring Framework provides a dedicated `ApplicationContext` that supports a Groovy-based\nBean Definition DSL, as known from the Grails framework.\n\nTypically, such configuration live in a \".groovy\" file with the structure shown in the\nfollowing example:\n\n[source,groovy,indent=0,subs=\"verbatim,quotes\"]\n----\n\tbeans {\n dataSource(BasicDataSource) {\n driverClassName = \"org.hsqldb.jdbcDriver\"\n url = \"jdbc:hsqldb:mem:grailsDB\"\n username = \"sa\"\n password = \"\"\n settings = [mynew:\"setting\"]\n }\n sessionFactory(SessionFactory) {\n dataSource = dataSource\n }\n myService(MyService) {\n nestedBean = { AnotherBean bean ->\n dataSource = dataSource\n }\n }\n\t}\n----\n\nThis configuration style is largely equivalent to XML bean definitions and even\nsupports Spring's XML configuration namespaces. It also allows for importing XML\nbean definition files through an `importBeans` directive.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/groovy.adoc", "title": "groovy", "heading": "The Groovy Bean Definition DSL", "heading_level": 2, "file_order": 189, "section_index": 1, "content_hash": "80738f554dc90c138604cbcfc9eb5c0f2f935ddee2d03b99595a5b3b506028b5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/groovy.adoc"}}
{"id": "sha256:abd891db264d0a754b870b7ab74f468d7a8aad7bda0def942a4daad7786743d2", "content": "[[kotlin]]\n\n{kotlin-site}[Kotlin] is a statically typed language that targets the JVM\n(and other platforms) which allows writing concise and elegant code while providing\nvery good {kotlin-docs}/java-interop.html[interoperability]\nwith existing libraries written in Java.\n\nThe Spring Framework provides first-class support for Kotlin and lets developers write\nKotlin applications almost as if the Spring Framework was a native Kotlin framework.\nMost of the code samples of the reference documentation are\nprovided in Kotlin in addition to Java.\n\nThe easiest way to build a Spring application with Kotlin is to leverage Spring Boot and\nits {spring-boot-docs-ref}/features/kotlin.html[dedicated Kotlin support].\n{spring-site-guides}/tutorials/spring-boot-kotlin/[This comprehensive tutorial]\nwill teach you how to build Spring Boot applications with Kotlin using\nhttps://start.spring.io/#!language=kotlin&type=gradle-project[start.spring.io].\n\nFeel free to join the #spring channel of https://slack.kotlinlang.org/[Kotlin Slack]\nor ask a question with `spring` and `kotlin` as tags on\n{stackoverflow-spring-kotlin-tags}[Stackoverflow] if you need support.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages/kotlin.adoc", "title": "kotlin", "heading": "kotlin", "heading_level": 1, "file_order": 190, "section_index": 0, "content_hash": "abd891db264d0a754b870b7ab74f468d7a8aad7bda0def942a4daad7786743d2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages/kotlin.adoc"}}
{"id": "sha256:a186fd36947a1c6f6e1b20c137d889d316624a371ae5ca832c127296a75b7467", "content": "[[spring-testing-annotation-activeprofiles]]\n\n`@ActiveProfiles` is an annotation that can be applied to a test class to declare which\nbean definition profiles should be active when loading an `ApplicationContext` for an\nintegration test.\n\nThe following example indicates that the `dev` profile should be active:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@ActiveProfiles(\"dev\") // <1>\n\tclass DeveloperTests {\n // class body...\n\t}\n----\n<1> Indicate that the `dev` profile should be active.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@ActiveProfiles(\"dev\") // <1>\n\tclass DeveloperTests {\n // class body...\n\t}\n----\n<1> Indicate that the `dev` profile should be active.\n======\n\nThe following example indicates that both the `dev` and the `integration` profiles should\nbe active:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@ActiveProfiles({\"dev\", \"integration\"}) // <1>\n\tclass DeveloperIntegrationTests {\n // class body...\n\t}\n----\n<1> Indicate that the `dev` and `integration` profiles should be active.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@ActiveProfiles([\"dev\", \"integration\"]) // <1>\n\tclass DeveloperIntegrationTests {\n // class body...\n\t}\n----\n<1> Indicate that the `dev` and `integration` profiles should be active.\n======\n\nNOTE: `@ActiveProfiles` provides support for inheriting active bean definition profiles\ndeclared by superclasses and enclosing classes by default. You can also resolve active\nbean definition profiles programmatically by implementing a custom\nxref:testing/testcontext-framework/ctx-management/env-profiles.adoc#testcontext-ctx-management-env-profiles-ActiveProfilesResolver[`ActiveProfilesResolver`]\nand registering it by using the `resolver` attribute of `@ActiveProfiles`.\n\nSee xref:testing/testcontext-framework/ctx-management/env-profiles.adoc[Context Configuration with Environment Profiles],\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-nested-test-configuration[`@Nested` test class configuration], and the\n{spring-framework-api}/test/context/ActiveProfiles.html[`@ActiveProfiles`] javadoc for\nexamples and further details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-activeprofiles.adoc", "title": "annotation-activeprofiles", "heading": "annotation-activeprofiles", "heading_level": 1, "file_order": 191, "section_index": 0, "content_hash": "a186fd36947a1c6f6e1b20c137d889d316624a371ae5ca832c127296a75b7467", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-activeprofiles.adoc"}}
{"id": "sha256:5e96724c9954f110383b267d4ac6fabd56f4181bff13149e0da2a1d079c4fff1", "content": "[[spring-testing-annotation-aftertransaction]]\n\n`@AfterTransaction` indicates that the annotated `void` method should be run after a\ntransaction is ended, for test methods that have been configured to run within a\ntransaction by using Spring's `@Transactional` annotation. `@AfterTransaction` methods\nare not required to be `public` and may be declared on interface default methods.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@AfterTransaction // <1>\n\tvoid afterTransaction() {\n // logic to be run after a transaction has ended\n\t}\n----\n<1> Run this method after a transaction.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@AfterTransaction // <1>\n\tfun afterTransaction() {\n // logic to be run after a transaction has ended\n\t}\n----\n<1> Run this method after a transaction.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-aftertransaction.adoc", "title": "annotation-aftertransaction", "heading": "annotation-aftertransaction", "heading_level": 1, "file_order": 192, "section_index": 0, "content_hash": "5e96724c9954f110383b267d4ac6fabd56f4181bff13149e0da2a1d079c4fff1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-aftertransaction.adoc"}}
{"id": "sha256:838a23e79b21af6ac2e3572527858fdab8542c674840836bd866fd467e757a07", "content": "[[spring-testing-annotation-beforetransaction]]\n\n`@BeforeTransaction` indicates that the annotated `void` method should be run before a\ntransaction is started, for test methods that have been configured to run within a\ntransaction by using Spring's `@Transactional` annotation. `@BeforeTransaction` methods\nare not required to be `public` and may be declared on interface default methods.\n\nThe following example shows how to use the `@BeforeTransaction` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@BeforeTransaction // <1>\n\tvoid beforeTransaction() {\n // logic to be run before a transaction is started\n\t}\n----\n<1> Run this method before a transaction.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@BeforeTransaction // <1>\n\tfun beforeTransaction() {\n // logic to be run before a transaction is started\n\t}\n----\n<1> Run this method before a transaction.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-beforetransaction.adoc", "title": "annotation-beforetransaction", "heading": "annotation-beforetransaction", "heading_level": 1, "file_order": 193, "section_index": 0, "content_hash": "838a23e79b21af6ac2e3572527858fdab8542c674840836bd866fd467e757a07", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-beforetransaction.adoc"}}
{"id": "sha256:1a2aa214b358a814c54120147f1402d17d2988d3ffb7bfa587c414bc09813141", "content": "[[spring-testing-annotation-bootstrapwith]]\n\n`@BootstrapWith` is an annotation that can be applied to a test class to configure how\nthe Spring TestContext Framework is bootstrapped. Specifically, you can use\n`@BootstrapWith` to specify a custom `TestContextBootstrapper`. See the section on\nxref:testing/testcontext-framework/bootstrapping.adoc[bootstrapping the TestContext framework] for further details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-bootstrapwith.adoc", "title": "annotation-bootstrapwith", "heading": "annotation-bootstrapwith", "heading_level": 1, "file_order": 194, "section_index": 0, "content_hash": "1a2aa214b358a814c54120147f1402d17d2988d3ffb7bfa587c414bc09813141", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-bootstrapwith.adoc"}}
{"id": "sha256:06e69cf0f294c508e5a5869f1e25c663a2bd6afc763fbfff1ac0362289e47357", "content": "[[spring-testing-annotation-commit]]\n\n`@Commit` indicates that the transaction for a transactional test method should be\ncommitted after the test method has completed. You can use `@Commit` as a direct\nreplacement for `@Rollback(false)` to more explicitly convey the intent of the code.\nAnalogous to `@Rollback`, `@Commit` can also be declared as a class-level or method-level\nannotation.\n\nThe following example shows how to use the `@Commit` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Commit // <1>\n\t@Test\n\tvoid testProcessWithoutRollback() {\n // ...\n\t}\n----\n<1> Commit the result of the test to the database.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Commit // <1>\n\t@Test\n\tfun testProcessWithoutRollback() {\n // ...\n\t}\n----\n<1> Commit the result of the test to the database.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-commit.adoc", "title": "annotation-commit", "heading": "annotation-commit", "heading_level": 1, "file_order": 195, "section_index": 0, "content_hash": "06e69cf0f294c508e5a5869f1e25c663a2bd6afc763fbfff1ac0362289e47357", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-commit.adoc"}}
{"id": "sha256:5e8b1c9bb14ad4b64735b5e456b433f8c582cd4f422eaf7220be4719141cfdfc", "content": "[[spring-testing-annotation-contextconfiguration]]\n\n`@ContextConfiguration` is an annotation that can be applied to a test class to configure\nmetadata that is used to determine how to load and configure an `ApplicationContext` for\nintegration tests. Specifically, `@ContextConfiguration` declares the application context\nresource `locations` or the component `classes` used to load the context.\n\nResource locations are typically XML configuration files or Groovy scripts located in the\nclasspath, while component classes are typically `@Configuration` classes. However,\nresource locations can also refer to files and scripts in the file system, and component\nclasses can be `@Component` classes, `@Service` classes, and so on. See\nxref:testing/testcontext-framework/ctx-management/javaconfig.adoc#testcontext-ctx-management-javaconfig-component-classes[Component Classes]\nfor further details.\n\nThe following example shows a `@ContextConfiguration` annotation that refers to an XML\nfile:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration(\"/test-config.xml\") // <1>\n\tclass XmlApplicationContextTests {\n // class body...\n\t}\n----\n<1> Referring to an XML file.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration(\"/test-config.xml\") // <1>\n\tclass XmlApplicationContextTests {\n // class body...\n\t}\n----\n<1> Referring to an XML file.\n======\n\nThe following example shows a `@ContextConfiguration` annotation that refers to a class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration(classes = TestConfig.class) // <1>\n\tclass ConfigClassApplicationContextTests {\n // class body...\n\t}\n----\n<1> Referring to a class.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration(classes = [TestConfig::class]) // <1>\n\tclass ConfigClassApplicationContextTests {\n // class body...\n\t}\n----\n<1> Referring to a class.\n======\n\nAs an alternative or in addition to declaring resource locations or component classes,\nyou can use `@ContextConfiguration` to declare `ApplicationContextInitializer` classes.\nThe following example shows such a case:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration(initializers = CustomContextInitializer.class) // <1>\n\tclass ContextInitializerTests {\n // class body...\n\t}\n----\n<1> Declaring an initializer class.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration(initializers = [CustomContextInitializer::class]) // <1>\n\tclass ContextInitializerTests {\n // class body...\n\t}\n----\n<1> Declaring an initializer class.\n======\n\nYou can optionally use `@ContextConfiguration` to declare the `ContextLoader` strategy as\nwell. Note, however, that you typically do not need to explicitly configure the loader,\nsince the default loader supports `initializers` and either resource `locations` or\ncomponent `classes`.\n\nThe following example uses both a location and a loader:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration(locations = \"/test-context.xml\", loader = CustomContextLoader.class) // <1>\n\tclass CustomLoaderXmlApplicationContextTests {\n // class body...\n\t}\n----\n<1> Configuring both a location and a custom loader.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration(\"/test-context.xml\", loader = CustomContextLoader::class) // <1>\n\tclass CustomLoaderXmlApplicationContextTests {\n // class body...\n\t}\n----\n<1> Configuring both a location and a custom loader.\n======\n\nNOTE: `@ContextConfiguration` provides support for inheriting resource locations or\nconfiguration classes as well as context initializers that are declared by superclasses\nor enclosing classes.\n\nSee xref:testing/testcontext-framework/ctx-management.adoc[Context Management],\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-nested-test-configuration[`@Nested` test class configuration],\nand the {spring-framework-api}/test/context/ContextConfiguration.html[`@ContextConfiguration`]\njavadocs for further details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-contextconfiguration.adoc", "title": "annotation-contextconfiguration", "heading": "annotation-contextconfiguration", "heading_level": 1, "file_order": 196, "section_index": 0, "content_hash": "5e8b1c9bb14ad4b64735b5e456b433f8c582cd4f422eaf7220be4719141cfdfc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-contextconfiguration.adoc"}}
{"id": "sha256:4ff2d52fcfe0bc269586013f2221821cc3245dbc7565ec5dbfe1fda0be6ea402", "content": "[[spring-testing-annotation-contextcustomizerfactories]]\n\n`@ContextCustomizerFactories` is an annotation that can be applied to a test class to\nregister `ContextCustomizerFactory` implementations for the particular test class, its\nsubclasses, and its nested classes. If you wish to register a factory globally, you\nshould register it via the automatic discovery mechanism described in\nxref:testing/testcontext-framework/ctx-management/context-customizers.adoc[`ContextCustomizerFactory` Configuration].\n\nThe following example shows how to register two `ContextCustomizerFactory` implementations:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@ContextCustomizerFactories({CustomContextCustomizerFactory.class, AnotherContextCustomizerFactory.class}) // <1>\n\tclass CustomContextCustomizerFactoryTests {\n // class body...\n\t}\n----\n<1> Register two `ContextCustomizerFactory` implementations.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@ContextCustomizerFactories([CustomContextCustomizerFactory::class, AnotherContextCustomizerFactory::class]) // <1>\n\tclass CustomContextCustomizerFactoryTests {\n // class body...\n\t}\n----\n<1> Register two `ContextCustomizerFactory` implementations.\n======\n\nBy default, `@ContextCustomizerFactories` provides support for inheriting factories from\nsuperclasses or enclosing classes. See\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-nested-test-configuration[`@Nested` test class configuration]\nand the {spring-framework-api}/test/context/ContextCustomizerFactories.html[`@ContextCustomizerFactories` javadoc]\nfor an example and further details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-contextcustomizerfactories.adoc", "title": "annotation-contextcustomizerfactories", "heading": "annotation-contextcustomizerfactories", "heading_level": 1, "file_order": 197, "section_index": 0, "content_hash": "4ff2d52fcfe0bc269586013f2221821cc3245dbc7565ec5dbfe1fda0be6ea402", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-contextcustomizerfactories.adoc"}}
{"id": "sha256:9c8907026887d13e6b78c25345218b94aa2944cd1442154f20c26cdb11374217", "content": "[[spring-testing-annotation-contexthierarchy]]\n\n`@ContextHierarchy` is an annotation that can be applied to a test class to define a\nhierarchy of `ApplicationContext` instances for integration tests. `@ContextHierarchy`\nshould be declared with a list of one or more `@ContextConfiguration` instances, each of\nwhich defines a level in the context hierarchy. The following examples demonstrate the\nuse of `@ContextHierarchy` within a single test class (`@ContextHierarchy` can also be\nused within a test class hierarchy):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextHierarchy({\n @ContextConfiguration(\"/parent-config.xml\"),\n @ContextConfiguration(\"/child-config.xml\")\n\t})\n\tclass ContextHierarchyTests {\n // class body...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextHierarchy(\n ContextConfiguration(\"/parent-config.xml\"),\n ContextConfiguration(\"/child-config.xml\"))\n\tclass ContextHierarchyTests {\n // class body...\n\t}\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@WebAppConfiguration\n\t@ContextHierarchy({\n @ContextConfiguration(classes = AppConfig.class),\n @ContextConfiguration(classes = WebConfig.class)\n\t})\n\tclass WebIntegrationTests {\n // class body...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@WebAppConfiguration\n\t@ContextHierarchy(\n ContextConfiguration(classes = [AppConfig::class]),\n ContextConfiguration(classes = [WebConfig::class]))\n\tclass WebIntegrationTests {\n // class body...\n\t}\n----\n======\n\nIf you need to merge or override the configuration for a given level of the context\nhierarchy within a test class hierarchy, you must explicitly name that level by supplying\nthe same value to the `name` attribute in `@ContextConfiguration` at each corresponding\nlevel in the class hierarchy. See xref:testing/testcontext-framework/ctx-management/hierarchies.adoc[Context Hierarchies]\nand the {spring-framework-api}/test/context/ContextHierarchy.html[`@ContextHierarchy`] javadoc\nfor further examples.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-contexthierarchy.adoc", "title": "annotation-contexthierarchy", "heading": "annotation-contexthierarchy", "heading_level": 1, "file_order": 198, "section_index": 0, "content_hash": "9c8907026887d13e6b78c25345218b94aa2944cd1442154f20c26cdb11374217", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-contexthierarchy.adoc"}}
{"id": "sha256:4e009dc787597c05fe7d6c645e1672c060d3a77efbd2e655b849c70fd3c8b6f2", "content": "[[spring-testing-annotation-dirtiescontext]]\n\n`@DirtiesContext` indicates that the underlying Spring `ApplicationContext` has been\ndirtied during the execution of a test (that is, the test modified or corrupted it in\nsome manner -- for example, by changing the state of a singleton bean) and should be\nclosed. When an application context is marked as dirty, it is removed from the testing\nframework's cache and closed. As a consequence, the underlying Spring container is\nrebuilt for any subsequent test that requires a context with the same configuration\nmetadata.\n\nYou can use `@DirtiesContext` as both a class-level and a method-level annotation within\nthe same test class or test class hierarchy. In such scenarios, the `ApplicationContext`\nis marked as dirty before or after any such annotated method as well as before or after\nthe current test class, depending on the configured `methodMode` and `classMode`. When\n`@DirtiesContext` is declared at both the class level and the method level, the\nconfigured modes from both annotations will be honored. For example, if the class mode is\nset to `BEFORE_EACH_TEST_METHOD` and the method mode is set to `AFTER_METHOD`, the\ncontext will be marked as dirty both before and after the given test method.\n\nThe following examples explain when the context would be dirtied for various\nconfiguration scenarios:\n\n* Before the current test class, when declared on a class with class mode set to\n`BEFORE_CLASS`.\n+\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@DirtiesContext(classMode = BEFORE_CLASS) // <1>\n\tclass FreshContextTests {\n // some tests that require a new Spring container\n\t}\n----\n<1> Dirty the context before the current test class.\n+\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@DirtiesContext(classMode = BEFORE_CLASS) // <1>\n\tclass FreshContextTests {\n // some tests that require a new Spring container\n\t}\n----\n<1> Dirty the context before the current test class.\n======\n\n* After the current test class, when declared on a class with class mode set to\n`AFTER_CLASS` (i.e., the default class mode).\n+\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@DirtiesContext // <1>\n\tclass ContextDirtyingTests {\n // some tests that result in the Spring container being dirtied\n\t}\n----\n<1> Dirty the context after the current test class.\n+\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@DirtiesContext // <1>\n\tclass ContextDirtyingTests {\n // some tests that result in the Spring container being dirtied\n\t}\n----\n<1> Dirty the context after the current test class.\n======\n\n* Before each test method in the current test class, when declared on a class with class\nmode set to `BEFORE_EACH_TEST_METHOD.`\n+\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) // <1>\n\tclass FreshContextTests {\n // some tests that require a new Spring container\n\t}\n----\n<1> Dirty the context before each test method.\n+\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) // <1>\n\tclass FreshContextTests {\n // some tests that require a new Spring container\n\t}\n----\n<1> Dirty the context before each test method.\n======\n\n* After each test method in the current test class, when declared on a class with class\nmode set to `AFTER_EACH_TEST_METHOD.`\n+\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) // <1>\n\tclass ContextDirtyingTests {\n // some tests that result in the Spring container being dirtied\n\t}\n----\n<1> Dirty the context after each test method.\n+\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) // <1>\n\tclass ContextDirtyingTests {\n // some tests that result in the Spring container being dirtied\n\t}\n----\n<1> Dirty the context after each test method.\n======\n\n* Before the current test, when declared on a method with the method mode set to\n`BEFORE_METHOD`.\n+\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@DirtiesContext(methodMode = BEFORE_METHOD) // <1>\n\t@Test\n\tvoid testProcessWhichRequiresFreshAppCtx() {\n // some logic that requires a new Spring container\n\t}\n----\n<1> Dirty the context before the current test method.\n+\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@DirtiesContext(methodMode = BEFORE_METHOD) // <1>\n\t@Test\n\tfun testProcessWhichRequiresFreshAppCtx() {\n // some logic that requires a new Spring container\n\t}\n----\n<1> Dirty the context before the current test method.\n======\n\n* After the current test, when declared on a method with the method mode set to\n`AFTER_METHOD` (i.e., the default method mode).\n+\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@DirtiesContext // <1>\n\t@Test\n\tvoid testProcessWhichDirtiesAppCtx() {\n // some logic that results in the Spring container being dirtied\n\t}\n----\n<1> Dirty the context after the current test method.\n+\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@DirtiesContext // <1>\n\t@Test\n\tfun testProcessWhichDirtiesAppCtx() {\n // some logic that results in the Spring container being dirtied\n\t}\n----\n<1> Dirty the context after the current test method.\n======\n\nIf you use `@DirtiesContext` in a test whose context is configured as part of a context\nhierarchy with `@ContextHierarchy`, you can use the `hierarchyMode` flag to control how\nthe context cache is cleared. By default, an exhaustive algorithm is used to clear the\ncontext cache, including not only the current level but also all other context\nhierarchies that share an ancestor context common to the current test. All\n`ApplicationContext` instances that reside in a sub-hierarchy of the common ancestor\ncontext are removed from the context cache and closed. If the exhaustive algorithm is\noverkill for a particular use case, you can specify the simpler current level algorithm,\nas the following example shows.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextHierarchy({\n @ContextConfiguration(\"/parent-config.xml\"),\n @ContextConfiguration(\"/child-config.xml\")\n\t})\n\tclass BaseTests {\n // class body...\n\t}\n\n\tclass ExtendedTests extends BaseTests {\n\n @Test\n @DirtiesContext(hierarchyMode = CURRENT_LEVEL) // <1>\n void test() {\n // some logic that results in the child context being dirtied\n }\n\t}\n----\n<1> Use the current-level algorithm.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextHierarchy(\n ContextConfiguration(\"/parent-config.xml\"),\n ContextConfiguration(\"/child-config.xml\"))\n\topen class BaseTests {\n // class body...\n\t}\n\n\tclass ExtendedTests : BaseTests() {\n\n @Test\n @DirtiesContext(hierarchyMode = CURRENT_LEVEL) // <1>\n fun test() {\n // some logic that results in the child context being dirtied\n }\n\t}\n----\n<1> Use the current-level algorithm.\n======\n\nFor further details regarding the `EXHAUSTIVE` and `CURRENT_LEVEL` algorithms, see the\n{spring-framework-api}/test/annotation/DirtiesContext.HierarchyMode.html[`DirtiesContext.HierarchyMode`]\njavadoc.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-dirtiescontext.adoc", "title": "annotation-dirtiescontext", "heading": "annotation-dirtiescontext", "heading_level": 1, "file_order": 199, "section_index": 0, "content_hash": "4e009dc787597c05fe7d6c645e1672c060d3a77efbd2e655b849c70fd3c8b6f2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-dirtiescontext.adoc"}}
{"id": "sha256:fc42db0dabd268d0ded777ee119e1ca2e5f7401c6932d61a38fbed419556ce6d", "content": "[[spring-testing-annotation-disabledinaotmode]]\n\n`@DisabledInAotMode` signals that the annotated test class is disabled in Spring AOT\n(ahead-of-time) mode, which means that the `ApplicationContext` for the test class will\nnot be processed for AOT optimizations at build time.\n\nIf a test class is annotated with `@DisabledInAotMode`, all other test classes which\nspecify configuration to load the same `ApplicationContext` must also be annotated with\n`@DisabledInAotMode`. Failure to annotate all such test classes will result in an\nexception, either at build time or run time.\n\nWhen used with JUnit Jupiter based tests, `@DisabledInAotMode` also signals that the\nannotated test class or test method is disabled when running the test suite in Spring AOT\nmode. When applied at the class level, all test methods within that class will be\ndisabled. In this sense, `@DisabledInAotMode` has semantics similar to those of JUnit\nJupiter's `@DisabledInNativeImage` annotation.\n\nFor details on AOT support specific to integration tests, see\nxref:testing/testcontext-framework/aot.adoc[Ahead of Time Support for Tests].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-disabledinaotmode.adoc", "title": "annotation-disabledinaotmode", "heading": "annotation-disabledinaotmode", "heading_level": 1, "file_order": 200, "section_index": 0, "content_hash": "fc42db0dabd268d0ded777ee119e1ca2e5f7401c6932d61a38fbed419556ce6d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-disabledinaotmode.adoc"}}
{"id": "sha256:73c01c606dc7ed2767455eb1733436329f15cd7d7f70325901c81eb897c4b295", "content": "[[spring-testing-annotation-dynamicpropertysource]]\n\n`@DynamicPropertySource` is an annotation that can be applied to methods in integration\ntest classes that need to register _dynamic_ properties to be added to the set of\n`PropertySources` in the `Environment` for an `ApplicationContext` loaded for an\nintegration test. Dynamic properties are useful when you do not know the value of the\nproperties upfront â€“ for example, if the properties are managed by an external resource\nsuch as for a container managed by the {testcontainers-site}[Testcontainers] project.\n\nThe following example demonstrates how to register a dynamic property:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\tclass MyIntegrationTests {\n\n static MyExternalServer server = // ...\n\n @DynamicPropertySource // <1>\n static void dynamicProperties(DynamicPropertyRegistry registry) { // <2>\n registry.add(\"server.port\", server::getPort); // <3>\n }\n\n // tests ...\n\t}\n----\n<1> Annotate a `static` method with `@DynamicPropertySource`.\n<2> Accept a `DynamicPropertyRegistry` as an argument.\n<3> Register a dynamic `server.port` property to be retrieved lazily from the server.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\tclass MyIntegrationTests {\n\n companion object {\n\n @JvmStatic\n val server: MyExternalServer = // ...\n\n @DynamicPropertySource // <1>\n @JvmStatic\n fun dynamicProperties(registry: DynamicPropertyRegistry) { // <2>\n registry.add(\"server.port\", server::getPort) // <3>\n }\n }\n\n // tests ...\n\t}\n----\n<1> Annotate a `static` method with `@DynamicPropertySource`.\n<2> Accept a `DynamicPropertyRegistry` as an argument.\n<3> Register a dynamic `server.port` property to be retrieved lazily from the server.\n======\n\nSee xref:testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc[Context Configuration with Dynamic Property Sources]\nfor further details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-dynamicpropertysource.adoc", "title": "annotation-dynamicpropertysource", "heading": "annotation-dynamicpropertysource", "heading_level": 1, "file_order": 201, "section_index": 0, "content_hash": "73c01c606dc7ed2767455eb1733436329f15cd7d7f70325901c81eb897c4b295", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-dynamicpropertysource.adoc"}}
{"id": "sha256:77b972419f5ed12b9a64d29d57f586f1c4d4ffe3178e2635105dff80db8fb976", "content": "[[spring-testing-annotation-beanoverriding-mockitobean]]\n\n{spring-framework-api}/test/context/bean/override/mockito/MockitoBean.html[`@MockitoBean`] and\n{spring-framework-api}/test/context/bean/override/mockito/MockitoSpyBean.html[`@MockitoSpyBean`]\ncan be used in test classes to override a bean in the test's `ApplicationContext` with a\nMockito _mock_ or _spy_, respectively. In the latter case, an early instance of the\noriginal bean is captured and wrapped by the spy.\n\nThe annotations can be applied in the following ways.\n\n* On a non-static field in a test class or any of its superclasses.\n* On a non-static field in an enclosing class for a `@Nested` test class or in any class\n in the type hierarchy or enclosing class hierarchy above the `@Nested` test class.\n* At the type level on a test class or any superclass or implemented interface in the\n type hierarchy above the test class.\n* At the type level on an enclosing class for a `@Nested` test class or on any class or\n interface in the type hierarchy or enclosing class hierarchy above the `@Nested` test\n class.\n\nWhen `@MockitoBean` or `@MockitoSpyBean` is declared on a field, the bean to mock or spy\nis inferred from the type of the annotated field. If multiple candidates exist in the\n`ApplicationContext`, a `@Qualifier` annotation can be declared on the field to help\ndisambiguate. In the absence of a `@Qualifier` annotation, the name of the annotated\nfield will be used as a _fallback qualifier_. Alternatively, you can explicitly specify a\nbean name to mock or spy by setting the `value` or `name` attribute in the annotation.\n\nWhen `@MockitoBean` or `@MockitoSpyBean` is declared at the type level, the type of bean\n(or beans) to mock or spy must be supplied via the `types` attribute in the annotation â€“\nfor example, `@MockitoBean(types = {OrderService.class, UserService.class})`. If multiple\ncandidates exist in the `ApplicationContext`, you can explicitly specify a bean name to\nmock or spy by setting the `name` attribute. Note, however, that the `types` attribute\nmust contain a single type if an explicit bean `name` is configured â€“ for example,\n`@MockitoBean(name = \"ps1\", types = PrintingService.class)`.\n\nTo support reuse of mock configuration, `@MockitoBean` and `@MockitoSpyBean` may be used\nas meta-annotations to create custom _composed annotations_ â€“ for example, to define\ncommon mock or spy configuration in a single annotation that can be reused across a test\nsuite. `@MockitoBean` and `@MockitoSpyBean` can also be used as repeatable annotations at\nthe type level â€” for example, to mock or spy several beans by name.\n\n[WARNING]\n====\nQualifiers, including the name of a field, are used to determine if a separate\n`ApplicationContext` needs to be created. If you are using this feature to mock or spy\nthe same bean in several test classes, make sure to name the fields consistently to avoid\ncreating unnecessary contexts.\n====\n\n[WARNING]\n====\nUsing `@MockitoBean` or `@MockitoSpyBean` in conjunction with `@ContextHierarchy` can\nlead to undesirable results since each `@MockitoBean` or `@MockitoSpyBean` will be\napplied to all context hierarchy levels by default. To ensure that a particular\n`@MockitoBean` or `@MockitoSpyBean` is applied to a single context hierarchy level, set\nthe `contextName` attribute to match a configured `@ContextConfiguration` name â€“ for\nexample, `@MockitoBean(contextName = \"app-config\")` or\n`@MockitoSpyBean(contextName = \"app-config\")`.\n\nSee\nxref:testing/testcontext-framework/ctx-management/hierarchies.adoc#testcontext-ctx-management-ctx-hierarchies-with-bean-overrides[context\nhierarchies with bean overrides] for further details and examples.\n====\n\nEach annotation also defines Mockito-specific attributes to fine-tune the mocking behavior.\n\nThe `@MockitoBean` annotation uses the `REPLACE_OR_CREATE`\nxref:testing/testcontext-framework/bean-overriding.adoc#testcontext-bean-overriding-strategy[strategy for bean overrides].\nIf a corresponding bean does not exist, a new bean will be created. However, you can\nswitch to the `REPLACE` strategy by setting the `enforceOverride` attribute to `true` â€“\nfor example, `@MockitoBean(enforceOverride = true)`.\n\nThe `@MockitoSpyBean` annotation uses the `WRAP`\nxref:testing/testcontext-framework/bean-overriding.adoc#testcontext-bean-overriding-strategy[strategy],\nand the original instance is wrapped in a Mockito spy. This strategy requires that\nexactly one candidate bean exists.\n\n[TIP]\n====\nAs stated in the documentation for Mockito, there are times when using `Mockito.when()` is\ninappropriate for stubbing a spy â€“ for example, if calling a real method on a spy results\nin undesired side effects.\n\nTo avoid such undesired side effects, consider using\n`Mockito.doReturn(...).when(spy)...`, `Mockito.doThrow(...).when(spy)...`,\n`Mockito.doNothing().when(spy)...`, and similar methods.\n====\n\n[NOTE]\n====\nWhen using `@MockitoBean` to mock a non-singleton bean, the non-singleton bean will be\nreplaced with a singleton mock, and the corresponding bean definition will be converted\nto a `singleton`. Consequently, if you mock a `prototype` or scoped bean, the mock will\nbe treated as a `singleton`.\n\nSimilarly, when using `@MockitoSpyBean` to create a spy for a non-singleton bean, the\ncorresponding bean definition will be converted to a `singleton`. Consequently, if you\ncreate a spy for a `prototype` or scoped bean, the spy will be treated as a `singleton`.\n\nWhen using `@MockitoBean` to mock a bean created by a `FactoryBean`, the `FactoryBean`\nwill be replaced with a singleton mock of the type of object created by the `FactoryBean`.\n\nSimilarly, when using `@MockitoSpyBean` to create a spy for a `FactoryBean`, a spy will\nbe created for the object created by the `FactoryBean`, not for the `FactoryBean` itself.\n\nFurthermore, `@MockitoSpyBean` cannot be used to spy on a scoped proxy â€” for example, a\nbean annotated with `@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS)`. Any attempt to do\nso will fail with an exception.\n====\n\n[NOTE]\n====\nThere are no restrictions on the visibility of `@MockitoBean` and `@MockitoSpyBean`\nfields.\n\nSuch fields can therefore be `public`, `protected`, package-private (default visibility),\nor `private` depending on the needs or coding practices of the project.\n====\n\n[[spring-testing-annotation-beanoverriding-mockitobean-examples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-mockitobean.adoc", "title": "annotation-mockitobean", "heading": "annotation-mockitobean", "heading_level": 1, "file_order": 202, "section_index": 0, "content_hash": "77b972419f5ed12b9a64d29d57f586f1c4d4ffe3178e2635105dff80db8fb976", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-mockitobean.adoc"}}
{"id": "sha256:3b7f3bb0d213079f0425eaa1af2e37eef92b47f185a6ef1bc40a4fc3c9351787", "content": "The following example shows how to use the default behavior of the `@MockitoBean`\nannotation.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\tclass BeanOverrideTests {\n\n @MockitoBean // <1>\n CustomService customService;\n\n // tests...\n\t}\n----\n<1> Replace the bean with type `CustomService` with a Mockito mock.\n======\n\nIn the example above, we are creating a mock for `CustomService`. If more than one bean\nof that type exists, the bean named `customService` is considered. Otherwise, the test\nwill fail, and you will need to provide a qualifier of some sort to identify which of the\n`CustomService` beans you want to override. If no such bean exists, a bean will be\ncreated with an auto-generated bean name.\n\nThe following example uses a by-name lookup, rather than a by-type lookup. If no bean\nnamed `service` exists, one is created.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\tclass BeanOverrideTests {\n\n @MockitoBean(\"service\") // <1>\n CustomService customService;\n\n // tests...\n\n\t}\n----\n<1> Replace the bean named `service` with a Mockito mock.\n======\n\nThe following `@SharedMocks` annotation registers two mocks by-type and one mock by-name.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MockitoBean(types = {OrderService.class, UserService.class}) // <1>\n\t@MockitoBean(name = \"ps1\", types = PrintingService.class) // <2>\n\tpublic @interface SharedMocks {\n\t}\n----\n<1> Register `OrderService` and `UserService` mocks by-type.\n<2> Register `PrintingService` mock by-name.\n======\n\nThe following demonstrates how `@SharedMocks` can be used on a test class.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\t@SharedMocks // <1>\n\tclass BeanOverrideTests {\n\n @Autowired OrderService orderService; // <2>\n\n @Autowired UserService userService; // <2>\n\n @Autowired PrintingService ps1; // <2>\n\n // Inject other components that rely on the mocks.\n\n @Test\n void testThatDependsOnMocks() {\n // ...\n }\n\t}\n----\n<1> Register common mocks via the custom `@SharedMocks` annotation.\n<2> Optionally inject mocks to _stub_ or _verify_ them.\n======\n\nTIP: The mocks can also be injected into `@Configuration` classes or other test-related\ncomponents in the `ApplicationContext` in order to configure them with Mockito's stubbing\nAPIs.\n\n[[spring-testing-annotation-beanoverriding-mockitospybean-examples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-mockitobean.adoc", "title": "annotation-mockitobean", "heading": "`@MockitoBean` Examples", "heading_level": 2, "file_order": 202, "section_index": 1, "content_hash": "3b7f3bb0d213079f0425eaa1af2e37eef92b47f185a6ef1bc40a4fc3c9351787", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-mockitobean.adoc"}}
{"id": "sha256:e85feb63255d18a55b16782b16aa00a8dd8b4712b682ac2075c72f0a674208fe", "content": "The following example shows how to use the default behavior of the `@MockitoSpyBean`\nannotation.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\tclass BeanOverrideTests {\n\n @MockitoSpyBean // <1>\n CustomService customService;\n\n // tests...\n\t}\n----\n<1> Wrap the bean with type `CustomService` with a Mockito spy.\n======\n\nIn the example above, we are wrapping the bean with type `CustomService`. If more than\none bean of that type exists, the bean named `customService` is considered. Otherwise,\nthe test will fail, and you will need to provide a qualifier of some sort to identify\nwhich of the `CustomService` beans you want to spy.\n\nThe following example uses a by-name lookup, rather than a by-type lookup.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\tclass BeanOverrideTests {\n\n @MockitoSpyBean(\"service\") // <1>\n CustomService customService;\n\n // tests...\n\t}\n----\n<1> Wrap the bean named `service` with a Mockito spy.\n======\n\nThe following `@SharedSpies` annotation registers two spies by-type and one spy by-name.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@MockitoSpyBean(types = {OrderService.class, UserService.class}) // <1>\n\t@MockitoSpyBean(name = \"ps1\", types = PrintingService.class) // <2>\n\tpublic @interface SharedSpies {\n\t}\n----\n<1> Register `OrderService` and `UserService` spies by-type.\n<2> Register `PrintingService` spy by-name.\n======\n\nThe following demonstrates how `@SharedSpies` can be used on a test class.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\t@SharedSpies // <1>\n\tclass BeanOverrideTests {\n\n @Autowired OrderService orderService; // <2>\n\n @Autowired UserService userService; // <2>\n\n @Autowired PrintingService ps1; // <2>\n\n // Inject other components that rely on the spies.\n\n @Test\n void testThatDependsOnMocks() {\n // ...\n }\n\t}\n----\n<1> Register common spies via the custom `@SharedSpies` annotation.\n<2> Optionally inject spies to _stub_ or _verify_ them.\n======\n\nTIP: The spies can also be injected into `@Configuration` classes or other test-related\ncomponents in the `ApplicationContext` in order to configure them with Mockito's stubbing\nAPIs.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-mockitobean.adoc", "title": "annotation-mockitobean", "heading": "`@MockitoSpyBean` Examples", "heading_level": 2, "file_order": 202, "section_index": 2, "content_hash": "e85feb63255d18a55b16782b16aa00a8dd8b4712b682ac2075c72f0a674208fe", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-mockitobean.adoc"}}
{"id": "sha256:420941abc80b1d1cd23b33507bec6463101dd5ff3cb2dab40738c8e694745862", "content": "[[spring-testing-annotation-recordapplicationevents]]\n\n`@RecordApplicationEvents` is an annotation that can be applied to a test class to\ninstruct the _Spring TestContext Framework_ to record all application events that are\npublished in the `ApplicationContext` during the execution of a single test.\n\nThe recorded events can be accessed via the `ApplicationEvents` API within tests.\n\nSee xref:testing/testcontext-framework/application-events.adoc[Application Events] and the\n{spring-framework-api}/test/context/event/RecordApplicationEvents.html[`@RecordApplicationEvents`\njavadoc] for an example and further details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-recordapplicationevents.adoc", "title": "annotation-recordapplicationevents", "heading": "annotation-recordapplicationevents", "heading_level": 1, "file_order": 203, "section_index": 0, "content_hash": "420941abc80b1d1cd23b33507bec6463101dd5ff3cb2dab40738c8e694745862", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-recordapplicationevents.adoc"}}
{"id": "sha256:8a6e25e27d2687d9b3b7c7f3122389e6cafe337b4d4f9123293ec4f9c9feb7c1", "content": "[[spring-testing-annotation-rollback]]\n\n`@Rollback` indicates whether the transaction for a transactional test method should be\nrolled back after the test method has completed. If `true`, the transaction is rolled\nback. Otherwise, the transaction is committed (see also\nxref:testing/annotations/integration-spring/annotation-commit.adoc[`@Commit`]). Rollback for integration tests in the Spring\nTestContext Framework defaults to `true` even if `@Rollback` is not explicitly declared.\n\nWhen declared as a class-level annotation, `@Rollback` defines the default rollback\nsemantics for all test methods within the test class hierarchy. When declared as a\nmethod-level annotation, `@Rollback` defines rollback semantics for the specific test\nmethod, potentially overriding class-level `@Rollback` or `@Commit` semantics.\n\nThe following example causes a test method's result to not be rolled back (that is, the\nresult is committed to the database):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Rollback(false) // <1>\n\t@Test\n\tvoid testProcessWithoutRollback() {\n // ...\n\t}\n----\n<1> Do not roll back the result.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Rollback(false) // <1>\n\t@Test\n\tfun testProcessWithoutRollback() {\n // ...\n\t}\n----\n<1> Do not roll back the result.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-rollback.adoc", "title": "annotation-rollback", "heading": "annotation-rollback", "heading_level": 1, "file_order": 204, "section_index": 0, "content_hash": "8a6e25e27d2687d9b3b7c7f3122389e6cafe337b4d4f9123293ec4f9c9feb7c1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-rollback.adoc"}}
{"id": "sha256:d14359ca2ee40edc7ac3ba21c7859ba2f5b81a1eecdb5462e815b1952a6e75ca", "content": "[[spring-testing-annotation-sql]]\n\n`@Sql` is used to annotate a test class or test method to configure SQL scripts to be run\nagainst a given database during integration tests. The following example shows how to use\nit:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\t@Sql({\"/test-schema.sql\", \"/test-user-data.sql\"}) // <1>\n\tvoid userTest() {\n // run code that relies on the test schema and test data\n\t}\n----\n<1> Run two scripts for this test.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\t@Sql(\"/test-schema.sql\", \"/test-user-data.sql\") // <1>\n\tfun userTest() {\n // run code that relies on the test schema and test data\n\t}\n----\n<1> Run two scripts for this test.\n======\n\nSee xref:testing/testcontext-framework/executing-sql.adoc#testcontext-executing-sql-declaratively[Executing SQL scripts declaratively with @Sql]\nfor further details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-sql.adoc", "title": "annotation-sql", "heading": "annotation-sql", "heading_level": 1, "file_order": 205, "section_index": 0, "content_hash": "d14359ca2ee40edc7ac3ba21c7859ba2f5b81a1eecdb5462e815b1952a6e75ca", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-sql.adoc"}}
{"id": "sha256:ee754a9e939002c9a625265147e22250de613d8ba46f6daee987fbb9a03ff92b", "content": "[[spring-testing-annotation-sqlconfig]]\n\n`@SqlConfig` defines metadata that is used to determine how to parse and run SQL scripts\nconfigured with the `@Sql` annotation. The following example shows how to use it:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\t@Sql(\n scripts = \"/test-user-data.sql\",\n config = @SqlConfig(commentPrefix = \"`\", separator = \"@@\") // <1>\n\t)\n\tvoid userTest() {\n // run code that relies on the test data\n\t}\n----\n<1> Set the comment prefix and the separator in SQL scripts.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\t@Sql(\"/test-user-data.sql\", config = SqlConfig(commentPrefix = \"`\", separator = \"@@\")) // <1>\n\tfun userTest() {\n // run code that relies on the test data\n\t}\n----\n<1> Set the comment prefix and the separator in SQL scripts.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-sqlconfig.adoc", "title": "annotation-sqlconfig", "heading": "annotation-sqlconfig", "heading_level": 1, "file_order": 206, "section_index": 0, "content_hash": "ee754a9e939002c9a625265147e22250de613d8ba46f6daee987fbb9a03ff92b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-sqlconfig.adoc"}}
{"id": "sha256:e507d2f7f0eb4d1d875c9889c38a000c7e9bfdc0f3f8a8eefd8fdc349460ba85", "content": "[[spring-testing-annotation-sqlgroup]]\n\n`@SqlGroup` is a container annotation that aggregates several `@Sql` annotations. You can\nuse `@SqlGroup` natively to declare several nested `@Sql` annotations, or you can use it\nin conjunction with Java's support for repeatable annotations, where `@Sql` can be\ndeclared several times on the same class or method, implicitly generating this container\nannotation. The following example shows how to declare an SQL group:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\t@SqlGroup({ // <1>\n @Sql(scripts = \"/test-schema.sql\", config = @SqlConfig(commentPrefix = \"`\")),\n @Sql(\"/test-user-data.sql\")\n\t})\n\tvoid userTest() {\n // run code that uses the test schema and test data\n\t}\n----\n<1> Declare a group of SQL scripts.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\t@SqlGroup( // <1>\n Sql(\"/test-schema.sql\", config = SqlConfig(commentPrefix = \"`\")),\n Sql(\"/test-user-data.sql\"))\n\tfun userTest() {\n // run code that uses the test schema and test data\n\t}\n----\n<1> Declare a group of SQL scripts.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-sqlgroup.adoc", "title": "annotation-sqlgroup", "heading": "annotation-sqlgroup", "heading_level": 1, "file_order": 207, "section_index": 0, "content_hash": "e507d2f7f0eb4d1d875c9889c38a000c7e9bfdc0f3f8a8eefd8fdc349460ba85", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-sqlgroup.adoc"}}
{"id": "sha256:79d0ea36f2dd3270b40b20e2f1671ba4df995dd427dcba67b6798e135da7edb7", "content": "[[spring-testing-annotation-sqlmergemode]]\n\n`@SqlMergeMode` is used to annotate a test class or test method to configure whether\nmethod-level `@Sql` declarations are merged with class-level `@Sql` declarations. If\n`@SqlMergeMode` is not declared on a test class or test method, the `OVERRIDE` merge mode\nwill be used by default. With the `OVERRIDE` mode, method-level `@Sql` declarations will\neffectively override class-level `@Sql` declarations.\n\nNote that a method-level `@SqlMergeMode` declaration overrides a class-level declaration.\n\nThe following example shows how to use `@SqlMergeMode` at the class level.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\t@Sql(\"/test-schema.sql\")\n\t@SqlMergeMode(MERGE) // <1>\n\tclass UserTests {\n\n @Test\n @Sql(\"/user-test-data-001.sql\")\n void standardUserProfile() {\n // run code that relies on test data set 001\n }\n\t}\n----\n<1> Set the `@Sql` merge mode to `MERGE` for all test methods in the class.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig::class)\n\t@Sql(\"/test-schema.sql\")\n\t@SqlMergeMode(MERGE) // <1>\n\tclass UserTests {\n\n @Test\n @Sql(\"/user-test-data-001.sql\")\n fun standardUserProfile() {\n // run code that relies on test data set 001\n }\n\t}\n----\n<1> Set the `@Sql` merge mode to `MERGE` for all test methods in the class.\n======\n\nThe following example shows how to use `@SqlMergeMode` at the method level.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\t@Sql(\"/test-schema.sql\")\n\tclass UserTests {\n\n @Test\n @Sql(\"/user-test-data-001.sql\")\n @SqlMergeMode(MERGE) // <1>\n void standardUserProfile() {\n // run code that relies on test data set 001\n }\n\t}\n----\n<1> Set the `@Sql` merge mode to `MERGE` for a specific test method.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig::class)\n\t@Sql(\"/test-schema.sql\")\n\tclass UserTests {\n\n @Test\n @Sql(\"/user-test-data-001.sql\")\n @SqlMergeMode(MERGE) // <1>\n fun standardUserProfile() {\n // run code that relies on test data set 001\n }\n\t}\n----\n<1> Set the `@Sql` merge mode to `MERGE` for a specific test method.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-sqlmergemode.adoc", "title": "annotation-sqlmergemode", "heading": "annotation-sqlmergemode", "heading_level": 1, "file_order": 208, "section_index": 0, "content_hash": "79d0ea36f2dd3270b40b20e2f1671ba4df995dd427dcba67b6798e135da7edb7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-sqlmergemode.adoc"}}
{"id": "sha256:f26f1ddd6713301ce0aa35740cdcd77d268940e87beb22bf3f7f757cc732ea90", "content": "[[spring-testing-annotation-beanoverriding-testbean]]\n\n{spring-framework-api}/test/context/bean/override/convention/TestBean.html[`@TestBean`]\nis used on a non-static field in a test class to override a specific bean in the test's\n`ApplicationContext` with an instance provided by a factory method.\n\nThe associated factory method name is derived from the annotated field's name, or the\nbean name if specified. The factory method must be `static`, accept no arguments, and\nhave a return type compatible with the type of the bean to override. To make things more\nexplicit, or if you'd rather use a different name, the annotation allows for a specific\nmethod name to be provided.\n\nBy default, the annotated field's type is used to search for candidate beans to override.\nIf multiple candidates match, `@Qualifier` can be provided to narrow the candidate to\noverride. Alternatively, a candidate whose bean name matches the name of the field will\nmatch.\n\nA bean will be created if a corresponding bean does not exist. However, if you would like\nfor the test to fail when a corresponding bean does not exist, you can set the\n`enforceOverride` attribute to `true` â€“ for example, `@TestBean(enforceOverride = true)`.\n\nTo use a by-name override rather than a by-type override, specify the `name` attribute\nof the annotation.\n\n[WARNING]\n====\nQualifiers, including the name of the field, are used to determine if a separate\n`ApplicationContext` needs to be created. If you are using this feature to override the\nsame bean in several tests, make sure to name the field consistently to avoid creating\nunnecessary contexts.\n====\n\n[WARNING]\n====\nUsing `@TestBean` in conjunction with `@ContextHierarchy` can lead to undesirable results\nsince each `@TestBean` will be applied to all context hierarchy levels by default. To\nensure that a particular `@TestBean` is applied to a single context hierarchy level, set\nthe `contextName` attribute to match a configured `@ContextConfiguration` name â€“ for\nexample, `@TestBean(contextName = \"app-config\")`.\n\nSee\nxref:testing/testcontext-framework/ctx-management/hierarchies.adoc#testcontext-ctx-management-ctx-hierarchies-with-bean-overrides[context\nhierarchies with bean overrides] for further details and examples.\n====\n\n[NOTE]\n====\nThere are no restrictions on the visibility of `@TestBean` fields or factory methods.\n\nSuch fields and methods can therefore be `public`, `protected`, package-private (default\nvisibility), or `private` depending on the needs or coding practices of the project.\n====\n\nThe following example shows how to use the default behavior of the `@TestBean` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass OverrideBeanTests {\n @TestBean // <1>\n CustomService customService;\n\n // test case body...\n\n static CustomService customService() { // <2>\n return new MyFakeCustomService();\n }\n\t}\n----\n<1> Mark a field for overriding the bean with type `CustomService`.\n<2> The result of this static method will be used as the instance and injected into the field.\n======\n\nIn the example above, we are overriding the bean with type `CustomService`. If more than\none bean of that type exists, the bean named `customService` is considered. Otherwise,\nthe test will fail, and you will need to provide a qualifier of some sort to identify\nwhich of the `CustomService` beans you want to override.\n\nThe following example uses a by-name lookup, rather than a by-type lookup:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass OverrideBeanTests {\n @TestBean(name = \"service\", methodName = \"createCustomService\") // <1>\n CustomService customService;\n\n // test case body...\n\n static CustomService createCustomService() { // <2>\n return new MyFakeCustomService();\n }\n\t}\n----\n<1> Mark a field for overriding the bean with name `service`, and specify that the\n factory method is named `createCustomService`.\n<2> The result of this static method will be used as the instance and injected into the field.\n======\n\n[TIP]\n====\nTo locate the factory method to invoke, Spring searches in the class in which the\n`@TestBean` field is declared, in one of its superclasses, or in any implemented\ninterfaces. If the `@TestBean` field is declared in a `@Nested` test class, the enclosing\nclass hierarchy will also be searched.\n\nAlternatively, a factory method in an external class can be referenced via its\nfully-qualified method name following the syntax `<fully-qualified class name>#<method name>`\nâ€“ for example, `methodName = \"org.example.TestUtils#createCustomService\"`.\n====\n\n[NOTE]\n====\nWhen overriding a non-singleton bean, the non-singleton bean will be replaced with a\nsingleton bean corresponding to the value returned from the `@TestBean` factory method,\nand the corresponding bean definition will be converted to a `singleton`. Consequently,\nif `@TestBean` is used to override a `prototype` or scoped bean, the overridden bean will\nbe treated as a `singleton`.\n\nSimilarly, when overriding a bean created by a `FactoryBean`, the `FactoryBean` will be\nreplaced with a singleton bean corresponding to the value returned from the `@TestBean`\nfactory method.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-testbean.adoc", "title": "annotation-testbean", "heading": "annotation-testbean", "heading_level": 1, "file_order": 209, "section_index": 0, "content_hash": "f26f1ddd6713301ce0aa35740cdcd77d268940e87beb22bf3f7f757cc732ea90", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-testbean.adoc"}}
{"id": "sha256:752411f44557ac987409ba8e665a8003a71cc90d50bce7db36ef348d1e3ffe14", "content": "[[spring-testing-annotation-testexecutionlisteners]]\n\n`@TestExecutionListeners` is used to register listeners for the annotated test class, its\nsubclasses, and its nested classes. If you wish to register a listener globally, you\nshould register it via the automatic discovery mechanism described in\nxref:testing/testcontext-framework/tel-config.adoc[`TestExecutionListener` Configuration].\n\nThe following example shows how to register two `TestExecutionListener` implementations:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestExecutionListeners({CustomTestExecutionListener.class, AnotherTestExecutionListener.class}) // <1>\n\tclass CustomTestExecutionListenerTests {\n // class body...\n\t}\n----\n<1> Register two `TestExecutionListener` implementations.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestExecutionListeners(CustomTestExecutionListener::class, AnotherTestExecutionListener::class) // <1>\n\tclass CustomTestExecutionListenerTests {\n // class body...\n\t}\n----\n<1> Register two `TestExecutionListener` implementations.\n======\n\nBy default, `@TestExecutionListeners` provides support for inheriting listeners from\nsuperclasses or enclosing classes. See\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-nested-test-configuration[`@Nested` test class configuration]\nand the {spring-framework-api}/test/context/TestExecutionListeners.html[`@TestExecutionListeners` javadoc]\nfor an example and further details. If you discover that you need to switch\nback to using the default `TestExecutionListener` implementations, see the note in\nxref:testing/testcontext-framework/tel-config.adoc#testcontext-tel-config-registering-tels[Registering `TestExecutionListener` Implementations].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-testexecutionlisteners.adoc", "title": "annotation-testexecutionlisteners", "heading": "annotation-testexecutionlisteners", "heading_level": 1, "file_order": 210, "section_index": 0, "content_hash": "752411f44557ac987409ba8e665a8003a71cc90d50bce7db36ef348d1e3ffe14", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-testexecutionlisteners.adoc"}}
{"id": "sha256:e32a7ce605c3f05a00a7c236bca95e4c8339da2d9732140f2f6e9451f4ada091", "content": "[[spring-testing-annotation-testpropertysource]]\n\n`@TestPropertySource` is an annotation that can be applied to a test class to configure\nthe locations of properties files and inlined properties to be added to the set of\n`PropertySources` in the `Environment` for an `ApplicationContext` loaded for an\nintegration test.\n\nThe following example demonstrates how to declare a properties file from the classpath:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestPropertySource(\"/test.properties\") // <1>\n\tclass MyIntegrationTests {\n // class body...\n\t}\n----\n<1> Get properties from `test.properties` in the root of the classpath.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestPropertySource(\"/test.properties\") // <1>\n\tclass MyIntegrationTests {\n // class body...\n\t}\n----\n<1> Get properties from `test.properties` in the root of the classpath.\n======\n\nThe following example demonstrates how to declare inlined properties:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestPropertySource(properties = { \"timezone = GMT\", \"port: 4242\" }) // <1>\n\tclass MyIntegrationTests {\n // class body...\n\t}\n----\n<1> Declare `timezone` and `port` properties.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestPropertySource(properties = [\"timezone = GMT\", \"port: 4242\"]) // <1>\n\tclass MyIntegrationTests {\n // class body...\n\t}\n----\n<1> Declare `timezone` and `port` properties.\n======\n\nSee xref:testing/testcontext-framework/ctx-management/property-sources.adoc[Context Configuration with Test Property Sources]\nfor examples and further details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-testpropertysource.adoc", "title": "annotation-testpropertysource", "heading": "annotation-testpropertysource", "heading_level": 1, "file_order": 211, "section_index": 0, "content_hash": "e32a7ce605c3f05a00a7c236bca95e4c8339da2d9732140f2f6e9451f4ada091", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-testpropertysource.adoc"}}
{"id": "sha256:d952239d3fe8baa88b6c7d6eaed346d1a2172dfaf80c418578a64ea00497a99b", "content": "[[spring-testing-annotation-webappconfiguration]]\n\n`@WebAppConfiguration` is an annotation that can be applied to a test class to declare\nthat the `ApplicationContext` loaded for an integration test should be a\n`WebApplicationContext`. The mere presence of `@WebAppConfiguration` on a test class\nensures that a `WebApplicationContext` is loaded for the test, using the default value of\n`\"file:src/main/webapp\"` for the path to the root of the web application (that is, the\nresource base path). The resource base path is used behind the scenes to create a\n`MockServletContext`, which serves as the `ServletContext` for the test's\n`WebApplicationContext`.\n\nThe following example shows how to use the `@WebAppConfiguration` annotation:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@WebAppConfiguration // <1>\n\tclass WebAppTests {\n // class body...\n\t}\n----\n<1> The `@WebAppConfiguration` annotation.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@WebAppConfiguration // <1>\n\tclass WebAppTests {\n // class body...\n\t}\n----\n<1> The `@WebAppConfiguration` annotation.\n======\n--\n\nTo override the default, you can specify a different base resource path by using the\nimplicit `value` attribute. Both `classpath:` and `file:` resource prefixes are\nsupported. If no resource prefix is supplied, the path is assumed to be a file system\nresource. The following example shows how to specify a classpath resource:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@WebAppConfiguration(\"classpath:test-web-resources\") // <1>\n\tclass WebAppTests {\n // class body...\n\t}\n----\n<1> Specifying a classpath resource.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@WebAppConfiguration(\"classpath:test-web-resources\") // <1>\n\tclass WebAppTests {\n // class body...\n\t}\n----\n<1> Specifying a classpath resource.\n======\n--\n\nNote that `@WebAppConfiguration` must be used in conjunction with\n`@ContextConfiguration`, either within a single test class or within a test class\nhierarchy. See the\n{spring-framework-api}/test/context/web/WebAppConfiguration.html[`@WebAppConfiguration`]\njavadoc for further details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-webappconfiguration.adoc", "title": "annotation-webappconfiguration", "heading": "annotation-webappconfiguration", "heading_level": 1, "file_order": 212, "section_index": 0, "content_hash": "d952239d3fe8baa88b6c7d6eaed346d1a2172dfaf80c418578a64ea00497a99b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring/annotation-webappconfiguration.adoc"}}
{"id": "sha256:170447a010aadd4836e26ce753ebb9de1b89c55455ab127f5b7543015e0c61af", "content": "[[integration-testing-annotations-junit-jupiter]]\n\nThe following annotations are supported when used in conjunction with the\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-extension[`SpringExtension`]\nand JUnit Jupiter (that is, the programming model in JUnit):\n\n* xref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-springextensionconfig[`@SpringExtensionConfig`]\n* xref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-junit-jupiter-springjunitconfig[`@SpringJUnitConfig`]\n* xref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-junit-jupiter-springjunitwebconfig[`@SpringJUnitWebConfig`]\n* xref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-testconstructor[`@TestConstructor`]\n* xref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-nestedtestconfiguration[`@NestedTestConfiguration`]\n* xref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-junit-jupiter-enabledif[`@EnabledIf`]\n* xref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-junit-jupiter-disabledif[`@DisabledIf`]\n* xref:testing/annotations/integration-spring/annotation-disabledinaotmode.adoc[`@DisabledInAotMode`]\n\n[[integration-testing-annotations-springextensionconfig]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc", "title": "integration-junit-jupiter", "heading": "integration-junit-jupiter", "heading_level": 1, "file_order": 213, "section_index": 0, "content_hash": "170447a010aadd4836e26ce753ebb9de1b89c55455ab127f5b7543015e0c61af", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc"}}
{"id": "sha256:1c05471de0bde84ee35c75d03cc5f54517103f079dbc9dad87127c892852a715", "content": "`@SpringExtensionConfig` is a type-level annotation that can be used to configure the\nbehavior of the `SpringExtension`.\n\nAs of Spring Framework 7.0, the `SpringExtension` is configured to use a test-method\nscoped `ExtensionContext`, which enables consistent dependency injection into fields and\nconstructors from the `ApplicationContext` for the current test method in a `@Nested`\ntest class hierarchy. However, if a third-party `TestExecutionListener` is not compatible\nwith the semantics associated with a test-method scoped extension context â€” or if a\ndeveloper wishes to switch to test-class scoped semantics â€” the `SpringExtension` can be\nconfigured to use a test-class scoped `ExtensionContext` by annotating a top-level test\nclass with `@SpringExtensionConfig(useTestClassScopedExtensionContext = true)`.\n\n[TIP]\n====\nIf your top-level test class is configured to use JUnit Jupiter's\n`@TestInstance(Lifecycle.PER_CLASS)` semantics, the `SpringExtension` will always use a\ntest-class scoped `ExtensionContext`, and there is no need to declare\n`@SpringExtensionConfig(useTestClassScopedExtensionContext = true)`.\n====\n\n[NOTE]\n====\nThis annotation is currently only applicable to `@Nested` test class hierarchies and\nshould be applied to the top-level enclosing class of a `@Nested` test class hierarchy.\n\nConsequently, there is no need to declare this annotation on a test class that does not\ncontain `@Nested` test classes.\n====\n\n[NOTE]\n====\nxref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-nestedtestconfiguration[`@NestedTestConfiguration`]\ndoes not apply to this annotation.\n\n`@SpringExtensionConfig` will always be detected within a `@Nested` test class hierarchy,\neffectively disregarding any `@NestedTestConfiguration(OVERRIDE)` declarations.\n====\n\n[[integration-testing-annotations-junit-jupiter-springjunitconfig]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc", "title": "integration-junit-jupiter", "heading": "`@SpringExtensionConfig`", "heading_level": 2, "file_order": 213, "section_index": 1, "content_hash": "1c05471de0bde84ee35c75d03cc5f54517103f079dbc9dad87127c892852a715", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc"}}
{"id": "sha256:38e98730aae6e8ae1a98009c5f5d4e1c81b69d994aa404a94244deb7ad474df9", "content": "`@SpringJUnitConfig` is a composed annotation that combines\n`@ExtendWith(SpringExtension.class)` from JUnit Jupiter with `@ContextConfiguration` from\nthe Spring TestContext Framework. It can be used at the class level as a drop-in\nreplacement for `@ContextConfiguration`. With regard to configuration options, the only\ndifference between `@ContextConfiguration` and `@SpringJUnitConfig` is that component\nclasses may be declared with the `value` attribute in `@SpringJUnitConfig`.\n\nThe following example shows how to use the `@SpringJUnitConfig` annotation to specify a\nconfiguration class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class) // <1>\n\tclass ConfigurationClassJUnitJupiterSpringTests {\n // class body...\n\t}\n----\n<1> Specify the configuration class.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig::class) // <1>\n\tclass ConfigurationClassJUnitJupiterSpringTests {\n // class body...\n\t}\n----\n<1> Specify the configuration class.\n======\n\nThe following example shows how to use the `@SpringJUnitConfig` annotation to specify the\nlocation of a configuration file:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(locations = \"/test-config.xml\") // <1>\n\tclass XmlJUnitJupiterSpringTests {\n // class body...\n\t}\n----\n<1> Specify the location of a configuration file.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(locations = [\"/test-config.xml\"]) // <1>\n\tclass XmlJUnitJupiterSpringTests {\n // class body...\n\t}\n----\n<1> Specify the location of a configuration file.\n======\n\nSee xref:testing/testcontext-framework/ctx-management.adoc[Context Management] as well as the javadoc for\n{spring-framework-api}/test/context/junit/jupiter/SpringJUnitConfig.html[`@SpringJUnitConfig`]\nand `@ContextConfiguration` for further details.\n\n[[integration-testing-annotations-junit-jupiter-springjunitwebconfig]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc", "title": "integration-junit-jupiter", "heading": "`@SpringJUnitConfig`", "heading_level": 2, "file_order": 213, "section_index": 2, "content_hash": "38e98730aae6e8ae1a98009c5f5d4e1c81b69d994aa404a94244deb7ad474df9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc"}}
{"id": "sha256:bf1fc41e8772243f928efa30608229da301f46180a0980e2ccdd2c757d03ee7f", "content": "`@SpringJUnitWebConfig` is a composed annotation that combines\n`@ExtendWith(SpringExtension.class)` from JUnit Jupiter with `@ContextConfiguration` and\n`@WebAppConfiguration` from the Spring TestContext Framework. You can use it at the class\nlevel as a drop-in replacement for `@ContextConfiguration` and `@WebAppConfiguration`.\nWith regard to configuration options, the only difference between `@ContextConfiguration`\nand `@SpringJUnitWebConfig` is that you can declare component classes by using the\n`value` attribute in `@SpringJUnitWebConfig`. In addition, you can override the `value`\nattribute from `@WebAppConfiguration` only by using the `resourcePath` attribute in\n`@SpringJUnitWebConfig`.\n\nThe following example shows how to use the `@SpringJUnitWebConfig` annotation to specify\na configuration class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig(TestConfig.class) // <1>\n\tclass ConfigurationClassJUnitJupiterSpringWebTests {\n // class body...\n\t}\n----\n<1> Specify the configuration class.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig(TestConfig::class) // <1>\n\tclass ConfigurationClassJUnitJupiterSpringWebTests {\n // class body...\n\t}\n----\n<1> Specify the configuration class.\n======\n\nThe following example shows how to use the `@SpringJUnitWebConfig` annotation to specify the\nlocation of a configuration file:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig(locations = \"/test-config.xml\") // <1>\n\tclass XmlJUnitJupiterSpringWebTests {\n // class body...\n\t}\n----\n<1> Specify the location of a configuration file.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig(locations = [\"/test-config.xml\"]) // <1>\n\tclass XmlJUnitJupiterSpringWebTests {\n // class body...\n\t}\n----\n<1> Specify the location of a configuration file.\n======\n\nSee xref:testing/testcontext-framework/ctx-management.adoc[Context Management] as well as the javadoc for\n{spring-framework-api}/test/context/junit/jupiter/web/SpringJUnitWebConfig.html[`@SpringJUnitWebConfig`],\n{spring-framework-api}/test/context/ContextConfiguration.html[`@ContextConfiguration`], and\n{spring-framework-api}/test/context/web/WebAppConfiguration.html[`@WebAppConfiguration`]\nfor further details.\n\n[[integration-testing-annotations-testconstructor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc", "title": "integration-junit-jupiter", "heading": "`@SpringJUnitWebConfig`", "heading_level": 2, "file_order": 213, "section_index": 3, "content_hash": "bf1fc41e8772243f928efa30608229da301f46180a0980e2ccdd2c757d03ee7f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc"}}
{"id": "sha256:6120207b54020f73d2809a29b3f80601ef12d398127f17f7f3d293b07dd23718", "content": "`@TestConstructor` is an annotation that can be applied to a test class to configure how\nthe parameters of a test class constructor are autowired from components in the test's\n`ApplicationContext`.\n\nIf `@TestConstructor` is not present or meta-present on a test class, the default _test\nconstructor autowire mode_ will be used. See the tip below for details on how to change\nthe default mode. Note, however, that a local declaration of `@Autowired` or\n`@jakarta.inject.Inject` on a constructor takes precedence over both `@TestConstructor`\nand the default mode.\n\n.Changing the default test constructor autowire mode\n[TIP]\n=====\nThe default _test constructor autowire mode_ can be changed by setting the\n`spring.test.constructor.autowire.mode` JVM system property to `all`. Alternatively, the\ndefault mode may be set via the\nxref:appendix.adoc#appendix-spring-properties[`SpringProperties`] mechanism.\n\nThe default mode may also be configured as a\nhttps://docs.junit.org/current/running-tests/configuration-parameters.html[JUnit Platform configuration parameter].\n\nIf the `spring.test.constructor.autowire.mode` property is not set, test class\nconstructors will not be automatically autowired.\n=====\n\nNOTE: `@TestConstructor` is only supported in conjunction with the `SpringExtension` for\nuse with JUnit Jupiter. Note that the `SpringExtension` is often automatically registered\nfor you â€“ for example, when using annotations such as `@SpringJUnitConfig` and\n`@SpringJUnitWebConfig` or various test-related annotations from Spring Boot Test.\n\n[[integration-testing-annotations-nestedtestconfiguration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc", "title": "integration-junit-jupiter", "heading": "`@TestConstructor`", "heading_level": 2, "file_order": 213, "section_index": 4, "content_hash": "6120207b54020f73d2809a29b3f80601ef12d398127f17f7f3d293b07dd23718", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc"}}
{"id": "sha256:e7a266aba971339321cf8d3452e7a4cdb204db5c4c67d6189518f02536f8e601", "content": "`@NestedTestConfiguration` is an annotation that can be applied to a test class to\nconfigure how Spring test configuration annotations are processed within enclosing class\nhierarchies for inner test classes.\n\nIf `@NestedTestConfiguration` is not present or meta-present on a test class, in its\nsupertype hierarchy, or in its enclosing class hierarchy, the default _enclosing\nconfiguration inheritance mode_ will be used. See the tip below for details on how to\nchange the default mode.\n\n.Changing the default enclosing configuration inheritance mode\n[TIP]\n=====\nThe default _enclosing configuration inheritance mode_ is `INHERIT`, but it can be\nchanged by setting the `spring.test.enclosing.configuration` JVM system property to\n`OVERRIDE`. Alternatively, the default mode may be set via the\nxref:appendix.adoc#appendix-spring-properties[`SpringProperties`] mechanism.\n=====\n\nThe xref:testing/testcontext-framework.adoc[Spring TestContext Framework] honors `@NestedTestConfiguration` semantics for the\nfollowing annotations.\n\n* xref:testing/annotations/integration-spring/annotation-bootstrapwith.adoc[`@BootstrapWith`]\n* xref:testing/annotations/integration-spring/annotation-contextconfiguration.adoc[`@ContextConfiguration`]\n* xref:testing/annotations/integration-spring/annotation-webappconfiguration.adoc[`@WebAppConfiguration`]\n* xref:testing/annotations/integration-spring/annotation-contexthierarchy.adoc[`@ContextHierarchy`]\n* xref:testing/annotations/integration-spring/annotation-contextcustomizerfactories.adoc[`@ContextCustomizerFactories`]\n* xref:testing/annotations/integration-spring/annotation-activeprofiles.adoc[`@ActiveProfiles`]\n* xref:testing/annotations/integration-spring/annotation-testpropertysource.adoc[`@TestPropertySource`]\n* xref:testing/annotations/integration-spring/annotation-dynamicpropertysource.adoc[`@DynamicPropertySource`]\n* xref:testing/annotations/integration-spring/annotation-dirtiescontext.adoc[`@DirtiesContext`]\n* xref:testing/annotations/integration-spring/annotation-testexecutionlisteners.adoc[`@TestExecutionListeners`]\n* xref:testing/annotations/integration-spring/annotation-recordapplicationevents.adoc[`@RecordApplicationEvents`]\n* xref:testing/testcontext-framework/tx.adoc[`@Transactional`]\n* xref:testing/annotations/integration-spring/annotation-commit.adoc[`@Commit`]\n* xref:testing/annotations/integration-spring/annotation-rollback.adoc[`@Rollback`]\n* xref:testing/annotations/integration-spring/annotation-sql.adoc[`@Sql`]\n* xref:testing/annotations/integration-spring/annotation-sqlconfig.adoc[`@SqlConfig`]\n* xref:testing/annotations/integration-spring/annotation-sqlmergemode.adoc[`@SqlMergeMode`]\n* xref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-testconstructor[`@TestConstructor`]\n\nNOTE: The use of `@NestedTestConfiguration` typically only makes sense in conjunction\nwith `@Nested` test classes in JUnit Jupiter; however, there may be other testing\nframeworks with support for Spring and nested test classes that make use of this\nannotation.\n\nSee xref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-nested-test-configuration[`@Nested` test class configuration]\nfor an example and further details.\n\n[[integration-testing-annotations-junit-jupiter-enabledif]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc", "title": "integration-junit-jupiter", "heading": "`@NestedTestConfiguration`", "heading_level": 2, "file_order": 213, "section_index": 5, "content_hash": "e7a266aba971339321cf8d3452e7a4cdb204db5c4c67d6189518f02536f8e601", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc"}}
{"id": "sha256:ae578ababa39a6604630742a2deba49f7e310c6bfeedc5162563e4ae511e0439", "content": "`@EnabledIf` is used to signal that the annotated JUnit Jupiter test class or test method\nis enabled and should be run if the supplied `expression` evaluates to `true`.\nSpecifically, if the expression evaluates to `Boolean.TRUE` or a `String` equal to `true`\n(ignoring case), the test is enabled. When applied at the class level, all test methods\nwithin that class are automatically enabled by default as well.\n\nExpressions can be any of the following:\n\n* xref:core/expressions.adoc[Spring Expression Language] (SpEL) expression. For example:\n `@EnabledIf(\"#{systemProperties['os.name'].toLowerCase().contains('mac')}\")`\n* Placeholder for a property available in the Spring xref:core/beans/environment.adoc[`Environment`].\n For example: `@EnabledIf(\"${smoke.tests.enabled}\")`\n* Text literal. For example: `@EnabledIf(\"true\")`\n\nNote, however, that a text literal that is not the result of dynamic resolution of a\nproperty placeholder is of zero practical value, since `@EnabledIf(\"false\")` is\nequivalent to `@Disabled` and `@EnabledIf(\"true\")` is logically meaningless.\n\nYou can use `@EnabledIf` as a meta-annotation to create custom composed annotations. For\nexample, you can create a custom `@EnabledOnMac` annotation as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@EnabledIf(\n expression = \"#{systemProperties['os.name'].toLowerCase().contains('mac')}\",\n reason = \"Enabled on Mac OS\"\n\t)\n\tpublic @interface EnabledOnMac {}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@EnabledIf(\n expression = \"#{systemProperties['os.name'].toLowerCase().contains('mac')}\",\n reason = \"Enabled on Mac OS\"\n\t)\n\tannotation class EnabledOnMac {}\n----\n======\n\n[NOTE]\n====\n`@EnabledOnMac` is meant only as an example of what is possible. If you have that exact\nuse case, please use the built-in `@EnabledOnOs(MAC)` support in JUnit Jupiter.\n====\n\n[WARNING]\n====\nSince JUnit 5.7, JUnit Jupiter also has a condition annotation named `@EnabledIf`. Thus,\nif you wish to use Spring's `@EnabledIf` support make sure you import the annotation type\nfrom the correct package.\n====\n\n[[integration-testing-annotations-junit-jupiter-disabledif]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc", "title": "integration-junit-jupiter", "heading": "`@EnabledIf`", "heading_level": 2, "file_order": 213, "section_index": 6, "content_hash": "ae578ababa39a6604630742a2deba49f7e310c6bfeedc5162563e4ae511e0439", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc"}}
{"id": "sha256:49f8db1bbfa11073b647c0165180a627ede241317b7250ef714dcab1f81b3ee3", "content": "`@DisabledIf` is used to signal that the annotated JUnit Jupiter test class or test\nmethod is disabled and should not be run if the supplied `expression` evaluates to\n`true`. Specifically, if the expression evaluates to `Boolean.TRUE` or a `String` equal\nto `true` (ignoring case), the test is disabled. When applied at the class level, all\ntest methods within that class are automatically disabled as well.\n\nExpressions can be any of the following:\n\n* xref:core/expressions.adoc[Spring Expression Language] (SpEL) expression. For example:\n `@DisabledIf(\"#{systemProperties['os.name'].toLowerCase().contains('mac')}\")`\n* Placeholder for a property available in the Spring xref:core/beans/environment.adoc[`Environment`].\n For example: `@DisabledIf(\"${smoke.tests.disabled}\")`\n* Text literal. For example: `@DisabledIf(\"true\")`\n\nNote, however, that a text literal that is not the result of dynamic resolution of a\nproperty placeholder is of zero practical value, since `@DisabledIf(\"true\")` is\nequivalent to `@Disabled` and `@DisabledIf(\"false\")` is logically meaningless.\n\nYou can use `@DisabledIf` as a meta-annotation to create custom composed annotations. For\nexample, you can create a custom `@DisabledOnMac` annotation as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target({ElementType.TYPE, ElementType.METHOD})\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@DisabledIf(\n expression = \"#{systemProperties['os.name'].toLowerCase().contains('mac')}\",\n reason = \"Disabled on Mac OS\"\n\t)\n\tpublic @interface DisabledOnMac {}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@DisabledIf(\n expression = \"#{systemProperties['os.name'].toLowerCase().contains('mac')}\",\n reason = \"Disabled on Mac OS\"\n\t)\n\tannotation class DisabledOnMac {}\n----\n======\n\n[NOTE]\n====\n`@DisabledOnMac` is meant only as an example of what is possible. If you have that exact\nuse case, please use the built-in `@DisabledOnOs(MAC)` support in JUnit Jupiter.\n====\n\n[WARNING]\n====\nSince JUnit 5.7, JUnit Jupiter also has a condition annotation named `@DisabledIf`. Thus,\nif you wish to use Spring's `@DisabledIf` support make sure you import the annotation type\nfrom the correct package.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc", "title": "integration-junit-jupiter", "heading": "`@DisabledIf`", "heading_level": 2, "file_order": 213, "section_index": 7, "content_hash": "49f8db1bbfa11073b647c0165180a627ede241317b7250ef714dcab1f81b3ee3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit-jupiter.adoc"}}
{"id": "sha256:48bc29dd197d41019525c811244150966b563626fdb6f3192018e07772e8a906", "content": "[[integration-testing-annotations-junit4]]\n\n[WARNING]\n====\nJUnit 4 support is deprecated since Spring Framework 7.0 in favor of the\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-extension[`SpringExtension`]\nand JUnit Jupiter.\n====\n\nThe following annotations are supported only when used in conjunction with the\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit4-runner[SpringRunner],\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit4-rules[Spring's JUnit 4 rules], or\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-support-classes-junit4[Spring's JUnit 4 support classes]:\n\n* xref:testing/annotations/integration-junit4.adoc#integration-testing-annotations-junit4-ifprofilevalue[`@IfProfileValue`]\n* xref:testing/annotations/integration-junit4.adoc#integration-testing-annotations-junit4-profilevaluesourceconfiguration[`@ProfileValueSourceConfiguration`]\n* xref:testing/annotations/integration-junit4.adoc#integration-testing-annotations-junit4-timed[`@Timed`]\n* xref:testing/annotations/integration-junit4.adoc#integration-testing-annotations-junit4-repeat[`@Repeat`]\n\n[[integration-testing-annotations-junit4-ifprofilevalue]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit4.adoc", "title": "integration-junit4", "heading": "integration-junit4", "heading_level": 1, "file_order": 214, "section_index": 0, "content_hash": "48bc29dd197d41019525c811244150966b563626fdb6f3192018e07772e8a906", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit4.adoc"}}
{"id": "sha256:60bb4a95bb705ed3d91148828d79689abfd0fbfdbcb32c9df46fc5cd86cc7858", "content": "`@IfProfileValue` indicates that the annotated test class or test method is enabled for a\nspecific testing environment. If the configured `ProfileValueSource` returns a matching\n`value` for the provided `name`, the test is enabled. Otherwise, the test is disabled\nand, effectively, ignored.\n\nYou can apply `@IfProfileValue` at the class level, the method level, or both.\nClass-level usage of `@IfProfileValue` takes precedence over method-level usage for any\nmethods within that class or its subclasses. Specifically, a test is enabled if it is\nenabled both at the class level and at the method level. The absence of `@IfProfileValue`\nmeans the test is implicitly enabled. This is analogous to the semantics of JUnit 4's\n`@Ignore` annotation, except that the presence of `@Ignore` always disables a test.\n\nThe following example shows a test that has an `@IfProfileValue` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@IfProfileValue(name=\"java.vendor\", value=\"Oracle Corporation\") // <1>\n\t@Test\n\tpublic void testProcessWhichRunsOnlyOnOracleJvm() {\n // some logic that should run only on Java VMs from Oracle Corporation\n\t}\n----\n<1> Run this test only when the Java vendor is \"Oracle Corporation\".\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@IfProfileValue(name=\"java.vendor\", value=\"Oracle Corporation\") // <1>\n\t@Test\n\tfun testProcessWhichRunsOnlyOnOracleJvm() {\n // some logic that should run only on Java VMs from Oracle Corporation\n\t}\n----\n<1> Run this test only when the Java vendor is \"Oracle Corporation\".\n======\n\nAlternatively, you can configure `@IfProfileValue` with a list of `values` (with `OR`\nsemantics) to achieve TestNG-like support for test groups in a JUnit 4 environment.\nConsider the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@IfProfileValue(name=\"test-groups\", values={\"unit-tests\", \"integration-tests\"}) // <1>\n\t@Test\n\tpublic void testProcessWhichRunsForUnitOrIntegrationTestGroups() {\n // some logic that should run only for unit and integration test groups\n\t}\n----\n<1> Run this test for unit tests and integration tests.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@IfProfileValue(name=\"test-groups\", values=[\"unit-tests\", \"integration-tests\"]) // <1>\n\t@Test\n\tfun testProcessWhichRunsForUnitOrIntegrationTestGroups() {\n // some logic that should run only for unit and integration test groups\n\t}\n----\n<1> Run this test for unit tests and integration tests.\n======\n\n[[integration-testing-annotations-junit4-profilevaluesourceconfiguration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit4.adoc", "title": "integration-junit4", "heading": "`@IfProfileValue`", "heading_level": 2, "file_order": 214, "section_index": 1, "content_hash": "60bb4a95bb705ed3d91148828d79689abfd0fbfdbcb32c9df46fc5cd86cc7858", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit4.adoc"}}
{"id": "sha256:323dfd9bb2f0d235e1bc8b0b14568a72a1d12dd39b2288a0ee969101897fc3dc", "content": "`@ProfileValueSourceConfiguration` is an annotation that can be applied to a test class\nto specify what type of `ProfileValueSource` to use when retrieving profile values\nconfigured through the `@IfProfileValue` annotation. If\n`@ProfileValueSourceConfiguration` is not declared for a test, `SystemProfileValueSource`\nis used by default. The following example shows how to use\n`@ProfileValueSourceConfiguration`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ProfileValueSourceConfiguration(CustomProfileValueSource.class) // <1>\n\tpublic class CustomProfileValueSourceTests {\n // class body...\n\t}\n----\n<1> Use a custom profile value source.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ProfileValueSourceConfiguration(CustomProfileValueSource::class) // <1>\n\tclass CustomProfileValueSourceTests {\n // class body...\n\t}\n----\n<1> Use a custom profile value source.\n======\n\n[[integration-testing-annotations-junit4-timed]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit4.adoc", "title": "integration-junit4", "heading": "`@ProfileValueSourceConfiguration`", "heading_level": 2, "file_order": 214, "section_index": 2, "content_hash": "323dfd9bb2f0d235e1bc8b0b14568a72a1d12dd39b2288a0ee969101897fc3dc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit4.adoc"}}
{"id": "sha256:e4f0905345d5a62915e9498adcf70b6b9e5fa4ab7f4f70611c6207379e780f90", "content": "`@Timed` indicates that the annotated test method must finish execution in a specified\ntime period (in milliseconds). If the text execution time exceeds the specified time\nperiod, the test fails.\n\nThe time period includes running the test method itself, any repetitions of the test (see\n`@Repeat`), as well as any setting up or tearing down of the test fixture. The following\nexample shows how to use it:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Timed(millis = 1000) // <1>\n\tpublic void testProcessWithOneSecondTimeout() {\n // some logic that should not take longer than 1 second to run\n\t}\n----\n<1> Set the time period for the test to one second.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Timed(millis = 1000) // <1>\n\tfun testProcessWithOneSecondTimeout() {\n // some logic that should not take longer than 1 second to run\n\t}\n----\n<1> Set the time period for the test to one second.\n======\n\nSpring's `@Timed` annotation has different semantics than JUnit 4's `@Test(timeout=...)`\nsupport. Specifically, due to the manner in which JUnit 4 handles test execution timeouts\n(that is, by executing the test method in a separate `Thread`), `@Test(timeout=...)`\npreemptively fails the test if the test takes too long. Spring's `@Timed`, on the other\nhand, does not preemptively fail the test but rather waits for the test to complete\nbefore failing.\n\n[[integration-testing-annotations-junit4-repeat]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit4.adoc", "title": "integration-junit4", "heading": "`@Timed`", "heading_level": 2, "file_order": 214, "section_index": 3, "content_hash": "e4f0905345d5a62915e9498adcf70b6b9e5fa4ab7f4f70611c6207379e780f90", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit4.adoc"}}
{"id": "sha256:cbc3045477ce29639f53787c78f11bc277457b6d4a2909548c94e4d8f50630b9", "content": "`@Repeat` indicates that the annotated test method must be run repeatedly. The number of\ntimes that the test method is to be run is specified in the annotation.\n\nThe scope of execution to be repeated includes execution of the test method itself as\nwell as any setting up or tearing down of the test fixture. When used with the\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit4-rules[`SpringMethodRule`],\nthe scope additionally includes preparation of the test instance by `TestExecutionListener`\nimplementations. The following example shows how to use the `@Repeat` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repeat(10) // <1>\n\t@Test\n\tpublic void testProcessRepeatedly() {\n // ...\n\t}\n----\n<1> Repeat this test ten times.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Repeat(10) // <1>\n\t@Test\n\tfun testProcessRepeatedly() {\n // ...\n\t}\n----\n<1> Repeat this test ten times.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-junit4.adoc", "title": "integration-junit4", "heading": "`@Repeat`", "heading_level": 2, "file_order": 214, "section_index": 4, "content_hash": "cbc3045477ce29639f53787c78f11bc277457b6d4a2909548c94e4d8f50630b9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-junit4.adoc"}}
{"id": "sha256:4322a1edd851405e69fc9e31bf19f8f9ca17fe83b9aa3bd3f029c3b0bd766d5e", "content": "[[integration-testing-annotations-meta]]\n\nYou can use most test-related annotations as\nxref:core/beans/classpath-scanning.adoc#beans-meta-annotations[meta-annotations] to\ncreate custom composed annotations and reduce configuration duplication across a test\nsuite.\n\nFor example, you can use each of the following as a meta-annotation in conjunction with\nthe xref:testing/testcontext-framework.adoc[TestContext framework].\n\n* `@BootstrapWith`\n* `@ContextConfiguration`\n* `@ContextHierarchy`\n* `@ContextCustomizerFactories`\n* `@ActiveProfiles`\n* `@TestPropertySource`\n* `@DirtiesContext`\n* `@WebAppConfiguration`\n* `@TestExecutionListeners`\n* `@Transactional`\n* `@BeforeTransaction`\n* `@AfterTransaction`\n* `@Commit`\n* `@Rollback`\n* `@Sql`\n* `@SqlConfig`\n* `@SqlMergeMode`\n* `@SqlGroup`\n* `@Repeat` _(only supported on JUnit 4)_\n* `@Timed` _(only supported on JUnit 4)_\n* `@IfProfileValue` _(only supported on JUnit 4)_\n* `@ProfileValueSourceConfiguration` _(only supported on JUnit 4)_\n* `@SpringJUnitConfig` _(only supported on JUnit Jupiter)_\n* `@SpringJUnitWebConfig` _(only supported on JUnit Jupiter)_\n* `@TestConstructor` _(only supported on JUnit Jupiter)_\n* `@NestedTestConfiguration` _(only supported on JUnit Jupiter)_\n* `@EnabledIf` _(only supported on JUnit Jupiter)_\n* `@DisabledIf` _(only supported on JUnit Jupiter)_\n\nConsider the following test classes that use the `SpringExtension` with JUnit Jupiter:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t@ContextConfiguration(classes = {AppConfig.class, TestDataAccessConfig.class})\n\t@ActiveProfiles(\"dev\")\n\t@Transactional\n\tclass OrderRepositoryTests { }\n\n\t@ExtendWith(SpringExtension.class)\n\t@ContextConfiguration(classes = {AppConfig.class, TestDataAccessConfig.class})\n\t@ActiveProfiles(\"dev\")\n\t@Transactional\n\tclass UserRepositoryTests { }\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t@ContextConfiguration(classes = [AppConfig::class, TestDataAccessConfig::class])\n\t@ActiveProfiles(\"dev\")\n\t@Transactional\n\tclass OrderRepositoryTests { }\n\n\t@ExtendWith(SpringExtension::class)\n\t@ContextConfiguration(classes = [AppConfig::class, TestDataAccessConfig::class])\n\t@ActiveProfiles(\"dev\")\n\t@Transactional\n\tclass UserRepositoryTests { }\n----\n======\n\nIf we discover that we are repeating the preceding configuration across our test suite,\nwe can reduce the duplication by introducing a custom composed annotation that\ncentralizes the common test configuration for Spring and JUnit Jupiter, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(ElementType.TYPE)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@ExtendWith(SpringExtension.class)\n\t@ContextConfiguration(classes = {AppConfig.class, TestDataAccessConfig.class})\n\t@ActiveProfiles(\"dev\")\n\t@Transactional\n\tpublic @interface TransactionalDevTestConfig { }\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(AnnotationTarget.TYPE)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@ExtendWith(SpringExtension::class)\n\t@ContextConfiguration(classes = [AppConfig::class, TestDataAccessConfig::class])\n\t@ActiveProfiles(\"dev\")\n\t@Transactional\n\tannotation class TransactionalDevTestConfig { }\n----\n======\n\nThen we can use our custom `@TransactionalDevTestConfig` annotation to simplify the\nconfiguration of individual JUnit Jupiter based test classes, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@TransactionalDevTestConfig\n\tclass OrderRepositoryTests { }\n\n\t@TransactionalDevTestConfig\n\tclass UserRepositoryTests { }\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@TransactionalDevTestConfig\n\tclass OrderRepositoryTests { }\n\n\t@TransactionalDevTestConfig\n\tclass UserRepositoryTests { }\n----\n======\n\nSince JUnit Jupiter supports the use of `@Test`, `@RepeatedTest`, `ParameterizedTest`,\nand others as meta-annotations, you can also create custom composed annotations at the\ntest method level. For example, if we wish to create a composed annotation that combines\nthe `@Test` and `@Tag` annotations from JUnit Jupiter with the `@Transactional`\nannotation from Spring, we could create an `@TransactionalIntegrationTest` annotation, as\nfollows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(ElementType.METHOD)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Transactional\n\t@Tag(\"integration-test\") // org.junit.jupiter.api.Tag\n\t@Test // org.junit.jupiter.api.Test\n\tpublic @interface TransactionalIntegrationTest { }\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Target(AnnotationTarget.TYPE)\n\t@Retention(AnnotationRetention.RUNTIME)\n\t@Transactional\n\t@Tag(\"integration-test\") // org.junit.jupiter.api.Tag\n\t@Test // org.junit.jupiter.api.Test\n\tannotation class TransactionalIntegrationTest { }\n----\n======\n\nThen we can use our custom `@TransactionalIntegrationTest` annotation to simplify the\nconfiguration of individual JUnit Jupiter based test methods, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@TransactionalIntegrationTest\n\tvoid saveOrder() { }\n\n\t@TransactionalIntegrationTest\n\tvoid deleteOrder() { }\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@TransactionalIntegrationTest\n\tfun saveOrder() { }\n\n\t@TransactionalIntegrationTest\n\tfun deleteOrder() { }\n----\n======\n\nFor further details, see the\n{spring-framework-wiki}/Spring-Annotation-Programming-Model[Spring Annotation Programming Model]\nwiki page.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-meta.adoc", "title": "integration-meta", "heading": "integration-meta", "heading_level": 1, "file_order": 215, "section_index": 0, "content_hash": "4322a1edd851405e69fc9e31bf19f8f9ca17fe83b9aa3bd3f029c3b0bd766d5e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-meta.adoc"}}
{"id": "sha256:af50592d542cef6cfffccfd5d30c4013f06e8ac2438e472c6535c6060bfcbfce", "content": "[[integration-testing-annotations-spring]]\n\nThe Spring Framework provides the following set of Spring-specific annotations that you\ncan use in your unit and integration tests in conjunction with the TestContext framework.\nSee the corresponding javadoc for further information, including default attribute\nvalues, attribute aliases, and other details.\n\nSpring's testing annotations include the following:\n\n* xref:testing/annotations/integration-spring/annotation-bootstrapwith.adoc[`@BootstrapWith`]\n* xref:testing/annotations/integration-spring/annotation-contextconfiguration.adoc[`@ContextConfiguration`]\n* xref:testing/annotations/integration-spring/annotation-webappconfiguration.adoc[`@WebAppConfiguration`]\n* xref:testing/annotations/integration-spring/annotation-contexthierarchy.adoc[`@ContextHierarchy`]\n* xref:testing/annotations/integration-spring/annotation-contextcustomizerfactories.adoc[`@ContextCustomizerFactories`]\n* xref:testing/annotations/integration-spring/annotation-activeprofiles.adoc[`@ActiveProfiles`]\n* xref:testing/annotations/integration-spring/annotation-testpropertysource.adoc[`@TestPropertySource`]\n* xref:testing/annotations/integration-spring/annotation-dynamicpropertysource.adoc[`@DynamicPropertySource`]\n* xref:testing/annotations/integration-spring/annotation-testbean.adoc[`@TestBean`]\n* xref:testing/annotations/integration-spring/annotation-mockitobean.adoc[`@MockitoBean` and `@MockitoSpyBean`]\n* xref:testing/annotations/integration-spring/annotation-dirtiescontext.adoc[`@DirtiesContext`]\n* xref:testing/annotations/integration-spring/annotation-testexecutionlisteners.adoc[`@TestExecutionListeners`]\n* xref:testing/annotations/integration-spring/annotation-recordapplicationevents.adoc[`@RecordApplicationEvents`]\n* xref:testing/annotations/integration-spring/annotation-commit.adoc[`@Commit`]\n* xref:testing/annotations/integration-spring/annotation-rollback.adoc[`@Rollback`]\n* xref:testing/annotations/integration-spring/annotation-beforetransaction.adoc[`@BeforeTransaction`]\n* xref:testing/annotations/integration-spring/annotation-aftertransaction.adoc[`@AfterTransaction`]\n* xref:testing/annotations/integration-spring/annotation-sql.adoc[`@Sql`]\n* xref:testing/annotations/integration-spring/annotation-sqlconfig.adoc[`@SqlConfig`]\n* xref:testing/annotations/integration-spring/annotation-sqlmergemode.adoc[`@SqlMergeMode`]\n* xref:testing/annotations/integration-spring/annotation-sqlgroup.adoc[`@SqlGroup`]\n* xref:testing/annotations/integration-spring/annotation-disabledinaotmode.adoc[`@DisabledInAotMode`]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-spring.adoc", "title": "integration-spring", "heading": "integration-spring", "heading_level": 1, "file_order": 216, "section_index": 0, "content_hash": "af50592d542cef6cfffccfd5d30c4013f06e8ac2438e472c6535c6060bfcbfce", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-spring.adoc"}}
{"id": "sha256:474159ae9a3f9356c36fba729bfadb02e9bfad5a73b281c9f778de2f97ebc4ce", "content": "[[integration-testing-annotations-standard]]\n\nThe following annotations are supported with standard semantics for all configurations of\nthe Spring TestContext Framework. Note that these annotations are not specific to tests\nand can be used anywhere in the Spring Framework.\n\n* `@Autowired`\n* `@Qualifier`\n* `@Value`\n* `@Resource` (jakarta.annotation) if JSR-250 is present\n* `@Inject` (jakarta.inject) if JSR-330 is present\n* `@Named` (jakarta.inject) if JSR-330 is present\n* `@PersistenceContext` (jakarta.persistence) if JPA is present\n* `@PersistenceUnit` (jakarta.persistence) if JPA is present\n* `@Transactional` (org.springframework.transaction.annotation)\n _with xref:testing/testcontext-framework/tx.adoc#testcontext-tx-attribute-support[limited attribute support]_\n\n.JSR-250 Lifecycle Annotations\n[NOTE]\n====\nIn the Spring TestContext Framework, you can use `@PostConstruct` and `@PreDestroy` with\nstandard semantics on any application components configured in the `ApplicationContext`.\nHowever, these lifecycle annotations have limited usage within an actual test class.\n\nIf a method within a test class is annotated with `@PostConstruct`, that method runs\nbefore any before methods of the underlying test framework (for example, methods\nannotated with JUnit Jupiter's `@BeforeEach`), and that applies for every test method in\nthe test class. On the other hand, if a method within a test class is annotated with\n`@PreDestroy`, that method never runs. Therefore, within a test class, we recommend that\nyou use test lifecycle callbacks from the underlying test framework instead of\n`@PostConstruct` and `@PreDestroy`.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations/integration-standard.adoc", "title": "integration-standard", "heading": "integration-standard", "heading_level": 1, "file_order": 217, "section_index": 0, "content_hash": "474159ae9a3f9356c36fba729bfadb02e9bfad5a73b281c9f778de2f97ebc4ce", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations/integration-standard.adoc"}}
{"id": "sha256:f03e7cb52b5d29234485bb44f5c780e0b9ca781cc821efa3ca0bfadad3046294", "content": "[[mockmvc-tester-assertions]]\n\nAssertions work the same way as any AssertJ assertions. The support provides dedicated\nassert objects for the various pieces of the `MvcTestResult`, as shown in the following\nexample:\n\ninclude-code::./HotelControllerTests[tag=get,indent=0]\n\nIf a request fails, the exchange does not throw the exception. Rather, you can assert\nthat the result of the exchange has failed:\n\ninclude-code::./HotelControllerTests[tag=failure,indent=0]\n\nThe request could also fail unexpectedly, that is the exception thrown by the handler\nhas not been handled and is thrown as is. You can still use `.hasFailed()` and\n`.failure()` but any attempt to access part of the result will throw an exception as\nthe exchange hasn't completed.\n\n[[mockmvc-tester-assertions-json]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/assertions.adoc", "title": "assertions", "heading": "assertions", "heading_level": 1, "file_order": 218, "section_index": 0, "content_hash": "f03e7cb52b5d29234485bb44f5c780e0b9ca781cc821efa3ca0bfadad3046294", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/assertions.adoc"}}
{"id": "sha256:84315f71901f42eaf5b467c8dfa2e98fd98fe90668c760d961a830bb812a6ee9", "content": "The AssertJ support for `MvcTestResult` provides JSON support via `bodyJson()`.\n\nIf https://github.com/jayway/JsonPath[JSONPath] is available, you can apply an expression\non the JSON document. The returned value provides convenient methods to return a dedicated\nassert object for the various supported JSON data types:\n\ninclude-code::./FamilyControllerTests[tag=extract-asmap,indent=0]\n\nYou can also convert the raw content to any of your data types as long as the message\nconverter is configured properly:\n\ninclude-code::./FamilyControllerTests[tag=extract-convert,indent=0]\n\nConverting to a target `Class` provides a generic assert object. For more complex types,\nyou may want to use `AssertFactory` instead that returns a dedicated assert type, if\npossible:\n\ninclude-code::./FamilyControllerTests[tag=extract-convert-assert-factory,indent=0]\n\nhttps://jsonassert.skyscreamer.org[JSONAssert] is also supported. The body of the\nresponse can be matched against a `Resource` or a content. If the content ends with\n`.json ` we look for a file matching that name on the classpath:\n\ninclude-code::./FamilyControllerTests[tag=assert-file,indent=0]\n\nIf you prefer to use another library, you can provide an implementation of\n{spring-framework-api}/test/json/JsonComparator.html[`JsonComparator`].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/assertions.adoc", "title": "assertions", "heading": "JSON Support", "heading_level": 2, "file_order": 218, "section_index": 1, "content_hash": "84315f71901f42eaf5b467c8dfa2e98fd98fe90668c760d961a830bb812a6ee9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/assertions.adoc"}}
{"id": "sha256:cb8708c2fac46c2da14b44cf69f352fbfbeb1e7cb6c884103c1cb965f8c0e20c", "content": "[[mockmvc-tester-integration]]\n\nIf you want to use the AssertJ support but have invested in the original `MockMvc`\nAPI, `MockMvcTester` offers several ways to integrate with it.\n\nIf you have your own `RequestBuilder` implementation, you can trigger the processing\nof the request using `perform`. The example below showcases how the query can be\ncrafted with the original API:\n\ninclude-code::./HotelControllerTests[tag=perform,indent=0]\n\nSimilarly, if you have crafted custom matchers that you use with the `.andExpect` feature\nof `MockMvc` you can use them via `.matches`. In the example below, we rewrite the\npreceding example to assert the status with the `ResultMatcher` implementation that\n`MockMvc` provides:\n\ninclude-code::./HotelControllerTests[tag=matches,indent=0]\n\n`MockMvc` also defines a `ResultHandler` contract that lets you execute arbitrary actions\non `MvcResult`. If you have implemented this contract you can invoke it using `.apply`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/integration.adoc", "title": "integration", "heading": "integration", "heading_level": 1, "file_order": 219, "section_index": 0, "content_hash": "cb8708c2fac46c2da14b44cf69f352fbfbeb1e7cb6c884103c1cb965f8c0e20c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/integration.adoc"}}
{"id": "sha256:953bf99001e5cc64fc4c2d6f9fd86e2b38bf950f8f935c2c3456c716fb520021", "content": "[[mockmvc-tester-requests]]\n\nThis section shows how to use `MockMvcTester` to perform requests and its integration\nwith AssertJ to verify responses.\n\n`MockMvcTester` provides a fluent API to compose the request that reuses the same\n`MockHttpServletRequestBuilder` as the Hamcrest support, except that there is no need\nto import a static method. The builder that is returned is AssertJ-aware so that\nwrapping it in the regular `assertThat()` factory method triggers the exchange and\nprovides access to a dedicated Assert object for `MvcTestResult`.\n\nHere is a simple example that performs a `POST` on `/hotels/42` and configures the\nrequest to specify an `Accept` header:\n\ninclude-code::./HotelControllerTests[tag=post,indent=0]\n\nAssertJ often consists of multiple `assertThat()` statements to validate the different\nparts of the exchange. Rather than having a single statement as in the case above, you\ncan use `.exchange()` to return a `MvcTestResult` that can be used in multiple\n`assertThat` statements:\n\ninclude-code::./HotelControllerTests[tag=post-exchange,indent=0]\n\nYou can specify query parameters in URI template style, as the following example shows:\n\ninclude-code::./HotelControllerTests[tag=query-parameters,indent=0]\n\nYou can also add Servlet request parameters that represent either query or form\nparameters, as the following example shows:\n\ninclude-code::./HotelControllerTests[tag=parameters,indent=0]\n\nIf application code relies on Servlet request parameters and does not check the query\nstring explicitly (as is most often the case), it does not matter which option you use.\nKeep in mind, however, that query parameters provided with the URI template are decoded\nwhile request parameters provided through the `param(...)` method are expected to already\nbe decoded.\n\n[[mockmvc-tester-requests-async]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/requests.adoc", "title": "requests", "heading": "requests", "heading_level": 1, "file_order": 220, "section_index": 0, "content_hash": "953bf99001e5cc64fc4c2d6f9fd86e2b38bf950f8f935c2c3456c716fb520021", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/requests.adoc"}}
{"id": "sha256:72b8e5d34ec269f1675a8e0f1709f321373068ae5ac0ae82be80beaa96531d29", "content": "If the processing of the request is done asynchronously, `exchange()` waits for\nthe completion of the request so that the result to assert is effectively immutable.\nThe default timeout is 10 seconds but it can be controlled on a request-by-request\nbasis as shown in the following example:\n\ninclude-code::./AsyncControllerTests[tag=duration,indent=0]\n\nIf you prefer to get the raw result and manage the lifecycle of the asynchronous\nrequest yourself, use `asyncExchange` rather than `exchange`.\n\n[[mockmvc-tester-requests-multipart]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/requests.adoc", "title": "requests", "heading": "Async", "heading_level": 2, "file_order": 220, "section_index": 1, "content_hash": "72b8e5d34ec269f1675a8e0f1709f321373068ae5ac0ae82be80beaa96531d29", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/requests.adoc"}}
{"id": "sha256:7bea77d525015313ba5bf80a31e140924e2c77c68416d6dc940dd5ab2b1feff3", "content": "You can perform file upload requests that internally use\n`MockMultipartHttpServletRequest` so that there is no actual parsing of a multipart\nrequest. Rather, you have to set it up to be similar to the following example:\n\ninclude-code::./MultipartControllerTests[tag=snippet,indent=0]\n\n[[mockmvc-tester-requests-paths]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/requests.adoc", "title": "requests", "heading": "Multipart", "heading_level": 2, "file_order": 220, "section_index": 2, "content_hash": "7bea77d525015313ba5bf80a31e140924e2c77c68416d6dc940dd5ab2b1feff3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/requests.adoc"}}
{"id": "sha256:5088943dc8f3dc0073f86deeb2174c8bc928037576f955b0f03922ec121bdffe", "content": "In most cases, it is preferable to leave the context path and the Servlet path out of the\nrequest URI. If you must test with the full request URI, be sure to set the `contextPath`\nand `servletPath` accordingly so that request mappings work, as the following example\nshows:\n\ninclude-code::./HotelControllerTests[tag=context-servlet-paths,indent=0]\n\nIn the preceding example, it would be cumbersome to set the `contextPath` and\n`servletPath` with every performed request. Instead, you can set up default request\nproperties, as the following example shows:\n\ninclude-code::./HotelControllerTests[tag=default-customizations,indent=0]\n\nThe preceding properties affect every request performed through the `mockMvc` instance.\nIf the same property is also specified on a given request, it overrides the default\nvalue. That is why the HTTP method and URI in the default request do not matter, since\nthey must be specified on every request.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/requests.adoc", "title": "requests", "heading": "Using Servlet and Context Paths", "heading_level": 2, "file_order": 220, "section_index": 3, "content_hash": "5088943dc8f3dc0073f86deeb2174c8bc928037576f955b0f03922ec121bdffe", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/requests.adoc"}}
{"id": "sha256:05ffe553b656e2b4d342939219df993f9041752469093b9d787cdafe8820f87a", "content": "[[mockmvc-tester-setup]]\n\n`MockMvcTester` can be setup in one of two ways. One is to point directly to the\ncontrollers you want to test and programmatically configure Spring MVC infrastructure.\nThe second is to point to Spring configuration with Spring MVC and controller\ninfrastructure in it.\n\nTIP: For a comparison of those two modes, check xref:testing/mockmvc/setup-options.adoc[Setup Options].\n\nTo set up `MockMvcTester` for testing a specific controller, use the following:\n\ninclude-code::./AccountControllerStandaloneTests[tag=snippet,indent=0]\n\nTo set up `MockMvcTester` through Spring configuration, use the following:\n\ninclude-code::./AccountControllerIntegrationTests[tag=snippet,indent=0]\n\n`MockMvcTester` can convert the JSON response body, or the result of a JSONPath expression,\nto one of your domain object as long as the relevant `HttpMessageConverter` is registered.\n\nIf you use Jackson to serialize content to JSON, the following example registers the\nconverter:\n\ninclude-code::./converter/AccountControllerIntegrationTests[tag=snippet,indent=0]\n\nNOTE: The above assumes the converter has been registered as a Bean.\n\nFinally, if you have a `MockMvc` instance handy, you can create a `MockMvcTester` by\nproviding the `MockMvc` instance to use using the `create` factory method.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/setup.adoc", "title": "setup", "heading": "setup", "heading_level": 1, "file_order": 221, "section_index": 0, "content_hash": "05ffe553b656e2b4d342939219df993f9041752469093b9d787cdafe8820f87a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/assertj/setup.adoc"}}
{"id": "sha256:a0e1e70bed662ffd0c331b1514ad2fb070ee1f372d4fce7b33f8044a35ff272c", "content": "[[mockmvc-async-requests]]\n\nThis section shows how to use MockMvc on its own to test asynchronous request handling.\nIf using MockMvc through the xref:testing/webtestclient.adoc[WebTestClient], there is nothing special to do to make\nasynchronous requests work as the `WebTestClient` automatically does what is described\nin this section.\n\nServlet asynchronous requests, xref:web/webmvc/mvc-ann-async.adoc[supported in Spring MVC],\nwork by exiting the Servlet container thread and allowing the application to compute\nthe response asynchronously, after which an async dispatch is made to complete\nprocessing on a Servlet container thread.\n\nIn Spring MVC Test, async requests can be tested by asserting the produced async value\nfirst, then manually performing the async dispatch, and finally verifying the response.\nBelow is an example test for controller methods that return `DeferredResult`, `Callable`,\nor reactive type such as Reactor `Mono`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// static import of MockMvcRequestBuilders.* and MockMvcResultMatchers.*\n\n\t@Test\n\tvoid test() throws Exception {\n MvcResult mvcResult = this.mockMvc.perform(get(\"/path\"))\n .andExpect(status().isOk()) <1>\n .andExpect(request().asyncStarted()) <2>\n .andExpect(request().asyncResult(\"body\")) <3>\n .andReturn();\n\n this.mockMvc.perform(asyncDispatch(mvcResult)) <4>\n .andExpect(status().isOk()) <5>\n .andExpect(content().string(\"body\"));\n\t}\n----\n<1> Check response status is still unchanged\n<2> Async processing must have started\n<3> Wait and assert the async result\n<4> Manually perform an ASYNC dispatch (as there is no running container)\n<5> Verify the final response\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\tfun test() {\n var mvcResult = mockMvc.get(\"/path\").andExpect {\n status { isOk() } // <1>\n request { asyncStarted() } // <2>\n // TODO Remove unused generic parameter\n request { asyncResult<Nothing>(\"body\") } // <3>\n }.andReturn()\n\n mockMvc.perform(asyncDispatch(mvcResult)) // <4>\n .andExpect {\n status { isOk() } // <5>\n content().string(\"body\")\n }\n\t}\n----\n<1> Check response status is still unchanged\n<2> Async processing must have started\n<3> Wait and assert the async result\n<4> Manually perform an ASYNC dispatch (as there is no running container)\n<5> Verify the final response\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/async-requests.adoc", "title": "async-requests", "heading": "async-requests", "heading_level": 1, "file_order": 222, "section_index": 0, "content_hash": "a0e1e70bed662ffd0c331b1514ad2fb070ee1f372d4fce7b33f8044a35ff272c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/async-requests.adoc"}}
{"id": "sha256:4bd16788da51db10d3d748bca4b5ce7b0422f666ebc76a55468fc4cf1644a09f", "content": "[[mockmvc-server-defining-expectations]]\n\nYou can define expectations by appending one or more `andExpect(..)` calls after\nperforming a request, as the following example shows. As soon as one expectation fails,\nno other expectations will be asserted.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// static import of MockMvcRequestBuilders.* and MockMvcResultMatchers.*\n\n\tmockMvc.perform(get(\"/accounts/1\")).andExpect(status().isOk());\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.test.web.servlet.get\n\n\tmockMvc.get(\"/accounts/1\").andExpect {\n status { isOk() }\n\t}\n----\n======\n\nYou can define multiple expectations by appending `andExpectAll(..)` after performing a\nrequest, as the following example shows. In contrast to `andExpect(..)`,\n`andExpectAll(..)` guarantees that all supplied expectations will be asserted and that\nall failures will be tracked and reported.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// static import of MockMvcRequestBuilders.* and MockMvcResultMatchers.*\n\n\tmockMvc.perform(get(\"/accounts/1\")).andExpectAll(\n status().isOk(),\n content().contentType(\"application/json;charset=UTF-8\"));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.test.web.servlet.get\n\n\tmockMvc.get(\"/accounts/1\").andExpectAll {\n status { isOk() }\n content { contentType(APPLICATION_JSON) }\n\t}\n----\n======\n\n`MockMvcResultMatchers.*` provides a number of expectations, some of which are further\nnested with more detailed expectations.\n\nExpectations fall in two general categories. The first category of assertions verifies\nproperties of the response (for example, the response status, headers, and content).\nThese are the most important results to assert.\n\nThe second category of assertions goes beyond the response. These assertions let you\ninspect Spring MVC specific aspects, such as which controller method processed the\nrequest, whether an exception was raised and handled, what the content of the model is,\nwhat view was selected, what flash attributes were added, and so on. They also let you\ninspect Servlet specific aspects, such as request and session attributes.\n\nThe following test asserts that binding or validation failed:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc.perform(post(\"/persons\"))\n .andExpect(status().isOk())\n .andExpect(model().attributeHasErrors(\"person\"));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.test.web.servlet.post\n\n\tmockMvc.post(\"/persons\").andExpect {\n status { isOk() }\n model {\n attributeHasErrors(\"person\")\n }\n\t}\n----\n======\n\nMany times, when writing tests, it is useful to dump the results of the performed\nrequest. You can do so as follows, where `print()` is a static import from\n`MockMvcResultHandlers`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc.perform(post(\"/persons\"))\n .andDo(print())\n .andExpect(status().isOk())\n .andExpect(model().attributeHasErrors(\"person\"));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.test.web.servlet.post\n\n\tmockMvc.post(\"/persons\").andDo {\n print()\n }.andExpect {\n status { isOk() }\n model {\n attributeHasErrors(\"person\")\n }\n }\n----\n======\n\nAs long as request processing does not cause an unhandled exception, the `print()` method\nprints all the available result data to `System.out`. There is also a `log()` method and\ntwo additional variants of the `print()` method, one that accepts an `OutputStream` and\none that accepts a `Writer`. For example, invoking `print(System.err)` prints the result\ndata to `System.err`, while invoking `print(myWriter)` prints the result data to a custom\nwriter. If you want to have the result data logged instead of printed, you can invoke the\n`log()` method, which logs the result data as a single `DEBUG` message under the\n`org.springframework.test.web.servlet.result` logging category.\n\nIn some cases, you may want to get direct access to the result and verify something that\ncannot be verified otherwise. This can be achieved by appending `.andReturn()` after all\nother expectations, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMvcResult mvcResult = mockMvc.perform(post(\"/persons\")).andExpect(status().isOk()).andReturn();\n\t// ...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tvar mvcResult = mockMvc.post(\"/persons\").andExpect { status { isOk() } }.andReturn()\n\t// ...\n----\n======\n\nIf all tests repeat the same expectations, you can set up common expectations once when\nbuilding the `MockMvc` instance, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tstandaloneSetup(new SimpleController())\n .alwaysExpect(status().isOk())\n .alwaysExpect(content().contentType(\"application/json;charset=UTF-8\"))\n .build()\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tstandaloneSetup(SimpleController())\n .alwaysExpect<StandaloneMockMvcBuilder>(status().isOk())\n .alwaysExpect<StandaloneMockMvcBuilder>(content().contentType(\"application/json;charset=UTF-8\"))\n .build()\n----\n======\n\nNote that common expectations are always applied and cannot be overridden without\ncreating a separate `MockMvc` instance.\n\nWhen a JSON response content contains hypermedia links created with\n{spring-github-org}/spring-hateoas[Spring HATEOAS], you can verify the\nresulting links by using JsonPath expressions, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc.perform(get(\"/people\").accept(MediaType.APPLICATION_JSON))\n .andExpect(jsonPath(\"$.links[?(@.rel == 'self')].href\").value(\"http://localhost:8080/people\"));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc.get(\"/people\") {\n accept(MediaType.APPLICATION_JSON)\n\t}.andExpect {\n jsonPath(\"$.links[?(@.rel == 'self')].href\") {\n value(\"http://localhost:8080/people\")\n }\n\t}\n----\n======\n\nWhen XML response content contains hypermedia links created with\n{spring-github-org}/spring-hateoas[Spring HATEOAS], you can verify the\nresulting links by using XPath expressions:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMap<String, String> ns = Collections.singletonMap(\"ns\", \"http://www.w3.org/2005/Atom\");\n\tmockMvc.perform(get(\"/handle\").accept(MediaType.APPLICATION_XML))\n .andExpect(xpath(\"/person/ns:link[@rel='self']/@href\", ns).string(\"http://localhost:8080/people\"));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval ns = mapOf(\"ns\" to \"http://www.w3.org/2005/Atom\")\n\tmockMvc.get(\"/handle\") {\n accept(MediaType.APPLICATION_XML)\n\t}.andExpect {\n xpath(\"/person/ns:link[@rel='self']/@href\", ns) {\n string(\"http://localhost:8080/people\")\n }\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/expectations.adoc", "title": "expectations", "heading": "expectations", "heading_level": 1, "file_order": 223, "section_index": 0, "content_hash": "4bd16788da51db10d3d748bca4b5ce7b0422f666ebc76a55468fc4cf1644a09f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/expectations.adoc"}}
{"id": "sha256:48314747ab45258beac83f4d240b01e809a1a2fc86a14d279e1622ea85024c73", "content": "[[mockmvc-server-filters]]\n\nWhen setting up a `MockMvc` instance, you can register one or more Servlet `Filter`\ninstances, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc = standaloneSetup(PersonController()).addFilters<StandaloneMockMvcBuilder>(CharacterEncodingFilter()).build()\n----\n======\n\nRegistered filters are invoked through the `MockFilterChain` from `spring-test`, and the\nlast filter delegates to the `DispatcherServlet`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/filters.adoc", "title": "filters", "heading": "filters", "heading_level": 1, "file_order": 224, "section_index": 0, "content_hash": "48314747ab45258beac83f4d240b01e809a1a2fc86a14d279e1622ea85024c73", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/filters.adoc"}}
{"id": "sha256:908c8d3a408012e433e5c6a4d072984970a97a536bd005b2f0d487f1718553e1", "content": "[[mockmvc-server-performing-requests]]\n\nThis section shows how to use MockMvc on its own to perform requests and verify responses.\nIf using MockMvc through the `WebTestClient` please see the corresponding section on\nxref:testing/webtestclient.adoc#webtestclient-tests[Writing Tests] instead.\n\nTo perform requests that use any HTTP method, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// static import of MockMvcRequestBuilders.*\n\n\tmockMvc.perform(post(\"/hotels/{id}\", 42).accept(MediaType.APPLICATION_JSON));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.test.web.servlet.post\n\n\tmockMvc.post(\"/hotels/{id}\", 42) {\n accept = MediaType.APPLICATION_JSON\n\t}\n----\n======\n\nYou can also perform file upload requests that internally use\n`MockMultipartHttpServletRequest` so that there is no actual parsing of a multipart\nrequest. Rather, you have to set it up to be similar to the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc.perform(multipart(\"/doc\").file(\"a1\", \"ABC\".getBytes(\"UTF-8\")));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.test.web.servlet.multipart\n\n\tmockMvc.multipart(\"/doc\") {\n file(\"a1\", \"ABC\".toByteArray(charset(\"UTF8\")))\n\t}\n----\n======\n\nYou can specify query parameters in URI template style, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc.perform(get(\"/hotels?thing={thing}\", \"somewhere\"));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc.get(\"/hotels?thing={thing}\", \"somewhere\")\n----\n======\n\nYou can also add Servlet request parameters that represent either query or form\nparameters, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc.perform(get(\"/hotels\").param(\"thing\", \"somewhere\"));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.test.web.servlet.get\n\n\tmockMvc.get(\"/hotels\") {\n param(\"thing\", \"somewhere\")\n\t}\n----\n======\n\nIf application code relies on Servlet request parameters and does not check the query\nstring explicitly (as is most often the case), it does not matter which option you use.\nKeep in mind, however, that query parameters provided with the URI template are decoded\nwhile request parameters provided through the `param(...)` method are expected to already\nbe decoded.\n\nIn most cases, it is preferable to leave the context path and the Servlet path out of the\nrequest URI. If you must test with the full request URI, be sure to set the `contextPath`\nand `servletPath` accordingly so that request mappings work, as the following example\nshows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc.perform(get(\"/app/main/hotels/{id}\").contextPath(\"/app\").servletPath(\"/main\"))\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.test.web.servlet.get\n\n\tmockMvc.get(\"/app/main/hotels/{id}\") {\n contextPath = \"/app\"\n servletPath = \"/main\"\n\t}\n----\n======\n\nIn the preceding example, it would be cumbersome to set the `contextPath` and\n`servletPath` with every performed request. Instead, you can set up default request\nproperties, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MyWebTests {\n\n MockMvc mockMvc;\n\n @BeforeEach\n void setup() {\n mockMvc = standaloneSetup(new AccountController())\n .defaultRequest(get(\"/\")\n .contextPath(\"/app\").servletPath(\"/main\")\n .accept(MediaType.APPLICATION_JSON)).build();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MyWebTests {\n\n lateinit var mockMvc: MockMvc\n\n @BeforeEach\n fun setup() {\n mockMvc = standaloneSetup(AccountController())\n .defaultRequest<StandaloneMockMvcBuilder>(get(\"/\")\n .contextPath(\"/app\").servletPath(\"/main\")\n .accept(MediaType.APPLICATION_JSON)).build()\n }\n\t}\n----\n======\n\nThe preceding properties affect every request performed through the `MockMvc` instance.\nIf the same property is also specified on a given request, it overrides the default\nvalue. That is why the HTTP method and URI in the default request do not matter, since\nthey must be specified on every request.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/requests.adoc", "title": "requests", "heading": "requests", "heading_level": 1, "file_order": 225, "section_index": 0, "content_hash": "908c8d3a408012e433e5c6a4d072984970a97a536bd005b2f0d487f1718553e1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/requests.adoc"}}
{"id": "sha256:60a8d6f9a577102413f2cc8164548831f57973cc7ea85b14209ee957781e8aa9", "content": "[[mockmvc-server-setup-steps]]\n\nNo matter which MockMvc builder you use, all `MockMvcBuilder` implementations provide\nsome common and very useful features. For example, you can declare an `Accept` header for\nall requests and expect a status of 200 as well as a `Content-Type` header in all\nresponses, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// static import of MockMvcBuilders.standaloneSetup\n\n\tMockMvc mockMvc = standaloneSetup(new MusicController())\n .defaultRequest(get(\"/\").accept(MediaType.APPLICATION_JSON))\n .alwaysExpect(status().isOk())\n .alwaysExpect(content().contentType(\"application/json;charset=UTF-8\"))\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// static import of MockMvcBuilders.standaloneSetup\n\n\tval mockMvc = standaloneSetup(MusicController())\n .defaultRequest<StandaloneMockMvcBuilder>(get(\"/\").accept(MediaType.APPLICATION_JSON))\n .alwaysExpect<StandaloneMockMvcBuilder>(status().isOk())\n .alwaysExpect<StandaloneMockMvcBuilder>(content().contentType(\"application/json;charset=UTF-8\"))\n .build()\n----\n======\n\nIn addition, third-party frameworks (and applications) can pre-package setup\ninstructions, such as those in a `MockMvcConfigurer`. The Spring Framework has one such\nbuilt-in implementation that helps to save and re-use the HTTP session across requests.\nYou can use it as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// static import of SharedHttpSessionConfigurer.sharedHttpSession\n\n\tMockMvc mockMvc = MockMvcBuilders.standaloneSetup(new TestController())\n .apply(sharedHttpSession())\n .build();\n\n\t// Use mockMvc to perform requests...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// static import of SharedHttpSessionConfigurer.sharedHttpSession\n\n\tval mockMvc = MockMvcBuilders.standaloneSetup(TestController())\n .apply<StandaloneMockMvcBuilder>(sharedHttpSession())\n .build()\n\n\t// Use mockMvc to perform requests...\n----\n======\n\nSee the javadoc for\n{spring-framework-api}/test/web/servlet/setup/ConfigurableMockMvcBuilder.html[`ConfigurableMockMvcBuilder`]\nfor a list of all MockMvc builder features or use the IDE to explore the available options.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/setup-steps.adoc", "title": "setup-steps", "heading": "setup-steps", "heading_level": 1, "file_order": 226, "section_index": 0, "content_hash": "60a8d6f9a577102413f2cc8164548831f57973cc7ea85b14209ee957781e8aa9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/setup-steps.adoc"}}
{"id": "sha256:601e011f246909ce1a7ba9362a32ef704a560f5b0bd053852100ec069625125c", "content": "[[mockmvc-setup]]\n\nMockMvc can be setup in one of two ways. One is to point directly to the controllers you\nwant to test and programmatically configure Spring MVC infrastructure. The second is to\npoint to Spring configuration with Spring MVC and controller infrastructure in it.\n\nTIP: For a comparison of those two modes, check xref:testing/mockmvc/setup-options.adoc[Setup Options].\n\nTo set up MockMvc for testing a specific controller, use the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MyWebTests {\n\n MockMvc mockMvc;\n\n @BeforeEach\n void setup() {\n this.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build();\n }\n\n // ...\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MyWebTests {\n\n lateinit var mockMvc : MockMvc\n\n @BeforeEach\n fun setup() {\n mockMvc = MockMvcBuilders.standaloneSetup(AccountController()).build()\n }\n\n // ...\n\n\t}\n----\n======\n\nOr you can also use this setup when testing through the\nxref:testing/webtestclient.adoc#webtestclient-controller-config[WebTestClient] which delegates to the same builder\nas shown above.\n\nTo set up MockMvc through Spring configuration, use the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig(locations = \"my-servlet-context.xml\")\n\tclass MyWebTests {\n\n MockMvc mockMvc;\n\n @BeforeEach\n void setup(WebApplicationContext wac) {\n this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();\n }\n\n // ...\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig(locations = [\"my-servlet-context.xml\"])\n\tclass MyWebTests {\n\n lateinit var mockMvc: MockMvc\n\n @BeforeEach\n fun setup(wac: WebApplicationContext) {\n mockMvc = MockMvcBuilders.webAppContextSetup(wac).build()\n }\n\n // ...\n\n\t}\n----\n======\n\nOr you can also use this setup when testing through the\nxref:testing/webtestclient.adoc#webtestclient-context-config[WebTestClient]\nwhich delegates to the same builder as shown above.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/setup.adoc", "title": "setup", "heading": "setup", "heading_level": 1, "file_order": 227, "section_index": 0, "content_hash": "601e011f246909ce1a7ba9362a32ef704a560f5b0bd053852100ec069625125c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/setup.adoc"}}
{"id": "sha256:3b187a3c6eddf54a8d6a6809a95288e32aa0e3924e419b67f0afbdf0b63f3e0b", "content": "[[mockmvc-server-static-imports]]\n\nWhen using MockMvc directly to perform requests, you'll need static imports for:\n\n- `MockMvcBuilders.{asterisk}`\n- `MockMvcRequestBuilders.{asterisk}`\n- `MockMvcResultMatchers.{asterisk}`\n- `MockMvcResultHandlers.{asterisk}`\n\nAn easy way to remember that is search for `MockMvc*`. If using Eclipse be sure to also\nadd the above as \"`favorite static members`\" in the Eclipse preferences.\n\nWhen using MockMvc through the xref:testing/webtestclient.adoc[WebTestClient] you do not need static imports.\nThe `WebTestClient` provides a fluent API without static imports.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/static-imports.adoc", "title": "static-imports", "heading": "static-imports", "heading_level": 1, "file_order": 228, "section_index": 0, "content_hash": "3b187a3c6eddf54a8d6a6809a95288e32aa0e3924e419b67f0afbdf0b63f3e0b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/static-imports.adoc"}}
{"id": "sha256:702f2f02c9ba7c18f4b3a0548f5909c56be5cf45084ce3cf1645242fcb0fdfd6", "content": "[[mockmvc-vs-streaming-response]]\n\nYou can use `WebTestClient` to test xref:testing/webtestclient.adoc#webtestclient-stream[streaming responses]\nsuch as Server-Sent Events. However, `MockMvcWebTestClient` doesn't support infinite\nstreams because there is no way to cancel the server stream from the client side.\nTo test infinite streams, you'll need to\nxref:testing/webtestclient.adoc#webtestclient-server-config[bind to] a running server,\nor when using Spring Boot,\n{spring-boot-docs-ref}/testing/spring-boot-applications.html#testing.spring-boot-applications.with-running-server[test with a running server].\n\n`MockMvcWebTestClient` does support asynchronous responses, and even streaming responses.\nThe limitation is that it can't influence the server to stop, and therefore the server\nmust finish writing the response on its own.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/vs-streaming-response.adoc", "title": "vs-streaming-response", "heading": "vs-streaming-response", "heading_level": 1, "file_order": 229, "section_index": 0, "content_hash": "702f2f02c9ba7c18f4b3a0548f5909c56be5cf45084ce3cf1645242fcb0fdfd6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest/vs-streaming-response.adoc"}}
{"id": "sha256:74b3847a505795dc43bb0f0f74049c2e955945688c0453dece199ab4b18e80c3", "content": "[[mockmvc-server-htmlunit-geb]]\n\nIn the previous section, we saw how to use MockMvc with WebDriver. In this section, we\nuse https://www.gebish.org/[Geb] to make our tests even Groovy-er.\n\n[[mockmvc-server-htmlunit-geb-why]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/geb.adoc", "title": "geb", "heading": "geb", "heading_level": 1, "file_order": 230, "section_index": 0, "content_hash": "74b3847a505795dc43bb0f0f74049c2e955945688c0453dece199ab4b18e80c3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/geb.adoc"}}
{"id": "sha256:94e195a338af6f75c5425eb35e48fdb3a406ce611c6e8bde197fa04a248333a4", "content": "Geb is backed by WebDriver, so it offers many of the\nxref:testing/mockmvc/htmlunit/webdriver.adoc#mockmvc-server-htmlunit-webdriver-why[same benefits]\nthat we get from WebDriver. However, Geb makes things even easier by taking care of some\nof the boilerplate code for us.\n\n[[mockmvc-server-htmlunit-geb-setup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/geb.adoc", "title": "geb", "heading": "Why Geb and MockMvc?", "heading_level": 2, "file_order": 230, "section_index": 1, "content_hash": "94e195a338af6f75c5425eb35e48fdb3a406ce611c6e8bde197fa04a248333a4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/geb.adoc"}}
{"id": "sha256:5a979457fb846ee34b834c412fa4250d1798e17240a83428d8b66b02af5eb17f", "content": "We can easily initialize a Geb `Browser` with a Selenium WebDriver that uses MockMvc, as\nfollows:\n\n[source,groovy]\n----\ndef setup() {\n\tbrowser.driver = MockMvcHtmlUnitDriverBuilder\n .webAppContextSetup(context)\n .build()\n}\n----\n\nNOTE: This is a simple example of using `MockMvcHtmlUnitDriverBuilder`. For more advanced\nusage, see\nxref:testing/mockmvc/htmlunit/webdriver.adoc#mockmvc-server-htmlunit-webdriver-advanced-builder[Advanced `MockMvcHtmlUnitDriverBuilder`].\n\nThis ensures that any URL referencing `localhost` as the server is directed to our\n`MockMvc` instance without the need for a real HTTP connection. Any other URL is\nrequested by using a network connection as normal. This lets us easily test the use of\nCDNs.\n\n[[mockmvc-server-htmlunit-geb-usage]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/geb.adoc", "title": "geb", "heading": "MockMvc and Geb Setup", "heading_level": 2, "file_order": 230, "section_index": 2, "content_hash": "5a979457fb846ee34b834c412fa4250d1798e17240a83428d8b66b02af5eb17f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/geb.adoc"}}
{"id": "sha256:1c0f2747d93962172594d89cd072f251c55e4b701ed95ea60db5e84377a2a563", "content": "Now we can use Geb as we normally would but without the need to deploy our application to\na Servlet container. For example, we can request the view to create a message with the\nfollowing:\n\n[source,groovy]\n----\nto CreateMessagePage\n----\n\nWe can then fill out the form and submit it to create a message, as follows:\n\n[source,groovy]\n----\nwhen:\nform.summary = expectedSummary\nform.text = expectedMessage\nsubmit.click(ViewMessagePage)\n----\n\nAny unrecognized method calls or property accesses or references that are not found are\nforwarded to the current page object. This removes a lot of the boilerplate code we\nneeded when using WebDriver directly.\n\nAs with direct WebDriver usage, this improves on the design of our\nxref:testing/mockmvc/htmlunit/mah.adoc#mockmvc-server-htmlunit-mah-usage[HtmlUnit test]\nby using the Page Object Pattern. As mentioned previously, we can use the Page Object\nPattern with HtmlUnit and WebDriver, but it is even easier with Geb. Consider our new\nGroovy-based `CreateMessagePage` implementation:\n\n[source,groovy]\n----\nclass CreateMessagePage extends Page {\n\tstatic url = 'messages/form'\n\tstatic at = { assert title == 'Messages : Create'; true }\n\tstatic content = {\n submit { $('input[type=submit]') }\n form { $('form') }\n errors(required:false) { $('label.error, .alert-error')?.text() }\n\t}\n}\n----\n\nOur `CreateMessagePage` extends `Page`. We do not go over the details of `Page`, but, in\nsummary, it contains common functionality for all of our pages. We define a URL in which\nthis page can be found. This lets us navigate to the page, as follows:\n\n[source,groovy]\n----\nto CreateMessagePage\n----\n\nWe also have an `at` closure that determines if we are at the specified page. It should\nreturn `true` if we are on the correct page. This is why we can assert that we are on the\ncorrect page, as follows:\n\n[source,groovy]\n----\nthen:\nat CreateMessagePage\nerrors.contains('This field is required.')\n----\n\nNOTE: We use an assertion in the closure so that we can determine where things went wrong\nif we were at the wrong page.\n\nNext, we create a `content` closure that specifies all the areas of interest within the\npage. We can use a\nhttps://www.gebish.org/manual/current/#the-jquery-ish-navigator-api[jQuery-ish Navigator\nAPI] to select the content in which we are interested.\n\nFinally, we can verify that a new message was created successfully, as follows:\n\n[source,groovy]\n----\nthen:\nat ViewMessagePage\nsuccess == 'Successfully created a new message'\nid\ndate\nsummary == expectedSummary\nmessage == expectedMessage\n----\n\nFor further details on how to get the most out of Geb, see\nhttps://www.gebish.org/manual/current/[The Book of Geb] user's manual.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/geb.adoc", "title": "geb", "heading": "MockMvc and Geb Usage", "heading_level": 2, "file_order": 230, "section_index": 3, "content_hash": "1c0f2747d93962172594d89cd072f251c55e4b701ed95ea60db5e84377a2a563", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/geb.adoc"}}
{"id": "sha256:a45e7da41b4b054c41c727ff540240b904a9fdf4e6c10e5ab219c26972d5be96", "content": "[[mockmvc-server-htmlunit-mah]]\n\nThis section describes how to integrate MockMvc and HtmlUnit. Use this option if you want\nto use the raw HtmlUnit libraries.\n\n[[mockmvc-server-htmlunit-mah-setup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/mah.adoc", "title": "mah", "heading": "mah", "heading_level": 1, "file_order": 231, "section_index": 0, "content_hash": "a45e7da41b4b054c41c727ff540240b904a9fdf4e6c10e5ab219c26972d5be96", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/mah.adoc"}}
{"id": "sha256:488f088b5eb0ef318218e6fc183b98fb0cdcb08b257f855f36325d19412b78e0", "content": "First, make sure that you have included a test dependency on `org.htmlunit:htmlunit`.\n\nWe can easily create an HtmlUnit `WebClient` that integrates with MockMvc by using the\n`MockMvcWebClientBuilder`, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient webClient;\n\n\t@BeforeEach\n\tvoid setup(WebApplicationContext context) {\n webClient = MockMvcWebClientBuilder\n .webAppContextSetup(context)\n .build();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tlateinit var webClient: WebClient\n\n\t@BeforeEach\n\tfun setup(context: WebApplicationContext) {\n webClient = MockMvcWebClientBuilder\n .webAppContextSetup(context)\n .build()\n\t}\n----\n======\n\nNOTE: This is a simple example of using `MockMvcWebClientBuilder`. For advanced usage,\nsee <<mockmvc-server-htmlunit-mah-advanced-builder>>.\n\nThis ensures that any URL that references `localhost` as the server is directed to our\n`MockMvc` instance without the need for a real HTTP connection. Any other URL is\nrequested by using a network connection, as normal. This lets us easily test the use of\nCDNs.\n\n[[mockmvc-server-htmlunit-mah-usage]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/mah.adoc", "title": "mah", "heading": "MockMvc and HtmlUnit Setup", "heading_level": 2, "file_order": 231, "section_index": 1, "content_hash": "488f088b5eb0ef318218e6fc183b98fb0cdcb08b257f855f36325d19412b78e0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/mah.adoc"}}
{"id": "sha256:eaf2072a5fee61d8624bb8c6e1f52c158b11aa893ef7fc0a230dadd0f55a7d7b", "content": "Now we can use HtmlUnit as we normally would but without the need to deploy our\napplication to a Servlet container. For example, we can request the view to create a\nmessage with the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHtmlPage createMsgFormPage = webClient.getPage(\"http://localhost/messages/form\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval createMsgFormPage = webClient.getPage(\"http://localhost/messages/form\")\n----\n======\n\nNOTE: The default context path is `\"\"`. Alternatively, we can specify the context path,\nas described in <<mockmvc-server-htmlunit-mah-advanced-builder>>.\n\nOnce we have a reference to the `HtmlPage`, we can then fill out the form and submit it\nto create a message, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHtmlForm form = createMsgFormPage.getHtmlElementById(\"messageForm\");\n\tHtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById(\"summary\");\n\tsummaryInput.setValueAttribute(\"Spring Rocks\");\n\tHtmlTextArea textInput = createMsgFormPage.getHtmlElementById(\"text\");\n\ttextInput.setText(\"In case you didn't know, Spring Rocks!\");\n\tHtmlSubmitInput submit = form.getOneHtmlElementByAttribute(\"input\", \"type\", \"submit\");\n\tHtmlPage newMessagePage = submit.click();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval form = createMsgFormPage.getHtmlElementById(\"messageForm\")\n\tval summaryInput = createMsgFormPage.getHtmlElementById(\"summary\")\n\tsummaryInput.setValueAttribute(\"Spring Rocks\")\n\tval textInput = createMsgFormPage.getHtmlElementById(\"text\")\n\ttextInput.setText(\"In case you didn't know, Spring Rocks!\")\n\tval submit = form.getOneHtmlElementByAttribute(\"input\", \"type\", \"submit\")\n\tval newMessagePage = submit.click()\n----\n======\n\nFinally, we can verify that a new message was created successfully. The following\nassertions use the {assertj-docs}[AssertJ] library:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tassertThat(newMessagePage.getUrl().toString()).endsWith(\"/messages/123\");\n\tString id = newMessagePage.getHtmlElementById(\"id\").getTextContent();\n\tassertThat(id).isEqualTo(\"123\");\n\tString summary = newMessagePage.getHtmlElementById(\"summary\").getTextContent();\n\tassertThat(summary).isEqualTo(\"Spring Rocks\");\n\tString text = newMessagePage.getHtmlElementById(\"text\").getTextContent();\n\tassertThat(text).isEqualTo(\"In case you didn't know, Spring Rocks!\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tassertThat(newMessagePage.getUrl().toString()).endsWith(\"/messages/123\")\n\tval id = newMessagePage.getHtmlElementById(\"id\").getTextContent()\n\tassertThat(id).isEqualTo(\"123\")\n\tval summary = newMessagePage.getHtmlElementById(\"summary\").getTextContent()\n\tassertThat(summary).isEqualTo(\"Spring Rocks\")\n\tval text = newMessagePage.getHtmlElementById(\"text\").getTextContent()\n\tassertThat(text).isEqualTo(\"In case you didn't know, Spring Rocks!\")\n----\n======\n\nThe preceding code improves on our\nxref:testing/mockmvc/htmlunit/why.adoc#mockmvc-server-htmlunit-why[MockMvc test] in a\nnumber of ways. First, we no longer have to explicitly verify our form and then create a\nrequest that looks like the form. Instead, we request the form, fill it out, and submit\nit, thereby significantly reducing the overhead.\n\nAnother important factor is that https://htmlunit.sourceforge.io/javascript.html[HtmlUnit\nuses the Mozilla Rhino engine] to evaluate JavaScript. This means that we can also test\nthe behavior of JavaScript within our pages.\n\nSee the https://htmlunit.sourceforge.io/gettingStarted.html[HtmlUnit documentation] for\nadditional information about using HtmlUnit.\n\n[[mockmvc-server-htmlunit-mah-advanced-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/mah.adoc", "title": "mah", "heading": "MockMvc and HtmlUnit Usage", "heading_level": 2, "file_order": 231, "section_index": 2, "content_hash": "eaf2072a5fee61d8624bb8c6e1f52c158b11aa893ef7fc0a230dadd0f55a7d7b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/mah.adoc"}}
{"id": "sha256:af1f2d56099d211947dc8f8d3d43a638e72f9a3aeb994022a363a1f7b05e4eab", "content": "In the examples so far, we have used `MockMvcWebClientBuilder` in the simplest way\npossible, by building a `WebClient` based on the `WebApplicationContext` loaded for us by\nthe Spring TestContext Framework. This approach is repeated in the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient webClient;\n\n\t@BeforeEach\n\tvoid setup(WebApplicationContext context) {\n webClient = MockMvcWebClientBuilder\n .webAppContextSetup(context)\n .build();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tlateinit var webClient: WebClient\n\n\t@BeforeEach\n\tfun setup(context: WebApplicationContext) {\n webClient = MockMvcWebClientBuilder\n .webAppContextSetup(context)\n .build()\n\t}\n----\n======\n\nWe can also specify additional configuration options, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient webClient;\n\n\t@BeforeEach\n\tvoid setup() {\n webClient = MockMvcWebClientBuilder\n // demonstrates applying a MockMvcConfigurer (Spring Security)\n .webAppContextSetup(context, springSecurity())\n // for illustration only - defaults to \"\"\n .contextPath(\"\")\n // By default MockMvc is used for localhost only;\n // the following will use MockMvc for example.com and example.org as well\n .useMockMvcForHosts(\"example.com\",\"example.org\")\n .build();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tlateinit var webClient: WebClient\n\n\t@BeforeEach\n\tfun setup() {\n webClient = MockMvcWebClientBuilder\n // demonstrates applying a MockMvcConfigurer (Spring Security)\n .webAppContextSetup(context, springSecurity())\n // for illustration only - defaults to \"\"\n .contextPath(\"\")\n // By default MockMvc is used for localhost only;\n // the following will use MockMvc for example.com and example.org as well\n .useMockMvcForHosts(\"example.com\",\"example.org\")\n .build()\n\t}\n----\n======\n\nAs an alternative, we can perform the exact same setup by configuring the `MockMvc`\ninstance separately and supplying it to the `MockMvcWebClientBuilder`, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMockMvc mockMvc = MockMvcBuilders\n .webAppContextSetup(context)\n .apply(springSecurity())\n .build();\n\n\twebClient = MockMvcWebClientBuilder\n .mockMvcSetup(mockMvc)\n // for illustration only - defaults to \"\"\n .contextPath(\"\")\n // By default MockMvc is used for localhost only;\n // the following will use MockMvc for example.com and example.org as well\n .useMockMvcForHosts(\"example.com\",\"example.org\")\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval mockMvc = MockMvcBuilders\n .webAppContextSetup(context)\n .apply<DefaultMockMvcBuilder>(springSecurity())\n .build()\n\n\twebClient = MockMvcWebClientBuilder\n .mockMvcSetup(mockMvc)\n // for illustration only - defaults to \"\"\n .contextPath(\"\")\n // By default MockMvc is used for localhost only;\n // the following will use MockMvc for example.com and example.org as well\n .useMockMvcForHosts(\"example.com\", \"example.org\")\n .build()\n----\n======\n\nThis is more verbose, but, by building the `WebClient` with a `MockMvc` instance, we have\nthe full power of MockMvc at our fingertips.\n\nTIP: For additional information on creating a `MockMvc` instance, see\nxref:testing/mockmvc/hamcrest/setup.adoc[Configuring MockMvc].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/mah.adoc", "title": "mah", "heading": "Advanced `MockMvcWebClientBuilder`", "heading_level": 2, "file_order": 231, "section_index": 3, "content_hash": "af1f2d56099d211947dc8f8d3d43a638e72f9a3aeb994022a363a1f7b05e4eab", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/mah.adoc"}}
{"id": "sha256:6b16e2763868d5f6ef99fdefbde42d1f74e9b1d3294f4d8191f2420964cd970f", "content": "[[mockmvc-server-htmlunit-webdriver]]\n\nIn the previous sections, we have seen how to use MockMvc in conjunction with the raw\nHtmlUnit APIs. In this section, we use additional abstractions within the Selenium\nhttps://docs.seleniumhq.org/projects/webdriver/[WebDriver] to make things even easier.\n\n[[mockmvc-server-htmlunit-webdriver-why]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/webdriver.adoc", "title": "webdriver", "heading": "webdriver", "heading_level": 1, "file_order": 232, "section_index": 0, "content_hash": "6b16e2763868d5f6ef99fdefbde42d1f74e9b1d3294f4d8191f2420964cd970f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/webdriver.adoc"}}
{"id": "sha256:e315a8b3b673a60ba2c8016eea1ed0b9128f58b01098dbb82f9e7bb18391f8dc", "content": "We can already use HtmlUnit and MockMvc, so why would we want to use WebDriver? The\nSelenium WebDriver provides a very elegant API that lets us easily organize our code. To\nbetter show how it works, we explore an example in this section.\n\nNOTE: Despite being a part of https://docs.seleniumhq.org/[Selenium], WebDriver does not\nrequire a Selenium Server to run your tests.\n\nSuppose we need to ensure that a message is created properly. The tests involve finding\nthe HTML form input elements, filling them out, and making various assertions.\n\nThis approach results in numerous separate tests because we want to test error conditions\nas well. For example, we want to ensure that we get an error if we fill out only part of\nthe form. If we fill out the entire form, the newly created message should be displayed\nafterwards.\n\nIf one of the fields were named \"`summary`\", we might have something that resembles the\nfollowing repeated in multiple places within our tests:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHtmlTextInput summaryInput = currentPage.getHtmlElementById(\"summary\");\n\tsummaryInput.setValueAttribute(summary);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval summaryInput = currentPage.getHtmlElementById(\"summary\")\n\tsummaryInput.setValueAttribute(summary)\n----\n======\n\nSo what happens if we change the `id` to `smmry`? Doing so would force us to update all\nof our tests to incorporate this change. This violates the DRY principle, so we should\nideally extract this code into its own method, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic HtmlPage createMessage(HtmlPage currentPage, String summary, String text) {\n setSummary(currentPage, summary);\n // ...\n\t}\n\n\tpublic void setSummary(HtmlPage currentPage, String summary) {\n HtmlTextInput summaryInput = currentPage.getHtmlElementById(\"summary\");\n summaryInput.setValueAttribute(summary);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun createMessage(currentPage: HtmlPage, summary:String, text:String) :HtmlPage{\n setSummary(currentPage, summary);\n // ...\n\t}\n\n\tfun setSummary(currentPage:HtmlPage , summary: String) {\n val summaryInput = currentPage.getHtmlElementById(\"summary\")\n summaryInput.setValueAttribute(summary)\n\t}\n----\n======\n\nDoing so ensures that we do not have to update all of our tests if we change the UI.\n\nWe might even take this a step further and place this logic within an `Object` that\nrepresents the `HtmlPage` we are currently on, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class CreateMessagePage {\n\n final HtmlPage currentPage;\n\n final HtmlTextInput summaryInput;\n\n final HtmlSubmitInput submit;\n\n public CreateMessagePage(HtmlPage currentPage) {\n this.currentPage = currentPage;\n this.summaryInput = currentPage.getHtmlElementById(\"summary\");\n this.submit = currentPage.getHtmlElementById(\"submit\");\n }\n\n public <T> T createMessage(String summary, String text) throws Exception {\n setSummary(summary);\n\n HtmlPage result = submit.click();\n boolean error = CreateMessagePage.at(result);\n\n return (T) (error ? new CreateMessagePage(result) : new ViewMessagePage(result));\n }\n\n public void setSummary(String summary) throws Exception {\n summaryInput.setValueAttribute(summary);\n }\n\n public static boolean at(HtmlPage page) {\n return \"Create Message\".equals(page.getTitleText());\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass CreateMessagePage(private val currentPage: HtmlPage) {\n\n val summaryInput: HtmlTextInput = currentPage.getHtmlElementById(\"summary\")\n\n val submit: HtmlSubmitInput = currentPage.getHtmlElementById(\"submit\")\n\n fun <T> createMessage(summary: String, text: String): T {\n setSummary(summary)\n\n val result = submit.click()\n val error = at(result)\n\n return (if (error) CreateMessagePage(result) else ViewMessagePage(result)) as T\n }\n\n fun setSummary(summary: String) {\n summaryInput.setValueAttribute(summary)\n }\n\n fun at(page: HtmlPage): Boolean {\n return \"Create Message\" == page.getTitleText()\n }\n\t}\n}\n----\n======\n\nFormerly, this pattern was known as the\nhttps://github.com/SeleniumHQ/selenium/wiki/PageObjects[Page Object Pattern]. While we\ncan certainly do this with HtmlUnit, WebDriver provides some tools that we explore in the\nfollowing sections to make this pattern much easier to implement.\n\n[[mockmvc-server-htmlunit-webdriver-setup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/webdriver.adoc", "title": "webdriver", "heading": "Why WebDriver and MockMvc?", "heading_level": 2, "file_order": 232, "section_index": 1, "content_hash": "e315a8b3b673a60ba2c8016eea1ed0b9128f58b01098dbb82f9e7bb18391f8dc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/webdriver.adoc"}}
{"id": "sha256:4722c04dfb09e979e30c178e389e1695d57f2562f6a63f556f188baf58f42207", "content": "To use Selenium WebDriver with `MockMvc`, make sure that your project includes a test\ndependency on `org.seleniumhq.selenium:htmlunit3-driver`.\n\nWe can easily create a Selenium WebDriver that integrates with MockMvc by using the\n`MockMvcHtmlUnitDriverBuilder` as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebDriver driver;\n\n\t@BeforeEach\n\tvoid setup(WebApplicationContext context) {\n driver = MockMvcHtmlUnitDriverBuilder\n .webAppContextSetup(context)\n .build();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tlateinit var driver: WebDriver\n\n\t@BeforeEach\n\tfun setup(context: WebApplicationContext) {\n driver = MockMvcHtmlUnitDriverBuilder\n .webAppContextSetup(context)\n .build()\n\t}\n----\n======\n\nNOTE: This is a simple example of using `MockMvcHtmlUnitDriverBuilder`. For more advanced\nusage, see <<mockmvc-server-htmlunit-webdriver-advanced-builder>>.\n\nThe preceding example ensures that any URL that references `localhost` as the server is\ndirected to our `MockMvc` instance without the need for a real HTTP connection. Any other\nURL is requested by using a network connection, as normal. This lets us easily test the\nuse of CDNs.\n\n[[mockmvc-server-htmlunit-webdriver-usage]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/webdriver.adoc", "title": "webdriver", "heading": "MockMvc and WebDriver Setup", "heading_level": 2, "file_order": 232, "section_index": 2, "content_hash": "4722c04dfb09e979e30c178e389e1695d57f2562f6a63f556f188baf58f42207", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/webdriver.adoc"}}
{"id": "sha256:24be7a167d2508ac3c84e44edda98be22462a3dffc04a7b9ac3a792692245711", "content": "Now we can use WebDriver as we normally would but without the need to deploy our\napplication to a Servlet container. For example, we can request the view to create a\nmessage with the following:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tCreateMessagePage page = CreateMessagePage.to(driver);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval page = CreateMessagePage.to(driver)\n----\n======\n--\n\nWe can then fill out the form and submit it to create a message, as follows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tViewMessagePage viewMessagePage =\n page.createMessage(ViewMessagePage.class, expectedSummary, expectedText);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval viewMessagePage =\n page.createMessage(ViewMessagePage::class, expectedSummary, expectedText)\n----\n======\n--\n\nThis improves on the design of our\nxref:testing/mockmvc/htmlunit/mah.adoc#mockmvc-server-htmlunit-mah-usage[HtmlUnit test]\nby leveraging the Page Object Pattern. As we mentioned in\n<<mockmvc-server-htmlunit-webdriver-why>>, we can use the Page Object Pattern with\nHtmlUnit, but it is much easier with WebDriver. Consider the following\n`CreateMessagePage` implementation:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class CreateMessagePage extends AbstractPage { // <1>\n\n // <2>\n private WebElement summary;\n private WebElement text;\n\n @FindBy(css = \"input[type=submit]\") // <3>\n private WebElement submit;\n\n public CreateMessagePage(WebDriver driver) {\n super(driver);\n }\n\n public <T> T createMessage(Class<T> resultPage, String summary, String details) {\n this.summary.sendKeys(summary);\n this.text.sendKeys(details);\n this.submit.click();\n return PageFactory.initElements(driver, resultPage);\n }\n\n public static CreateMessagePage to(WebDriver driver) {\n driver.get(\"http://localhost:9990/mail/messages/form\");\n return PageFactory.initElements(driver, CreateMessagePage.class);\n }\n\t}\n----\n<1> `CreateMessagePage` extends the `AbstractPage`. We do not go over the details of\n`AbstractPage`, but, in summary, it contains common functionality for all of our pages.\nFor example, if our application has a navigational bar, global error messages, and other\nfeatures, we can place this logic in a shared location.\n<2> We have a member variable for each of the parts of the HTML page in which we are\ninterested. These are of type `WebElement`. WebDriver's\nhttps://github.com/SeleniumHQ/selenium/wiki/PageFactory[`PageFactory`] lets us remove a\nlot of code from the HtmlUnit version of `CreateMessagePage` by automatically resolving\neach `WebElement`. The\nhttps://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-[`PageFactory#initElements(WebDriver,Class<T>)`]\nmethod automatically resolves each `WebElement` by using the field name and looking it up\nby the `id` or `name` of the element within the HTML page.\n<3> We can use the\nhttps://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations[`@FindBy` annotation]\nto override the default lookup behavior. Our example shows how to use the `@FindBy`\nannotation to look up our submit button with a `css` selector (`input[type=submit]`).\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass CreateMessagePage(private val driver: WebDriver) : AbstractPage(driver) { // <1>\n\n // <2>\n private lateinit var summary: WebElement\n private lateinit var text: WebElement\n\n @FindBy(css = \"input[type=submit]\") // <3>\n private lateinit var submit: WebElement\n\n fun <T> createMessage(resultPage: Class<T>, summary: String, details: String): T {\n this.summary.sendKeys(summary)\n text.sendKeys(details)\n submit.click()\n return PageFactory.initElements(driver, resultPage)\n }\n companion object {\n fun to(driver: WebDriver): CreateMessagePage {\n driver.get(\"http://localhost:9990/mail/messages/form\")\n return PageFactory.initElements(driver, CreateMessagePage::class.java)\n }\n }\n\t}\n----\n<1> `CreateMessagePage` extends the `AbstractPage`. We do not go over the details of\n`AbstractPage`, but, in summary, it contains common functionality for all of our pages.\nFor example, if our application has a navigational bar, global error messages, and other\nfeatures, we can place this logic in a shared location.\n<2> We have a member variable for each of the parts of the HTML page in which we are\ninterested. These are of type `WebElement`. WebDriver's\nhttps://github.com/SeleniumHQ/selenium/wiki/PageFactory[`PageFactory`] lets us remove a\nlot of code from the HtmlUnit version of `CreateMessagePage` by automatically resolving\neach `WebElement`. The\nhttps://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-[`PageFactory#initElements(WebDriver,Class<T>)`]\nmethod automatically resolves each `WebElement` by using the field name and looking it up\nby the `id` or `name` of the element within the HTML page.\n<3> We can use the\nhttps://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations[`@FindBy` annotation]\nto override the default lookup behavior. Our example shows how to use the `@FindBy`\nannotation to look up our submit button with a `css` selector (*input[type=submit]*).\n======\n--\n\nFinally, we can verify that a new message was created successfully. The following\nassertions use the {assertj-docs}[AssertJ] assertion library:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tassertThat(viewMessagePage.getMessage()).isEqualTo(expectedMessage);\n\tassertThat(viewMessagePage.getSuccess()).isEqualTo(\"Successfully created a new message\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tassertThat(viewMessagePage.message).isEqualTo(expectedMessage)\n\tassertThat(viewMessagePage.success).isEqualTo(\"Successfully created a new message\")\n----\n======\n--\n\nWe can see that our `ViewMessagePage` lets us interact with our custom domain model. For\nexample, it exposes a method that returns a `Message` object:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic Message getMessage() throws ParseException {\n Message message = new Message();\n message.setId(getId());\n message.setCreated(getCreated());\n message.setSummary(getSummary());\n message.setText(getText());\n return message;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun getMessage() = Message(getId(), getCreated(), getSummary(), getText())\n----\n======\n--\n\nWe can then use the rich domain objects in our assertions.\n\nLastly, we must not forget to close the `WebDriver` instance when the test is complete,\nas follows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@AfterEach\n\tvoid destroy() {\n if (driver != null) {\n driver.close();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@AfterEach\n\tfun destroy() {\n if (driver != null) {\n driver.close()\n }\n\t}\n----\n======\n--\n\nFor additional information on using WebDriver, see the Selenium\nhttps://github.com/SeleniumHQ/selenium/wiki/Getting-Started[WebDriver documentation].\n\n[[mockmvc-server-htmlunit-webdriver-advanced-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/webdriver.adoc", "title": "webdriver", "heading": "MockMvc and WebDriver Usage", "heading_level": 2, "file_order": 232, "section_index": 3, "content_hash": "24be7a167d2508ac3c84e44edda98be22462a3dffc04a7b9ac3a792692245711", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/webdriver.adoc"}}
{"id": "sha256:6bf46be1c0c652ef9c0c60a46ae0f4e3048e7833b040bc83b500c557ec1f5251", "content": "In the examples so far, we have used `MockMvcHtmlUnitDriverBuilder` in the simplest way\npossible, by building a `WebDriver` based on the `WebApplicationContext` loaded for us by\nthe Spring TestContext Framework. This approach is repeated here, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebDriver driver;\n\n\t@BeforeEach\n\tvoid setup(WebApplicationContext context) {\n driver = MockMvcHtmlUnitDriverBuilder\n .webAppContextSetup(context)\n .build();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tlateinit var driver: WebDriver\n\n\t@BeforeEach\n\tfun setup(context: WebApplicationContext) {\n driver = MockMvcHtmlUnitDriverBuilder\n .webAppContextSetup(context)\n .build()\n\t}\n----\n======\n\nWe can also specify additional configuration options, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebDriver driver;\n\n\t@BeforeEach\n\tvoid setup() {\n driver = MockMvcHtmlUnitDriverBuilder\n // demonstrates applying a MockMvcConfigurer (Spring Security)\n .webAppContextSetup(context, springSecurity())\n // for illustration only - defaults to \"\"\n .contextPath(\"\")\n // By default MockMvc is used for localhost only;\n // the following will use MockMvc for example.com and example.org as well\n .useMockMvcForHosts(\"example.com\",\"example.org\")\n .build();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tlateinit var driver: WebDriver\n\n\t@BeforeEach\n\tfun setup() {\n driver = MockMvcHtmlUnitDriverBuilder\n // demonstrates applying a MockMvcConfigurer (Spring Security)\n .webAppContextSetup(context, springSecurity())\n // for illustration only - defaults to \"\"\n .contextPath(\"\")\n // By default MockMvc is used for localhost only;\n // the following will use MockMvc for example.com and example.org as well\n .useMockMvcForHosts(\"example.com\",\"example.org\")\n .build()\n\t}\n----\n======\n\nAs an alternative, we can perform the exact same setup by configuring the `MockMvc`\ninstance separately and supplying it to the `MockMvcHtmlUnitDriverBuilder`, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMockMvc mockMvc = MockMvcBuilders\n .webAppContextSetup(context)\n .apply(springSecurity())\n .build();\n\n\tdriver = MockMvcHtmlUnitDriverBuilder\n .mockMvcSetup(mockMvc)\n // for illustration only - defaults to \"\"\n .contextPath(\"\")\n // By default MockMvc is used for localhost only;\n // the following will use MockMvc for example.com and example.org as well\n .useMockMvcForHosts(\"example.com\",\"example.org\")\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval mockMvc: MockMvc = MockMvcBuilders\n .webAppContextSetup(context)\n .apply<DefaultMockMvcBuilder>(springSecurity())\n .build()\n\n\tdriver = MockMvcHtmlUnitDriverBuilder\n .mockMvcSetup(mockMvc)\n // for illustration only - defaults to \"\"\n .contextPath(\"\")\n // By default MockMvc is used for localhost only;\n // the following will use MockMvc for example.com and example.org as well\n .useMockMvcForHosts(\"example.com\", \"example.org\")\n .build()\n----\n======\n\nThis is more verbose, but, by building the `WebDriver` with a `MockMvc` instance, we have\nthe full power of MockMvc at our fingertips.\n\nTIP: For additional information on creating a `MockMvc` instance, see\nxref:testing/mockmvc/hamcrest/setup.adoc[Configuring MockMvc].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/webdriver.adoc", "title": "webdriver", "heading": "Advanced `MockMvcHtmlUnitDriverBuilder`", "heading_level": 2, "file_order": 232, "section_index": 4, "content_hash": "6bf46be1c0c652ef9c0c60a46ae0f4e3048e7833b040bc83b500c557ec1f5251", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/webdriver.adoc"}}
{"id": "sha256:5ee9ce55e827a2b7509f346e5f8ba3c63db54ae1e2ab47007632ae61f48ca7ad", "content": "[[mockmvc-server-htmlunit-why]]\n\nThe most obvious question that comes to mind is \"`Why do I need this?`\" The answer is\nbest found by exploring a very basic sample application. Assume you have a Spring MVC web\napplication that supports CRUD operations on a `Message` object. The application also\nsupports paging through all messages. How would you go about testing it?\n\nWith Spring MVC Test, we can easily test if we are able to create a `Message`, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMockHttpServletRequestBuilder createMessage = post(\"/messages/\")\n .param(\"summary\", \"Spring Rocks\")\n .param(\"text\", \"In case you didn't know, Spring Rocks!\");\n\n\tmockMvc.perform(createMessage)\n .andExpect(status().is3xxRedirection())\n .andExpect(redirectedUrl(\"/messages/123\"));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\tfun test() {\n mockMvc.post(\"/messages/\") {\n param(\"summary\", \"Spring Rocks\")\n param(\"text\", \"In case you didn't know, Spring Rocks!\")\n }.andExpect {\n status().is3xxRedirection()\n redirectedUrl(\"/messages/123\")\n }\n\t}\n----\n======\n\nWhat if we want to test the form view that lets us create the message? For example,\nassume our form looks like the following snippet:\n\n[source,xml,indent=0]\n----\n\t<form id=\"messageForm\" action=\"/messages/\" method=\"post\">\n <div class=\"pull-right\"><a href=\"/messages/\">Messages</a></div>\n\n <label for=\"summary\">Summary</label>\n <input type=\"text\" class=\"required\" id=\"summary\" name=\"summary\" value=\"\" />\n\n <label for=\"text\">Message</label>\n <textarea id=\"text\" name=\"text\"></textarea>\n\n <div class=\"form-actions\">\n <input type=\"submit\" value=\"Create\" />\n </div>\n\t</form>\n----\n\nHow do we ensure that our form produces the correct request to create a new message? A\nnaive attempt might resemble the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc.perform(get(\"/messages/form\"))\n .andExpect(xpath(\"//input[@name='summary']\").exists())\n .andExpect(xpath(\"//textarea[@name='text']\").exists());\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tmockMvc.get(\"/messages/form\").andExpect {\n xpath(\"//input[@name='summary']\") { exists() }\n xpath(\"//textarea[@name='text']\") { exists() }\n\t}\n----\n======\n\nThis test has some obvious drawbacks. If we update our controller to use the parameter\n`message` instead of `text`, our form test continues to pass, even though the HTML form\nis out of sync with the controller. To resolve this we can combine our two tests, as\nfollows:\n\n[tabs]\n======\nJava::\n+\n[[mockmvc-server-htmlunit-mock-mvc-test]]\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString summaryParamName = \"summary\";\n\tString textParamName = \"text\";\n\tmockMvc.perform(get(\"/messages/form\"))\n .andExpect(xpath(\"//input[@name='\" + summaryParamName + \"']\").exists())\n .andExpect(xpath(\"//textarea[@name='\" + textParamName + \"']\").exists());\n\n\tMockHttpServletRequestBuilder createMessage = post(\"/messages/\")\n .param(summaryParamName, \"Spring Rocks\")\n .param(textParamName, \"In case you didn't know, Spring Rocks!\");\n\n\tmockMvc.perform(createMessage)\n .andExpect(status().is3xxRedirection())\n .andExpect(redirectedUrl(\"/messages/123\"));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval summaryParamName = \"summary\";\n\tval textParamName = \"text\";\n\tmockMvc.get(\"/messages/form\").andExpect {\n xpath(\"//input[@name='$summaryParamName']\") { exists() }\n xpath(\"//textarea[@name='$textParamName']\") { exists() }\n\t}\n\tmockMvc.post(\"/messages/\") {\n param(summaryParamName, \"Spring Rocks\")\n param(textParamName, \"In case you didn't know, Spring Rocks!\")\n\t}.andExpect {\n status().is3xxRedirection()\n redirectedUrl(\"/messages/123\")\n\t}\n----\n======\n\nThis would reduce the risk of our test incorrectly passing, but there are still some\nproblems:\n\n* What if we have multiple forms on our page? Admittedly, we could update our XPath\n expressions, but they get more complicated as we take more factors into account: Are\n the fields the correct type? Are the fields enabled? And so on.\n* Another issue is that we are doing double the work we would expect. We must first\n verify the view, and then we submit the view with the same parameters we just verified.\n Ideally, this could be done all at once.\n* Finally, we still cannot account for some things. For example, what if the form has\n JavaScript validation that we wish to test as well?\n\nThe overall problem is that testing a web page does not involve a single interaction.\nInstead, it is a combination of how the user interacts with a web page and how that web\npage interacts with other resources. For example, the result of a form view is used as\nthe input to a user for creating a message. In addition, our form view can potentially\nuse additional resources that impact the behavior of the page, such as JavaScript\nvalidation.\n\n[[mockmvc-server-htmlunit-why-integration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/why.adoc", "title": "why", "heading": "why", "heading_level": 1, "file_order": 233, "section_index": 0, "content_hash": "5ee9ce55e827a2b7509f346e5f8ba3c63db54ae1e2ab47007632ae61f48ca7ad", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/why.adoc"}}
{"id": "sha256:b2ea77da2a97f84f95a32b860f261b2d56e37e206c0ab611de29bec617d10abe", "content": "To resolve the issues mentioned above, we could perform end-to-end integration testing,\nbut this has some drawbacks. Consider testing the view that lets us page through the\nmessages. We might need the following tests:\n\n* Does our page display a notification to the user to indicate that no results are\n available when the messages are empty?\n* Does our page properly display a single message?\n* Does our page properly support paging?\n\nTo set up these tests, we need to ensure our database contains the proper messages. This\nleads to a number of additional challenges:\n\n* Ensuring the proper messages are in the database can be tedious. (Consider foreign key\n constraints.)\n* Testing can become slow, since each test would need to ensure that the database is in\n the correct state.\n* Since our database needs to be in a specific state, we cannot run tests in parallel.\n* Performing assertions on items such as auto-generated IDs, timestamps, and others can\n be difficult.\n\nThese challenges do not mean that we should abandon end-to-end integration testing\naltogether. Instead, we can reduce the number of end-to-end integration tests by\nrefactoring our detailed tests to use mock services that run much faster, more reliably,\nand without side effects. We can then implement a small number of true end-to-end\nintegration tests that validate simple workflows to ensure that everything works together\nproperly.\n\n[[mockmvc-server-htmlunit-why-mockmvc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/why.adoc", "title": "why", "heading": "Integration Testing to the Rescue?", "heading_level": 2, "file_order": 233, "section_index": 1, "content_hash": "b2ea77da2a97f84f95a32b860f261b2d56e37e206c0ab611de29bec617d10abe", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/why.adoc"}}
{"id": "sha256:6e6d1b545700511418b38bba78d819c2ce857c89f0a913319fb1992f17df874f", "content": "So how can we achieve a balance between testing the interactions of our pages and still\nretain good performance within our test suite? The answer is: \"`By integrating MockMvc\nwith HtmlUnit.`\"\n\n[[mockmvc-server-htmlunit-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/why.adoc", "title": "why", "heading": "Enter HtmlUnit Integration", "heading_level": 2, "file_order": 233, "section_index": 2, "content_hash": "6e6d1b545700511418b38bba78d819c2ce857c89f0a913319fb1992f17df874f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/why.adoc"}}
{"id": "sha256:9520c5e4a65391d991b5f7500071618498ad01aa5d13fa77046028ae04df4224", "content": "You have a number of options when you want to integrate MockMvc with HtmlUnit:\n\n* xref:testing/mockmvc/htmlunit/mah.adoc[MockMvc and HtmlUnit]: Use this option if you\n want to use the raw HtmlUnit libraries.\n* xref:testing/mockmvc/htmlunit/webdriver.adoc[MockMvc and WebDriver]: Use this option to\n ease development and reuse code between integration and end-to-end testing.\n* xref:testing/mockmvc/htmlunit/geb.adoc[MockMvc and Geb]: Use this option if you want to\n use Groovy for testing, ease development, and reuse code between integration and\n end-to-end testing.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/why.adoc", "title": "why", "heading": "HtmlUnit Integration Options", "heading_level": 2, "file_order": 233, "section_index": 3, "content_hash": "9520c5e4a65391d991b5f7500071618498ad01aa5d13fa77046028ae04df4224", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit/why.adoc"}}
{"id": "sha256:16af5196f2b9ff6c6328ea7f3bb9073992174ec1feecdd7a0c6d02d00d32de9e", "content": "[[mockmvc-tester]]\n\nThe AssertJ integration builds on top of plain `MockMvc` with several differences:\n\n* There is no need to use static imports as both the requests and assertions can be\ncrafted using a fluent API.\n* Unresolved exceptions are handled consistently so that your tests do not need to\nthrow (or catch) `Exception`.\n* By default, the result to assert is complete whether the processing is asynchronous\nor not. In other words, there is no need for special handling for Async requests.\n\n`MockMvcTester` is the entry point for the AssertJ support. It allows to craft the\nrequest and return a result that is AssertJ compatible so that it can be wrapped in\na standard `assertThat()` method.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/assertj.adoc", "title": "assertj", "heading": "assertj", "heading_level": 1, "file_order": 234, "section_index": 0, "content_hash": "16af5196f2b9ff6c6328ea7f3bb9073992174ec1feecdd7a0c6d02d00d32de9e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/assertj.adoc"}}
{"id": "sha256:0e36a6f17982339597a7a846010d7bdfd6322ea91f07563eaba9799e509710ed", "content": "[[mockmvc-server]]\n\nPlain `MockMvc` provides an API to build the request using a builder-style approach\nthat can be initiated with static imports. Hamcrest is used to define expectations and\nit provides many out-of-the-box options for common needs.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest.adoc", "title": "hamcrest", "heading": "hamcrest", "heading_level": 1, "file_order": 235, "section_index": 0, "content_hash": "0e36a6f17982339597a7a846010d7bdfd6322ea91f07563eaba9799e509710ed", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/hamcrest.adoc"}}
{"id": "sha256:c99ec941b8e8dbba5ff3ca16aedc273a0ec23ee505bbea6f16b627bf7559e618", "content": "[[mockmvc-server-htmlunit]]\n\nSpring provides integration between xref:testing/mockmvc/overview.adoc[MockMvc] and\nhttps://htmlunit.sourceforge.io/[HtmlUnit]. This simplifies performing end-to-end testing\nwhen using HTML-based views. This integration lets you:\n\n* Easily test HTML pages by using tools such as\n https://htmlunit.sourceforge.io/[HtmlUnit],\n https://www.seleniumhq.org[WebDriver], and\n https://www.gebish.org/manual/current/#spock-junit-testng[Geb] without the need to\n deploy to a Servlet container.\n* Test JavaScript within pages.\n* Optionally, test using mock services to speed up testing.\n* Share logic between in-container end-to-end tests and out-of-container integration tests.\n\nNOTE: MockMvc works with templating technologies that do not rely on a Servlet Container\n(for example, Thymeleaf, FreeMarker, and others), but it does not work with JSPs, since\nthey rely on the Servlet container.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit.adoc", "title": "htmlunit", "heading": "htmlunit", "heading_level": 1, "file_order": 236, "section_index": 0, "content_hash": "c99ec941b8e8dbba5ff3ca16aedc273a0ec23ee505bbea6f16b627bf7559e618", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/htmlunit.adoc"}}
{"id": "sha256:982867e449d10d6ab612ede549389ffc6b8a5888898116732f972c7db767011c", "content": "[[mockmvc-overview]]\n\nYou can write plain unit tests for Spring MVC by instantiating a controller, injecting it\nwith dependencies, and calling its methods. However such tests do not verify request\nmappings, data binding, message conversion, type conversion, or validation and also do\nnot involve any of the supporting `@InitBinder`, `@ModelAttribute`, or\n`@ExceptionHandler` methods.\n\n`MockMvc` aims to provide more complete testing support for Spring MVC controllers\nwithout a running server. It does that by invoking the `DispatcherServlet` and passing\nxref:testing/unit.adoc#mock-objects-servlet[\"mock\" implementations of the Servlet API]\nfrom the `spring-test` module which replicates the full Spring MVC request handling\nwithout a running server.\n\nMockMvc is a server-side test framework that lets you verify most of the functionality of\na Spring MVC application using lightweight and targeted tests. You can use it on its own\nto perform requests and to verify responses using Hamcrest or through `MockMvcTester`\nwhich provides a fluent API using AssertJ. You can also use it through the\nxref:testing/webtestclient.adoc[WebTestClient] API with MockMvc plugged in as the server\nto handle requests.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/overview.adoc", "title": "overview", "heading": "overview", "heading_level": 1, "file_order": 237, "section_index": 0, "content_hash": "982867e449d10d6ab612ede549389ffc6b8a5888898116732f972c7db767011c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/overview.adoc"}}
{"id": "sha256:31823e5df9d890eafe472480ed3ee63f47cf6b74ef8b4c19629a05e03753c7a4", "content": "[[mockmvc-server-resources]]\n\nThe framework's own test suite includes\n{spring-framework-code}/spring-test/src/test/java/org/springframework/test/web/servlet/samples[\nmany sample tests] intended to show how to use MockMvc on its own or through the\n{spring-framework-code}/spring-test/src/test/java/org/springframework/test/web/servlet/samples/client[\nWebTestClient]. Browse these examples for further ideas.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/resources.adoc", "title": "resources", "heading": "resources", "heading_level": 1, "file_order": 238, "section_index": 0, "content_hash": "31823e5df9d890eafe472480ed3ee63f47cf6b74ef8b4c19629a05e03753c7a4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/resources.adoc"}}
{"id": "sha256:a6a5a9450610edf2f93c8b286ca8aa05f493365257a19044b8bd6a23256a32d0", "content": "[[mockmvc-server-setup-options]]\n\nMockMvc can be set up in one of two ways.\n\n`WebApplicationContext` ::\n Point to Spring configuration with Spring MVC and controller infrastructure in it.\nStandalone ::\n Point directly to the controllers you want to test and programmatically configure Spring\n MVC infrastructure.\n\nWhich setup option should you use?\n\nA `WebApplicationContext`-based test loads your actual Spring MVC configuration,\nresulting in a more complete integration test. Since the TestContext framework caches the\nloaded Spring configuration, it helps keep tests running fast, even as you introduce more\ntests in your test suite using the same configuration. Furthermore, you can override\nservices used by your controller using `@MockitoBean` or `@TestBean` to remain focused on\ntesting the web layer.\n\nA standalone test, on the other hand, is a little closer to a unit test. It tests one\ncontroller at a time. You can manually inject the controller with mock dependencies, and\nit does not involve loading Spring configuration. Such tests are more focused on style\nand make it easier to see which controller is being tested, whether any specific Spring\nMVC configuration is required to work, and so on. The standalone setup is also a very\nconvenient way to write ad-hoc tests to verify specific behavior or to debug an issue.\n\nAs with most \"integration versus unit testing\" debates, there is no right or wrong\nanswer. However, using standalone tests does imply the need for additional integration\ntests to verify your Spring MVC configuration. Alternatively, you can write all your\ntests with a `WebApplicationContext`, so that they always test against your actual Spring\nMVC configuration.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/setup-options.adoc", "title": "setup-options", "heading": "setup-options", "heading_level": 1, "file_order": 239, "section_index": 0, "content_hash": "a6a5a9450610edf2f93c8b286ca8aa05f493365257a19044b8bd6a23256a32d0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/setup-options.adoc"}}
{"id": "sha256:7e57444694021b7046143039ac5498b26f009adf5e77abff3c1a1c6ef10876f2", "content": "[[mockmvc-vs-end-to-end-integration-tests]]\n\nMockMvc is built on Servlet API mock implementations from the\n`spring-test` module and does not rely on a running container. Therefore, there are\nsome differences when compared to full end-to-end integration tests with an actual\nclient and a live server running.\n\nThe easiest way to think about this is by starting with a blank `MockHttpServletRequest`.\nWhatever you add to it is what the request becomes. Things that may catch you by surprise\nare that there is no context path by default; no `jsessionid` cookie; no forwarding,\nerror, or async dispatches; and, therefore, no actual JSP rendering. Instead,\n\"forwarded\" and \"redirected\" URLs are saved in the `MockHttpServletResponse` and can\nbe asserted with expectations.\n\nThis means that, if you use JSPs, you can verify the JSP page to which the request was\nforwarded, but no HTML is rendered. In other words, the JSP is not invoked. Note,\nhowever, that all other rendering technologies which do not rely on forwarding, such as\nThymeleaf and Freemarker, render HTML to the response body as expected. The same is true\nfor rendering JSON, XML, and other formats through `@ResponseBody` methods.\n\nAlternatively, you may consider the full end-to-end integration testing support from\nSpring Boot with `@SpringBootTest`. See the\n{spring-boot-docs-ref}/testing/spring-boot-applications.html[Spring Boot Reference Guide].\n\nThere are pros and cons for each approach. The options provided in Spring MVC Test are\ndifferent stops on the scale from classic unit testing to full integration testing. To be\ncertain, none of the options in Spring MVC Test fall under the category of classic unit\ntesting, but they are a little closer to it. For example, you can isolate the web layer\nby injecting mocked services into controllers, in which case you are testing the web\nlayer only through the `DispatcherServlet` but with actual Spring configuration, as you\nmight test the data access layer in isolation from the layers above it. Also, you can use\nthe standalone setup, focusing on one controller at a time and manually providing the\nconfiguration required to make it work.\n\nAnother important distinction when using Spring MVC Test is that, conceptually, such\ntests are server-side tests, so you can check what handler was used, if an exception was\nhandled with a `HandlerExceptionResolver`, what the content of the model is, what binding\nerrors there were, and other details. That means that it is easier to write expectations,\nsince the server is not an opaque box, as it is when testing it through an actual HTTP\nclient. This is generally an advantage of classic unit testing: it is easier to write,\nreason about, and debug but does not replace the need for full integration tests. At the\nsame time, it is important not to lose sight of the fact that the response is the most\nimportant thing to check. In short, there is room for multiple styles and strategies\nof testing even within the same project.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc/vs-end-to-end-integration-tests.adoc", "title": "vs-end-to-end-integration-tests", "heading": "vs-end-to-end-integration-tests", "heading_level": 1, "file_order": 240, "section_index": 0, "content_hash": "7e57444694021b7046143039ac5498b26f009adf5e77abff3c1a1c6ef10876f2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc/vs-end-to-end-integration-tests.adoc"}}
{"id": "sha256:63886aea6645beb88073a4d4f4509c47e5f018ab0afc1aba81aeecc804f85ae5", "content": "[[testcontext-ctx-management-caching]]\n\nOnce the TestContext framework loads an `ApplicationContext` (or `WebApplicationContext`)\nfor a test, that context is cached and reused for all subsequent tests that declare the\nsame unique context configuration within the same test suite. To understand how caching\nworks, it is important to understand what is meant by \"unique\" and \"test suite.\"\n\nAn `ApplicationContext` can be uniquely identified by the combination of configuration\nparameters that is used to load it. Consequently, the unique combination of configuration\nparameters is used to generate a key under which the context is cached. The TestContext\nframework uses the following configuration parameters to build the context cache key:\n\n* `locations` (from `@ContextConfiguration`)\n* `classes` (from `@ContextConfiguration`)\n* `contextInitializerClasses` (from `@ContextConfiguration`)\n* `contextCustomizers` (from `ContextCustomizerFactory`) â€“ this includes\n `@DynamicPropertySource` methods, bean overrides (such as `@TestBean`, `@MockitoBean`,\n `@MockitoSpyBean` etc.), as well as various features from Spring Boot's testing support.\n* `contextLoader` (from `@ContextConfiguration`)\n* `parent` (from `@ContextHierarchy`)\n* `activeProfiles` (from `@ActiveProfiles`)\n* `propertySourceDescriptors` (from `@TestPropertySource`)\n* `propertySourceProperties` (from `@TestPropertySource`)\n* `resourceBasePath` (from `@WebAppConfiguration`)\n\nFor example, if `TestClassA` specifies `{\"app-config.xml\", \"test-config.xml\"}` for the\n`locations` (or `value`) attribute of `@ContextConfiguration`, the TestContext framework\nloads the corresponding `ApplicationContext` and stores it in a `static` context cache\nunder a key that is based solely on those locations. So, if `TestClassB` also defines\n`{\"app-config.xml\", \"test-config.xml\"}` for its locations (either explicitly or\nimplicitly through inheritance) but does not define `@WebAppConfiguration`, a different\n`ContextLoader`, different active profiles, different context initializers, different\ncontext customizers, different test or dynamic property sources, or a different parent\ncontext, then the same `ApplicationContext` is shared by both test classes. This means\nthat the setup cost for loading an application context is incurred only once (per test\nsuite), and subsequent test execution is much faster.\n\n.Test suites and forked processes\n[NOTE]\n====\nThe Spring TestContext framework stores application contexts in a static cache. This\nmeans that the context is literally stored in a `static` variable. In other words, if\ntests run in separate processes, the static cache is cleared between each test\nexecution, which effectively disables the caching mechanism.\n\nTo benefit from the caching mechanism, all tests must run within the same process or test\nsuite. This can be achieved by executing all tests as a group within an IDE. Similarly,\nwhen executing tests with a build framework such as Ant, Maven, or Gradle, it is\nimportant to make sure that the build framework does not fork between tests. For example,\nif the\nhttps://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#forkMode[`forkMode`]\nfor the Maven Surefire plug-in is set to `always` or `pertest`, the TestContext framework\ncannot cache application contexts between test classes, and the build process runs\nsignificantly more slowly as a result.\n====\n\nThe size of the context cache is bounded with a default maximum size of 32. Whenever the\nmaximum size is reached, a least recently used (LRU) eviction policy is used to evict and\nclose stale contexts. You can configure the maximum size from the command line or a build\nscript by setting a JVM system property named `spring.test.context.cache.maxSize`. As an\nalternative, you can set the same property via the\nxref:appendix.adoc#appendix-spring-properties[`SpringProperties`] mechanism.\n\nSince having a large number of application contexts loaded within a given test suite can\ncause the suite to take an unnecessarily long time to run, it is often beneficial to\nknow exactly how many contexts have been loaded and cached. To view the statistics for\nthe underlying context cache, you can set the log level for the\n`org.springframework.test.context.cache` logging category to `DEBUG`.\n\nIn the unlikely case that a test corrupts the application context and requires reloading\n(for example, by modifying a bean definition or the state of an application object), you\ncan annotate your test class or test method with `@DirtiesContext` (see the discussion of\n`@DirtiesContext` in\nxref:testing/annotations/integration-spring/annotation-dirtiescontext.adoc[Spring Testing Annotations]).\nThis instructs Spring to remove the context from the cache and rebuild the application\ncontext before running the next test that requires the same application context. Note\nthat support for the `@DirtiesContext` annotation is provided by the\n`DirtiesContextBeforeModesTestExecutionListener` and the\n`DirtiesContextTestExecutionListener`, which are enabled by default.\n\n.ApplicationContext lifecycle and console logging\n[NOTE]\n====\nWhen you need to debug a test executed with the Spring TestContext Framework, it can be\nuseful to analyze the console output (that is, output to the `SYSOUT` and `SYSERR`\nstreams). Some build tools and IDEs are able to associate console output with a given\ntest; however, some console output cannot be easily associated with a given test.\n\nWith regard to console logging triggered by the Spring Framework itself or by components\nregistered in the `ApplicationContext`, it is important to understand the lifecycle of an\n`ApplicationContext` that has been loaded by the Spring TestContext Framework within a\ntest suite.\n\nThe `ApplicationContext` for a test is typically loaded when an instance of the test\nclass is being prepared -- for example, to perform dependency injection into `@Autowired`\nfields of the test instance. This means that any console logging triggered during the\ninitialization of the `ApplicationContext` typically cannot be associated with an\nindividual test method. However, if the context is closed immediately before the\nexecution of a test method according to xref:testing/annotations/integration-spring/annotation-dirtiescontext.adoc[`@DirtiesContext`]\nsemantics, a new instance of the context will be loaded just prior to execution of the\ntest method. In the latter scenario, an IDE or build tool may potentially associate\nconsole logging with the individual test method.\n\nThe `ApplicationContext` for a test can be closed via one of the following scenarios.\n\n* The context is closed according to `@DirtiesContext` semantics.\n* The context is closed because it has been automatically evicted from the cache\n according to the LRU eviction policy.\n* The context is closed via a JVM shutdown hook when the JVM for the test suite\n terminates.\n\nIf the context is closed according to `@DirtiesContext` semantics after a particular test\nmethod, an IDE or build tool may potentially associate console logging with the\nindividual test method. If the context is closed according to `@DirtiesContext` semantics\nafter a test class, any console logging triggered during the shutdown of the\n`ApplicationContext` cannot be associated with an individual test method. Similarly, any\nconsole logging triggered during the shutdown phase via a JVM shutdown hook cannot be\nassociated with an individual test method.\n\nWhen a Spring `ApplicationContext` is closed via a JVM shutdown hook, callbacks executed\nduring the shutdown phase are executed on a thread named `SpringContextShutdownHook`. So,\nif you wish to disable console logging triggered when the `ApplicationContext` is closed\nvia a JVM shutdown hook, you may be able to register a custom filter with your logging\nframework that allows you to ignore any logging initiated by that thread.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/caching.adoc", "title": "caching", "heading": "caching", "heading_level": 1, "file_order": 241, "section_index": 0, "content_hash": "63886aea6645beb88073a4d4f4509c47e5f018ab0afc1aba81aeecc804f85ae5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/caching.adoc"}}
{"id": "sha256:45c5a1f1d1bf7573c7df29747fc0c7600bbb89e7e1da176d156aa13a8098bd51", "content": "[[testcontext-context-customizers]]\n\nA `ContextCustomizer` is responsible for customizing the supplied\n`ConfigurableApplicationContext` after bean definitions have been loaded into the context\nbut before the context has been refreshed.\n\nA `ContextCustomizerFactory` is responsible for creating a `ContextCustomizer`, based on\nsome custom logic which determines if the `ContextCustomizer` is necessary for a given\ntest class -- for example, based on the presence of a certain annotation. Factories are\ninvoked after `ContextLoaders` have processed context configuration attributes for a test\nclass but before the `MergedContextConfiguration` is created.\n\nFor example, Spring Framework provides the following `ContextCustomizerFactory`\nimplementation which is registered by default:\n\n`MockServerContainerContextCustomizerFactory`:: Creates a\n `MockServerContainerContextCustomizer` if WebSocket support is present in the classpath\n and the test class or one of its enclosing classes is annotated or meta-annotated with\n `@WebAppConfiguration`. `MockServerContainerContextCustomizer` instantiates a new\n `MockServerContainer` and stores it in the `ServletContext` under the attribute named\n `jakarta.websocket.server.ServerContainer`.\n\n[[testcontext-context-customizers-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/context-customizers.adoc", "title": "context-customizers", "heading": "context-customizers", "heading_level": 1, "file_order": 242, "section_index": 0, "content_hash": "45c5a1f1d1bf7573c7df29747fc0c7600bbb89e7e1da176d156aa13a8098bd51", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/context-customizers.adoc"}}
{"id": "sha256:caaae581f8e7e4fac96663e766699b065c80266a9e888b92026511556c97c392", "content": "You can register `ContextCustomizerFactory` implementations explicitly for a test class, its\nsubclasses, and its nested classes by using the `@ContextCustomizerFactories` annotation. See\nxref:testing/annotations/integration-spring/annotation-contextcustomizerfactories.adoc[annotation support]\nand the javadoc for\n{spring-framework-api}/test/context/ContextCustomizerFactories.html[`@ContextCustomizerFactories`]\nfor details and examples.\n\n[[testcontext-context-customizers-automatic-discovery]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/context-customizers.adoc", "title": "context-customizers", "heading": "Registering `ContextCustomizerFactory` Implementations", "heading_level": 2, "file_order": 242, "section_index": 1, "content_hash": "caaae581f8e7e4fac96663e766699b065c80266a9e888b92026511556c97c392", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/context-customizers.adoc"}}
{"id": "sha256:f203daf4b1d7b9f43720c4e948f7e347d8fbd023c4a75674305ff23b6fb25ad3", "content": "Registering `ContextCustomizerFactory` implementations by using `@ContextCustomizerFactories` is\nsuitable for custom factories that are used in limited testing scenarios. However, it can\nbecome cumbersome if a custom factory needs to be used across an entire test suite. This\nissue is addressed through support for automatic discovery of default\n`ContextCustomizerFactory` implementations through the `SpringFactoriesLoader` mechanism.\n\nFor example, the modules that make up the testing support in Spring Framework and Spring\nBoot declare all core default `ContextCustomizerFactory` implementations under the\n`org.springframework.test.context.ContextCustomizerFactory` key in their\n`META-INF/spring.factories` properties files. The `spring.factories` file for the\n`spring-test` module can be viewed\n{spring-framework-code}/spring-test/src/main/resources/META-INF/spring.factories[here].\nThird-party frameworks and developers can contribute their own `ContextCustomizerFactory`\nimplementations to the list of default factories in the same manner through their own\n`spring.factories` files.\n\n[[testcontext-context-customizers-merging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/context-customizers.adoc", "title": "context-customizers", "heading": "Automatic Discovery of Default `ContextCustomizerFactory` Implementations", "heading_level": 2, "file_order": 242, "section_index": 2, "content_hash": "f203daf4b1d7b9f43720c4e948f7e347d8fbd023c4a75674305ff23b6fb25ad3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/context-customizers.adoc"}}
{"id": "sha256:38be85247688fbaf1272c5f5a1cf0ec6342ef027bcac2a7ebdb4c8c1b5e26051", "content": "If a custom `ContextCustomizerFactory` is registered via `@ContextCustomizerFactories`, it\nwill be _merged_ with the default factories that have been registered using the aforementioned\nxref:testing/testcontext-framework/ctx-management/context-customizers.adoc#testcontext-context-customizers-automatic-discovery[automatic discovery mechanism].\n\nThe merging algorithm ensures that duplicates are removed from the list and that locally\ndeclared factories are appended to the list of default factories when merged.\n\n[TIP]\n====\nTo replace the default factories for a test class, its subclasses, and its nested\nclasses, you can set the `mergeMode` attribute of `@ContextCustomizerFactories` to\n`MergeMode.REPLACE_DEFAULTS`.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/context-customizers.adoc", "title": "context-customizers", "heading": "Merging `ContextCustomizerFactory` Implementations", "heading_level": 2, "file_order": 242, "section_index": 3, "content_hash": "38be85247688fbaf1272c5f5a1cf0ec6342ef027bcac2a7ebdb4c8c1b5e26051", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/context-customizers.adoc"}}
{"id": "sha256:25a945702cc308be901dee6cfe393d5f8f9414e4e728c2d24ec9c1f29b330261", "content": "[[testcontext-ctx-management-pausing]]\n\nAs of Spring Framework 7.0, an `ApplicationContext` stored in the context cache (see\nxref:testing/testcontext-framework/ctx-management/caching.adoc[Context Caching]) may be\n_paused_ when it is no longer actively in use and automatically _restarted_ the next time\nthe context is retrieved from the cache. Specifically, the latter will restart all\nauto-startup beans in the application context, effectively restoring the lifecycle state.\nThis ensures that background processes within the context are not actively running while\nthe context is not used by tests. For example, JMS listener containers, scheduled tasks,\nand any other components in the context that implement `Lifecycle` or `SmartLifecycle`\nwill be in a \"stopped\" state until the context is used again by a test. Note, however,\nthat `SmartLifecycle` components can opt out of pausing by returning `false` from\n`SmartLifecycle#isPauseable()`.\n\nYou can control whether inactive application contexts should be paused by setting the\n`PauseMode` to one of the following supported values.\n\n`ALWAYS` :: Always pause inactive application contexts.\n`ON_CONTEXT_SWITCH` :: Only pause inactive application contexts if the next context\n retrieved from the context cache is a different context.\n`NEVER` :: Never pause inactive application contexts, effectively disabling the pausing\n feature of the context cache.\n\nThe `PauseMode` defaults to `ON_CONTEXT_SWITCH`, but it can be changed from the command\nline or a build script by setting a JVM system property named\n`spring.test.context.cache.pause` to one of the supported values (case insensitive). As\nan alternative, you can set the property via the\nxref:appendix.adoc#appendix-spring-properties[`SpringProperties`] mechanism.\n\nFor example, if you want inactive application contexts to always be paused, you can\nswitch from the default `ON_CONTEXT_SWITCH` mode to `ALWAYS` by setting the\n`spring.test.context.cache.pause` system property to `always`.\n\n```shell\n-Dspring.test.context.cache.pause=always\n```\nSimilarly, if you encounter issues with `Lifecycle` components that cannot or should not\nopt out of pausing, or if you discover that your test suite runs more slowly due to the\npausing and restarting of application contexts, you can disable the pausing feature by\nsetting the `spring.test.context.cache.pause` system property to `never`.\n\n```shell\n-Dspring.test.context.cache.pause=never\n```", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/context-pausing.adoc", "title": "context-pausing", "heading": "context-pausing", "heading_level": 1, "file_order": 243, "section_index": 0, "content_hash": "25a945702cc308be901dee6cfe393d5f8f9414e4e728c2d24ec9c1f29b330261", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/context-pausing.adoc"}}
{"id": "sha256:0039af7560511df753bb29eeae5f026dc42aac4175ada8ed188c7288046d38ce", "content": "[[testcontext-ctx-management-dynamic-property-sources]]\n\nThe Spring TestContext Framework provides support for _dynamic_ properties via the\n`DynamicPropertyRegistry`, the `@DynamicPropertySource` annotation, and the\n`DynamicPropertyRegistrar` API.\n\n[NOTE]\n====\nThe dynamic property source infrastructure was originally designed to allow properties\nfrom {testcontainers-site}[Testcontainers] based tests to be exposed easily to Spring\nintegration tests. However, these features may be used with any form of external resource\nwhose lifecycle is managed outside the test's `ApplicationContext` or with beans whose\nlifecycle is managed by the test's `ApplicationContext`.\n====\n\n[[testcontext-ctx-management-dynamic-property-sources-precedence]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc", "title": "dynamic-property-sources", "heading": "dynamic-property-sources", "heading_level": 1, "file_order": 244, "section_index": 0, "content_hash": "0039af7560511df753bb29eeae5f026dc42aac4175ada8ed188c7288046d38ce", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc"}}
{"id": "sha256:47e524f398573fa19643544158a433609aa31701c7160f1361b770272e2f59c1", "content": "Dynamic properties have higher precedence than those loaded from `@TestPropertySource`,\nthe operating system's environment, Java system properties, or property sources added by\nthe application declaratively by using `@PropertySource` or programmatically. Thus,\ndynamic properties can be used to selectively override properties loaded via\n`@TestPropertySource`, system property sources, and application property sources.\n\n[[testcontext-ctx-management-dynamic-property-sources-dynamic-property-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc", "title": "dynamic-property-sources", "heading": "Precedence", "heading_level": 2, "file_order": 244, "section_index": 1, "content_hash": "47e524f398573fa19643544158a433609aa31701c7160f1361b770272e2f59c1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc"}}
{"id": "sha256:3a993edd1e82dc79721f77e52d2d40776991607b389207d697b3b955899feaf0", "content": "A `DynamicPropertyRegistry` is used to add _name-value_ pairs to the `Environment`.\nValues are dynamic and provided via a `Supplier` which is only invoked when the property\nis resolved. Typically, method references are used to supply values. The following\nsections provide examples of how to use the `DynamicPropertyRegistry`.\n\n[[testcontext-ctx-management-dynamic-property-sources-dynamic-property-source]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc", "title": "dynamic-property-sources", "heading": "`DynamicPropertyRegistry`", "heading_level": 2, "file_order": 244, "section_index": 2, "content_hash": "3a993edd1e82dc79721f77e52d2d40776991607b389207d697b3b955899feaf0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc"}}
{"id": "sha256:9d33f6a9d5fbb636627c3f5622bb4bace1ab8c6690071d828d418c5a07a536bc", "content": "In contrast to the\nxref:testing/testcontext-framework/ctx-management/property-sources.adoc[`@TestPropertySource`]\nannotation that is applied at the class level, `@DynamicPropertySource` can be applied to\n`static` methods in integration test classes in order to add properties with dynamic\nvalues to the set of `PropertySources` in the `Environment` for the `ApplicationContext`\nloaded for the integration test.\n\nMethods in integration test classes that are annotated with `@DynamicPropertySource` must\nbe `static` and must accept a single `DynamicPropertyRegistry` argument. See the\nclass-level javadoc for `DynamicPropertyRegistry` for further details.\n\n[TIP]\n====\nIf you use `@DynamicPropertySource` in a base class and discover that tests in subclasses\nfail because the dynamic properties change between subclasses, you may need to annotate\nyour base class with\nxref:testing/annotations/integration-spring/annotation-dirtiescontext.adoc[`@DirtiesContext`]\nto ensure that each subclass gets its own `ApplicationContext` with the correct dynamic\nproperties.\n====\n\nThe following example uses the Testcontainers project to manage a Redis container outside\nof the Spring `ApplicationContext`. The IP address and port of the managed Redis\ncontainer are made available to components within the test's `ApplicationContext` via the\n`redis.host` and `redis.port` properties. These properties can be accessed via Spring's\n`Environment` abstraction or injected directly into Spring-managed components â€“ for\nexample, via `@Value(\"${redis.host}\")` and `@Value(\"${redis.port}\")`, respectively.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(/* ... */)\n\t@Testcontainers\n\tclass ExampleIntegrationTests {\n\n @Container\n static GenericContainer redis =\n new GenericContainer(\"redis:5.0.3-alpine\").withExposedPorts(6379);\n\n @DynamicPropertySource\n static void redisProperties(DynamicPropertyRegistry registry) {\n registry.add(\"redis.host\", redis::getHost);\n registry.add(\"redis.port\", redis::getFirstMappedPort);\n }\n\n // tests ...\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(/* ... */)\n\t@Testcontainers\n\tclass ExampleIntegrationTests {\n\n companion object {\n\n @Container\n @JvmStatic\n val redis: GenericContainer =\n GenericContainer(\"redis:5.0.3-alpine\").withExposedPorts(6379)\n\n @DynamicPropertySource\n @JvmStatic\n fun redisProperties(registry: DynamicPropertyRegistry) {\n registry.add(\"redis.host\", redis::getHost)\n registry.add(\"redis.port\", redis::getFirstMappedPort)\n }\n }\n\n // tests ...\n\n\t}\n----\n======\n\n[[testcontext-ctx-management-dynamic-property-sources-dynamic-property-registrar]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc", "title": "dynamic-property-sources", "heading": "`@DynamicPropertySource`", "heading_level": 2, "file_order": 244, "section_index": 3, "content_hash": "9d33f6a9d5fbb636627c3f5622bb4bace1ab8c6690071d828d418c5a07a536bc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc"}}
{"id": "sha256:babb66413291246bc5930eacd599eec2b299323e114aaf26e4b8737cea56b851", "content": "As an alternative to implementing `@DynamicPropertySource` methods in integration test\nclasses, you can register implementations of the `DynamicPropertyRegistrar` API as beans\nwithin the test's `ApplicationContext`. Doing so allows you to support additional use\ncases that are not possible with a `@DynamicPropertySource` method. For example, since a\n`DynamicPropertyRegistrar` is itself a bean in the `ApplicationContext`, it can interact\nwith other beans in the context and register dynamic properties that are sourced from\nthose beans.\n\nAny bean in a test's `ApplicationContext` that implements the `DynamicPropertyRegistrar`\ninterface will be automatically detected and eagerly initialized before the singleton\npre-instantiation phase, and the `accept()` methods of such beans will be invoked with a\n`DynamicPropertyRegistry` that performs the actual dynamic property registration on\nbehalf of the registrar.\n\nWARNING: Any interaction with other beans results in eager initialization of those other\nbeans and their dependencies.\n\nThe following example demonstrates how to implement a `DynamicPropertyRegistrar` as a\nlambda expression that registers a dynamic property for the `ApiServer` bean. The\n`api.url` property can be accessed via Spring's `Environment` abstraction or injected\ndirectly into other Spring-managed components â€“ for example, via `@Value(\"${api.url}\")`,\nand the value of the `api.url` property will be dynamically retrieved from the\n`ApiServer` bean.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass TestConfig {\n\n @Bean\n ApiServer apiServer() {\n return new ApiServer();\n }\n\n @Bean\n DynamicPropertyRegistrar apiPropertiesRegistrar(ApiServer apiServer) {\n return registry -> registry.add(\"api.url\", apiServer::getUrl);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass TestConfig {\n\n @Bean\n fun apiServer(): ApiServer {\n return ApiServer()\n }\n\n @Bean\n fun apiPropertiesRegistrar(apiServer: ApiServer): DynamicPropertyRegistrar {\n return registry -> registry.add(\"api.url\", apiServer::getUrl)\n }\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc", "title": "dynamic-property-sources", "heading": "`DynamicPropertyRegistrar`", "heading_level": 2, "file_order": 244, "section_index": 4, "content_hash": "babb66413291246bc5930eacd599eec2b299323e114aaf26e4b8737cea56b851", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc"}}
{"id": "sha256:1bd5fa8d9a40f27ea30e4f780ca07a65896b0153d5125f71519a6b30c6696809", "content": "[[testcontext-ctx-management-env-profiles]]\n\nThe Spring Framework has first-class support for the notion of environments and profiles\n(AKA \"bean definition profiles\"), and integration tests can be configured to activate\nparticular bean definition profiles for various testing scenarios. This is achieved by\nannotating a test class with the `@ActiveProfiles` annotation and supplying a list of\nprofiles that should be activated when loading the `ApplicationContext` for the test.\n\nNOTE: You can use `@ActiveProfiles` with any implementation of the `SmartContextLoader`\nSPI, but `@ActiveProfiles` is not supported with implementations of the older\n`ContextLoader` SPI.\n\nConsider two examples with XML configuration and `@Configuration` classes:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- app-config.xml -->\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\"\n xmlns:jee=\"http://www.springframework.org/schema/jee\"\n xsi:schemaLocation=\"...\">\n\n <bean id=\"transferService\"\n class=\"com.bank.service.internal.DefaultTransferService\">\n <constructor-arg ref=\"accountRepository\"/>\n <constructor-arg ref=\"feePolicy\"/>\n </bean>\n\n <bean id=\"accountRepository\"\n class=\"com.bank.repository.internal.JdbcAccountRepository\">\n <constructor-arg ref=\"dataSource\"/>\n </bean>\n\n <bean id=\"feePolicy\"\n class=\"com.bank.service.internal.ZeroFeePolicy\"/>\n\n <beans profile=\"dev\">\n <jdbc:embedded-database id=\"dataSource\">\n <jdbc:script\n location=\"classpath:com/bank/config/sql/schema.sql\"/>\n <jdbc:script\n location=\"classpath:com/bank/config/sql/test-data.sql\"/>\n </jdbc:embedded-database>\n </beans>\n\n <beans profile=\"production\">\n <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/>\n </beans>\n\n <beans profile=\"default\">\n <jdbc:embedded-database id=\"dataSource\">\n <jdbc:script\n location=\"classpath:com/bank/config/sql/schema.sql\"/>\n </jdbc:embedded-database>\n </beans>\n\n\t</beans>\n----\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t// ApplicationContext will be loaded from \"classpath:/app-config.xml\"\n\t@ContextConfiguration(\"/app-config.xml\")\n\t@ActiveProfiles(\"dev\")\n\tclass TransferServiceTest {\n\n @Autowired\n TransferService transferService;\n\n @Test\n void testTransferService() {\n // test the transferService\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t// ApplicationContext will be loaded from \"classpath:/app-config.xml\"\n\t@ContextConfiguration(\"/app-config.xml\")\n\t@ActiveProfiles(\"dev\")\n\tclass TransferServiceTest {\n\n @Autowired\n lateinit var transferService: TransferService\n\n @Test\n fun testTransferService() {\n // test the transferService\n }\n\t}\n----\n======\n\nWhen `TransferServiceTest` is run, its `ApplicationContext` is loaded from the\n`app-config.xml` configuration file in the root of the classpath. If you inspect\n`app-config.xml`, you can see that the `accountRepository` bean has a dependency on a\n`dataSource` bean. However, `dataSource` is not defined as a top-level bean. Instead,\n`dataSource` is defined three times: in the `production` profile, in the `dev` profile,\nand in the `default` profile.\n\nBy annotating `TransferServiceTest` with `@ActiveProfiles(\"dev\")`, we instruct the Spring\nTestContext Framework to load the `ApplicationContext` with the active profiles set to\n`{\"dev\"}`. As a result, an embedded database is created and populated with test data, and\nthe `accountRepository` bean is wired with a reference to the development `DataSource`.\nThat is likely what we want in an integration test.\n\nIt is sometimes useful to assign beans to a `default` profile. Beans within the default\nprofile are included only when no other profile is specifically activated. You can use\nthis to define \"`fallback`\" beans to be used in the application's default state. For\nexample, you may explicitly provide a data source for `dev` and `production` profiles,\nbut define an in-memory data source as a default when neither of these is active.\n\nThe following code listings demonstrate how to implement the same configuration and\nintegration test with `@Configuration` classes instead of XML:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@Profile(\"dev\")\n\tpublic class StandaloneDataConfig {\n\n @Bean\n public DataSource dataSource() {\n return new EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.HSQL)\n .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n .addScript(\"classpath:com/bank/config/sql/test-data.sql\")\n .build();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@Profile(\"dev\")\n\tclass StandaloneDataConfig {\n\n @Bean\n fun dataSource(): DataSource {\n return EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.HSQL)\n .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n .addScript(\"classpath:com/bank/config/sql/test-data.sql\")\n .build()\n }\n\t}\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@Profile(\"production\")\n\tpublic class JndiDataConfig {\n\n @Bean(destroyMethod=\"\")\n public DataSource dataSource() throws Exception {\n Context ctx = new InitialContext();\n return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\");\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@Profile(\"production\")\n\tclass JndiDataConfig {\n\n @Bean(destroyMethod = \"\")\n fun dataSource(): DataSource {\n val ctx = InitialContext()\n return ctx.lookup(\"java:comp/env/jdbc/datasource\") as DataSource\n }\n\t}\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@Profile(\"default\")\n\tpublic class DefaultDataConfig {\n\n @Bean\n public DataSource dataSource() {\n return new EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.HSQL)\n .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n .build();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@Profile(\"default\")\n\tclass DefaultDataConfig {\n\n @Bean\n fun dataSource(): DataSource {\n return EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.HSQL)\n .addScript(\"classpath:com/bank/config/sql/schema.sql\")\n .build()\n }\n\t}\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class TransferServiceConfig {\n\n @Autowired DataSource dataSource;\n\n @Bean\n public TransferService transferService() {\n return new DefaultTransferService(accountRepository(), feePolicy());\n }\n\n @Bean\n public AccountRepository accountRepository() {\n return new JdbcAccountRepository(dataSource);\n }\n\n @Bean\n public FeePolicy feePolicy() {\n return new ZeroFeePolicy();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass TransferServiceConfig {\n\n @Autowired\n lateinit var dataSource: DataSource\n\n @Bean\n fun transferService(): TransferService {\n return DefaultTransferService(accountRepository(), feePolicy())\n }\n\n @Bean\n fun accountRepository(): AccountRepository {\n return JdbcAccountRepository(dataSource)\n }\n\n @Bean\n fun feePolicy(): FeePolicy {\n return ZeroFeePolicy()\n }\n\t}\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig({\n TransferServiceConfig.class,\n StandaloneDataConfig.class,\n JndiDataConfig.class,\n DefaultDataConfig.class})\n\t@ActiveProfiles(\"dev\")\n\tclass TransferServiceTest {\n\n @Autowired\n TransferService transferService;\n\n @Test\n void testTransferService() {\n // test the transferService\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(\n TransferServiceConfig::class,\n StandaloneDataConfig::class,\n JndiDataConfig::class,\n DefaultDataConfig::class)\n\t@ActiveProfiles(\"dev\")\n\tclass TransferServiceTest {\n\n @Autowired\n lateinit var transferService: TransferService\n\n @Test\n fun testTransferService() {\n // test the transferService\n }\n\t}\n----\n======\n\nIn this variation, we have split the XML configuration into four independent\n`@Configuration` classes:\n\n* `TransferServiceConfig`: Acquires a `dataSource` through dependency injection by using\n `@Autowired`.\n* `StandaloneDataConfig`: Defines a `dataSource` for an embedded database suitable for\n developer tests.\n* `JndiDataConfig`: Defines a `dataSource` that is retrieved from JNDI in a production\n environment.\n* `DefaultDataConfig`: Defines a `dataSource` for a default embedded database, in case no\n profile is active.\n\nAs with the XML-based configuration example, we still annotate `TransferServiceTest` with\n`@ActiveProfiles(\"dev\")`, but this time we specify all four configuration classes by\nusing the `@ContextConfiguration` annotation. The body of the test class itself remains\ncompletely unchanged.\n\nIt is often the case that a single set of profiles is used across multiple test classes\nwithin a given project. Thus, to avoid duplicate declarations of the `@ActiveProfiles`\nannotation, you can declare `@ActiveProfiles` once on a base class, and subclasses\nautomatically inherit the `@ActiveProfiles` configuration from the base class. In the\nfollowing example, the declaration of `@ActiveProfiles` (as well as other annotations)\nhas been moved to an abstract superclass, `AbstractIntegrationTest`:\n\nNOTE: Test configuration may also be inherited from enclosing classes. See\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-nested-test-configuration[`@Nested` test class configuration] for details.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig({\n TransferServiceConfig.class,\n StandaloneDataConfig.class,\n JndiDataConfig.class,\n DefaultDataConfig.class})\n\t@ActiveProfiles(\"dev\")\n\tabstract class AbstractIntegrationTest {\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(\n TransferServiceConfig::class,\n StandaloneDataConfig::class,\n JndiDataConfig::class,\n DefaultDataConfig::class)\n\t@ActiveProfiles(\"dev\")\n\tabstract class AbstractIntegrationTest {\n\t}\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// \"dev\" profile inherited from superclass\n\tclass TransferServiceTest extends AbstractIntegrationTest {\n\n @Autowired\n TransferService transferService;\n\n @Test\n void testTransferService() {\n // test the transferService\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// \"dev\" profile inherited from superclass\n\tclass TransferServiceTest : AbstractIntegrationTest() {\n\n @Autowired\n lateinit var transferService: TransferService\n\n @Test\n fun testTransferService() {\n // test the transferService\n }\n\t}\n----\n======\n\n`@ActiveProfiles` also supports an `inheritProfiles` attribute that can be used to\ndisable the inheritance of active profiles, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// \"dev\" profile overridden with \"production\"\n\t@ActiveProfiles(profiles = \"production\", inheritProfiles = false)\n\tclass ProductionTransferServiceTest extends AbstractIntegrationTest {\n // test body\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// \"dev\" profile overridden with \"production\"\n\t@ActiveProfiles(\"production\", inheritProfiles = false)\n\tclass ProductionTransferServiceTest : AbstractIntegrationTest() {\n // test body\n\t}\n----\n======\n\n[[testcontext-ctx-management-env-profiles-ActiveProfilesResolver]]\nFurthermore, it is sometimes necessary to resolve active profiles for tests\nprogrammatically instead of declaratively -- for example, based on:\n\n* The current operating system.\n* Whether tests are being run on a continuous integration build server.\n* The presence of certain environment variables.\n* The presence of custom class-level annotations.\n* Other concerns.\n\nTo resolve active bean definition profiles programmatically, you can implement\na custom `ActiveProfilesResolver` and register it by using the `resolver`\nattribute of `@ActiveProfiles`. For further information, see the corresponding\n{spring-framework-api}/test/context/ActiveProfilesResolver.html[javadoc].\nThe following example demonstrates how to implement and register a custom\n`OperatingSystemActiveProfilesResolver`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// \"dev\" profile overridden programmatically via a custom resolver\n\t@ActiveProfiles(\n resolver = OperatingSystemActiveProfilesResolver.class,\n inheritProfiles = false)\n\tclass TransferServiceTest extends AbstractIntegrationTest {\n // test body\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// \"dev\" profile overridden programmatically via a custom resolver\n\t@ActiveProfiles(\n resolver = OperatingSystemActiveProfilesResolver::class,\n inheritProfiles = false)\n\tclass TransferServiceTest : AbstractIntegrationTest() {\n // test body\n\t}\n----\n======\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class OperatingSystemActiveProfilesResolver implements ActiveProfilesResolver {\n\n @Override\n public String[] resolve(Class<?> testClass) {\n String profile = ...;\n // determine the value of profile based on the operating system\n return new String[] {profile};\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass OperatingSystemActiveProfilesResolver : ActiveProfilesResolver {\n\n override fun resolve(testClass: Class<*>): Array<String> {\n val profile: String = ...\n // determine the value of profile based on the operating system\n return arrayOf(profile)\n }\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/env-profiles.adoc", "title": "env-profiles", "heading": "env-profiles", "heading_level": 1, "file_order": 245, "section_index": 0, "content_hash": "1bd5fa8d9a40f27ea30e4f780ca07a65896b0153d5125f71519a6b30c6696809", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/env-profiles.adoc"}}
{"id": "sha256:57a46aa6a253fb0b55db6ed26a7bd25c511da6ec11f99ee97c094514554c2596", "content": "[[testcontext-ctx-management-failure-threshold]]\n\nAs of Spring Framework 6.1, a context _failure threshold_ policy is in place which helps\navoid repeated attempts to load a failing `ApplicationContext`. By default, the failure\nthreshold is set to `1` which means that only one attempt will be made to load an\n`ApplicationContext` for a given context cache key (see\nxref:testing/testcontext-framework/ctx-management/caching.adoc[Context Caching]). Any\nsubsequent attempt to load the `ApplicationContext` for the same context cache key will\nresult in an immediate `IllegalStateException` with an error message which explains that\nthe attempt was preemptively skipped. This behavior allows individual test classes and\ntest suites to fail faster by avoiding repeated attempts to load an `ApplicationContext`\nthat will never successfully load -- for example, due to a configuration error or a missing\nexternal resource that prevents the context from loading in the current environment.\n\nYou can configure the context failure threshold from the command line or a build script\nby setting a JVM system property named `spring.test.context.failure.threshold` with a\npositive integer value. As an alternative, you can set the same property via the\nxref:appendix.adoc#appendix-spring-properties[`SpringProperties`] mechanism.\n\nNOTE: If you wish to effectively disable the context failure threshold, you can set the\nproperty to a very large value. For example, from the command line you could set the\nsystem property via `-Dspring.test.context.failure.threshold=1000000`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/failure-threshold.adoc", "title": "failure-threshold", "heading": "failure-threshold", "heading_level": 1, "file_order": 246, "section_index": 0, "content_hash": "57a46aa6a253fb0b55db6ed26a7bd25c511da6ec11f99ee97c094514554c2596", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/failure-threshold.adoc"}}
{"id": "sha256:11b305512ef3fd02d24766a28a7f961d37ad44c02165fad6929093d0c1e24680", "content": "[[testcontext-ctx-management-groovy]]\n\nTo load an `ApplicationContext` for your tests by using Groovy scripts that use the\nxref:core/beans/basics.adoc#beans-factory-groovy[Groovy Bean Definition DSL], you can annotate\nyour test class with `@ContextConfiguration` and configure the `locations` or `value`\nattribute with an array that contains the resource locations of Groovy scripts. Resource\nlookup semantics for Groovy scripts are the same as those described for\nxref:testing/testcontext-framework/ctx-management/xml.adoc[XML configuration files].\n\n.Enabling Groovy script support\nTIP: Support for using Groovy scripts to load an `ApplicationContext` in the Spring\nTestContext Framework is enabled automatically if Groovy is on the classpath.\n\nThe following example shows how to specify Groovy configuration files:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t// ApplicationContext will be loaded from \"/AppConfig.groovy\" and\n\t// \"/TestConfig.groovy\" in the root of the classpath\n\t@ContextConfiguration({\"/AppConfig.groovy\", \"/TestConfig.Groovy\"}) <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Specifying the location of Groovy configuration files.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t// ApplicationContext will be loaded from \"/AppConfig.groovy\" and\n\t// \"/TestConfig.groovy\" in the root of the classpath\n\t@ContextConfiguration(\"/AppConfig.groovy\", \"/TestConfig.Groovy\") // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Specifying the location of Groovy configuration files.\n======\n\nIf you omit both the `locations` and `value` attributes from the `@ContextConfiguration`\nannotation, the TestContext framework tries to detect a default Groovy script.\nSpecifically, `GenericGroovyXmlContextLoader` and `GenericGroovyXmlWebContextLoader`\ndetect a default location based on the name of the test class. If your class is named\n`com.example.MyTest`, the Groovy context loader loads your application context from\n`\"classpath:com/example/MyTestContext.groovy\"`. The following example shows how to use\nthe default:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t// ApplicationContext will be loaded from\n\t// \"classpath:com/example/MyTestContext.groovy\"\n\t@ContextConfiguration // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Loading configuration from the default location.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t// ApplicationContext will be loaded from\n\t// \"classpath:com/example/MyTestContext.groovy\"\n\t@ContextConfiguration // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Loading configuration from the default location.\n======\n\n.Declaring XML configuration and Groovy scripts simultaneously\n[TIP]\n=====\nYou can declare both XML configuration files and Groovy scripts simultaneously by using\nthe `locations` or `value` attribute of `@ContextConfiguration`. If the path to a\nconfigured resource location ends with `.xml`, it is loaded by using an\n`XmlBeanDefinitionReader`. Otherwise, it is loaded by using a\n`GroovyBeanDefinitionReader`.\n\nThe following listing shows how to combine both in an integration test:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t// ApplicationContext will be loaded from\n\t// \"/app-config.xml\" and \"/TestConfig.groovy\"\n\t@ContextConfiguration({ \"/app-config.xml\", \"/TestConfig.groovy\" })\n\tclass MyTest {\n // class body...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t// ApplicationContext will be loaded from\n\t// \"/app-config.xml\" and \"/TestConfig.groovy\"\n\t@ContextConfiguration(\"/app-config.xml\", \"/TestConfig.groovy\")\n\tclass MyTest {\n // class body...\n\t}\n----\n======\n=====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/groovy.adoc", "title": "groovy", "heading": "groovy", "heading_level": 1, "file_order": 247, "section_index": 0, "content_hash": "11b305512ef3fd02d24766a28a7f961d37ad44c02165fad6929093d0c1e24680", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/groovy.adoc"}}
{"id": "sha256:883d22d15ab3f83e280cf8dcf5bd798aa7df418f109f243255859acbb1ad0ae6", "content": "[[testcontext-ctx-management-ctx-hierarchies]]\n\nWhen writing integration tests that rely on a loaded Spring `ApplicationContext`, it is\noften sufficient to test against a single context. However, there are times when it is\nbeneficial or even necessary to test against a hierarchy of `ApplicationContext`\ninstances. For example, if you are developing a Spring MVC web application, you typically\nhave a root `WebApplicationContext` loaded by Spring's `ContextLoaderListener` and a\nchild `WebApplicationContext` loaded by Spring's `DispatcherServlet`. This results in a\nparent-child context hierarchy where shared components and infrastructure configuration\nare declared in the root context and consumed in the child context by web-specific\ncomponents. Another use case can be found in Spring Batch applications, where you often\nhave a parent context that provides configuration for shared batch infrastructure and a\nchild context for the configuration of a specific batch job.\n\nYou can write integration tests that use context hierarchies by declaring context\nconfiguration with the `@ContextHierarchy` annotation, either on an individual test class\nor within a test class hierarchy. If a context hierarchy is declared on multiple classes\nwithin a test class hierarchy, you can also merge or override the context configuration\nfor a specific, named level in the context hierarchy. When merging configuration for a\ngiven level in the hierarchy, the configuration resource type (that is, XML configuration\nfiles or component classes) must be consistent. Otherwise, it is perfectly acceptable to\nhave different levels in a context hierarchy configured using different resource types.\n\n[NOTE]\n====\nIf you use `@DirtiesContext` in a test whose context is configured as part of a context\nhierarchy, you can use the `hierarchyMode` flag to control how the context cache is\ncleared.\n\nFor further details, see the discussion of `@DirtiesContext` in\nxref:testing/annotations/integration-spring/annotation-dirtiescontext.adoc[Spring Testing Annotations]\nand the {spring-framework-api}/test/annotation/DirtiesContext.html[`@DirtiesContext`] javadoc.\n====\n\nThe JUnit Jupiter based examples in this section show common configuration scenarios for\nintegration tests that require the use of context hierarchies.\n\n**Single test class with context hierarchy**\n--\n`ControllerIntegrationTests` represents a typical integration testing scenario for a\nSpring MVC web application by declaring a context hierarchy that consists of two levels,\none for the root `WebApplicationContext` (loaded by using the `TestAppConfig`\n`@Configuration` class) and one for the dispatcher servlet `WebApplicationContext`\n(loaded by using the `WebConfig` `@Configuration` class). The `WebApplicationContext`\nthat is autowired into the test instance is the one for the child context (that is, the\nlowest context in the hierarchy). The following listing shows this configuration scenario:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t@WebAppConfiguration\n\t@ContextHierarchy({\n @ContextConfiguration(classes = TestAppConfig.class),\n @ContextConfiguration(classes = WebConfig.class)\n\t})\n\tclass ControllerIntegrationTests {\n\n @Autowired\n WebApplicationContext wac;\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t@WebAppConfiguration\n\t@ContextHierarchy(\n ContextConfiguration(classes = [TestAppConfig::class]),\n ContextConfiguration(classes = [WebConfig::class]))\n\tclass ControllerIntegrationTests {\n\n @Autowired\n lateinit var wac: WebApplicationContext\n\n // ...\n\t}\n----\n======\n--\n\n**Class hierarchy with implicit parent context**\n--\nThe test classes in this example define a context hierarchy within a test class\nhierarchy. `AbstractWebTests` declares the configuration for a root\n`WebApplicationContext` in a Spring-powered web application. Note, however, that\n`AbstractWebTests` does not declare `@ContextHierarchy`. Consequently, subclasses of\n`AbstractWebTests` can optionally participate in a context hierarchy or follow the\nstandard semantics for `@ContextConfiguration`. `SoapWebServiceTests` and\n`RestWebServiceTests` both extend `AbstractWebTests` and define a context hierarchy by\nusing `@ContextHierarchy`. The result is that three application contexts are loaded (one\nfor each declaration of `@ContextConfiguration`), and the application context loaded\nbased on the configuration in `AbstractWebTests` is set as the parent context for each of\nthe contexts loaded for the concrete subclasses. The following listing shows this\nconfiguration scenario:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t@WebAppConfiguration\n\t@ContextConfiguration(\"file:src/main/webapp/WEB-INF/applicationContext.xml\")\n\tpublic abstract class AbstractWebTests {}\n\n\t@ContextHierarchy(@ContextConfiguration(\"/spring/soap-ws-config.xml\"))\n\tpublic class SoapWebServiceTests extends AbstractWebTests {}\n\n\t@ContextHierarchy(@ContextConfiguration(\"/spring/rest-ws-config.xml\"))\n\tpublic class RestWebServiceTests extends AbstractWebTests {}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t@WebAppConfiguration\n\t@ContextConfiguration(\"file:src/main/webapp/WEB-INF/applicationContext.xml\")\n\tabstract class AbstractWebTests\n\n\t@ContextHierarchy(ContextConfiguration(\"/spring/soap-ws-config.xml\"))\n\tclass SoapWebServiceTests : AbstractWebTests()\n\n\t@ContextHierarchy(ContextConfiguration(\"/spring/rest-ws-config.xml\"))\n\tclass RestWebServiceTests : AbstractWebTests()\n\n----\n======\n--\n\n**Class hierarchy with merged context hierarchy configuration**\n--\nThe classes in this example show the use of named hierarchy levels in order to merge the\nconfiguration for specific levels in a context hierarchy. `BaseTests` defines two levels\nin the hierarchy, `parent` and `child`. `ExtendedTests` extends `BaseTests` and instructs\nthe Spring TestContext Framework to merge the context configuration for the `child`\nhierarchy level, by ensuring that the names declared in the `name` attribute in\n`@ContextConfiguration` are both `child`. The result is that three application contexts\nare loaded: one for `/app-config.xml`, one for `/user-config.xml`, and one for\n`{\"/user-config.xml\", \"/order-config.xml\"}`. As with the previous example, the\napplication context loaded from `/app-config.xml` is set as the parent context for the\ncontexts loaded from `/user-config.xml` and `{\"/user-config.xml\", \"/order-config.xml\"}`.\nThe following listing shows this configuration scenario:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t@ContextHierarchy({\n @ContextConfiguration(name = \"parent\", locations = \"/app-config.xml\"),\n @ContextConfiguration(name = \"child\", locations = \"/user-config.xml\")\n\t})\n\tclass BaseTests {}\n\n\t@ContextHierarchy(\n @ContextConfiguration(name = \"child\", locations = \"/order-config.xml\")\n\t)\n\tclass ExtendedTests extends BaseTests {}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t@ContextHierarchy(\n ContextConfiguration(name = \"parent\", locations = [\"/app-config.xml\"]),\n ContextConfiguration(name = \"child\", locations = [\"/user-config.xml\"]))\n\topen class BaseTests {}\n\n\t@ContextHierarchy(\n ContextConfiguration(name = \"child\", locations = [\"/order-config.xml\"])\n\t)\n\tclass ExtendedTests : BaseTests() {}\n----\n======\n--\n\n**Class hierarchy with overridden context hierarchy configuration**\n--\nIn contrast to the previous example, this example demonstrates how to override the\nconfiguration for a given named level in a context hierarchy by setting the\n`inheritLocations` flag in `@ContextConfiguration` to `false`. Consequently, the\napplication context for `ExtendedTests` is loaded only from `/test-user-config.xml` and\nhas its parent set to the context loaded from `/app-config.xml`. The following listing\nshows this configuration scenario:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t@ContextHierarchy({\n @ContextConfiguration(name = \"parent\", locations = \"/app-config.xml\"),\n @ContextConfiguration(name = \"child\", locations = \"/user-config.xml\")\n\t})\n\tclass BaseTests {}\n\n\t@ContextHierarchy(\n @ContextConfiguration(\n name = \"child\",\n locations = \"/test-user-config.xml\",\n inheritLocations = false\n\t))\n\tclass ExtendedTests extends BaseTests {}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t@ContextHierarchy(\n ContextConfiguration(name = \"parent\", locations = [\"/app-config.xml\"]),\n ContextConfiguration(name = \"child\", locations = [\"/user-config.xml\"]))\n\topen class BaseTests {}\n\n\t@ContextHierarchy(\n ContextConfiguration(\n name = \"child\",\n locations = [\"/test-user-config.xml\"],\n inheritLocations = false\n ))\n\tclass ExtendedTests : BaseTests() {}\n----\n======\n--\n\n[[testcontext-ctx-management-ctx-hierarchies-with-bean-overrides]]\n**Context hierarchies with bean overrides**\n--\nWhen `@ContextHierarchy` is used in conjunction with\nxref:testing/testcontext-framework/bean-overriding.adoc[bean overrides] such as\n`@TestBean`, `@MockitoBean`, or `@MockitoSpyBean`, it may be desirable or necessary to\nhave the override applied to a single level in the context hierarchy. To achieve that,\nthe bean override must specify a context name that matches a name configured via the\n`name` attribute in `@ContextConfiguration`.\n\nThe following test class configures the name of the second hierarchy level to be\n`\"user-config\"` and simultaneously specifies that the `UserService` should be wrapped in\na Mockito spy in the context named `\"user-config\"`. Consequently, Spring will only\nattempt to create the spy in the `\"user-config\"` context and will not attempt to create\nthe spy in the parent context.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t@ContextHierarchy({\n @ContextConfiguration(classes = AppConfig.class),\n @ContextConfiguration(classes = UserConfig.class, name = \"user-config\")\n\t})\n\tclass IntegrationTests {\n\n @MockitoSpyBean(contextName = \"user-config\")\n UserService userService;\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t@ContextHierarchy(\n ContextConfiguration(classes = [AppConfig::class]),\n ContextConfiguration(classes = [UserConfig::class], name = \"user-config\"))\n\tclass IntegrationTests {\n\n @MockitoSpyBean(contextName = \"user-config\")\n lateinit var userService: UserService\n\n // ...\n\t}\n----\n======\n\nWhen applying bean overrides in different levels of the context hierarchy, you may need\nto have all of the bean override instances injected into the test class in order to\ninteract with them â€” for example, to configure stubbing for mocks. However, `@Autowired`\nwill always inject a matching bean found in the lowest level of the context hierarchy.\nThus, to inject bean override instances from specific levels in the context hierarchy,\nyou need to annotate fields with appropriate bean override annotations and configure the\nname of the context level.\n\nThe following test class configures the names of the hierarchy levels to be `\"parent\"`\nand `\"child\"`. It also declares two `PropertyService` fields that are configured to\ncreate or replace `PropertyService` beans with Mockito mocks in the respective contexts,\nnamed `\"parent\"` and `\"child\"`. Consequently, the mock from the `\"parent\"` context will\nbe injected into the `propertyServiceInParent` field, and the mock from the `\"child\"`\ncontext will be injected into the `propertyServiceInChild` field.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t@ContextHierarchy({\n @ContextConfiguration(classes = ParentConfig.class, name = \"parent\"),\n @ContextConfiguration(classes = ChildConfig.class, name = \"child\")\n\t})\n\tclass IntegrationTests {\n\n @MockitoBean(contextName = \"parent\")\n PropertyService propertyServiceInParent;\n\n @MockitoBean(contextName = \"child\")\n PropertyService propertyServiceInChild;\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t@ContextHierarchy(\n ContextConfiguration(classes = [ParentConfig::class], name = \"parent\"),\n ContextConfiguration(classes = [ChildConfig::class], name = \"child\"))\n\tclass IntegrationTests {\n\n @MockitoBean(contextName = \"parent\")\n lateinit var propertyServiceInParent: PropertyService\n\n @MockitoBean(contextName = \"child\")\n lateinit var propertyServiceInChild: PropertyService\n\n // ...\n\t}\n----\n======\n--", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/hierarchies.adoc", "title": "hierarchies", "heading": "hierarchies", "heading_level": 1, "file_order": 248, "section_index": 0, "content_hash": "883d22d15ab3f83e280cf8dcf5bd798aa7df418f109f243255859acbb1ad0ae6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/hierarchies.adoc"}}
{"id": "sha256:50f5c5fef1618f0cadc286d185887a081211fffef62e2412f38f5fff64996ba4", "content": "[[testcontext-ctx-management-inheritance]]\n\n`@ContextConfiguration` supports boolean `inheritLocations` and `inheritInitializers`\nattributes that denote whether resource locations or component classes and context\ninitializers declared by superclasses should be inherited. The default value for both\nflags is `true`. This means that a test class inherits the resource locations or\ncomponent classes as well as the context initializers declared by any superclasses.\nSpecifically, the resource locations or component classes for a test class are appended\nto the list of resource locations or annotated classes declared by superclasses.\nSimilarly, the initializers for a given test class are added to the set of initializers\ndefined by test superclasses. Thus, subclasses have the option of extending the resource\nlocations, component classes, or context initializers.\n\nIf the `inheritLocations` or `inheritInitializers` attribute in `@ContextConfiguration`\nis set to `false`, the resource locations or component classes and the context\ninitializers, respectively, for the test class shadow and effectively replace the\nconfiguration defined by superclasses.\n\nNOTE: Test configuration may also be inherited from enclosing classes. See\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-nested-test-configuration[`@Nested` test class configuration] for details.\n\nIn the next example, which uses XML resource locations, the `ApplicationContext` for\n`ExtendedTest` is loaded from `base-config.xml` and `extended-config.xml`, in that order.\nBeans defined in `extended-config.xml` can, therefore, override (that is, replace) those\ndefined in `base-config.xml`. The following example shows how one class can extend\nanother and use both its own configuration file and the superclass's configuration file:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t// ApplicationContext will be loaded from \"/base-config.xml\"\n\t// in the root of the classpath\n\t@ContextConfiguration(\"/base-config.xml\") <1>\n\tclass BaseTest {\n // class body...\n\t}\n\n\t// ApplicationContext will be loaded from \"/base-config.xml\" and\n\t// \"/extended-config.xml\" in the root of the classpath\n\t@ContextConfiguration(\"/extended-config.xml\") <2>\n\tclass ExtendedTest extends BaseTest {\n // class body...\n\t}\n----\n<1> Configuration file defined in the superclass.\n<2> Configuration file defined in the subclass.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t// ApplicationContext will be loaded from \"/base-config.xml\"\n\t// in the root of the classpath\n\t@ContextConfiguration(\"/base-config.xml\") // <1>\n\topen class BaseTest {\n // class body...\n\t}\n\n\t// ApplicationContext will be loaded from \"/base-config.xml\" and\n\t// \"/extended-config.xml\" in the root of the classpath\n\t@ContextConfiguration(\"/extended-config.xml\") // <2>\n\tclass ExtendedTest : BaseTest() {\n // class body...\n\t}\n----\n<1> Configuration file defined in the superclass.\n<2> Configuration file defined in the subclass.\n======\n\nSimilarly, in the next example, which uses component classes, the `ApplicationContext`\nfor `ExtendedTest` is loaded from the `BaseConfig` and `ExtendedConfig` classes, in that\norder. Beans defined in `ExtendedConfig` can, therefore, override (that is, replace)\nthose defined in `BaseConfig`. The following example shows how one class can extend\nanother and use both its own configuration class and the superclass's configuration class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// ApplicationContext will be loaded from BaseConfig\n\t@SpringJUnitConfig(BaseConfig.class) // <1>\n\tclass BaseTest {\n // class body...\n\t}\n\n\t// ApplicationContext will be loaded from BaseConfig and ExtendedConfig\n\t@SpringJUnitConfig(ExtendedConfig.class) // <2>\n\tclass ExtendedTest extends BaseTest {\n // class body...\n\t}\n----\n<1> Configuration class defined in the superclass.\n<2> Configuration class defined in the subclass.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// ApplicationContext will be loaded from BaseConfig\n\t@SpringJUnitConfig(BaseConfig::class) // <1>\n\topen class BaseTest {\n // class body...\n\t}\n\n\t// ApplicationContext will be loaded from BaseConfig and ExtendedConfig\n\t@SpringJUnitConfig(ExtendedConfig::class) // <2>\n\tclass ExtendedTest : BaseTest() {\n // class body...\n\t}\n----\n<1> Configuration class defined in the superclass.\n<2> Configuration class defined in the subclass.\n======\n\nIn the next example, which uses context initializers, the `ApplicationContext` for\n`ExtendedTest` is initialized by using `BaseInitializer` and `ExtendedInitializer`. Note,\nhowever, that the order in which the initializers are invoked depends on whether they\nimplement Spring's `Ordered` interface or are annotated with Spring's `@Order` annotation\nor the standard `@Priority` annotation. The following example shows how one class can\nextend another and use both its own initializer and the superclass's initializer:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// ApplicationContext will be initialized by BaseInitializer\n\t@SpringJUnitConfig(initializers = BaseInitializer.class) // <1>\n\tclass BaseTest {\n // class body...\n\t}\n\n\t// ApplicationContext will be initialized by BaseInitializer\n\t// and ExtendedInitializer\n\t@SpringJUnitConfig(initializers = ExtendedInitializer.class) // <2>\n\tclass ExtendedTest extends BaseTest {\n // class body...\n\t}\n----\n<1> Initializer defined in the superclass.\n<2> Initializer defined in the subclass.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// ApplicationContext will be initialized by BaseInitializer\n\t@SpringJUnitConfig(initializers = [BaseInitializer::class]) // <1>\n\topen class BaseTest {\n // class body...\n\t}\n\n\t// ApplicationContext will be initialized by BaseInitializer\n\t// and ExtendedInitializer\n\t@SpringJUnitConfig(initializers = [ExtendedInitializer::class]) // <2>\n\tclass ExtendedTest : BaseTest() {\n // class body...\n\t}\n----\n<1> Initializer defined in the superclass.\n<2> Initializer defined in the subclass.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/inheritance.adoc", "title": "inheritance", "heading": "inheritance", "heading_level": 1, "file_order": 249, "section_index": 0, "content_hash": "50f5c5fef1618f0cadc286d185887a081211fffef62e2412f38f5fff64996ba4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/inheritance.adoc"}}
{"id": "sha256:2c77d0171f88ddc7c2261b215fc0f24e319f13c0aa80026565d54d50d451197f", "content": "[[testcontext-ctx-management-initializers]]\n\nTo configure an `ApplicationContext` for your tests by using context initializers,\nannotate your test class with `@ContextConfiguration` and configure the `initializers`\nattribute with an array that contains references to classes that implement\n`ApplicationContextInitializer`. The declared context initializers are then used to\ninitialize the `ConfigurableApplicationContext` that is loaded for your tests. Note that\nthe concrete `ConfigurableApplicationContext` type supported by each declared initializer\nmust be compatible with the type of `ApplicationContext` created by the\n`SmartContextLoader` in use (typically a `GenericApplicationContext`). Furthermore, the\norder in which the initializers are invoked depends on whether they implement Spring's\n`Ordered` interface or are annotated with Spring's `@Order` annotation or the standard\n`@Priority` annotation. The following example shows how to use initializers:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t// ApplicationContext will be loaded from TestConfig\n\t// and initialized by TestAppCtxInitializer\n\t@ContextConfiguration(\n classes = TestConfig.class,\n initializers = TestAppCtxInitializer.class) // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Specifying configuration by using a configuration class and an initializer.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t// ApplicationContext will be loaded from TestConfig\n\t// and initialized by TestAppCtxInitializer\n\t@ContextConfiguration(\n classes = [TestConfig::class],\n initializers = [TestAppCtxInitializer::class]) // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Specifying configuration by using a configuration class and an initializer.\n======\n\nYou can also omit the declaration of XML configuration files, Groovy scripts, or\ncomponent classes in `@ContextConfiguration` entirely and instead declare only\n`ApplicationContextInitializer` classes, which are then responsible for registering beans\nin the context -- for example, by programmatically loading bean definitions from XML\nfiles or configuration classes. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t// ApplicationContext will be initialized by EntireAppInitializer\n\t// which presumably registers beans in the context\n\t@ContextConfiguration(initializers = EntireAppInitializer.class) <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Specifying configuration by using only an initializer.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t// ApplicationContext will be initialized by EntireAppInitializer\n\t// which presumably registers beans in the context\n\t@ContextConfiguration(initializers = [EntireAppInitializer::class]) // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Specifying configuration by using only an initializer.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/initializers.adoc", "title": "initializers", "heading": "initializers", "heading_level": 1, "file_order": 250, "section_index": 0, "content_hash": "2c77d0171f88ddc7c2261b215fc0f24e319f13c0aa80026565d54d50d451197f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/initializers.adoc"}}
{"id": "sha256:e79d0fbb164b1eef9593b51838d092676e6d42b6f2533c0e04bfee9c8a5fa2d7", "content": "[[testcontext-ctx-management-javaconfig]]\n\nTo load an `ApplicationContext` for your tests by using component classes (see\nxref:core/beans/java.adoc[Java-based container configuration]), you can annotate your test\nclass with `@ContextConfiguration` and configure the `classes` attribute with an array\nthat contains references to component classes. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t// ApplicationContext will be loaded from AppConfig and TestConfig\n\t@ContextConfiguration(classes = {AppConfig.class, TestConfig.class}) // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Specifying component classes.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t// ApplicationContext will be loaded from AppConfig and TestConfig\n\t@ContextConfiguration(classes = [AppConfig::class, TestConfig::class]) // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Specifying component classes.\n======\n\n[[testcontext-ctx-management-javaconfig-component-classes]]\n.Component Classes\n[TIP]\n====\nThe term \"`component class`\" can refer to any of the following:\n\n* A class annotated with `@Configuration`.\n* A component (that is, a class annotated with `@Component`, `@Service`, `@Repository`, or other stereotype annotations).\n* A JSR-330 compliant class that is annotated with `jakarta.inject` annotations.\n* Any class that contains `@Bean`-methods.\n* Any other class that is intended to be registered as a Spring component (i.e., a Spring\n bean in the `ApplicationContext`), potentially taking advantage of automatic autowiring\n of a single constructor without the use of Spring annotations.\n\nSee the javadoc of\n{spring-framework-api}/context/annotation/Configuration.html[`@Configuration`] and\n{spring-framework-api}/context/annotation/Bean.html[`@Bean`] for further information\nregarding the configuration and semantics of component classes, paying special attention\nto the discussion of `@Bean` Lite Mode.\n====\n\nIf you omit the `classes` attribute from the `@ContextConfiguration` annotation, the\nTestContext framework tries to detect the presence of default configuration classes.\nSpecifically, `AnnotationConfigContextLoader` and `AnnotationConfigWebContextLoader`\ndetect all `static` nested classes of the test class that meet the requirements for\nconfiguration class implementations, as specified in the\n{spring-framework-api}/context/annotation/Configuration.html[`@Configuration`] javadoc.\nNote that the name of the configuration class is arbitrary. In addition, a test class can\ncontain more than one `static` nested configuration class if desired. In the following\nexample, the `OrderServiceTest` class declares a `static` nested configuration class\nnamed `Config` that is automatically used to load the `ApplicationContext` for the test\nclass:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig <1>\n\t// ApplicationContext will be loaded from the static nested Config class\n\tclass OrderServiceTest {\n\n @Configuration\n static class Config {\n\n // this bean will be injected into the OrderServiceTest class\n @Bean\n OrderService orderService() {\n OrderService orderService = new OrderServiceImpl();\n // set properties, etc.\n return orderService;\n }\n }\n\n @Autowired\n OrderService orderService;\n\n @Test\n void testOrderService() {\n // test the orderService\n }\n\n\t}\n----\n<1> Loading configuration information from the nested `Config` class.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig <1>\n\t// ApplicationContext will be loaded from the nested Config class\n\tclass OrderServiceTest {\n\n @Autowired\n lateinit var orderService: OrderService\n\n @Configuration\n class Config {\n\n // this bean will be injected into the OrderServiceTest class\n @Bean\n fun orderService(): OrderService {\n // set properties, etc.\n return OrderServiceImpl()\n }\n }\n\n @Test\n fun testOrderService() {\n // test the orderService\n }\n\t}\n----\n<1> Loading configuration information from the nested `Config` class.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/javaconfig.adoc", "title": "javaconfig", "heading": "javaconfig", "heading_level": 1, "file_order": 251, "section_index": 0, "content_hash": "e79d0fbb164b1eef9593b51838d092676e6d42b6f2533c0e04bfee9c8a5fa2d7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/javaconfig.adoc"}}
{"id": "sha256:181fe2b333c845acbf416d35613570f340ff4dbc364b68fb598ad2343f4a6011", "content": "[[testcontext-ctx-management-mixed-config]]\n\nIt may sometimes be desirable to mix XML configuration files, Groovy scripts, and\ncomponent classes (typically `@Configuration` classes) to configure an\n`ApplicationContext` for your tests. For example, if you use XML configuration in\nproduction, you may decide that you want to use `@Configuration` classes to configure\nspecific Spring-managed components for your tests, or vice versa.\n\nFurthermore, some third-party frameworks (such as Spring Boot) provide first-class\nsupport for loading an `ApplicationContext` from different types of resources\nsimultaneously (for example, XML configuration files, Groovy scripts, and\n`@Configuration` classes). The Spring Framework, historically, has not supported this for\nstandard deployments. Consequently, most of the `SmartContextLoader` implementations that\nthe Spring Framework delivers in the `spring-test` module support only one resource type\nfor each test context. However, this does not mean that you cannot use both. One\nexception to the general rule is that the `GenericGroovyXmlContextLoader` and\n`GenericGroovyXmlWebContextLoader` support both XML configuration files and Groovy\nscripts simultaneously. Furthermore, third-party frameworks may choose to support the\ndeclaration of both `locations` and `classes` through `@ContextConfiguration`, and, with\nthe standard testing support in the TestContext framework, you have the following options.\n\nIf you want to use resource locations (for example, XML or Groovy) and `@Configuration`\nclasses to configure your tests, you must pick one as the entry point, and that one must\ninclude or import the other. For example, in XML or Groovy scripts, you can include\n`@Configuration` classes by using component scanning or defining them as normal Spring\nbeans, whereas, in a `@Configuration` class, you can use `@ImportResource` to import XML\nconfiguration files or Groovy scripts. Note that this behavior is semantically equivalent\nto how you configure your application in production: In production configuration, you\ndefine either a set of XML or Groovy resource locations or a set of `@Configuration`\nclasses from which your production `ApplicationContext` is loaded, but you still have the\nfreedom to include or import the other type of configuration.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/mixed-config.adoc", "title": "mixed-config", "heading": "mixed-config", "heading_level": 1, "file_order": 252, "section_index": 0, "content_hash": "181fe2b333c845acbf416d35613570f340ff4dbc364b68fb598ad2343f4a6011", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/mixed-config.adoc"}}
{"id": "sha256:abd2b055659b9a37f64637461d31ec27b9e7911cb325bef8bd052c204dc9a055", "content": "[[testcontext-ctx-management-property-sources]]\n\nThe Spring Framework has first-class support for the notion of an environment with a\nhierarchy of property sources, and you can configure integration tests with test-specific\nproperty sources. In contrast to the `@PropertySource` annotation used on\n`@Configuration` classes, you can declare the `@TestPropertySource` annotation on a test\nclass to declare resource locations for test properties files or inlined properties.\nThese test property sources are added to the set of `PropertySources` in the\n`Environment` for the `ApplicationContext` loaded for the annotated integration test.\n\n[NOTE]\n====\nYou can use `@TestPropertySource` with any implementation of the `SmartContextLoader`\nSPI, but `@TestPropertySource` is not supported with implementations of the older\n`ContextLoader` SPI.\n\nImplementations of `SmartContextLoader` gain access to merged test property source values\nthrough the `getPropertySourceDescriptors()` and `getPropertySourceProperties()` methods in\n`MergedContextConfiguration`.\n====\n\n[[declaring-test-property-sources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/property-sources.adoc", "title": "property-sources", "heading": "property-sources", "heading_level": 1, "file_order": 253, "section_index": 0, "content_hash": "abd2b055659b9a37f64637461d31ec27b9e7911cb325bef8bd052c204dc9a055", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/property-sources.adoc"}}
{"id": "sha256:3512eb2301eb745a008cec99e9ef5aacd5e76af9fcc090a8aec28761a0b31d7f", "content": "You can configure test properties files by using the `locations` or `value` attribute of\n`@TestPropertySource`.\n\nBy default, both traditional and XML-based `java.util.Properties` file formats are\nsupported -- for example, `\"classpath:/com/example/test.properties\"` or\n`\"file:///path/to/file.xml\"`. As of Spring Framework 6.1, you can configure a custom\n`PropertySourceFactory` via the `factory` attribute in `@TestPropertySource` in order to\nsupport a different file format such as JSON, YAML, etc.\n\nEach path is interpreted as a Spring `Resource`. A plain path (for example,\n`\"test.properties\"`) is treated as a classpath resource that is relative to the package\nin which the test class is defined. A path starting with a slash is treated as an\nabsolute classpath resource (for example: `\"/org/example/test.xml\"`). A path that\nreferences a URL (for example, a path prefixed with `classpath:`, `file:`, or `http:`) is\nloaded by using the specified resource protocol.\n\nProperty placeholders in paths (such as `${...}`) will be resolved against the `Environment`.\n\nAs of Spring Framework 6.1, resource location patterns are also supported â€” for\nexample, `\"classpath*:/config/*.properties\"`.\n\nThe following example uses a test properties file:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestPropertySource(\"/test.properties\") // <1>\n\tclass MyIntegrationTests {\n // class body...\n\t}\n----\n<1> Specifying a properties file with an absolute path.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestPropertySource(\"/test.properties\") // <1>\n\tclass MyIntegrationTests {\n // class body...\n\t}\n----\n<1> Specifying a properties file with an absolute path.\n======\n\nYou can configure inlined properties in the form of key-value pairs by using the\n`properties` attribute of `@TestPropertySource`, as shown in the next example. All\nkey-value pairs are added to the enclosing `Environment` as a single test\n`PropertySource` with the highest precedence.\n\nThe supported syntax for key-value pairs is the same as the syntax defined for entries in\na Java properties file:\n\n* `key=value`\n* `key:value`\n* `key value`\n\n[TIP]\n====\nAlthough properties can be defined using any of the above syntax variants and any number\nof spaces between the key and the value, it is recommended that you use one syntax\nvariant and consistent spacing within your test suite â€” for example, consider always\nusing `key = value` instead of `key= value`, `key=value`, etc. Similarly, if you define\ninlined properties using text blocks you should consistently use text blocks for inlined\nproperties throughout your test suite.\n\nThe reason is that the exact strings you provide will be used to determine the key for\nthe context cache. Consequently, to benefit from the context cache you must ensure that\nyou define inlined properties consistently.\n====\n\nThe following example sets two inlined properties:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestPropertySource(properties = {\"timezone = GMT\", \"port = 4242\"}) // <1>\n\tclass MyIntegrationTests {\n // class body...\n\t}\n----\n<1> Setting two properties via an array of strings.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestPropertySource(properties = [\"timezone = GMT\", \"port = 4242\"]) // <1>\n\tclass MyIntegrationTests {\n // class body...\n\t}\n----\n<1> Setting two properties via an array of strings.\n======\n\nAs of Spring Framework 6.1, you can use _text blocks_ to define multiple inlined\nproperties in a single `String`. The following example sets two inlined properties using\na text block:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestPropertySource(properties = \"\"\"\n timezone = GMT\n port = 4242\n \"\"\") // <1>\n\tclass MyIntegrationTests {\n // class body...\n\t}\n----\n<1> Setting two properties via a text block.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestPropertySource(properties = [\"\"\"\n timezone = GMT\n port = 4242\n \"\"\"]) // <1>\n\tclass MyIntegrationTests {\n // class body...\n\t}\n----\n<1> Setting two properties via a text block.\n======\n\n[NOTE]\n====\n`@TestPropertySource` can be used as _repeatable annotation_.\n\nThat means that you can have multiple declarations of `@TestPropertySource` on a single\ntest class, with the `locations` and `properties` from later `@TestPropertySource`\nannotations overriding those from previous `@TestPropertySource` annotations.\n\nIn addition, you may declare multiple composed annotations on a test class that are each\nmeta-annotated with `@TestPropertySource`, and all of those `@TestPropertySource`\ndeclarations will contribute to your test property sources.\n\nDirectly present `@TestPropertySource` annotations always take precedence over\nmeta-present `@TestPropertySource` annotations. In other words, `locations` and\n`properties` from a directly present `@TestPropertySource` annotation will override the\n`locations` and `properties` from a `@TestPropertySource` annotation used as a\nmeta-annotation.\n====\n\n[[default-properties-file-detection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/property-sources.adoc", "title": "property-sources", "heading": "Declaring Test Property Sources", "heading_level": 2, "file_order": 253, "section_index": 1, "content_hash": "3512eb2301eb745a008cec99e9ef5aacd5e76af9fcc090a8aec28761a0b31d7f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/property-sources.adoc"}}
{"id": "sha256:d806eba817f69b39507b61985e21e07ffc494f081a142be409f0b67c12705f3b", "content": "If `@TestPropertySource` is declared as an empty annotation (that is, without explicit\nvalues for the `locations` or `properties` attributes), an attempt is made to detect a\ndefault properties file relative to the class that declared the annotation. For example,\nif the annotated test class is `com.example.MyTest`, the corresponding default properties\nfile is `classpath:com/example/MyTest.properties`. If the default cannot be detected, an\n`IllegalStateException` is thrown.\n\n[[testcontext-ctx-management-property-sources-precedence]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/property-sources.adoc", "title": "property-sources", "heading": "Default Properties File Detection", "heading_level": 2, "file_order": 253, "section_index": 2, "content_hash": "d806eba817f69b39507b61985e21e07ffc494f081a142be409f0b67c12705f3b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/property-sources.adoc"}}
{"id": "sha256:9466f6b1db0408232c07ff8954e6520fb26cbefe0b5c6ab0a2eb28e501985125", "content": "Test properties have higher precedence than those defined in the operating system's\nenvironment, Java system properties, or property sources added by the application\ndeclaratively by using `@PropertySource` or programmatically. Thus, test properties can\nbe used to selectively override properties loaded from system and application property\nsources. Furthermore, inlined properties have higher precedence than properties loaded\nfrom resource locations. Note, however, that properties registered via\nxref:testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc[`@DynamicPropertySource`] have\nhigher precedence than those loaded via `@TestPropertySource`.\n\nIn the next example, the `timezone` and `port` properties and any properties defined in\n`\"/test.properties\"` override any properties of the same name that are defined in system\nand application property sources. Furthermore, if the `\"/test.properties\"` file defines\nentries for the `timezone` and `port` properties those are overridden by the inlined\nproperties declared by using the `properties` attribute. The following example shows how\nto specify properties both in a file and inline:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestPropertySource(\n locations = \"/test.properties\",\n properties = {\"timezone = GMT\", \"port = 4242\"}\n\t)\n\tclass MyIntegrationTests {\n // class body...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestPropertySource(\"/test.properties\",\n properties = [\"timezone = GMT\", \"port = 4242\"]\n\t)\n\tclass MyIntegrationTests {\n // class body...\n\t}\n----\n======\n\n[[inheriting-and-overriding-test-property-sources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/property-sources.adoc", "title": "property-sources", "heading": "Precedence", "heading_level": 2, "file_order": 253, "section_index": 3, "content_hash": "9466f6b1db0408232c07ff8954e6520fb26cbefe0b5c6ab0a2eb28e501985125", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/property-sources.adoc"}}
{"id": "sha256:50d25fb16dc17d77f78daa6bf9c396a0e5ca3765631e916ad32bb46d209d47a0", "content": "`@TestPropertySource` supports boolean `inheritLocations` and `inheritProperties`\nattributes that denote whether resource locations for properties files and inlined\nproperties declared by superclasses should be inherited. The default value for both flags\nis `true`. This means that a test class inherits the locations and inlined properties\ndeclared by any superclasses. Specifically, the locations and inlined properties for a\ntest class are appended to the locations and inlined properties declared by superclasses.\nThus, subclasses have the option of extending the locations and inlined properties. Note\nthat properties that appear later shadow (that is, override) properties of the same name\nthat appear earlier. In addition, the aforementioned precedence rules apply for inherited\ntest property sources as well.\n\nIf the `inheritLocations` or `inheritProperties` attribute in `@TestPropertySource` is\nset to `false`, the locations or inlined properties, respectively, for the test class\nshadow and effectively replace the configuration defined by superclasses.\n\nNOTE: Test configuration may also be inherited from enclosing classes. See\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-nested-test-configuration[`@Nested` test class configuration] for details.\n\nIn the next example, the `ApplicationContext` for `BaseTest` is loaded by using only the\n`base.properties` file as a test property source. In contrast, the `ApplicationContext`\nfor `ExtendedTest` is loaded by using the `base.properties` and `extended.properties`\nfiles as test property source locations. The following example shows how to define\nproperties in both a subclass and its superclass by using `properties` files:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@TestPropertySource(\"base.properties\")\n\t@ContextConfiguration\n\tclass BaseTest {\n // ...\n\t}\n\n\t@TestPropertySource(\"extended.properties\")\n\t@ContextConfiguration\n\tclass ExtendedTest extends BaseTest {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@TestPropertySource(\"base.properties\")\n\t@ContextConfiguration\n\topen class BaseTest {\n // ...\n\t}\n\n\t@TestPropertySource(\"extended.properties\")\n\t@ContextConfiguration\n\tclass ExtendedTest : BaseTest() {\n // ...\n\t}\n----\n======\n\nIn the next example, the `ApplicationContext` for `BaseTest` is loaded by using only the\ninlined `key1` property. In contrast, the `ApplicationContext` for `ExtendedTest` is\nloaded by using the inlined `key1` and `key2` properties. The following example shows how\nto define properties in both a subclass and its superclass by using inline properties:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@TestPropertySource(properties = \"key1 = value1\")\n\t@ContextConfiguration\n\tclass BaseTest {\n // ...\n\t}\n\n\t@TestPropertySource(properties = \"key2 = value2\")\n\t@ContextConfiguration\n\tclass ExtendedTest extends BaseTest {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@TestPropertySource(properties = [\"key1 = value1\"])\n\t@ContextConfiguration\n\topen class BaseTest {\n // ...\n\t}\n\n\t@TestPropertySource(properties = [\"key2 = value2\"])\n\t@ContextConfiguration\n\tclass ExtendedTest : BaseTest() {\n // ...\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/property-sources.adoc", "title": "property-sources", "heading": "Inheriting and Overriding Test Property Sources", "heading_level": 2, "file_order": 253, "section_index": 4, "content_hash": "50d25fb16dc17d77f78daa6bf9c396a0e5ca3765631e916ad32bb46d209d47a0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/property-sources.adoc"}}
{"id": "sha256:531f126e6277b6f9dcc9b8236c514089618bf2cdf134add9728114c98b995e49", "content": "[[testcontext-ctx-management-web-mocks]]\n\nTo provide comprehensive web testing support, the TestContext framework has a\n`ServletTestExecutionListener` that is enabled by default. When testing against a\n`WebApplicationContext`, this xref:testing/testcontext-framework/key-abstractions.adoc[`TestExecutionListener`]\nsets up default thread-local state by using Spring Web's `RequestContextHolder` before\neach test method and creates a `MockHttpServletRequest`, a `MockHttpServletResponse`, and\na `ServletWebRequest` based on the base resource path configured with\n`@WebAppConfiguration`. `ServletTestExecutionListener` also ensures that the\n`MockHttpServletResponse` and `ServletWebRequest` can be injected into the test instance,\nand, once the test is complete, it cleans up thread-local state.\n\nOnce you have a `WebApplicationContext` loaded for your test, you might find that you\nneed to interact with the web mocks -- for example, to set up your test fixture or to\nperform assertions after invoking your web component. The following example shows which\nmocks can be autowired into your test instance. Note that the `WebApplicationContext` and\n`MockServletContext` are both cached across the test suite, whereas the other mocks are\nmanaged per test method by the `ServletTestExecutionListener`.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig\n\tclass WacTests {\n\n @Autowired\n WebApplicationContext wac; // cached\n\n @Autowired\n MockServletContext servletContext; // cached\n\n @Autowired\n MockHttpSession session;\n\n @Autowired\n MockHttpServletRequest request;\n\n @Autowired\n MockHttpServletResponse response;\n\n @Autowired\n ServletWebRequest webRequest;\n\n //...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig\n\tclass WacTests {\n\n @Autowired\n lateinit var wac: WebApplicationContext // cached\n\n @Autowired\n lateinit var servletContext: MockServletContext // cached\n\n @Autowired\n lateinit var session: MockHttpSession\n\n @Autowired\n lateinit var request: MockHttpServletRequest\n\n @Autowired\n lateinit var response: MockHttpServletResponse\n\n @Autowired\n lateinit var webRequest: ServletWebRequest\n\n //...\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/web-mocks.adoc", "title": "web-mocks", "heading": "web-mocks", "heading_level": 1, "file_order": 254, "section_index": 0, "content_hash": "531f126e6277b6f9dcc9b8236c514089618bf2cdf134add9728114c98b995e49", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/web-mocks.adoc"}}
{"id": "sha256:afdcd95a587c2765e415e14cf07fc5039bfd18e3beb30bf77ccb42e9c778ff70", "content": "[[testcontext-ctx-management-web]]\n\nTo instruct the TestContext framework to load a `WebApplicationContext` instead of a\nstandard `ApplicationContext`, you can annotate the respective test class with\n`@WebAppConfiguration`.\n\nThe presence of `@WebAppConfiguration` on your test class instructs the TestContext\nframework (TCF) that a `WebApplicationContext` (WAC) should be loaded for your\nintegration tests. In the background, the TCF makes sure that a `MockServletContext` is\ncreated and supplied to your test's WAC. By default, the base resource path for your\n`MockServletContext` is set to `src/main/webapp`. This is interpreted as a path relative\nto the root of your JVM (normally the path to your project). If you are familiar with the\ndirectory structure of a web application in a Maven project, you know that\n`src/main/webapp` is the default location for the root of your WAR. If you need to\noverride this default, you can provide an alternate path to the `@WebAppConfiguration`\nannotation (for example, `@WebAppConfiguration(\"src/test/webapp\")`). If you wish to\nreference a base resource path from the classpath instead of the file system, you can use\nSpring's `classpath:` prefix.\n\nNote that Spring's testing support for `WebApplicationContext` implementations is on par\nwith its support for standard `ApplicationContext` implementations. When testing with a\n`WebApplicationContext`, you are free to declare XML configuration files, Groovy scripts,\nor `@Configuration` classes by using `@ContextConfiguration`. You are also free to use\nany other test annotations, such as `@ActiveProfiles`, `@TestExecutionListeners`, `@Sql`,\n`@Rollback`, and others.\n\nThe remaining examples in this section show some of the various configuration options for\nloading a `WebApplicationContext`. The following example shows the TestContext\nframework's support for convention over configuration:\n\n.Conventions\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\n\t// defaults to \"file:src/main/webapp\"\n\t@WebAppConfiguration\n\n\t// detects \"WacTests-context.xml\" in the same package\n\t// or static nested @Configuration classes\n\t@ContextConfiguration\n\tclass WacTests {\n //...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\n\t// defaults to \"file:src/main/webapp\"\n\t@WebAppConfiguration\n\n\t// detects \"WacTests-context.xml\" in the same package\n\t// or static nested @Configuration classes\n\t@ContextConfiguration\n\tclass WacTests {\n //...\n\t}\n----\n======\n\nIf you annotate a test class with `@WebAppConfiguration` without specifying a resource\nbase path, the resource path effectively defaults to `file:src/main/webapp`. Similarly,\nif you declare `@ContextConfiguration` without specifying resource `locations`, component\n`classes`, or context `initializers`, Spring tries to detect the presence of your\nconfiguration by using conventions (that is, `WacTests-context.xml` in the same package\nas the `WacTests` class or static nested `@Configuration` classes).\n\nThe following example shows how to explicitly declare a resource base path with\n`@WebAppConfiguration` and an XML resource location with `@ContextConfiguration`:\n\n.Default resource semantics\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\n\t// file system resource\n\t@WebAppConfiguration(\"webapp\")\n\n\t// classpath resource\n\t@ContextConfiguration(\"/spring/test-servlet-config.xml\")\n\tclass WacTests {\n //...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\n\t// file system resource\n\t@WebAppConfiguration(\"webapp\")\n\n\t// classpath resource\n\t@ContextConfiguration(\"/spring/test-servlet-config.xml\")\n\tclass WacTests {\n //...\n\t}\n----\n======\n\nThe important thing to note here is the different semantics for paths with these two\nannotations. By default, `@WebAppConfiguration` resource paths are file system based,\nwhereas `@ContextConfiguration` resource locations are classpath based.\n\nThe following example shows that we can override the default resource semantics for both\nannotations by specifying a Spring resource prefix:\n\n.Explicit resource semantics\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\n\t// classpath resource\n\t@WebAppConfiguration(\"classpath:test-web-resources\")\n\n\t// file system resource\n\t@ContextConfiguration(\"file:src/main/webapp/WEB-INF/servlet-config.xml\")\n\tclass WacTests {\n //...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\n\t// classpath resource\n\t@WebAppConfiguration(\"classpath:test-web-resources\")\n\n\t// file system resource\n\t@ContextConfiguration(\"file:src/main/webapp/WEB-INF/servlet-config.xml\")\n\tclass WacTests {\n //...\n\t}\n----\n======\n\nContrast the comments in this example with the previous example.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/web.adoc", "title": "web", "heading": "web", "heading_level": 1, "file_order": 255, "section_index": 0, "content_hash": "afdcd95a587c2765e415e14cf07fc5039bfd18e3beb30bf77ccb42e9c778ff70", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/web.adoc"}}
{"id": "sha256:b6f0dbd117fcb9388e9d435d964eecbe5162e4e4a23a0e7014b6dc146d39c90e", "content": "[[testcontext-ctx-management-xml]]\n\nTo load an `ApplicationContext` for your tests by using XML configuration files, annotate\nyour test class with `@ContextConfiguration` and configure the `locations` attribute with\nan array that contains the resource locations of XML configuration metadata. A plain or\nrelative path (for example, `context.xml`) is treated as a classpath resource that is\nrelative to the package in which the test class is defined. A path starting with a slash\nis treated as an absolute classpath location (for example, `/org/example/config.xml`). A\npath that represents a resource URL (i.e., a path prefixed with `classpath:`, `file:`,\n`http:`, etc.) is used _as is_.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t// ApplicationContext will be loaded from \"/app-config.xml\" and\n\t// \"/test-config.xml\" in the root of the classpath\n\t@ContextConfiguration(locations = {\"/app-config.xml\", \"/test-config.xml\"}) // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Setting the locations attribute to a list of XML files.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t// ApplicationContext will be loaded from \"/app-config.xml\" and\n\t// \"/test-config.xml\" in the root of the classpath\n\t@ContextConfiguration(locations = [\"/app-config.xml\", \"/test-config.xml\"]) // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Setting the locations attribute to a list of XML files.\n======\n\n`@ContextConfiguration` supports an alias for the `locations` attribute through the\nstandard Java `value` attribute. Thus, if you do not need to declare additional\nattributes in `@ContextConfiguration`, you can omit the declaration of the `locations`\nattribute name and declare the resource locations by using the shorthand format\ndemonstrated in the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t@ContextConfiguration({\"/app-config.xml\", \"/test-config.xml\"}) <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Specifying XML files without using the `locations` attribute.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t@ContextConfiguration(\"/app-config.xml\", \"/test-config.xml\") // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Specifying XML files without using the `locations` attribute.\n======\n\nIf you omit both the `locations` and the `value` attributes from the\n`@ContextConfiguration` annotation, the TestContext framework tries to detect a default\nXML resource location. Specifically, `GenericXmlContextLoader` and\n`GenericXmlWebContextLoader` detect a default location based on the name of the test\nclass. If your class is named `com.example.MyTest`, `GenericXmlContextLoader` loads your\napplication context from `\"classpath:com/example/MyTest-context.xml\"`. The following\nexample shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t// ApplicationContext will be loaded from\n\t// \"classpath:com/example/MyTest-context.xml\"\n\t@ContextConfiguration // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Loading configuration from the default location.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t// ApplicationContext will be loaded from\n\t// \"classpath:com/example/MyTest-context.xml\"\n\t@ContextConfiguration // <1>\n\tclass MyTest {\n // class body...\n\t}\n----\n<1> Loading configuration from the default location.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/xml.adoc", "title": "xml", "heading": "xml", "heading_level": 1, "file_order": 256, "section_index": 0, "content_hash": "b6f0dbd117fcb9388e9d435d964eecbe5162e4e4a23a0e7014b6dc146d39c90e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management/xml.adoc"}}
{"id": "sha256:7bd1b37d36cd947799488d42b628eaad95b953997fef1f12842ac0f8346ec487", "content": "[[testcontext-aot]]\n\nThis chapter covers Spring's Ahead of Time (AOT) support for integration tests using the\nSpring TestContext Framework.\n\nThe testing support extends Spring's xref:core/aot.adoc[core AOT support] with the\nfollowing features.\n\n* Build-time detection of all integration tests in the current project that use the\n TestContext framework to load an `ApplicationContext`.\n - Provides explicit support for test classes based on JUnit Jupiter and JUnit 4 as well\n as implicit support for TestNG and other testing frameworks that use Spring's core\n testing annotations -- as long as the tests are run using a JUnit Platform\n `TestEngine` that is registered for the current project.\n* Build-time AOT processing: each unique test `ApplicationContext` in the current project\n will be xref:core/aot.adoc#aot.refresh[refreshed for AOT processing].\n* Runtime AOT support: when executing in AOT runtime mode, a Spring integration test will\n use an AOT-optimized `ApplicationContext` that participates transparently with the\n xref:testing/testcontext-framework/ctx-management/caching.adoc[context cache].\n\nAll tests are enabled in AOT mode by default. However, you can selectively disable an\nentire test class or individual test method in AOT mode by annotating it with\nxref:testing/annotations/integration-spring/annotation-disabledinaotmode.adoc[`@DisabledInAotMode`].\nWhen using JUnit Jupiter, you may selectively enable or disable tests in a GraalVM native\nimage via Jupiter's `@EnabledInNativeImage` and `@DisabledInNativeImage` annotations.\nNote that `@DisabledInAotMode` also disables the annotated test class or test method when\nrunning within a GraalVM native image, analogous to JUnit Jupiter's\n`@DisabledInNativeImage` annotation.\n\n[TIP]\n====\nBy default, if an error is encountered during build-time AOT processing, an exception\nwill be thrown, and the overall process will fail immediately.\n\nIf you would prefer that build-time AOT processing continue after errors are encountered,\nyou can disable the `failOnError` mode which results in errors being logged at `WARN`\nlevel or with greater detail at `DEBUG` level.\n\nThe `failOnError` mode can be disabled from the command line or a build script by setting\na JVM system property named `spring.test.aot.processing.failOnError` to `false`. As an\nalternative, you can set the same property via the\nxref:appendix.adoc#appendix-spring-properties[`SpringProperties`] mechanism.\n====\n\n[TIP]\n====\nJPA's `@PersistenceContext` and `@PersistenceUnit` annotations cannot be used to perform\ndependency injection within test classes in AOT mode.\n\nHowever, as of Spring Framework 7.0, you can inject an `EntityManager` or\n`EntityManagerFactory` into tests using `@Autowired` instead of `@PersistenceContext` and\n`@PersistenceUnit`, respectively.\n====\n\n[NOTE]\n====\nThe `@ContextHierarchy` annotation is not supported in AOT mode.\n====\n\nTo provide test-specific runtime hints for use within a GraalVM native image, you have\nthe following options.\n\n* Implement a custom\n {spring-framework-api}/test/context/aot/TestRuntimeHintsRegistrar.html[`TestRuntimeHintsRegistrar`]\n and register it globally via `META-INF/spring/aot.factories`.\n* Implement a custom {spring-framework-api}/aot/hint/RuntimeHintsRegistrar.html[`RuntimeHintsRegistrar`]\n and register it globally via `META-INF/spring/aot.factories` or locally on a test class\n via {spring-framework-api}/context/annotation/ImportRuntimeHints.html[`@ImportRuntimeHints`].\n* Annotate a test class with {spring-framework-api}/aot/hint/annotation/Reflective.html[`@Reflective`] or\n {spring-framework-api}/aot/hint/annotation/RegisterReflectionForBinding.html[`@RegisterReflectionForBinding`].\n* See xref:core/aot.adoc#aot.hints[Runtime Hints] for details on Spring's core runtime hints\n and annotation support.\n\n[TIP]\n====\nThe `TestRuntimeHintsRegistrar` API serves as a companion to the core\n`RuntimeHintsRegistrar` API. If you need to register global hints for testing support\nthat are not specific to particular test classes, favor implementing\n`RuntimeHintsRegistrar` over the test-specific API.\n====\n\nIf you implement a custom `ContextLoader`, it must implement\n{spring-framework-api}/test/context/aot/AotContextLoader.html[`AotContextLoader`] in\norder to provide AOT build-time processing and AOT runtime execution support. Note,\nhowever, that all context loader implementations provided by the Spring Framework and\nSpring Boot already implement `AotContextLoader`.\n\nIf you implement a custom `TestExecutionListener`, it must implement\n{spring-framework-api}/test/context/aot/AotTestExecutionListener.html[`AotTestExecutionListener`]\nin order to participate in AOT processing. See the `SqlScriptsTestExecutionListener` in\nthe `spring-test` module for an example.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/aot.adoc", "title": "aot", "heading": "aot", "heading_level": 1, "file_order": 257, "section_index": 0, "content_hash": "7bd1b37d36cd947799488d42b628eaad95b953997fef1f12842ac0f8346ec487", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/aot.adoc"}}
{"id": "sha256:8726f3be46047e38041d4ff5b21e65512fe88267a381dc7c4ff3478c18d1258c", "content": "[[testcontext-application-events]]\n\nThe TestContext framework provides support for recording\nxref:core/beans/context-introduction.adoc#context-functionality-events[application events]\npublished in the `ApplicationContext` so that assertions can be performed against those\nevents within tests. All events published during the execution of a single test are made\navailable via the `ApplicationEvents` API which allows you to process the events as a\n`java.util.Stream`.\n\nTo use `ApplicationEvents` in your tests, do the following.\n\n* Ensure that your test class is annotated or meta-annotated with\n xref:testing/annotations/integration-spring/annotation-recordapplicationevents.adoc[`@RecordApplicationEvents`].\n* Ensure that the `ApplicationEventsTestExecutionListener` is registered. Note, however,\n that `ApplicationEventsTestExecutionListener` is registered by default and only needs\n to be manually registered if you have custom configuration via\n `@TestExecutionListeners` that does not include the default listeners.\n* When using the\n xref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-extension[SpringExtension for JUnit Jupiter],\n declare a method parameter of type `ApplicationEvents` in a `@Test`, `@BeforeEach`, or\n `@AfterEach` method.\n** Since `ApplicationEvents` is scoped to the lifecycle of the current test method, this\n is the recommended approach.\n* Alternatively, you can annotate a field of type `ApplicationEvents` with `@Autowired`\n and use that instance of `ApplicationEvents` in your test and lifecycle methods.\n\nNOTE: `ApplicationEvents` is registered with the `ApplicationContext` as a _resolvable\ndependency_ which is scoped to the lifecycle of the current test method. Consequently,\n`ApplicationEvents` cannot be accessed outside the lifecycle of a test method and cannot be\n`@Autowired` into the constructor of a test class.\n\nThe following test class uses the `SpringExtension` for JUnit Jupiter and\n{assertj-docs}[AssertJ] to assert the types of application events published while\ninvoking a method in a Spring-managed component:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@SpringJUnitConfig(/* ... */)\n\t@RecordApplicationEvents // <1>\n\tclass OrderServiceTests {\n\n @Test\n void submitOrder(@Autowired OrderService service, ApplicationEvents events) { // <2>\n // Invoke method in OrderService that publishes an event\n service.submitOrder(new Order(/* ... */));\n // Verify that an OrderSubmitted event was published\n long numEvents = events.stream(OrderSubmitted.class).count(); // <3>\n assertThat(numEvents).isEqualTo(1);\n }\n\t}\n----\n<1> Annotate the test class with `@RecordApplicationEvents`.\n<2> Inject the `ApplicationEvents` instance for the current test.\n<3> Use the `ApplicationEvents` API to count how many `OrderSubmitted` events were published.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@SpringJUnitConfig(/* ... */)\n\t@RecordApplicationEvents // <1>\n\tclass OrderServiceTests {\n\n @Test\n fun submitOrder(@Autowired service: OrderService, events: ApplicationEvents) { // <2>\n // Invoke method in OrderService that publishes an event\n service.submitOrder(Order(/* ... */))\n // Verify that an OrderSubmitted event was published\n val numEvents = events.stream(OrderSubmitted::class).count() // <3>\n assertThat(numEvents).isEqualTo(1)\n }\n\t}\n----\n<1> Annotate the test class with `@RecordApplicationEvents`.\n<2> Inject the `ApplicationEvents` instance for the current test.\n<3> Use the `ApplicationEvents` API to count how many `OrderSubmitted` events were published.\n======\n\nSee the\n{spring-framework-api}/test/context/event/ApplicationEvents.html[`ApplicationEvents`\njavadoc] for further details regarding the `ApplicationEvents` API.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/application-events.adoc", "title": "application-events", "heading": "application-events", "heading_level": 1, "file_order": 258, "section_index": 0, "content_hash": "8726f3be46047e38041d4ff5b21e65512fe88267a381dc7c4ff3478c18d1258c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/application-events.adoc"}}
{"id": "sha256:a16e9097f998fb5a833b2d3427270e2c7c2ffce45568f7fe6da9f49e64d29cf0", "content": "[[testcontext-bean-overriding]]\n\nBean overriding in tests refers to the ability to override specific beans in the\n`ApplicationContext` for a test class, by annotating the test class or one or more\nnon-static fields in the test class.\n\nNOTE: This feature is intended as a less risky alternative to the practice of registering\na bean via `@Bean` with the `DefaultListableBeanFactory`\n`setAllowBeanDefinitionOverriding` flag set to `true`.\n\nThe Spring TestContext framework provides two sets of annotations for bean overriding.\n\n* xref:testing/annotations/integration-spring/annotation-testbean.adoc[`@TestBean`]\n* xref:testing/annotations/integration-spring/annotation-mockitobean.adoc[`@MockitoBean` and `@MockitoSpyBean`]\n\nThe former relies purely on Spring, while the latter set relies on the\nhttps://site.mockito.org/[Mockito] third-party library.\n\n[[testcontext-bean-overriding-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/bean-overriding.adoc", "title": "bean-overriding", "heading": "bean-overriding", "heading_level": 1, "file_order": 259, "section_index": 0, "content_hash": "a16e9097f998fb5a833b2d3427270e2c7c2ffce45568f7fe6da9f49e64d29cf0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/bean-overriding.adoc"}}
{"id": "sha256:11c99268ccee9f41dacc245c2fad99032c0f7611bdf070e17f74d975c72165fe", "content": "The three annotations mentioned above build upon the `@BeanOverride` meta-annotation and\nassociated infrastructure, which allows one to define custom bean overriding variants.\n\nTo implement custom bean override support, the following is needed:\n\n* An annotation meta-annotated with `@BeanOverride` that defines the\n `BeanOverrideProcessor` to use\n* A custom `BeanOverrideProcessor` implementation\n* One or more concrete `BeanOverrideHandler` implementations created by the processor\n\nThe Spring TestContext framework includes implementations of the following APIs that\nsupport bean overriding and are responsible for setting up the rest of the infrastructure.\n\n* a `BeanFactoryPostProcessor`\n* a `ContextCustomizerFactory`\n* a `TestExecutionListener`\n\nThe `spring-test` module registers implementations of the latter two\n(`BeanOverrideContextCustomizerFactory` and `BeanOverrideTestExecutionListener`) in its\n{spring-framework-code}/spring-test/src/main/resources/META-INF/spring.factories[`META-INF/spring.factories`\nproperties file].\n\nThe bean overriding infrastructure searches for annotations on test classes as well as\nannotations on non-static fields in test classes that are meta-annotated with\n`@BeanOverride` and instantiates the corresponding `BeanOverrideProcessor` which is\nresponsible for creating an appropriate `BeanOverrideHandler`.\n\nThe internal `BeanOverrideBeanFactoryPostProcessor` then uses bean override handlers to\nalter the test's `ApplicationContext` by creating, replacing, or wrapping beans as\ndefined by the corresponding `BeanOverrideStrategy`:\n\n[[testcontext-bean-overriding-strategy]]\n`REPLACE`::\n Replaces the bean. Throws an exception if a corresponding bean does not exist.\n`REPLACE_OR_CREATE`::\n Replaces the bean if it exists. Creates a new bean if a corresponding bean does not\n exist.\n`WRAP`::\n Retrieves the original bean and wraps it.\n\n[TIP]\n====\nWhen replacing a non-singleton bean, the non-singleton bean will be replaced with a\nsingleton bean corresponding to bean override instance created by the applicable\n`BeanOverrideHandler`, and the corresponding bean definition will be converted to a\n`singleton`. Consequently, if a handler overrides a `prototype` or scoped bean, the\noverridden bean will be treated as a `singleton`.\n\nWhen replacing a bean created by a `FactoryBean`, the `FactoryBean` itself will be\nreplaced with a singleton bean corresponding to bean override instance created by the\napplicable `BeanOverrideHandler`.\n\nWhen wrapping a bean created by a `FactoryBean`, the object created by the `FactoryBean`\nwill be wrapped, not the `FactoryBean` itself.\n====\n\n[NOTE]\n====\nIn contrast to Spring's autowiring mechanism (for example, resolution of an `@Autowired`\nfield), the bean overriding infrastructure in the TestContext framework has limited\nheuristics it can perform to locate a bean. Either the `BeanOverrideProcessor` can compute\nthe name of the bean to override, or it can be unambiguously selected given the type of\nthe annotated field and its qualifying annotations.\n\nTypically, the bean is selected \"by type\" by the `BeanOverrideFactoryPostProcessor`.\nAlternatively, the user can directly provide the bean name in the custom annotation.\n\n`BeanOverrideProcessor` implementations may also internally compute a bean name based on\na convention or some other method.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/bean-overriding.adoc", "title": "bean-overriding", "heading": "Custom Bean Override Support", "heading_level": 2, "file_order": 259, "section_index": 1, "content_hash": "11c99268ccee9f41dacc245c2fad99032c0f7611bdf070e17f74d975c72165fe", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/bean-overriding.adoc"}}
{"id": "sha256:b4b8326701ec67ddb71ff2db76ad0cef268140118f942b6779f447796cebde8f", "content": "[[testcontext-bootstrapping]]\n\nThe default configuration for the internals of the Spring TestContext Framework is\nsufficient for all common use cases. However, there are times when a development team or\nthird party framework would like to change the default `ContextLoader`, implement a\ncustom `TestContext` or `ContextCache`, augment the default sets of\n`ContextCustomizerFactory` and `TestExecutionListener` implementations, and so on. For\nsuch low-level control over how the TestContext framework operates, Spring provides a\nbootstrapping strategy.\n\n`TestContextBootstrapper` defines the SPI for bootstrapping the TestContext framework. A\n`TestContextBootstrapper` is used by the `TestContextManager` to load the\n`TestExecutionListener` implementations for the current test and to build the\n`TestContext` that it manages. You can configure a custom bootstrapping strategy for a\ntest class (or test class hierarchy) by using `@BootstrapWith`, either directly or as a\nmeta-annotation. If a bootstrapper is not explicitly configured by using\n`@BootstrapWith`, either the `DefaultTestContextBootstrapper` or the\n`WebTestContextBootstrapper` is used, depending on the presence of `@WebAppConfiguration`.\n\nSince the `TestContextBootstrapper` SPI is likely to change in the future (to accommodate\nnew requirements), we strongly encourage implementers not to implement this interface\ndirectly but rather to extend `AbstractTestContextBootstrapper` or one of its concrete\nsubclasses instead.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/bootstrapping.adoc", "title": "bootstrapping", "heading": "bootstrapping", "heading_level": 1, "file_order": 260, "section_index": 0, "content_hash": "b4b8326701ec67ddb71ff2db76ad0cef268140118f942b6779f447796cebde8f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/bootstrapping.adoc"}}
{"id": "sha256:c24fba53db608ea7659edba98d0c18a558a47fa377772d1dcce8ac3fd0636a80", "content": "[[testcontext-ctx-management]]\n\nEach `TestContext` provides context management and caching support for the test instance\nfor which it is responsible. Test instances do not automatically receive access to the\nconfigured `ApplicationContext`. However, if a test class implements the\n`ApplicationContextAware` interface, a reference to the `ApplicationContext` is supplied\nto the test instance. Note that `AbstractJUnit4SpringContextTests` and\n`AbstractTestNGSpringContextTests` implement `ApplicationContextAware` and, therefore,\nprovide access to the `ApplicationContext` automatically.\n\n.@Autowired ApplicationContext\n[TIP]\n=====\nAs an alternative to implementing the `ApplicationContextAware` interface, you can inject\nthe application context for your test class through the `@Autowired` annotation on either\na field or setter method, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig\n\tclass MyTest {\n\n @Autowired // <1>\n ApplicationContext applicationContext;\n\n // class body...\n\t}\n----\n<1> Injecting the `ApplicationContext`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig\n\tclass MyTest {\n\n @Autowired // <1>\n lateinit var applicationContext: ApplicationContext\n\n // class body...\n\t}\n----\n<1> Injecting the `ApplicationContext`.\n======\n\nSimilarly, if your test is configured to load a `WebApplicationContext`, you can inject\nthe web application context into your test, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig // <1>\n\tclass MyWebAppTest {\n\n @Autowired // <2>\n WebApplicationContext wac;\n\n // class body...\n\t}\n----\n<1> Configuring the `WebApplicationContext`.\n<2> Injecting the `WebApplicationContext`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig // <1>\n\tclass MyWebAppTest {\n\n @Autowired // <2>\n lateinit var wac: WebApplicationContext\n // class body...\n\t}\n----\n<1> Configuring the `WebApplicationContext`.\n<2> Injecting the `WebApplicationContext`.\n======\n\nDependency injection by using `@Autowired` is provided by the\n`DependencyInjectionTestExecutionListener`, which is configured by default\n(see xref:testing/testcontext-framework/fixture-di.adoc[Dependency Injection of Test Fixtures]).\n=====\n\nTest classes that use the TestContext framework do not need to extend any particular\nclass or implement a specific interface to configure their application context. Instead,\nconfiguration is achieved by declaring the `@ContextConfiguration` annotation at the\nclass level. If your test class does not explicitly declare application context resource\nlocations or component classes, the configured `ContextLoader` determines how to load a\ncontext from a default location or default configuration classes. In addition to context\nresource locations and component classes, an application context can also be configured\nthrough application context initializers.\n\nThe following sections explain how to use Spring's `@ContextConfiguration` annotation to\nconfigure a test `ApplicationContext` by using XML configuration files, Groovy scripts,\ncomponent classes (typically `@Configuration` classes), or context initializers.\nAlternatively, you can implement and configure your own custom `SmartContextLoader` for\nadvanced use cases.\n\n* xref:testing/testcontext-framework/ctx-management/xml.adoc[Context Configuration with XML resources]\n* xref:testing/testcontext-framework/ctx-management/groovy.adoc[Context Configuration with Groovy Scripts]\n* xref:testing/testcontext-framework/ctx-management/javaconfig.adoc[Context Configuration with Component Classes]\n* xref:testing/testcontext-framework/ctx-management/mixed-config.adoc[Mixing XML, Groovy Scripts, and Component Classes]\n* xref:testing/testcontext-framework/ctx-management/context-customizers.adoc[Context Configuration with Context Customizers]\n* xref:testing/testcontext-framework/ctx-management/initializers.adoc[Context Configuration with Context Initializers]\n* xref:testing/testcontext-framework/ctx-management/inheritance.adoc[Context Configuration Inheritance]\n* xref:testing/testcontext-framework/ctx-management/env-profiles.adoc[Context Configuration with Environment Profiles]\n* xref:testing/testcontext-framework/ctx-management/property-sources.adoc[Context Configuration with Test Property Sources]\n* xref:testing/testcontext-framework/ctx-management/dynamic-property-sources.adoc[Context Configuration with Dynamic Property Sources]\n* xref:testing/testcontext-framework/ctx-management/web.adoc[Loading a `WebApplicationContext`]\n* xref:testing/testcontext-framework/ctx-management/caching.adoc[Context Caching]\n* xref:testing/testcontext-framework/ctx-management/failure-threshold.adoc[Context Failure Threshold]\n* xref:testing/testcontext-framework/ctx-management/hierarchies.adoc[Context Hierarchies]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management.adoc", "title": "ctx-management", "heading": "ctx-management", "heading_level": 1, "file_order": 261, "section_index": 0, "content_hash": "c24fba53db608ea7659edba98d0c18a558a47fa377772d1dcce8ac3fd0636a80", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/ctx-management.adoc"}}
{"id": "sha256:8f1c4e9e5cebfa8e79cad4185c38798f42b8637e1751870d64a2cec3364c2da6", "content": "[[testcontext-executing-sql]]\n\nWhen writing integration tests against a relational database, it is often beneficial to\nrun SQL scripts to modify the database schema or insert test data into tables. The\n`spring-jdbc` module provides support for _initializing_ an embedded or existing database\nby executing SQL scripts when the Spring `ApplicationContext` is loaded. See\nxref:data-access/jdbc/embedded-database-support.adoc[Embedded database support] and\nxref:data-access/jdbc/embedded-database-support.adoc#jdbc-embedded-database-dao-testing[Testing data access logic with an embedded database]\n for details.\n\nAlthough it is very useful to initialize a database for testing _once_ when the\n`ApplicationContext` is loaded, sometimes it is essential to be able to modify the\ndatabase _during_ integration tests. The following sections explain how to run SQL\nscripts programmatically and declaratively during integration tests.\n\n[[testcontext-executing-sql-programmatically]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc", "title": "executing-sql", "heading": "executing-sql", "heading_level": 1, "file_order": 262, "section_index": 0, "content_hash": "8f1c4e9e5cebfa8e79cad4185c38798f42b8637e1751870d64a2cec3364c2da6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc"}}
{"id": "sha256:1456cac7b255609c2ed95e4f168849a52e4efaddf8ca8ef136bf19dfde50bbbc", "content": "Spring provides the following options for executing SQL scripts programmatically within\nintegration test methods.\n\n* `org.springframework.jdbc.datasource.init.ScriptUtils`\n* `org.springframework.jdbc.datasource.init.ResourceDatabasePopulator`\n* `org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests`\n* `org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests`\n\n`ScriptUtils` provides a collection of static utility methods for working with SQL\nscripts and is mainly intended for internal use within the framework. However, if you\nrequire full control over how SQL scripts are parsed and run, `ScriptUtils` may suit\nyour needs better than some of the other alternatives described later. See the\n{spring-framework-api}/jdbc/datasource/init/ScriptUtils.html[javadoc] for individual\nmethods in `ScriptUtils` for further details.\n\n`ResourceDatabasePopulator` provides an object-based API for programmatically populating,\ninitializing, or cleaning up a database by using SQL scripts defined in external\nresources. `ResourceDatabasePopulator` provides options for configuring the character\nencoding, statement separator, comment delimiters, and error handling flags used when\nparsing and running the scripts. Each of the configuration options has a reasonable\ndefault value. See the\n{spring-framework-api}/jdbc/datasource/init/ResourceDatabasePopulator.html[javadoc] for\ndetails on default values. To run the scripts configured in a\n`ResourceDatabasePopulator`, you can invoke either the `populate(Connection)` method to\nrun the populator against a `java.sql.Connection` or the `execute(DataSource)` method\nto run the populator against a `javax.sql.DataSource`. The following example\nspecifies SQL scripts for a test schema and test data, sets the statement separator to\n`@@`, and run the scripts against a `DataSource`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\tvoid databaseTest() {\n ResourceDatabasePopulator populator = new ResourceDatabasePopulator();\n populator.addScripts(\n new ClassPathResource(\"test-schema.sql\"),\n new ClassPathResource(\"test-data.sql\"));\n populator.setSeparator(\"@@\");\n populator.execute(this.dataSource);\n // run code that uses the test schema and data\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\tfun databaseTest() {\n val populator = ResourceDatabasePopulator()\n populator.addScripts(\n ClassPathResource(\"test-schema.sql\"),\n ClassPathResource(\"test-data.sql\"))\n populator.setSeparator(\"@@\")\n populator.execute(dataSource)\n // run code that uses the test schema and data\n\t}\n----\n======\n\nNote that `ResourceDatabasePopulator` internally delegates to `ScriptUtils` for parsing\nand running SQL scripts. Similarly, the `executeSqlScript(..)` methods in\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-support-classes-junit4[`AbstractTransactionalJUnit4SpringContextTests`]\nand xref:testing/testcontext-framework/support-classes.adoc#testcontext-support-classes-testng[`AbstractTransactionalTestNGSpringContextTests`]\ninternally use a `ResourceDatabasePopulator` to run SQL scripts. See the Javadoc for the\nvarious `executeSqlScript(..)` methods for further details.\n\n[[testcontext-executing-sql-declaratively]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc", "title": "executing-sql", "heading": "Executing SQL scripts programmatically", "heading_level": 2, "file_order": 262, "section_index": 1, "content_hash": "1456cac7b255609c2ed95e4f168849a52e4efaddf8ca8ef136bf19dfde50bbbc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc"}}
{"id": "sha256:eedf490f573ffcd6a1260cace6d9f9c2d27ea8bc3815f758ceefb2e4c6c6756c", "content": "In addition to the aforementioned mechanisms for running SQL scripts programmatically,\nyou can declaratively configure SQL scripts in the Spring TestContext Framework.\nSpecifically, you can declare the `@Sql` annotation on a test class or test method to\nconfigure individual SQL statements or the resource paths to SQL scripts that should be\nrun against a given database before or after an integration test class or test method.\nSupport for `@Sql` is provided by the `SqlScriptsTestExecutionListener`, which is enabled\nby default.\n\n[NOTE]\n====\nMethod-level `@Sql` declarations override class-level declarations by default, but this\nbehavior may be configured per test class or per test method via `@SqlMergeMode`. See\nxref:testing/testcontext-framework/executing-sql.adoc#testcontext-executing-sql-declaratively-script-merging[Merging and Overriding Configuration with `@SqlMergeMode`]\nfor further details.\n\nHowever, this does not apply to class-level declarations configured for the\n`BEFORE_TEST_CLASS` or `AFTER_TEST_CLASS` execution phases. Such declarations cannot be\noverridden, and the corresponding scripts and statements will be executed once per class\nin addition to any method-level scripts and statements.\n====\n\n[[testcontext-executing-sql-declaratively-script-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc", "title": "executing-sql", "heading": "Executing SQL scripts declaratively with @Sql", "heading_level": 2, "file_order": 262, "section_index": 2, "content_hash": "eedf490f573ffcd6a1260cace6d9f9c2d27ea8bc3815f758ceefb2e4c6c6756c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc"}}
{"id": "sha256:9968efdc1a99b4172030173a1458a2d067a25a1600fe0df7a2553e68e801eca4", "content": "Each path is interpreted as a Spring `Resource`. A plain path (for example,\n`\"schema.sql\"`) is treated as a classpath resource that is relative to the package in\nwhich the test class is defined. A path starting with a slash is treated as an absolute\nclasspath resource (for example, `\"/org/example/schema.sql\"`). A path that references a\nURL (for example, a path prefixed with `classpath:`, `file:`, `http:`) is loaded by using\nthe specified resource protocol.\n\nAs of Spring Framework 6.2, paths may contain property placeholders (`${...}`) that will\nbe replaced by properties stored in the `Environment` of the test's `ApplicationContext`.\n\nThe following example shows how to use `@Sql` at the class level and at the method level\nwithin a JUnit Jupiter based integration test class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig\n\t@Sql(\"/test-schema.sql\")\n\tclass DatabaseTests {\n\n @Test\n void emptySchemaTest() {\n // run code that uses the test schema without any test data\n }\n\n @Test\n @Sql({\"/test-schema.sql\", \"/test-user-data.sql\"})\n void userTest() {\n // run code that uses the test schema and test data\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig\n\t@Sql(\"/test-schema.sql\")\n\tclass DatabaseTests {\n\n @Test\n fun emptySchemaTest() {\n // run code that uses the test schema without any test data\n }\n\n @Test\n @Sql(\"/test-schema.sql\", \"/test-user-data.sql\")\n fun userTest() {\n // run code that uses the test schema and test data\n }\n\t}\n----\n======\n\n[[testcontext-executing-sql-declaratively-script-detection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc", "title": "executing-sql", "heading": "Path Resource Semantics", "heading_level": 3, "file_order": 262, "section_index": 3, "content_hash": "9968efdc1a99b4172030173a1458a2d067a25a1600fe0df7a2553e68e801eca4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc"}}
{"id": "sha256:76870991e9d057e9948ce1428bc517fcb9849fa47743fd9567d13550fcfa69a0", "content": "If no SQL scripts or statements are specified, an attempt is made to detect a `default`\nscript, depending on where `@Sql` is declared. If a default cannot be detected, an\n`IllegalStateException` is thrown.\n\n* Class-level declaration: If the annotated test class is `com.example.MyTest`, the\n corresponding default script is `classpath:com/example/MyTest.sql`.\n* Method-level declaration: If the annotated test method is named `testMethod()` and is\n defined in the class `com.example.MyTest`, the corresponding default script is\n `classpath:com/example/MyTest.testMethod.sql`.\n\n[[testcontext-executing-sql-declaratively-logging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc", "title": "executing-sql", "heading": "Default Script Detection", "heading_level": 3, "file_order": 262, "section_index": 4, "content_hash": "76870991e9d057e9948ce1428bc517fcb9849fa47743fd9567d13550fcfa69a0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc"}}
{"id": "sha256:3e1547874394f8bb036aa4a06f6775e5e04ef25cbe3305c30cf0e46724aeda1e", "content": "If you want to see which SQL scripts are being executed, set the\n`org.springframework.test.context.jdbc` logging category to `DEBUG`.\n\nIf you want to see which SQL statements are being executed, set the\n`org.springframework.jdbc.datasource.init` logging category to `DEBUG`.\n\n[[testcontext-executing-sql-declaratively-multiple-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc", "title": "executing-sql", "heading": "Logging SQL Scripts and Statements", "heading_level": 3, "file_order": 262, "section_index": 5, "content_hash": "3e1547874394f8bb036aa4a06f6775e5e04ef25cbe3305c30cf0e46724aeda1e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc"}}
{"id": "sha256:5b80ee200e58e6c578dbef243df7a685684f0fbec402b44f16805ee2a08c4cd0", "content": "If you need to configure multiple sets of SQL scripts for a given test class or test\nmethod but with different syntax configuration, different error handling rules, or\ndifferent execution phases per set, you can declare multiple instances of `@Sql`. You can\neither use `@Sql` as a repeatable annotation, or you can use the `@SqlGroup` annotation\nas an explicit container for declaring multiple instances of `@Sql`.\n\nThe following example shows how to use `@Sql` as a repeatable annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\t@Sql(scripts = \"/test-schema.sql\", config = @SqlConfig(commentPrefix = \"`\"))\n\t@Sql(\"/test-user-data.sql\")\n\tvoid userTest() {\n // run code that uses the test schema and test data\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\t@Sql(\"/test-schema.sql\", config = SqlConfig(commentPrefix = \"`\"))\n\t@Sql(\"/test-user-data.sql\")\n\tfun userTest() {\n // run code that uses the test schema and test data\n\t}\n----\n======\n\nIn the scenario presented in the preceding example, the `test-schema.sql` script uses a\ndifferent syntax for single-line comments.\n\nThe following example is identical to the preceding example, except that the `@Sql`\ndeclarations are grouped together within `@SqlGroup`. The use of `@SqlGroup` is optional,\nbut you may need to use `@SqlGroup` for compatibility with other JVM languages.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\t@SqlGroup({\n @Sql(scripts = \"/test-schema.sql\", config = @SqlConfig(commentPrefix = \"`\")),\n @Sql(\"/test-user-data.sql\")\n\t})\n\tvoid userTest() {\n // run code that uses the test schema and test data\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\t@SqlGroup(\n Sql(\"/test-schema.sql\", config = SqlConfig(commentPrefix = \"`\")),\n Sql(\"/test-user-data.sql\")\n\t)\n\tfun userTest() {\n // Run code that uses the test schema and test data\n\t}\n----\n======\n\n[[testcontext-executing-sql-declaratively-script-execution-phases]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc", "title": "executing-sql", "heading": "Declaring Multiple `@Sql` Sets", "heading_level": 3, "file_order": 262, "section_index": 6, "content_hash": "5b80ee200e58e6c578dbef243df7a685684f0fbec402b44f16805ee2a08c4cd0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc"}}
{"id": "sha256:9551926efd9244c63354ab05976623ab520c5e100db3ce5815e2a486bf2239de", "content": "By default, SQL scripts are run before the corresponding test method. However, if you\nneed to run a particular set of scripts after the test method (for example, to clean up\ndatabase state), you can set the `executionPhase` attribute in `@Sql` to\n`AFTER_TEST_METHOD`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\t@Sql(\n scripts = \"create-test-data.sql\",\n config = @SqlConfig(transactionMode = ISOLATED)\n\t)\n\t@Sql(\n scripts = \"delete-test-data.sql\",\n config = @SqlConfig(transactionMode = ISOLATED),\n executionPhase = AFTER_TEST_METHOD\n\t)\n\tvoid userTest() {\n // run code that needs the test data to be committed\n // to the database outside of the test's transaction\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Test\n\t@Sql(\"create-test-data.sql\",\n config = SqlConfig(transactionMode = ISOLATED))\n\t@Sql(\"delete-test-data.sql\",\n config = SqlConfig(transactionMode = ISOLATED),\n executionPhase = AFTER_TEST_METHOD)\n\tfun userTest() {\n // run code that needs the test data to be committed\n // to the database outside of the test's transaction\n\t}\n----\n======\n\nNOTE: `ISOLATED` and `AFTER_TEST_METHOD` are statically imported from\n`Sql.TransactionMode` and `Sql.ExecutionPhase`, respectively.\n\nAs of Spring Framework 6.1, it is possible to run a particular set of scripts before or\nafter the test class by setting the `executionPhase` attribute in a class-level `@Sql`\ndeclaration to `BEFORE_TEST_CLASS` or `AFTER_TEST_CLASS`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig\n\t@Sql(scripts = \"/test-schema.sql\", executionPhase = BEFORE_TEST_CLASS)\n\tclass DatabaseTests {\n\n @Test\n void emptySchemaTest() {\n // run code that uses the test schema without any test data\n }\n\n @Test\n @Sql(\"/test-user-data.sql\")\n void userTest() {\n // run code that uses the test schema and test data\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig\n\t@Sql(\"/test-schema.sql\", executionPhase = BEFORE_TEST_CLASS)\n\tclass DatabaseTests {\n\n @Test\n fun emptySchemaTest() {\n // run code that uses the test schema without any test data\n }\n\n @Test\n @Sql(\"/test-user-data.sql\")\n fun userTest() {\n // run code that uses the test schema and test data\n }\n\t}\n----\n======\n\nNOTE: `BEFORE_TEST_CLASS` is statically imported from `Sql.ExecutionPhase`.\n\n[[testcontext-executing-sql-declaratively-script-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc", "title": "executing-sql", "heading": "Script Execution Phases", "heading_level": 3, "file_order": 262, "section_index": 7, "content_hash": "9551926efd9244c63354ab05976623ab520c5e100db3ce5815e2a486bf2239de", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc"}}
{"id": "sha256:8ebc94f08866b03f11360693229fd6394225c39186d1a50a1e3a6b26c8576171", "content": "You can configure script parsing and error handling by using the `@SqlConfig` annotation.\nWhen declared as a class-level annotation on an integration test class, `@SqlConfig`\nserves as global configuration for all SQL scripts within the test class hierarchy. When\ndeclared directly by using the `config` attribute of the `@Sql` annotation, `@SqlConfig`\nserves as local configuration for the SQL scripts declared within the enclosing `@Sql`\nannotation. Every attribute in `@SqlConfig` has an implicit default value, which is\ndocumented in the javadoc of the corresponding attribute. Due to the rules defined for\nannotation attributes in the Java Language Specification, it is, unfortunately, not\npossible to assign a value of `null` to an annotation attribute. Thus, in order to\nsupport overrides of inherited global configuration, `@SqlConfig` attributes have an\nexplicit default value of either `\"\"` (for Strings), `{}` (for arrays), or `DEFAULT` (for\nenumerations). This approach lets local declarations of `@SqlConfig` selectively override\nindividual attributes from global declarations of `@SqlConfig` by providing a value other\nthan `\"\"`, `{}`, or `DEFAULT`. Global `@SqlConfig` attributes are inherited whenever\nlocal `@SqlConfig` attributes do not supply an explicit value other than `\"\"`, `{}`, or\n`DEFAULT`. Explicit local configuration, therefore, overrides global configuration.\n\nThe configuration options provided by `@Sql` and `@SqlConfig` are equivalent to those\nsupported by `ScriptUtils` and `ResourceDatabasePopulator` but are a superset of those\nprovided by the `<jdbc:initialize-database/>` XML namespace element. See the javadoc of\nindividual attributes in {spring-framework-api}/test/context/jdbc/Sql.html[`@Sql`] and\n{spring-framework-api}/test/context/jdbc/SqlConfig.html[`@SqlConfig`] for details.\n\n[[testcontext-executing-sql-declaratively-tx]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc", "title": "executing-sql", "heading": "Script Configuration with `@SqlConfig`", "heading_level": 3, "file_order": 262, "section_index": 8, "content_hash": "8ebc94f08866b03f11360693229fd6394225c39186d1a50a1e3a6b26c8576171", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc"}}
{"id": "sha256:3c233cfc7a35291abfcfe050aff2fecf66db6797d941072312fa62a4e8a461bd", "content": "By default, the `SqlScriptsTestExecutionListener` infers the desired transaction\nsemantics for scripts configured by using `@Sql`. Specifically, SQL scripts are run\nwithout a transaction, within an existing Spring-managed transaction (for example, a\ntransaction managed by the `TransactionalTestExecutionListener` for a test annotated with\n`@Transactional`), or within an isolated transaction, depending on the configured value\nof the `transactionMode` attribute in `@SqlConfig` and the presence of a\n`PlatformTransactionManager` in the test's `ApplicationContext`. As a bare minimum,\nhowever, a `javax.sql.DataSource` must be present in the test's `ApplicationContext`.\n\nIf the algorithms used by `SqlScriptsTestExecutionListener` to detect a `DataSource` and\n`PlatformTransactionManager` and infer the transaction semantics do not suit your needs,\nyou can specify explicit names by setting the `dataSource` and `transactionManager`\nattributes of `@SqlConfig`. Furthermore, you can control the transaction propagation\nbehavior by setting the `transactionMode` attribute of `@SqlConfig` (for example, whether\nscripts should be run in an isolated transaction). Although a thorough discussion of all\nsupported options for transaction management with `@Sql` is beyond the scope of this\nreference manual, the javadoc for\n{spring-framework-api}/test/context/jdbc/SqlConfig.html[`@SqlConfig`] and\n{spring-framework-api}/test/context/jdbc/SqlScriptsTestExecutionListener.html[`SqlScriptsTestExecutionListener`]\nprovide detailed information, and the following example shows a typical testing scenario\nthat uses JUnit Jupiter and transactional tests with `@Sql`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestDatabaseConfig.class)\n\t@Transactional\n\tclass TransactionalSqlScriptsTests {\n\n final JdbcTemplate jdbcTemplate;\n\n @Autowired\n TransactionalSqlScriptsTests(DataSource dataSource) {\n this.jdbcTemplate = new JdbcTemplate(dataSource);\n }\n\n @Test\n @Sql(\"/test-data.sql\")\n void usersTest() {\n // verify state in test database:\n assertNumUsers(2);\n // run code that uses the test data...\n }\n\n int countRowsInTable(String tableName) {\n return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);\n }\n\n void assertNumUsers(int expected) {\n assertEquals(expected, countRowsInTable(\"user\"),\n \"Number of rows in the [user] table.\");\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestDatabaseConfig::class)\n\t@Transactional\n\tclass TransactionalSqlScriptsTests @Autowired constructor(dataSource: DataSource) {\n\n val jdbcTemplate: JdbcTemplate = JdbcTemplate(dataSource)\n\n @Test\n @Sql(\"/test-data.sql\")\n fun usersTest() {\n // verify state in test database:\n assertNumUsers(2)\n // run code that uses the test data...\n }\n\n fun countRowsInTable(tableName: String): Int {\n return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName)\n }\n\n fun assertNumUsers(expected: Int) {\n assertEquals(expected, countRowsInTable(\"user\"),\n \"Number of rows in the [user] table.\")\n }\n\t}\n----\n======\n\nNote that there is no need to clean up the database after the `usersTest()` method is\nrun, since any changes made to the database (either within the test method or within the\n`/test-data.sql` script) are automatically rolled back by the\n`TransactionalTestExecutionListener` (see xref:testing/testcontext-framework/tx.adoc[transaction management] for\ndetails).\n\n[[testcontext-executing-sql-declaratively-script-merging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc", "title": "executing-sql", "heading": "Transaction management for `@Sql`", "heading_level": 4, "file_order": 262, "section_index": 9, "content_hash": "3c233cfc7a35291abfcfe050aff2fecf66db6797d941072312fa62a4e8a461bd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc"}}
{"id": "sha256:c47f6d5c211b2bd5a414a7481980ca38c76d5eff6a40b9e5a87450d7274bf11a", "content": "It is possible to merge method-level `@Sql` declarations with\nclass-level declarations. For example, this allows you to provide the configuration for a\ndatabase schema or some common test data once per test class and then provide additional,\nuse case specific test data per test method. To enable `@Sql` merging, annotate either\nyour test class or test method with `@SqlMergeMode(MERGE)`. To disable merging for a\nspecific test method (or specific test subclass), you can switch back to the default mode\nvia `@SqlMergeMode(OVERRIDE)`. Consult the\nxref:testing/annotations/integration-spring/annotation-sqlmergemode.adoc[`@SqlMergeMode` annotation documentation section]\nfor examples and further details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc", "title": "executing-sql", "heading": "Merging and Overriding Configuration with `@SqlMergeMode`", "heading_level": 3, "file_order": 262, "section_index": 10, "content_hash": "c47f6d5c211b2bd5a414a7481980ca38c76d5eff6a40b9e5a87450d7274bf11a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/executing-sql.adoc"}}
{"id": "sha256:641250eb05fc034f24eccda3067c3b5ea139942023d76961682e1aec70f75f38", "content": "[[testcontext-fixture-di]]\n\nWhen you use the `DependencyInjectionTestExecutionListener` (which is configured by\ndefault), the dependencies of your test instances are injected from beans in the\napplication context that you configured with `@ContextConfiguration` or related\nannotations. You may use setter injection, field injection, or both, depending on\nwhich annotations you choose and whether you place them on setter methods or fields.\nIf you are using JUnit Jupiter you may also optionally use constructor injection\n(see xref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-di[Dependency Injection with `SpringExtension`]).\nFor consistency with Spring's annotation-based injection support, you may also use\nSpring's `@Autowired` annotation or the `@Inject` annotation from JSR-330 for\nfield and setter injection.\n\nTIP: For testing frameworks other than JUnit Jupiter, the TestContext framework does not\nparticipate in instantiation of the test class. Thus, the use of `@Autowired` or\n`@Inject` for constructors has no effect for test classes.\n\nNOTE: Although field injection is discouraged in production code, field injection is\nactually quite natural in test code. The rationale for the difference is that you will\nnever instantiate your test class directly. Consequently, there is no need to be able to\ninvoke a `public` constructor or setter method on your test class.\n\nBecause `@Autowired` is used to perform xref:core/beans/dependencies/factory-autowire.adoc[autowiring by type]\n, if you have multiple bean definitions of the same type, you cannot rely on this\napproach for those particular beans. In that case, you can use `@Autowired` in\nconjunction with `@Qualifier`. You can also choose to use `@Inject` in conjunction with\n`@Named`. Alternatively, if your test class has access to its `ApplicationContext`, you\ncan perform an explicit lookup by using (for example) a call to\n`applicationContext.getBean(\"titleRepository\", TitleRepository.class)`.\n\nIf you do not want dependency injection applied to your test instances, do not annotate\nfields or setter methods with `@Autowired` or `@Inject`. Alternatively, you can disable\ndependency injection altogether by explicitly configuring your class with\n`@TestExecutionListeners` and omitting `DependencyInjectionTestExecutionListener.class`\nfrom the list of listeners.\n\nConsider the scenario of testing a `HibernateTitleRepository` class, as outlined in the\nxref:testing/integration.adoc#integration-testing-goals[Goals] section. The next two code\nlistings demonstrate the use of `@Autowired` on fields and setter methods. The application\ncontext configuration is presented after all sample code listings.\n\n[NOTE]\n====\nThe dependency injection behavior in the following code listings is not specific to JUnit\nJupiter. The same DI techniques can be used in conjunction with any supported testing\nframework.\n\nThe following examples make calls to static assertion methods, such as `assertNotNull()`,\nbut without prepending the call with `Assertions`. In such cases, assume that the method\nwas properly imported through an `import static` declaration that is not shown in the\nexample.\n====\n\nThe first code listing shows a JUnit Jupiter based implementation of the test class that\nuses `@Autowired` for field injection:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t// specifies the Spring configuration to load for this test fixture\n\t@ContextConfiguration(\"repository-config.xml\")\n\tclass HibernateTitleRepositoryTests {\n\n // this instance will be dependency injected by type\n @Autowired\n HibernateTitleRepository titleRepository;\n\n @Test\n void findById() {\n Title title = titleRepository.findById(new Long(10));\n assertNotNull(title);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t// specifies the Spring configuration to load for this test fixture\n\t@ContextConfiguration(\"repository-config.xml\")\n\tclass HibernateTitleRepositoryTests {\n\n // this instance will be dependency injected by type\n @Autowired\n lateinit var titleRepository: HibernateTitleRepository\n\n @Test\n fun findById() {\n val title = titleRepository.findById(10)\n assertNotNull(title)\n }\n\t}\n----\n======\n\nAlternatively, you can configure the class to use `@Autowired` for setter injection, as\nfollows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t// specifies the Spring configuration to load for this test fixture\n\t@ContextConfiguration(\"repository-config.xml\")\n\tclass HibernateTitleRepositoryTests {\n\n // this instance will be dependency injected by type\n HibernateTitleRepository titleRepository;\n\n @Autowired\n void setTitleRepository(HibernateTitleRepository titleRepository) {\n this.titleRepository = titleRepository;\n }\n\n @Test\n void findById() {\n Title title = titleRepository.findById(new Long(10));\n assertNotNull(title);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension::class)\n\t// specifies the Spring configuration to load for this test fixture\n\t@ContextConfiguration(\"repository-config.xml\")\n\tclass HibernateTitleRepositoryTests {\n\n // this instance will be dependency injected by type\n lateinit var titleRepository: HibernateTitleRepository\n\n @Autowired\n fun setTitleRepository(titleRepository: HibernateTitleRepository) {\n this.titleRepository = titleRepository\n }\n\n @Test\n fun findById() {\n val title = titleRepository.findById(10)\n assertNotNull(title)\n }\n\t}\n----\n======\n\nThe preceding code listings use the same XML context file referenced by the\n`@ContextConfiguration` annotation (that is, `repository-config.xml`). The following\nshows this configuration:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <!-- this bean will be injected into the HibernateTitleRepositoryTests class -->\n <bean id=\"titleRepository\" class=\"com.foo.repository.hibernate.HibernateTitleRepository\">\n <property name=\"sessionFactory\" ref=\"sessionFactory\"/>\n </bean>\n\n <bean id=\"sessionFactory\" class=\"org.springframework.orm.jpa.hibernate.LocalSessionFactoryBean\">\n <!-- configuration elided for brevity -->\n </bean>\n\n\t</beans>\n----\n\n[NOTE]\n=====\nIf you are extending from a Spring-provided test base class that happens to use\n`@Autowired` on one of its setter methods, you might have multiple beans of the affected\ntype defined in your application context (for example, multiple `DataSource` beans). In\nsuch a case, you can override the setter method and use the `@Qualifier` annotation to\nindicate a specific target bean, as follows (but make sure to delegate to the overridden\nmethod in the superclass as well):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// ...\n\n @Autowired\n @Override\n public void setDataSource(@Qualifier(\"myDataSource\") DataSource dataSource) {\n super.setDataSource(dataSource);\n }\n\n\t// ...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// ...\n\n @Autowired\n override fun setDataSource(@Qualifier(\"myDataSource\") dataSource: DataSource) {\n super.setDataSource(dataSource)\n }\n\n\t// ...\n----\n======\n\nThe specified qualifier value indicates the specific `DataSource` bean to inject,\nnarrowing the set of type matches to a specific bean. Its value is matched against\n`<qualifier>` declarations within the corresponding `<bean>` definitions. The bean name\nis used as a fallback qualifier value, so you can effectively also point to a specific\nbean by name there (as shown earlier, assuming that `myDataSource` is the bean `id`).\n=====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/fixture-di.adoc", "title": "fixture-di", "heading": "fixture-di", "heading_level": 1, "file_order": 263, "section_index": 0, "content_hash": "641250eb05fc034f24eccda3067c3b5ea139942023d76961682e1aec70f75f38", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/fixture-di.adoc"}}
{"id": "sha256:1f934ffe4ba8487cc6cc372213aae917a4f28305d48206529d3453bb35144e59", "content": "[[testcontext-key-abstractions]]\n\nThe core of the framework consists of the `TestContextManager` class and the\n`TestContext`, `TestExecutionListener`, and `SmartContextLoader` interfaces. A\n`TestContextManager` is created for each test class (for example, for the execution of\nall test methods within a single test class in JUnit Jupiter). The `TestContextManager`,\nin turn, manages a `TestContext` that holds the context of the current test. The\n`TestContextManager` also updates the state of the `TestContext` as the test progresses\nand delegates to `TestExecutionListener` implementations, which instrument the actual\ntest execution by providing dependency injection, managing transactions, and so on. A\n`SmartContextLoader` is responsible for loading an `ApplicationContext` for a given test\nclass. See the {spring-framework-api}/test/context/package-summary.html[javadoc] and the\nSpring test suite for further information and examples of various implementations.\n\n[[testcontext]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/key-abstractions.adoc", "title": "key-abstractions", "heading": "key-abstractions", "heading_level": 1, "file_order": 264, "section_index": 0, "content_hash": "1f934ffe4ba8487cc6cc372213aae917a4f28305d48206529d3453bb35144e59", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/key-abstractions.adoc"}}
{"id": "sha256:e8055e8132338bb1bcb2db034c03a4b5072d97f7848ed5e1f69d3ba5dfa98187", "content": "`TestContext` encapsulates the context in which a test is run (agnostic of the\nactual testing framework in use) and provides context management and caching support for\nthe test instance for which it is responsible. The `TestContext` also delegates to a\n`SmartContextLoader` to load an `ApplicationContext` if requested.\n\n[[testcontextmanager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/key-abstractions.adoc", "title": "key-abstractions", "heading": "`TestContext`", "heading_level": 2, "file_order": 264, "section_index": 1, "content_hash": "e8055e8132338bb1bcb2db034c03a4b5072d97f7848ed5e1f69d3ba5dfa98187", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/key-abstractions.adoc"}}
{"id": "sha256:10baaaa4b0fec45bc0081e727080c80f1f0e66c3dbff6c5be28662f78f542a6c", "content": "`TestContextManager` is the main entry point into the Spring TestContext Framework and is\nresponsible for managing a single `TestContext` and signaling events to each registered\n`TestExecutionListener` at well-defined test execution points:\n\n* Prior to any \"`before class`\" or \"`before all`\" methods of a particular testing framework.\n* Test instance post-processing.\n* Prior to any \"`before`\" or \"`before each`\" methods of a particular testing framework.\n* Immediately before execution of the test method but after test setup.\n* Immediately after execution of the test method but before test tear down.\n* After any \"`after`\" or \"`after each`\" methods of a particular testing framework.\n* After any \"`after class`\" or \"`after all`\" methods of a particular testing framework.\n\n[[testexecutionlistener]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/key-abstractions.adoc", "title": "key-abstractions", "heading": "`TestContextManager`", "heading_level": 2, "file_order": 264, "section_index": 2, "content_hash": "10baaaa4b0fec45bc0081e727080c80f1f0e66c3dbff6c5be28662f78f542a6c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/key-abstractions.adoc"}}
{"id": "sha256:1560588054c1a461f69c556d23822aca3be8e1fd37390c15a07e40a1b691afb4", "content": "`TestExecutionListener` defines the API for reacting to test-execution events published by\nthe `TestContextManager` with which the listener is registered. See\nxref:testing/testcontext-framework/tel-config.adoc[`TestExecutionListener` Configuration].\n\n[[context-loaders]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/key-abstractions.adoc", "title": "key-abstractions", "heading": "`TestExecutionListener`", "heading_level": 2, "file_order": 264, "section_index": 3, "content_hash": "1560588054c1a461f69c556d23822aca3be8e1fd37390c15a07e40a1b691afb4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/key-abstractions.adoc"}}
{"id": "sha256:415422e75810721a7831242c641d5316658bc8966b2b26e06c809de7c5373768", "content": "`ContextLoader` is a strategy interface for loading an `ApplicationContext` for an\nintegration test managed by the Spring TestContext Framework. You should implement\n`SmartContextLoader` instead of this interface to provide support for component classes,\nactive bean definition profiles, test property sources, context hierarchies, and\n`WebApplicationContext` support.\n\n`SmartContextLoader` is an extension of the `ContextLoader` interface that supersedes the\noriginal minimal `ContextLoader` SPI. Specifically, a `SmartContextLoader` can choose to\nprocess resource locations, component classes, or context initializers. Furthermore, a\n`SmartContextLoader` can set active bean definition profiles and test property sources in\nthe context that it loads.\n\nSpring provides the following implementations:\n\n* `DelegatingSmartContextLoader`: One of two default loaders, it delegates internally to\n an `AnnotationConfigContextLoader`, a `GenericXmlContextLoader`, or a\n `GenericGroovyXmlContextLoader`, depending either on the configuration declared for the\n test class or on the presence of default locations or default configuration classes.\n Groovy support is enabled only if Groovy is on the classpath.\n* `WebDelegatingSmartContextLoader`: One of two default loaders, it delegates internally\n to an `AnnotationConfigWebContextLoader`, a `GenericXmlWebContextLoader`, or a\n `GenericGroovyXmlWebContextLoader`, depending either on the configuration declared for\n the test class or on the presence of default locations or default configuration\n classes. A web `ContextLoader` is used only if `@WebAppConfiguration` is present on the\n test class. Groovy support is enabled only if Groovy is on the classpath.\n* `AnnotationConfigContextLoader`: Loads a standard `ApplicationContext` from component\n classes.\n* `AnnotationConfigWebContextLoader`: Loads a `WebApplicationContext` from component\n classes.\n* `GenericGroovyXmlContextLoader`: Loads a standard `ApplicationContext` from resource\n locations that are either Groovy scripts or XML configuration files.\n* `GenericGroovyXmlWebContextLoader`: Loads a `WebApplicationContext` from resource\n locations that are either Groovy scripts or XML configuration files.\n* `GenericXmlContextLoader`: Loads a standard `ApplicationContext` from XML resource\n locations.\n* `GenericXmlWebContextLoader`: Loads a `WebApplicationContext` from XML resource\n locations.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/key-abstractions.adoc", "title": "key-abstractions", "heading": "Context Loaders", "heading_level": 2, "file_order": 264, "section_index": 4, "content_hash": "415422e75810721a7831242c641d5316658bc8966b2b26e06c809de7c5373768", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/key-abstractions.adoc"}}
{"id": "sha256:752b6b05903f4ee9848f5171f89ce648e43531d2cfc722401c6079bc046d3233", "content": "[[testcontext-parallel-test-execution]]\n\nThe Spring TestContext Framework provides basic support for executing tests in parallel\nwithin a single JVM. In general, this means that most test classes or test methods can be\nrun in parallel without any changes to test code or configuration.\n\nTIP: For details on how to set up parallel test execution, see the documentation for your\ntesting framework, build tool, or IDE.\n\nKeep in mind that the introduction of concurrency into your test suite can result in\nunexpected side effects, strange runtime behavior, and tests that fail intermittently or\nseemingly randomly. The Spring Team therefore provides the following general guidelines\nfor when not to run tests in parallel.\n\nDo not run tests in parallel if the tests:\n\n* Use Spring Framework's `@DirtiesContext` support.\n* Use Spring Framework's `@MockitoBean` or `@MockitoSpyBean` support.\n* Use Spring Boot's `@MockBean` or `@SpyBean` support.\n* Use JUnit Jupiter's `@TestMethodOrder` support or any testing framework feature that is\n designed to ensure that test methods run in a particular order. Note, however, that\n this does not apply if entire test classes are run in parallel.\n* Change the state of shared services or systems such as a database, message broker,\n filesystem, and others. This applies to both embedded and external systems.\n\n[TIP]\n====\nIf parallel test execution fails with an exception stating that the `ApplicationContext`\nfor the current test is no longer active, this typically means that the\n`ApplicationContext` was removed from the `ContextCache` in a different thread.\n\nThis may be due to the use of `@DirtiesContext` or due to automatic eviction from the\n`ContextCache`. If `@DirtiesContext` is the culprit, you either need to find a way to\navoid using `@DirtiesContext` or exclude such tests from parallel execution. If the\nmaximum size of the `ContextCache` has been exceeded, you can increase the maximum size\nof the cache. See the discussion on xref:testing/testcontext-framework/ctx-management/caching.adoc[context caching]\nfor details.\n====\n\nWARNING: Parallel test execution in the Spring TestContext Framework is only possible if\nthe underlying `TestContext` implementation provides a copy constructor, as explained in\nthe javadoc for {spring-framework-api}/test/context/TestContext.html[`TestContext`]. The\n`DefaultTestContext` used in Spring provides such a constructor. However, if you use a\nthird-party library that provides a custom `TestContext` implementation, you need to\nverify that it is suitable for parallel test execution.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/parallel-test-execution.adoc", "title": "parallel-test-execution", "heading": "parallel-test-execution", "heading_level": 1, "file_order": 265, "section_index": 0, "content_hash": "752b6b05903f4ee9848f5171f89ce648e43531d2cfc722401c6079bc046d3233", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/parallel-test-execution.adoc"}}
{"id": "sha256:80fd07b855f7c9863f166ef27f0cce6c38f15b8dfe4170aed736c6faa0f7190e", "content": "[[testcontext-support-classes]]\n\nThis section describes the various classes that support the Spring TestContext Framework\nin JUnit and TestNG.\n\n[[testcontext-junit-jupiter-extension]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc", "title": "support-classes", "heading": "support-classes", "heading_level": 1, "file_order": 266, "section_index": 0, "content_hash": "80fd07b855f7c9863f166ef27f0cce6c38f15b8dfe4170aed736c6faa0f7190e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc"}}
{"id": "sha256:efbef67835342390de10247d739ad7429d824b9e7cc94ce5981e016eb9e25f33", "content": "The `SpringExtension` integrates the Spring TestContext Framework into the JUnit Jupiter\ntesting framework.\n\nNOTE: As of Spring Framework 7.0, the `SpringExtension` requires JUnit Jupiter 6.0 or higher.\n\nBy annotating test classes with `@ExtendWith(SpringExtension.class)`, you can implement\nstandard JUnit Jupiter-based unit and integration tests and simultaneously reap the\nbenefits of the TestContext framework, such as support for loading application contexts,\ndependency injection of test instances, transactional test method execution, and so on.\n\nFurthermore, thanks to the rich extension API in JUnit Jupiter, Spring provides the\nfollowing features above and beyond the feature set that Spring supports for JUnit 4 and\nTestNG:\n\n* Dependency injection for test constructors, test methods, and test lifecycle callback\n methods. See xref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-di[Dependency\n Injection with the `SpringExtension`] for further details.\n* Powerful support for link:https://docs.junit.org/current/extensions/conditional-test-execution.html[conditional\n test execution] based on SpEL expressions, environment variables, system properties,\n and so on. See the documentation for `@EnabledIf` and `@DisabledIf` in\n xref:testing/annotations/integration-junit-jupiter.adoc[Spring JUnit Jupiter Testing Annotations]\n for further details and examples.\n* Custom composed annotations that combine annotations from Spring and JUnit Jupiter. See\n the `@TransactionalDevTestConfig` and `@TransactionalIntegrationTest` examples in\n xref:testing/annotations/integration-meta.adoc[Meta-Annotation Support for Testing] for\n further details.\n\nThe following code listing shows how to configure a test class to use the\n`SpringExtension` in conjunction with `@ContextConfiguration`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Instructs JUnit Jupiter to extend the test with Spring support.\n\t@ExtendWith(SpringExtension.class)\n\t// Instructs Spring to load an ApplicationContext from TestConfig.class\n\t@ContextConfiguration(classes = TestConfig.class)\n\tclass SimpleTests {\n\n @Test\n void testMethod() {\n // test logic...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Instructs JUnit Jupiter to extend the test with Spring support.\n\t@ExtendWith(SpringExtension::class)\n\t// Instructs Spring to load an ApplicationContext from TestConfig::class\n\t@ContextConfiguration(classes = [TestConfig::class])\n\tclass SimpleTests {\n\n @Test\n fun testMethod() {\n // test logic...\n }\n\t}\n----\n======\n\nSince you can also use annotations in JUnit Jupiter as meta-annotations, Spring provides\nthe `@SpringJUnitConfig` and `@SpringJUnitWebConfig` composed annotations to simplify the\nconfiguration of the test `ApplicationContext` and JUnit Jupiter.\n\nThe following example uses `@SpringJUnitConfig` to reduce the amount of configuration\nused in the previous example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Instructs Spring to register the SpringExtension with JUnit\n\t// Jupiter and load an ApplicationContext from TestConfig.class\n\t@SpringJUnitConfig(TestConfig.class)\n\tclass SimpleTests {\n\n @Test\n void testMethod() {\n // test logic...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Instructs Spring to register the SpringExtension with JUnit\n\t// Jupiter and load an ApplicationContext from TestConfig.class\n\t@SpringJUnitConfig(TestConfig::class)\n\tclass SimpleTests {\n\n @Test\n fun testMethod() {\n // test logic...\n }\n\t}\n----\n======\n\nSimilarly, the following example uses `@SpringJUnitWebConfig` to create a\n`WebApplicationContext` for use with JUnit Jupiter:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Instructs Spring to register the SpringExtension with JUnit\n\t// Jupiter and load a WebApplicationContext from TestWebConfig.class\n\t@SpringJUnitWebConfig(TestWebConfig.class)\n\tclass SimpleWebTests {\n\n @Test\n void testMethod() {\n // test logic...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Instructs Spring to register the SpringExtension with JUnit\n\t// Jupiter and load a WebApplicationContext from TestWebConfig::class\n\t@SpringJUnitWebConfig(TestWebConfig::class)\n\tclass SimpleWebTests {\n\n @Test\n fun testMethod() {\n // test logic...\n }\n\t}\n----\n======\n\nSee the documentation for `@SpringJUnitConfig` and `@SpringJUnitWebConfig` in\nxref:testing/annotations/integration-junit-jupiter.adoc[Spring JUnit Jupiter Testing Annotations]\nfor further details.\n\n[[testcontext-junit-jupiter-di]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc", "title": "support-classes", "heading": "SpringExtension for JUnit Jupiter", "heading_level": 2, "file_order": 266, "section_index": 1, "content_hash": "efbef67835342390de10247d739ad7429d824b9e7cc94ce5981e016eb9e25f33", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc"}}
{"id": "sha256:f00188f4ad3b0c25aea2ade5f17ce4a101fd74e4b60be88b511d283241cccb3b", "content": "The `SpringExtension` implements the\nlink:https://docs.junit.org/current/extensions/parameter-resolution.html[`ParameterResolver`]\nextension API from JUnit Jupiter, which lets Spring provide dependency injection for test\nconstructors, test methods, and test lifecycle callback methods.\n\nSpecifically, the `SpringExtension` can inject dependencies from the test's\n`ApplicationContext` into test constructors and methods that are annotated with Spring's\n`@BeforeTransaction` and `@AfterTransaction` or JUnit's `@BeforeAll`, `@AfterAll`,\n`@BeforeEach`, `@AfterEach`, `@Test`, `@RepeatedTest`, `@ParameterizedTest`, and others.\n\n[[testcontext-junit-jupiter-di-constructor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc", "title": "support-classes", "heading": "Dependency Injection with the `SpringExtension`", "heading_level": 3, "file_order": 266, "section_index": 2, "content_hash": "f00188f4ad3b0c25aea2ade5f17ce4a101fd74e4b60be88b511d283241cccb3b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc"}}
{"id": "sha256:04ce4d9b5ca6896deccd3f5f55829af643f26c1d6f8af598bdc7f01cbe295cbd", "content": "If a specific parameter in a constructor for a JUnit Jupiter test class is of type\n`ApplicationContext` (or a sub-type thereof) or is annotated or meta-annotated with\n`@Autowired`, `@Qualifier`, or `@Value`, Spring injects the value for that specific\nparameter with the corresponding bean or value from the test's `ApplicationContext`.\n\nSpring can also be configured to autowire all arguments for a test class constructor if\nthe constructor is considered to be _autowirable_. A constructor is considered to be\nautowirable if one of the following conditions is met (in order of precedence).\n\n* The constructor is annotated with `@Autowired`.\n* `@TestConstructor` is present or meta-present on the test class with the `autowireMode`\n attribute set to `ALL`.\n* The default _test constructor autowire mode_ has been changed to `ALL`.\n\nSee xref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-testconstructor[`@TestConstructor`]\nfor details on the use of `@TestConstructor` and how to change the global _test\nconstructor autowire mode_.\n\nWARNING: If the constructor for a test class is considered to be _autowirable_, Spring\nassumes the responsibility for resolving arguments for all parameters in the constructor.\nConsequently, no other `ParameterResolver` registered with JUnit Jupiter can resolve\nparameters for such a constructor.\n\n[WARNING]\n====\nConstructor injection for test classes must not be used in conjunction with JUnit\nJupiter's `@TestInstance(PER_CLASS)` support if `@DirtiesContext` is used to close the\ntest's `ApplicationContext` before or after test methods.\n\nThe reason is that `@TestInstance(PER_CLASS)` instructs JUnit Jupiter to cache the test\ninstance between test method invocations. Consequently, the test instance will retain\nreferences to beans that were originally injected from an `ApplicationContext` that has\nbeen subsequently closed. Since the constructor for the test class will only be invoked\nonce in such scenarios, dependency injection will not occur again, and subsequent tests\nwill interact with beans from the closed `ApplicationContext` which may result in errors.\n\nTo use `@DirtiesContext` with \"before test method\" or \"after test method\" modes in\nconjunction with `@TestInstance(PER_CLASS)`, one must configure dependencies from Spring\nto be supplied via field or setter injection so that they can be re-injected between test\nmethod invocations.\n====\n\nIn the following example, Spring injects the `OrderService` bean from the\n`ApplicationContext` loaded from `TestConfig.class` into the\n`OrderServiceIntegrationTests` constructor.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\tclass OrderServiceIntegrationTests {\n\n private final OrderService orderService;\n\n @Autowired\n OrderServiceIntegrationTests(OrderService orderService) {\n this.orderService = orderService;\n }\n\n // tests that use the injected OrderService\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig::class)\n\tclass OrderServiceIntegrationTests @Autowired constructor(private val orderService: OrderService){\n // tests that use the injected OrderService\n\t}\n\n----\n======\n\nNote that this feature lets test dependencies be `final` and therefore immutable.\n\nIf the `spring.test.constructor.autowire.mode` property is to `all` (see\nxref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-testconstructor[`@TestConstructor`]),\nwe can omit the declaration of `@Autowired` on the constructor in the previous example,\nresulting in the following.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\tclass OrderServiceIntegrationTests {\n\n private final OrderService orderService;\n\n OrderServiceIntegrationTests(OrderService orderService) {\n this.orderService = orderService;\n }\n\n // tests that use the injected OrderService\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig::class)\n\tclass OrderServiceIntegrationTests(val orderService:OrderService) {\n // tests that use the injected OrderService\n\t}\n----\n======\n\n[[testcontext-junit-jupiter-di-method]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc", "title": "support-classes", "heading": "Constructor Injection", "heading_level": 4, "file_order": 266, "section_index": 3, "content_hash": "04ce4d9b5ca6896deccd3f5f55829af643f26c1d6f8af598bdc7f01cbe295cbd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc"}}
{"id": "sha256:55a3a96f8a183f9a444da62aa1fd73a4366f1373202a68802c63b1bde98400fa", "content": "If a parameter in a JUnit Jupiter test method or test lifecycle callback method is of\ntype `ApplicationContext` (or a sub-type thereof) or is annotated or meta-annotated with\n`@Autowired`, `@Qualifier`, or `@Value`, Spring injects the value for that specific\nparameter with the corresponding bean from the test's `ApplicationContext`.\n\nIn the following example, Spring injects the `OrderService` from the `ApplicationContext`\nloaded from `TestConfig.class` into the `deleteOrder()` test method:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\tclass OrderServiceIntegrationTests {\n\n @Test\n void deleteOrder(@Autowired OrderService orderService) {\n // use orderService from the test's ApplicationContext\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig::class)\n\tclass OrderServiceIntegrationTests {\n\n @Test\n fun deleteOrder(@Autowired orderService: OrderService) {\n // use orderService from the test's ApplicationContext\n }\n\t}\n----\n======\n\nDue to the robustness of the `ParameterResolver` support in JUnit Jupiter, you can also\nhave multiple dependencies injected into a single method, not only from Spring but also\nfrom JUnit Jupiter itself or other third-party extensions.\n\nThe following example shows how to have both Spring and JUnit Jupiter inject dependencies\ninto the `placeOrderRepeatedly()` test method simultaneously.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\tclass OrderServiceIntegrationTests {\n\n @RepeatedTest(10)\n void placeOrderRepeatedly(RepetitionInfo repetitionInfo,\n @Autowired OrderService orderService) {\n\n // use orderService from the test's ApplicationContext\n // and repetitionInfo from JUnit Jupiter\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig::class)\n\tclass OrderServiceIntegrationTests {\n\n @RepeatedTest(10)\n fun placeOrderRepeatedly(repetitionInfo:RepetitionInfo, @Autowired orderService:OrderService) {\n\n // use orderService from the test's ApplicationContext\n // and repetitionInfo from JUnit Jupiter\n }\n\t}\n----\n======\n\nNote that the use of `@RepeatedTest` from JUnit Jupiter lets the test method gain access\nto the `RepetitionInfo`.\n\n[[testcontext-junit-jupiter-nested-test-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc", "title": "support-classes", "heading": "Method Injection", "heading_level": 4, "file_order": 266, "section_index": 4, "content_hash": "55a3a96f8a183f9a444da62aa1fd73a4366f1373202a68802c63b1bde98400fa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc"}}
{"id": "sha256:57595af1f139b1bfa44aeccfa398b69680ee9c7b786331098a18fb3c48d4e827", "content": "The _Spring TestContext Framework_ supports the use of test-related annotations on `@Nested`\ntest classes in JUnit Jupiter, including first-class support for inheriting test class\nconfiguration from enclosing classes, and such configuration will be inherited by\ndefault. To change from the default `INHERIT` mode to `OVERRIDE` mode, you may annotate\nan individual `@Nested` test class with\n`@NestedTestConfiguration(EnclosingConfiguration.OVERRIDE)`. An explicit\n`@NestedTestConfiguration` declaration will apply to the annotated test class as well as\nany of its subclasses and nested classes. Thus, you may annotate a top-level test class\nwith `@NestedTestConfiguration`, and that will apply to all of its nested test classes\nrecursively.\n\n[NOTE]\n====\nAs of Spring Framework 7.0, the `SpringExtension` uses a test-method scoped\n`ExtensionContext` within `@Nested` test class hierarchies by default. However, the\n`SpringExtension` can be configured to use a test-class scoped `ExtensionContext`.\n\nSee the documentation for\nxref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-springextensionconfig[`@SpringExtensionConfig`]\nfor details.\n====\n\n[TIP]\n====\nIf you are developing a component that integrates with the Spring TestContext Framework\nand needs to support annotation inheritance within enclosing class hierarchies, you must\nuse the annotation search utilities provided in `TestContextAnnotationUtils` in order to\nhonor `@NestedTestConfiguration` semantics.\n====\n\nIn order to allow development teams to change the default to `OVERRIDE` â€“ for example,\nfor compatibility with Spring Framework 5.0 through 5.2 â€“ the default mode can be changed\nglobally via a JVM system property or a `spring.properties` file in the root of the\nclasspath. See the\nxref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-nestedtestconfiguration[\"Changing the default enclosing configuration inheritance mode\"]\nnote for details.\n\nAlthough the following \"Hello World\" example is very simplistic, it shows how to declare\ncommon configuration on a top-level class that is inherited by its `@Nested` test\nclasses. In this particular example, only the `TestConfig` configuration class is\ninherited. Each nested test class provides its own set of active profiles, resulting in a\ndistinct `ApplicationContext` for each nested test class (see\nxref:testing/testcontext-framework/ctx-management/caching.adoc[Context Caching] for details).\nConsult the list of\nxref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-nestedtestconfiguration[supported annotations]\nto see which annotations can be inherited in `@Nested` test classes.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\tclass GreetingServiceTests {\n\n @Nested\n @ActiveProfiles(\"lang_en\")\n class EnglishGreetings {\n\n @Test\n void hello(@Autowired GreetingService service) {\n assertThat(service.greetWorld()).isEqualTo(\"Hello World\");\n }\n }\n\n @Nested\n @ActiveProfiles(\"lang_de\")\n class GermanGreetings {\n\n @Test\n void hello(@Autowired GreetingService service) {\n assertThat(service.greetWorld()).isEqualTo(\"Hallo Welt\");\n }\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig::class)\n\tclass GreetingServiceTests {\n\n @Nested\n @ActiveProfiles(\"lang_en\")\n inner class EnglishGreetings {\n\n @Test\n fun hello(@Autowired service:GreetingService) {\n assertThat(service.greetWorld()).isEqualTo(\"Hello World\")\n }\n }\n\n @Nested\n @ActiveProfiles(\"lang_de\")\n inner class GermanGreetings {\n\n @Test\n fun hello(@Autowired service:GreetingService) {\n assertThat(service.greetWorld()).isEqualTo(\"Hallo Welt\")\n }\n }\n\t}\n----\n======\n\n[[testcontext-junit4-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc", "title": "support-classes", "heading": "`@Nested` test class configuration", "heading_level": 3, "file_order": 266, "section_index": 5, "content_hash": "57595af1f139b1bfa44aeccfa398b69680ee9c7b786331098a18fb3c48d4e827", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc"}}
{"id": "sha256:4996adbd0a30a13453cd2642b86899cd92991ce12a06405aa80218a5fa562086", "content": "[[testcontext-junit4-runner]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc", "title": "support-classes", "heading": "JUnit 4 Support", "heading_level": 2, "file_order": 266, "section_index": 6, "content_hash": "4996adbd0a30a13453cd2642b86899cd92991ce12a06405aa80218a5fa562086", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc"}}
{"id": "sha256:14a53ad2f089d36eab58424e23a3358d2fe689cdb9fbace1436187d408eacfec", "content": "[WARNING]\n====\nJUnit 4 is officially in maintenance mode, and JUnit 4 support in Spring is deprecated\nsince Spring Framework 7.0 in favor of the\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-extension[`SpringExtension`]\nand JUnit Jupiter.\n====\n\nThe Spring TestContext Framework offers full integration with JUnit 4 through a custom\nrunner (supported on JUnit 4.12 or higher). By annotating test classes with\n`@RunWith(SpringJUnit4ClassRunner.class)` or the shorter `@RunWith(SpringRunner.class)`\nvariant, developers can implement standard JUnit 4-based unit and integration tests and\nsimultaneously reap the benefits of the TestContext framework, such as support for\nloading application contexts, dependency injection of test instances, transactional test\nmethod execution, and so on. If you want to use the Spring TestContext Framework with an\nalternative runner (such as JUnit 4's `Parameterized` runner) or third-party runners\n(such as the `MockitoJUnitRunner`), you can, optionally, use\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit4-rules[Spring's support for JUnit rules]\ninstead.\n\nThe following code listing shows the minimal requirements for configuring a test class to\nrun with the custom Spring `Runner`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RunWith(SpringRunner.class)\n\t@TestExecutionListeners({})\n\tpublic class SimpleTest {\n\n @Test\n public void testMethod() {\n // test logic...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RunWith(SpringRunner::class)\n\t@TestExecutionListeners\n\tclass SimpleTest {\n\n @Test\n fun testMethod() {\n // test logic...\n }\n\t}\n----\n======\n\nIn the preceding example, `@TestExecutionListeners` is configured with an empty list, to\ndisable the default listeners, which otherwise would require an `ApplicationContext` to\nbe configured through `@ContextConfiguration`.\n\n[[testcontext-junit4-rules]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc", "title": "support-classes", "heading": "Spring JUnit 4 Runner", "heading_level": 3, "file_order": 266, "section_index": 7, "content_hash": "14a53ad2f089d36eab58424e23a3358d2fe689cdb9fbace1436187d408eacfec", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc"}}
{"id": "sha256:e701cf3dd51ba5246f46e82a54eba6a0fd797dc0936595319bd7a89c196d0265", "content": "[WARNING]\n====\nJUnit 4 is officially in maintenance mode, and JUnit 4 support in Spring is deprecated\nsince Spring Framework 7.0 in favor of the\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-extension[`SpringExtension`]\nand JUnit Jupiter.\n====\n\nThe `org.springframework.test.context.junit4.rules` package provides the following JUnit\n4 rules (supported on JUnit 4.12 or higher):\n\n* `SpringClassRule`\n* `SpringMethodRule`\n\n`SpringClassRule` is a JUnit `TestRule` that supports class-level features of the Spring\nTestContext Framework, whereas `SpringMethodRule` is a JUnit `MethodRule` that supports\ninstance-level and method-level features of the Spring TestContext Framework.\n\nIn contrast to the `SpringRunner`, Spring's rule-based JUnit support has the advantage of\nbeing independent of any `org.junit.runner.Runner` implementation and can, therefore, be\ncombined with existing alternative runners (such as JUnit 4's `Parameterized`) or\nthird-party runners (such as the `MockitoJUnitRunner`).\n\nTo support the full functionality of the TestContext framework, you must combine a\n`SpringClassRule` with a `SpringMethodRule`. The following example shows the proper way\nto declare these rules in an integration test:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Optionally specify a non-Spring Runner via @RunWith(...)\n\t@ContextConfiguration\n\tpublic class IntegrationTest {\n\n @ClassRule\n public static final SpringClassRule springClassRule = new SpringClassRule();\n\n @Rule\n public final SpringMethodRule springMethodRule = new SpringMethodRule();\n\n @Test\n public void testMethod() {\n // test logic...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Optionally specify a non-Spring Runner via @RunWith(...)\n\t@ContextConfiguration\n\tclass IntegrationTest {\n\n @Rule\n val springMethodRule = SpringMethodRule()\n\n @Test\n fun testMethod() {\n // test logic...\n }\n\n companion object {\n @ClassRule\n val springClassRule = SpringClassRule()\n }\n\t}\n----\n======\n\n[[testcontext-support-classes-junit4]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc", "title": "support-classes", "heading": "Spring JUnit 4 Rules", "heading_level": 3, "file_order": 266, "section_index": 8, "content_hash": "e701cf3dd51ba5246f46e82a54eba6a0fd797dc0936595319bd7a89c196d0265", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc"}}
{"id": "sha256:894ba270080f048d85d8502b19639fe806333d3a1106907e7141b62d0759b1fb", "content": "[WARNING]\n====\nJUnit 4 is officially in maintenance mode, and JUnit 4 support in Spring is deprecated\nsince Spring Framework 7.0 in favor of the\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-extension[`SpringExtension`]\nand JUnit Jupiter.\n====\n\nThe `org.springframework.test.context.junit4` package provides the following support\nclasses for JUnit 4-based test cases (supported on JUnit 4.12 or higher):\n\n* `AbstractJUnit4SpringContextTests`\n* `AbstractTransactionalJUnit4SpringContextTests`\n\n`AbstractJUnit4SpringContextTests` is an abstract base test class that integrates the\nSpring TestContext Framework with explicit `ApplicationContext` testing support in a\nJUnit 4 environment. When you extend `AbstractJUnit4SpringContextTests`, you can access a\n`protected` `applicationContext` instance variable that you can use to perform explicit\nbean lookups or to test the state of the context as a whole.\n\n`AbstractTransactionalJUnit4SpringContextTests` is an abstract transactional extension of\n`AbstractJUnit4SpringContextTests` that adds some convenience functionality for JDBC\naccess. This class expects a `javax.sql.DataSource` bean and a\n`PlatformTransactionManager` bean to be defined in the `ApplicationContext`. When you\nextend `AbstractTransactionalJUnit4SpringContextTests`, you can access a `protected`\n`jdbcTemplate` instance variable that you can use to run SQL statements to query the\ndatabase. You can use such queries to confirm database state both before and after\nrunning database-related application code, and Spring ensures that such queries run in\nthe scope of the same transaction as the application code. When used in conjunction with\nan ORM tool, be sure to avoid\nxref:testing/testcontext-framework/tx.adoc#testcontext-tx-false-positives[false positives].\nAs mentioned in xref:testing/support-jdbc.adoc[JDBC Testing Support],\n`AbstractTransactionalJUnit4SpringContextTests` also provides convenience methods that\ndelegate to methods in `JdbcTestUtils` by using the aforementioned `jdbcTemplate`.\nFurthermore, `AbstractTransactionalJUnit4SpringContextTests` provides an\n`executeSqlScript(..)` method for running SQL scripts against the configured `DataSource`.\n\nTIP: These classes are a convenience for extension. If you do not want your test classes\nto be tied to a Spring-specific class hierarchy, you can configure your own custom test\nclasses by using `@RunWith(SpringRunner.class)` or\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit4-rules[Spring's JUnit rules].\n\n[[testcontext-support-classes-testng]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc", "title": "support-classes", "heading": "JUnit 4 Base Classes", "heading_level": 3, "file_order": 266, "section_index": 9, "content_hash": "894ba270080f048d85d8502b19639fe806333d3a1106907e7141b62d0759b1fb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc"}}
{"id": "sha256:a33742876ceea76e2aef6be26084e301575aa277abd1e7e4a02d5d53b30a779d", "content": "The `org.springframework.test.context.testng` package provides the following support\nclasses for TestNG based test cases:\n\n* `AbstractTestNGSpringContextTests`\n* `AbstractTransactionalTestNGSpringContextTests`\n\n`AbstractTestNGSpringContextTests` is an abstract base test class that integrates the\nSpring TestContext Framework with explicit `ApplicationContext` testing support in a\nTestNG environment. When you extend `AbstractTestNGSpringContextTests`, you can access a\n`protected` `applicationContext` instance variable that you can use to perform explicit\nbean lookups or to test the state of the context as a whole.\n\n`AbstractTransactionalTestNGSpringContextTests` is an abstract transactional extension of\n`AbstractTestNGSpringContextTests` that adds some convenience functionality for JDBC\naccess. This class expects a `javax.sql.DataSource` bean and a\n`PlatformTransactionManager` bean to be defined in the `ApplicationContext`. When you\nextend `AbstractTransactionalTestNGSpringContextTests`, you can access a `protected`\n`jdbcTemplate` instance variable that you can use to run SQL statements to query the\ndatabase. You can use such queries to confirm database state both before and after\nrunning database-related application code, and Spring ensures that such queries run in\nthe scope of the same transaction as the application code. When used in conjunction with\nan ORM tool, be sure to avoid\nxref:testing/testcontext-framework/tx.adoc#testcontext-tx-false-positives[false positives].\nAs mentioned in xref:testing/support-jdbc.adoc[JDBC Testing Support],\n`AbstractTransactionalTestNGSpringContextTests` also provides convenience methods that\ndelegate to methods in `JdbcTestUtils` by using the aforementioned `jdbcTemplate`.\nFurthermore, `AbstractTransactionalTestNGSpringContextTests` provides an\n`executeSqlScript(..)` method for running SQL scripts against the configured `DataSource`.\n\nTIP: These classes are a convenience for extension. If you do not want your test classes\nto be tied to a Spring-specific class hierarchy, you can configure your own custom test\nclasses by using `@ContextConfiguration`, `@TestExecutionListeners`, and so on and by\nmanually instrumenting your test class with a `TestContextManager`. See the source code\nof `AbstractTestNGSpringContextTests` for an example of how to instrument your test class.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc", "title": "support-classes", "heading": "TestNG Support", "heading_level": 2, "file_order": 266, "section_index": 10, "content_hash": "a33742876ceea76e2aef6be26084e301575aa277abd1e7e4a02d5d53b30a779d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/support-classes.adoc"}}
{"id": "sha256:b57ac594caf271c7b221bc0ae64b150059f56fb6f0edb674ff7fc78927292a55", "content": "[[testcontext-tel-config]]\n\nSpring provides the following `TestExecutionListener` implementations that are registered\nby default, exactly in the following order:\n\n* `ServletTestExecutionListener`: Configures Servlet API mocks for a\n `WebApplicationContext`.\n* `DirtiesContextBeforeModesTestExecutionListener`: Handles the `@DirtiesContext`\n annotation for \"before\" modes.\n* `ApplicationEventsTestExecutionListener`: Provides support for\n xref:testing/testcontext-framework/application-events.adoc[`ApplicationEvents`].\n* `BeanOverrideTestExecutionListener`: Provides support for\n xref:testing/testcontext-framework/bean-overriding.adoc[].\n* `DependencyInjectionTestExecutionListener`: Provides dependency injection for the test\n instance.\n* `MicrometerObservationRegistryTestExecutionListener`: Provides support for\n Micrometer's `ObservationRegistry`.\n* `DirtiesContextTestExecutionListener`: Handles the `@DirtiesContext` annotation for\n \"after\" modes.\n* `CommonCachesTestExecutionListener`: Clears resource caches in the test's\n `ApplicationContext` if necessary.\n* `TransactionalTestExecutionListener`: Provides transactional test execution with\n default rollback semantics.\n* `SqlScriptsTestExecutionListener`: Runs SQL scripts configured by using the `@Sql`\n annotation.\n* `EventPublishingTestExecutionListener`: Publishes test execution events to the test's\n `ApplicationContext` (see xref:testing/testcontext-framework/test-execution-events.adoc[Test Execution Events]).\n* `MockitoResetTestExecutionListener`: Resets mocks as configured by `@MockitoBean` or `@MockitoSpyBean`.\n\n[[testcontext-tel-config-registering-tels]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tel-config.adoc", "title": "tel-config", "heading": "tel-config", "heading_level": 1, "file_order": 267, "section_index": 0, "content_hash": "b57ac594caf271c7b221bc0ae64b150059f56fb6f0edb674ff7fc78927292a55", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tel-config.adoc"}}
{"id": "sha256:db5aaadda791ee9f5946a2c648415ff21db85afc67e1043331e7c19d56fabda2", "content": "You can register `TestExecutionListener` implementations explicitly for a test class, its\nsubclasses, and its nested classes by using the `@TestExecutionListeners` annotation. See\nxref:testing/annotations.adoc[annotation support] and the javadoc for\n{spring-framework-api}/test/context/TestExecutionListeners.html[`@TestExecutionListeners`]\nfor details and examples.\n\n.Switching to default `TestExecutionListener` implementations\n[NOTE]\n====\nIf you extend a class that is annotated with `@TestExecutionListeners` and you need to\nswitch to using the default set of listeners, you can annotate your class with the\nfollowing.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Switch to default listeners\n\t@TestExecutionListeners(\n listeners = {},\n inheritListeners = false,\n mergeMode = MERGE_WITH_DEFAULTS)\n\tclass MyTest extends BaseTest {\n // class body...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Switch to default listeners\n\t@TestExecutionListeners(\n listeners = [],\n inheritListeners = false,\n mergeMode = MERGE_WITH_DEFAULTS)\n\tclass MyTest : BaseTest {\n // class body...\n\t}\n----\n======\n====\n\n[[testcontext-tel-config-automatic-discovery]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tel-config.adoc", "title": "tel-config", "heading": "Registering `TestExecutionListener` Implementations", "heading_level": 2, "file_order": 267, "section_index": 1, "content_hash": "db5aaadda791ee9f5946a2c648415ff21db85afc67e1043331e7c19d56fabda2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tel-config.adoc"}}
{"id": "sha256:0147839b37f9bfb3f058a505eeb9fdfd922c5d7beb9fa9723a7af7d74c61a1d8", "content": "Registering `TestExecutionListener` implementations by using `@TestExecutionListeners` is\nsuitable for custom listeners that are used in limited testing scenarios. However, it can\nbecome cumbersome if a custom listener needs to be used across an entire test suite. This\nissue is addressed through support for automatic discovery of default\n`TestExecutionListener` implementations through the `SpringFactoriesLoader` mechanism.\n\nFor example, the `spring-test` module declares all core default `TestExecutionListener`\nimplementations under the `org.springframework.test.context.TestExecutionListener` key in\nits {spring-framework-code}/spring-test/src/main/resources/META-INF/spring.factories[`META-INF/spring.factories`\nproperties file]. Third-party frameworks and developers can contribute their own\n`TestExecutionListener` implementations to the list of default listeners in the same\nmanner through their own `spring.factories` files.\n\n[[testcontext-tel-config-ordering]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tel-config.adoc", "title": "tel-config", "heading": "Automatic Discovery of Default `TestExecutionListener` Implementations", "heading_level": 2, "file_order": 267, "section_index": 2, "content_hash": "0147839b37f9bfb3f058a505eeb9fdfd922c5d7beb9fa9723a7af7d74c61a1d8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tel-config.adoc"}}
{"id": "sha256:b5e0b84510bf5568d3aa99494cf68847dbbcf1fce347a8a1f6ea40171f8fde72", "content": "When the TestContext framework discovers default `TestExecutionListener` implementations\nthrough the xref:testing/testcontext-framework/tel-config.adoc#testcontext-tel-config-automatic-discovery[aforementioned]\n`SpringFactoriesLoader` mechanism, the instantiated listeners are sorted by using\nSpring's `AnnotationAwareOrderComparator`, which honors Spring's `Ordered` interface and\n`@Order` annotation for ordering. `AbstractTestExecutionListener` and all default\n`TestExecutionListener` implementations provided by Spring implement `Ordered` with\nappropriate values. Third-party frameworks and developers should therefore make sure that\ntheir default `TestExecutionListener` implementations are registered in the proper order\nby implementing `Ordered` or declaring `@Order`. See the javadoc for the `getOrder()`\nmethods of the core default `TestExecutionListener` implementations for details on what\nvalues are assigned to each core listener.\n\n[[testcontext-tel-config-merging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tel-config.adoc", "title": "tel-config", "heading": "Ordering `TestExecutionListener` Implementations", "heading_level": 2, "file_order": 267, "section_index": 3, "content_hash": "b5e0b84510bf5568d3aa99494cf68847dbbcf1fce347a8a1f6ea40171f8fde72", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tel-config.adoc"}}
{"id": "sha256:876fb6daa1a6493c457c487363409ccb0b80b5c2c818c1b3e5a37171faf9bcad", "content": "If a custom `TestExecutionListener` is registered via `@TestExecutionListeners`, the\ndefault listeners are not registered. In most common testing scenarios, this effectively\nforces the developer to manually declare all default listeners in addition to any custom\nlisteners. The following listing demonstrates this style of configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestExecutionListeners({\n MyCustomTestExecutionListener.class,\n ServletTestExecutionListener.class,\n DirtiesContextBeforeModesTestExecutionListener.class,\n DependencyInjectionTestExecutionListener.class,\n DirtiesContextTestExecutionListener.class,\n TransactionalTestExecutionListener.class,\n SqlScriptsTestExecutionListener.class\n\t})\n\tclass MyTest {\n // class body...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestExecutionListeners(\n MyCustomTestExecutionListener::class,\n ServletTestExecutionListener::class,\n DirtiesContextBeforeModesTestExecutionListener::class,\n DependencyInjectionTestExecutionListener::class,\n DirtiesContextTestExecutionListener::class,\n TransactionalTestExecutionListener::class,\n SqlScriptsTestExecutionListener::class\n\t)\n\tclass MyTest {\n // class body...\n\t}\n----\n======\n\nThe challenge with this approach is that it requires that the developer know exactly\nwhich listeners are registered by default. Moreover, the set of default listeners can\nchange from release to release -- for example, `SqlScriptsTestExecutionListener` was\nintroduced in Spring Framework 4.1, and `DirtiesContextBeforeModesTestExecutionListener`\nwas introduced in Spring Framework 4.2. Furthermore, third-party frameworks like Spring\nBoot and Spring Security register their own default `TestExecutionListener`\nimplementations by using the aforementioned\nxref:testing/testcontext-framework/tel-config.adoc#testcontext-tel-config-automatic-discovery[automatic discovery mechanism].\n\nTo avoid having to be aware of and re-declare all default listeners, you can set the\n`mergeMode` attribute of `@TestExecutionListeners` to `MergeMode.MERGE_WITH_DEFAULTS`.\n`MERGE_WITH_DEFAULTS` indicates that locally declared listeners should be merged with the\ndefault listeners. The merging algorithm ensures that duplicates are removed from the\nlist and that the resulting set of merged listeners is sorted according to the semantics\nof `AnnotationAwareOrderComparator`, as described in\nxref:testing/testcontext-framework/tel-config.adoc#testcontext-tel-config-ordering[Ordering `TestExecutionListener` Implementations].\nIf a listener implements `Ordered` or is annotated with `@Order`, it can influence the\nposition in which it is merged with the defaults. Otherwise, locally declared listeners\nare appended to the list of default listeners when merged.\n\nFor example, if the `MyCustomTestExecutionListener` class in the previous example\nconfigures its `order` value (for example, `500`) to be less than the order of the\n`ServletTestExecutionListener` (which happens to be `1000`), the\n`MyCustomTestExecutionListener` can then be automatically merged with the list of\ndefaults in front of the `ServletTestExecutionListener`, and the previous example could\nbe replaced with the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestExecutionListeners(\n listeners = MyCustomTestExecutionListener.class,\n mergeMode = MERGE_WITH_DEFAULTS\n\t)\n\tclass MyTest {\n // class body...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration\n\t@TestExecutionListeners(\n listeners = [MyCustomTestExecutionListener::class],\n mergeMode = MERGE_WITH_DEFAULTS\n\t)\n\tclass MyTest {\n // class body...\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tel-config.adoc", "title": "tel-config", "heading": "Merging `TestExecutionListener` Implementations", "heading_level": 2, "file_order": 267, "section_index": 4, "content_hash": "876fb6daa1a6493c457c487363409ccb0b80b5c2c818c1b3e5a37171faf9bcad", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tel-config.adoc"}}
{"id": "sha256:21fea2c14b9aa176f2473103268291d7114a62088402e2bba45a441307a76391", "content": "[[testcontext-test-execution-events]]\n\nThe `EventPublishingTestExecutionListener` offers an alternative approach to implementing\na custom `TestExecutionListener`. Components in the test's `ApplicationContext` can\nlisten to the following events published by the\n`EventPublishingTestExecutionListener`, each of which corresponds to a method in the\n`TestExecutionListener` API.\n\n* `BeforeTestClassEvent`\n* `PrepareTestInstanceEvent`\n* `BeforeTestMethodEvent`\n* `BeforeTestExecutionEvent`\n* `AfterTestExecutionEvent`\n* `AfterTestMethodEvent`\n* `AfterTestClassEvent`\n\nThese events may be consumed for various reasons, such as resetting mock beans or tracing\ntest execution. One advantage of consuming test execution events rather than implementing\na custom `TestExecutionListener` is that test execution events may be consumed by any\nSpring bean registered in the test `ApplicationContext`, and such beans may benefit\ndirectly from dependency injection and other features of the `ApplicationContext`. In\ncontrast, a `TestExecutionListener` is not a bean in the `ApplicationContext`.\n\n[NOTE]\n====\nThe `EventPublishingTestExecutionListener` is registered by default; however, it only\npublishes events if the `ApplicationContext` has _already been loaded_. This prevents the\n`ApplicationContext` from being loaded unnecessarily or too early.\n\nConsequently, a `BeforeTestClassEvent` will not be published until after the\n`ApplicationContext` has been loaded by another `TestExecutionListener`. For example, with\nthe default set of `TestExecutionListener` implementations registered, a\n`BeforeTestClassEvent` will not be published for the first test class that uses a\nparticular test `ApplicationContext`, but a `BeforeTestClassEvent` _will_ be published for\nany subsequent test class in the same test suite that uses the same test\n`ApplicationContext` since the context will already have been loaded when subsequent test\nclasses run (as long as the context has not been removed from the `ContextCache` via\n`@DirtiesContext` or the max-size eviction policy).\n\nIf you wish to ensure that a `BeforeTestClassEvent` is always published for every test\nclass, you need to register a `TestExecutionListener` that loads the `ApplicationContext`\nin the `beforeTestClass` callback, and that `TestExecutionListener` must be registered\n_before_ the `EventPublishingTestExecutionListener`.\n\nSimilarly, if `@DirtiesContext` is used to remove the `ApplicationContext` from the\ncontext cache after the last test method in a given test class, the `AfterTestClassEvent`\nwill not be published for that test class.\n====\n\nIn order to listen to test execution events, a Spring bean may choose to implement the\n`org.springframework.context.ApplicationListener` interface. Alternatively, listener\nmethods can be annotated with `@EventListener` and configured to listen to one of the\nparticular event types listed above (see\nxref:core/beans/context-introduction.adoc#context-functionality-events-annotation[Annotation-based Event Listeners]).\nDue to the popularity of this approach, Spring provides the following dedicated\n`@EventListener` annotations to simplify registration of test execution event listeners.\nThese annotations reside in the `org.springframework.test.context.event.annotation`\npackage.\n\n* `@BeforeTestClass`\n* `@PrepareTestInstance`\n* `@BeforeTestMethod`\n* `@BeforeTestExecution`\n* `@AfterTestExecution`\n* `@AfterTestMethod`\n* `@AfterTestClass`\n\n[[testcontext-test-execution-events-exception-handling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/test-execution-events.adoc", "title": "test-execution-events", "heading": "test-execution-events", "heading_level": 1, "file_order": 268, "section_index": 0, "content_hash": "21fea2c14b9aa176f2473103268291d7114a62088402e2bba45a441307a76391", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/test-execution-events.adoc"}}
{"id": "sha256:5df1aa02f28bf35cfa5402794391912b930481df56d015c65a0b5633183e61af", "content": "By default, if a test execution event listener throws an exception while consuming an\nevent, that exception will propagate to the underlying testing framework in use (such as\nJUnit or TestNG). For example, if the consumption of a `BeforeTestMethodEvent` results in\nan exception, the corresponding test method will fail as a result of the exception. In\ncontrast, if an asynchronous test execution event listener throws an exception, the\nexception will not propagate to the underlying testing framework. For further details on\nasynchronous exception handling, consult the class-level javadoc for `@EventListener`.\n\n[[testcontext-test-execution-events-async]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/test-execution-events.adoc", "title": "test-execution-events", "heading": "Exception Handling", "heading_level": 2, "file_order": 268, "section_index": 1, "content_hash": "5df1aa02f28bf35cfa5402794391912b930481df56d015c65a0b5633183e61af", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/test-execution-events.adoc"}}
{"id": "sha256:e88d4afe82132f6d4ca7827a6220ab0e3361f13a6fe1d810296faa1efe9566a0", "content": "If you want a particular test execution event listener to process events asynchronously,\nyou can use Spring's\nxref:integration/scheduling.adoc#scheduling-annotation-support-async[regular `@Async` support].\nFor further details, consult the class-level javadoc for `@EventListener`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/test-execution-events.adoc", "title": "test-execution-events", "heading": "Asynchronous Listeners", "heading_level": 2, "file_order": 268, "section_index": 2, "content_hash": "e88d4afe82132f6d4ca7827a6220ab0e3361f13a6fe1d810296faa1efe9566a0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/test-execution-events.adoc"}}
{"id": "sha256:7bbfc29fb0ba0549de16e7bef3a175217041c5068dc19348e764d5c539c0f5f7", "content": "[[testcontext-tx]]\n\nIn the TestContext framework, transactions are managed by the\n`TransactionalTestExecutionListener`, which is configured by default, even if you do not\nexplicitly declare `@TestExecutionListeners` on your test class. To enable support for\ntransactions, however, you must configure a `PlatformTransactionManager` bean in the\n`ApplicationContext` that is loaded with `@ContextConfiguration` semantics (further\ndetails are provided later). In addition, you must declare Spring's `@Transactional`\nannotation either at the class or the method level for your tests.\n\n[[testcontext-tx-test-managed-transactions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc", "title": "tx", "heading": "tx", "heading_level": 1, "file_order": 269, "section_index": 0, "content_hash": "7bbfc29fb0ba0549de16e7bef3a175217041c5068dc19348e764d5c539c0f5f7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc"}}
{"id": "sha256:4b62e199e41123d8ba22ed26189e32700b341664ce68e50253fad0489d506566", "content": "Test-managed transactions are transactions that are managed declaratively by using the\n`TransactionalTestExecutionListener` or programmatically by using `TestTransaction`\n(described later). You should not confuse such transactions with Spring-managed\ntransactions (those managed directly by Spring within the `ApplicationContext` loaded for\ntests) or application-managed transactions (those managed programmatically within\napplication code that is invoked by tests). Spring-managed and application-managed\ntransactions typically participate in test-managed transactions. However, you should use\ncaution if Spring-managed or application-managed transactions are configured with any\npropagation type other than `REQUIRED` or `SUPPORTS` (see the discussion on\nxref:data-access/transaction/declarative/tx-propagation.adoc[transaction propagation] for details).\n\n.Preemptive timeouts and test-managed transactions\n[WARNING]\n====\nCaution must be taken when using any form of preemptive timeouts from a testing framework\nin conjunction with Spring's test-managed transactions.\n\nSpecifically, Springâ€™s testing support binds transaction state to the current thread (via\na `java.lang.ThreadLocal` variable) _before_ the current test method is invoked. If a\ntesting framework invokes the current test method in a new thread in order to support a\npreemptive timeout, any actions performed within the current test method will _not_ be\ninvoked within the test-managed transaction. Consequently, the result of any such actions\nwill not be rolled back with the test-managed transaction. On the contrary, such actions\nwill be committed to the persistent store -- for example, a relational database -- even\nthough the test-managed transaction is properly rolled back by Spring.\n\nSituations in which this can occur include but are not limited to the following.\n\n* JUnit 4's `@Test(timeout = ...)` support and `TimeOut` rule\n* JUnit Jupiter's `assertTimeoutPreemptively(...)` methods in the\n `org.junit.jupiter.api.Assertions` class\n* TestNG's `@Test(timeOut = ...)` support\n====\n\n[[testcontext-tx-enabling-transactions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc", "title": "tx", "heading": "Test-managed Transactions", "heading_level": 2, "file_order": 269, "section_index": 1, "content_hash": "4b62e199e41123d8ba22ed26189e32700b341664ce68e50253fad0489d506566", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc"}}
{"id": "sha256:4f0efa14b34792e38ce8be339dcc29efe906624db02452af1c922b648d9e6cbe", "content": "Annotating a test method with `@Transactional` causes the test to be run within a\ntransaction that is, by default, automatically rolled back after completion of the test.\nIf a test class is annotated with `@Transactional`, each test method within that class\nhierarchy runs within a transaction. Test methods that are not annotated with\n`@Transactional` (at the class or method level) are not run within a transaction. Note\nthat `@Transactional` is not supported on test lifecycle methods â€” for example, methods\nannotated with JUnit Jupiter's `@BeforeAll`, `@BeforeEach`, etc. Furthermore, tests that\nare annotated with `@Transactional` but have the `propagation` attribute set to\n`NOT_SUPPORTED` or `NEVER` are not run within a transaction.\n\n[[testcontext-tx-attribute-support]]\n.`@Transactional` attribute support\n|===\n|Attribute |Supported for test-managed transactions\n\n|`value` and `transactionManager` |yes\n\n|`propagation` |only `Propagation.NOT_SUPPORTED` and `Propagation.NEVER` are supported\n\n|`isolation` |no\n\n|`timeout` |no\n\n|`readOnly` |no\n\n|`rollbackFor` and `rollbackForClassName` |no: use `TestTransaction.flagForRollback()` instead\n\n|`noRollbackFor` and `noRollbackForClassName` |no: use `TestTransaction.flagForCommit()` instead\n|===\n\n[TIP]\n====\nMethod-level lifecycle methods â€” for example, methods annotated with JUnit Jupiter's\n`@BeforeEach` or `@AfterEach` â€” are run within a test-managed transaction. On the other\nhand, suite-level and class-level lifecycle methods â€” for example, methods annotated with\nJUnit Jupiter's `@BeforeAll` or `@AfterAll` and methods annotated with TestNG's\n`@BeforeSuite`, `@AfterSuite`, `@BeforeClass`, or `@AfterClass` â€” are _not_ run within a\ntest-managed transaction.\n\nIf you need to run code in a suite-level or class-level lifecycle method within a\ntransaction, you may wish to inject a corresponding `PlatformTransactionManager` into\nyour test class and then use that with a `TransactionTemplate` for programmatic\ntransaction management.\n====\n\nNote that xref:testing/testcontext-framework/support-classes.adoc#testcontext-support-classes-junit4[`AbstractTransactionalJUnit4SpringContextTests`]\n and\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-support-classes-testng[`AbstractTransactionalTestNGSpringContextTests`]\nare preconfigured for transactional support at the class level.\n\nThe following example demonstrates a common scenario for writing an integration test for\na Hibernate-based `UserRepository`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig.class)\n\t@Transactional\n\tclass HibernateUserRepositoryTests {\n\n @Autowired\n HibernateUserRepository repository;\n\n @Autowired\n SessionFactory sessionFactory;\n\n JdbcTemplate jdbcTemplate;\n\n @Autowired\n void setDataSource(DataSource dataSource) {\n this.jdbcTemplate = new JdbcTemplate(dataSource);\n }\n\n @Test\n void createUser() {\n // track initial state in test database:\n final int count = countRowsInTable(\"user\");\n\n User user = new User(...);\n repository.save(user);\n\n // Manual flush is required to avoid false positive in test\n sessionFactory.getCurrentSession().flush();\n assertNumUsers(count + 1);\n }\n\n private int countRowsInTable(String tableName) {\n return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName);\n }\n\n private void assertNumUsers(int expected) {\n assertEquals(\"Number of rows in the [user] table.\", expected, countRowsInTable(\"user\"));\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(TestConfig::class)\n\t@Transactional\n\tclass HibernateUserRepositoryTests {\n\n @Autowired\n lateinit var repository: HibernateUserRepository\n\n @Autowired\n lateinit var sessionFactory: SessionFactory\n\n lateinit var jdbcTemplate: JdbcTemplate\n\n @Autowired\n fun setDataSource(dataSource: DataSource) {\n this.jdbcTemplate = JdbcTemplate(dataSource)\n }\n\n @Test\n fun createUser() {\n // track initial state in test database:\n val count = countRowsInTable(\"user\")\n\n val user = User()\n repository.save(user)\n\n // Manual flush is required to avoid false positive in test\n sessionFactory.getCurrentSession().flush()\n assertNumUsers(count + 1)\n }\n\n private fun countRowsInTable(tableName: String): Int {\n return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName)\n }\n\n private fun assertNumUsers(expected: Int) {\n assertEquals(\"Number of rows in the [user] table.\", expected, countRowsInTable(\"user\"))\n }\n\t}\n----\n======\n\nAs explained in xref:testing/testcontext-framework/tx.adoc#testcontext-tx-rollback-and-commit-behavior[Transaction Rollback and Commit Behavior],\nthere is no need to clean up the database after the `createUser()` method runs,\nsince any changes made to the database are automatically rolled back by the\n`TransactionalTestExecutionListener`.\n\n[[testcontext-tx-rollback-and-commit-behavior]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc", "title": "tx", "heading": "Enabling and Disabling Transactions", "heading_level": 2, "file_order": 269, "section_index": 2, "content_hash": "4f0efa14b34792e38ce8be339dcc29efe906624db02452af1c922b648d9e6cbe", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc"}}
{"id": "sha256:b3508d66940017f7fa8fed63071570544562bdbf2372fe7c47e868acf36b532d", "content": "By default, test transactions will be automatically rolled back after completion of the\ntest; however, transactional commit and rollback behavior can be configured declaratively\nvia the `@Commit` and `@Rollback` annotations. See the corresponding entries in the\nxref:testing/annotations.adoc[annotation support] section for further details.\n\n[[testcontext-tx-programmatic-tx-mgt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc", "title": "tx", "heading": "Transaction Rollback and Commit Behavior", "heading_level": 2, "file_order": 269, "section_index": 3, "content_hash": "b3508d66940017f7fa8fed63071570544562bdbf2372fe7c47e868acf36b532d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc"}}
{"id": "sha256:b891e3915722531d32f3c25e8f20e7b3091f9e9889bab0cbca4e9cee4ef2f40f", "content": "You can interact with test-managed transactions programmatically by using the static\nmethods in `TestTransaction`. For example, you can use `TestTransaction` within test\nmethods, before methods, and after methods to start or end the current test-managed\ntransaction or to configure the current test-managed transaction for rollback or commit.\nSupport for `TestTransaction` is automatically available whenever the\n`TransactionalTestExecutionListener` is enabled.\n\nThe following example demonstrates some of the features of `TestTransaction`. See the\njavadoc for {spring-framework-api}/test/context/transaction/TestTransaction.html[`TestTransaction`]\nfor further details.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration(classes = TestConfig.class)\n\tpublic class ProgrammaticTransactionManagementTests extends\n AbstractTransactionalJUnit4SpringContextTests {\n\n @Test\n public void transactionalTest() {\n // assert initial state in test database:\n assertNumUsers(2);\n\n deleteFromTables(\"user\");\n\n // changes to the database will be committed!\n TestTransaction.flagForCommit();\n TestTransaction.end();\n assertFalse(TestTransaction.isActive());\n assertNumUsers(0);\n\n TestTransaction.start();\n // perform other actions against the database that will\n // be automatically rolled back after the test completes...\n }\n\n protected void assertNumUsers(int expected) {\n assertEquals(\"Number of rows in the [user] table.\", expected, countRowsInTable(\"user\"));\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ContextConfiguration(classes = [TestConfig::class])\n\tclass ProgrammaticTransactionManagementTests : AbstractTransactionalJUnit4SpringContextTests() {\n\n @Test\n fun transactionalTest() {\n // assert initial state in test database:\n assertNumUsers(2)\n\n deleteFromTables(\"user\")\n\n // changes to the database will be committed!\n TestTransaction.flagForCommit()\n TestTransaction.end()\n assertFalse(TestTransaction.isActive())\n assertNumUsers(0)\n\n TestTransaction.start()\n // perform other actions against the database that will\n // be automatically rolled back after the test completes...\n }\n\n protected fun assertNumUsers(expected: Int) {\n assertEquals(\"Number of rows in the [user] table.\", expected, countRowsInTable(\"user\"))\n }\n\t}\n----\n======\n\n[[testcontext-tx-before-and-after-tx]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc", "title": "tx", "heading": "Programmatic Transaction Management", "heading_level": 2, "file_order": 269, "section_index": 4, "content_hash": "b891e3915722531d32f3c25e8f20e7b3091f9e9889bab0cbca4e9cee4ef2f40f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc"}}
{"id": "sha256:075adcbf73212c05733cf5e59e49c01cd994a73f8ce91f7943a7f664a1b8a01f", "content": "Occasionally, you may need to run certain code before or after a transactional test\nmethod but outside the transactional context -- for example, to verify the initial\ndatabase state prior to running your test or to verify expected transactional commit\nbehavior after your test runs (if the test was configured to commit the transaction).\n`TransactionalTestExecutionListener` supports the `@BeforeTransaction` and\n`@AfterTransaction` annotations for exactly such scenarios. You can annotate any `void`\nmethod in a test class or any `void` default method in a test interface with one of these\nannotations, and the `TransactionalTestExecutionListener` ensures that your\nbefore-transaction method or after-transaction method runs at the appropriate time.\n\n[NOTE]\n====\nGenerally speaking, `@BeforeTransaction` and `@AfterTransaction` methods must not accept\nany arguments.\n\nHowever, for tests using the\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-junit-jupiter-extension[`SpringExtension`]\nwith JUnit Jupiter, `@BeforeTransaction` and `@AfterTransaction` methods may optionally\naccept arguments which will be resolved by any registered JUnit `ParameterResolver`\nextension such as the `SpringExtension`. This means that JUnit-specific arguments like\n`TestInfo` or beans from the test's `ApplicationContext` may be provided to\n`@BeforeTransaction` and `@AfterTransaction` methods, as demonstrated in the following\nexample.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n@BeforeTransaction\nvoid verifyInitialDatabaseState(@Autowired DataSource dataSource) {\n\t// Use the DataSource to verify the initial state before a transaction is started\n}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n@BeforeTransaction\nfun verifyInitialDatabaseState(@Autowired dataSource: DataSource) {\n\t// Use the DataSource to verify the initial state before a transaction is started\n}\n----\n======\n====\n\n[TIP]\n====\nAny before methods (such as methods annotated with JUnit Jupiter's `@BeforeEach`) and any\nafter methods (such as methods annotated with JUnit Jupiter's `@AfterEach`) are run\nwithin the test-managed transaction for a transactional test method.\n\nSimilarly, methods annotated with `@BeforeTransaction` or `@AfterTransaction` are only\nrun for transactional test methods.\n====\n\n[[testcontext-tx-mgr-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc", "title": "tx", "heading": "Running Code Outside of a Transaction", "heading_level": 2, "file_order": 269, "section_index": 5, "content_hash": "075adcbf73212c05733cf5e59e49c01cd994a73f8ce91f7943a7f664a1b8a01f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc"}}
{"id": "sha256:d2435e8c305a1b4e1af5f2837a88a0b83607191325877980199d5d95018dd92c", "content": "`TransactionalTestExecutionListener` expects a `PlatformTransactionManager` bean to be\ndefined in the Spring `ApplicationContext` for the test. If there are multiple instances\nof `PlatformTransactionManager` within the test's `ApplicationContext`, you can declare a\nqualifier by using `@Transactional(\"myTxMgr\")` or `@Transactional(transactionManager =\n\"myTxMgr\")`, or `TransactionManagementConfigurer` can be implemented by an\n`@Configuration` class. Consult the\n{spring-framework-api}/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager(org.springframework.test.context.TestContext,java.lang.String)[javadoc\nfor `TestContextTransactionUtils.retrieveTransactionManager()`] for details on the\nalgorithm used to look up a transaction manager in the test's `ApplicationContext`.\n\n[[testcontext-tx-annotation-demo]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc", "title": "tx", "heading": "Configuring a Transaction Manager", "heading_level": 2, "file_order": 269, "section_index": 6, "content_hash": "d2435e8c305a1b4e1af5f2837a88a0b83607191325877980199d5d95018dd92c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc"}}
{"id": "sha256:9fdd095bcba723b50e5afb2953d03955ac24c3fed67622d189f25d36e8f0856b", "content": "The following JUnit Jupiter based example displays a fictitious integration testing\nscenario that highlights all transaction-related annotations. The example is not intended\nto demonstrate best practices but rather to demonstrate how these annotations can be\nused. See the xref:testing/annotations.adoc[annotation support] section for further\ninformation and configuration examples. xref:testing/testcontext-framework/executing-sql.adoc#testcontext-executing-sql-declaratively-tx[Transaction management for `@Sql`]\n contains an additional example that uses `@Sql` for\ndeclarative SQL script execution with default transaction rollback semantics. The\nfollowing example shows the relevant annotations:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig\n\t@Transactional(transactionManager = \"txMgr\")\n\t@Commit\n\tclass FictitiousTransactionalTest {\n\n @BeforeTransaction\n void verifyInitialDatabaseState() {\n // logic to verify the initial state before a transaction is started\n }\n\n @BeforeEach\n void setUpTestDataWithinTransaction() {\n // set up test data within the transaction\n }\n\n @Test\n // overrides the class-level @Commit setting\n @Rollback\n void modifyDatabaseWithinTransaction() {\n // logic which uses the test data and modifies database state\n }\n\n @AfterEach\n void tearDownWithinTransaction() {\n // run \"tear down\" logic within the transaction\n }\n\n @AfterTransaction\n void verifyFinalDatabaseState() {\n // logic to verify the final state after transaction has rolled back\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig\n\t@Transactional(transactionManager = \"txMgr\")\n\t@Commit\n\tclass FictitiousTransactionalTest {\n\n @BeforeTransaction\n fun verifyInitialDatabaseState() {\n // logic to verify the initial state before a transaction is started\n }\n\n @BeforeEach\n fun setUpTestDataWithinTransaction() {\n // set up test data within the transaction\n }\n\n @Test\n // overrides the class-level @Commit setting\n @Rollback\n fun modifyDatabaseWithinTransaction() {\n // logic which uses the test data and modifies database state\n }\n\n @AfterEach\n fun tearDownWithinTransaction() {\n // run \"tear down\" logic within the transaction\n }\n\n @AfterTransaction\n fun verifyFinalDatabaseState() {\n // logic to verify the final state after transaction has rolled back\n }\n\n\t}\n----\n======\n\n[[testcontext-tx-false-positives]]\n.Avoid false positives when testing ORM code\n[NOTE]\n=====\nWhen you test application code that manipulates the state of a Hibernate session or JPA\npersistence context, make sure to flush the underlying unit of work within test methods\nthat run that code. Failing to flush the underlying unit of work can produce false\npositives: Your test passes, but the same code throws an exception in a live, production\nenvironment. Note that this applies to any ORM framework that maintains an in-memory unit\nof work. In the following Hibernate-based example test case, one method demonstrates a\nfalse positive, and the other method correctly exposes the results of flushing the\nsession:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// ...\n\n\t@Autowired\n\tSessionFactory sessionFactory;\n\n\t@Transactional\n\t@Test // no expected exception!\n\tpublic void falsePositive() {\n updateEntityInHibernateSession();\n // False positive: an exception will be thrown once the Hibernate\n // Session is finally flushed (i.e., in production code)\n\t}\n\n\t@Transactional\n\t@Test(expected = ...)\n\tpublic void updateWithSessionFlush() {\n updateEntityInHibernateSession();\n // Manual flush is required to avoid false positive in test\n sessionFactory.getCurrentSession().flush();\n\t}\n\n\t// ...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// ...\n\n\t@Autowired\n\tlateinit var sessionFactory: SessionFactory\n\n\t@Transactional\n\t@Test // no expected exception!\n\tfun falsePositive() {\n updateEntityInHibernateSession()\n // False positive: an exception will be thrown once the Hibernate\n // Session is finally flushed (i.e., in production code)\n\t}\n\n\t@Transactional\n\t@Test(expected = ...)\n\tfun updateWithSessionFlush() {\n updateEntityInHibernateSession()\n // Manual flush is required to avoid false positive in test\n sessionFactory.getCurrentSession().flush()\n\t}\n\n\t// ...\n----\n======\n\nThe following example shows matching methods for JPA:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// ...\n\n\t@PersistenceContext\n\tEntityManager entityManager;\n\n\t@Transactional\n\t@Test // no expected exception!\n\tpublic void falsePositive() {\n updateEntityInJpaPersistenceContext();\n // False positive: an exception will be thrown once the JPA\n // EntityManager is finally flushed (i.e., in production code)\n\t}\n\n\t@Transactional\n\t@Test(expected = ...)\n\tpublic void updateWithEntityManagerFlush() {\n updateEntityInJpaPersistenceContext();\n // Manual flush is required to avoid false positive in test\n entityManager.flush();\n\t}\n\n\t// ...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// ...\n\n\t@PersistenceContext\n\tlateinit var entityManager:EntityManager\n\n\t@Transactional\n\t@Test // no expected exception!\n\tfun falsePositive() {\n updateEntityInJpaPersistenceContext()\n // False positive: an exception will be thrown once the JPA\n // EntityManager is finally flushed (i.e., in production code)\n\t}\n\n\t@Transactional\n\t@Test(expected = ...)\n\tvoid updateWithEntityManagerFlush() {\n updateEntityInJpaPersistenceContext()\n // Manual flush is required to avoid false positive in test\n entityManager.flush()\n\t}\n\n\t// ...\n----\n======\n=====\n\n[[testcontext-tx-orm-lifecycle-callbacks]]\n.Testing ORM entity lifecycle callbacks\n[NOTE]\n=====\nSimilar to the note about avoiding xref:testing/testcontext-framework/tx.adoc#testcontext-tx-false-positives[false positives]\nwhen testing ORM code, if your application makes use of entity lifecycle callbacks (also\nknown as entity listeners), make sure to flush the underlying unit of work within test\nmethods that run that code. Failing to _flush_ or _clear_ the underlying unit of work can\nresult in certain lifecycle callbacks not being invoked.\n\nFor example, when using JPA, `@PostPersist`, `@PreUpdate`, and `@PostUpdate` callbacks\nwill not be called unless `entityManager.flush()` is invoked after an entity has been\nsaved or updated. Similarly, if an entity is already attached to the current unit of work\n(associated with the current persistence context), an attempt to reload the entity will\nnot result in a `@PostLoad` callback unless `entityManager.clear()` is invoked before the\nattempt to reload the entity.\n\nThe following example shows how to flush the `EntityManager` to ensure that\n`@PostPersist` callbacks are invoked when an entity is persisted. An entity listener with\na `@PostPersist` callback method has been registered for the `Person` entity used in the\nexample.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// ...\n\n\t@Autowired\n\tJpaPersonRepository repo;\n\n\t@PersistenceContext\n\tEntityManager entityManager;\n\n\t@Transactional\n\t@Test\n\tvoid savePerson() {\n // EntityManager#persist(...) results in @PrePersist but not @PostPersist\n repo.save(new Person(\"Jane\"));\n\n // Manual flush is required for @PostPersist callback to be invoked\n entityManager.flush();\n\n // Test code that relies on the @PostPersist callback\n // having been invoked...\n\t}\n\n\t// ...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// ...\n\n\t@Autowired\n\tlateinit var repo: JpaPersonRepository\n\n\t@PersistenceContext\n\tlateinit var entityManager: EntityManager\n\n\t@Transactional\n\t@Test\n\tfun savePerson() {\n // EntityManager#persist(...) results in @PrePersist but not @PostPersist\n repo.save(Person(\"Jane\"))\n\n // Manual flush is required for @PostPersist callback to be invoked\n entityManager.flush()\n\n // Test code that relies on the @PostPersist callback\n // having been invoked...\n\t}\n\n\t// ...\n----\n======\n\nSee\n{spring-framework-code}/spring-test/src/test/java/org/springframework/test/context/junit/jupiter/orm/JpaEntityListenerTests.java[JpaEntityListenerTests]\nin the Spring Framework test suite for working examples using all JPA lifecycle callbacks.\n=====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc", "title": "tx", "heading": "Demonstration of All Transaction-related Annotations", "heading_level": 2, "file_order": 269, "section_index": 7, "content_hash": "9fdd095bcba723b50e5afb2953d03955ac24c3fed67622d189f25d36e8f0856b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/tx.adoc"}}
{"id": "sha256:a792d6e0401385cbaafe36b0d839279cd88b2709eb68d3898d1c9dcedbfec771", "content": "[[testcontext-web-scoped-beans]]\n\nSpring has supported xref:core/beans/factory-scopes.adoc#beans-factory-scopes-other[Request- and session-scoped beans]\n since the early years, and you can test your request-scoped and session-scoped\nbeans by following these steps:\n\n* Ensure that a `WebApplicationContext` is loaded for your test by annotating your test\n class with `@WebAppConfiguration`.\n* Inject the mock request or session into your test instance and prepare your test\n fixture as appropriate.\n* Invoke your web component that you retrieved from the configured\n `WebApplicationContext` (with dependency injection).\n* Perform assertions against the mocks.\n\nThe next code snippet shows the XML configuration for a login use case. Note that the\n`userService` bean has a dependency on a request-scoped `loginAction` bean. Also, the\n`LoginAction` is instantiated by using xref:core/expressions.adoc[SpEL expressions] that\nretrieve the username and password from the current HTTP request. In our test, we want to\nconfigure these request parameters through the mock managed by the TestContext framework.\nThe following listing shows the configuration for this use case:\n\n.Request-scoped bean configuration\n[source,xml,indent=0]\n----\n\t<beans>\n\n <bean id=\"userService\" class=\"com.example.SimpleUserService\"\n c:loginAction-ref=\"loginAction\"/>\n\n <bean id=\"loginAction\" class=\"com.example.LoginAction\"\n c:username=\"#{request.getParameter('user')}\"\n c:password=\"#{request.getParameter('pswd')}\"\n scope=\"request\">\n <aop:scoped-proxy/>\n </bean>\n\n\t</beans>\n----\n\nIn `RequestScopedBeanTests`, we inject both the `UserService` (that is, the subject under\ntest) and the `MockHttpServletRequest` into our test instance. Within our\n`requestScope()` test method, we set up our test fixture by setting request parameters in\nthe provided `MockHttpServletRequest`. When the `loginUser()` method is invoked on our\n`userService`, we are assured that the user service has access to the request-scoped\n`loginAction` for the current `MockHttpServletRequest` (that is, the one in which we just\nset parameters). We can then perform assertions against the results based on the known\ninputs for the username and password. The following listing shows how to do so:\n\n.Request-scoped bean test\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig\n\tclass RequestScopedBeanTests {\n\n @Autowired UserService userService;\n @Autowired MockHttpServletRequest request;\n\n @Test\n void requestScope() {\n request.setParameter(\"user\", \"enigma\");\n request.setParameter(\"pswd\", \"$pr!ng\");\n\n LoginResults results = userService.loginUser();\n // assert results\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig\n\tclass RequestScopedBeanTests {\n\n @Autowired lateinit var userService: UserService\n @Autowired lateinit var request: MockHttpServletRequest\n\n @Test\n fun requestScope() {\n request.setParameter(\"user\", \"enigma\")\n request.setParameter(\"pswd\", \"\\$pr!ng\")\n\n val results = userService.loginUser()\n // assert results\n }\n\t}\n----\n======\n\nThe following code snippet is similar to the one we saw earlier for a request-scoped\nbean. However, this time, the `userService` bean has a dependency on a session-scoped\n`userPreferences` bean. Note that the `UserPreferences` bean is instantiated by using a\nSpEL expression that retrieves an attribute from the current HTTP session.\n\n.Session-scoped bean configuration\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<beans>\n\n <bean id=\"userService\" class=\"com.example.SimpleUserService\"\n c:userPreferences-ref=\"userPreferences\" />\n\n <bean id=\"userPreferences\" class=\"com.example.UserPreferences\"\n c:theme=\"#{session.getAttribute('theme')}\"\n scope=\"session\">\n <aop:scoped-proxy/>\n </bean>\n\n\t</beans>\n----\n\nIn `SessionScopedBeanTests`, we inject the `UserService` and the `MockHttpSession` into\nour test instance. Within our `sessionScope()` test method, we set up our test fixture by\nsetting the expected `theme` attribute in the provided `MockHttpSession`. When the\n`processUserPreferences()` method is invoked on our `userService`, we are assured that\nthe user service has access to the session-scoped `userPreferences` for the current\n`MockHttpSession`, and we can perform assertions against the results based on the\nconfigured theme. The following example shows how to do so:\n\n.Session-scoped bean test\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig\n\tclass SessionScopedBeanTests {\n\n @Autowired UserService userService;\n @Autowired MockHttpSession session;\n\n @Test\n void sessionScope() throws Exception {\n session.setAttribute(\"theme\", \"blue\");\n\n Results results = userService.processUserPreferences();\n // assert results\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitWebConfig\n\tclass SessionScopedBeanTests {\n\n @Autowired lateinit var userService: UserService\n @Autowired lateinit var session: MockHttpSession\n\n @Test\n fun sessionScope() {\n session.setAttribute(\"theme\", \"blue\")\n\n val results = userService.processUserPreferences()\n // assert results\n }\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework/web-scoped-beans.adoc", "title": "web-scoped-beans", "heading": "web-scoped-beans", "heading_level": 1, "file_order": 270, "section_index": 0, "content_hash": "a792d6e0401385cbaafe36b0d839279cd88b2709eb68d3898d1c9dcedbfec771", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework/web-scoped-beans.adoc"}}
{"id": "sha256:ba58d087e140deea87579e3b82c0751c5093641df6afbc272f4c69d9d91af5c5", "content": "[[integration-testing-annotations]]\n\nThis section covers annotations that you can use when you test Spring applications.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/annotations.adoc", "title": "annotations", "heading": "annotations", "heading_level": 1, "file_order": 271, "section_index": 0, "content_hash": "ba58d087e140deea87579e3b82c0751c5093641df6afbc272f4c69d9d91af5c5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/annotations.adoc"}}
{"id": "sha256:5cd0bd11859cff2ffe32c1f672fcf6efe1c3dedb32d58adf5214961928ee1116", "content": "[[appendix]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/appendix.adoc", "title": "appendix", "heading": "appendix", "heading_level": 1, "file_order": 272, "section_index": 0, "content_hash": "5cd0bd11859cff2ffe32c1f672fcf6efe1c3dedb32d58adf5214961928ee1116", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/appendix.adoc"}}
{"id": "sha256:beb3faeb16408b9782c7e6bd11abe131f01f45b6688319b43d812de537228f9f", "content": "[[integration-testing]]\n\nIt is important to be able to perform some integration testing without requiring\ndeployment to your application server or connecting to other enterprise infrastructure.\nDoing so lets you test things such as:\n\n* The correct wiring of your Spring components.\n* Data access using JDBC or an ORM tool.\n ** This can include such things as the correctness of SQL statements, Hibernate queries,\n JPA entity mappings, and so forth.\n\nThe Spring Framework provides first-class support for integration testing in the\n`spring-test` module. The name of the actual JAR file might include the release version,\ndepending on where you get it from (see the\n{spring-framework-wiki}/Spring-Framework-Artifacts[Spring Framework Artifacts] wiki page\nfor details). This library includes the `org.springframework.test` package, which\ncontains valuable classes for integration testing with a Spring container. This testing\ndoes not rely on an application server or other deployment environment. Such tests are\nslower to run than unit tests but much faster than the equivalent Selenium tests or\nremote tests that rely on deployment to an application server.\n\nUnit and integration testing support is provided in the form of the annotation-driven\nxref:testing/testcontext-framework.adoc[Spring TestContext Framework]. The TestContext\nframework is agnostic of the actual testing framework in use, which allows\ninstrumentation of tests in various environments, including JUnit, TestNG, and others.\n\nThe following section provides an overview of the high-level goals of Spring's\nintegration support, and the rest of this chapter then focuses on dedicated topics:\n\n* xref:testing/support-jdbc.adoc[JDBC Testing Support]\n* xref:testing/testcontext-framework.adoc[Spring TestContext Framework]\n* xref:testing/webtestclient.adoc[WebTestClient]\n* xref:testing/mockmvc.adoc[MockMvc]\n* xref:testing/spring-mvc-test-client.adoc[Testing Client Applications]\n* xref:testing/annotations.adoc[Annotations]\n\n[[integration-testing-goals]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/integration.adoc", "title": "integration", "heading": "integration", "heading_level": 1, "file_order": 273, "section_index": 0, "content_hash": "beb3faeb16408b9782c7e6bd11abe131f01f45b6688319b43d812de537228f9f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/integration.adoc"}}
{"id": "sha256:04207d9b146f2ea8cf382d8d0fb16b098983d097896277f56a9fceb349318db8", "content": "Spring's integration testing support has the following primary goals:\n\n* To manage xref:testing/integration.adoc#testing-ctx-management[Spring IoC container caching] between tests.\n* To provide xref:testing/integration.adoc#testing-fixture-di[Dependency Injection of test fixture instances].\n* To provide xref:testing/integration.adoc#testing-tx[transaction management] appropriate to integration testing.\n* To supply xref:testing/integration.adoc#testing-support-classes[Spring-specific base classes] that assist\n developers in writing integration tests.\n\nThe next few sections describe each goal and provide links to implementation and\nconfiguration details.\n\n[[testing-ctx-management]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/integration.adoc", "title": "integration", "heading": "Goals of Integration Testing", "heading_level": 2, "file_order": 273, "section_index": 1, "content_hash": "04207d9b146f2ea8cf382d8d0fb16b098983d097896277f56a9fceb349318db8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/integration.adoc"}}
{"id": "sha256:af2c46c22e90c8c7d536d946594ddcb1b1679ac7dd81ea96b909fc2a4e0d90a9", "content": "The Spring TestContext Framework provides consistent loading of Spring\n`ApplicationContext` instances and `WebApplicationContext` instances as well as caching\nof those contexts. Support for the caching of loaded contexts is important, because\nstartup time can become an issue -- not because of the overhead of Spring itself, but\nbecause the objects instantiated by the Spring container take time to instantiate. For\nexample, a project with 50 to 100 Hibernate mapping files might take 10 to 20 seconds to\nload the mapping files, and incurring that cost before running every test in every test\nfixture leads to slower overall test runs that reduce developer productivity.\n\nTest classes typically declare either an array of resource locations for XML or Groovy\nconfiguration metadata -- often in the classpath -- or an array of component classes that\nis used to configure the application. These locations or classes are the same as or\nsimilar to those specified in `web.xml` or other configuration files for production\ndeployments.\n\nBy default, once loaded, the configured `ApplicationContext` is reused for each test.\nThus, the setup cost is incurred only once per test suite, and subsequent test execution\nis much faster. In this context, the term \"`test suite`\" means all tests run in the same\nJVM -- for example, all tests run from an Ant, Maven, or Gradle build for a given project\nor module. In the unlikely case that a test corrupts the application context and requires\nreloading (for example, by modifying a bean definition or the state of an application\nobject) the TestContext framework can be configured to reload the configuration and\nrebuild the application context before executing the next test.\n\nSee xref:testing/testcontext-framework/ctx-management.adoc[Context Management] and\nxref:testing/testcontext-framework/ctx-management/caching.adoc[Context Caching] with the\nTestContext framework.\n\n[[testing-fixture-di]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/integration.adoc", "title": "integration", "heading": "Context Management and Caching", "heading_level": 3, "file_order": 273, "section_index": 2, "content_hash": "af2c46c22e90c8c7d536d946594ddcb1b1679ac7dd81ea96b909fc2a4e0d90a9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/integration.adoc"}}
{"id": "sha256:4c6d6e2be835546022ac52da423dd7910a972ed94104dd8dda60b3423f7ee7e7", "content": "When the TestContext framework loads your application context, it can optionally\nconfigure instances of your test classes by using Dependency Injection. This provides a\nconvenient mechanism for setting up test fixtures by using preconfigured beans from your\napplication context. A strong benefit here is that you can reuse application contexts\nacross various testing scenarios (for example, for configuring Spring-managed object\ngraphs, transactional proxies, `DataSource` instances, and others), thus avoiding the\nneed to duplicate complex test fixture setup for individual test cases.\n\nAs an example, consider a scenario where we have a class (`HibernateTitleRepository`)\nthat implements data access logic for a `Title` domain entity. We want to write\nintegration tests that test the following areas:\n\n* The Spring configuration: Basically, is everything related to the configuration of the\n `HibernateTitleRepository` bean correct and present?\n* The Hibernate mapping file configuration: Is everything mapped correctly and are the\n correct lazy-loading settings in place?\n* The logic of the `HibernateTitleRepository`: Does the configured instance of this class\n perform as anticipated?\n\nSee dependency injection of test fixtures with the\nxref:testing/testcontext-framework/fixture-di.adoc[TestContext framework].\n\n[[testing-tx]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/integration.adoc", "title": "integration", "heading": "Dependency Injection of Test Fixtures", "heading_level": 3, "file_order": 273, "section_index": 3, "content_hash": "4c6d6e2be835546022ac52da423dd7910a972ed94104dd8dda60b3423f7ee7e7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/integration.adoc"}}
{"id": "sha256:f0b50186429c08179eef123afbc27de05f74c7d2f1805bb0a962a64182e60416", "content": "One common issue in tests that access a real database is their effect on the state of the\npersistence store. Even when you use a development database, changes to the state may\naffect future tests. Also, many operations -- such as inserting or modifying persistent\ndata -- cannot be performed (or verified) outside of a transaction.\n\nThe TestContext framework addresses this issue. By default, the framework creates and\nrolls back a transaction for each test. You can write code that can assume the existence\nof a transaction. If you call transactionally proxied objects in your tests, they behave\ncorrectly, according to their configured transactional semantics. In addition, if a test\nmethod deletes the contents of selected tables while running within the transaction\nmanaged for the test, the transaction rolls back by default, and the database returns to\nits state prior to execution of the test. Transactional support is provided to a test by\nusing a `PlatformTransactionManager` bean defined in the test's application context.\n\nIf you want a transaction to commit (unusual, but occasionally useful when you want a\nparticular test to populate or modify the database), you can tell the TestContext\nframework to cause the transaction to commit instead of roll back by using the\nxref:testing/annotations.adoc[`@Commit`] annotation.\n\nSee transaction management with the xref:testing/testcontext-framework/tx.adoc[TestContext framework].\n\n[[testing-support-classes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/integration.adoc", "title": "integration", "heading": "Transaction Management", "heading_level": 3, "file_order": 273, "section_index": 4, "content_hash": "f0b50186429c08179eef123afbc27de05f74c7d2f1805bb0a962a64182e60416", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/integration.adoc"}}
{"id": "sha256:09d3cb8e027bca7c9746040f220a9a5fe6e8d16eb3f220f6393ad3e170b597e6", "content": "The Spring TestContext Framework provides several `abstract` support classes that\nsimplify the writing of integration tests. These base test classes provide well-defined\nhooks into the testing framework as well as convenient instance variables and methods,\nwhich let you access:\n\n* The `ApplicationContext`, for performing explicit bean lookups or testing the state of\n the context as a whole.\n* A `JdbcTemplate`, for executing SQL statements to query the database. You can use such\n queries to confirm database state both before and after execution of database-related\n application code, and Spring ensures that such queries run in the scope of the same\n transaction as the application code. When used in conjunction with an ORM tool, be sure\n to avoid xref:testing/testcontext-framework/tx.adoc#testcontext-tx-false-positives[false positives].\n\nIn addition, you may want to create your own custom, application-wide superclass with\ninstance variables and methods specific to your project.\n\nSee support classes for the xref:testing/testcontext-framework/support-classes.adoc[TestContext framework].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/integration.adoc", "title": "integration", "heading": "Support Classes for Integration Testing", "heading_level": 3, "file_order": 273, "section_index": 5, "content_hash": "09d3cb8e027bca7c9746040f220a9a5fe6e8d16eb3f220f6393ad3e170b597e6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/integration.adoc"}}
{"id": "sha256:70ed4962394edb2c78111318b1e419da18fe3573f71c973354881960952fb0e9", "content": "[[testing-introduction]]\n\nTesting is an integral part of enterprise software development. This chapter focuses on\nthe value added by the IoC principle to xref:testing/unit.adoc[unit testing] and on the benefits\nof the Spring Framework's support for xref:testing/integration.adoc[integration testing]. (A\nthorough treatment of testing in the enterprise is beyond the scope of this reference\nmanual.)", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/introduction.adoc", "title": "introduction", "heading": "introduction", "heading_level": 1, "file_order": 274, "section_index": 0, "content_hash": "70ed4962394edb2c78111318b1e419da18fe3573f71c973354881960952fb0e9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/introduction.adoc"}}
{"id": "sha256:f2b088e9afddd420c8b3d0575a4218a5979c9c7db8b282ff0cc5e820dfdbba53", "content": "[[mockmvc]]\n\nMockMvc provides support for testing Spring MVC applications. It performs full Spring MVC\nrequest handling but via mock request and response objects instead of a running server.\n\nMockMvc can be used on its own to perform requests and verify responses using Hamcrest or\nthrough `MockMvcTester` which provides a fluent API using AssertJ. It can also be used\nthrough the xref:testing/webtestclient.adoc[WebTestClient] where MockMvc is plugged in as\nthe server to handle requests. The advantage of using `WebTestClient` is that it provides\nyou the option of working with higher level objects instead of raw data as well as the\nability to switch to full, end-to-end HTTP tests against a live server and use the same\ntest API.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/mockmvc.adoc", "title": "mockmvc", "heading": "mockmvc", "heading_level": 1, "file_order": 275, "section_index": 0, "content_hash": "f2b088e9afddd420c8b3d0575a4218a5979c9c7db8b282ff0cc5e820dfdbba53", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/mockmvc.adoc"}}
{"id": "sha256:b872362d0e404ecb8b9a6b971b55b29f0671311ef85b60fdc6275c2c0063164d", "content": "[[testing-resources]]\nSee the following resources for more information about testing:\n\nhttps://www.junit.org/[JUnit] ::\n \"A programmer-friendly testing framework for Java and the JVM\". Used by the Spring\n Framework in its test suite and supported in the\n xref:testing/testcontext-framework.adoc[Spring TestContext Framework].\nhttps://testng.org/[TestNG] ::\n A testing framework inspired by JUnit with added support for test groups, data-driven\n testing, distributed testing, and other features. Supported in the\n xref:testing/testcontext-framework.adoc[Spring TestContext Framework].\n{assertj-docs}[AssertJ] ::\n \"Fluent assertions for Java\", including support for lambda expressions, streams, and\n numerous other features. Supported in Spring's\n xref:testing/mockmvc/assertj.adoc[MockMvc testing support].\nhttps://en.wikipedia.org/wiki/Mock_Object[Mock Objects] ::\n Article in Wikipedia.\nhttps://site.mockito.org[Mockito] ::\n Java mock library based on the http://xunitpatterns.com/Test%20Spy.html[Test Spy]\n pattern. Used by the Spring Framework in its test suite.\nhttps://easymock.org/[EasyMock] ::\n Java library \"that provides Mock Objects for interfaces (and objects through the class\n extension) by generating them on the fly using Java's proxy mechanism.\"\nhttps://jmock.org/[JMock] ::\n Library that supports test-driven development of Java code with mock objects.\nhttps://www.dbunit.org/[DbUnit] ::\n JUnit extension (also usable with Ant and Maven) that is targeted at database-driven\n projects and, among other things, puts your database into a known state between test\n runs.\n{testcontainers-site}[Testcontainers] ::\n Java library that supports JUnit tests, providing lightweight, throwaway instances of\n common databases, Selenium web browsers, or anything else that can run in a Docker\n container.\nhttps://sourceforge.net/projects/grinder/[The Grinder] ::\n Java load testing framework.\nhttps://github.com/Ninja-Squad/springmockk[SpringMockK] ::\n Support for Spring Boot integration tests written in Kotlin using\n https://mockk.io/[MockK] instead of Mockito.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resources.adoc", "title": "resources", "heading": "resources", "heading_level": 1, "file_order": 276, "section_index": 0, "content_hash": "b872362d0e404ecb8b9a6b971b55b29f0671311ef85b60fdc6275c2c0063164d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resources.adoc"}}
{"id": "sha256:d878e2dfc12921d54e9ce5f22ddc92bf2d4436b4ba042e3001b98e93185c5a70", "content": "[[resttestclient]]\n\n`RestTestClient` is an HTTP client designed for testing server applications. It wraps\nSpring's xref:integration/rest-clients.adoc#rest-restclient[`RestClient`] and uses it to perform requests,\nbut exposes a testing facade for verifying responses. `RestTestClient` can be used to\nperform end-to-end HTTP tests. It can also be used to test Spring MVC\napplications without a running server via MockMvc.\n\n[[resttestclient.setup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resttestclient.adoc", "title": "resttestclient", "heading": "resttestclient", "heading_level": 1, "file_order": 277, "section_index": 0, "content_hash": "d878e2dfc12921d54e9ce5f22ddc92bf2d4436b4ba042e3001b98e93185c5a70", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resttestclient.adoc"}}
{"id": "sha256:2330a48dbf6bc51acb9816a9eb2e1b03187b9a8c0380c741979713f6e39353d5", "content": "To set up a `RestTestClient` you need to choose a server setup to bind to. This can be one\nof several MockMvc setup choices, or a connection to a live server.\n\n[[resttestclient.controller-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resttestclient.adoc", "title": "resttestclient", "heading": "Setup", "heading_level": 2, "file_order": 277, "section_index": 1, "content_hash": "2330a48dbf6bc51acb9816a9eb2e1b03187b9a8c0380c741979713f6e39353d5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resttestclient.adoc"}}
{"id": "sha256:c908ebb0c8281d998293e35866ccedb6d589a4deec5239bff280abc7c93c62ca", "content": "This setup allows you to test specific controller(s) via mock request and response objects,\nwithout a running server.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRestTestClient client =\n RestTestClient.bindToController(new TestController()).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval client = RestTestClient.bindToController(TestController()).build()\n----\n======\n\n[[resttestclient.context-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resttestclient.adoc", "title": "resttestclient", "heading": "Bind to Controller", "heading_level": 3, "file_order": 277, "section_index": 2, "content_hash": "c908ebb0c8281d998293e35866ccedb6d589a4deec5239bff280abc7c93c62ca", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resttestclient.adoc"}}
{"id": "sha256:5e148aa824dbb35c984f4c79502f26157402a05cf1895ff10e1a2f70fb0e19f9", "content": "This setup allows you to load Spring configuration with Spring MVC\ninfrastructure and controller declarations and use it to handle requests via mock request\nand response objects, without a running server.\n\ninclude-code::./RestClientContextTests[indent=0]\n\n[[resttestclient.fn-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resttestclient.adoc", "title": "resttestclient", "heading": "Bind to `ApplicationContext`", "heading_level": 3, "file_order": 277, "section_index": 3, "content_hash": "5e148aa824dbb35c984f4c79502f26157402a05cf1895ff10e1a2f70fb0e19f9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resttestclient.adoc"}}
{"id": "sha256:f32d6c8343b35121377dabe7027a4b682bbb5142831efff3ca60ff8af0745486", "content": "This setup allows you to test xref:web/webmvc-functional.adoc[functional endpoints] via\nmock request and response objects, without a running server.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRouterFunction<?> route = ...\n\tclient = RestTestClient.bindToRouterFunction(route).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval route: RouterFunction<*> = ...\n\tval client = RestTestClient.bindToRouterFunction(route).build()\n----\n======\n\n[[resttestclient.server-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resttestclient.adoc", "title": "resttestclient", "heading": "Bind to Router Function", "heading_level": 3, "file_order": 277, "section_index": 4, "content_hash": "f32d6c8343b35121377dabe7027a4b682bbb5142831efff3ca60ff8af0745486", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resttestclient.adoc"}}
{"id": "sha256:170fac84aa9998f73d5ba4a49adeb34bd96975504625d18a52c8694d2bba632a", "content": "This setup connects to a running server to perform full, end-to-end HTTP tests:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient = RestTestClient.bindToServer().baseUrl(\"http://localhost:8080\").build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient = RestTestClient.bindToServer().baseUrl(\"http://localhost:8080\").build()\n----\n======\n\n[[resttestclient.client-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resttestclient.adoc", "title": "resttestclient", "heading": "Bind to Server", "heading_level": 3, "file_order": 277, "section_index": 5, "content_hash": "170fac84aa9998f73d5ba4a49adeb34bd96975504625d18a52c8694d2bba632a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resttestclient.adoc"}}
{"id": "sha256:36b69a527b0dc3b732cc56a7268de96132c5bb8ffd9138aaf1ae1001e1698772", "content": "In addition to the server setup options described earlier, you can also configure client\noptions, including base URL, default headers, client filters, and others. These options\nare readily available following the initial `bindTo` call, as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient = RestTestClient.bindToController(new TestController())\n .baseUrl(\"/test\")\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient = RestTestClient.bindToController(TestController())\n .baseUrl(\"/test\")\n .build()\n----\n======\n\n[[resttestclient.tests]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resttestclient.adoc", "title": "resttestclient", "heading": "Client Config", "heading_level": 3, "file_order": 277, "section_index": 6, "content_hash": "36b69a527b0dc3b732cc56a7268de96132c5bb8ffd9138aaf1ae1001e1698772", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resttestclient.adoc"}}
{"id": "sha256:241e844fa46947a34da8a4bf094f882681f0e4ab393e5cf8e31253f4405264fd", "content": "xref:integration/rest-clients.adoc#rest-restclient[`RestClient`] and `RestTestClient` have\nthe same API up to the point of the call to `exchange()`. After that, `RestTestClient`\nprovides two alternative ways to verify the response:\n\n1. xref:resttestclient-workflow[Built-in Assertions] extend the request workflow with a chain of expectations\n2. xref:resttestclient-assertj[AssertJ Integration] to verify the response via `assertThat()` statements\n\n[[resttestclient.workflow]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resttestclient.adoc", "title": "resttestclient", "heading": "Writing Tests", "heading_level": 2, "file_order": 277, "section_index": 7, "content_hash": "241e844fa46947a34da8a4bf094f882681f0e4ab393e5cf8e31253f4405264fd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resttestclient.adoc"}}
{"id": "sha256:46704bb70b9c12853647dc9db9ae44124e7d8f359d14007ff20166eacb7eb690", "content": "To use the built-in assertions, remain in the workflow after the call to `exchange()`, and\nuse one of the expectation methods. For example:\n\ninclude-code::./RestClientWorkflowTests[tag=test,indent=0]\n\nIf you would like for all expectations to be asserted even if one of them fails, you can\nuse `expectAll(..)` instead of multiple chained `expect*(..)` calls. This feature is\nsimilar to the _soft assertions_ support in AssertJ and the `assertAll()` support in\nJUnit Jupiter.\n\ninclude-code::./RestClientWorkflowTests[tag=soft-assertions,indent=0]\n\nYou can then choose to decode the response body through one of the following:\n\n* `expectBody(Class<T>)`: Decode to single object.\n* `expectBody()`: Decode to `byte[]` for xref:testing/resttestclient.adoc#resttestclient-json[JSON Content] or an empty body.\n\nIf the built-in assertions are insufficient, you can consume the object instead and\nperform any other assertions:\n\ninclude-code::./RestClientWorkflowTests[tag=consume,indent=0]\n\nOr you can exit the workflow and obtain a `EntityExchangeResult`:\n\ninclude-code::./RestClientWorkflowTests[tag=result,indent=0]\n\nTIP: When you need to decode to a target type with generics, look for the overloaded methods\nthat accept {spring-framework-api}/core/ParameterizedTypeReference.html[`ParameterizedTypeReference`]\ninstead of `Class<T>`.\n\n[[resttestclient.no-content]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resttestclient.adoc", "title": "resttestclient", "heading": "Built-in Assertions", "heading_level": 3, "file_order": 277, "section_index": 8, "content_hash": "46704bb70b9c12853647dc9db9ae44124e7d8f359d14007ff20166eacb7eb690", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resttestclient.adoc"}}
{"id": "sha256:8eb5c8067adb67d94c09411b518ccb95f1cf754740c35c327c97217b1de49c1f", "content": "If the response is not expected to have content, you can assert that as follows:\n\ninclude-code::./NoContentTests[tag=emptyBody,indent=0]\n\nIf you want to ignore the response content, the following releases the content without any assertions:\n\ninclude-code::./NoContentTests[tag=ignoreBody,indent=0]\n\nNOTE: Consuming the response body (for example, with `expectBody`) is required if your tests are running with\nleak detection for pooled buffers. Without that, the tool will report buffers being leaked.\n\n[[resttestclient.json]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resttestclient.adoc", "title": "resttestclient", "heading": "No Content", "heading_level": 4, "file_order": 277, "section_index": 9, "content_hash": "8eb5c8067adb67d94c09411b518ccb95f1cf754740c35c327c97217b1de49c1f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resttestclient.adoc"}}
{"id": "sha256:0c9702d659c35a21c981b47c7ee29ffd6beeac1dc9fc7cbaede15548bc28bbc2", "content": "You can use `expectBody()` without a target type to perform assertions on the raw\ncontent rather than through higher level Object(s).\n\nTo verify the full JSON content with https://jsonassert.skyscreamer.org[JSONAssert]:\n\ninclude-code::./JsonTests[tag=jsonBody,indent=0]\n\nTo verify JSON content with https://github.com/jayway/JsonPath[JSONPath]:\n\ninclude-code::./JsonTests[tag=jsonPath,indent=0]\n\n[[resttestclient.assertj]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resttestclient.adoc", "title": "resttestclient", "heading": "JSON Content", "heading_level": 4, "file_order": 277, "section_index": 10, "content_hash": "0c9702d659c35a21c981b47c7ee29ffd6beeac1dc9fc7cbaede15548bc28bbc2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resttestclient.adoc"}}
{"id": "sha256:d3b1a23dea4018441165487dc2e1e017c651bccc5c2d632291c247f481a3a447", "content": "`RestTestClientResponse` is the main entry point for the AssertJ integration.\nIt is an `AssertProvider` that wraps the `ResponseSpec` of an exchange in order to enable\nuse of `assertThat()` statements. For example:\n\ninclude-code::./AssertJTests[tag=withSpec,indent=0]\n\nYou can also use the built-in workflow first, and then obtain an `ExchangeResult` to wrap\nand continue with AssertJ. For example:\n\ninclude-code::./AssertJTests[tag=withResult,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/resttestclient.adoc", "title": "resttestclient", "heading": "AssertJ Integration", "heading_level": 3, "file_order": 277, "section_index": 11, "content_hash": "d3b1a23dea4018441165487dc2e1e017c651bccc5c2d632291c247f481a3a447", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/resttestclient.adoc"}}
{"id": "sha256:81a753d2868410f6bcdfa20468bb1cf63c9a6fdc0b20b045df8b2eb82636a623", "content": "[[spring-mvc-test-client]]\n\nTo test code that uses the `RestClient` or `RestTemplate`, you can use a mock web server, such as\nhttps://github.com/square/okhttp#mockwebserver[OkHttp MockWebServer] or\nhttps://wiremock.org/[WireMock]. Mock web servers accept requests over HTTP like a regular\nserver, and that means you can test with the same HTTP client that is also configured in\nthe same way as in production, which is important because there are often subtle\ndifferences in the way different clients handle network I/O. Another advantage of mock\nweb servers is the ability to simulate specific network issues and conditions at the\ntransport level, in combination with the client used in production.\n\nIn addition to dedicated mock web servers, historically the Spring Framework has provided\na built-in option to test `RestClient` or `RestTemplate` through `MockRestServiceServer`.\nThis relies on configuring the client under test with a custom `ClientHttpRequestFactory`\nbacked by the mock server that is in turn set up to expect requests and send \"`stub`\"\nresponses so that you can focus on testing the code in isolation, without running a server.\n\nTIP: `MockRestServiceServer` predates the existence of mock web servers. At present, we\nrecommend using mock web servers for more complete testing of the transport layer and\nnetwork conditions.\n\nThe following example shows an example of using `MockRestServiceServer`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRestTemplate restTemplate = new RestTemplate();\n\n\tMockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();\n\tmockServer.expect(requestTo(\"/greeting\")).andRespond(withSuccess());\n\n\t// Test code that uses the above RestTemplate ...\n\n\tmockServer.verify();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval restTemplate = RestTemplate()\n\n\tval mockServer = MockRestServiceServer.bindTo(restTemplate).build()\n\tmockServer.expect(requestTo(\"/greeting\")).andRespond(withSuccess())\n\n\t// Test code that uses the above RestTemplate ...\n\n\tmockServer.verify()\n----\n======\n\nIn the preceding example, `MockRestServiceServer` (the central class for client-side REST\ntests) configures the `RestTemplate` with a custom `ClientHttpRequestFactory` that\nasserts actual requests against expectations and returns \"`stub`\" responses. In this\ncase, we expect a request to `/greeting` and want to return a 200 response with\n`text/plain` content. We can define additional expected requests and stub responses as\nneeded. When we define expected requests and stub responses, the `RestTemplate` can be\nused in client-side code as usual. At the end of testing, `mockServer.verify()` can be\nused to verify that all expectations have been satisfied.\n\nBy default, requests are expected in the order in which expectations were declared. You\ncan set the `ignoreExpectOrder` option when building the server, in which case all\nexpectations are checked (in order) to find a match for a given request. That means\nrequests are allowed to come in any order. The following example uses `ignoreExpectOrder`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tserver = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tserver = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build()\n----\n======\n\nEven with unordered requests by default, each request is allowed to run once only.\nThe `expect` method provides an overloaded variant that accepts an `ExpectedCount`\nargument that specifies a count range (for example, `once`, `manyTimes`, `max`, `min`,\n`between`, and so on). The following example uses `times`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRestTemplate restTemplate = new RestTemplate();\n\n\tMockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();\n\tmockServer.expect(times(2), requestTo(\"/something\")).andRespond(withSuccess());\n\tmockServer.expect(times(3), requestTo(\"/somewhere\")).andRespond(withSuccess());\n\n\t// ...\n\n\tmockServer.verify();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval restTemplate = RestTemplate()\n\n\tval mockServer = MockRestServiceServer.bindTo(restTemplate).build()\n\tmockServer.expect(times(2), requestTo(\"/something\")).andRespond(withSuccess())\n\tmockServer.expect(times(3), requestTo(\"/somewhere\")).andRespond(withSuccess())\n\n\t// ...\n\n\tmockServer.verify()\n----\n======\n\nNote that, when `ignoreExpectOrder` is not set (the default), and, therefore, requests\nare expected in order of declaration, then that order applies only to the first of any\nexpected request. For example if \"/something\" is expected two times followed by\n\"/somewhere\" three times, then there should be a request to \"/something\" before there is\na request to \"/somewhere\", but, aside from that subsequent \"/something\" and \"/somewhere\",\nrequests can come at any time.\n\nAs an alternative to all of the above, the client-side test support also provides a\n`ClientHttpRequestFactory` implementation that you can configure into a `RestTemplate` to\nbind it to a `MockMvc` instance. That allows processing requests using actual server-side\nlogic but without running a server. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build();\n\tthis.restTemplate = new RestTemplate(new MockMvcClientHttpRequestFactory(mockMvc));\n\n\t// Test code that uses the above RestTemplate ...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build()\n\trestTemplate = RestTemplate(MockMvcClientHttpRequestFactory(mockMvc))\n\n\t// Test code that uses the above RestTemplate ...\n----\n======\n\nIn some cases it may be necessary to perform an actual call to a remote service instead\nof mocking the response. The following example shows how to do that through\n`ExecutingResponseCreator`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRestTemplate restTemplate = new RestTemplate();\n\n\t// Create ExecutingResponseCreator with the original request factory\n\tExecutingResponseCreator withActualResponse = new ExecutingResponseCreator(restTemplate.getRequestFactory());\n\n\tMockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();\n\tmockServer.expect(requestTo(\"/profile\")).andRespond(withSuccess());\n\tmockServer.expect(requestTo(\"/quoteOfTheDay\")).andRespond(withActualResponse);\n\n\t// Test code that uses the above RestTemplate ...\n\n\tmockServer.verify();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval restTemplate = RestTemplate()\n\n\t// Create ExecutingResponseCreator with the original request factory\n\tval withActualResponse = new ExecutingResponseCreator(restTemplate.getRequestFactory())\n\n\tval mockServer = MockRestServiceServer.bindTo(restTemplate).build()\n\tmockServer.expect(requestTo(\"/profile\")).andRespond(withSuccess())\n\tmockServer.expect(requestTo(\"/quoteOfTheDay\")).andRespond(withActualResponse)\n\n\t// Test code that uses the above RestTemplate ...\n\n\tmockServer.verify()\n----\n======\n\nIn the preceding example, we create the `ExecutingResponseCreator` using the\n`ClientHttpRequestFactory` from the `RestTemplate` _before_ `MockRestServiceServer` replaces\nit with a different one that mocks responses.\nThen we define expectations with two kinds of responses:\n\n * a stub `200` response for the `/profile` endpoint (no actual request will be executed)\n * a response obtained through a call to the `/quoteOfTheDay` endpoint\n\nIn the second case, the request is executed through the `ClientHttpRequestFactory` that was\ncaptured earlier. This generates a response that could, for example, come from an actual remote server,\ndepending on how the `RestTemplate` was originally configured.\n\n[[spring-mvc-test-client-static-imports]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/spring-mvc-test-client.adoc", "title": "spring-mvc-test-client", "heading": "spring-mvc-test-client", "heading_level": 1, "file_order": 278, "section_index": 0, "content_hash": "81a753d2868410f6bcdfa20468bb1cf63c9a6fdc0b20b045df8b2eb82636a623", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/spring-mvc-test-client.adoc"}}
{"id": "sha256:d7e7deb5b2441d6287d324c82196e9b818da8a1a79f85485b1aefdf671625fa2", "content": "As with server-side tests, the fluent API for client-side tests requires a few static\nimports. Those are easy to find by searching for `MockRest*`. Eclipse users should add\n`MockRestRequestMatchers.{asterisk}` and `MockRestResponseCreators.{asterisk}` as\n\"`favorite static members`\" in the Eclipse preferences under Java -> Editor -> Content\nAssist -> Favorites. That allows using content assist after typing the first character of\nthe static method name. Other IDEs (such IntelliJ) may not require any additional\nconfiguration. Check for the support for code completion on static members.\n\n[[spring-mvc-test-client-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/spring-mvc-test-client.adoc", "title": "spring-mvc-test-client", "heading": "Static Imports", "heading_level": 2, "file_order": 278, "section_index": 1, "content_hash": "d7e7deb5b2441d6287d324c82196e9b818da8a1a79f85485b1aefdf671625fa2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/spring-mvc-test-client.adoc"}}
{"id": "sha256:b821609593895798a54d9fe0b0f961db849479b9069bf07933244af5f8df2cb7", "content": "Spring MVC Test's own tests include\n{spring-framework-code}/spring-test/src/test/java/org/springframework/test/web/client/samples[example\ntests] of client-side REST tests.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/spring-mvc-test-client.adoc", "title": "spring-mvc-test-client", "heading": "Further Examples of Client-side REST Tests", "heading_level": 2, "file_order": 278, "section_index": 2, "content_hash": "b821609593895798a54d9fe0b0f961db849479b9069bf07933244af5f8df2cb7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/spring-mvc-test-client.adoc"}}
{"id": "sha256:b87f8e3a2116057ba175c635bfe62e1cf676be4ede9f5c38ea2e50239242ff6f", "content": "[[integration-testing-support-jdbc]]\n\n[[integration-testing-support-jdbc-test-utils]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/support-jdbc.adoc", "title": "support-jdbc", "heading": "support-jdbc", "heading_level": 1, "file_order": 279, "section_index": 0, "content_hash": "b87f8e3a2116057ba175c635bfe62e1cf676be4ede9f5c38ea2e50239242ff6f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/support-jdbc.adoc"}}
{"id": "sha256:d6b46a22ad211c49bddc3539c60fff83ef8d27dd5452d081355e526c4d3613a1", "content": "The `org.springframework.test.jdbc` package contains `JdbcTestUtils`, which is a\ncollection of JDBC-related utility functions intended to simplify standard database\ntesting scenarios. Specifically, `JdbcTestUtils` provides the following static utility\nmethods.\n\n* `countRowsInTable(..)`: Counts the number of rows in the given table.\n* `countRowsInTableWhere(..)`: Counts the number of rows in the given table by using the\n provided `WHERE` clause.\n* `deleteFromTables(..)`: Deletes all rows from the specified tables.\n* `deleteFromTableWhere(..)`: Deletes rows from the given table by using the provided\n `WHERE` clause.\n* `dropTables(..)`: Drops the specified tables.\n\n[TIP]\n====\nxref:testing/testcontext-framework/support-classes.adoc#testcontext-support-classes-junit4[`AbstractTransactionalJUnit4SpringContextTests`]\nand xref:testing/testcontext-framework/support-classes.adoc#testcontext-support-classes-testng[`AbstractTransactionalTestNGSpringContextTests`]\nprovide convenience methods that delegate to the aforementioned methods in\n`JdbcTestUtils`.\n====\n\n[[integration-testing-support-jdbc-embedded-database]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/support-jdbc.adoc", "title": "support-jdbc", "heading": "JdbcTestUtils", "heading_level": 2, "file_order": 279, "section_index": 1, "content_hash": "d6b46a22ad211c49bddc3539c60fff83ef8d27dd5452d081355e526c4d3613a1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/support-jdbc.adoc"}}
{"id": "sha256:73f972f96231c01e384df826b04d760c1fad54377ffc491814628e9f402c54d3", "content": "The `spring-jdbc` module provides support for configuring and launching an embedded\ndatabase, which you can use in integration tests that interact with a database.\nFor details, see xref:data-access/jdbc/embedded-database-support.adoc[Embedded Database Support]\n and xref:data-access/jdbc/embedded-database-support.adoc#jdbc-embedded-database-dao-testing[Testing Data Access\nLogic with an Embedded Database].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/support-jdbc.adoc", "title": "support-jdbc", "heading": "Embedded Databases", "heading_level": 2, "file_order": 279, "section_index": 2, "content_hash": "73f972f96231c01e384df826b04d760c1fad54377ffc491814628e9f402c54d3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/support-jdbc.adoc"}}
{"id": "sha256:447cf2806762c03ba0b44c88fa3bd760cc8278bbe9f262170efa219ebae590ac", "content": "[[testcontext-framework]]\n\nThe Spring TestContext Framework (located in the `org.springframework.test.context`\npackage) provides generic, annotation-driven unit and integration testing support that is\nagnostic of the testing framework in use. The TestContext framework also places a great\ndeal of importance on convention over configuration, with reasonable defaults that you\ncan override through annotation-based configuration.\n\nIn addition to generic testing infrastructure, the TestContext framework provides\nexplicit support for JUnit Jupiter, JUnit 4, and TestNG. For JUnit 4 and TestNG, Spring\nprovides `abstract` support classes. Furthermore, Spring provides a custom JUnit `Runner`\nand custom JUnit `Rules` for JUnit 4 and a custom `Extension` for JUnit Jupiter that let\nyou write so-called POJO test classes. POJO test classes are not required to extend a\nparticular class hierarchy, such as the `abstract` support classes.\n\nThe following section provides an overview of the internals of the TestContext framework.\nIf you are interested only in using the framework and are not interested in extending it\nwith your own custom listeners or custom loaders, feel free to go directly to the\nconfiguration (xref:testing/testcontext-framework/ctx-management.adoc[context management],\nxref:testing/testcontext-framework/fixture-di.adoc[dependency injection],\nxref:testing/testcontext-framework/tx.adoc[transaction management]),\nxref:testing/testcontext-framework/support-classes.adoc[support classes], and\nxref:testing/annotations.adoc[annotation support] sections.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/testcontext-framework.adoc", "title": "testcontext-framework", "heading": "testcontext-framework", "heading_level": 1, "file_order": 280, "section_index": 0, "content_hash": "447cf2806762c03ba0b44c88fa3bd760cc8278bbe9f262170efa219ebae590ac", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/testcontext-framework.adoc"}}
{"id": "sha256:62e4875de1c21d8a075eadb85661f41769b18b968ddbb9b3522c48705780e0dc", "content": "[[unit-testing]]\n\nDependency injection should make your code less dependent on the container than it would\nbe with traditional J2EE / Java EE development. The POJOs that make up your application\nshould be testable in JUnit or TestNG tests, with objects instantiated by using the `new`\noperator, without Spring or any other container. You can use xref:testing/unit.adoc#mock-objects[mock objects]\n(in conjunction with other valuable testing techniques) to test your code in isolation.\nIf you follow the architecture recommendations for Spring, the resulting clean layering\nand componentization of your codebase facilitate easier unit testing. For example,\nyou can test service layer objects by stubbing or mocking DAO or repository interfaces,\nwithout needing to access persistent data while running unit tests.\n\nTrue unit tests typically run extremely quickly, as there is no runtime infrastructure to\nset up. Emphasizing true unit tests as part of your development methodology can boost\nyour productivity. You may not need this section of the testing chapter to help you write\neffective unit tests for your IoC-based applications. For certain unit testing scenarios,\nhowever, the Spring Framework provides mock objects and testing support classes, which\nare described in this chapter.\n\n[[mock-objects]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/unit.adoc", "title": "unit", "heading": "unit", "heading_level": 1, "file_order": 281, "section_index": 0, "content_hash": "62e4875de1c21d8a075eadb85661f41769b18b968ddbb9b3522c48705780e0dc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/unit.adoc"}}
{"id": "sha256:2b10c8298199f63b514d6aefa1e5f4e0d8aada2e7d618278c7478d025eb5b0bb", "content": "Spring includes a number of packages dedicated to mocking:\n\n* xref:testing/unit.adoc#mock-objects-env[Environment]\n* xref:testing/unit.adoc#mock-objects-servlet[Servlet API]\n* xref:testing/unit.adoc#mock-objects-web-reactive[Spring Web Reactive]\n\n[[mock-objects-env]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/unit.adoc", "title": "unit", "heading": "Mock Objects", "heading_level": 2, "file_order": 281, "section_index": 1, "content_hash": "2b10c8298199f63b514d6aefa1e5f4e0d8aada2e7d618278c7478d025eb5b0bb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/unit.adoc"}}
{"id": "sha256:80de3257c8ba75c213e119ed17633e22f722bc73a96fd08d363a569ea1b02158", "content": "The `org.springframework.mock.env` package contains mock implementations of the\n`Environment` and `PropertySource` abstractions (see\nxref:core/beans/environment.adoc#beans-definition-profiles[Bean Definition Profiles]\nand xref:core/beans/environment.adoc#beans-property-source-abstraction[`PropertySource` Abstraction]).\n`MockEnvironment` and `MockPropertySource` are useful for developing\nout-of-container tests for code that depends on environment-specific properties.\n\n[[mock-objects-servlet]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/unit.adoc", "title": "unit", "heading": "Environment", "heading_level": 3, "file_order": 281, "section_index": 2, "content_hash": "80de3257c8ba75c213e119ed17633e22f722bc73a96fd08d363a569ea1b02158", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/unit.adoc"}}
{"id": "sha256:be144d5c5927d97b3da0d73acd706a34837b72af874150bc066330d2c98043f8", "content": "The `org.springframework.mock.web` package contains a comprehensive set of Servlet API\nmock objects that are useful for testing web contexts, controllers, and filters. These\nmock objects are targeted at usage with Spring's Web MVC framework and are generally more\nconvenient to use than dynamic mock objects (such as https://easymock.org/[EasyMock]).\n\nTIP: Since Spring Framework 7.0, the mock objects in `org.springframework.mock.web` are\nbased on the Servlet 6.1 API.\n\nMockMvc builds on the mock Servlet API objects to provide an integration testing\nframework for Spring MVC. See xref:testing/mockmvc.adoc[MockMvc].\n\n[[mock-objects-web-reactive]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/unit.adoc", "title": "unit", "heading": "Servlet API", "heading_level": 3, "file_order": 281, "section_index": 3, "content_hash": "be144d5c5927d97b3da0d73acd706a34837b72af874150bc066330d2c98043f8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/unit.adoc"}}
{"id": "sha256:6e9a4b6e4b4806316f260cbabd5ba161bc485a86b666c5b163d4c75cc6e647af", "content": "The `org.springframework.mock.http.server.reactive` package contains mock implementations\nof `ServerHttpRequest` and `ServerHttpResponse` for use in WebFlux applications. The\n`org.springframework.mock.web.server` package contains a mock `ServerWebExchange` that\ndepends on those mock request and response objects.\n\nBoth `MockServerHttpRequest` and `MockServerHttpResponse` extend from the same abstract\nbase classes as server-specific implementations and share behavior with them. For\nexample, a mock request is immutable once created, but you can use the `mutate()` method\nfrom `ServerHttpRequest` to create a modified instance.\n\nIn order for the mock response to properly implement the write contract and return a\nwrite completion handle (that is, `Mono<Void>`), it by default uses a `Flux` with\n`cache().then()`, which buffers the data and makes it available for assertions in tests.\nApplications can set a custom write function (for example, to test an infinite stream).\n\nThe xref:testing/webtestclient.adoc[WebTestClient] builds on the mock request and response to provide support for\ntesting WebFlux applications without an HTTP server. The client can also be used for\nend-to-end tests with a running server.\n\n[[unit-testing-support-classes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/unit.adoc", "title": "unit", "heading": "Spring Web Reactive", "heading_level": 3, "file_order": 281, "section_index": 4, "content_hash": "6e9a4b6e4b4806316f260cbabd5ba161bc485a86b666c5b163d4c75cc6e647af", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/unit.adoc"}}
{"id": "sha256:a674f0361379147d7630e88cb0e5fdbf81d7940939b5e60cb8088805e8624133", "content": "Spring includes a number of classes that can help with unit testing. They fall into two\ncategories:\n\n* xref:testing/unit.adoc#unit-testing-utilities[General Testing Utilities]\n* xref:testing/unit.adoc#unit-testing-spring-mvc[Spring MVC Testing Utilities]\n\n[[unit-testing-utilities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/unit.adoc", "title": "unit", "heading": "Unit Testing Support Classes", "heading_level": 2, "file_order": 281, "section_index": 5, "content_hash": "a674f0361379147d7630e88cb0e5fdbf81d7940939b5e60cb8088805e8624133", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/unit.adoc"}}
{"id": "sha256:cd4ac78c55d5c718b4aee671d54e452df770abd92f805844579d25fa9a603127", "content": "The `org.springframework.test.util` package contains several general purpose utilities\nfor use in unit and integration testing.\n\n{spring-framework-api}/test/util/AopTestUtils.html[`AopTestUtils`] is a collection of\nAOP-related utility methods. You can use these methods to obtain a reference to the\nunderlying target object hidden behind one or more Spring proxies. For example, if you\nhave configured a bean as a dynamic mock by using a library such as EasyMock or Mockito,\nand the mock is wrapped in a Spring proxy, you may need direct access to the underlying\nmock to configure expectations on it and perform verifications. For Spring's core AOP\nutilities, see {spring-framework-api}/aop/support/AopUtils.html[`AopUtils`] and\n{spring-framework-api}/aop/framework/AopProxyUtils.html[`AopProxyUtils`].\n\n{spring-framework-api}/test/util/ReflectionTestUtils.html[`ReflectionTestUtils`] is a\ncollection of reflection-based utility methods. You can use these methods in testing\nscenarios where you need to change the value of a constant, set a non-`public` field,\ninvoke a non-`public` setter method, or invoke a non-`public` configuration or lifecycle\ncallback method when testing application code for use cases such as the following:\n\n* ORM frameworks (such as JPA and Hibernate) that condone `private` or `protected` field\n access as opposed to `public` setter methods for properties in a domain entity.\n* Spring's support for annotations (such as `@Autowired`, `@Inject`, and `@Resource`),\n that provide dependency injection for `private` or `protected` fields, setter methods,\n and configuration methods.\n* Use of annotations such as `@PostConstruct` and `@PreDestroy` for lifecycle callback\n methods.\n\n{spring-framework-api}/test/util/TestSocketUtils.html[`TestSocketUtils`] is a simple\nutility for finding available TCP ports on `localhost` for use in integration testing\nscenarios.\n\n[NOTE]\n====\n`TestSocketUtils` can be used in integration tests which start an external server on an\navailable random port. However, these utilities make no guarantee about the subsequent\navailability of a given port and are therefore unreliable. Instead of using\n`TestSocketUtils` to find an available local port for a server, it is recommended that\nyou rely on a server's ability to start on a random ephemeral port that it selects or is\nassigned by the operating system. To interact with that server, you should query the\nserver for the port it is currently using.\n====\n\n[[unit-testing-spring-mvc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/unit.adoc", "title": "unit", "heading": "General Testing Utilities", "heading_level": 3, "file_order": 281, "section_index": 6, "content_hash": "cd4ac78c55d5c718b4aee671d54e452df770abd92f805844579d25fa9a603127", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/unit.adoc"}}
{"id": "sha256:ff998938b46c7a2108d98f32ffff70aef22bb0e475fda15dfdca990c2ddfc0d3", "content": "The `org.springframework.test.web` package contains\n{spring-framework-api}/test/web/ModelAndViewAssert.html[`ModelAndViewAssert`], which you\ncan use in combination with JUnit, TestNG, or any other testing framework for unit tests\nthat deal with Spring MVC `ModelAndView` objects.\n\n.Unit testing Spring MVC Controllers\nTIP: To unit test your Spring MVC `Controller` classes as POJOs, use `ModelAndViewAssert`\ncombined with `MockHttpServletRequest`, `MockHttpSession`, and so on from Spring's\nxref:testing/unit.adoc#mock-objects-servlet[Servlet API mocks]. For thorough integration\ntesting of your Spring MVC and REST `Controller` classes in conjunction with your\n`WebApplicationContext` configuration for Spring MVC, use\nxref:testing/mockmvc.adoc[MockMvc] instead.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/unit.adoc", "title": "unit", "heading": "Spring MVC Testing Utilities", "heading_level": 3, "file_order": 281, "section_index": 7, "content_hash": "ff998938b46c7a2108d98f32ffff70aef22bb0e475fda15dfdca990c2ddfc0d3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/unit.adoc"}}
{"id": "sha256:11e14119cf065a409537c5a2ace0366e766a92ed5d47398f8a8cd5c115bfb71c", "content": "[[webtestclient]]\n\n`WebTestClient` is an HTTP client designed for testing server applications. It wraps\nSpring's xref:web/webflux-webclient.adoc[WebClient] and uses it to perform requests\nbut exposes a testing facade for verifying responses. `WebTestClient` can be used to\nperform end-to-end HTTP tests. It can also be used to test Spring MVC and Spring WebFlux\napplications without a running server via mock server request and response objects.\n\n[[webtestclient-setup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "webtestclient", "heading_level": 1, "file_order": 282, "section_index": 0, "content_hash": "11e14119cf065a409537c5a2ace0366e766a92ed5d47398f8a8cd5c115bfb71c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:d0ef0529409602e99edb1f9eba2e0a0a180b7e82bd173b6b02da39c0ab0e1661", "content": "To set up a `WebTestClient` you need to choose a server setup to bind to. This can be one\nof several mock server setup choices or a connection to a live server.\n\n[[webtestclient-controller-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "Setup", "heading_level": 2, "file_order": 282, "section_index": 1, "content_hash": "d0ef0529409602e99edb1f9eba2e0a0a180b7e82bd173b6b02da39c0ab0e1661", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:e9bfe6ea8d807c0edabecf4d1493b034820cf53d03598c60172e2be4aa4e0566", "content": "This setup allows you to test specific controller(s) via mock request and response objects,\nwithout a running server.\n\nFor WebFlux applications, use the following which loads infrastructure equivalent to the\nxref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[WebFlux Java config], registers the given\ncontroller(s), and creates a xref:web/webflux/reactive-spring.adoc#webflux-web-handler-api[WebHandler chain]\nto handle requests:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebTestClient client =\n WebTestClient.bindToController(new TestController()).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval client = WebTestClient.bindToController(TestController()).build()\n----\n======\n\nFor Spring MVC, use the following which delegates to the\n{spring-framework-api}/test/web/servlet/setup/StandaloneMockMvcBuilder.html[StandaloneMockMvcBuilder]\nto load infrastructure equivalent to the xref:web/webmvc/mvc-config.adoc[WebMvc Java config],\nregisters the given controller(s), and creates an instance of\nxref:testing/mockmvc.adoc[MockMvc] to handle requests:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebTestClient client =\n MockMvcWebTestClient.bindToController(new TestController()).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval client = MockMvcWebTestClient.bindToController(TestController()).build()\n----\n======\n\n[[webtestclient-context-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "Bind to Controller", "heading_level": 3, "file_order": 282, "section_index": 2, "content_hash": "e9bfe6ea8d807c0edabecf4d1493b034820cf53d03598c60172e2be4aa4e0566", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:4d99080281ec9cdefe164f7de01a08bb7323381f0e99b1457aff44800fc3952e", "content": "This setup allows you to load Spring configuration with Spring MVC or Spring WebFlux\ninfrastructure and controller declarations and use it to handle requests via mock request\nand response objects, without a running server.\n\nFor WebFlux, use the following where the Spring `ApplicationContext` is passed to\n{spring-framework-api}/web/server/adapter/WebHttpHandlerBuilder.html#applicationContext(org.springframework.context.ApplicationContext)[WebHttpHandlerBuilder]\nto create the xref:web/webflux/reactive-spring.adoc#webflux-web-handler-api[WebHandler chain] to handle\nrequests:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(WebConfig.class) // <1>\n\tclass MyTests {\n\n WebTestClient client;\n\n @BeforeEach\n void setUp(ApplicationContext context) { // <2>\n client = WebTestClient.bindToApplicationContext(context).build(); // <3>\n }\n\t}\n----\n<1> Specify the configuration to load\n<2> Inject the configuration\n<3> Create the `WebTestClient`\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@SpringJUnitConfig(WebConfig::class) // <1>\n\tclass MyTests {\n\n lateinit var client: WebTestClient\n\n @BeforeEach\n fun setUp(context: ApplicationContext) { // <2>\n client = WebTestClient.bindToApplicationContext(context).build() // <3>\n }\n\t}\n----\n<1> Specify the configuration to load\n<2> Inject the configuration\n<3> Create the `WebTestClient`\n======\n\nFor Spring MVC, use the following where the Spring `ApplicationContext` is passed to\n{spring-framework-api}/test/web/servlet/setup/MockMvcBuilders.html#webAppContextSetup(org.springframework.web.context.WebApplicationContext)[MockMvcBuilders.webAppContextSetup]\nto create a xref:testing/mockmvc.adoc[MockMvc] instance to handle\nrequests:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t@WebAppConfiguration(\"classpath:META-INF/web-resources\") // <1>\n\t@ContextHierarchy({\n @ContextConfiguration(classes = RootConfig.class),\n @ContextConfiguration(classes = WebConfig.class)\n\t})\n\tclass MyTests {\n\n @Autowired\n WebApplicationContext wac; // <2>\n\n WebTestClient client;\n\n @BeforeEach\n void setUp() {\n client = MockMvcWebTestClient.bindToApplicationContext(this.wac).build(); // <3>\n }\n\t}\n----\n<1> Specify the configuration to load\n<2> Inject the configuration\n<3> Create the `WebTestClient`\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ExtendWith(SpringExtension.class)\n\t@WebAppConfiguration(\"classpath:META-INF/web-resources\") // <1>\n\t@ContextHierarchy({\n @ContextConfiguration(classes = RootConfig.class),\n @ContextConfiguration(classes = WebConfig.class)\n\t})\n\tclass MyTests {\n\n @Autowired\n lateinit var wac: WebApplicationContext; // <2>\n\n lateinit var client: WebTestClient\n\n @BeforeEach\n fun setUp() { // <2>\n client = MockMvcWebTestClient.bindToApplicationContext(wac).build() // <3>\n }\n\t}\n----\n<1> Specify the configuration to load\n<2> Inject the configuration\n<3> Create the `WebTestClient`\n======\n\n[[webtestclient-fn-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "Bind to `ApplicationContext`", "heading_level": 3, "file_order": 282, "section_index": 3, "content_hash": "4d99080281ec9cdefe164f7de01a08bb7323381f0e99b1457aff44800fc3952e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:cf084f7aebda88193b7c188813094016947df0e0090d73fa8d02c15e711be472", "content": "This setup allows you to test xref:web/webflux-functional.adoc[functional endpoints] via\nmock request and response objects, without a running server.\n\nFor WebFlux, use the following which delegates to `RouterFunctions.toWebHandler` to\ncreate a server setup to handle requests:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRouterFunction<?> route = ...\n\tclient = WebTestClient.bindToRouterFunction(route).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval route: RouterFunction<*> = ...\n\tval client = WebTestClient.bindToRouterFunction(route).build()\n----\n======\n\nFor Spring MVC there are currently no options to test\nxref:web/webmvc-functional.adoc[WebMvc functional endpoints].\n\n[[webtestclient-server-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "Bind to Router Function", "heading_level": 3, "file_order": 282, "section_index": 4, "content_hash": "cf084f7aebda88193b7c188813094016947df0e0090d73fa8d02c15e711be472", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:38471a9e4a8bfd86a022fdc41de6dfa11569a0e11b80b800d9e89a4caee3d091", "content": "This setup connects to a running server to perform full, end-to-end HTTP tests:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient = WebTestClient.bindToServer().baseUrl(\"http://localhost:8080\").build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient = WebTestClient.bindToServer().baseUrl(\"http://localhost:8080\").build()\n----\n======\n\n[[webtestclient-client-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "Bind to Server", "heading_level": 3, "file_order": 282, "section_index": 5, "content_hash": "38471a9e4a8bfd86a022fdc41de6dfa11569a0e11b80b800d9e89a4caee3d091", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:1de94bc723e2bd37f940734af12683ccb045e510d597454d9af35efa1cd61ba7", "content": "In addition to the server setup options described earlier, you can also configure client\noptions, including base URL, default headers, client filters, and others. These options\nare readily available following `bindToServer()`. For all other configuration options,\nyou need to use `configureClient()` to transition from server to client configuration, as\nfollows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient = WebTestClient.bindToController(new TestController())\n .configureClient()\n .baseUrl(\"/test\")\n .apiVersionInserter(ApiVersionInserter.fromHeader(\"API-Version\").build())\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient = WebTestClient.bindToController(TestController())\n .configureClient()\n .baseUrl(\"/test\")\n .apiVersionInserter(ApiVersionInserter.fromHeader(\"API-Version\").build())\n .build()\n----\n======\n\n[[webtestclient-tests]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "Client Config", "heading_level": 3, "file_order": 282, "section_index": 6, "content_hash": "1de94bc723e2bd37f940734af12683ccb045e510d597454d9af35efa1cd61ba7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:7c8d4d9d5b365f32923ce5770b2d3883f12f4c91b045d30dc71fd8a867b16fdf", "content": "xref:web/webflux-webclient.adoc[WebClient] and `WebTestClient` have\nthe same API up to the point of the call to `exchange()`. After that, `WebTestClient`\nprovides two alternative ways to verify the response:\n\n1. xref:webtestclient-workflow[Built-in Assertions] extend the request workflow with a chain of expectations\n2. xref:webtestclient-assertj[AssertJ Integration] to verify the response via `assertThat()` statements\n\nTIP: See the xref:web/webflux-webclient/client-body.adoc[WebClient] documentation for\nexamples on how to prepare a request with any content including form data,\nmultipart data, and more.\n\n[[webtestclient-workflow]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "Writing Tests", "heading_level": 2, "file_order": 282, "section_index": 7, "content_hash": "7c8d4d9d5b365f32923ce5770b2d3883f12f4c91b045d30dc71fd8a867b16fdf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:361dad78e961d8d539df7c0c2de487698ed41c85f21fed21917ebaed8445d21c", "content": "To assert the response status and headers, use the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.get().uri(\"/persons/1\")\n .accept(MediaType.APPLICATION_JSON)\n .exchange()\n .expectStatus().isOk()\n .expectHeader().contentType(MediaType.APPLICATION_JSON);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.get().uri(\"/persons/1\")\n .accept(MediaType.APPLICATION_JSON)\n .exchange()\n .expectStatus().isOk()\n .expectHeader().contentType(MediaType.APPLICATION_JSON)\n----\n======\n\nIf you would like for all expectations to be asserted even if one of them fails, you can\nuse `expectAll(..)` instead of multiple chained `expect*(..)` calls. This feature is\nsimilar to the _soft assertions_ support in AssertJ and the `assertAll()` support in\nJUnit Jupiter.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.get().uri(\"/persons/1\")\n .accept(MediaType.APPLICATION_JSON)\n .exchange()\n .expectAll(\n spec -> spec.expectStatus().isOk(),\n spec -> spec.expectHeader().contentType(MediaType.APPLICATION_JSON)\n );\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.get().uri(\"/persons/1\")\n .accept(MediaType.APPLICATION_JSON)\n .exchange()\n .expectAll(\n { spec -> spec.expectStatus().isOk() },\n { spec -> spec.expectHeader().contentType(MediaType.APPLICATION_JSON) }\n )\n----\n======\n\nYou can then choose to decode the response body through one of the following:\n\n* `expectBody(Class<T>)`: Decode to single object.\n* `expectBodyList(Class<T>)`: Decode and collect objects to `List<T>`.\n* `expectBody()`: Decode to `byte[]` for xref:testing/webtestclient.adoc#webtestclient-json[JSON Content] or an empty body.\n\nAnd perform assertions on the resulting higher level Object(s):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.get().uri(\"/persons\")\n .exchange()\n .expectStatus().isOk()\n .expectBodyList(Person.class).hasSize(3).contains(person);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.test.web.reactive.server.expectBodyList\n\n\tclient.get().uri(\"/persons\")\n .exchange()\n .expectStatus().isOk()\n .expectBodyList<Person>().hasSize(3).contains(person)\n----\n======\n\nIf the built-in assertions are insufficient, you can consume the object instead and\nperform any other assertions:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.test.web.reactive.server.expectBody\n\n\tclient.get().uri(\"/persons/1\")\n .exchange()\n .expectStatus().isOk()\n .expectBody(Person.class)\n .consumeWith(result -> {\n // custom assertions (for example, AssertJ)...\n });\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.get().uri(\"/persons/1\")\n .exchange()\n .expectStatus().isOk()\n .expectBody<Person>()\n .consumeWith {\n // custom assertions (for example, AssertJ)...\n }\n----\n======\n\nOr you can exit the workflow and obtain an `EntityExchangeResult`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tEntityExchangeResult<Person> result = client.get().uri(\"/persons/1\")\n .exchange()\n .expectStatus().isOk()\n .expectBody(Person.class)\n .returnResult();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.test.web.reactive.server.expectBody\n\n\tval result = client.get().uri(\"/persons/1\")\n .exchange()\n .expectStatus().isOk\n .expectBody<Person>()\n .returnResult()\n----\n======\n\nTIP: When you need to decode to a target type with generics, look for the overloaded methods\nthat accept\n{spring-framework-api}/core/ParameterizedTypeReference.html[`ParameterizedTypeReference`]\ninstead of `Class<T>`.\n\n[[webtestclient-no-content]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "Built-in Assertions", "heading_level": 3, "file_order": 282, "section_index": 8, "content_hash": "361dad78e961d8d539df7c0c2de487698ed41c85f21fed21917ebaed8445d21c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:cf9534f8f306965ded348d15973dcdb6942fff83f94c3c58eb3054e9f51f1818", "content": "If the response is not expected to have content, you can assert that as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.post().uri(\"/persons\")\n .body(personMono, Person.class)\n .exchange()\n .expectStatus().isCreated()\n .expectBody().isEmpty();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.post().uri(\"/persons\")\n .bodyValue(person)\n .exchange()\n .expectStatus().isCreated()\n .expectBody().isEmpty()\n----\n======\n\nIf you want to ignore the response content, the following releases the content without\nany assertions:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.get().uri(\"/persons/123\")\n .exchange()\n .expectStatus().isNotFound()\n .expectBody(Void.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.get().uri(\"/persons/123\")\n .exchange()\n .expectStatus().isNotFound\n .expectBody<Unit>()\n----\n======\n\n[[webtestclient-json]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "No Content", "heading_level": 4, "file_order": 282, "section_index": 9, "content_hash": "cf9534f8f306965ded348d15973dcdb6942fff83f94c3c58eb3054e9f51f1818", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:237cd3a981d1cd14b7a4ecc1f3189687222b453d0747bee2f305e5535799de74", "content": "You can use `expectBody()` without a target type to perform assertions on the raw\ncontent rather than through higher level Object(s).\n\nTo verify the full JSON content with https://jsonassert.skyscreamer.org[JSONAssert]:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.get().uri(\"/persons/1\")\n .exchange()\n .expectStatus().isOk()\n .expectBody()\n .json(\"{\\\"name\\\":\\\"Jane\\\"}\")\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.get().uri(\"/persons/1\")\n .exchange()\n .expectStatus().isOk()\n .expectBody()\n .json(\"{\\\"name\\\":\\\"Jane\\\"}\")\n----\n======\n\nTo verify JSON content with https://github.com/jayway/JsonPath[JSONPath]:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.get().uri(\"/persons\")\n .exchange()\n .expectStatus().isOk()\n .expectBody()\n .jsonPath(\"$[0].name\").isEqualTo(\"Jane\")\n .jsonPath(\"$[1].name\").isEqualTo(\"Jason\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclient.get().uri(\"/persons\")\n .exchange()\n .expectStatus().isOk()\n .expectBody()\n .jsonPath(\"$[0].name\").isEqualTo(\"Jane\")\n .jsonPath(\"$[1].name\").isEqualTo(\"Jason\")\n----\n======\n\n[[webtestclient-stream]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "JSON Content", "heading_level": 4, "file_order": 282, "section_index": 10, "content_hash": "237cd3a981d1cd14b7a4ecc1f3189687222b453d0747bee2f305e5535799de74", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:d53c1fd3acc9ec5d548151102c17d2cc4b168dee107cd81e167592dff91bd073", "content": "To test potentially infinite streams such as `\"text/event-stream\"` or\n`\"application/x-ndjson\"`, start by verifying the response status and headers, and then\nobtain a `FluxExchangeResult`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tFluxExchangeResult<MyEvent> result = client.get().uri(\"/events\")\n .accept(TEXT_EVENT_STREAM)\n .exchange()\n .expectStatus().isOk()\n .returnResult(MyEvent.class);\n\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.test.web.reactive.server.returnResult\n\n\tval result = client.get().uri(\"/events\")\n .accept(TEXT_EVENT_STREAM)\n .exchange()\n .expectStatus().isOk()\n .returnResult<MyEvent>()\n----\n======\n\nNow you're ready to consume the response stream with `StepVerifier` from `reactor-test`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tFlux<Event> eventFlux = result.getResponseBody();\n\n\tStepVerifier.create(eventFlux)\n .expectNext(person)\n .expectNextCount(4)\n .consumeNextWith(p -> ...)\n .thenCancel()\n .verify();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval eventFlux = result.getResponseBody()\n\n\tStepVerifier.create(eventFlux)\n .expectNext(person)\n .expectNextCount(4)\n .consumeNextWith { p -> ... }\n .thenCancel()\n .verify()\n----\n======\n\n[[webtestclient-assertj]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "Streaming Responses", "heading_level": 4, "file_order": 282, "section_index": 11, "content_hash": "d53c1fd3acc9ec5d548151102c17d2cc4b168dee107cd81e167592dff91bd073", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:3908cc1b5b29163007459609aec1cc9886e80d447d1b802a49337c87e30ddb7d", "content": "`WebTestClientResponse` is the main entry point for the AssertJ integration.\nIt is an `AssertProvider` that wraps the `ResponseSpec` of an exchange in order to enable\nuse of `assertThat()` statements. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tResponseSpec spec = client.get().uri(\"/persons\").exchange();\n\n\tWebTestClientResponse response = WebTestClientResponse.from(spec);\n\tassertThat(response).hasStatusOk();\n\tassertThat(response).hasContentTypeCompatibleWith(MediaType.TEXT_PLAIN);\n\t// ...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval spec = client.get().uri(\"/persons\").exchange()\n\n\tval response = WebTestClientResponse.from(spec)\n\tassertThat(response).hasStatusOk()\n\tassertThat(response).hasContentTypeCompatibleWith(MediaType.TEXT_PLAIN)\n\t// ...\n----\n======\n\nYou can also use the built-in workflow first, and then obtain an `ExchangeResult` to wrap\nand continue with AssertJ. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tExchangeResult result = client.get().uri(\"/persons\").exchange()\n . // ...\n .returnResult();\n\n\tWebTestClientResponse response = WebTestClientResponse.from(result);\n\tassertThat(response).hasStatusOk();\n\tassertThat(response).hasContentTypeCompatibleWith(MediaType.TEXT_PLAIN);\n\t// ...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval result = client.get().uri(\"/persons\").exchange()\n . // ...\n .returnResult()\n\n\tval response = WebTestClientResponse.from(spec)\n\tassertThat(response).hasStatusOk()\n\tassertThat(response).hasContentTypeCompatibleWith(MediaType.TEXT_PLAIN)\n\t// ...\n----\n======\n\n[[webtestclient-mockmvc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "AssertJ Integration", "heading_level": 3, "file_order": 282, "section_index": 12, "content_hash": "3908cc1b5b29163007459609aec1cc9886e80d447d1b802a49337c87e30ddb7d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:c89c8d51b471e31ac0cccccc0712d840bd5cbffa549900f031242fea22b7d0de", "content": "`WebTestClient` is an HTTP client and as such it can only verify what is in the client\nresponse including status, headers, and body.\n\nWhen testing a Spring MVC application with a MockMvc server setup, you have the extra\nchoice to perform further assertions on the server response. To do that start by\nobtaining an `ExchangeResult` after asserting the body:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// For a response with a body\n\tEntityExchangeResult<Person> result = client.get().uri(\"/persons/1\")\n .exchange()\n .expectStatus().isOk()\n .expectBody(Person.class)\n .returnResult();\n\n\t// For a response without a body\n\tEntityExchangeResult<Void> result = client.get().uri(\"/path\")\n .exchange()\n .expectBody().isEmpty();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// For a response with a body\n\tval result = client.get().uri(\"/persons/1\")\n .exchange()\n .expectStatus().isOk()\n .expectBody<Person>()\n .returnResult()\n\n\t// For a response without a body\n\tval result = client.get().uri(\"/path\")\n .exchange()\n .expectBody().isEmpty()\n----\n======\n\nThen switch to MockMvc server response assertions:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMockMvcWebTestClient.resultActionsFor(result)\n .andExpect(model().attribute(\"integer\", 3))\n .andExpect(model().attribute(\"string\", \"a string value\"));\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMockMvcWebTestClient.resultActionsFor(result)\n .andExpect(model().attribute(\"integer\", 3))\n .andExpect(model().attribute(\"string\", \"a string value\"));\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing/webtestclient.adoc", "title": "webtestclient", "heading": "MockMvc Assertions", "heading_level": 3, "file_order": 282, "section_index": 13, "content_hash": "c89c8d51b471e31ac0cccccc0712d840bd5cbffa549900f031242fea22b7d0de", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing/webtestclient.adoc"}}
{"id": "sha256:a2844c59f55613da69b2be6199b1233d5b7dbc7a48ce1fe694bee7e69ca3106d", "content": "[[webflux-ann-arguments]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/arguments.adoc[See equivalent in the Servlet stack]#\n\nThe following table shows the supported controller method arguments.\n\nReactive types (Reactor, RxJava, xref:web/webflux-reactive-libraries.adoc[or other]) are\nsupported on arguments that require blocking I/O (for example, reading the request body) to\nbe resolved. This is marked in the Description column. Reactive types are not expected\non arguments that do not require blocking.\n\nJDK 1.8's `java.util.Optional` is supported as a method argument in combination with\nannotations that have a `required` attribute (for example, `@RequestParam`, `@RequestHeader`,\nand others) and is equivalent to `required=false`.\n\n[cols=\"1,2\", options=\"header\"]\n|===\n| Controller method argument | Description\n\n| `ServerWebExchange`\n| Access to the full `ServerWebExchange` -- container for the HTTP request and response,\n request and session attributes, `checkNotModified` methods, and others.\n\n| `ServerHttpRequest`, `ServerHttpResponse`\n| Access to the HTTP request or response.\n\n| `WebSession`\n| Access to the session. This does not force the start of a new session unless attributes\n are added. Supports reactive types.\n\n| `java.security.Principal`\n| The currently authenticated user -- possibly a specific `Principal` implementation class if known.\n Supports reactive types.\n\n| `org.springframework.http.HttpMethod`\n| The HTTP method of the request.\n\n| `java.util.Locale`\n| The current request locale, determined by the most specific `LocaleResolver` available -- in\n effect, the configured `LocaleResolver`/`LocaleContextResolver`.\n\n| `java.util.TimeZone` + `java.time.ZoneId`\n| The time zone associated with the current request, as determined by a `LocaleContextResolver`.\n\n| `@PathVariable`\n| For access to URI template variables. See xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-uri-templates[URI Patterns].\n\n| `@MatrixVariable`\n| For access to name-value pairs in URI path segments. See xref:web/webflux/controller/ann-methods/matrix-variables.adoc[Matrix Variables].\n\n| `@RequestParam`\n| For access to query parameters. Parameter values are converted to the declared method argument\n type. See xref:web/webflux/controller/ann-methods/requestparam.adoc[`@RequestParam`].\n\n Note that use of `@RequestParam` is optional -- for example, to set its attributes.\n See \"`Any other argument`\" later in this table.\n\n| `@RequestHeader`\n| For access to request headers. Header values are converted to the declared method argument\n type. See xref:web/webflux/controller/ann-methods/requestheader.adoc[`@RequestHeader`].\n\n| `@CookieValue`\n| For access to cookies. Cookie values are converted to the declared method argument type.\n See xref:web/webflux/controller/ann-methods/cookievalue.adoc[`@CookieValue`].\n\n| `@RequestBody`\n| For access to the HTTP request body. Body content is converted to the declared method\n argument type by using `HttpMessageReader` instances. Supports reactive types.\n See xref:web/webflux/controller/ann-methods/requestbody.adoc[`@RequestBody`].\n\n| `HttpEntity<B>`\n| For access to request headers and body. The body is converted with `HttpMessageReader` instances.\n Supports reactive types. See xref:web/webflux/controller/ann-methods/httpentity.adoc[`HttpEntity`].\n\n| `@RequestPart`\n| For access to a part in a `multipart/form-data` request. Supports reactive types.\n See xref:web/webflux/controller/ann-methods/multipart-forms.adoc[Multipart Content] and xref:web/webflux/reactive-spring.adoc#webflux-multipart[Multipart Data].\n\n| `java.util.Map` or `org.springframework.ui.Model`\n| For access to the model that is used in HTML controllers and is exposed to templates as\n part of view rendering.\n\n| `@ModelAttribute`\n| For access to an existing attribute in the model (instantiated if not present) with\n data binding and validation applied. See xref:web/webflux/controller/ann-methods/modelattrib-method-args.adoc[`@ModelAttribute`] as well\n as xref:web/webflux/controller/ann-modelattrib-methods.adoc[`Model`] and xref:web/webflux/controller/ann-initbinder.adoc[`DataBinder`].\n\n Note that use of `@ModelAttribute` is optional -- for example, to set its attributes.\n See \"`Any other argument`\" later in this table.\n\n| `Errors` or `BindingResult`\n| For access to errors from validation and data binding for a command object, i.e. a\n `@ModelAttribute` argument. An `Errors` or `BindingResult` argument must be declared\n immediately after the validated method argument.\n\n| `SessionStatus` + class-level `@SessionAttributes`\n| For marking form processing complete, which triggers cleanup of session attributes\n declared through a class-level `@SessionAttributes` annotation.\n See xref:web/webflux/controller/ann-methods/sessionattributes.adoc[`@SessionAttributes`] for more details.\n\n| `UriComponentsBuilder`\n| For preparing a URL relative to the current request's host, port, scheme, and\n context path. See xref:web/webflux/uri-building.adoc[URI Links].\n\n| `@SessionAttribute`\n| For access to any session attribute -- in contrast to model attributes stored in the session\n as a result of a class-level `@SessionAttributes` declaration. See\n xref:web/webflux/controller/ann-methods/sessionattribute.adoc[`@SessionAttribute`] for more details.\n\n| `@RequestAttribute`\n| For access to request attributes. See xref:web/webflux/controller/ann-methods/requestattrib.adoc[`@RequestAttribute`] for more details.\n\n| Any other argument\n| If a method argument is not matched to any of the above, it is, by default, resolved as\n a `@RequestParam` if it is a simple type, as determined by\n {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty],\n or as a `@ModelAttribute`, otherwise.\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/arguments.adoc", "title": "arguments", "heading": "arguments", "heading_level": 1, "file_order": 283, "section_index": 0, "content_hash": "a2844c59f55613da69b2be6199b1233d5b7dbc7a48ce1fe694bee7e69ca3106d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/arguments.adoc"}}
{"id": "sha256:3e88977ae387f67e5b2af6f1865b5f22371f3ed6cca6087c2fa5c5c9412c39a1", "content": "[[webflux-ann-cookievalue]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/cookievalue.adoc[See equivalent in the Servlet stack]#\n\nYou can use the `@CookieValue` annotation to bind the value of an HTTP cookie to a method argument\nin a controller.\n\nThe following example shows a request with a cookie:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nJSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84\n----\n\nThe following code sample demonstrates how to get the cookie value:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/demo\")\n\tpublic void handle(@CookieValue(\"JSESSIONID\") String cookie) { // <1>\n //...\n\t}\n----\n<1> Get the cookie value.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/demo\")\n\tfun handle(@CookieValue(\"JSESSIONID\") cookie: String) { // <1>\n //...\n\t}\n----\n<1> Get the cookie value.\n======\n\nType conversion is applied automatically if the target method parameter type is not\n`String`. See xref:web/webflux/controller/ann-methods/typeconversion.adoc[Type Conversion].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/cookievalue.adoc", "title": "cookievalue", "heading": "cookievalue", "heading_level": 1, "file_order": 284, "section_index": 0, "content_hash": "3e88977ae387f67e5b2af6f1865b5f22371f3ed6cca6087c2fa5c5c9412c39a1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/cookievalue.adoc"}}
{"id": "sha256:d27da4e6578c5022500dbfdfcc5c09d41fd8011ac77658672105d800cbd17136", "content": "[[webflux-ann-httpentity]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/httpentity.adoc[See equivalent in the Servlet stack]#\n\n`HttpEntity` is more or less identical to using xref:web/webflux/controller/ann-methods/requestbody.adoc[`@RequestBody`] but is based on a\ncontainer object that exposes request headers and the body. The following example uses an\n`HttpEntity`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tpublic void handle(HttpEntity<Account> entity) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tfun handle(entity: HttpEntity<Account>) {\n // ...\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/httpentity.adoc", "title": "httpentity", "heading": "httpentity", "heading_level": 1, "file_order": 285, "section_index": 0, "content_hash": "d27da4e6578c5022500dbfdfcc5c09d41fd8011ac77658672105d800cbd17136", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/httpentity.adoc"}}
{"id": "sha256:759ad1c3eebf8d87dbeabe5df2c6528bcfd4ed2be8476d0887c3fd9657195056", "content": "[[webflux-ann-jackson]]\n\nSpring offers support for the Jackson JSON library.\n\n[[webflux-ann-jsonview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/jackson.adoc", "title": "jackson", "heading": "jackson", "heading_level": 1, "file_order": 286, "section_index": 0, "content_hash": "759ad1c3eebf8d87dbeabe5df2c6528bcfd4ed2be8476d0887c3fd9657195056", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/jackson.adoc"}}
{"id": "sha256:3905814b503f2e35d61feff59fbecd70f1afaa4a7617d118f85d14ed2e6262a8", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-methods/jackson.adoc[See equivalent in the Servlet stack]#\n\nSpring WebFlux provides built-in support for\n{baeldung-blog}/jackson-json-view-annotation[Jackson's Serialization Views],\nwhich allows rendering only a subset of all fields in an `Object`. To use it with\n`@ResponseBody` or `ResponseEntity` controller methods, you can use Jackson's\n`@JsonView` annotation to activate a serialization view class, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\tpublic class UserController {\n\n @GetMapping(\"/user\")\n @JsonView(User.WithoutPasswordView.class)\n public User getUser() {\n return new User(\"eric\", \"7!jd#h23\");\n }\n\t}\n\n\tpublic class User {\n\n public interface WithoutPasswordView {};\n public interface WithPasswordView extends WithoutPasswordView {};\n\n private String username;\n private String password;\n\n public User() {\n }\n\n public User(String username, String password) {\n this.username = username;\n this.password = password;\n }\n\n @JsonView(WithoutPasswordView.class)\n public String getUsername() {\n return this.username;\n }\n\n @JsonView(WithPasswordView.class)\n public String getPassword() {\n return this.password;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\tclass UserController {\n\n @GetMapping(\"/user\")\n @JsonView(User.WithoutPasswordView::class)\n fun getUser(): User {\n return User(\"eric\", \"7!jd#h23\")\n }\n\t}\n\n\tclass User(\n @JsonView(WithoutPasswordView::class) val username: String,\n @JsonView(WithPasswordView::class) val password: String\n\t) {\n interface WithoutPasswordView\n interface WithPasswordView : WithoutPasswordView\n\t}\n----\n======\n\nNOTE: `@JsonView` allows an array of view classes but you can specify only one per\ncontroller method. Use a composite interface if you need to activate multiple views.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/jackson.adoc", "title": "jackson", "heading": "JSON Views", "heading_level": 2, "file_order": 286, "section_index": 1, "content_hash": "3905814b503f2e35d61feff59fbecd70f1afaa4a7617d118f85d14ed2e6262a8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/jackson.adoc"}}
{"id": "sha256:a98e9045726f6c04dbf90553dfbee236c90704ed70f154bf6c976196ff7d3295", "content": "[[webflux-ann-matrix-variables]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/matrix-variables.adoc[See equivalent in the Servlet stack]#\n\n{rfc-site}/rfc3986#section-3.3[RFC 3986] discusses name-value pairs in\npath segments. In Spring WebFlux, we refer to those as \"`matrix variables`\" based on an\nhttps://www.w3.org/DesignIssues/MatrixURIs.html[\"`old post`\"] by Tim Berners-Lee, but they\ncan be also be referred to as URI path parameters.\n\nMatrix variables can appear in any path segment, with each variable separated by a semicolon and\nmultiple values separated by commas -- for example, `\"/cars;color=red,green;year=2012\"`. Multiple\nvalues can also be specified through repeated variable names -- for example,\n`\"color=red;color=green;color=blue\"`.\n\nUnlike Spring MVC, in WebFlux, the presence or absence of matrix variables in a URL does\nnot affect request mappings. In other words, you are not required to use a URI variable\nto mask variable content. That said, if you want to access matrix variables from a\ncontroller method, you need to add a URI variable to the path segment where matrix\nvariables are expected. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /pets/42;q=11;r=22\n\n\t@GetMapping(\"/pets/{petId}\")\n\tpublic void findPet(@PathVariable String petId, @MatrixVariable int q) {\n\n // petId == 42\n // q == 11\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /pets/42;q=11;r=22\n\n\t@GetMapping(\"/pets/{petId}\")\n\tfun findPet(@PathVariable petId: String, @MatrixVariable q: Int) {\n\n // petId == 42\n // q == 11\n\t}\n----\n======\n\nGiven that all path segments can contain matrix variables, you may sometimes need to\ndisambiguate which path variable the matrix variable is expected to be in,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /owners/42;q=11/pets/21;q=22\n\n\t@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n\tpublic void findPet(\n @MatrixVariable(name=\"q\", pathVar=\"ownerId\") int q1,\n @MatrixVariable(name=\"q\", pathVar=\"petId\") int q2) {\n\n // q1 == 11\n // q2 == 22\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n\tfun findPet(\n @MatrixVariable(name = \"q\", pathVar = \"ownerId\") q1: Int,\n @MatrixVariable(name = \"q\", pathVar = \"petId\") q2: Int) {\n\n // q1 == 11\n // q2 == 22\n\t}\n----\n======\n\nYou can define a matrix variable may be defined as optional and specify a default value\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /pets/42\n\n\t@GetMapping(\"/pets/{petId}\")\n\tpublic void findPet(@MatrixVariable(required=false, defaultValue=\"1\") int q) {\n\n // q == 1\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /pets/42\n\n\t@GetMapping(\"/pets/{petId}\")\n\tfun findPet(@MatrixVariable(required = false, defaultValue = \"1\") q: Int) {\n\n // q == 1\n\t}\n----\n======\n\nTo get all matrix variables, use a `MultiValueMap`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /owners/42;q=11;r=12/pets/21;q=22;s=23\n\n\t@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n\tpublic void findPet(\n @MatrixVariable MultiValueMap<String, String> matrixVars,\n @MatrixVariable(pathVar=\"petId\") MultiValueMap<String, String> petMatrixVars) {\n\n // matrixVars: [\"q\" : [11,22], \"r\" : 12, \"s\" : 23]\n // petMatrixVars: [\"q\" : 22, \"s\" : 23]\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /owners/42;q=11;r=12/pets/21;q=22;s=23\n\n\t@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n\tfun findPet(\n @MatrixVariable matrixVars: MultiValueMap<String, String>,\n @MatrixVariable(pathVar=\"petId\") petMatrixVars: MultiValueMap<String, String>) {\n\n // matrixVars: [\"q\" : [11,22], \"r\" : 12, \"s\" : 23]\n // petMatrixVars: [\"q\" : 22, \"s\" : 23]\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/matrix-variables.adoc", "title": "matrix-variables", "heading": "matrix-variables", "heading_level": 1, "file_order": 287, "section_index": 0, "content_hash": "a98e9045726f6c04dbf90553dfbee236c90704ed70f154bf6c976196ff7d3295", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/matrix-variables.adoc"}}
{"id": "sha256:ca378f2470e79ea776a9369a0b50f8d7e3b7f01377f04fe4d0be6f6f18a3e1fb", "content": "[[webflux-ann-modelattrib-method-args]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/modelattrib-method-args.adoc[See equivalent in the Servlet stack]#\n\nThe `@ModelAttribute` method parameter annotation binds form data, query parameters,\nURI path variables, and request headers onto a model object. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n\tpublic String processSubmit(@ModelAttribute Pet pet) { } // <1>\n----\n<1> Bind to an instance of `Pet`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n\tfun processSubmit(@ModelAttribute pet: Pet): String { } // <1>\n----\n<1> Bind to an instance of `Pet`.\n======\n\nForm data and query parameters take precedence over URI variables and headers, which are\nincluded only if they don't override request parameters with the same name. Dashes are\nstripped from header names.\n\nThe `Pet` instance may be:\n\n* Accessed from the model where it could have been added by a\n xref:web/webflux/controller/ann-modelattrib-methods.adoc[`Model`].\n* Accessed from the HTTP session if the model attribute was listed in\n the class-level xref:web/webflux/controller/ann-methods/sessionattributes.adoc[`@SessionAttributes`].\n* Instantiated through a default constructor.\n* Instantiated through a \"`primary constructor`\" with arguments that match to Servlet\nrequest parameters. Argument names are determined through runtime-retained parameter\nnames in the bytecode.\n\nBy default, both constructor and property\nxref:core/validation/data-binding.adoc[data binding] are applied. However,\nmodel object design requires careful consideration, and for security reasons it is\nrecommended either to use an object tailored specifically for web binding, or to apply\nconstructor binding only. If property binding must still be used, then _allowedFields_\npatterns should be set to limit which properties can be set. For further details on this\nand example configuration, see\nxref:web/webflux/controller/ann-initbinder.adoc#webflux-ann-initbinder-model-design[model design].\n\nWhen using constructor binding, you can customize request parameter names through an\n`@BindParam` annotation. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Account {\n\n private final String firstName;\n\n public Account(@BindParam(\"first-name\") String firstName) {\n this.firstName = firstName;\n }\n\t}\n----\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Account(@BindParam(\"first-name\") val firstName: String)\n----\n======\n\nNOTE: The `@BindParam` may also be placed on the fields that correspond to constructor\nparameters. While `@BindParam` is supported out of the box, you can also use a\ndifferent annotation by setting a `DataBinder.NameResolver` on `DataBinder`\n\nConstructor binding supports `List`, `Map`, and array arguments either converted from\na single string, for example, comma-separated list, or based on indexed keys such as\n`accounts[2].name` or `account[KEY].name`.\n\nWebFlux, unlike Spring MVC, supports reactive types in the model, for example, `Mono<Account>`.\nYou can declare a `@ModelAttribute` argument with or without a reactive type wrapper, and\nit will be resolved accordingly to the actual value.\n\nIf data binding results in errors, by default a `WebExchangeBindException` is raised,\nbut you can also add a `BindingResult` argument immediately next to the `@ModelAttribute`\nin order to handle such errors in the controller method. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n\tpublic String processSubmit(@ModelAttribute(\"pet\") Pet pet, BindingResult result) { <1>\n if (result.hasErrors()) {\n return \"petForm\";\n }\n // ...\n\t}\n----\n<1> Adding a `BindingResult`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n\tfun processSubmit(@ModelAttribute(\"pet\") pet: Pet, result: BindingResult): String { // <1>\n if (result.hasErrors()) {\n return \"petForm\"\n }\n // ...\n\t}\n----\n<1> Adding a `BindingResult`.\n======\n\nTo use a `BindingResult` argument, you must declare the `@ModelAttribute` argument before\nit without a reactive type wrapper. If you want to use the reactive, you can handle errors\ndirectly through it. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n\tpublic Mono<String> processSubmit(@Valid @ModelAttribute(\"pet\") Mono<Pet> petMono) {\n return petMono\n .flatMap(pet -> {\n // ...\n })\n .onErrorResume(ex -> {\n // ...\n });\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n\tfun processSubmit(@Valid @ModelAttribute(\"pet\") petMono: Mono<Pet>): Mono<String> {\n return petMono\n .flatMap { pet ->\n // ...\n }\n .onErrorResume{ ex ->\n // ...\n }\n\t}\n----\n======\n\nYou can automatically apply validation after data binding by adding the\n`jakarta.validation.Valid` annotation or Spring's `@Validated` annotation (see\nxref:core/validation/beanvalidation.adoc[Bean Validation] and\nxref:web/webmvc/mvc-config/validation.adoc[Spring validation]). For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n\tpublic String processSubmit(@Valid @ModelAttribute(\"pet\") Pet pet, BindingResult result) { // <1>\n if (result.hasErrors()) {\n return \"petForm\";\n }\n // ...\n\t}\n----\n<1> Using `@Valid` on a model attribute argument.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n\tfun processSubmit(@Valid @ModelAttribute(\"pet\") pet: Pet, result: BindingResult): String { // <1>\n if (result.hasErrors()) {\n return \"petForm\"\n }\n // ...\n\t}\n----\n<1> Using `@Valid` on a model attribute argument.\n======\n\nIf method validation applies because other parameters have `@Constraint` annotations,\nthen `HandlerMethodValidationException` would be raised instead. See the section on\ncontroller method xref:web/webmvc/mvc-controller/ann-validation.adoc[Validation].\n\nTIP: Using `@ModelAttribute` is optional. By default, any argument that is not a simple\nvalue type as determined by\n{spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty]\n_AND_ that is not resolved by any other argument resolver is treated as an implicit `@ModelAttribute`.\n\nWARNING: When compiling to a native image with GraalVM, the implicit `@ModelAttribute`\nsupport described above does not allow proper ahead-of-time inference of related data\nbinding reflection hints. As a consequence, it is recommended to explicitly annotate\nmethod parameters with `@ModelAttribute` for use in a GraalVM native image.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/modelattrib-method-args.adoc", "title": "modelattrib-method-args", "heading": "modelattrib-method-args", "heading_level": 1, "file_order": 288, "section_index": 0, "content_hash": "ca378f2470e79ea776a9369a0b50f8d7e3b7f01377f04fe4d0be6f6f18a3e1fb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/modelattrib-method-args.adoc"}}
{"id": "sha256:1680c0f264152e48aa37d7ed941a18f8b74d8500e413bfd491b17a1f3018a11e", "content": "[[webflux-multipart-forms]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/multipart-forms.adoc[See equivalent in the Servlet stack]#\n\nAs explained in xref:web/webflux/reactive-spring.adoc#webflux-multipart[Multipart Data], `ServerWebExchange` provides access to multipart\ncontent. The best way to handle a file upload form (for example, from a browser) in a controller\nis through data binding to a xref:web/webflux/controller/ann-methods/modelattrib-method-args.adoc[command object],\nas the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MyForm {\n\n private String name;\n\n private FilePart file;\n\n // ...\n\n\t}\n\n\t@Controller\n\tpublic class FileUploadController {\n\n @PostMapping(\"/form\")\n public String handleFormUpload(MyForm form, BindingResult errors) {\n // ...\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MyForm(\n private val name: String,\n private val file: FilePart)\n\n\t@Controller\n\tclass FileUploadController {\n\n @PostMapping(\"/form\")\n fun handleFormUpload(form: MyForm, errors: BindingResult): String {\n // ...\n }\n\n\t}\n----\n======\n--\n\nYou can also submit multipart requests from non-browser clients in a RESTful service\nscenario. The following example uses a file along with JSON:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nPOST /someUrl\nContent-Type: multipart/mixed\n\n--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp\nContent-Disposition: form-data; name=\"meta-data\"\nContent-Type: application/json; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\n{\n\t\"name\": \"value\"\n}\n--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp\nContent-Disposition: form-data; name=\"file-data\"; filename=\"file.properties\"\nContent-Type: text/xml\nContent-Transfer-Encoding: 8bit\n... File Data ...\n----\n\nYou can access individual parts with `@RequestPart`, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/\")\n\tpublic String handle(@RequestPart(\"meta-data\") Part metadata, // <1>\n @RequestPart(\"file-data\") FilePart file) { // <2>\n // ...\n\t}\n----\n<1> Using `@RequestPart` to get the metadata.\n<2> Using `@RequestPart` to get the file.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/\")\n\tfun handle(@RequestPart(\"meta-data\") metadata: Part, // <1>\n @RequestPart(\"file-data\") file: FilePart): String { // <2>\n // ...\n\t}\n----\n<1> Using `@RequestPart` to get the metadata.\n<2> Using `@RequestPart` to get the file.\n======\n--\n\nTo deserialize the raw part content (for example, to JSON -- similar to `@RequestBody`),\nyou can declare a concrete target `Object`, instead of `Part`, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/\")\n\tpublic String handle(@RequestPart(\"meta-data\") MetaData metadata) { // <1>\n // ...\n\t}\n----\n<1> Using `@RequestPart` to get the metadata.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/\")\n\tfun handle(@RequestPart(\"meta-data\") metadata: MetaData): String { // <1>\n // ...\n\t}\n----\n<1> Using `@RequestPart` to get the metadata.\n======\n--\n\nYou can use `@RequestPart` in combination with `jakarta.validation.Valid` or Spring's\n`@Validated` annotation, which causes Standard Bean Validation to be applied. Validation\nerrors lead to a `WebExchangeBindException` that results in a 400 (BAD_REQUEST) response.\nThe exception contains a `BindingResult` with the error details and can also be handled\nin the controller method by declaring the argument with an async wrapper and then using\nerror related operators:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/\")\n\tpublic String handle(@Valid @RequestPart(\"meta-data\") Mono<MetaData> metadata) {\n // use one of the onError* operators...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/\")\n\tfun handle(@Valid @RequestPart(\"meta-data\") metadata: Mono<MetaData>): String {\n // use one of the onError* operators...\n\t}\n----\n======\n--\n\nIf method validation applies because other parameters have `@Constraint` annotations,\nthen `HandlerMethodValidationException` is raised instead. See the section on\nxref:web/webflux/controller/ann-validation.adoc[Validation].\n\nTo access all multipart data as a `MultiValueMap`, you can use `@RequestBody`,\nas the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/\")\n\tpublic String handle(@RequestBody Mono<MultiValueMap<String, Part>> parts) { // <1>\n // ...\n\t}\n----\n<1> Using `@RequestBody`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/\")\n\tfun handle(@RequestBody parts: Mono<MultiValueMap<String, Part>>): String { // <1>\n // ...\n\t}\n----\n<1> Using `@RequestBody`.\n======\n--\n\n[[partevent]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/multipart-forms.adoc", "title": "multipart-forms", "heading": "multipart-forms", "heading_level": 1, "file_order": 289, "section_index": 0, "content_hash": "1680c0f264152e48aa37d7ed941a18f8b74d8500e413bfd491b17a1f3018a11e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/multipart-forms.adoc"}}
{"id": "sha256:073f3edf7aa80b66643d081cb703c086c815e58331ace09643439a99addc2eef", "content": "To access multipart data sequentially, in a streaming fashion, you can use `@RequestBody` with\n`Flux<PartEvent>` (or `Flow<PartEvent>` in Kotlin).\nEach part in a multipart HTTP message will produce at\nleast one `PartEvent` containing both headers and a buffer with the contents of the part.\n\n- Form fields will produce a *single* `FormPartEvent`, containing the value of the field.\n- File uploads will produce *one or more* `FilePartEvent` objects, containing the filename used\nwhen uploading. If the file is large enough to be split across multiple buffers, the first\n`FilePartEvent` will be followed by subsequent events.\n\nFor example:\n\ninclude-code::./PartEventController[tag=snippet,indent=0]\n\nReceived part events can also be relayed to another service by using the `WebClient`.\nSee xref:web/webflux-webclient/client-body.adoc#webflux-client-body-multipart[Multipart Data].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/multipart-forms.adoc", "title": "multipart-forms", "heading": "`PartEvent`", "heading_level": 2, "file_order": 289, "section_index": 1, "content_hash": "073f3edf7aa80b66643d081cb703c086c815e58331ace09643439a99addc2eef", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/multipart-forms.adoc"}}
{"id": "sha256:579345e6db36ab3208e2aaf8f596ed6cf95621267df7976a2a92e1770693fdf5", "content": "[[webflux-ann-requestattrib]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/requestattrib.adoc[See equivalent in the Servlet stack]#\n\nSimilarly to `@SessionAttribute`, you can use the `@RequestAttribute` annotation to\naccess pre-existing request attributes created earlier (for example, by a `WebFilter`),\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/\")\n\tpublic String handle(@RequestAttribute Client client) { <1>\n // ...\n\t}\n----\n<1> Using `@RequestAttribute`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/\")\n\tfun handle(@RequestAttribute client: Client): String { // <1>\n // ...\n\t}\n----\n<1> Using `@RequestAttribute`.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/requestattrib.adoc", "title": "requestattrib", "heading": "requestattrib", "heading_level": 1, "file_order": 290, "section_index": 0, "content_hash": "579345e6db36ab3208e2aaf8f596ed6cf95621267df7976a2a92e1770693fdf5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/requestattrib.adoc"}}
{"id": "sha256:eff4f0496734b95811d368263f271bc4e70952a57ec5111d1c33c4140d977249", "content": "[[webflux-ann-requestbody]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/requestbody.adoc[See equivalent in the Servlet stack]#\n\nYou can use the `@RequestBody` annotation to have the request body read and deserialized into an\n`Object` through an xref:web/webflux/reactive-spring.adoc#webflux-codecs[HttpMessageReader].\nThe following example uses a `@RequestBody` argument:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tpublic void handle(@RequestBody Account account) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tfun handle(@RequestBody account: Account) {\n // ...\n\t}\n----\n======\n\nUnlike Spring MVC, in WebFlux, the `@RequestBody` method argument supports reactive types\nand fully non-blocking reading and (client-to-server) streaming.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tpublic void handle(@RequestBody Mono<Account> account) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tfun handle(@RequestBody accounts: Flow<Account>) {\n // ...\n\t}\n----\n======\n\nYou can use the xref:web/webflux/config.adoc#webflux-config-message-codecs[HTTP message codecs] option of the xref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[WebFlux Config] to\nconfigure or customize message readers.\n\nYou can use `@RequestBody` in combination with `jakarta.validation.Valid` or Spring's\n`@Validated` annotation, which causes Standard Bean Validation to be applied. Validation\nerrors cause a `WebExchangeBindException`, which results in a 400 (BAD_REQUEST) response.\nThe exception contains a `BindingResult` with error details and can be handled in the\ncontroller method by declaring the argument with an async wrapper and then using error\nrelated operators:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tpublic void handle(@Valid @RequestBody Mono<Account> account) {\n // use one of the onError* operators...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tfun handle(@Valid @RequestBody account: Mono<Account>) {\n // ...\n\t}\n----\n======\n\nYou can also declare an `Errors` parameter for access to validation errors, but in\nthat case the request body must not be a `Mono`, and will be resolved first:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tpublic void handle(@Valid @RequestBody Account account, Errors errors) {\n // use one of the onError* operators...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tfun handle(@Valid @RequestBody account: Mono<Account>) {\n // ...\n\t}\n----\n======\n\nIf method validation applies because other parameters have `@Constraint` annotations,\nthen `HandlerMethodValidationException` is raised instead. For more details, see the\nsection on xref:web/webflux/controller/ann-validation.adoc[Validation].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/requestbody.adoc", "title": "requestbody", "heading": "requestbody", "heading_level": 1, "file_order": 291, "section_index": 0, "content_hash": "eff4f0496734b95811d368263f271bc4e70952a57ec5111d1c33c4140d977249", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/requestbody.adoc"}}
{"id": "sha256:98a88347d84b2245cbe7ff545a1bbc5735aa13d42c6d48b7e436c6100c26abab", "content": "[[webflux-ann-requestheader]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/requestheader.adoc[See equivalent in the Servlet stack]#\n\nYou can use the `@RequestHeader` annotation to bind a request header to a method argument in a\ncontroller.\n\nThe following example shows a request with headers:\n\n[literal]\n[subs=\"verbatim,quotes\"]\n----\nHost localhost:8080\nAccept text/html,application/xhtml+xml,application/xml;q=0.9\nAccept-Language fr,en-gb;q=0.7,en;q=0.3\nAccept-Encoding gzip,deflate\nAccept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7\nKeep-Alive 300\n----\n\nThe following example gets the value of the `Accept-Encoding` and `Keep-Alive` headers:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/demo\")\n\tpublic void handle(\n @RequestHeader(\"Accept-Encoding\") String encoding, // <1>\n @RequestHeader(\"Keep-Alive\") long keepAlive) { // <2>\n //...\n\t}\n----\n<1> Get the value of the `Accept-Encoding` header.\n<2> Get the value of the `Keep-Alive` header.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/demo\")\n\tfun handle(\n @RequestHeader(\"Accept-Encoding\") encoding: String, // <1>\n @RequestHeader(\"Keep-Alive\") keepAlive: Long) { // <2>\n //...\n\t}\n----\n<1> Get the value of the `Accept-Encoding` header.\n<2> Get the value of the `Keep-Alive` header.\n======\n\nType conversion is applied automatically if the target method parameter type is not\n`String`. See xref:web/webflux/controller/ann-methods/typeconversion.adoc[Type Conversion].\n\nWhen a `@RequestHeader` annotation is used on a `Map<String, String>`,\n`MultiValueMap<String, String>`, or `HttpHeaders` argument, the map is populated\nwith all header values.\n\nTIP: Built-in support is available for converting a comma-separated string into an\narray or collection of strings or other types known to the type conversion system. For\nexample, a method parameter annotated with `@RequestHeader(\"Accept\")` may be of type\n`String` but also of `String[]` or `List<String>`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/requestheader.adoc", "title": "requestheader", "heading": "requestheader", "heading_level": 1, "file_order": 292, "section_index": 0, "content_hash": "98a88347d84b2245cbe7ff545a1bbc5735aa13d42c6d48b7e436c6100c26abab", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/requestheader.adoc"}}
{"id": "sha256:222edfaf2585ebd6cf8532e4df1aeb9ccc4b2d36227fbb3e13406f3e3054bf9f", "content": "[[webflux-ann-requestparam]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/requestparam.adoc[See equivalent in the Servlet stack]#\n\nYou can use the `@RequestParam` annotation to bind query parameters to a method argument in a\ncontroller. The following code snippet shows the usage:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@RequestMapping(\"/pets\")\n\tpublic class EditPetForm {\n\n // ...\n\n @GetMapping\n public String setupForm(@RequestParam(\"petId\") int petId, Model model) { <1>\n Pet pet = this.clinic.loadPet(petId);\n model.addAttribute(\"pet\", pet);\n return \"petForm\";\n }\n\n // ...\n\t}\n----\n<1> Using `@RequestParam`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.ui.set\n\n\t@Controller\n\t@RequestMapping(\"/pets\")\n\tclass EditPetForm {\n\n // ...\n\n @GetMapping\n fun setupForm(@RequestParam(\"petId\") petId: Int, model: Model): String { // <1>\n val pet = clinic.loadPet(petId)\n model[\"pet\"] = pet\n return \"petForm\"\n }\n\n // ...\n\t}\n----\n<1> Using `@RequestParam`.\n======\n\nTIP: The Servlet API \"`request parameter`\" concept conflates query parameters, form\ndata, and multiparts into one. However, in WebFlux, each is accessed individually through\n`ServerWebExchange`. While `@RequestParam` binds to query parameters only, you can use\ndata binding to apply query parameters, form data, and multiparts to a\nxref:web/webflux/controller/ann-methods/modelattrib-method-args.adoc[command object].\n\nMethod parameters that use the `@RequestParam` annotation are required by default, but\nyou can specify that a method parameter is optional by setting the required flag of a `@RequestParam`\nto `false` or by declaring the argument with a `java.util.Optional`\nwrapper.\n\nType conversion is applied automatically if the target method parameter type is not\n`String`. See xref:web/webflux/controller/ann-methods/typeconversion.adoc[Type Conversion].\n\nWhen a `@RequestParam` annotation is declared on a `Map<String, String>` or\n`MultiValueMap<String, String>` argument, the map is populated with all query parameters.\n\nNote that use of `@RequestParam` is optional -- for example, to set its attributes. By\ndefault, any argument that is a simple value type (as determined by\n{spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty])\nand is not resolved by any other argument resolver is treated as if it were annotated\nwith `@RequestParam`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/requestparam.adoc", "title": "requestparam", "heading": "requestparam", "heading_level": 1, "file_order": 293, "section_index": 0, "content_hash": "222edfaf2585ebd6cf8532e4df1aeb9ccc4b2d36227fbb3e13406f3e3054bf9f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/requestparam.adoc"}}
{"id": "sha256:768ea20b3b2811ec81617bf4a7afd90c63a622b3ad65ef214a522081d2844a20", "content": "[[webflux-ann-responsebody]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/responsebody.adoc[See equivalent in the Servlet stack]#\n\nYou can use the `@ResponseBody` annotation on a method to have the return serialized\nto the response body through an xref:web/webflux/reactive-spring.adoc#webflux-codecs[HttpMessageWriter]. The following\nexample shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/accounts/{id}\")\n\t@ResponseBody\n\tpublic Account handle() {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/accounts/{id}\")\n\t@ResponseBody\n\tfun handle(): Account {\n // ...\n\t}\n----\n======\n\n`@ResponseBody` is also supported at the class level, in which case it is inherited by\nall controller methods. This is the effect of `@RestController`, which is nothing more\nthan a meta-annotation marked with `@Controller` and `@ResponseBody`.\n\n`@ResponseBody` supports reactive types, which means you can return Reactor or RxJava\ntypes and have the asynchronous values they produce rendered to the response.\nFor additional details, see xref:web/webflux/reactive-spring.adoc#webflux-codecs-streaming[Streaming]\nand xref:web/webflux/reactive-spring.adoc#webflux-codecs-jackson[JSON rendering].\n\nYou can combine `@ResponseBody` methods with JSON serialization views.\nSee xref:web/webflux/controller/ann-methods/jackson.adoc[Jackson JSON] for details.\n\nYou can use the xref:web/webflux/config.adoc#webflux-config-message-codecs[HTTP message codecs]\noption of the xref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[WebFlux Config]\nto configure or customize message writing.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/responsebody.adoc", "title": "responsebody", "heading": "responsebody", "heading_level": 1, "file_order": 294, "section_index": 0, "content_hash": "768ea20b3b2811ec81617bf4a7afd90c63a622b3ad65ef214a522081d2844a20", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/responsebody.adoc"}}
{"id": "sha256:be5e331a701ecfa7a199fdc8c8768c9e9e4b899c5d1cad02b833bb44f4e7dd07", "content": "[[webflux-ann-responseentity]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/responseentity.adoc[See equivalent in the Servlet stack]#\n\n`ResponseEntity` is like xref:web/webflux/controller/ann-methods/responsebody.adoc[`@ResponseBody`]\nbut with status and headers. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/something\")\n\tpublic ResponseEntity<String> handle() {\n String body = ... ;\n String etag = ... ;\n return ResponseEntity.ok().eTag(etag).body(body);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/something\")\n\tfun handle(): ResponseEntity<String> {\n val body: String = ...\n val etag: String = ...\n return ResponseEntity.ok().eTag(etag).build(body)\n\t}\n----\n======\n\nWebFlux supports using a single value xref:web/webflux-reactive-libraries.adoc[reactive type] to\nproduce the `ResponseEntity` asynchronously, and/or single and multi-value reactive types\nfor the body. This allows a variety of async responses with `ResponseEntity` as follows:\n\n* `ResponseEntity<Mono<T>>` or `ResponseEntity<Flux<T>>` make the response status and\n headers known immediately while the body is provided asynchronously at a later point.\n Use `Mono` if the body consists of 0..1 values or `Flux` if it can produce multiple values.\n* `Mono<ResponseEntity<T>>` provides all three -- response status, headers, and body,\n asynchronously at a later point. This allows the response status and headers to vary\n depending on the outcome of asynchronous request handling.\n* `Mono<ResponseEntity<Mono<T>>>` or `Mono<ResponseEntity<Flux<T>>>` are yet another\n possible, albeit less common alternative. They provide the response status and headers\n asynchronously first and then the response body, also asynchronously, second.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/responseentity.adoc", "title": "responseentity", "heading": "responseentity", "heading_level": 1, "file_order": 295, "section_index": 0, "content_hash": "be5e331a701ecfa7a199fdc8c8768c9e9e4b899c5d1cad02b833bb44f4e7dd07", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/responseentity.adoc"}}
{"id": "sha256:215f297a3d315c210b11ab366c17ceee4a6ed5052895ae3148e5fc3bdecd4329", "content": "[[webflux-ann-return-types]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/return-types.adoc[See equivalent in the Servlet stack]#\n\nThe following table shows the supported controller method return values. Note that reactive\ntypes from libraries such as Reactor, RxJava, xref:web/webflux-reactive-libraries.adoc[or other] are\ngenerally supported for all return values.\n\nFor return types like `Flux`, when multiple values are expected, elements are streamed as they come\nand are not buffered. This is the default behavior, as keeping a potentially large amount of elements in memory\nis not efficient. If the media type implies an infinite stream (for example,\n`application/json+stream`), values are written and flushed individually. Otherwise,\nvalues are written individually and the flushing happens separately.\n\nNOTE: If an error happens while an element is encoded to JSON, the response might have been written to\nand committed already and it is impossible at that point to render a proper error response.\nIn some cases, applications can choose to trade memory efficiency for better handling such errors by\nbuffering elements and encoding them all at once. Controllers can then return a `Flux<List<B>>`;\nReactor provides a dedicated operator for that, `Flux#collectList()`.\n\n[cols=\"1,2\", options=\"header\"]\n|===\n| Controller method return value | Description\n\n| `@ResponseBody`\n| The return value is encoded through `HttpMessageWriter` instances and written to the response.\n See xref:web/webflux/controller/ann-methods/responsebody.adoc[`@ResponseBody`].\n\n| `HttpEntity<B>`, `ResponseEntity<B>`\n| The return value specifies the full response, including HTTP headers, and the body is encoded\n through `HttpMessageWriter` instances and written to the response.\n See xref:web/webflux/controller/ann-methods/responseentity.adoc[`ResponseEntity`].\n\n| `HttpHeaders`\n| For returning a response with headers and no body.\n\n| `ErrorResponse`, `ProblemDetail`\n| To render an RFC 9457 error response with details in the body,\n see xref:web/webflux/ann-rest-exceptions.adoc[Error Responses]\n\n| `String`\n| A view name to be resolved with `ViewResolver` instances and used together with the implicit\n model -- determined through command objects and `@ModelAttribute` methods. The handler\n method can also programmatically enrich the model by declaring a `Model` argument\n (described xref:web/webflux/dispatcher-handler.adoc#webflux-viewresolution-handling[earlier]).\n\n| `View`\n| A `View` instance to use for rendering together with the implicit model -- determined\n through command objects and `@ModelAttribute` methods. The handler method can also\n programmatically enrich the model by declaring a `Model` argument\n (described xref:web/webflux/dispatcher-handler.adoc#webflux-viewresolution-handling[earlier]).\n\n| `java.util.Map`, `org.springframework.ui.Model`\n| Attributes to be added to the implicit model, with the view name implicitly determined\n based on the request path.\n\n| `@ModelAttribute`\n| An attribute to be added to the model, with the view name implicitly determined based\n on the request path.\n\n Note that `@ModelAttribute` is optional. See \"`Any other return value`\" later in\n this table.\n\n| `Rendering`\n| An API for model and view rendering scenarios.\n\n| `FragmentsRendering`, `Flux<Fragment>`, `Collection<Fragment>`\n| For rendering one or more fragments each with its own view and model.\n See xref:web/webflux-view.adoc#webflux-view-fragments[HTML Fragments] for more details.\n\n| `void`\n| A method with a `void`, possibly asynchronous (for example, `Mono<Void>`), return type (or a `null` return\n value) is considered to have fully handled the response if it also has a `ServerHttpResponse`,\n a `ServerWebExchange` argument, or an `@ResponseStatus` annotation. The same is also true\n if the controller has made a positive ETag or `lastModified` timestamp check.\n See xref:web/webflux/caching.adoc#webflux-caching-etag-lastmodified[Controllers] for details.\n\n If none of the above is true, a `void` return type can also indicate \"`no response body`\" for\n REST controllers or default view name selection for HTML controllers.\n\n| `Flux<ServerSentEvent>`, `Observable<ServerSentEvent>`, or other reactive type\n| Emit server-sent events. The `ServerSentEvent` wrapper can be omitted when only data needs\n to be written (however, `text/event-stream` must be requested or declared in the mapping\n through the `produces` attribute).\n\n| Other return values\n| If a return value remains unresolved in any other way, it is treated as a model\n attribute, unless it is a simple type as determined by\n {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty],\n in which case it remains unresolved.\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/return-types.adoc", "title": "return-types", "heading": "return-types", "heading_level": 1, "file_order": 296, "section_index": 0, "content_hash": "215f297a3d315c210b11ab366c17ceee4a6ed5052895ae3148e5fc3bdecd4329", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/return-types.adoc"}}
{"id": "sha256:848b021a109970efd5b4c8ab1d6939018a80bb8f3b027e85d62ef14d98cbaf32", "content": "[[webflux-ann-sessionattribute]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/sessionattribute.adoc[See equivalent in the Servlet stack]#\n\nIf you need access to pre-existing session attributes that are managed globally\n(that is, outside the controller -- for example, by a filter) and may or may not be present,\nyou can use the `@SessionAttribute` annotation on a method parameter, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/\")\n\tpublic String handle(@SessionAttribute User user) { // <1>\n // ...\n\t}\n----\n<1> Using `@SessionAttribute`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/\")\n\tfun handle(@SessionAttribute user: User): String { // <1>\n // ...\n\t}\n----\n<1> Using `@SessionAttribute`.\n======\n\nFor use cases that require adding or removing session attributes, consider injecting\n`WebSession` into the controller method.\n\nFor temporary storage of model attributes in the session as part of a controller\nworkflow, consider using `SessionAttributes`, as described in\nxref:web/webflux/controller/ann-methods/sessionattributes.adoc[`@SessionAttributes`].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/sessionattribute.adoc", "title": "sessionattribute", "heading": "sessionattribute", "heading_level": 1, "file_order": 297, "section_index": 0, "content_hash": "848b021a109970efd5b4c8ab1d6939018a80bb8f3b027e85d62ef14d98cbaf32", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/sessionattribute.adoc"}}
{"id": "sha256:a1bc041d1649f977b345a70ef2ddbd3d7c346d9b0e58bb32b169a280b876650c", "content": "[[webflux-ann-sessionattributes]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/sessionattributes.adoc[See equivalent in the Servlet stack]#\n\n`@SessionAttributes` is used to store model attributes in the `WebSession` between\nrequests. It is a type-level annotation that declares session attributes used by a\nspecific controller. This typically lists the names of model attributes or types of\nmodel attributes that should be transparently stored in the session for subsequent\nrequests to access.\n\nConsider the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@SessionAttributes(\"pet\") <1>\n\tpublic class EditPetForm {\n // ...\n\t}\n----\n<1> Using the `@SessionAttributes` annotation.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@SessionAttributes(\"pet\") // <1>\n\tclass EditPetForm {\n // ...\n\t}\n----\n<1> Using the `@SessionAttributes` annotation.\n======\n\nOn the first request, when a model attribute with the name, `pet`, is added to the model,\nit is automatically promoted to and saved in the `WebSession`. It remains there until\nanother controller method uses a `SessionStatus` method argument to clear the storage,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@SessionAttributes(\"pet\") // <1>\n\tpublic class EditPetForm {\n\n // ...\n\n @PostMapping(\"/pets/{id}\")\n public String handle(Pet pet, BindingResult errors, SessionStatus status) { // <2>\n if (errors.hasErrors()) {\n // ...\n }\n status.setComplete();\n // ...\n }\n }\n\t}\n----\n<1> Using the `@SessionAttributes` annotation.\n<2> Using a `SessionStatus` variable.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@SessionAttributes(\"pet\") // <1>\n\tclass EditPetForm {\n\n // ...\n\n @PostMapping(\"/pets/{id}\")\n fun handle(pet: Pet, errors: BindingResult, status: SessionStatus): String { // <2>\n if (errors.hasErrors()) {\n // ...\n }\n status.setComplete()\n // ...\n }\n\t}\n----\n<1> Using the `@SessionAttributes` annotation.\n<2> Using a `SessionStatus` variable.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/sessionattributes.adoc", "title": "sessionattributes", "heading": "sessionattributes", "heading_level": 1, "file_order": 298, "section_index": 0, "content_hash": "a1bc041d1649f977b345a70ef2ddbd3d7c346d9b0e58bb32b169a280b876650c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/sessionattributes.adoc"}}
{"id": "sha256:36b5100692200cf31576e30b471e8cb576fe8ef9a124d453c97cc7a53c6081a3", "content": "[[webflux-ann-typeconversion]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods/typeconversion.adoc[See equivalent in the Servlet stack]#\n\nSome annotated controller method arguments that represent String-based request input (for example,\n`@RequestParam`, `@RequestHeader`, `@PathVariable`, `@MatrixVariable`, and `@CookieValue`)\ncan require type conversion if the argument is declared as something other than `String`.\n\nFor such cases, type conversion is automatically applied based on the configured converters.\nBy default, simple types (such as `int`, `long`, `Date`, and others) are supported. Type conversion\ncan be customized through a `WebDataBinder` (see xref:web/webflux/controller/ann-initbinder.adoc[`DataBinder`])\nor by registering `Formatters` with the `FormattingConversionService` (see\nxref:core/validation/format.adoc[Spring Field Formatting]).\n\nA practical issue in type conversion is the treatment of an empty String source value.\nSuch a value is treated as missing if it becomes `null` as a result of type conversion.\nThis can be the case for `Long`, `UUID`, and other target types. If you want to allow `null`\nto be injected, either use the `required` flag on the argument annotation, or declare the\nargument as `@Nullable`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/typeconversion.adoc", "title": "typeconversion", "heading": "typeconversion", "heading_level": 1, "file_order": 299, "section_index": 0, "content_hash": "36b5100692200cf31576e30b471e8cb576fe8ef9a124d453c97cc7a53c6081a3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods/typeconversion.adoc"}}
{"id": "sha256:b600718009a2d5844f791f58c34d690183459d5045e391ccc4bd728492f9f666", "content": "[[webflux-ann-controller-advice]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-advice.adoc[See equivalent in the Servlet stack]#\n\nTypically, the `@ExceptionHandler`, `@InitBinder`, and `@ModelAttribute` methods apply\nwithin the `@Controller` class (or class hierarchy) in which they are declared. If you\nwant such methods to apply more globally (across controllers), you can declare them in a\nclass annotated with `@ControllerAdvice` or `@RestControllerAdvice`.\n\n`@ControllerAdvice` is annotated with `@Component`, which means that such classes can be\nregistered as Spring beans through xref:core/beans/java/instantiating-container.adoc#beans-java-instantiating-container-scan[component scanning]\n. `@RestControllerAdvice` is a composed annotation that is annotated\nwith both `@ControllerAdvice` and `@ResponseBody`, which essentially means\n`@ExceptionHandler` methods are rendered to the response body through message conversion\n(versus view resolution or template rendering).\n\nOn startup, the infrastructure classes for `@RequestMapping` and `@ExceptionHandler`\nmethods detect Spring beans annotated with `@ControllerAdvice` and then apply their\nmethods at runtime. Global `@ExceptionHandler` methods (from a `@ControllerAdvice`) are\napplied _after_ local ones (from the `@Controller`). By contrast, global `@ModelAttribute`\nand `@InitBinder` methods are applied _before_ local ones.\n\nBy default, `@ControllerAdvice` methods apply to every request (that is, all controllers),\nbut you can narrow that down to a subset of controllers by using attributes on the\nannotation, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Target all Controllers annotated with @RestController\n\t@ControllerAdvice(annotations = RestController.class)\n\tpublic class ExampleAdvice1 {}\n\n\t// Target all Controllers within specific packages\n\t@ControllerAdvice(\"org.example.controllers\")\n\tpublic class ExampleAdvice2 {}\n\n\t// Target all Controllers assignable to specific classes\n\t@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})\n\tpublic class ExampleAdvice3 {}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Target all Controllers annotated with @RestController\n\t@ControllerAdvice(annotations = [RestController::class])\n\tpublic class ExampleAdvice1 {}\n\n\t// Target all Controllers within specific packages\n\t@ControllerAdvice(\"org.example.controllers\")\n\tpublic class ExampleAdvice2 {}\n\n\t// Target all Controllers assignable to specific classes\n\t@ControllerAdvice(assignableTypes = [ControllerInterface::class, AbstractController::class])\n\tpublic class ExampleAdvice3 {}\n----\n======\n\nThe selectors in the preceding example are evaluated at runtime and may negatively impact\nperformance if used extensively. See the\n{spring-framework-api}/web/bind/annotation/ControllerAdvice.html[`@ControllerAdvice`]\njavadoc for more details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-advice.adoc", "title": "ann-advice", "heading": "ann-advice", "heading_level": 1, "file_order": 300, "section_index": 0, "content_hash": "b600718009a2d5844f791f58c34d690183459d5045e391ccc4bd728492f9f666", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-advice.adoc"}}
{"id": "sha256:b8e3cf3d61fdca53df91bece21c992bebb236188e24790b227ec52f9a484df3f", "content": "[[webflux-ann-controller-exceptions]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-exceptionhandler.adoc[See equivalent in the Servlet stack]#\n\n`@Controller` and xref:web/webflux/controller/ann-advice.adoc[@ControllerAdvice] classes can have\n`@ExceptionHandler` methods to handle exceptions from controller methods. The following\nexample includes such a handler method:\n\ninclude-code::./SimpleController[indent=0]\n\nThe exception can match against a top-level exception being propagated (that is, a direct\n`IOException` being thrown) or against the immediate cause within a top-level wrapper\nexception (for example, an `IOException` wrapped inside an `IllegalStateException`).\n\nFor matching exception types, preferably declare the target exception as a method argument,\nas shown in the preceding example. Alternatively, the annotation declaration can narrow the\nexception types to match. We generally recommend being as specific as possible in the\nargument signature and to declare your primary root exception mappings on a\n`@ControllerAdvice` prioritized with a corresponding order.\nSee xref:web/webmvc/mvc-controller/ann-exceptionhandler.adoc[the MVC section] for details.\n\nNOTE: An `@ExceptionHandler` method in WebFlux supports the same method arguments and\nreturn values as a `@RequestMapping` method, with the exception of request body-\nand `@ModelAttribute`-related method arguments.\n\nSupport for `@ExceptionHandler` methods in Spring WebFlux is provided by the\n`HandlerAdapter` for `@RequestMapping` methods. See xref:web/webflux/dispatcher-handler.adoc[`DispatcherHandler`]\nfor more detail.\n\n[[webflux-ann-exceptionhandler-media]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-exceptions.adoc", "title": "ann-exceptions", "heading": "ann-exceptions", "heading_level": 1, "file_order": 301, "section_index": 0, "content_hash": "b8e3cf3d61fdca53df91bece21c992bebb236188e24790b227ec52f9a484df3f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-exceptions.adoc"}}
{"id": "sha256:3029f2bf3a8d9595a9456fc5824b90d5b654e721985d4215cb57cbc0f5b64d2c", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-exceptionhandler.adoc#mvc-ann-exceptionhandler-media[See equivalent in the Servlet stack]#\n\nIn addition to exception types, `@ExceptionHandler` methods can also declare producible media types.\nThis allows to refine error responses depending on the media types requested by HTTP clients, typically in the \"Accept\" HTTP request header.\n\nApplications can declare producible media types directly on annotations, for the same exception type:\n\ninclude-code::./MediaTypeController[tag=mediatype,indent=0]\n\nHere, methods handle the same exception type but will not be rejected as duplicates.\nInstead, API clients requesting \"application/json\" will receive a JSON error, and browsers will get an HTML error view.\nEach `@ExceptionHandler` annotation can declare several producible media types,\nthe content negotiation during the error handling phase will decide which content type will be used.\n\n[[webflux-ann-exceptionhandler-args]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-exceptions.adoc", "title": "ann-exceptions", "heading": "Media Type Mapping", "heading_level": 2, "file_order": 301, "section_index": 1, "content_hash": "3029f2bf3a8d9595a9456fc5824b90d5b654e721985d4215cb57cbc0f5b64d2c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-exceptions.adoc"}}
{"id": "sha256:b382bcb1e423820f8c7f73acbeccdcc8aa4a8e0a1132f9333d028943aa7fb985", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-exceptionhandler.adoc#mvc-ann-exceptionhandler-args[See equivalent in the Servlet stack]#\n\n`@ExceptionHandler` methods support the same xref:web/webflux/controller/ann-methods/arguments.adoc[method arguments]\nas `@RequestMapping` methods, except the request body might have been consumed already.\n\n[[webflux-ann-exceptionhandler-return-values]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-exceptions.adoc", "title": "ann-exceptions", "heading": "Method Arguments", "heading_level": 2, "file_order": 301, "section_index": 2, "content_hash": "b382bcb1e423820f8c7f73acbeccdcc8aa4a8e0a1132f9333d028943aa7fb985", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-exceptions.adoc"}}
{"id": "sha256:b41ef4c36899c0ad23f7bf487efa695774063cc9814798c874562299c8d4ae42", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-exceptionhandler.adoc#mvc-ann-exceptionhandler-return-values[See equivalent in the Servlet stack]#\n\n`@ExceptionHandler` methods support the same xref:web/webflux/controller/ann-methods/return-types.adoc[return values]\nas `@RequestMapping` methods.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-exceptions.adoc", "title": "ann-exceptions", "heading": "Return Values", "heading_level": 2, "file_order": 301, "section_index": 3, "content_hash": "b41ef4c36899c0ad23f7bf487efa695774063cc9814798c874562299c8d4ae42", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-exceptions.adoc"}}
{"id": "sha256:d997a3c57aec5e7a8814585f2dd80660519370deb66d4e9312d1a14662a14e1b", "content": "[[webflux-ann-initbinder]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-initbinder.adoc[See equivalent in the Servlet stack]#\n\n`@Controller` or `@ControllerAdvice` classes can have `@InitBinder` methods to\ninitialize `WebDataBinder` instances that in turn can:\n\n* Bind request parameters to a model object.\n* Convert request values from string to object property types.\n* Format model object properties as strings when rendering HTML forms.\n\nIn an `@Controller`, `DataBinder` customizations apply locally within the controller,\nor even to a specific model attribute referenced by name through the annotation.\nIn an `@ControllerAdvice` customizations can apply to all or a subset of controllers.\n\nYou can register `PropertyEditor`, `Converter`, and `Formatter` components in the\n`DataBinder` for type conversion. Alternatively, you can use the\nxref:web/webflux/config.adoc#webflux-config-conversion[WebFlux config] to register\n`Converter` and `Formatter` components in a globally shared `FormattingConversionService`.\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class FormController {\n\n @InitBinder // <1>\n public void initBinder(WebDataBinder binder) {\n SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n dateFormat.setLenient(false);\n binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n }\n\n // ...\n\t}\n----\n<1> Using the `@InitBinder` annotation.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tclass FormController {\n\n @InitBinder // <1>\n fun initBinder(binder: WebDataBinder) {\n val dateFormat = SimpleDateFormat(\"yyyy-MM-dd\")\n dateFormat.isLenient = false\n binder.registerCustomEditor(Date::class.java, CustomDateEditor(dateFormat, false))\n }\n\n // ...\n\t}\n----\n<1> Using the `@InitBinder` annotation.\n======\n--\n\nAlternatively, when using a `Formatter`-based setup through a shared\n`FormattingConversionService`, you could re-use the same approach and register\ncontroller-specific `Formatter` instances, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class FormController {\n\n @InitBinder\n protected void initBinder(WebDataBinder binder) {\n binder.addCustomFormatter(new DateFormatter(\"yyyy-MM-dd\")); <1>\n }\n\n // ...\n\t}\n----\n<1> Adding a custom formatter (a `DateFormatter`, in this case).\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tclass FormController {\n\n @InitBinder\n fun initBinder(binder: WebDataBinder) {\n binder.addCustomFormatter(DateFormatter(\"yyyy-MM-dd\")) // <1>\n }\n\n // ...\n\t}\n----\n<1> Adding a custom formatter (a `DateFormatter`, in this case).\n======\n--\n\n[[webflux-ann-initbinder-model-design]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-initbinder.adoc", "title": "ann-initbinder", "heading": "ann-initbinder", "heading_level": 1, "file_order": 302, "section_index": 0, "content_hash": "d997a3c57aec5e7a8814585f2dd80660519370deb66d4e9312d1a14662a14e1b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-initbinder.adoc"}}
{"id": "sha256:f65bd57f7ffbddb84338b03ec9767179f91a19bdafb795d265ecf57bc12de4f8", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-initbinder.adoc#mvc-ann-initbinder-model-design[See equivalent in the Servlet stack]#\n\nxref:core/validation/data-binding.adoc[Data binding] for web requests involves\nbinding request parameters to a model object. By default, request parameters can be bound\nto any public property of the model object, which means malicious clients can provide\nextra values for properties that exist in the model object graph, but are not expected to\nbe set. This is why model object design requires careful consideration.\n\nTIP: The model object, and its nested object graph is also sometimes referred to as a\n_command object_, _form-backing object_, or _POJO_ (Plain Old Java Object).\n\nA good practice is to use a _dedicated model object_ rather than exposing your domain\nmodel such as JPA or Hibernate entities for web data binding. For example, on a form to\nchange an email address, create a `ChangeEmailForm` model object that declares only\nthe properties required for the input:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ChangeEmailForm {\n\n\t\tprivate String oldEmailAddress;\n\t\tprivate String newEmailAddress;\n\n\t\tpublic void setOldEmailAddress(String oldEmailAddress) {\n\t\t\tthis.oldEmailAddress = oldEmailAddress;\n\t\t}\n\n\t\tpublic String getOldEmailAddress() {\n\t\t\treturn this.oldEmailAddress;\n\t\t}\n\n\t\tpublic void setNewEmailAddress(String newEmailAddress) {\n\t\t\tthis.newEmailAddress = newEmailAddress;\n\t\t}\n\n\t\tpublic String getNewEmailAddress() {\n\t\t\treturn this.newEmailAddress;\n\t\t}\n\n\t}\n----\n\nAnother good practice is to apply\nxref:core/validation/data-binding.adoc#data-binding-constructor-binding[constructor binding],\nwhich uses only the request parameters it needs for constructor arguments, and any other\ninput is ignored. This is in contrast to property binding which by default binds every\nrequest parameter for which there is a matching property.\n\nIf neither a dedicated model object nor constructor binding is sufficient, and you must\nuse property binding, we strongly recommend registering `allowedFields` patterns (case\nsensitive) on `WebDataBinder` in order to prevent unexpected properties from being set.\nFor example:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class ChangeEmailController {\n\n\t\t@InitBinder\n\t\tvoid initBinder(WebDataBinder binder) {\n\t\t\tbinder.setAllowedFields(\"oldEmailAddress\", \"newEmailAddress\");\n\t\t}\n\n\t\t// @RequestMapping methods, etc.\n\n\t}\n----\n\nYou can also register `disallowedFields`  patterns (case insensitive). However,\n\"allowed\" configuration is preferred over \"disallowed\" as it is more explicit and less\nprone to mistakes.\n\nBy default, constructor and property binding are both used. If you want to use\nconstructor binding only, you can set the `declarativeBinding` flag on `WebDataBinder`\nthrough an `@InitBinder` method either locally within a controller or globally through an\n`@ControllerAdvice`. Turning this flag on ensures that only constructor binding is used\nand that property binding is not used unless `allowedFields` patterns are configured.\nFor example:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class MyController {\n\n\t\t@InitBinder\n\t\tvoid initBinder(WebDataBinder binder) {\n\t\t\tbinder.setDeclarativeBinding(true);\n\t\t}\n\n\t\t// @RequestMapping methods, etc.\n\n\t}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-initbinder.adoc", "title": "ann-initbinder", "heading": "Model Design", "heading_level": 2, "file_order": 302, "section_index": 1, "content_hash": "f65bd57f7ffbddb84338b03ec9767179f91a19bdafb795d265ecf57bc12de4f8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-initbinder.adoc"}}
{"id": "sha256:d1dd587fad6a47662cb4aec268c61079adad1f881cc5ca84b8ecced072f4d3fb", "content": "[[webflux-ann-methods]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-methods.adoc[See equivalent in the Servlet stack]#\n\n`@RequestMapping` handler methods have a flexible signature and can choose from a range of\nsupported controller method arguments and return values.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods.adoc", "title": "ann-methods", "heading": "ann-methods", "heading_level": 1, "file_order": 303, "section_index": 0, "content_hash": "d1dd587fad6a47662cb4aec268c61079adad1f881cc5ca84b8ecced072f4d3fb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-methods.adoc"}}
{"id": "sha256:35bfc8cfb05c84f7392af3939bd0f76b9b329b38c94c4fbffc3c1d31d374f453", "content": "[[webflux-ann-modelattrib-methods]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-modelattrib-methods.adoc[See equivalent in the Servlet stack]#\n\nYou can use the `@ModelAttribute` annotation:\n\n* On a xref:web/webflux/controller/ann-methods/modelattrib-method-args.adoc[method argument]\nin `@RequestMapping` methods to create or access an Object from the model and to bind it\nto the request through a `WebDataBinder`.\n* As a method-level annotation in `@Controller` or `@ControllerAdvice` classes, helping\nto initialize the model prior to any `@RequestMapping` method invocation.\n* On a `@RequestMapping` method to mark its return value as a model attribute.\n\nThis section discusses `@ModelAttribute` methods, or the second item from the preceding list.\nA controller can have any number of `@ModelAttribute` methods. All such methods are\ninvoked before `@RequestMapping` methods in the same controller. A `@ModelAttribute`\nmethod can also be shared across controllers through `@ControllerAdvice`. See the section on\nxref:web/webflux/controller/ann-advice.adoc[Controller Advice] for more details.\n\n`@ModelAttribute` methods have flexible method signatures. They support many of the same\narguments as `@RequestMapping` methods (except for `@ModelAttribute` itself and anything\nrelated to the request body).\n\nThe following example uses a `@ModelAttribute` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ModelAttribute\n\tpublic void populateModel(@RequestParam String number, Model model) {\n model.addAttribute(accountRepository.findAccount(number));\n // add more ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ModelAttribute\n\tfun populateModel(@RequestParam number: String, model: Model) {\n model.addAttribute(accountRepository.findAccount(number))\n // add more ...\n\t}\n----\n======\n\nThe following example adds one attribute only:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ModelAttribute\n\tpublic Account addAccount(@RequestParam String number) {\n return accountRepository.findAccount(number);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ModelAttribute\n\tfun addAccount(@RequestParam number: String): Account {\n return accountRepository.findAccount(number);\n\t}\n----\n======\n\nNOTE: When a name is not explicitly specified, a default name is chosen based on the type,\nas explained in the javadoc for {spring-framework-api}/core/Conventions.html[`Conventions`].\nYou can always assign an explicit name by using the overloaded `addAttribute` method or\nthrough the name attribute on `@ModelAttribute` (for a return value).\n\nSpring WebFlux, unlike Spring MVC, explicitly supports reactive types in the model\n(for example, `Mono<Account>` or `io.reactivex.Single<Account>`). Such asynchronous model\nattributes can be transparently resolved (and the model updated) to their actual values\nat the time of `@RequestMapping` invocation, provided a `@ModelAttribute` argument is\ndeclared without a wrapper, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ModelAttribute\n\tpublic void addAccount(@RequestParam String number) {\n Mono<Account> accountMono = accountRepository.findAccount(number);\n model.addAttribute(\"account\", accountMono);\n\t}\n\n\t@PostMapping(\"/accounts\")\n\tpublic String handle(@ModelAttribute Account account, BindingResult errors) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.ui.set\n\n\t@ModelAttribute\n\tfun addAccount(@RequestParam number: String) {\n val accountMono: Mono<Account> = accountRepository.findAccount(number)\n model[\"account\"] = accountMono\n\t}\n\n\t@PostMapping(\"/accounts\")\n\tfun handle(@ModelAttribute account: Account, errors: BindingResult): String {\n // ...\n\t}\n----\n======\n\nIn addition, any model attributes that have a reactive type wrapper are resolved to their\nactual values (and the model updated) just prior to view rendering.\n\nYou can also use `@ModelAttribute` as a method-level annotation on `@RequestMapping`\nmethods, in which case the return value of the `@RequestMapping` method is interpreted as a\nmodel attribute. This is typically not required, as it is the default behavior in HTML\ncontrollers, unless the return value is a `String` that would otherwise be interpreted\nas a view name. `@ModelAttribute` can also help to customize the model attribute name,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/accounts/{id}\")\n\t@ModelAttribute(\"myAccount\")\n\tpublic Account handle() {\n // ...\n return account;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/accounts/{id}\")\n\t@ModelAttribute(\"myAccount\")\n\tfun handle(): Account {\n // ...\n return account\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-modelattrib-methods.adoc", "title": "ann-modelattrib-methods", "heading": "ann-modelattrib-methods", "heading_level": 1, "file_order": 304, "section_index": 0, "content_hash": "35bfc8cfb05c84f7392af3939bd0f76b9b329b38c94c4fbffc3c1d31d374f453", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-modelattrib-methods.adoc"}}
{"id": "sha256:fca5816e81e394c6355041de4d9651195fcb9eb47b98f3082bfe5970d8f502c0", "content": "[[webflux-ann-requestmapping]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc[See equivalent in the Servlet stack]#\n\nThis section discusses request mapping for annotated controllers.\n\n[[webflux-ann-requestmapping-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "ann-requestmapping", "heading_level": 1, "file_order": 305, "section_index": 0, "content_hash": "fca5816e81e394c6355041de4d9651195fcb9eb47b98f3082bfe5970d8f502c0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc"}}
{"id": "sha256:8d720579d6037417445dadf8823c81ac97a7a771f4b77b4ae76a2222e0b9b009", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-annotation[See equivalent in the Servlet stack]#\n\nThe `@RequestMapping` annotation is used to map requests to controllers methods. It has\nvarious attributes to match by URL, HTTP method, request parameters, headers, and media\ntypes. You can use it at the class level to express shared mappings or at the method level\nto narrow down to a specific endpoint mapping.\n\nThere are also HTTP method specific shortcut variants of `@RequestMapping`:\n\n* `@GetMapping`\n* `@PostMapping`\n* `@PutMapping`\n* `@DeleteMapping`\n* `@PatchMapping`\n\nThe preceding annotations are xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-composed[Custom Annotations] that are provided\nbecause, arguably, most controller methods should be mapped to a specific HTTP method versus\nusing `@RequestMapping`, which, by default, matches to all HTTP methods. At the same time, a\n`@RequestMapping` is still needed at the class level to express shared mappings.\n\nNOTE: `@RequestMapping` cannot be used in conjunction with other `@RequestMapping`\nannotations that are declared on the same element (class, interface, or method). If\nmultiple `@RequestMapping` annotations are detected on the same element, a warning will\nbe logged, and only the first mapping will be used. This also applies to composed\n`@RequestMapping` annotations such as `@GetMapping`, `@PostMapping`, etc.\n\nThe following example uses type and method level mappings:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\t@RequestMapping(\"/persons\")\n\tclass PersonController {\n\n @GetMapping(\"/{id}\")\n public Person getPerson(@PathVariable Long id) {\n // ...\n }\n\n @PostMapping\n @ResponseStatus(HttpStatus.CREATED)\n public void add(@RequestBody Person person) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\t@RequestMapping(\"/persons\")\n\tclass PersonController {\n\n @GetMapping(\"/{id}\")\n fun getPerson(@PathVariable id: Long): Person {\n // ...\n }\n\n @PostMapping\n @ResponseStatus(HttpStatus.CREATED)\n fun add(@RequestBody person: Person) {\n // ...\n }\n\t}\n----\n======\n\n[[webflux-ann-requestmapping-uri-templates]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "`@RequestMapping`", "heading_level": 2, "file_order": 305, "section_index": 1, "content_hash": "8d720579d6037417445dadf8823c81ac97a7a771f4b77b4ae76a2222e0b9b009", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc"}}
{"id": "sha256:7f28e62482ba4d9ba6331114703cc19a465c282de283a4fec9ed6ed9c9cef887", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-uri-templates[See equivalent in the Servlet stack]#\n\nYou can map requests by using glob patterns and wildcards:\n\n[cols=\"2,3,5\"]\n|===\n|Pattern |Description |Example\n\n| `spring`\n| Literal pattern\n| `+\"/spring\"+` matches `+\"/spring\"+`\n\n| `+?+`\n| Matches one character\n| `+\"/pages/t?st.html\"+` matches `+\"/pages/test.html\"+` and `+\"/pages/t3st.html\"+`\n\n| `+*+`\n| Matches zero or more characters within a path segment\n| `+\"/resources/*.png\"+` matches `+\"/resources/file.png\"+`\n\n`+\"/projects/*/versions\"+` matches `+\"/projects/spring/versions\"+` but does not match `+\"/projects/spring/boot/versions\"+`.\n\n`+\"/projects/*\"+` matches `+\"/projects/spring\"+` but does not match `+\"/projects\"+` as the path segment is not present.\n\n| `+**+`\n| Matches zero or more path segments\n| `+\"/resources/**\"+` matches `+\"/resources\"+`, `+\"/resources/file.png\"+` and `+\"/resources/images/file.png\"+`\n\n`+\"/**/info\"+` matches `+\"/info\"+`, `+\"/spring/info\"+` and `+\"/spring/framework/info\"+`\n\n`+\"/resources/**/file.png\"+` is invalid as `+**+` is not allowed in the middle of the path.\n\n`+\"/**/spring/**\"+` is not allowed, as only a single `+**+`/`+{*path}+` instance is allowed per pattern.\n\n| `+{name}+`\n| Similar to `+*+`, but also captures the path segment as a variable named \"name\"\n| `+\"/projects/{project}/versions\"+` matches `+\"/projects/spring/versions\"+` and captures `+project=spring+`\n\n`+\"/projects/{project}/versions\"+` does not match `+\"/projects/spring/framework/versions\"+` as it captures a single path segment.\n\n| `{name:[a-z]+}`\n| Matches the regexp `\"[a-z]+\"` as a path variable named \"name\"\n| `\"/projects/{project:[a-z]+}/versions\"` matches `\"/projects/spring/versions\"` but not `\"/projects/spring1/versions\"`\n\n| `+{*path}+`\n| Similar to `+**+`, but also captures the path segments as a variable named \"path\"\n| `+\"/resources/{*file}\"+` matches `+\"/resources/images/file.png\"+` and captures `+file=/images/file.png+`\n\n`+\"{*path}/resources\"+` matches `+\"/spring/framework/resources\"+` and captures `+path=/spring/framework+`\n\n`+\"/resources/{*path}/file.png\"+` is invalid as `{*path}` is not allowed in the middle of the path.\n\n`+\"/{*path}/spring/**\"+` is not allowed, as only a single `+**+`/`+{*path}+` instance is allowed per pattern.\n\n|===\n\nCaptured URI variables can be accessed with `@PathVariable`, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n\tpublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n\tfun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {\n // ...\n\t}\n----\n======\n--\n\nYou can declare URI variables at the class and method levels, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@RequestMapping(\"/owners/{ownerId}\") // <1>\n\tpublic class OwnerController {\n\n @GetMapping(\"/pets/{petId}\") // <2>\n public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n // ...\n }\n\t}\n----\n<1> Class-level URI mapping.\n<2> Method-level URI mapping.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@RequestMapping(\"/owners/{ownerId}\") // <1>\n\tclass OwnerController {\n\n @GetMapping(\"/pets/{petId}\") // <2>\n fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {\n // ...\n }\n\t}\n----\n<1> Class-level URI mapping.\n<2> Method-level URI mapping.\n======\n--\n\nURI variables are automatically converted to the appropriate type or a `TypeMismatchException`\nis raised. Simple types (`int`, `long`, `Date`, and so on) are supported by default and you can\nregister support for any other data type.\nSee xref:web/webflux/controller/ann-methods/typeconversion.adoc[Type Conversion] and xref:web/webflux/controller/ann-initbinder.adoc[`DataBinder`].\n\nURI variables can be named explicitly (for example, `@PathVariable(\"customId\")`), but you can\nleave that detail out if the names are the same and you compile your code with the `-parameters`\ncompiler flag.\n\nThe syntax `{*varName}` declares a URI variable that matches zero or more remaining path\nsegments. For example `/resources/{*path}` matches all files under `/resources/`, and the\n`\"path\"` variable captures the complete path under `/resources`.\n\nThe syntax `{varName:regex}` declares a URI variable with a regular expression that has the\nsyntax: `{varName:regex}`. For example, given a URL of `/spring-web-3.0.5.jar`, the following method\nextracts the name, version, and file extension:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}\")\n\tpublic void handle(@PathVariable String version, @PathVariable String ext) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}\")\n\tfun handle(@PathVariable version: String, @PathVariable ext: String) {\n // ...\n\t}\n----\n======\n--\n\nURI path patterns can also have:\n\n- Embedded `${...}` placeholders that are resolved on startup via\n`PropertySourcesPlaceholderConfigurer` against local, system, environment, and\nother property sources. This is useful, for example, to parameterize a base URL based on\nexternal configuration.\n- SpEL expressions `#{...}`.\n\nNOTE: Spring WebFlux uses `PathPattern` and the `PathPatternParser` for URI path matching support.\nBoth classes are located in `spring-web` and are expressly designed for use with HTTP URL\npaths in web applications where a large number of URI path patterns are matched at runtime.\n\nSpring WebFlux does not support suffix pattern matching -- unlike Spring MVC, where a\nmapping such as `/person` also matches to `/person.{asterisk}`. For URL-based content\nnegotiation, if needed, we recommend using a query parameter, which is simpler, more\nexplicit, and less vulnerable to URL path based exploits.\n\n[[webflux-ann-requestmapping-pattern-comparison]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "URI Patterns", "heading_level": 2, "file_order": 305, "section_index": 2, "content_hash": "7f28e62482ba4d9ba6331114703cc19a465c282de283a4fec9ed6ed9c9cef887", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc"}}
{"id": "sha256:a2277df540bcedfe7ab6616ef4eb0ef7b290e5a8fe7d981417d1d9d38acb6a64", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-pattern-comparison[See equivalent in the Servlet stack]#\n\nWhen multiple patterns match a URL, they must be compared to find the best match. This is done\nwith `PathPattern.SPECIFICITY_COMPARATOR`, which looks for patterns that are more specific.\n\nFor every pattern, a score is computed, based on the number of URI variables and wildcards,\nwhere a URI variable scores lower than a wildcard. A pattern with a lower total score\nwins. If two patterns have the same score, the longer is chosen.\n\nCatch-all patterns (for example, `**`, `{*varName}`) are excluded from the scoring and are always\nsorted last instead. If two patterns are both catch-all, the longer is chosen.\n\n[[webflux-ann-requestmapping-consumes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Pattern Comparison", "heading_level": 2, "file_order": 305, "section_index": 3, "content_hash": "a2277df540bcedfe7ab6616ef4eb0ef7b290e5a8fe7d981417d1d9d38acb6a64", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc"}}
{"id": "sha256:d1c46543cb912a019b70fed3441ecaea84b7a21c01ca0438d279014580c7d10c", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-consumes[See equivalent in the Servlet stack]#\n\nYou can narrow the request mapping based on the `Content-Type` of the request,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(path = \"/pets\", consumes = \"application/json\")\n\tpublic void addPet(@RequestBody Pet pet) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/pets\", consumes = [\"application/json\"])\n\tfun addPet(@RequestBody pet: Pet) {\n // ...\n\t}\n----\n======\n\nThe consumes attribute also supports negation expressions -- for example, `!text/plain` means any\ncontent type other than `text/plain`.\n\nYou can declare a shared `consumes` attribute at the class level. Unlike most other request\nmapping attributes, however, when used at the class level, a method-level `consumes` attribute\noverrides rather than extends the class-level declaration.\n\nTIP: `MediaType` provides constants for commonly used media types -- for example,\n`APPLICATION_JSON_VALUE` and `APPLICATION_XML_VALUE`.\n\n[[webflux-ann-requestmapping-produces]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Consumable Media Types", "heading_level": 2, "file_order": 305, "section_index": 4, "content_hash": "d1c46543cb912a019b70fed3441ecaea84b7a21c01ca0438d279014580c7d10c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc"}}
{"id": "sha256:babcb02ba0f3716f572b23ecf046ce7feffb2d24b00ffd5f794f1c1888598099", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-produces[See equivalent in the Servlet stack]#\n\nYou can narrow the request mapping based on the `Accept` request header and the list of\ncontent types that a controller method produces, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(path = \"/pets/{petId}\", produces = \"application/json\")\n\t@ResponseBody\n\tpublic Pet getPet(@PathVariable String petId) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/pets/{petId}\", produces = [\"application/json\"])\n\t@ResponseBody\n\tfun getPet(@PathVariable petId: String): Pet {\n // ...\n\t}\n----\n======\n\nThe media type can specify a character set. Negated expressions are supported -- for example,\n`!text/plain` means any content type other than `text/plain`.\n\nYou can declare a shared `produces` attribute at the class level. Unlike most other request\nmapping attributes, however, when used at the class level, a method-level `produces` attribute\noverrides rather than extend the class level declaration.\n\nTIP: `MediaType` provides constants for commonly used media types -- for example,\n`APPLICATION_JSON_VALUE`, `APPLICATION_XML_VALUE`.\n\n[[webflux-ann-requestmapping-params-and-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Producible Media Types", "heading_level": 2, "file_order": 305, "section_index": 5, "content_hash": "babcb02ba0f3716f572b23ecf046ce7feffb2d24b00ffd5f794f1c1888598099", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc"}}
{"id": "sha256:f6dc84645317d2693c7741b678b3651a2057b62d97055a735ce3597c9c59a5aa", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-params-and-headers[See equivalent in the Servlet stack]#\n\nYou can narrow request mappings based on query parameter conditions. You can test for the\npresence of a query parameter (`myParam`), for its absence (`!myParam`), or for a\nspecific value (`myParam=myValue`). The following examples tests for a parameter with a value:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(path = \"/pets/{petId}\", params = \"myParam=myValue\") // <1>\n\tpublic void findPet(@PathVariable String petId) {\n // ...\n\t}\n----\n<1> Check that `myParam` equals `myValue`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/pets/{petId}\", params = [\"myParam=myValue\"]) // <1>\n\tfun findPet(@PathVariable petId: String) {\n // ...\n\t}\n----\n<1> Check that `myParam` equals `myValue`.\n======\n\nYou can also use the same with request header conditions, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(path = \"/pets/{petId}\", headers = \"myHeader=myValue\") // <1>\n\tpublic void findPet(@PathVariable String petId) {\n // ...\n\t}\n----\n<1> Check that `myHeader` equals `myValue`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/pets/{petId}\", headers = [\"myHeader=myValue\"]) // <1>\n\tfun findPet(@PathVariable petId: String) {\n // ...\n\t}\n----\n<1> Check that `myHeader` equals `myValue`.\n======\n\n[[webflux-ann-requestmapping-version]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Parameters and Headers", "heading_level": 2, "file_order": 305, "section_index": 6, "content_hash": "f6dc84645317d2693c7741b678b3651a2057b62d97055a735ce3597c9c59a5aa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc"}}
{"id": "sha256:90c9ac674717975e81ec1d49a3fc3d9d13a1512733af7594c9fc35a9c3547770", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-version[See equivalent in the Servlet stack]#\n\nThere is no standard way to specify an API version, so when you enable API versioning\nin the xref:web/webflux/config.adoc#webflux-config-api-version[WebFlux Config] you need\nto specify how to resolve the version. The WebFlux Config creates an\nxref:web/webflux-versioning.adoc#webflux-versioning-strategy[ApiVersionStrategy] that in turn\nis used to map requests.\n\nOnce API versioning is enabled, you can begin to map requests with versions.\nThe `@RequestMapping` `version` attribute supports the following:\n\n- Fixed version (\"1.2\") -- matches the given version only\n- Baseline version (\"1.2+\") -- matches the given version and above\n- No value -- matches any version, but is superseded by a more specific version match\n\nIf multiple controller methods have a version less than or equal to the request version,\nthe highest of those, and closest to the request version, is the one considered,\nin effect superseding the rest.\n\nTo illustrate this, consider the following mappings:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\t@RequestMapping(\"/account/{id}\")\n\tpublic class AccountController {\n\n @GetMapping // <1>\n public Account getAccount() {\n }\n\n @GetMapping(version = \"1.1\") // <2>\n public Account getAccount1_1() {\n }\n\n @GetMapping(version = \"1.2+\") // <3>\n public Account getAccount1_2() {\n }\n\n @GetMapping(version = \"1.5\") // <4>\n public Account getAccount1_5() {\n }\n\t}\n----\n<1> match any version\n<2> match version 1.1\n<3> match version 1.2 and above\n<4> match version 1.5\n======\n\nFor request with version `\"1.3\"`:\n\n- (1) matches as it matches any version\n- (2) does not match\n- (3) matches as it matches 1.2 and above, and is *chosen* as the highest match\n- (4) is higher and does not match\n\nFor request with version `\"1.5\"`:\n\n- (1) matches as it matches any version\n- (2) does not match\n- (3) matches as it matches 1.2 and above\n- (4) matches and is *chosen* as the highest match\n\nA request with version `\"1.6\"` does not have a match. (1) and (3) do match, but are\nsuperseded by (4), which allows only a strict match, and therefore does not match.\nIn this scenario, a `NotAcceptableApiVersionException` results in a 400 response.\n\nController methods without a version are intended to support clients created before a\nversioned alternative was introduced. Therefore, even though an unversioned controller\nmethod is considered a match for any version, it is in fact given the lowest priority,\nand is effectively superseded by any alternative controller method with a version.\n\nNOTE: The above assumes the request version is a\nxref:web/webflux/config.adoc#webflux-config-api-version[\"supported\" version],\nor otherwise it would fail.\n\nSee xref:web/webflux-versioning.adoc[API Versioning] for more details on underlying\ninfrastructure and support for API Versioning.\n\n[[webflux-ann-requestmapping-head-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "API Version", "heading_level": 2, "file_order": 305, "section_index": 7, "content_hash": "90c9ac674717975e81ec1d49a3fc3d9d13a1512733af7594c9fc35a9c3547770", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc"}}
{"id": "sha256:8bb8b11139a99f651b157b585d6b4f28e6e25c2663712eb27fbae267a64f24e3", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-head-options[See equivalent in the Servlet stack]#\n\n`@GetMapping` and `@RequestMapping(method=HttpMethod.GET)` support HTTP HEAD\ntransparently for request mapping purposes. Controller methods need not change.\nA response wrapper, applied in the `HttpHandler` server adapter, ensures a `Content-Length`\nheader is set to the number of bytes written without actually writing to the response.\n\nBy default, HTTP OPTIONS is handled by setting the `Allow` response header to the list of HTTP\nmethods listed in all `@RequestMapping` methods with matching URL patterns.\n\nFor a `@RequestMapping` without HTTP method declarations, the `Allow` header is set to\n`GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`. Controller methods should always declare the\nsupported HTTP methods (for example, by using the HTTP method specific variants --\n`@GetMapping`, `@PostMapping`, and others).\n\nYou can explicitly map a `@RequestMapping` method to HTTP HEAD and HTTP OPTIONS, but that\nis not necessary in the common case.\n\n[[webflux-ann-requestmapping-composed]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "HTTP HEAD, OPTIONS", "heading_level": 2, "file_order": 305, "section_index": 8, "content_hash": "8bb8b11139a99f651b157b585d6b4f28e6e25c2663712eb27fbae267a64f24e3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc"}}
{"id": "sha256:927aba3e96dc480fbd504bfbc1fec34c7b6e4d2e2ee00da33e27d6ad54003aae", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-composed[See equivalent in the Servlet stack]#\n\nSpring WebFlux supports the use of xref:core/beans/classpath-scanning.adoc#beans-meta-annotations[composed annotations]\nfor request mapping. Those are annotations that are themselves meta-annotated with\n`@RequestMapping` and composed to redeclare a subset (or all) of the `@RequestMapping`\nattributes with a narrower, more specific purpose.\n\n`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, and `@PatchMapping` are\nexamples of composed annotations. They are provided, because, arguably, most\ncontroller methods should be mapped to a specific HTTP method versus using `@RequestMapping`,\nwhich, by default, matches to all HTTP methods. If you need an example of how to implement\na composed annotation, look at how those are declared.\n\nNOTE: `@RequestMapping` cannot be used in conjunction with other `@RequestMapping`\nannotations that are declared on the same element (class, interface, or method). If\nmultiple `@RequestMapping` annotations are detected on the same element, a warning will\nbe logged, and only the first mapping will be used. This also applies to composed\n`@RequestMapping` annotations such as `@GetMapping`, `@PostMapping`, etc.\n\nSpring WebFlux also supports custom request mapping attributes with custom request matching\nlogic. This is a more advanced option that requires sub-classing\n`RequestMappingHandlerMapping` and overriding the `getCustomMethodCondition` method, where\nyou can check the custom attribute and return your own `RequestCondition`.\n\n[[webflux-ann-requestmapping-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Custom Annotations", "heading_level": 2, "file_order": 305, "section_index": 9, "content_hash": "927aba3e96dc480fbd504bfbc1fec34c7b6e4d2e2ee00da33e27d6ad54003aae", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc"}}
{"id": "sha256:28fe32a4edf83470cd4a6cd7aa5cddefffa2cafcc19eea232f842c5da214b5fa", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-registration[See equivalent in the Servlet stack]#\n\nYou can programmatically register Handler methods, which can be used for dynamic\nregistrations or for advanced cases, such as different instances of the same handler\nunder different URLs. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class MyConfig {\n\n @Autowired\n public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) // <1>\n throws NoSuchMethodException {\n\n RequestMappingInfo info = RequestMappingInfo\n .paths(\"/user/{id}\").methods(RequestMethod.GET).build(); // <2>\n\n Method method = UserHandler.class.getMethod(\"getUser\", Long.class); // <3>\n\n mapping.registerMapping(info, handler, method); // <4>\n }\n\n\t}\n----\n<1> Inject target handlers and the handler mapping for controllers.\n<2> Prepare the request mapping metadata.\n<3> Get the handler method.\n<4> Add the registration.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass MyConfig {\n\n @Autowired\n fun setHandlerMapping(mapping: RequestMappingHandlerMapping, handler: UserHandler) { // <1>\n\n val info = RequestMappingInfo.paths(\"/user/{id}\").methods(RequestMethod.GET).build() // <2>\n\n val method = UserHandler::class.java.getMethod(\"getUser\", Long::class.java) // <3>\n\n mapping.registerMapping(info, handler, method) // <4>\n }\n\t}\n----\n<1> Inject target handlers and the handler mapping for controllers.\n<2> Prepare the request mapping metadata.\n<3> Get the handler method.\n<4> Add the registration.\n======\n\n[[webflux-ann-httpexchange-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Explicit Registrations", "heading_level": 2, "file_order": 305, "section_index": 10, "content_hash": "28fe32a4edf83470cd4a6cd7aa5cddefffa2cafcc19eea232f842c5da214b5fa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc"}}
{"id": "sha256:bec8344f8d78c0480a65cea77049bff89a9bafa26888ca5b84e13f153463b614", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-httpexchange-annotation[See equivalent in the Servlet stack]#\n\nWhile the main purpose of `@HttpExchange` is for an HTTP Service\nxref:integration/rest-clients.adoc#rest-http-service-client[client with a generated proxy],\nthe HTTP Service interface on which such annotations are placed is a contract neutral\nto client vs server use. In addition to simplifying client code, there are also cases\nwhere an HTTP Service interface may be a convenient way for servers to expose their\nAPI for client access. This leads to increased coupling between client and server and\nis often not a good choice, especially for public API's, but may be exactly the goal\nfor an internal API. It is an approach commonly used in Spring Cloud, and it is why\n`@HttpExchange` is supported as an alternative to `@RequestMapping` for server side\nhandling in controller classes.\n\nFor example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@HttpExchange(\"/persons\")\n\tinterface PersonService {\n\n @GetExchange(\"/{id}\")\n Person getPerson(@PathVariable Long id);\n\n @PostExchange\n void add(@RequestBody Person person);\n\t}\n\n\t@RestController\n\tclass PersonController implements PersonService {\n\n public Person getPerson(@PathVariable Long id) {\n // ...\n }\n\n @ResponseStatus(HttpStatus.CREATED)\n public void add(@RequestBody Person person) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@HttpExchange(\"/persons\")\n\tinterface PersonService {\n\n @GetExchange(\"/{id}\")\n fun getPerson(@PathVariable id: Long): Person\n\n @PostExchange\n fun add(@RequestBody person: Person)\n\t}\n\n\t@RestController\n\tclass PersonController : PersonService {\n\n override fun getPerson(@PathVariable id: Long): Person {\n // ...\n }\n\n @ResponseStatus(HttpStatus.CREATED)\n override fun add(@RequestBody person: Person) {\n // ...\n }\n\t}\n----\n======\n\n`@HttpExchange` and `@RequestMapping` have differences.\n`@RequestMapping` can map to any number of requests by path patterns, HTTP methods,\nand more, while `@HttpExchange` declares a single endpoint with a concrete HTTP method,\npath, and content types.\n\nFor method parameters and returns values, generally, `@HttpExchange` supports a\nsubset of the method parameters that `@RequestMapping` does. Notably, it excludes any\nserver-side specific parameter types. For details, see the list for\nxref:integration/rest-clients.adoc#rest-http-service-client-method-parameters[@HttpExchange] and\nxref:web/webflux/controller/ann-methods/arguments.adoc[@RequestMapping].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "`@HttpExchange`", "heading_level": 2, "file_order": 305, "section_index": 11, "content_hash": "bec8344f8d78c0480a65cea77049bff89a9bafa26888ca5b84e13f153463b614", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-requestmapping.adoc"}}
{"id": "sha256:c9d1f8d52fe10dc367da51e9f5d2c1015788f89d617913e141b4637f4a882bc3", "content": "[[mvc-ann-validation]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann-validation.adoc[See equivalent in the Servlet stack]#\n\nSpring WebFlux has built-in xref:core/validation/validator.adoc[Validation] for\n`@RequestMapping` methods, including xref:core/validation/beanvalidation.adoc[Java Bean Validation].\nValidation may be applied at one of two levels:\n\n1. Java Bean Validation is applied individually to an\nxref:web/webflux/controller/ann-methods/modelattrib-method-args.adoc[@ModelAttribute],\nxref:web/webflux/controller/ann-methods/requestbody.adoc[@RequestBody], and\nxref:web/webflux/controller/ann-methods/multipart-forms.adoc[@RequestPart] method parameter\nannotated with `@jakarta.validation.Valid` or Spring's `@Validated` so long as\nit is a command object rather than a container such as `Map` or `Collection`, it does not\nhave `Errors` or `BindingResult` immediately after in the method signature, and does not\notherwise require method validation (see next). `WebExchangeBindException` is the\nexception raised when validating a method parameter individually.\n\n2. Java Bean Validation is applied to the method when `@Constraint` annotations such as\n`@Min`, `@NotBlank` and others are declared directly on method parameters, or on the\nmethod for the return value, and it supersedes any validation that would be applied\notherwise to a method parameter individually because method validation covers both\nmethod parameter constraints and nested constraints via `@Valid`.\n`HandlerMethodValidationException` is the exception raised validation is applied\nto the method.\n\nApplications must handle both `WebExchangeBindException` and\n`HandlerMethodValidationException` as either may be raised depending on the controller\nmethod signature. The two exceptions, however are designed to be very similar, and can be\nhandled with almost identical code. The main difference is that the former is for a single\nobject while the latter is for a list of method parameters.\n\nNOTE: `@Valid` is not a constraint annotation, but rather for nested constraints within\nan Object. Therefore, by itself `@Valid` does not lead to method validation. `@NotNull`\non the other hand is a constraint, and adding it to an `@Valid` parameter leads to method\nvalidation. For nullability specifically, you may also use the `required` flag of\n`@RequestBody` or `@ModelAttribute`.\n\nMethod validation may be used in combination with `Errors` or `BindingResult` method\nparameters. However, the controller method is called only if all validation errors are on\nmethod parameters with an `Errors` immediately after. If there are validation errors on\nany other method parameter then `HandlerMethodValidationException` is raised.\n\nYou can configure a `Validator` globally through the\nxref:web/webflux/config.adoc#webflux-config-validation[WebFlux config], or locally\nthrough an xref:web/webflux/controller/ann-initbinder.adoc[@InitBinder] method in an\n`@Controller` or `@ControllerAdvice`. You can also use multiple validators.\n\nNOTE: If a controller has a class level `@Validated`, then\nxref:core/validation/beanvalidation.adoc#validation-beanvalidation-spring-method[method validation is applied]\nthrough an AOP proxy. In order to take advantage of the Spring MVC built-in support for\nmethod validation added in Spring Framework 6.1, you need to remove the class level\n`@Validated` annotation from the controller.\n\nThe xref:web/webflux/ann-rest-exceptions.adoc[Error Responses] section provides further\ndetails on how `WebExchangeBindException` and `HandlerMethodValidationException`\nare handled, and also how their rendering can be customized through a `MessageSource` and\nlocale and language specific resource bundles.\n\nFor further custom handling of method validation errors, you can extend\n`ResponseEntityExceptionHandler` or use an `@ExceptionHandler` method in a controller\nor in a `@ControllerAdvice`, and handle `HandlerMethodValidationException` directly.\nThe exception contains a list of ``ParameterValidationResult``s that group validation errors\nby method parameter. You can either iterate over those, or provide a visitor with callback\nmethods by controller method parameter type:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHandlerMethodValidationException ex = ... ;\n\n\tex.visitResults(new HandlerMethodValidationException.Visitor() {\n\n @Override\n public void requestHeader(RequestHeader requestHeader, ParameterValidationResult result) {\n // ...\n }\n\n @Override\n public void requestParam(@Nullable RequestParam requestParam, ParameterValidationResult result) {\n // ...\n }\n\n @Override\n public void modelAttribute(@Nullable ModelAttribute modelAttribute, ParameterErrors errors) {\n\n // ...\n\n @Override\n public void other(ParameterValidationResult result) {\n // ...\n }\n\t});\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// HandlerMethodValidationException\n\tval ex\n\n\tex.visitResults(object : HandlerMethodValidationException.Visitor {\n\n override fun requestHeader(requestHeader: RequestHeader, result: ParameterValidationResult) {\n // ...\n }\n\n override fun requestParam(requestParam: RequestParam?, result: ParameterValidationResult) {\n // ...\n }\n\n override fun modelAttribute(modelAttribute: ModelAttribute?, errors: ParameterErrors) {\n // ...\n }\n\n // ...\n\n override fun other(result: ParameterValidationResult) {\n // ...\n }\n\t})\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann-validation.adoc", "title": "ann-validation", "heading": "ann-validation", "heading_level": 1, "file_order": 306, "section_index": 0, "content_hash": "c9d1f8d52fe10dc367da51e9f5d2c1015788f89d617913e141b4637f4a882bc3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann-validation.adoc"}}
{"id": "sha256:85b38a3329f691165eae308ed02aad9b9e121680237f61463678b620da8ba095", "content": "[[webflux-ann-controller]]\n\n[.small]#xref:web/webmvc/mvc-controller/ann.adoc[See equivalent in the Servlet stack]#\n\nYou can define controller beans by using a standard Spring bean definition.\nThe `@Controller` stereotype allows for auto-detection and is aligned with Spring general support\nfor detecting `@Component` classes in the classpath and auto-registering bean definitions\nfor them. It also acts as a stereotype for the annotated class, indicating its role as\na web component.\n\nTo enable auto-detection of such `@Controller` beans, you can add component scanning to\nyour Java configuration, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(\"org.example.web\") // <1>\n\tpublic class WebConfiguration {\n\n // ...\n\t}\n----\n<1> Scan the `org.example.web` package.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@ComponentScan(\"org.example.web\") // <1>\n\tclass WebConfiguration {\n\n // ...\n\t}\n----\n<1> Scan the `org.example.web` package.\n======\n\n`@RestController` is a xref:core/beans/classpath-scanning.adoc#beans-meta-annotations[composed annotation] that is\nitself meta-annotated with `@Controller` and `@ResponseBody`, indicating a controller whose\nevery method inherits the type-level `@ResponseBody` annotation and, therefore, writes\ndirectly to the response body versus view resolution and rendering with an HTML template.\n\n[[webflux-ann-requestmapping-proxying]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann.adoc", "title": "ann", "heading": "ann", "heading_level": 1, "file_order": 307, "section_index": 0, "content_hash": "85b38a3329f691165eae308ed02aad9b9e121680237f61463678b620da8ba095", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann.adoc"}}
{"id": "sha256:e25cbbb8afae066f6e02ceeed5dacb6d51c40b51104a3b13e80ca1fb1c0c752a", "content": "[.small]#xref:web/webmvc/mvc-controller/ann.adoc#mvc-ann-requestmapping-proxying[See equivalent in the Servlet stack]#\n\nIn some cases, you may need to decorate a controller with an AOP proxy at runtime.\nOne example is if you choose to have `@Transactional` annotations directly on the\ncontroller. When this is the case, for controllers specifically, we recommend\nusing class-based proxying. This is automatically the case with such annotations\ndirectly on the controller.\n\nIf the controller implements an interface, and needs AOP proxying, you may need to\nexplicitly configure class-based proxying. For example, with `@EnableTransactionManagement`\nyou can change to `@EnableTransactionManagement(proxyTargetClass = true)`, and with\n`<tx:annotation-driven/>` you can change to `<tx:annotation-driven proxy-target-class=\"true\"/>`.\n\nNOTE: Keep in mind that as of 6.0, with interface proxying, Spring WebFlux no longer detects\ncontrollers based solely on a type-level `@RequestMapping` annotation on the interface.\nPlease, enable class based proxying, or otherwise the interface must also have an\n`@Controller` annotation.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller/ann.adoc", "title": "ann", "heading": "AOP Proxies", "heading_level": 2, "file_order": 307, "section_index": 1, "content_hash": "e25cbbb8afae066f6e02ceeed5dacb6d51c40b51104a3b13e80ca1fb1c0c752a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller/ann.adoc"}}
{"id": "sha256:85eee4e7e97ce53e123c7decd2f61a95df0781a7aa244897c3f25817e9b8a894", "content": "[[webflux-ann-rest-exceptions]]\n\n[.small]#xref:web/webmvc/mvc-ann-rest-exceptions.adoc[See equivalent in the Servlet stack]#\n\nA common requirement for REST services is to include details in the body of error\nresponses. The Spring Framework supports the \"Problem Details for HTTP APIs\"\nspecification, {rfc-site}/rfc9457.html[RFC 9457].\n\nThe following are the main abstractions for this support:\n\n- `ProblemDetail` -- representation for an RFC 9457 problem detail; a simple container\nfor both standard fields defined in the spec, and for non-standard ones.\n- `ErrorResponse` -- contract to expose HTTP error response details including HTTP\nstatus, response headers, and a body in the format of RFC 9457; this allows exceptions to\nencapsulate and expose the details of how they map to an HTTP response. All Spring WebFlux\nexceptions implement this.\n- `ErrorResponseException` -- basic `ErrorResponse` implementation that others\ncan use as a convenient base class.\n- `ResponseEntityExceptionHandler` -- convenient base class for an\nxref:web/webflux/controller/ann-advice.adoc[@ControllerAdvice] that handles all Spring WebFlux exceptions,\nand any `ErrorResponseException`, and renders an error response with a body.\n\n[[webflux-ann-rest-exceptions-render]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/ann-rest-exceptions.adoc", "title": "ann-rest-exceptions", "heading": "ann-rest-exceptions", "heading_level": 1, "file_order": 308, "section_index": 0, "content_hash": "85eee4e7e97ce53e123c7decd2f61a95df0781a7aa244897c3f25817e9b8a894", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/ann-rest-exceptions.adoc"}}
{"id": "sha256:c2d55842e0fbea34e23ad6608f095df917fc77a8bba2738550efed7f525b604a", "content": "[.small]#xref:web/webmvc/mvc-ann-rest-exceptions.adoc#mvc-ann-rest-exceptions-render[See equivalent in the Servlet stack]#\n\nYou can return `ProblemDetail` or `ErrorResponse` from any `@ExceptionHandler` or from\nany `@RequestMapping` method to render an RFC 9457 response. This is processed as follows:\n\n- The `status` property of `ProblemDetail` determines the HTTP status.\n- The `instance` property of `ProblemDetail` is set from the current URL path, if not\nalready set.\n- The Jackson JSON and XML message converters use \"application/problem+json\" or\n\"application/problem+xml\" respectively as the producible media types for `ProblemDetail`\nto ensure they are favored for content negotiation.\n\nTo enable RFC 9457 responses for Spring WebFlux exceptions and for any\n`ErrorResponseException`, extend `ResponseEntityExceptionHandler` and declare it as an\nxref:web/webflux/controller/ann-advice.adoc[@ControllerAdvice] in Spring configuration. The handler\nhas an `@ExceptionHandler` method that handles any `ErrorResponse` exception, which\nincludes all built-in web exceptions. You can add more exception handling methods, and\nuse a protected method to map any exception to a `ProblemDetail`.\n\nYou can register `ErrorResponse` interceptors through the\nxref:web/webflux/config.adoc[WebFlux Config] with a `WebFluxConfigurer`. Use that to intercept\nany RFC 9457 response and take some action.\n\n[[webflux-ann-rest-exceptions-non-standard]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/ann-rest-exceptions.adoc", "title": "ann-rest-exceptions", "heading": "Render", "heading_level": 2, "file_order": 308, "section_index": 1, "content_hash": "c2d55842e0fbea34e23ad6608f095df917fc77a8bba2738550efed7f525b604a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/ann-rest-exceptions.adoc"}}
{"id": "sha256:5ec94d090f438c511820c5261767521f6ecea13eddc3b7fa70e40af981e0a98c", "content": "[.small]#xref:web/webmvc/mvc-ann-rest-exceptions.adoc#mvc-ann-rest-exceptions-non-standard[See equivalent in the Servlet stack]#\n\nYou can extend an RFC 9457 response with non-standard fields in one of two ways.\n\nOne, insert into the \"properties\" `Map` of `ProblemDetail`. When using the Jackson\nlibrary, the Spring Framework registers `ProblemDetailJacksonMixin` that ensures this\n\"properties\" `Map` is unwrapped and rendered as top level JSON properties in the\nresponse, and likewise any unknown property during deserialization is inserted into\nthis `Map`.\n\nYou can also extend `ProblemDetail` to add dedicated non-standard properties.\nThe copy constructor in `ProblemDetail` allows a subclass to make it easy to be created\nfrom an existing `ProblemDetail`. This could be done centrally, for example, from an\n`@ControllerAdvice` such as `ResponseEntityExceptionHandler` that re-creates the\n`ProblemDetail` of an exception into a subclass with the additional non-standard fields.\n\nTIP: In Spring Boot, the `spring.webflux.problemdetails.enabled` property autoconfigures\na `ResponseEntityExceptionHandler` that handles built-in exceptions with problem details.\nIn that case, you may prefer to create another `@ControllerAdvice` instead of extending\n`ResponseEntityExceptionHandler` if you want to take over the handling of a specific\nbuilt-in exception. You'll need to ensure your handler is ordered ahead of the one\nconfigured by Spring Boot whose order is 0.\n\n[[webflux-ann-rest-exceptions-i18n]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/ann-rest-exceptions.adoc", "title": "ann-rest-exceptions", "heading": "Non-Standard Fields", "heading_level": 2, "file_order": 308, "section_index": 2, "content_hash": "5ec94d090f438c511820c5261767521f6ecea13eddc3b7fa70e40af981e0a98c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/ann-rest-exceptions.adoc"}}
{"id": "sha256:bea79c7e9c5481e11a69df20047e9e9120e74c311b1294ff20577931872c12cb", "content": "[.small]#xref:web/webmvc/mvc-ann-rest-exceptions.adoc#mvc-ann-rest-exceptions-i18n[See equivalent in the Servlet stack]#\n\nIt is a common requirement to customize and internationalize error response details.\nIt is also good practice to customize the problem details for Spring WebFlux exceptions\nto avoid revealing implementation details. This section describes the support for that.\n\nAn `ErrorResponse` exposes message codes for \"type\", \"title\", and \"detail\", as well as\nmessage code arguments for the \"detail\" field. `ResponseEntityExceptionHandler` resolves\nthese through a xref:core/beans/context-introduction.adoc#context-functionality-messagesource[MessageSource]\nand updates the corresponding `ProblemDetail` fields accordingly.\n\nThe default strategy for message codes follows the pattern:\n\n`problemDetail.[type|title|detail].[fully qualified exception class name]`\n\nAn `ErrorResponse` may expose more than one message code, typically adding a suffix\nto the default message code. The table below lists message codes, and arguments for\nSpring WebFlux exceptions:\n\n[[webflux-ann-rest-exceptions-codes]]\n[cols=\"1,1,2\", options=\"header\"]\n|===\n| Exception | Message Code | Message Code Arguments\n\n| `HandlerMethodValidationException`\n| (default)\n| `+{0}+` list all validation errors.\nMessage codes and arguments for each error are also resolved via `MessageSource`.\n\n| `MethodNotAllowedException`\n| (default)\n| `+{0}+` the current HTTP method, `+{1}+` the list of supported HTTP methods\n\n| `MissingRequestValueException`\n| (default)\n| `+{0}+` a label for the value (for example, \"request header\", \"cookie value\", ...), `+{1}+` the value name\n\n| `NotAcceptableStatusException`\n| (default)\n| `+{0}+` list of supported media types\n\n| `NotAcceptableStatusException`\n| (default) + \".parseError\"\n|\n\n| `ServerErrorException`\n| (default)\n| `+{0}+` the failure reason provided to the class constructor\n\n| `UnsupportedMediaTypeStatusException`\n| (default)\n| `+{0}+` the media type that is not supported, `+{1}+` list of supported media types\n\n| `UnsupportedMediaTypeStatusException`\n| (default) + \".parseError\"\n|\n\n| `UnsatisfiedRequestParameterException`\n| (default)\n| `+{0}+` the list of parameter conditions\n\n| `WebExchangeBindException`\n| (default)\n| `+{0}+` the list of global errors, `+{1}+` the list of field errors.\nMessage codes and arguments for each error are also resolved via `MessageSource`.\n\n| `NoResourceFoundException`\n| (default)\n| `+{0}+` the request path (or portion of) used to find a resource\n\n|===\n\nNOTE: Unlike other exceptions, the message arguments for\n`WebExchangeBindException` and `HandlerMethodValidationException` are based on a list of\n`MessageSourceResolvable` errors that can also be customized through a\nxref:core/beans/context-introduction.adoc#context-functionality-messagesource[MessageSource]\nresource bundle. See\nxref:core/validation/beanvalidation.adoc#validation-beanvalidation-spring-method-i18n[Customizing Validation Errors]\nfor more details.\n\n[[webflux-ann-rest-exceptions-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/ann-rest-exceptions.adoc", "title": "ann-rest-exceptions", "heading": "Customization and i18n", "heading_level": 2, "file_order": 308, "section_index": 3, "content_hash": "bea79c7e9c5481e11a69df20047e9e9120e74c311b1294ff20577931872c12cb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/ann-rest-exceptions.adoc"}}
{"id": "sha256:0bbdb6a1c484b6c918dd2719e1d1cb819d6da53a8482f441437041192a3931ff", "content": "[.small]#xref:web/webmvc/mvc-ann-rest-exceptions.adoc#mvc-ann-rest-exceptions-client[See equivalent in the Servlet stack]#\n\nA client application can catch `WebClientResponseException`, when using the `WebClient`,\nor `RestClientResponseException` when using the `RestTemplate`, and use their\n`getResponseBodyAs` methods to decode the error response body to any target type such as\n`ProblemDetail`, or a subclass of `ProblemDetail`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/ann-rest-exceptions.adoc", "title": "ann-rest-exceptions", "heading": "Client Handling", "heading_level": 2, "file_order": 308, "section_index": 4, "content_hash": "0bbdb6a1c484b6c918dd2719e1d1cb819d6da53a8482f441437041192a3931ff", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/ann-rest-exceptions.adoc"}}
{"id": "sha256:c9d6e5da21003ada5850a1594d3a059332d3324d7659c1c01626de955cb61591", "content": "[[webflux-caching]]\n\n[.small]#xref:web/webmvc/mvc-caching.adoc[See equivalent in the Servlet stack]#\n\nHTTP caching can significantly improve the performance of a web application. HTTP caching\nrevolves around the `Cache-Control` response header and subsequent conditional request\nheaders, such as `Last-Modified` and `ETag`. `Cache-Control` advises private (for example, browser)\nand public (for example, proxy) caches how to cache and re-use responses. An `ETag` header is used\nto make a conditional request that may result in a 304 (NOT_MODIFIED) without a body,\nif the content has not changed. `ETag` can be seen as a more sophisticated successor to\nthe `Last-Modified` header.\n\nThis section describes the HTTP caching related options available in Spring WebFlux.\n\n[[webflux-caching-cachecontrol]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/caching.adoc", "title": "caching", "heading": "caching", "heading_level": 1, "file_order": 309, "section_index": 0, "content_hash": "c9d6e5da21003ada5850a1594d3a059332d3324d7659c1c01626de955cb61591", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/caching.adoc"}}
{"id": "sha256:96cc637559e93a2744c27ffa5a33bf87f519a3035c0dec0f65c8d8cd0598217e", "content": "[.small]#xref:web/webmvc/mvc-caching.adoc#mvc-caching-cachecontrol[See equivalent in the Servlet stack]#\n\n{spring-framework-api}/http/CacheControl.html[`CacheControl`] provides support for\nconfiguring settings related to the `Cache-Control` header and is accepted as an argument\nin a number of places:\n\n* xref:web/webflux/caching.adoc#webflux-caching-etag-lastmodified[Controllers]\n* xref:web/webflux/caching.adoc#webflux-caching-static-resources[Static Resources]\n\nWhile {rfc-site}/rfc7234#section-5.2.2[RFC 7234] describes all possible\ndirectives for the `Cache-Control` response header, the `CacheControl` type takes a\nuse case-oriented approach that focuses on the common scenarios, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Cache for an hour - \"Cache-Control: max-age=3600\"\n\tCacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);\n\n\t// Prevent caching - \"Cache-Control: no-store\"\n\tCacheControl ccNoStore = CacheControl.noStore();\n\n\t// Cache for ten days in public and private caches,\n\t// public caches should not transform the response\n\t// \"Cache-Control: max-age=864000, public, no-transform\"\n\tCacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Cache for an hour - \"Cache-Control: max-age=3600\"\n\tval ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS)\n\n\t// Prevent caching - \"Cache-Control: no-store\"\n\tval ccNoStore = CacheControl.noStore()\n\n\t// Cache for ten days in public and private caches,\n\t// public caches should not transform the response\n\t// \"Cache-Control: max-age=864000, public, no-transform\"\n\tval ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic()\n\n----\n======\n\n[[webflux-caching-etag-lastmodified]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/caching.adoc", "title": "caching", "heading": "`CacheControl`", "heading_level": 2, "file_order": 309, "section_index": 1, "content_hash": "96cc637559e93a2744c27ffa5a33bf87f519a3035c0dec0f65c8d8cd0598217e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/caching.adoc"}}
{"id": "sha256:d855156eb4653f55507ece98c63f89fdf9cce9e616521c6995cc4eb9051be20f", "content": "[.small]#xref:web/webmvc/mvc-caching.adoc#mvc-caching-etag-lastmodified[See equivalent in the Servlet stack]#\n\nControllers can add explicit support for HTTP caching. We recommend doing so, since the\n`lastModified` or `ETag` value for a resource needs to be calculated before it can be compared\nagainst conditional request headers. A controller can add an `ETag` and `Cache-Control`\nsettings to a `ResponseEntity`, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/book/{id}\")\n\tpublic ResponseEntity<Book> showBook(@PathVariable Long id) {\n\n Book book = findBook(id);\n String version = book.getVersion();\n\n return ResponseEntity\n .ok()\n .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))\n .eTag(version) // lastModified is also available\n .body(book);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/book/{id}\")\n\tfun showBook(@PathVariable id: Long): ResponseEntity<Book> {\n\n val book = findBook(id)\n val version = book.getVersion()\n\n return ResponseEntity\n .ok()\n .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))\n .eTag(version) // lastModified is also available\n .body(book)\n\t}\n----\n======\n--\n\nThe preceding example sends a 304 (NOT_MODIFIED) response with an empty body if the comparison\nto the conditional request headers indicates the content has not changed. Otherwise, the\n`ETag` and `Cache-Control` headers are added to the response.\n\nYou can also make the check against conditional request headers in the controller,\nas the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RequestMapping\n\tpublic String myHandleMethod(ServerWebExchange exchange, Model model) {\n\n long eTag = ... // <1>\n\n if (exchange.checkNotModified(eTag)) {\n return null; // <2>\n }\n\n model.addAttribute(...); // <3>\n return \"myViewName\";\n\t}\n----\n<1> Application-specific calculation.\n<2> Response has been set to 304 (NOT_MODIFIED). No further processing.\n<3> Continue with request processing.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RequestMapping\n\tfun myHandleMethod(exchange: ServerWebExchange, model: Model): String? {\n\n val eTag: Long = ... // <1>\n\n if (exchange.checkNotModified(eTag)) {\n return null// <2>\n }\n\n model.addAttribute(...) // <3>\n return \"myViewName\"\n\t}\n----\n<1> Application-specific calculation.\n<2> Response has been set to 304 (NOT_MODIFIED). No further processing.\n<3> Continue with request processing.\n======\n--\n\nThere are three variants for checking conditional requests against `eTag` values, `lastModified`\nvalues, or both. For conditional `GET` and `HEAD` requests, you can set the response to\n304 (NOT_MODIFIED). For conditional `POST`, `PUT`, and `DELETE`, you can instead set the response\nto 412 (PRECONDITION_FAILED) to prevent concurrent modification.\n\n[[webflux-caching-static-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/caching.adoc", "title": "caching", "heading": "Controllers", "heading_level": 2, "file_order": 309, "section_index": 2, "content_hash": "d855156eb4653f55507ece98c63f89fdf9cce9e616521c6995cc4eb9051be20f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/caching.adoc"}}
{"id": "sha256:2a312637b398ae9d09c3d9731c30da139abc46516bd73d087cf032da7d3af5d7", "content": "[.small]#xref:web/webmvc/mvc-caching.adoc#mvc-caching-static-resources[See equivalent in the Servlet stack]#\n\nYou should serve static resources with a `Cache-Control` and conditional response headers\nfor optimal performance. See the section on configuring\nxref:web/webflux/config.adoc#webflux-config-static-resources[Static Resources].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/caching.adoc", "title": "caching", "heading": "Static Resources", "heading_level": 2, "file_order": 309, "section_index": 3, "content_hash": "2a312637b398ae9d09c3d9731c30da139abc46516bd73d087cf032da7d3af5d7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/caching.adoc"}}
{"id": "sha256:df838fbb6acd481c553bf2bf9e095f8049ef7085ee06f223d6e7f29e4893f06f", "content": "[[webflux-config]]\n\n[.small]#xref:web/webmvc/mvc-config.adoc[See equivalent in the Servlet stack]#\n\nThe WebFlux Java configuration declares the components that are required to process\nrequests with annotated controllers or functional endpoints, and it offers an API to\ncustomize the configuration. That means you do not need to understand the underlying\nbeans created by the Java configuration. However, if you want to understand them,\nyou can see them in `WebFluxConfigurationSupport` or read more about what they are\nin xref:web/webflux/dispatcher-handler.adoc#webflux-special-bean-types[Special Bean Types].\n\nFor more advanced customizations, not available in the configuration API, you can\ngain full control over the configuration through the\nxref:web/webflux/config.adoc#webflux-config-advanced-java[Advanced Configuration Mode].\n\n[[webflux-config-enable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "config", "heading_level": 1, "file_order": 310, "section_index": 0, "content_hash": "df838fbb6acd481c553bf2bf9e095f8049ef7085ee06f223d6e7f29e4893f06f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:f2ec14790422462fb844677da4fa038ea5a8f85e95bb74b022c3e1b2a5712604", "content": "[.small]#xref:web/webmvc/mvc-config/enable.adoc[See equivalent in the Servlet stack]#\n\nYou can use the `@EnableWebFlux` annotation in your Java config, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@EnableWebFlux\n\tpublic class WebConfig {\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\t@EnableWebFlux\n\tclass WebConfig\n----\n======\n\nNOTE: When using Spring Boot, you may want to use `@Configuration` classes of type `WebFluxConfigurer` but without\n`@EnableWebFlux` to keep Spring Boot WebFlux customizations. See more details in\nxref:#webflux-config-customize[the WebFlux config API section] and in\n{spring-boot-docs-ref}/web/reactive.html#web.reactive.webflux.auto-configuration[the dedicated Spring Boot documentation].\n\nThe preceding example registers a number of Spring WebFlux\nxref:web/webflux/dispatcher-handler.adoc#webflux-special-bean-types[infrastructure beans] and adapts to dependencies\navailable on the classpath -- for JSON, XML, and others.\n\n[[webflux-config-customize]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "Enabling WebFlux Config", "heading_level": 2, "file_order": 310, "section_index": 1, "content_hash": "f2ec14790422462fb844677da4fa038ea5a8f85e95bb74b022c3e1b2a5712604", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:1488bf002ee7bf2b54c47fe32a7cb62f4913bb8ca25e522d20221f0d6afa9eb7", "content": "[.small]#xref:web/webmvc/mvc-config/customize.adoc[See equivalent in the Servlet stack]#\n\nIn your Java configuration, you can implement the `WebFluxConfigurer` interface,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n // Implement configuration methods...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n@Configuration\nclass WebConfig : WebFluxConfigurer {\n\n\t// Implement configuration methods...\n}\n----\n======\n\n[[webflux-config-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "WebFlux config API", "heading_level": 2, "file_order": 310, "section_index": 2, "content_hash": "1488bf002ee7bf2b54c47fe32a7cb62f4913bb8ca25e522d20221f0d6afa9eb7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:907402bf5d35039930afbbfe60c5c187a8433be743537d89b3562f2a102b3a5b", "content": "[.small]#xref:web/webmvc/mvc-config/conversion.adoc[See equivalent in the Servlet stack]#\n\nBy default, formatters for various number and date types are installed, along with support\nfor customization via `@NumberFormat`, `@DurationFormat`, and `@DateTimeFormat` on fields\nand parameters.\n\nTo register custom formatters and converters in Java config, use the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public void addFormatters(FormatterRegistry registry) {\n // ...\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n override fun addFormatters(registry: FormatterRegistry) {\n // ...\n }\n\t}\n----\n======\n\nBy default Spring WebFlux considers the request Locale when parsing and formatting date\nvalues. This works for forms where dates are represented as Strings with \"input\" form\nfields. For \"date\" and \"time\" form fields, however, browsers use a fixed format defined\nin the HTML spec. For such cases date and time formatting can be customized as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public void addFormatters(FormatterRegistry registry) {\n DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();\n registrar.setUseIsoFormat(true);\n registrar.registerFormatters(registry);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n override fun addFormatters(registry: FormatterRegistry) {\n val registrar = DateTimeFormatterRegistrar()\n registrar.setUseIsoFormat(true)\n registrar.registerFormatters(registry)\n }\n\t}\n----\n======\n\nNOTE: See xref:core/validation/format.adoc#format-FormatterRegistrar-SPI[`FormatterRegistrar` SPI]\nand the `FormattingConversionServiceFactoryBean` for more information on when to\nuse `FormatterRegistrar` implementations.\n\n[[webflux-config-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "Conversion, formatting", "heading_level": 2, "file_order": 310, "section_index": 3, "content_hash": "907402bf5d35039930afbbfe60c5c187a8433be743537d89b3562f2a102b3a5b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:2125dd5e302099340c2036343d3bb203b67425ff40640ebb39ab05dc62cd87df", "content": "[.small]#xref:web/webmvc/mvc-config/validation.adoc[See equivalent in the Servlet stack]#\n\nBy default, if xref:core/validation/beanvalidation.adoc#validation-beanvalidation-overview[Bean Validation] is present\non the classpath (for example, the Hibernate Validator), the `LocalValidatorFactoryBean`\nis registered as a global xref:core/validation/validator.adoc[validator] for use with `@Valid` and\n`@Validated` on `@Controller` method arguments.\n\nIn your Java configuration, you can customize the global `Validator` instance,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public Validator getValidator() {\n // ...\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n override fun getValidator(): Validator {\n // ...\n }\n\n\t}\n----\n======\n\nNote that you can also register `Validator` implementations locally,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class MyController {\n\n @InitBinder\n protected void initBinder(WebDataBinder binder) {\n binder.addValidators(new FooValidator());\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tclass MyController {\n\n @InitBinder\n protected fun initBinder(binder: WebDataBinder) {\n binder.addValidators(FooValidator())\n }\n\t}\n----\n======\n\nTIP: If you need to have a `LocalValidatorFactoryBean` injected somewhere, create a bean and\nmark it with `@Primary` in order to avoid conflict with the one declared in the MVC config.\n\n[[webflux-config-content-negotiation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "Validation", "heading_level": 2, "file_order": 310, "section_index": 4, "content_hash": "2125dd5e302099340c2036343d3bb203b67425ff40640ebb39ab05dc62cd87df", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:2e193314962f61561883a76dc7d00b46015a0302c4cc9f627c04db586ead4605", "content": "[.small]#xref:web/webmvc/mvc-config/content-negotiation.adoc[See equivalent in the Servlet stack]#\n\nYou can configure how Spring WebFlux determines the requested media types for\n`@Controller` instances from the request. By default, only the `Accept` header is checked,\nbut you can also enable a query parameter-based strategy.\n\nThe following example shows how to customize the requested content type resolution:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n override fun configureContentTypeResolver(builder: RequestedContentTypeResolverBuilder) {\n // ...\n }\n\t}\n----\n======\n\n[[webflux-config-message-codecs]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "Content Type Resolvers", "heading_level": 2, "file_order": 310, "section_index": 5, "content_hash": "2e193314962f61561883a76dc7d00b46015a0302c4cc9f627c04db586ead4605", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:9183869c00591ce86e9bdb098471bcc95184694bd33ddc2a38f318262eee976d", "content": "[.small]#xref:web/webmvc/mvc-config/message-converters.adoc[See equivalent in the Servlet stack]#\n\nThe following example shows how to customize how the request and response body are read and written:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {\n configurer.defaultCodecs().maxInMemorySize(512 * 1024);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) {\n configurer.defaultCodecs().maxInMemorySize(512 * 1024)\n }\n\t}\n----\n======\n\n`ServerCodecConfigurer` provides a set of default readers and writers. You can use it to add\nmore readers and writers, customize the default ones, or replace the default ones completely.\n\nFor Jackson, consider using a Jackson format-specific builder like `JsonMapper.Builder` to configure Jackson's default\nproperties.\n\n[[webflux-config-view-resolvers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "HTTP message codecs", "heading_level": 2, "file_order": 310, "section_index": 6, "content_hash": "9183869c00591ce86e9bdb098471bcc95184694bd33ddc2a38f318262eee976d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:7e5ef54d95e3c8946e458514caf5ff2cc44fe2e4901fbddcce9bfd9d97bbee36", "content": "[.small]#xref:web/webmvc/mvc-config/view-resolvers.adoc[See equivalent in the Servlet stack]#\n\nThe following example shows how to configure view resolution:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public void configureViewResolvers(ViewResolverRegistry registry) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n override fun configureViewResolvers(registry: ViewResolverRegistry) {\n // ...\n }\n\t}\n----\n======\n\nThe `ViewResolverRegistry` has shortcuts for view technologies with which the Spring Framework\nintegrates. The following example uses FreeMarker (which also requires configuring the\nunderlying FreeMarker view technology):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public void configureViewResolvers(ViewResolverRegistry registry) {\n registry.freeMarker();\n }\n\n // Configure Freemarker...\n\n @Bean\n public FreeMarkerConfigurer freeMarkerConfigurer() {\n FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n configurer.setTemplateLoaderPath(\"classpath:/templates\");\n return configurer;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n override fun configureViewResolvers(registry: ViewResolverRegistry) {\n registry.freeMarker()\n }\n\n // Configure Freemarker...\n\n @Bean\n fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {\n setTemplateLoaderPath(\"classpath:/templates\")\n }\n\t}\n----\n======\n\nYou can also plug in any `ViewResolver` implementation, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public void configureViewResolvers(ViewResolverRegistry registry) {\n ViewResolver resolver = ... ;\n registry.viewResolver(resolver);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n override fun configureViewResolvers(registry: ViewResolverRegistry) {\n val resolver: ViewResolver = ...\n registry.viewResolver(resolver\n }\n\t}\n----\n======\n\nTo support xref:web/webflux/dispatcher-handler.adoc#webflux-multiple-representations[Content Negotiation] and rendering other formats\nthrough view resolution (besides HTML), you can configure one or more default views based\non the `HttpMessageWriterView` implementation, which accepts any of the available\nxref:web/webflux/reactive-spring.adoc#webflux-codecs[Codecs] from `spring-web`. The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public void configureViewResolvers(ViewResolverRegistry registry) {\n registry.freeMarker();\n\n JacksonJsonEncoder encoder = new JacksonJsonEncoder();\n registry.defaultViews(new HttpMessageWriterView(encoder));\n }\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n override fun configureViewResolvers(registry: ViewResolverRegistry) {\n registry.freeMarker()\n\n val encoder = JacksonJsonEncoder()\n registry.defaultViews(HttpMessageWriterView(encoder))\n }\n\n // ...\n\t}\n----\n======\n\nSee xref:web/webflux-view.adoc[View Technologies] for more on the view technologies that are integrated with Spring WebFlux.\n\n[[webflux-config-static-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "View Resolvers", "heading_level": 2, "file_order": 310, "section_index": 7, "content_hash": "7e5ef54d95e3c8946e458514caf5ff2cc44fe2e4901fbddcce9bfd9d97bbee36", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:3dc53f33238efe5aa7767c5141111f8e9379c3294132cd48d3b7eba7ba184efe", "content": "[.small]#xref:web/webmvc/mvc-config/static-resources.adoc[See equivalent in the Servlet stack]#\n\nThis option provides a convenient way to serve static resources from a list of\n{spring-framework-api}/core/io/Resource.html[`Resource`]-based locations.\n\nIn the next example, given a request that starts with `/resources`, the relative path is\nused to find and serve static resources relative to `/static` on the classpath. Resources\nare served with a one-year future expiration to ensure maximum use of the browser cache\nand a reduction in HTTP requests made by the browser. The `Last-Modified` header is also\nevaluated and, if present, a `304` status code is returned. The following listing shows\nthe example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public void addResourceHandlers(ResourceHandlerRegistry registry) {\n registry.addResourceHandler(\"/resources/**\")\n .addResourceLocations(\"/public\", \"classpath:/static/\")\n .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n override fun addResourceHandlers(registry: ResourceHandlerRegistry) {\n registry.addResourceHandler(\"/resources/**\")\n .addResourceLocations(\"/public\", \"classpath:/static/\")\n .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS))\n }\n\t}\n----\n======\n\nSee also xref:web/webflux/caching.adoc#webflux-caching-static-resources[HTTP caching support for static resources].\n\nThe resource handler also supports a chain of\n{spring-framework-api}/web/reactive/resource/ResourceResolver.html[`ResourceResolver`] implementations and\n{spring-framework-api}/web/reactive/resource/ResourceTransformer.html[`ResourceTransformer`] implementations,\nwhich can be used to create a toolchain for working with optimized resources.\n\nYou can use the `VersionResourceResolver` for versioned resource URLs based on an MD5 hash\ncomputed from the content, a fixed application version, or other information. A\n`ContentVersionStrategy` (MD5 hash) is a good choice with some notable exceptions (such as\nJavaScript resources used with a module loader).\n\nThe following example shows how to use `VersionResourceResolver` in your Java configuration:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public void addResourceHandlers(ResourceHandlerRegistry registry) {\n registry.addResourceHandler(\"/resources/**\")\n .addResourceLocations(\"/public/\")\n .resourceChain(true)\n .addResolver(new VersionResourceResolver().addContentVersionStrategy(\"/**\"));\n }\n\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n override fun addResourceHandlers(registry: ResourceHandlerRegistry) {\n registry.addResourceHandler(\"/resources/**\")\n .addResourceLocations(\"/public/\")\n .resourceChain(true)\n .addResolver(VersionResourceResolver().addContentVersionStrategy(\"/**\"))\n }\n\n\t}\n----\n======\n\nYou can use `ResourceUrlProvider` to rewrite URLs and apply the full chain of resolvers and\ntransformers (for example, to insert versions). The WebFlux configuration provides a `ResourceUrlProvider`\nso that it can be injected into others.\n\nUnlike Spring MVC, at present, in WebFlux, there is no way to transparently rewrite static\nresource URLs, since there are no view technologies that can make use of a non-blocking chain\nof resolvers and transformers. When serving only local resources, the workaround is to use\n`ResourceUrlProvider` directly (for example, through a custom element) and block.\n\nNote that, when using both `EncodedResourceResolver` (for example, Gzip, Brotli encoded) and\n`VersionedResourceResolver`, they must be registered in that order, to ensure content-based\nversions are always computed reliably based on the unencoded file.\n\nFor https://www.webjars.org/documentation[WebJars], versioned URLs like\n`/webjars/jquery/1.2.0/jquery.min.js` are the recommended and most efficient way to use them.\nThe related resource location is configured out of the box with Spring Boot (or can be configured\nmanually via `ResourceHandlerRegistry`) and does not require to add the\n`org.webjars:webjars-locator-lite` dependency.\n\nVersion-less URLs like `/webjars/jquery/jquery.min.js` are supported through the\n`WebJarsResourceResolver` which is automatically registered when the\n`org.webjars:webjars-locator-lite` library is present on the classpath. The resolver can re-write\nURLs to include the version of the jar and can also match against incoming URLs without versions\n-- for example, from `/webjars/jquery/jquery.min.js` to `/webjars/jquery/1.2.0/jquery.min.js`.\n\nTIP: The Java configuration based on `ResourceHandlerRegistry` provides further options\nfor fine-grained control, for example, last-modified behavior and optimized resource resolution.\n\n[[webflux-config-path-matching]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "Static Resources", "heading_level": 2, "file_order": 310, "section_index": 8, "content_hash": "3dc53f33238efe5aa7767c5141111f8e9379c3294132cd48d3b7eba7ba184efe", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:c54abfd260db509e00279f411a6310f2a61840beb8ddeb0282921d28caf1b6ae", "content": "[.small]#xref:web/webmvc/mvc-config/path-matching.adoc[See equivalent in the Servlet stack]#\n\nYou can customize options related to path matching. For details on the individual options, see the\n{spring-framework-api}/web/reactive/config/PathMatchConfigurer.html[`PathMatchConfigurer`] javadoc.\nThe following example shows how to use `PathMatchConfigurer`:\n\ninclude-code::./WebConfig[]\n\n[TIP]\n====\nSpring WebFlux relies on a parsed representation of the request path called\n`RequestPath` for access to decoded path segment values, with semicolon content removed\n(that is, path or matrix variables). That means, unlike in Spring MVC, you need not indicate\nwhether to decode the request path nor whether to remove semicolon content for\npath matching purposes.\n\nSpring WebFlux also does not support suffix pattern matching, unlike in Spring MVC, where we\nare also xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-suffix-pattern-match[recommend] moving away from\nreliance on it.\n====\n\n[[webflux-config-api-version]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "Path Matching", "heading_level": 2, "file_order": 310, "section_index": 9, "content_hash": "c54abfd260db509e00279f411a6310f2a61840beb8ddeb0282921d28caf1b6ae", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:dfa40e2095e03f5ded2dbed7289cac710a5fa199cced49e29d4800fbd8bc963e", "content": "[.small]#xref:web/webmvc/mvc-config/api-version.adoc[See equivalent in the Servlet stack]#\n\nTo enable API versioning, use the `ApiVersionConfigurer` callback of `WebFluxConfigurer`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Configuration\n\tpublic class WebConfiguration implements WebFluxConfigurer {\n\n @Override\n public void configureApiVersioning(ApiVersionConfigurer configurer) {\n configurer.useRequestHeader(\"API-Version\");\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Configuration\n\tclass WebConfiguration : WebFluxConfigurer {\n\n override fun configureApiVersioning(configurer: ApiVersionConfigurer) {\n configurer.useRequestHeader(\"API-Version\")\n }\n\t}\n----\n======\n\nYou can resolve the version through one of the built-in options listed below, or\nalternatively use a custom `ApiVersionResolver`:\n\n- Request header\n- Request parameter\n- Path segment\n- Media type parameter\n\nTo resolve from a path segment, you need to specify the index of the path segment expected\nto contain the version. The path segment must be declared as a URI variable, e.g.\n\"/\\{version}\", \"/api/\\{version}\", etc. where the actual name is not important.\nAs the version is typically at the start of the path, consider configuring it externally\nas a common path prefix for all handlers through the\nxref:web/webflux/config.adoc#webflux-config-path-matching[Path Matching] options.\n\nBy default, the version is parsed with `SemanticVersionParser`, but you can also configure\na custom xref:web/webflux-versioning.adoc#webflux-versioning-parser[ApiVersionParser].\n\nSupported versions are transparently detected from versions declared in request mappings\nfor convenience, but you can turn that off through a flag in the WebFlux config, and\nconsider only the versions configured explicitly in the config as supported.\nRequests with a version that is not supported are rejected with\n`InvalidApiVersionException` resulting in a 400 response.\n\nYou can set an `ApiVersionDeprecationHandler` to send information about deprecated\nversions to clients. The built-in standard handler can set \"Deprecation\", \"Sunset\", and\n\"Link\" headers based on https://datatracker.ietf.org/doc/html/rfc9745[RFC 9745] and\nhttps://datatracker.ietf.org/doc/html/rfc8594[RFC 8594].\n\nOnce API versioning is configured, you can begin to map requests to\nxref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-version[controller methods]\naccording to the request version.\n\n[[webflux-config-blocking-execution]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "API Version", "heading_level": 2, "file_order": 310, "section_index": 10, "content_hash": "dfa40e2095e03f5ded2dbed7289cac710a5fa199cced49e29d4800fbd8bc963e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:55a9645c3205bcee2ef53dd5932d60c65385998f268ef8c884042b239bce545e", "content": "The WebFlux Java config allows you to customize blocking execution in WebFlux.\n\nYou can have blocking controller methods called on a separate thread by providing\nan `AsyncTaskExecutor` such as the\n{spring-framework-api}/core/task/VirtualThreadTaskExecutor.html[`VirtualThreadTaskExecutor`]\nas follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public void configureBlockingExecution(BlockingExecutionConfigurer configurer) {\n AsyncTaskExecutor executor = ...\n configurer.setExecutor(executor);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n @Override\n fun configureBlockingExecution(configurer: BlockingExecutionConfigurer) {\n val executor = ...\n configurer.setExecutor(executor)\n }\n\t}\n----\n======\n\nBy default, controller methods whose return type is not recognized by the configured\n`ReactiveAdapterRegistry` are considered blocking, but you can set a custom controller\nmethod predicate via `BlockingExecutionConfigurer`.\n\n[[webflux-config-websocket-service]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "Blocking Execution", "heading_level": 2, "file_order": 310, "section_index": 11, "content_hash": "55a9645c3205bcee2ef53dd5932d60c65385998f268ef8c884042b239bce545e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:6c4036fd17dc457e7d74983cc80de55d6cb04882feb84f9dab7dee2740b5523c", "content": "The WebFlux Java config declares of a `WebSocketHandlerAdapter` bean which provides\nsupport for the invocation of WebSocket handlers. That means all that remains to do in\norder to handle a WebSocket handshake request is to map a `WebSocketHandler` to a URL\nvia `SimpleUrlHandlerMapping`.\n\nIn some cases it may be necessary to create the `WebSocketHandlerAdapter` bean with a\nprovided `WebSocketService` service which allows configuring WebSocket server properties.\nFor example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public WebSocketService getWebSocketService() {\n TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();\n strategy.setMaxSessionIdleTimeout(0L);\n return new HandshakeWebSocketService(strategy);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n @Override\n fun webSocketService(): WebSocketService {\n val strategy = TomcatRequestUpgradeStrategy().apply {\n setMaxSessionIdleTimeout(0L)\n }\n return HandshakeWebSocketService(strategy)\n }\n\t}\n----\n======\n\n[[webflux-config-advanced-java]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "WebSocketService", "heading_level": 2, "file_order": 310, "section_index": 12, "content_hash": "6c4036fd17dc457e7d74983cc80de55d6cb04882feb84f9dab7dee2740b5523c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:6e894e056636d0eb7c4b10be04aa87e7fb350c31a173710e9faae7d044f98a93", "content": "[.small]#xref:web/webmvc/mvc-config/advanced-java.adoc[See equivalent in the Servlet stack]#\n\n`@EnableWebFlux` imports `DelegatingWebFluxConfiguration` that:\n\n* Provides default Spring configuration for WebFlux applications\n\n* detects and delegates to `WebFluxConfigurer` implementations to customize that configuration.\n\nFor advanced mode, you can remove `@EnableWebFlux` and extend directly from\n`DelegatingWebFluxConfiguration` instead of implementing `WebFluxConfigurer`,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig extends DelegatingWebFluxConfiguration {\n\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : DelegatingWebFluxConfiguration {\n\n // ...\n\t}\n----\n======\n\nYou can keep existing methods in `WebConfig`, but you can now also override bean declarations\nfrom the base class and still have any number of other `WebMvcConfigurer` implementations on\nthe classpath.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/config.adoc", "title": "config", "heading": "Advanced Configuration Mode", "heading_level": 2, "file_order": 310, "section_index": 13, "content_hash": "6e894e056636d0eb7c4b10be04aa87e7fb350c31a173710e9faae7d044f98a93", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/config.adoc"}}
{"id": "sha256:7f32fbad8c9e4f8bee5f4652d09ad815c683b2ece94f90381054306e11c31064", "content": "[[webflux-controller]]\n\n[.small]#xref:web/webmvc/mvc-controller.adoc[See equivalent in the Servlet stack]#\n\nSpring WebFlux provides an annotation-based programming model, where `@Controller` and\n`@RestController` components use annotations to express request mappings, request input,\nhandle exceptions, and more. Annotated controllers have flexible method signatures and\ndo not have to extend base classes nor implement specific interfaces.\n\nThe following listing shows a basic example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\tpublic class HelloController {\n\n @GetMapping(\"/hello\")\n public String handle() {\n return \"Hello WebFlux\";\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\tclass HelloController {\n\n @GetMapping(\"/hello\")\n fun handle() = \"Hello WebFlux\"\n\t}\n----\n======\n\nIn the preceding example, the method returns a `String` to be written to the response body.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/controller.adoc", "title": "controller", "heading": "controller", "heading_level": 1, "file_order": 311, "section_index": 0, "content_hash": "7f32fbad8c9e4f8bee5f4652d09ad815c683b2ece94f90381054306e11c31064", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/controller.adoc"}}
{"id": "sha256:ce6a475cde83e3648992f4bc1aa92e90366f5b0613a0b8f11e671cfbb004a87b", "content": "[[webflux-dispatcher-handler]]\n\n[.small]#xref:web/webmvc/mvc-servlet.adoc[See equivalent in the Servlet stack]#\n\nSpring WebFlux, similarly to Spring MVC, is designed around the front controller pattern,\nwhere a central `WebHandler`, the `DispatcherHandler`, provides a shared algorithm for\nrequest processing, while actual work is performed by configurable, delegate components.\nThis model is flexible and supports diverse workflows.\n\n`DispatcherHandler` discovers the delegate components it needs from Spring configuration.\nIt is also designed to be a Spring bean itself and implements `ApplicationContextAware`\nfor access to the context in which it runs. If `DispatcherHandler` is declared with a bean\nname of `webHandler`, it is, in turn, discovered by\n{spring-framework-api}/web/server/adapter/WebHttpHandlerBuilder.html[`WebHttpHandlerBuilder`],\nwhich puts together a request-processing chain, as described in\nxref:web/webflux/reactive-spring.adoc#webflux-web-handler-api[`WebHandler` API].\n\nSpring configuration in a WebFlux application typically contains:\n\n* `DispatcherHandler` with the bean name `webHandler`\n* `WebFilter` and `WebExceptionHandler` beans\n* xref:web/webflux/dispatcher-handler.adoc#webflux-special-bean-types[`DispatcherHandler` special beans]\n* Others\n\nThe configuration is given to `WebHttpHandlerBuilder` to build the processing chain,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext context = ...\n\tHttpHandler handler = WebHttpHandlerBuilder.applicationContext(context).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval context: ApplicationContext = ...\n\tval handler = WebHttpHandlerBuilder.applicationContext(context).build()\n----\n======\n\nThe resulting `HttpHandler` is ready for use with a\nxref:web/webflux/reactive-spring.adoc#webflux-httphandler[server adapter].\n\n[[webflux-special-bean-types]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc", "title": "dispatcher-handler", "heading": "dispatcher-handler", "heading_level": 1, "file_order": 312, "section_index": 0, "content_hash": "ce6a475cde83e3648992f4bc1aa92e90366f5b0613a0b8f11e671cfbb004a87b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc"}}
{"id": "sha256:38b037a632c05df461ec6765330ff66568ffe178d1dfdf417b527fc50cbf6c4f", "content": "[.small]#xref:web/webmvc/mvc-servlet/special-bean-types.adoc[See equivalent in the Servlet stack]#\n\nThe `DispatcherHandler` delegates to special beans to process requests and render the\nappropriate responses. By \"`special beans,`\" we mean Spring-managed `Object` instances that\nimplement WebFlux framework contracts. Those usually come with built-in contracts, but\nyou can customize their properties, extend them, or replace them.\n\nThe following table lists the special beans detected by the `DispatcherHandler`. Note that\nthere are also some other beans detected at a lower level (see\nxref:web/webflux/reactive-spring.adoc#webflux-web-handler-api-special-beans[Special bean types]\nin the Web Handler API).\n\n[[webflux-special-beans-table]]\n[cols=\"1,2\", options=\"header\"]\n|===\n| Bean type | Explanation\n\n| `HandlerMapping`\n| Map a request to a handler. The mapping is based on some criteria, the details of\n which vary by `HandlerMapping` implementation -- annotated controllers, simple\n URL pattern mappings, and others.\n\n The main `HandlerMapping` implementations are `RequestMappingHandlerMapping` for\n `@RequestMapping` annotated methods, `RouterFunctionMapping` for functional endpoint\n routes, and `SimpleUrlHandlerMapping` for explicit registrations of URI path patterns\n and `WebHandler` instances.\n\n| `HandlerAdapter`\n| Help the `DispatcherHandler` to invoke a handler mapped to a request regardless of\n how the handler is actually invoked. For example, invoking an annotated controller\n requires resolving annotations. The main purpose of a `HandlerAdapter` is to shield the\n `DispatcherHandler` from such details.\n\n| `HandlerResultHandler`\n| Process the result from the handler invocation and finalize the response.\n See xref:web/webflux/dispatcher-handler.adoc#webflux-resulthandling[Result Handling].\n\n|===\n\n[[webflux-framework-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc", "title": "dispatcher-handler", "heading": "Special Bean Types", "heading_level": 2, "file_order": 312, "section_index": 1, "content_hash": "38b037a632c05df461ec6765330ff66568ffe178d1dfdf417b527fc50cbf6c4f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc"}}
{"id": "sha256:d122496c0261fb86fcb7156bace00c45a1b6d324c304bb92c2904ccccc7a9e9c", "content": "[.small]#xref:web/webmvc/mvc-servlet/config.adoc[See equivalent in the Servlet stack]#\n\nApplications can declare the infrastructure beans (listed under\nxref:web/webflux/reactive-spring.adoc#webflux-web-handler-api-special-beans[Web Handler API] and\nxref:web/webflux/dispatcher-handler.adoc#webflux-special-bean-types[`DispatcherHandler`])\nthat are required to process requests. However, in most cases, the\nxref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[WebFlux Config]\nis the best starting point. It declares the required beans and provides a higher-level\nconfiguration callback API to customize it.\n\nNOTE: Spring Boot relies on the WebFlux config to configure Spring WebFlux and also provides\nmany extra convenient options.\n\n[[webflux-dispatcher-handler-sequence]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc", "title": "dispatcher-handler", "heading": "WebFlux Config", "heading_level": 2, "file_order": 312, "section_index": 2, "content_hash": "d122496c0261fb86fcb7156bace00c45a1b6d324c304bb92c2904ccccc7a9e9c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc"}}
{"id": "sha256:944ab260065e75f666c4adf082d5ed2d302d029952792aed6ca45ffd0d8a71e3", "content": "[.small]#xref:web/webmvc/mvc-servlet/sequence.adoc[See equivalent in the Servlet stack]#\n\n`DispatcherHandler` processes requests as follows:\n\n* Each `HandlerMapping` is asked to find a matching handler, and the first match is used.\n* If a handler is found, it is run through an appropriate `HandlerAdapter`, which\nexposes the return value from the execution as `HandlerResult`.\n* The `HandlerResult` is given to an appropriate `HandlerResultHandler` to complete\nprocessing by writing to the response directly or by using a view to render.\n\n[[webflux-resulthandling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc", "title": "dispatcher-handler", "heading": "Processing", "heading_level": 2, "file_order": 312, "section_index": 3, "content_hash": "944ab260065e75f666c4adf082d5ed2d302d029952792aed6ca45ffd0d8a71e3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc"}}
{"id": "sha256:132f4b738dfef7105550e9b6b636a95c924072a1bbb79c78d22018600d8fd9fe", "content": "The return value from the invocation of a handler, through a `HandlerAdapter`, is wrapped\nas a `HandlerResult`, along with some additional context, and passed to the first\n`HandlerResultHandler` that claims support for it. The following table shows the available\n`HandlerResultHandler` implementations, all of which are declared in the\nxref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[WebFlux Config]:\n\n[cols=\"1,2,1\", options=\"header\"]\n|===\n| Result Handler Type | Return Values | Default Order\n\n| `ResponseEntityResultHandler`\n| `ResponseEntity`, typically from `@Controller` instances.\n| 0\n\n| `ServerResponseResultHandler`\n| `ServerResponse`, typically from functional endpoints.\n| 0\n\n| `ResponseBodyResultHandler`\n| Handle return values from `@ResponseBody` methods or `@RestController` classes.\n| 100\n\n| `ViewResolutionResultHandler`\n| `CharSequence`, {spring-framework-api}/web/reactive/result/view/View.html[`View`],\n {spring-framework-api}/ui/Model.html[Model], `Map`,\n {spring-framework-api}/web/reactive/result/view/Rendering.html[Rendering],\n or any other `Object` is treated as a model attribute.\n\n See also xref:web/webflux/dispatcher-handler.adoc#webflux-viewresolution[View Resolution].\n| `Integer.MAX_VALUE`\n\n|===\n\n[[webflux-dispatcher-exceptions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc", "title": "dispatcher-handler", "heading": "Result Handling", "heading_level": 2, "file_order": 312, "section_index": 4, "content_hash": "132f4b738dfef7105550e9b6b636a95c924072a1bbb79c78d22018600d8fd9fe", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc"}}
{"id": "sha256:1e29379ef24162815e5d4ae0660f0278ab9f26eca82f035d6c85b5cc03e7725f", "content": "[.small]#xref:web/webmvc/mvc-servlet/exceptionhandlers.adoc[See equivalent in the Servlet stack]#\n\n`HandlerAdapter` implementations can handle internally exceptions from invoking a request\nhandler, such as a controller method. However, an exception may be deferred if the request\nhandler returns an asynchronous value.\n\nA `HandlerAdapter` may expose its exception handling mechanism as a\n`DispatchExceptionHandler` set on the `HandlerResult` it returns. When that's set,\n`DispatcherHandler` will also apply it to the handling of the result.\n\nA `HandlerAdapter` may also choose to implement `DispatchExceptionHandler`. In that case\n`DispatcherHandler` will apply it to exceptions that arise before a handler is mapped,\nfor example, during handler mapping, or earlier, for example, in a `WebFilter`.\n\nSee also xref:web/webflux/controller/ann-exceptions.adoc[Exceptions] in the \"`Annotated Controller`\" section or\nxref:web/webflux/reactive-spring.adoc#webflux-exception-handler[Exceptions] in the WebHandler API section.\n\n[[webflux-viewresolution]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc", "title": "dispatcher-handler", "heading": "Exceptions", "heading_level": 2, "file_order": 312, "section_index": 5, "content_hash": "1e29379ef24162815e5d4ae0660f0278ab9f26eca82f035d6c85b5cc03e7725f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc"}}
{"id": "sha256:eb089fea4f3f394e95a5cdaef0c43fec8b366a29d6cd9e92f2de5c8771c7afb0", "content": "[.small]#xref:web/webmvc/mvc-servlet/viewresolver.adoc[See equivalent in the Servlet stack]#\n\nView resolution enables rendering to a browser with an HTML template and a model without\ntying you to a specific view technology. In Spring WebFlux, view resolution is\nsupported through a dedicated xref:web/webflux/dispatcher-handler.adoc#webflux-resulthandling[HandlerResultHandler]\nthat uses `ViewResolver` instances to map a String (representing a logical view name) to\na `View` instance. The `View` is then used to render the response.\n\nWeb applications need to use a xref:web/webflux-view.adoc[View rendering library] to support this use case.\n\n[[webflux-viewresolution-handling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc", "title": "dispatcher-handler", "heading": "View Resolution", "heading_level": 2, "file_order": 312, "section_index": 6, "content_hash": "eb089fea4f3f394e95a5cdaef0c43fec8b366a29d6cd9e92f2de5c8771c7afb0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc"}}
{"id": "sha256:ff3935b84b2cce4ba80883468cc4238f9c78603e7dc51061c84dafbc8fafe1cb", "content": "[.small]#xref:web/webmvc/mvc-servlet/viewresolver.adoc#mvc-viewresolver-handling[See equivalent in the Servlet stack]#\n\nThe `HandlerResult` passed into `ViewResolutionResultHandler` contains the return value\nfrom the handler and the model that contains attributes added during request\nhandling. The return value is processed as one of the following:\n\n* `String`, `CharSequence`: A logical view name to be resolved to a `View` through\nthe list of configured `ViewResolver` implementations.\n* `void`: Select a default view name based on the request path, minus the leading and\ntrailing slash, and resolve it to a `View`. The same also happens when a view name\nwas not provided (for example, model attribute was returned) or an async return value\n(for example, `Mono` completed empty).\n* {spring-framework-api}/web/reactive/result/view/Rendering.html[Rendering]: API for\nview resolution scenarios. Explore the options in your IDE with code completion.\n* `Model`, `Map`: Extra model attributes to be added to the model for the request.\n* Any other: Any other return value (except for simple types, as determined by\n{spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty])\nis treated as a model attribute to be added to the model. The attribute name is derived\nfrom the class name by using {spring-framework-api}/core/Conventions.html[conventions],\nunless a handler method `@ModelAttribute` annotation is present.\n\nThe model can contain asynchronous, reactive types (for example, from Reactor or RxJava). Prior\nto rendering, `AbstractView` resolves such model attributes into concrete values\nand updates the model. Single-value reactive types are resolved to a single\nvalue or no value (if empty), while multi-value reactive types (for example, `Flux<T>`) are\ncollected and resolved to `List<T>`.\n\nTo configure view resolution is as simple as adding a `ViewResolutionResultHandler` bean\nto your Spring configuration. xref:web/webflux/config.adoc#webflux-config-view-resolvers[WebFlux Config] provides a\ndedicated configuration API for view resolution.\n\nSee xref:web/webflux-view.adoc[View Technologies] for more on the view technologies integrated with Spring WebFlux.\n\n[[webflux-redirecting-redirect-prefix]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc", "title": "dispatcher-handler", "heading": "Handling", "heading_level": 3, "file_order": 312, "section_index": 7, "content_hash": "ff3935b84b2cce4ba80883468cc4238f9c78603e7dc51061c84dafbc8fafe1cb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc"}}
{"id": "sha256:ce9ee49085baaa510eeed13deaa35ebe12159d65f36b701af27353f3d19b19c4", "content": "[.small]#xref:web/webmvc/mvc-servlet/viewresolver.adoc#mvc-redirecting-redirect-prefix[See equivalent in the Servlet stack]#\n\nThe special `redirect:` prefix in a view name lets you perform a redirect. The\n`UrlBasedViewResolver` (and sub-classes) recognize this as an instruction that a\nredirect is needed. The rest of the view name is the redirect URL.\n\nThe net effect is the same as if the controller had returned a `RedirectView` or\n`Rendering.redirectTo(\"abc\").build()`, but now the controller itself can\noperate in terms of logical view names. A view name such as\n`redirect:/some/resource` is relative to the current application, while a view name such as\n`redirect:https://example.com/arbitrary/path` redirects to an absolute URL.\n\nNOTE: xref:web/webmvc/mvc-servlet/viewresolver.adoc#mvc-redirecting-forward-prefix[Unlike the Servlet stack],\nSpring WebFlux does not support \"FORWARD\" dispatches, so `forward:` prefixes are not supported as a result.\n\n[[webflux-multiple-representations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc", "title": "dispatcher-handler", "heading": "Redirecting", "heading_level": 3, "file_order": 312, "section_index": 8, "content_hash": "ce9ee49085baaa510eeed13deaa35ebe12159d65f36b701af27353f3d19b19c4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc"}}
{"id": "sha256:37216ca4fed40dca1ae17fcb29f808766fc2e5a3a8e5dcb2c1a11b2673d6b652", "content": "[.small]#xref:web/webmvc/mvc-servlet/viewresolver.adoc#mvc-multiple-representations[See equivalent in the Servlet stack]#\n\n`ViewResolutionResultHandler` supports content negotiation. It compares the request\nmedia types with the media types supported by each selected `View`. The first `View`\nthat supports the requested media type(s) is used.\n\nIn order to support media types such as JSON and XML, Spring WebFlux provides\n`HttpMessageWriterView`, which is a special `View` that renders through an\nxref:web/webflux/reactive-spring.adoc#webflux-codecs[HttpMessageWriter]. Typically, you would configure these as default\nviews through the xref:web/webflux/config.adoc#webflux-config-view-resolvers[WebFlux Configuration]. Default views are\nalways selected and used if they match the requested media type.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc", "title": "dispatcher-handler", "heading": "Content Negotiation", "heading_level": 3, "file_order": 312, "section_index": 9, "content_hash": "37216ca4fed40dca1ae17fcb29f808766fc2e5a3a8e5dcb2c1a11b2673d6b652", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/dispatcher-handler.adoc"}}
{"id": "sha256:ae1db5c28ed2af0cf1547aae9bf0519ee5f5d4c610b5fbb85d2965478aedadf4", "content": "[[webflux-http2]]\n\n[.small]#xref:web/webmvc/mvc-http2.adoc[See equivalent in the Servlet stack]#\n\nHTTP/2 is supported with Reactor Netty, Tomcat, and Jetty. However, there are\nconsiderations related to server configuration. For more details, see the\n{spring-framework-wiki}/HTTP-2-support[HTTP/2 wiki page].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/http2.adoc", "title": "http2", "heading": "http2", "heading_level": 1, "file_order": 313, "section_index": 0, "content_hash": "ae1db5c28ed2af0cf1547aae9bf0519ee5f5d4c610b5fbb85d2965478aedadf4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/http2.adoc"}}
{"id": "sha256:e7a03a276e6a19daa9438f337e829bbcfd9ef6cb4cb578634591c920a8d7668a", "content": "[[webflux-new-framework]]\n\nWhy was Spring WebFlux created?\n\nPart of the answer is the need for a non-blocking web stack to handle concurrency with a\nsmall number of threads and scale with fewer hardware resources. Servlet non-blocking I/O\nleads away from the rest of the Servlet API, where contracts are synchronous\n(`Filter`, `Servlet`) or blocking (`getParameter`, `getPart`). This was the motivation\nfor a new common API to serve as a foundation across any non-blocking runtime. That is\nimportant because of servers (such as Netty) that are well-established in the async,\nnon-blocking space.\n\nThe other part of the answer is functional programming. Much as the addition of annotations\nin Java 5 created opportunities (such as annotated REST controllers or unit tests), the\naddition of lambda expressions in Java 8 created opportunities for functional APIs in Java.\nThis is a boon for non-blocking applications and continuation-style APIs (as popularized\nby `CompletableFuture` and https://reactivex.io/[ReactiveX]) that allow declarative\ncomposition of asynchronous logic. At the programming-model level, Java 8 enabled Spring\nWebFlux to offer functional web endpoints alongside annotated controllers.\n\n[[webflux-why-reactive]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc", "title": "new-framework", "heading": "new-framework", "heading_level": 1, "file_order": 314, "section_index": 0, "content_hash": "e7a03a276e6a19daa9438f337e829bbcfd9ef6cb4cb578634591c920a8d7668a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc"}}
{"id": "sha256:c1cec74b91e5d9e2f9f212297040af40507af0cb32515d83cfa22f3066cb67ed", "content": "We touched on \"`non-blocking`\" and \"`functional`\" but what does reactive mean?\n\nThe term, \"`reactive,`\" refers to programming models that are built around reacting to change --\nnetwork components reacting to I/O events, UI controllers reacting to mouse events, and others.\nIn that sense, non-blocking is reactive, because, instead of being blocked, we are now in the mode\nof reacting to notifications as operations complete or data becomes available.\n\nThere is also another important mechanism that we on the Spring team associate with \"`reactive`\"\nand that is non-blocking back pressure. In synchronous, imperative code, blocking calls\nserve as a natural form of back pressure that forces the caller to wait. In non-blocking\ncode, it becomes important to control the rate of events so that a fast producer does not\noverwhelm its destination.\n\nReactive Streams is a\n{reactive-streams-spec}[small spec]\n(also {java-api}/java.base/java/util/concurrent/Flow.html[adopted] in Java 9)\nthat defines the interaction between asynchronous components with back pressure.\nFor example a data repository (acting as\n{reactive-streams-site}/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html[Publisher])\ncan produce data that an HTTP server (acting as\n{reactive-streams-site}/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html[Subscriber])\ncan then write to the response. The main purpose of Reactive Streams is to let the\n subscriber control how quickly or how slowly the publisher produces data.\n\nNOTE: *Common question: what if a publisher cannot slow down?* +\nThe purpose of Reactive Streams is only to establish the mechanism and a boundary.\nIf a publisher cannot slow down, it has to decide whether to buffer, drop, or fail.\n\n[[webflux-reactive-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc", "title": "new-framework", "heading": "Define \"`Reactive`\"", "heading_level": 2, "file_order": 314, "section_index": 1, "content_hash": "c1cec74b91e5d9e2f9f212297040af40507af0cb32515d83cfa22f3066cb67ed", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc"}}
{"id": "sha256:5ba26532b654f94fbb08d239bd3a0cd63c45d16be473657038fc9d5d870a4bbb", "content": "Reactive Streams plays an important role for interoperability. It is of interest to libraries\nand infrastructure components but less useful as an application API, because it is too\nlow-level. Applications need a higher-level and richer, functional API to\ncompose async logic -- similar to the Java `Stream` API but not only for collections.\nThis is the role that reactive libraries play.\n\n{reactor-github-org}/reactor[Reactor] is the reactive library of choice for\nSpring WebFlux. It provides the\n{reactor-site}/docs/core/release/api/reactor/core/publisher/Mono.html[`Mono`] and\n{reactor-site}/docs/core/release/api/reactor/core/publisher/Flux.html[`Flux`] API types\nto work on data sequences of 0..1 (`Mono`) and 0..N (`Flux`) through a rich set of operators aligned with the\nReactiveX https://reactivex.io/documentation/operators.html[vocabulary of operators].\nReactor is a Reactive Streams library and, therefore, all of its operators support non-blocking back pressure.\nReactor has a strong focus on server-side Java. It is developed in close collaboration\nwith Spring.\n\nWebFlux requires Reactor as a core dependency but it is interoperable with other reactive\nlibraries via Reactive Streams. As a general rule, a WebFlux API accepts a plain `Publisher`\nas input, adapts it to a Reactor type internally, uses that, and returns either a\n`Flux` or a `Mono` as output. So, you can pass any `Publisher` as input and you can apply\noperations on the output, but you need to adapt the output for use with another reactive library.\nWhenever feasible (for example, annotated controllers), WebFlux adapts transparently to the use\nof RxJava or another reactive library. See xref:web/webflux-reactive-libraries.adoc[Reactive Libraries] for more details.\n\nNOTE: In addition to Reactive APIs, WebFlux can also be used with\nxref:languages/kotlin/coroutines.adoc[Coroutines] APIs in Kotlin which provides a more imperative style of programming.\nThe following Kotlin code samples will be provided with Coroutines APIs.\n\n[[webflux-programming-models]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc", "title": "new-framework", "heading": "Reactive API", "heading_level": 2, "file_order": 314, "section_index": 2, "content_hash": "5ba26532b654f94fbb08d239bd3a0cd63c45d16be473657038fc9d5d870a4bbb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc"}}
{"id": "sha256:7a8f1178244ce3474253b4d7dcbac7c1fc6874ddd351d9d79d9e24a246652999", "content": "The `spring-web` module contains the reactive foundation that underlies Spring WebFlux,\nincluding HTTP abstractions, Reactive Streams xref:web/webflux/reactive-spring.adoc#webflux-httphandler[adapters]\nfor supported servers, xref:web/webflux/reactive-spring.adoc#webflux-codecs[codecs], and a core\nxref:web/webflux/reactive-spring.adoc#webflux-web-handler-api[`WebHandler` API] comparable to\nthe Servlet API but with non-blocking contracts.\n\nOn that foundation, Spring WebFlux provides a choice of two programming models:\n\n* xref:web/webflux/controller.adoc[Annotated Controllers]: Consistent with Spring MVC and based on the\nsame annotations from the `spring-web` module. Both Spring MVC and WebFlux controllers support reactive\n(Reactor and RxJava) return types, and, as a result, it is not easy to tell them apart. One notable\ndifference is that WebFlux also supports reactive `@RequestBody` arguments.\n* xref:web/webflux-functional.adoc[Functional Endpoints]: Lambda-based, lightweight,\nand functional programming model. You can think of this as a small library or a set of\nutilities that an application can use to route and handle requests. The big difference\nwith annotated controllers is that the application is in charge of request handling\nfrom start to finish versus declaring intent through annotations and being called back.\n\n[[webflux-framework-choice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc", "title": "new-framework", "heading": "Programming Models", "heading_level": 2, "file_order": 314, "section_index": 3, "content_hash": "7a8f1178244ce3474253b4d7dcbac7c1fc6874ddd351d9d79d9e24a246652999", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc"}}
{"id": "sha256:0810f7b2e1f9412f9fc70e85b4c5468cb5da4f3531c00da6fda4c1869bd71ca2", "content": "Spring MVC or WebFlux?\n\nA natural question to ask but one that sets up an unsound dichotomy. Actually, both\nwork together to expand the range of available options. The two are designed for\ncontinuity and consistency with each other, they are available side by side, and feedback\nfrom each side benefits both sides. The following diagram shows how the two relate, what they\nhave in common, and what each supports uniquely:\n\nimage::spring-mvc-and-webflux-venn.png[]\n\nWe suggest that you consider the following specific points:\n\n* If you have a Spring MVC application that works fine, there is no need to change.\nImperative programming is the easiest way to write, understand, and debug code.\nYou have maximum choice of libraries, since, historically, most are blocking.\n\n* If you are already shopping for a non-blocking web stack, Spring WebFlux offers the same\nexecution model benefits as others in this space and also provides a choice of servers\n(Netty, Tomcat, Jetty, and Servlet containers), a choice of programming models\n(annotated controllers and functional web endpoints), and a choice of reactive libraries\n(Reactor, RxJava, or other).\n\n* If you are interested in a lightweight, functional web framework for use with Java\nor Kotlin, you can use the Spring WebFlux functional web endpoints. That can also be a good choice\nfor smaller applications or microservices with less complex requirements that can benefit\nfrom greater transparency and control.\n\n* In a microservice architecture, you can have a mix of applications with either Spring MVC\nor Spring WebFlux controllers or with Spring WebFlux functional endpoints. Having support\nfor the same annotation-based programming model in both frameworks makes it easier to\nre-use knowledge while also selecting the right tool for the right job.\n\n* A simple way to evaluate an application is to check its dependencies. If you have blocking\npersistence APIs (JPA, JDBC) or networking APIs to use, Spring MVC is the best choice\nfor common architectures at least. It is technically feasible with both Reactor and\nRxJava to perform blocking calls on a separate thread but you would not be making the\nmost of a non-blocking web stack.\n\n* If you have a Spring MVC application with calls to remote services, try the reactive `WebClient`.\nYou can return reactive types (Reactor, RxJava, xref:web/webflux-reactive-libraries.adoc[or other])\ndirectly from Spring MVC controller methods. The greater the latency per call or the\ninterdependency among calls, the more dramatic the benefits. Spring MVC controllers\ncan call other reactive components too.\n\n* If you have a large team, keep in mind the steep learning curve in the shift to non-blocking,\nfunctional, and declarative programming. A practical way to start without a full switch\nis to use the reactive `WebClient`. Beyond that, start small and measure the benefits.\nWe expect that, for a wide range of applications, the shift is unnecessary. If you are\nunsure what benefits to look for, start by learning about how non-blocking I/O works\n(for example, concurrency on single-threaded Node.js) and its effects.\n\n[[webflux-server-choice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc", "title": "new-framework", "heading": "Applicability", "heading_level": 2, "file_order": 314, "section_index": 4, "content_hash": "0810f7b2e1f9412f9fc70e85b4c5468cb5da4f3531c00da6fda4c1869bd71ca2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc"}}
{"id": "sha256:2897c993f01058b5a283d8554454fcc474a55c93be8f0500a4883b431c0f8e03", "content": "Spring WebFlux is supported on Tomcat, Jetty, Servlet containers, as well as on\nnon-Servlet runtimes such as Netty. All servers are adapted to a low-level,\nxref:web/webflux/reactive-spring.adoc#webflux-httphandler[common API] so that higher-level\nxref:web/webflux/new-framework.adoc#webflux-programming-models[programming models] can be supported across servers.\n\nSpring WebFlux does not have built-in support to start or stop a server. However, it is\neasy to xref:web/webflux/reactive-spring.adoc#webflux-web-handler-api[assemble] an application from Spring configuration and\nxref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[WebFlux infrastructure] and xref:web/webflux/reactive-spring.adoc#webflux-httphandler[run it] with a few\nlines of code.\n\nSpring Boot has a WebFlux starter that automates these steps. By default, the starter uses\nNetty, but it is easy to switch to Tomcat, or Jetty by changing your\nMaven or Gradle dependencies. Spring Boot defaults to Netty, because it is more widely\nused in the asynchronous, non-blocking space and lets a client and a server share resources.\n\nTomcat and Jetty can be used with both Spring MVC and WebFlux. Keep in mind, however, that\nthe way they are used is very different. Spring MVC relies on Servlet blocking I/O and\nlets applications use the Servlet API directly if they need to. Spring WebFlux\nrelies on Servlet non-blocking I/O and uses the Servlet API behind a low-level\nadapter. It is not exposed for direct use.\n\nNOTE: It is strongly advised not to map Servlet filters or directly manipulate the Servlet API in the context of a WebFlux application.\nFor the reasons listed above, mixing blocking I/O and non-blocking I/O in the same context will cause runtime issues.\n\n[[webflux-performance]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc", "title": "new-framework", "heading": "Servers", "heading_level": 2, "file_order": 314, "section_index": 5, "content_hash": "2897c993f01058b5a283d8554454fcc474a55c93be8f0500a4883b431c0f8e03", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc"}}
{"id": "sha256:8a9a3422249ae8d72437d9e2dc459e793cfbde888628364399923a5c1a52a62a", "content": "Performance has many characteristics and meanings. Reactive and non-blocking generally\ndo not make applications run faster. They can in some cases â€“ for example, if using the\n`WebClient` to run remote calls in parallel. However, it requires more work to do\nthings the non-blocking way, and that can slightly increase the required processing time.\n\nThe key expected benefit of reactive and non-blocking is the ability to scale with a small,\nfixed number of threads and less memory. That makes applications more resilient under load,\nbecause they scale in a more predictable way. In order to observe those benefits, however, you\nneed to have some latency (including a mix of slow and unpredictable network I/O).\nThat is where the reactive stack begins to show its strengths, and the differences can be\ndramatic.\n\n[[webflux-concurrency-model]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc", "title": "new-framework", "heading": "Performance", "heading_level": 2, "file_order": 314, "section_index": 6, "content_hash": "8a9a3422249ae8d72437d9e2dc459e793cfbde888628364399923a5c1a52a62a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc"}}
{"id": "sha256:e09735545dd66f880a6cb8a75e3f6c8d633ef1d2367fdac5be861cee617b65d5", "content": "Both Spring MVC and Spring WebFlux support annotated controllers, but there is a key\ndifference in the concurrency model and the default assumptions for blocking and threads.\n\nIn Spring MVC (and servlet applications in general), it is assumed that applications can\nblock the current thread, (for example, for remote calls). For this reason, servlet containers\nuse a large thread pool to absorb potential blocking during request handling.\n\nIn Spring WebFlux (and non-blocking servers in general), it is assumed that applications\ndo not block. Therefore, non-blocking servers use a small, fixed-size thread pool\n(event loop workers) to handle requests.\n\nTIP: \"`To scale`\" and \"`small number of threads`\" may sound contradictory, but to never block the\ncurrent thread (and rely on callbacks instead) means that you do not need extra threads, as\nthere are no blocking calls to absorb.\n\n[[invoking-a-blocking-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc", "title": "new-framework", "heading": "Concurrency Model", "heading_level": 2, "file_order": 314, "section_index": 7, "content_hash": "e09735545dd66f880a6cb8a75e3f6c8d633ef1d2367fdac5be861cee617b65d5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc"}}
{"id": "sha256:b1df9363cb558ecefd92131453495f6d8ad40a1fa073f787d039e497e8985bc3", "content": "What if you do need to use a blocking library? Both Reactor and RxJava provide the\n`publishOn` operator to continue processing on a different thread. That means there is an\neasy escape hatch. Keep in mind, however, that blocking APIs are not a good fit for\nthis concurrency model.\n\n[[mutable-state]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc", "title": "new-framework", "heading": "Invoking a Blocking API", "heading_level": 3, "file_order": 314, "section_index": 8, "content_hash": "b1df9363cb558ecefd92131453495f6d8ad40a1fa073f787d039e497e8985bc3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc"}}
{"id": "sha256:3b9b636291bc6cc5990fd11939dae652a7b396bbdb04381cb51b0aa60a5e2e2d", "content": "In Reactor and RxJava, you declare logic through operators. At runtime, a reactive\npipeline is formed where data is processed sequentially, in distinct stages. A key benefit\nof this is that it frees applications from having to protect mutable state because\napplication code within that pipeline is never invoked concurrently.\n\n[[threading-model]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc", "title": "new-framework", "heading": "Mutable State", "heading_level": 3, "file_order": 314, "section_index": 9, "content_hash": "3b9b636291bc6cc5990fd11939dae652a7b396bbdb04381cb51b0aa60a5e2e2d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc"}}
{"id": "sha256:613cf9991e1bffadfbde07f0a7805fde9f089ecd2300f16d12eded66da73a63f", "content": "What threads should you expect to see on a server running with Spring WebFlux?\n\n* On a \"`vanilla`\" Spring WebFlux server (for example, no data access or other optional\ndependencies), you can expect one thread for the server and several others for request\nprocessing (typically as many as the number of CPU cores). Servlet containers, however,\nmay start with more threads (for example, 10 on Tomcat), in support of both servlet (blocking) I/O\nand servlet 3.1 (non-blocking) I/O usage.\n\n* The reactive `WebClient` operates in event loop style. So you can see a small, fixed\nnumber of processing threads related to that (for example, `reactor-http-nio-` with the Reactor\nNetty connector). However, if Reactor Netty is used for both client and server, the two\nshare event loop resources by default.\n\n* Reactor and RxJava provide thread pool abstractions, called schedulers, to use with the\n`publishOn` operator that is used to switch processing to a different thread pool.\nThe schedulers have names that suggest a specific concurrency strategy -- for example, \"`parallel`\"\n(for CPU-bound work with a limited number of threads) or \"`elastic`\" (for I/O-bound work with\na large number of threads). If you see such threads, it means some code is using a\nspecific thread pool `Scheduler` strategy.\n\n* Data access libraries and other third party dependencies can also create and use threads\nof their own.\n\n[[configuring]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc", "title": "new-framework", "heading": "Threading Model", "heading_level": 3, "file_order": 314, "section_index": 10, "content_hash": "613cf9991e1bffadfbde07f0a7805fde9f089ecd2300f16d12eded66da73a63f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc"}}
{"id": "sha256:56bb7b308ee6263342371a9dca27c6ab7ea360622bf39ac9fe07ad5d1df7c785", "content": "The Spring Framework does not provide support for starting and stopping\nxref:web/webflux/new-framework.adoc#webflux-server-choice[servers]. To configure the threading model for a server,\nyou need to use server-specific configuration APIs, or, if you use Spring Boot,\ncheck the Spring Boot configuration options for each server. You can\nxref:web/webflux-webclient/client-builder.adoc[configure] the `WebClient` directly.\nFor all other libraries, see their respective documentation.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc", "title": "new-framework", "heading": "Configuring", "heading_level": 3, "file_order": 314, "section_index": 11, "content_hash": "56bb7b308ee6263342371a9dca27c6ab7ea360622bf39ac9fe07ad5d1df7c785", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/new-framework.adoc"}}
{"id": "sha256:66459fb995a67947dc80e6ba3ef21f2348dc1e93d75a625028c446c6b1b43a94", "content": "[[webflux-range]]\n\n[.small]#xref:web/webmvc/mvc-range.adoc[See equivalent in the Servlet stack]#\n\nSpring WebFlux supports https://datatracker.ietf.org/doc/html/rfc9110#section-14[RFC 9110]\nrange requests. For an overview, see the\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Range_requests[Ranger Requests]\nMozilla guide.\n\nThe `Range` header is parsed and handled transparently in WebFlux when an annotated\ncontroller returns a `Resource` or `ResponseEntity<Resource>`, or a functional endpoint\nxref:web/webflux-functional.adoc#webflux-fn-resources[serves a `Resource`]. `Range` header\nsupport is also transparently handled when serving\nxref:web/webflux/config.adoc#webflux-config-static-resources[static resources].\n\nTIP: The `Resource` must not be an `InputStreamResource` and with `ResponseEntity<Resource>`,\nthe status of the response must be 200.\n\nThe underlying support is in the `HttpRange` class, which exposes methods to parse\n`Range` headers and split a `Resource` into a `List<ResourceRegion>` that in turn can be\nthen written to the response via `ResourceRegionEncoder` and `ResourceHttpMessageWriter`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/range.adoc", "title": "range", "heading": "range", "heading_level": 1, "file_order": 315, "section_index": 0, "content_hash": "66459fb995a67947dc80e6ba3ef21f2348dc1e93d75a625028c446c6b1b43a94", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/range.adoc"}}
{"id": "sha256:7912e1ae73cc66006448302e336949a884612eb98cdfede6e7979a04a1f8db39", "content": "[[webflux-reactive-spring-web]]\n\nThe `spring-web` module contains the following foundational support for reactive web\napplications:\n\n* For server request processing there are two levels of support.\n** xref:web/webflux/reactive-spring.adoc#webflux-httphandler[HttpHandler]: Basic contract for HTTP request handling with\nnon-blocking I/O and Reactive Streams back pressure, along with adapters for Reactor Netty,\nTomcat, Jetty, and any Servlet container.\n** xref:web/webflux/reactive-spring.adoc#webflux-web-handler-api[`WebHandler` API]: Slightly higher level, general-purpose web API for\nrequest handling, on top of which concrete programming models such as annotated\ncontrollers and functional endpoints are built.\n* For the client side, there is a basic `ClientHttpConnector` contract to perform HTTP\nrequests with non-blocking I/O and Reactive Streams back pressure, along with adapters for\n{reactor-github-org}/reactor-netty[Reactor Netty], reactive\nhttps://github.com/jetty-project/jetty-reactive-httpclient[Jetty HttpClient]\nand https://hc.apache.org/[Apache HttpComponents].\nThe higher level xref:web/webflux-webclient.adoc[WebClient] used in applications\nbuilds on this basic contract.\n* For client and server, xref:web/webflux/reactive-spring.adoc#webflux-codecs[codecs] for serialization and\ndeserialization of HTTP request and response content.\n\n[[webflux-httphandler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "reactive-spring", "heading_level": 1, "file_order": 316, "section_index": 0, "content_hash": "7912e1ae73cc66006448302e336949a884612eb98cdfede6e7979a04a1f8db39", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:a8868bbb5959b0a95a2fa2e50eb742cd18d7195a5ba8128166e8aea6454e5feb", "content": "{spring-framework-api}/http/server/reactive/HttpHandler.html[HttpHandler]\nis a simple contract with a single method to handle a request and a response. It is\nintentionally minimal, and its main and only purpose is to be a minimal abstraction\nover different HTTP server APIs.\n\nThe following table describes the supported server APIs:\n\n[cols=\"1,2,2\", options=\"header\"]\n|===\n| Server name | Server API used | Reactive Streams support\n\n| Netty\n| Netty API\n| {reactor-github-org}/reactor-netty[Reactor Netty]\n\n| Tomcat\n| Servlet non-blocking I/O; Tomcat API to read and write ByteBuffers vs byte[]\n| spring-web: Servlet non-blocking I/O to Reactive Streams bridge\n\n| Jetty\n| Servlet non-blocking I/O; Jetty API to write ByteBuffers vs byte[]\n| spring-web: Servlet non-blocking I/O to Reactive Streams bridge\n\n| Servlet container\n| Servlet non-blocking I/O\n| spring-web: Servlet non-blocking I/O to Reactive Streams bridge\n|===\n\nThe following table describes server dependencies (also see\n{spring-framework-wiki}/What%27s-New-in-the-Spring-Framework[supported versions]):\n\n|===\n|Server name|Group id|Artifact name\n\n|Reactor Netty\n|io.projectreactor.netty\n|reactor-netty\n\n|Tomcat\n|org.apache.tomcat.embed\n|tomcat-embed-core\n\n|Jetty\n|org.eclipse.jetty\n|jetty-server, jetty-servlet\n|===\n\nThe code snippets below show using the `HttpHandler` adapters with each server API.\n\n*Reactor Netty*\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHttpHandler handler = ...\n\tReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);\n\tHttpServer.create().host(host).port(port).handle(adapter).bindNow();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval handler: HttpHandler = ...\n\tval adapter = ReactorHttpHandlerAdapter(handler)\n\tHttpServer.create().host(host).port(port).handle(adapter).bindNow()\n----\n======\n\n*Tomcat*\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHttpHandler handler = ...\n\tServlet servlet = new TomcatHttpHandlerAdapter(handler);\n\n\tTomcat server = new Tomcat();\n\tFile base = new File(System.getProperty(\"java.io.tmpdir\"));\n\tContext rootContext = server.addContext(\"\", base.getAbsolutePath());\n\tTomcat.addServlet(rootContext, \"main\", servlet);\n\trootContext.addServletMappingDecoded(\"/\", \"main\");\n\tserver.setHost(host);\n\tserver.setPort(port);\n\tserver.start();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval handler: HttpHandler = ...\n\tval servlet = TomcatHttpHandlerAdapter(handler)\n\n\tval server = Tomcat()\n\tval base = File(System.getProperty(\"java.io.tmpdir\"))\n\tval rootContext = server.addContext(\"\", base.absolutePath)\n\tTomcat.addServlet(rootContext, \"main\", servlet)\n\trootContext.addServletMappingDecoded(\"/\", \"main\")\n\tserver.host = host\n\tserver.setPort(port)\n\tserver.start()\n----\n======\n\n*Jetty*\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHttpHandler handler = ...\n\tJettyCoreHttpHandlerAdapter adapter = new JettyCoreHttpHandlerAdapter(handler);\n\n\tServer server = new Server();\n\tserver.setHandler(adapter);\n\n\tServerConnector connector = new ServerConnector(server);\n\tconnector.setHost(host);\n\tconnector.setPort(port);\n\tserver.addConnector(connector);\n\n\tserver.start();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval handler: HttpHandler = ...\n\tval adapter = JettyCoreHttpHandlerAdapter(handler)\n\n\tval server = Server()\n\tserver.setHandler(adapter)\n\n\tval connector = ServerConnector(server)\n\tconnector.host = host\n\tconnector.port = port\n\tserver.addConnector(connector)\n\n\tserver.start()\n----\n======\n\nTIP: In Spring Framework 6.2, `JettyHttpHandlerAdapter` was deprecated in favor of\n`JettyCoreHttpHandlerAdapter`, which integrates directly with Jetty 12 APIs\nwithout a Servlet layer.\n\nTo deploy as a WAR to a Servlet container instead, use\n{spring-framework-api}/web/server/adapter/AbstractReactiveWebInitializer.html[`AbstractReactiveWebInitializer`],\nto adapt `HttpHandler` to a `Servlet` via `ServletHttpHandlerAdapter`.\n\n[[webflux-web-handler-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "`HttpHandler`", "heading_level": 2, "file_order": 316, "section_index": 1, "content_hash": "a8868bbb5959b0a95a2fa2e50eb742cd18d7195a5ba8128166e8aea6454e5feb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:9d15334de30a35d2ef7f463913cbac78400285fe7afeadb5e0cb6f436f5e6955", "content": "The `org.springframework.web.server` package builds on the\nxref:web/webflux/reactive-spring.adoc#webflux-httphandler[`HttpHandler`] contract\nto provide a general-purpose web API for processing requests through a chain of multiple\n{spring-framework-api}/web/server/WebExceptionHandler.html[`WebExceptionHandler`], multiple\n{spring-framework-api}/web/server/WebFilter.html[`WebFilter`], and a single\n{spring-framework-api}/web/server/WebHandler.html[`WebHandler`] component. The chain can\nbe put together with `WebHttpHandlerBuilder` by simply pointing to a Spring\n`ApplicationContext` where components are\nxref:web/webflux/reactive-spring.adoc#webflux-web-handler-api-special-beans[auto-detected], and/or by registering components\nwith the builder.\n\nWhile `HttpHandler` has a simple goal to abstract the use of different HTTP servers, the\n`WebHandler` API aims to provide a broader set of features commonly used in web applications\nsuch as:\n\n* User session with attributes.\n* Request attributes.\n* Resolved `Locale` or `Principal` for the request.\n* Access to parsed and cached form data.\n* Abstractions for multipart data.\n* and more..\n\n[[webflux-web-handler-api-special-beans]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "`WebHandler` API", "heading_level": 2, "file_order": 316, "section_index": 2, "content_hash": "9d15334de30a35d2ef7f463913cbac78400285fe7afeadb5e0cb6f436f5e6955", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:93e43cae4edb441ce22bc04c37bc7050e8031f8b5c77b24feb9d42d831e3334b", "content": "The table below lists the components that `WebHttpHandlerBuilder` can auto-detect in a\nSpring ApplicationContext, or that can be registered directly with it:\n\n[cols=\"2,2,1,3\", options=\"header\"]\n|===\n| Bean name | Bean type | Count | Description\n\n| <any>\n| `WebExceptionHandler`\n| 0..N\n| Provide handling for exceptions from the chain of `WebFilter` instances and the target\n `WebHandler`. For more details, see xref:web/webflux/reactive-spring.adoc#webflux-exception-handler[Exceptions].\n\n| <any>\n| `WebFilter`\n| 0..N\n| Apply interception style logic to before and after the rest of the filter chain and\n the target `WebHandler`. For more details, see xref:web/webflux/reactive-spring.adoc#webflux-filters[Filters].\n\n| `webHandler`\n| `WebHandler`\n| 1\n| The handler for the request.\n\n| `webSessionManager`\n| `WebSessionManager`\n| 0..1\n| The manager for `WebSession` instances exposed through a method on `ServerWebExchange`.\n `DefaultWebSessionManager` by default.\n\n| `serverCodecConfigurer`\n| `ServerCodecConfigurer`\n| 0..1\n| For access to `HttpMessageReader` instances for parsing form data and multipart data that is then\n exposed through methods on `ServerWebExchange`. `ServerCodecConfigurer.create()` by default.\n\n| `localeContextResolver`\n| `LocaleContextResolver`\n| 0..1\n| The resolver for `LocaleContext` exposed through a method on `ServerWebExchange`.\n `AcceptHeaderLocaleContextResolver` by default.\n\n| `forwardedHeaderTransformer`\n| `ForwardedHeaderTransformer`\n| 0..1\n| For processing forwarded type headers, either by extracting and removing them or by removing them only.\n Not used by default.\n|===\n\n[[webflux-form-data]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Special bean types", "heading_level": 3, "file_order": 316, "section_index": 3, "content_hash": "93e43cae4edb441ce22bc04c37bc7050e8031f8b5c77b24feb9d42d831e3334b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:b151e4ae8e22b08fa9a4168b7ca13a95e496046255deb9a708a1ab27672505f8", "content": "`ServerWebExchange` exposes the following method for accessing form data:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMono<MultiValueMap<String, String>> getFormData();\n----\n\nKotlin::\n+\n[source,Kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tsuspend fun getFormData(): MultiValueMap<String, String>\n----\n======\n\nThe `DefaultServerWebExchange` uses the configured `HttpMessageReader` to parse form data\n(`application/x-www-form-urlencoded`) into a `MultiValueMap`. By default,\n`FormHttpMessageReader` is configured for use by the `ServerCodecConfigurer` bean\n(see the xref:web/webflux/reactive-spring.adoc#webflux-web-handler-api[Web Handler API]).\n\n[[webflux-multipart]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Form Data", "heading_level": 3, "file_order": 316, "section_index": 4, "content_hash": "b151e4ae8e22b08fa9a4168b7ca13a95e496046255deb9a708a1ab27672505f8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:cdf7e58c686c09e7960441e0cb5a1c7300c322aa8c751c4e3986f5eacf650a3e", "content": "[.small]#xref:web/webmvc/mvc-servlet/multipart.adoc[See equivalent in the Servlet stack]#\n\n`ServerWebExchange` exposes the following method for accessing multipart data:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMono<MultiValueMap<String, Part>> getMultipartData();\n----\n\nKotlin::\n+\n[source,Kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tsuspend fun getMultipartData(): MultiValueMap<String, Part>\n----\n======\n\nThe `DefaultServerWebExchange` uses the configured\n`HttpMessageReader<MultiValueMap<String, Part>>` to parse `multipart/form-data`,\n`multipart/mixed`, and `multipart/related` content into a `MultiValueMap`.\nBy default, this is the `DefaultPartHttpMessageReader`, which does not have any third-party\ndependencies.\nAlternatively, the `SynchronossPartHttpMessageReader` can be used, which is based on the\nhttps://github.com/synchronoss/nio-multipart[Synchronoss NIO Multipart] library.\nBoth are configured through the `ServerCodecConfigurer` bean\n(see the xref:web/webflux/reactive-spring.adoc#webflux-web-handler-api[Web Handler API]).\n\nTo parse multipart data in streaming fashion, you can use the `Flux<PartEvent>` returned from the\n`PartEventHttpMessageReader` instead of using `@RequestPart`, as that implies `Map`-like access\nto individual parts by name and, hence, requires parsing multipart data in full.\nBy contrast, you can use `@RequestBody` to decode the content to `Flux<PartEvent>` without\ncollecting to a `MultiValueMap`.\n\n[[webflux-forwarded-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Multipart Data", "heading_level": 3, "file_order": 316, "section_index": 5, "content_hash": "cdf7e58c686c09e7960441e0cb5a1c7300c322aa8c751c4e3986f5eacf650a3e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:c4c56e839696a3b2e3210e7fd6692ff1956c4655e99ceb15330f0a2e14a0632f", "content": "[.small]#xref:web/webmvc/filters.adoc#filters-forwarded-headers[See equivalent in the Servlet stack]#\n\nAs a request goes through proxies such as load balancers the host, port, and\nscheme may change, and that makes it a challenge to create links that point to the correct\nhost, port, and scheme from a client perspective.\n\n{rfc-site}/rfc7239[RFC 7239] defines the `Forwarded` HTTP header\nthat proxies can use to provide information about the original request.\n\n[[forwarded-headers-non-standard]]\n=== Non-standard Headers\n\nThere are other non-standard headers, too, including `X-Forwarded-Host`, `X-Forwarded-Port`,\n`X-Forwarded-Proto`, `X-Forwarded-Ssl`, `X-Forwarded-Prefix`, and `X-Forwarded-For`.\n\n[[x-forwarded-host]]\n==== X-Forwarded-Host\n\nWhile not standard, https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host[`X-Forwarded-Host: <host>`]\nis a de-facto standard header that is used to communicate the original host to a\ndownstream server. For example, if a request of `https://example.com/resource` is sent to\na proxy which forwards the request to `http://localhost:8080/resource`, then a header of\n`X-Forwarded-Host: example.com` can be sent to inform the server that the original host was `example.com`.\n\n[[x-forwarded-port]]\n==== X-Forwarded-Port\n\nWhile not standard, `X-Forwarded-Port: <port>` is a de-facto standard header that is used to\ncommunicate the original port to a downstream server. For example, if a request of\n`https://example.com/resource` is sent to a proxy which forwards the request to\n`http://localhost:8080/resource`, then a header of `X-Forwarded-Port: 443` can be sent\nto inform the server that the original port was `443`.\n\n[[x-forwarded-proto]]\n==== X-Forwarded-Proto\n\nWhile not standard, https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto[`X-Forwarded-Proto: (https|http)`]\nis a de-facto standard header that is used to communicate the original protocol (for example, https / http)\nto a downstream server. For example, if a request of `https://example.com/resource` is sent to\na proxy which forwards the request to `http://localhost:8080/resource`, then a header of\n`X-Forwarded-Proto: https` can be sent to inform the server that the original protocol was `https`.\n\n[[x-forwarded-ssl]]\n==== X-Forwarded-Ssl\n\nWhile not standard, `X-Forwarded-Ssl: (on|off)` is a de-facto standard header that is used to communicate the\noriginal protocol (for example, https / https) to a downstream server. For example, if a request of\n`https://example.com/resource` is sent to a proxy which forwards the request to\n`http://localhost:8080/resource`, then a header of `X-Forwarded-Ssl: on` to inform the server that the\noriginal protocol was `https`.\n\n[[x-forwarded-prefix]]\n==== X-Forwarded-Prefix\n\nWhile not standard, https://microsoft.github.io/reverse-proxy/articles/transforms.html#defaults[`X-Forwarded-Prefix: <prefix>`]\nis a de-facto standard header that is used to communicate the original URL path prefix to a\ndownstream server.\n\nUse of `X-Forwarded-Prefix` can vary by deployment scenario, and needs to be flexible to\nallow replacing, removing, or prepending the path prefix of the target server.\n\n_Scenario 1: Override path prefix_\n\n[subs=\"-attributes\"]\n----\nhttps://example.com/api/{path} -> http://localhost:8080/app1/{path}\n----\n\nThe prefix is the start of the path before the capture group `+{path}+`. For the proxy,\nthe prefix is `/api` while for the server the prefix is `/app1`. In this case, the proxy\ncan send `X-Forwarded-Prefix: /api` to have the original prefix `/api` override the\nserver prefix `/app1`.\n\n_Scenario 2: Remove path prefix_\n\nAt times, an application may want to have the prefix removed. For example, consider the\nfollowing proxy to server mapping:\n\n[subs=\"-attributes\"]\n----\nhttps://app1.example.com/{path} -> http://localhost:8080/app1/{path}\nhttps://app2.example.com/{path} -> http://localhost:8080/app2/{path}\n----\n\nThe proxy has no prefix, while applications `app1` and `app2` have path prefixes\n`/app1` and `/app2` respectively. The proxy can send ``X-Forwarded-Prefix: `` to\nhave the empty prefix override server prefixes `/app1` and `/app2`.\n\n[NOTE]\n====\nA common case for this deployment scenario is where licenses are paid per\nproduction application server, and it is preferable to deploy multiple applications per\nserver to reduce fees. Another reason is to run more applications on the same server in\norder to share the resources required by the server to run.\n\nIn these scenarios, applications need a non-empty context root because there are multiple\napplications on the same server. However, this should not be visible in URL paths of\nthe public API where applications may use different subdomains that provides benefits\nsuch as:\n\n* Added security, for example, same origin policy\n* Independent scaling of applications (different domain points to different IP address)\n====\n\n_Scenario 3: Insert path prefix_\n\nIn other cases, it may be necessary to prepend a prefix. For example, consider the\nfollowing proxy to server mapping:\n\n[subs=\"-attributes\"]\n----\nhttps://example.com/api/app1/{path} -> http://localhost:8080/app1/{path}\n----\n\nIn this case, the proxy has a prefix of `/api/app1` and the server has a prefix of\n`/app1`. The proxy can send `X-Forwarded-Prefix: /api/app1` to have the original prefix\n`/api/app1` override the server prefix `/app1`.\n\n[[x-forwarded-for]]\n==== X-Forwarded-For\n\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-For[`X-Forwarded-For: <address>`]\nis a de-facto standard header that is used to communicate the original `InetSocketAddress` of the client to a\ndownstream server. For example, if a request is sent by a client at `[fd00:fefe:1::4]` to a proxy at\n`192.168.0.1`, the \"remote address\" information contained in the HTTP request will reflect the actual address of the\nclient, not the proxy.\n\n[[webflux-forwarded-headers-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Forwarded Headers", "heading_level": 3, "file_order": 316, "section_index": 6, "content_hash": "c4c56e839696a3b2e3210e7fd6692ff1956c4655e99ceb15330f0a2e14a0632f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:263a80a2a735bc419ce9b420166f2fae2eebc3a9e4b7188be6bc0c96940e8e6b", "content": "`ForwardedHeaderTransformer` is a component that modifies the host, port, and scheme of\nthe request, based on forwarded headers, and then removes those headers. If you declare\nit as a bean with the name `forwardedHeaderTransformer`, it will be\nxref:web/webflux/reactive-spring.adoc#webflux-web-handler-api-special-beans[detected] and used.\n\n[[webflux-forwarded-headers-security]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "ForwardedHeaderTransformer", "heading_level": 3, "file_order": 316, "section_index": 7, "content_hash": "263a80a2a735bc419ce9b420166f2fae2eebc3a9e4b7188be6bc0c96940e8e6b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:d780db895981de6d643b7696e001ed8d46556dd10061f0cbb902a5207ef65f91", "content": "There are security considerations for forwarded headers since an application cannot know\nif the headers were added by a proxy, as intended, or by a malicious client. This is why\na proxy at the boundary of trust should be configured to remove untrusted forwarded traffic coming\nfrom the outside. You can also configure the `ForwardedHeaderTransformer` with\n`removeOnly=true`, in which case it removes but does not use the headers.\n\n[[webflux-filters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Security Considerations", "heading_level": 3, "file_order": 316, "section_index": 8, "content_hash": "d780db895981de6d643b7696e001ed8d46556dd10061f0cbb902a5207ef65f91", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:74ec1ff893fa7ba9b3c3e94e26265f7e4fbf1b6031bb9f8e336fb50be7297159", "content": "[.small]#xref:web/webmvc/filters.adoc[See equivalent in the Servlet stack]#\n\nIn the xref:web/webflux/reactive-spring.adoc#webflux-web-handler-api[`WebHandler` API], you can use a `WebFilter` to apply interception-style\nlogic before and after the rest of the processing chain of filters and the target\n`WebHandler`. When using the xref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[WebFlux Config], registering a `WebFilter` is as simple\nas declaring it as a Spring bean and (optionally) expressing precedence by using `@Order` on\nthe bean declaration or by implementing `Ordered`.\n\n[[webflux-filters-cors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Filters", "heading_level": 2, "file_order": 316, "section_index": 9, "content_hash": "74ec1ff893fa7ba9b3c3e94e26265f7e4fbf1b6031bb9f8e336fb50be7297159", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:bd9a0b68b655264be6595e681df29b0f67d47901b4ac7480e808a33dcf55e10f", "content": "[.small]#xref:web/webmvc/filters.adoc#filters-cors[See equivalent in the Servlet stack]#\n\nSpring WebFlux provides fine-grained support for CORS configuration through annotations on\ncontrollers. However, when you use it with Spring Security, we advise relying on the built-in\n`CorsFilter`, which must be ordered ahead of Spring Security's chain of filters.\n\nSee the section on xref:web/webflux-cors.adoc[CORS] and the xref:web/webflux-cors.adoc#webflux-cors-webfilter[CORS `WebFilter`] for more details.\n\n[[filters.url-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "CORS", "heading_level": 3, "file_order": 316, "section_index": 10, "content_hash": "bd9a0b68b655264be6595e681df29b0f67d47901b4ac7480e808a33dcf55e10f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:6b08cbe3bcd455da0ed20313f9da96544fb84316c20371a43ebb49ac1ad33517", "content": "[.small]#xref:web/webmvc/filters.adoc#filters.url-handler[See equivalent in the Servlet stack]#\n\nYou may want your controller endpoints to match routes with or without a trailing slash in the URL path.\nFor example, both \"GET /home\" and \"GET /home/\" should be handled by a controller method annotated with `@GetMapping(\"/home\")`.\n\nSpring provides `UrlHandlerFilter` that removes the trailing slash from URL paths to ensure a consistent view of paths with or without a trailing slash.\nThis is important to avoid a mismatch between URL-based authorization decisions and web framework request mappings.\nThe filter can remove the trailing slash in one of a couple of ways:\n\n* respond with an HTTP redirect status that sends clients to the same path without a trailing slash.\n* mutate the request to remove the trailing slash.\n\nHere is how you can instantiate and configure a `UrlHandlerFilter` for a blog application:\n\ninclude-code::./UrlHandlerFilterConfiguration[tag=config,indent=0]\n\nKeep in mind the following:\n\n- the root path `\"/\"` is excluded from trailing slash handling.\n- `@RequestMapping(\"/\")` adds a trailing slash to a type-level mapping, and therefore will\nnot map when trailing slash handling applies; use `@RequestMapping` (no path attribute) instead.\n\n[[webflux-exception-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "URL Handler", "heading_level": 3, "file_order": 316, "section_index": 11, "content_hash": "6b08cbe3bcd455da0ed20313f9da96544fb84316c20371a43ebb49ac1ad33517", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:8de7a2778d930c450046a8d33d6958585b6c5d52f77a3046fc5e8fd66b2c6cf7", "content": "[.small]#xref:web/webmvc/mvc-servlet/exceptionhandlers.adoc#mvc-ann-customer-servlet-container-error-page[See equivalent in the Servlet stack]#\n\nIn the xref:web/webflux/reactive-spring.adoc#webflux-web-handler-api[`WebHandler` API], you can use a `WebExceptionHandler` to handle\nexceptions from the chain of `WebFilter` instances and the target `WebHandler`. When using the\nxref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[WebFlux Config], registering a `WebExceptionHandler` is as simple as declaring it as a\nSpring bean and (optionally) expressing precedence by using `@Order` on the bean declaration or\nby implementing `Ordered`.\n\nThe following table describes the available `WebExceptionHandler` implementations:\n\n[cols=\"1,2\", options=\"header\"]\n|===\n| Exception Handler | Description\n\n| `ResponseStatusExceptionHandler`\n| Provides handling for exceptions of type\n {spring-framework-api}/web/server/ResponseStatusException.html[`ResponseStatusException`]\n by setting the response to the HTTP status code of the exception.\n\n| `WebFluxResponseStatusExceptionHandler`\n| Extension of `ResponseStatusExceptionHandler` that can also determine the HTTP status\n code of a `@ResponseStatus` annotation on any exception.\n\n This handler is declared in the xref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[WebFlux Config].\n\n|===\n\n[[webflux-codecs]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Exceptions", "heading_level": 2, "file_order": 316, "section_index": 12, "content_hash": "8de7a2778d930c450046a8d33d6958585b6c5d52f77a3046fc5e8fd66b2c6cf7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:31396de16929f9db2d3ce9e570cb6bf95d20ab40597d7fbdc586fac15c291e65", "content": "[.small]#xref:web/webmvc/message-converters.adoc#message-converters[See equivalent in the Servlet stack]#\n\nThe `spring-web` and `spring-core` modules provide support for serializing and\ndeserializing byte content to and from higher level objects through non-blocking I/O with\nReactive Streams back pressure. The following describes this support:\n\n* {spring-framework-api}/core/codec/Encoder.html[`Encoder`] and\n{spring-framework-api}/core/codec/Decoder.html[`Decoder`] are low level contracts to\nencode and decode content independent of HTTP.\n* {spring-framework-api}/http/codec/HttpMessageReader.html[`HttpMessageReader`] and\n{spring-framework-api}/http/codec/HttpMessageWriter.html[`HttpMessageWriter`] are contracts\nto encode and decode HTTP message content.\n* An `Encoder` can be wrapped with `EncoderHttpMessageWriter` to adapt it for use in a web\napplication, while a `Decoder` can be wrapped with `DecoderHttpMessageReader`.\n* {spring-framework-api}/core/io/buffer/DataBuffer.html[`DataBuffer`] abstracts different\nbyte buffer representations (for example, Netty `ByteBuf`, `java.nio.ByteBuffer`, etc.) and is\nwhat all codecs work on. See xref:core/databuffer-codec.adoc[Data Buffers and Codecs] in the\n\"Spring Core\" section for more on this topic.\n\nThe `spring-core` module provides `byte[]`, `ByteBuffer`, `DataBuffer`, `Resource`, and\n`String` encoder and decoder implementations. The `spring-web` module provides Jackson\nJSON, Jackson Smile, JAXB2, Protocol Buffers and other encoders and decoders along with\nweb-only HTTP message reader and writer implementations for form data, multipart content,\nserver-sent events, and others.\n\n`ClientCodecConfigurer` and `ServerCodecConfigurer` are typically used to configure and\ncustomize the codecs to use in an application. See the section on configuring\nxref:web/webflux/config.adoc#webflux-config-message-codecs[HTTP message codecs].\n\n[[webflux-codecs-jackson]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Codecs", "heading_level": 2, "file_order": 316, "section_index": 13, "content_hash": "31396de16929f9db2d3ce9e570cb6bf95d20ab40597d7fbdc586fac15c291e65", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:c434c64973aae49dfdce2ad7e71debd0f10ff778cbd67550c4cfd9352ddc44fc", "content": "JSON and binary JSON ({jackson-github-org}/smile-format-specification[Smile]) are\nboth supported when the Jackson library is present.\n\nThe `JacksonJsonDecoder` works as follows:\n\n* Jackson's asynchronous, non-blocking parser is used to aggregate a stream of byte chunks\ninto ``TokenBuffer``'s each representing a JSON object.\n* Each `TokenBuffer` is passed to Jackson's `JsonMapper` to create a higher level object.\n* When decoding to a single-value publisher (for example, `Mono`), there is one `TokenBuffer`.\n* When decoding to a multi-value publisher (for example, `Flux`), each `TokenBuffer` is passed to\nthe `JsonMapper` as soon as enough bytes are received for a fully formed object. The\ninput content can be a JSON array, or any\nhttps://en.wikipedia.org/wiki/JSON_streaming[line-delimited JSON] format such as NDJSON,\nJSON Lines, or JSON Text Sequences.\n\nThe `JacksonJsonEncoder` works as follows:\n\n* For a single value publisher (for example, `Mono`), simply serialize it through the\n`JsonMapper`.\n* For a multi-value publisher with `application/json`, by default collect the values with\n`Flux#collectToList()` and then serialize the resulting collection.\n* For a multi-value publisher with a streaming media type such as\n`application/x-ndjson` or `application/stream+x-jackson-smile`, encode, write, and\nflush each value individually using a\nhttps://en.wikipedia.org/wiki/JSON_streaming[line-delimited JSON] format. Other\nstreaming media types may be registered with the encoder.\n* For SSE the `JacksonJsonEncoder` is invoked per event and the output is flushed to ensure\ndelivery without delay.\n\n[NOTE]\n====\nBy default both `JacksonJsonEncoder` and `JacksonJsonDecoder` do not support elements of type\n`String`. Instead the default assumption is that a string or a sequence of strings\nrepresent serialized JSON content, to be rendered by the `CharSequenceEncoder`. If what\nyou need is to render a JSON array from `Flux<String>`, use `Flux#collectToList()` and\nencode a `Mono<List<String>>`.\n====\n\n[[webflux-codecs-forms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Jackson JSON", "heading_level": 3, "file_order": 316, "section_index": 14, "content_hash": "c434c64973aae49dfdce2ad7e71debd0f10ff778cbd67550c4cfd9352ddc44fc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:a81c75a4a7649cd9fe00bba03fd6872a5201060282ad6760976358cb7930634a", "content": "`FormHttpMessageReader` and `FormHttpMessageWriter` support decoding and encoding\n`application/x-www-form-urlencoded` content.\n\nOn the server side where form content often needs to be accessed from multiple places,\n`ServerWebExchange` provides a dedicated `getFormData()` method that parses the content\nthrough `FormHttpMessageReader` and then caches the result for repeated access.\nSee xref:web/webflux/reactive-spring.adoc#webflux-form-data[Form Data] in the\nxref:web/webflux/reactive-spring.adoc#webflux-web-handler-api[`WebHandler` API] section.\n\nOnce `getFormData()` is used, the original raw content can no longer be read from the\nrequest body. For this reason, applications are expected to go through `ServerWebExchange`\nconsistently for access to the cached form data versus reading from the raw request body.\n\n[[webflux-codecs-multipart]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Form Data", "heading_level": 3, "file_order": 316, "section_index": 15, "content_hash": "a81c75a4a7649cd9fe00bba03fd6872a5201060282ad6760976358cb7930634a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:662175fb1560330ef87a6605b88a3df307f8da3bd130088490e7f61d0b610a8f", "content": "`MultipartHttpMessageReader` and `MultipartHttpMessageWriter` support decoding and\nencoding \"multipart/form-data\", \"multipart/mixed\", and \"multipart/related\" content.\nIn turn `MultipartHttpMessageReader` delegates to another `HttpMessageReader`\nfor the actual parsing to a `Flux<Part>` and then simply collects the parts into a `MultiValueMap`.\nBy default, the `DefaultPartHttpMessageReader` is used, but this can be changed through the\n`ServerCodecConfigurer`.\nFor more information about the `DefaultPartHttpMessageReader`, refer to the\n{spring-framework-api}/http/codec/multipart/DefaultPartHttpMessageReader.html[javadoc of `DefaultPartHttpMessageReader`].\n\nOn the server side where multipart form content may need to be accessed from multiple\nplaces, `ServerWebExchange` provides a dedicated `getMultipartData()` method that parses\nthe content through `MultipartHttpMessageReader` and then caches the result for repeated access.\nSee xref:web/webflux/reactive-spring.adoc#webflux-multipart[Multipart Data] in the\nxref:web/webflux/reactive-spring.adoc#webflux-web-handler-api[`WebHandler` API] section.\n\nOnce `getMultipartData()` is used, the original raw content can no longer be read from the\nrequest body. For this reason applications have to consistently use `getMultipartData()`\nfor repeated, map-like access to parts, or otherwise rely on the\n`SynchronossPartHttpMessageReader` for a one-time access to `Flux<Part>`.\n\n[[webflux-codecs-protobuf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Multipart", "heading_level": 3, "file_order": 316, "section_index": 16, "content_hash": "662175fb1560330ef87a6605b88a3df307f8da3bd130088490e7f61d0b610a8f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:324991ac2e0fdbdc967cd79b7f021a92a8ae5c391aceb2793a4cfa8798f08171", "content": "`ProtobufEncoder` and `ProtobufDecoder` supporting decoding and encoding \"application/x-protobuf\", \"application/octet-stream\"\nand \"application/vnd.google.protobuf\" content for `com.google.protobuf.Message` types. They also support stream of values\nif content is received/sent with the \"delimited\" parameter along the content type (like \"application/x-protobuf;delimited=true\").\nThis requires the \"com.google.protobuf:protobuf-java\" library, version 3.29 and higher.\n\nThe `ProtobufJsonDecoder` and `ProtobufJsonEncoder` variants support reading and writing JSON documents to and from Protobuf messages.\nThey require the \"com.google.protobuf:protobuf-java-util\" dependency. Note, the JSON variants do not support reading stream of messages,\nsee the {spring-framework-api}/http/codec/protobuf/ProtobufJsonDecoder.html[javadoc of `ProtobufJsonDecoder`] for more details.\n\n[[webflux-codecs-gson]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Protocol Buffers", "heading_level": 3, "file_order": 316, "section_index": 17, "content_hash": "324991ac2e0fdbdc967cd79b7f021a92a8ae5c391aceb2793a4cfa8798f08171", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:f7ae5234ea2bc2429308bb86768103b07712e0ba294e6e5f799e0b54a31ac449", "content": "Applications can use the `GsonEncoder` and `GsonDecoder` to serialize and deserialize JSON documents thanks to the https://google.github.io/gson/[Google Gson] library .\nThis codec supports both JSON media types and the NDJSON format for streaming.\n\n[NOTE]\n====\n`Gson` does not support non-blocking parsing, so the `GsonDecoder` does not support deserializing\nto `Flux<*>` types. For example, if this decoder is used for deserializing a JSON stream or even a list of elements\nas a `Flux<*>`, an `UnsupportedOperationException` will be thrown at runtime.\nApplications should instead focus on deserializing bounded collections and use `Mono<List<*>>` as target types.\n====\n\n[[webflux-codecs-limits]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Google Gson", "heading_level": 3, "file_order": 316, "section_index": 18, "content_hash": "f7ae5234ea2bc2429308bb86768103b07712e0ba294e6e5f799e0b54a31ac449", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:ef8cc0427dddff76f0009e5bca23d9d5eff1f015ba519c9bc6bf7ecdabca19ca", "content": "`Decoder` and `HttpMessageReader` implementations that buffer some or all of the input\nstream can be configured with a limit on the maximum number of bytes to buffer in memory.\nIn some cases buffering occurs because input is aggregated and represented as a single\nobject â€” for example, a controller method with `@RequestBody byte[]`,\n`x-www-form-urlencoded` data, and so on. Buffering can also occur with streaming, when\nsplitting the input stream â€” for example, delimited text, a stream of JSON objects, and\nso on. For those streaming cases, the limit applies to the number of bytes associated\nwith one object in the stream.\n\nTo configure buffer sizes, you can check if a given `Decoder` or `HttpMessageReader`\nexposes a `maxInMemorySize` property and if so the Javadoc will have details about default\nvalues. On the server side, `ServerCodecConfigurer` provides a single place from where to\nset all codecs, see xref:web/webflux/config.adoc#webflux-config-message-codecs[HTTP message codecs]. On the client side, the limit for\nall codecs can be changed in\nxref:web/webflux-webclient/client-builder.adoc#webflux-client-builder-maxinmemorysize[WebClient.Builder].\n\nFor xref:web/webflux/reactive-spring.adoc#webflux-codecs-multipart[Multipart parsing] the `maxInMemorySize` property limits\nthe size of non-file parts. For file parts, it determines the threshold at which the part\nis written to disk. For file parts written to disk, there is an additional\n`maxDiskUsagePerPart` property to limit the amount of disk space per part. There is also\na `maxParts` property to limit the overall number of parts in a multipart request.\nTo configure all three in WebFlux, you'll need to supply a pre-configured instance of\n`MultipartHttpMessageReader` to `ServerCodecConfigurer`.\n\n[[webflux-codecs-streaming]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Limits", "heading_level": 3, "file_order": 316, "section_index": 19, "content_hash": "ef8cc0427dddff76f0009e5bca23d9d5eff1f015ba519c9bc6bf7ecdabca19ca", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:f5de61e945c8e631e705d04a59c2934cdf21fb2396bc470af1dd9275b6bdc21e", "content": "[.small]#xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-http-streaming[See equivalent in the Servlet stack]#\n\nWhen streaming to the HTTP response (for example, `text/event-stream`,\n`application/x-ndjson`), it is important to send data periodically, in order to\nreliably detect a disconnected client sooner rather than later. Such a send could be a\ncomment-only, empty SSE event or any other \"no-op\" data that would effectively serve as\na heartbeat.\n\n[[webflux-codecs-buffers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Streaming", "heading_level": 3, "file_order": 316, "section_index": 20, "content_hash": "f5de61e945c8e631e705d04a59c2934cdf21fb2396bc470af1dd9275b6bdc21e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:568a3abc4acbecfa8b71d15f0a91d1a189c2feda70872f950ea0ea691b963154", "content": "`DataBuffer` is the representation for a byte buffer in WebFlux. The Spring Core part of\nthis reference has more on that in the section on\nxref:core/databuffer-codec.adoc[Data Buffers and Codecs]. The key point to understand is that on some\nservers like Netty, byte buffers are pooled and reference counted, and must be released\nwhen consumed to avoid memory leaks.\n\nWebFlux applications generally do not need to be concerned with such issues, unless they\nconsume or produce data buffers directly, as opposed to relying on codecs to convert to\nand from higher level objects, or unless they choose to create custom codecs. For such\ncases please review the information in xref:core/databuffer-codec.adoc[Data Buffers and Codecs],\nespecially the section on xref:core/databuffer-codec.adoc#databuffers-using[Using DataBuffer].\n\n[[webflux-logging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "`DataBuffer`", "heading_level": 3, "file_order": 316, "section_index": 21, "content_hash": "568a3abc4acbecfa8b71d15f0a91d1a189c2feda70872f950ea0ea691b963154", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:da1505d272c3c47b8b73461842e2c8f49340c32b3a2d2975962a4101585cf1e3", "content": "[.small]#xref:web/webmvc/mvc-servlet/logging.adoc[See equivalent in the Servlet stack]#\n\n`DEBUG` level logging in Spring WebFlux is designed to be compact, minimal, and\nhuman-friendly. It focuses on high value bits of information that are useful over and\nover again vs others that are useful only when debugging a specific issue.\n\n`TRACE` level logging generally follows the same principles as `DEBUG` (and for example also\nshould not be a firehose) but can be used for debugging any issue. In addition, some log\nmessages may show a different level of detail at `TRACE` vs `DEBUG`.\n\nGood logging comes from the experience of using the logs. If you spot anything that does\nnot meet the stated goals, please let us know.\n\n[[webflux-logging-id]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Logging", "heading_level": 2, "file_order": 316, "section_index": 22, "content_hash": "da1505d272c3c47b8b73461842e2c8f49340c32b3a2d2975962a4101585cf1e3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:8d254d0b46c0e6e956f8dcc9acad474c7eddc79dd5f01ee06f46bfc8aba8ad4e", "content": "In WebFlux, a single request can be run over multiple threads and the thread ID\nis not useful for correlating log messages that belong to a specific request. This is why\nWebFlux log messages are prefixed with a request-specific ID by default.\n\nOn the server side, the log ID is stored in the `ServerWebExchange` attribute\n({spring-framework-api}/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE[`LOG_ID_ATTRIBUTE`]),\nwhile a fully formatted prefix based on that ID is available from\n`ServerWebExchange#getLogPrefix()`. On the `WebClient` side, the log ID is stored in the\n`ClientRequest` attribute\n({spring-framework-api}/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE[`LOG_ID_ATTRIBUTE`])\n,while a fully formatted prefix is available from `ClientRequest#logPrefix()`.\n\n[[webflux-logging-sensitive-data]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Log Id", "heading_level": 3, "file_order": 316, "section_index": 23, "content_hash": "8d254d0b46c0e6e956f8dcc9acad474c7eddc79dd5f01ee06f46bfc8aba8ad4e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:a44e7adc653f67eea68590b13a9eaa53d9e395fa7291792bf7e8a20074b76a8c", "content": "[.small]#xref:web/webmvc/mvc-servlet/logging.adoc#mvc-logging-sensitive-data[See equivalent in the Servlet stack]#\n\n`DEBUG` and `TRACE` logging can log sensitive information. This is why form parameters and\nheaders are masked by default and you must explicitly enable their logging in full.\n\nThe following example shows how to do so for server-side requests:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass MyConfig implements WebFluxConfigurer {\n\n @Override\n public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {\n configurer.defaultCodecs().enableLoggingRequestDetails(true);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass MyConfig : WebFluxConfigurer {\n\n override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) {\n configurer.defaultCodecs().enableLoggingRequestDetails(true)\n }\n\t}\n----\n======\n\nThe following example shows how to do so for client-side requests:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tConsumer<ClientCodecConfigurer> consumer = configurer ->\n configurer.defaultCodecs().enableLoggingRequestDetails(true);\n\n\tWebClient webClient = WebClient.builder()\n .exchangeStrategies(strategies -> strategies.codecs(consumer))\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval consumer: (ClientCodecConfigurer) -> Unit = { configurer -> configurer.defaultCodecs().enableLoggingRequestDetails(true) }\n\n\tval webClient = WebClient.builder()\n .exchangeStrategies({ strategies -> strategies.codecs(consumer) })\n .build()\n----\n======\n\n[[webflux-logging-appenders]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Sensitive Data", "heading_level": 3, "file_order": 316, "section_index": 24, "content_hash": "a44e7adc653f67eea68590b13a9eaa53d9e395fa7291792bf7e8a20074b76a8c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:50ef37b3496f5c4b7959db567887cdcac77a39d31086dc4921b07874f442e879", "content": "Logging libraries such as SLF4J and Log4J 2 provide asynchronous loggers that avoid\nblocking. While those have their own drawbacks such as potentially dropping messages\nthat could not be queued for logging, they are the best available options currently\nfor use in a reactive, non-blocking application.\n\n[[webflux-codecs-custom]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Appenders", "heading_level": 3, "file_order": 316, "section_index": 25, "content_hash": "50ef37b3496f5c4b7959db567887cdcac77a39d31086dc4921b07874f442e879", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:926b80cd5f6f85ffb20e3b2eba3d87ab1f5f2809726b6ead47c9417fa248e92c", "content": "Applications can register custom codecs for supporting additional media types,\nor specific behaviors that are not supported by the default codecs.\n\nSome configuration options expressed by developers are enforced on default codecs.\nCustom codecs might want to get a chance to align with those preferences,\nlike xref:web/webflux/reactive-spring.adoc#webflux-codecs-limits[enforcing buffering limits]\nor xref:web/webflux/reactive-spring.adoc#webflux-logging-sensitive-data[logging sensitive data].\n\nThe following example shows how to do so for client-side requests:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient webClient = WebClient.builder()\n .codecs(configurer -> {\n CustomDecoder decoder = new CustomDecoder();\n configurer.customCodecs().registerWithDefaultConfig(decoder);\n })\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval webClient = WebClient.builder()\n .codecs({ configurer ->\n val decoder = CustomDecoder()\n configurer.customCodecs().registerWithDefaultConfig(decoder)\n })\n .build()\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc", "title": "reactive-spring", "heading": "Custom codecs", "heading_level": 3, "file_order": 316, "section_index": 26, "content_hash": "926b80cd5f6f85ffb20e3b2eba3d87ab1f5f2809726b6ead47c9417fa248e92c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/reactive-spring.adoc"}}
{"id": "sha256:0c98496185d1a13d9228e5b1a1d828f9d0d6b299ef0f15897e78cb38f33d29f5", "content": "[[webflux-web-security]]\n\n[.small]#xref:web/webmvc/mvc-security.adoc[See equivalent in the Servlet stack]#\n\nThe {spring-site-projects}/spring-security[Spring Security] project provides support\nfor protecting web applications from malicious exploits. See the Spring Security\nreference documentation, including:\n\n* {docs-spring-security}/reactive/configuration/webflux.html[WebFlux Security]\n* {docs-spring-security}/reactive/test/index.html[WebFlux Testing Support]\n* {docs-spring-security}/features/exploits/csrf.html#csrf-protection[CSRF protection]\n* {docs-spring-security}/features/exploits/headers.html[Security Response Headers]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/security.adoc", "title": "security", "heading": "security", "heading_level": 1, "file_order": 317, "section_index": 0, "content_hash": "0c98496185d1a13d9228e5b1a1d828f9d0d6b299ef0f15897e78cb38f33d29f5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/security.adoc"}}
{"id": "sha256:3c6062e7b09709766dedc6528b58e57cf9f9b08865ad3358c2b6747285dc13a9", "content": "[[webflux-uri-building]]\n\n[.small]#xref:web/webmvc/mvc-uri-building.adoc[See equivalent in the Servlet stack]#\n\nThis section describes various options available in the Spring Framework to prepare URIs.\n\n[[uricomponents]]\n= UriComponents\n[.small]#Spring MVC and Spring WebFlux#\n\n`UriComponentsBuilder` helps to build URI's from URI templates with variables, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tUriComponents uriComponents = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}\") // <1>\n\t\t\t.queryParam(\"q\", \"{q}\") // <2>\n\t\t\t.encode() // <3>\n\t\t\t.build(); // <4>\n\n\tURI uri = uriComponents.expand(\"Westin\", \"123\").toUri(); // <5>\n----\n<1> Static factory method with a URI template.\n<2> Add or replace URI components.\n<3> Request to have the URI template and URI variables encoded.\n<4> Build a `UriComponents`.\n<5> Expand variables and obtain the `URI`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uriComponents = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}\") // <1>\n\t\t\t.queryParam(\"q\", \"{q}\") // <2>\n\t\t\t.encode() // <3>\n\t\t\t.build() // <4>\n\n\tval uri = uriComponents.expand(\"Westin\", \"123\").toUri() // <5>\n----\n<1> Static factory method with a URI template.\n<2> Add or replace URI components.\n<3> Request to have the URI template and URI variables encoded.\n<4> Build a `UriComponents`.\n<5> Expand variables and obtain the `URI`.\n======\n\nThe preceding example can be consolidated into one chain and shortened with `buildAndExpand`,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tURI uri = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.encode()\n\t\t\t.buildAndExpand(\"Westin\", \"123\")\n\t\t\t.toUri();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uri = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.encode()\n\t\t\t.buildAndExpand(\"Westin\", \"123\")\n\t\t\t.toUri()\n----\n======\n\nYou can shorten it further by going directly to a URI (which implies encoding),\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tURI uri = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.build(\"Westin\", \"123\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uri = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.build(\"Westin\", \"123\")\n----\n======\n\nYou can shorten it further still with a full URI template, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tURI uri = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}?q={q}\")\n\t\t\t.build(\"Westin\", \"123\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uri = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}?q={q}\")\n\t\t\t.build(\"Westin\", \"123\")\n----\n======\n\n\n\n[[uribuilder]]\n= UriBuilder\n[.small]#Spring MVC and Spring WebFlux#\n\n<<web-uricomponents, `UriComponentsBuilder`>> implements `UriBuilder`. You can create a\n`UriBuilder`, in turn, with a `UriBuilderFactory`. Together, `UriBuilderFactory` and\n`UriBuilder` provide a pluggable mechanism to build URIs from URI templates, based on\nshared configuration, such as a base URL, encoding preferences, and other details.\n\nYou can configure `RestTemplate` and `WebClient` with a `UriBuilderFactory`\nto customize the preparation of URIs. `DefaultUriBuilderFactory` is a default\nimplementation of `UriBuilderFactory` that uses `UriComponentsBuilder` internally and\nexposes shared configuration options.\n\nThe following example shows how to configure a `RestTemplate`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;\n\n\tString baseUrl = \"https://example.org\";\n\tDefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);\n\tfactory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);\n\n\tRestTemplate restTemplate = new RestTemplate();\n\trestTemplate.setUriTemplateHandler(factory);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode\n\n\tval baseUrl = \"https://example.org\"\n\tval factory = DefaultUriBuilderFactory(baseUrl)\n\tfactory.encodingMode = EncodingMode.TEMPLATE_AND_VALUES\n\n\tval restTemplate = RestTemplate()\n\trestTemplate.uriTemplateHandler = factory\n----\n======\n\nThe following example configures a `WebClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;\n\n\tString baseUrl = \"https://example.org\";\n\tDefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);\n\tfactory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);\n\n\tWebClient client = WebClient.builder().uriBuilderFactory(factory).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode\n\n\tval baseUrl = \"https://example.org\"\n\tval factory = DefaultUriBuilderFactory(baseUrl)\n\tfactory.encodingMode = EncodingMode.TEMPLATE_AND_VALUES\n\n\tval client = WebClient.builder().uriBuilderFactory(factory).build()\n----\n======\n\nIn addition, you can also use `DefaultUriBuilderFactory` directly. It is similar to using\n`UriComponentsBuilder` but, instead of static factory methods, it is an actual instance\nthat holds configuration and preferences, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString baseUrl = \"https://example.com\";\n\tDefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);\n\n\tURI uri = uriBuilderFactory.uriString(\"/hotels/{hotel}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.build(\"Westin\", \"123\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval baseUrl = \"https://example.com\"\n\tval uriBuilderFactory = DefaultUriBuilderFactory(baseUrl)\n\n\tval uri = uriBuilderFactory.uriString(\"/hotels/{hotel}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.build(\"Westin\", \"123\")\n----\n======\n\n\n[[uri-parsing]]\n= URI Parsing\n[.small]#Spring MVC and Spring WebFlux#\n\n`UriComponentsBuilder` supports two URI parser types:\n\n1. RFC parser -- this parser type expects URI strings to conform to RFC 3986 syntax,\nand treats deviations from the syntax as illegal.\n\n2. WhatWG parser -- this parser is based on the\nhttps://github.com/web-platform-tests/wpt/tree/master/url[URL parsing algorithm] in the\nhttps://url.spec.whatwg.org[WhatWG URL Living standard]. It provides lenient handling of\na wide range of cases of unexpected input. Browsers implement this in order to handle\nleniently user typed URL's. For more details, see the URL Living Standard and URL parsing\nhttps://github.com/web-platform-tests/wpt/tree/master/url[test cases].\n\nBy default, `RestClient`, `WebClient`, and `RestTemplate` use the RFC parser type, and\nexpect applications to provide with URL templates that conform to RFC syntax. To change\nthat you can customize the `UriBuilderFactory` on any of the clients.\n\nApplications and frameworks may further rely on `UriComponentsBuilder` for their own needs\nto parse user provided URL's in order to inspect and possibly validated URI components\nsuch as the scheme, host, port, path, and query. Such components can decide to use the\nWhatWG parser type in order to handle URL's more leniently, and to align with the way\nbrowsers parse URI's, in case of a redirect to the input URL or if it is included in a\nresponse to a browser.\n\n\n[[uri-encoding]]\n= URI Encoding\n[.small]#Spring MVC and Spring WebFlux#\n\n`UriComponentsBuilder` exposes encoding options at two levels:\n\n* {spring-framework-api}/web/util/UriComponentsBuilder.html#encode()[UriComponentsBuilder#encode()]:\nPre-encodes the URI template first and then strictly encodes URI variables when expanded.\n* {spring-framework-api}/web/util/UriComponents.html#encode()[UriComponents#encode()]:\nEncodes URI components _after_ URI variables are expanded.\n\nBoth options replace non-ASCII and illegal characters with escaped octets. However, the first option\nalso replaces characters with reserved meaning that appear in URI variables.\n\nTIP: Consider \";\", which is legal in a path but has reserved meaning. The first option replaces\n\";\" with \"%3B\" in URI variables but not in the URI template. By contrast, the second option never\nreplaces \";\", since it is a legal character in a path.\n\nFor most cases, the first option is likely to give the expected result, because it treats URI\nvariables as opaque data to be fully encoded, while the second option is useful if URI\nvariables do intentionally contain reserved characters. The second option is also useful\nwhen not expanding URI variables at all since that will also encode anything that\nincidentally looks like a URI variable.\n\nThe following example uses the first option:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tURI uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.encode()\n\t\t\t.buildAndExpand(\"New York\", \"foo+bar\")\n\t\t\t.toUri();\n\n\t// Result is \"/hotel%20list/New%20York?q=foo%2Bbar\"\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.encode()\n\t\t\t.buildAndExpand(\"New York\", \"foo+bar\")\n\t\t\t.toUri()\n\n\t// Result is \"/hotel%20list/New%20York?q=foo%2Bbar\"\n----\n======\n\nYou can shorten the preceding example by going directly to the URI (which implies encoding),\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tURI uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.build(\"New York\", \"foo+bar\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.build(\"New York\", \"foo+bar\")\n----\n======\n\nYou can shorten it further still with a full URI template, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tURI uri = UriComponentsBuilder.fromUriString(\"/hotel list/{city}?q={q}\")\n\t\t\t.build(\"New York\", \"foo+bar\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uri = UriComponentsBuilder.fromUriString(\"/hotel list/{city}?q={q}\")\n\t\t\t.build(\"New York\", \"foo+bar\")\n----\n======\n\nThe `WebClient` and the `RestTemplate` expand and encode URI templates internally through\nthe `UriBuilderFactory` strategy. Both can be configured with a custom strategy,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString baseUrl = \"https://example.com\";\n\tDefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl)\n\tfactory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);\n\n\t// Customize the RestTemplate..\n\tRestTemplate restTemplate = new RestTemplate();\n\trestTemplate.setUriTemplateHandler(factory);\n\n\t// Customize the WebClient..\n\tWebClient client = WebClient.builder().uriBuilderFactory(factory).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval baseUrl = \"https://example.com\"\n\tval factory = DefaultUriBuilderFactory(baseUrl).apply {\n\t\tencodingMode = EncodingMode.TEMPLATE_AND_VALUES\n\t}\n\n\t// Customize the RestTemplate..\n\tval restTemplate = RestTemplate().apply {\n\t\turiTemplateHandler = factory\n\t}\n\n\t// Customize the WebClient..\n\tval client = WebClient.builder().uriBuilderFactory(factory).build()\n----\n======\n\nThe `DefaultUriBuilderFactory` implementation uses `UriComponentsBuilder` internally to\nexpand and encode URI templates. As a factory, it provides a single place to configure\nthe approach to encoding, based on one of the below encoding modes:\n\n* `TEMPLATE_AND_VALUES`: Uses `UriComponentsBuilder#encode()`, corresponding to\nthe first option in the earlier list, to pre-encode the URI template and strictly encode URI variables when\nexpanded.\n* `VALUES_ONLY`: Does not encode the URI template and, instead, applies strict encoding\nto URI variables through `UriUtils#encodeUriVariables` prior to expanding them into the\ntemplate.\n* `URI_COMPONENT`: Uses `UriComponents#encode()`, corresponding to the second option in the earlier list, to\nencode URI component value _after_ URI variables are expanded.\n* `NONE`: No encoding is applied.\n\nThe `RestTemplate` is set to `EncodingMode.URI_COMPONENT` for historical\nreasons and for backwards compatibility. The `WebClient` relies on the default value\nin `DefaultUriBuilderFactory`, which was changed from `EncodingMode.URI_COMPONENT` in\n5.0.x to `EncodingMode.TEMPLATE_AND_VALUES` in 5.1.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux/uri-building.adoc", "title": "uri-building", "heading": "uri-building", "heading_level": 1, "file_order": 318, "section_index": 0, "content_hash": "3c6062e7b09709766dedc6528b58e57cf9f9b08865ad3358c2b6747285dc13a9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux/uri-building.adoc"}}
{"id": "sha256:78f5b258a35855b18835798a2a7d7c5ee7e3e655ec31821e7b82d9ce6e6098d8", "content": "[[webflux-client-attributes]]\n\nYou can add attributes to a request. This is convenient if you want to pass information\nthrough the filter chain and influence the behavior of filters for a given request.\nFor example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient client = WebClient.builder()\n .filter((request, next) -> {\n Optional<Object> usr = request.attribute(\"myAttribute\");\n // ...\n })\n .build();\n\n\tclient.get().uri(\"https://example.org/\")\n .attribute(\"myAttribute\", \"...\")\n .retrieve()\n .bodyToMono(Void.class);\n\n }\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval client = WebClient.builder()\n .filter { request, _ ->\n val usr = request.attributes()[\"myAttribute\"];\n // ...\n }\n .build()\n\n client.get().uri(\"https://example.org/\")\n .attribute(\"myAttribute\", \"...\")\n .retrieve()\n .awaitBody<Unit>()\n----\n======\n\nNote that you can configure a `defaultRequest` callback globally at the\n`WebClient.Builder` level which lets you insert attributes into all requests,\nwhich could be used for example in a Spring MVC application to populate\nrequest attributes based on `ThreadLocal` data.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-attributes.adoc", "title": "client-attributes", "heading": "client-attributes", "heading_level": 1, "file_order": 319, "section_index": 0, "content_hash": "78f5b258a35855b18835798a2a7d7c5ee7e3e655ec31821e7b82d9ce6e6098d8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-attributes.adoc"}}
{"id": "sha256:4a5c512c49c77c3dde455f2f774c79cc5bbef68d0257a83c74bf91e89014ad6f", "content": "[[webflux-client-body]]\n\nThe request body can be encoded from any asynchronous type handled by `ReactiveAdapterRegistry`,\nlike `Mono` or Kotlin Coroutines `Deferred` as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMono<Person> personMono = ... ;\n\n\tMono<Void> result = client.post()\n .uri(\"/persons/{id}\", id)\n .contentType(MediaType.APPLICATION_JSON)\n .body(personMono, Person.class)\n .retrieve()\n .bodyToMono(Void.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval personDeferred: Deferred<Person> = ...\n\n\tclient.post()\n .uri(\"/persons/{id}\", id)\n .contentType(MediaType.APPLICATION_JSON)\n .body<Person>(personDeferred)\n .retrieve()\n .awaitBody<Unit>()\n----\n======\n\nYou can also have a stream of objects be encoded, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tFlux<Person> personFlux = ... ;\n\n\tMono<Void> result = client.post()\n .uri(\"/persons/{id}\", id)\n .contentType(MediaType.APPLICATION_STREAM_JSON)\n .body(personFlux, Person.class)\n .retrieve()\n .bodyToMono(Void.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval people: Flow<Person> = ...\n\n\tclient.post()\n .uri(\"/persons/{id}\", id)\n .contentType(MediaType.APPLICATION_JSON)\n .body(people)\n .retrieve()\n .awaitBody<Unit>()\n----\n======\n\nAlternatively, if you have the actual value, you can use the `bodyValue` shortcut method,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tPerson person = ... ;\n\n\tMono<Void> result = client.post()\n .uri(\"/persons/{id}\", id)\n .contentType(MediaType.APPLICATION_JSON)\n .bodyValue(person)\n .retrieve()\n .bodyToMono(Void.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval person: Person = ...\n\n\tclient.post()\n .uri(\"/persons/{id}\", id)\n .contentType(MediaType.APPLICATION_JSON)\n .bodyValue(person)\n .retrieve()\n .awaitBody<Unit>()\n----\n======\n\n[[webflux-client-body-form]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-body.adoc", "title": "client-body", "heading": "client-body", "heading_level": 1, "file_order": 320, "section_index": 0, "content_hash": "4a5c512c49c77c3dde455f2f774c79cc5bbef68d0257a83c74bf91e89014ad6f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-body.adoc"}}
{"id": "sha256:2997d2532523c0518082f29db6abae4f5e33ca645050efd319a43ae3da15295c", "content": "To send form data, you can provide a `MultiValueMap<String, String>` as the body. Note that the\ncontent is automatically set to `application/x-www-form-urlencoded` by the\n`FormHttpMessageWriter`. The following example shows how to use `MultiValueMap<String, String>`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMultiValueMap<String, String> formData = ... ;\n\n\tMono<Void> result = client.post()\n .uri(\"/path\", id)\n .bodyValue(formData)\n .retrieve()\n .bodyToMono(Void.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval formData: MultiValueMap<String, String> = ...\n\n\tclient.post()\n .uri(\"/path\", id)\n .bodyValue(formData)\n .retrieve()\n .awaitBody<Unit>()\n----\n======\n\nYou can also supply form data in-line by using `BodyInserters`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport static org.springframework.web.reactive.function.BodyInserters.*;\n\n\tMono<Void> result = client.post()\n .uri(\"/path\", id)\n .body(fromFormData(\"k1\", \"v1\").with(\"k2\", \"v2\"))\n .retrieve()\n .bodyToMono(Void.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.web.reactive.function.BodyInserters.*\n\n\tclient.post()\n .uri(\"/path\", id)\n .body(fromFormData(\"k1\", \"v1\").with(\"k2\", \"v2\"))\n .retrieve()\n .awaitBody<Unit>()\n----\n======\n\n[[webflux-client-body-multipart]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-body.adoc", "title": "client-body", "heading": "Form Data", "heading_level": 2, "file_order": 320, "section_index": 1, "content_hash": "2997d2532523c0518082f29db6abae4f5e33ca645050efd319a43ae3da15295c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-body.adoc"}}
{"id": "sha256:204db5375821c018a4160330cf8dead24e4331e15ef598c56eabb5168fba59a8", "content": "To send multipart data, you need to provide a `MultiValueMap<String, ?>` whose values are\neither `Object` instances that represent part content or `HttpEntity` instances that represent the content and\nheaders for a part. `MultipartBodyBuilder` provides a convenient API to prepare a\nmultipart request. The following example shows how to create a `MultiValueMap<String, ?>`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMultipartBodyBuilder builder = new MultipartBodyBuilder();\n\tbuilder.part(\"fieldPart\", \"fieldValue\");\n\tbuilder.part(\"filePart1\", new FileSystemResource(\"...logo.png\"));\n\tbuilder.part(\"jsonPart\", new Person(\"Jason\"));\n\tbuilder.part(\"myPart\", part); // Part from a server request\n\n\tMultiValueMap<String, HttpEntity<?>> parts = builder.build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval builder = MultipartBodyBuilder().apply {\n part(\"fieldPart\", \"fieldValue\")\n part(\"filePart1\", FileSystemResource(\"...logo.png\"))\n part(\"jsonPart\", Person(\"Jason\"))\n part(\"myPart\", part) // Part from a server request\n\t}\n\n\tval parts = builder.build()\n----\n======\n\nIn most cases, you do not have to specify the `Content-Type` for each part. The content\ntype is determined automatically based on the `HttpMessageWriter` chosen to serialize it\nor, in the case of a `Resource`, based on the file extension. If necessary, you can\nexplicitly provide the `MediaType` to use for each part through one of the overloaded\nbuilder `part` methods.\n\nOnce a `MultiValueMap` is prepared, the easiest way to pass it to the `WebClient` is\nthrough the `body` method, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMultipartBodyBuilder builder = ...;\n\n\tMono<Void> result = client.post()\n .uri(\"/path\", id)\n .body(builder.build())\n .retrieve()\n .bodyToMono(Void.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval builder: MultipartBodyBuilder = ...\n\n\tclient.post()\n .uri(\"/path\", id)\n .body(builder.build())\n .retrieve()\n .awaitBody<Unit>()\n----\n======\n\nIf the `MultiValueMap` contains at least one non-`String` value, which could also\nrepresent regular form data (that is, `application/x-www-form-urlencoded`), you need not\nset the `Content-Type` to `multipart/form-data`. This is always the case when using\n`MultipartBodyBuilder`, which ensures an `HttpEntity` wrapper.\n\nAs an alternative to `MultipartBodyBuilder`, you can also provide multipart content,\ninline-style, through the built-in `BodyInserters`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport static org.springframework.web.reactive.function.BodyInserters.*;\n\n\tMono<Void> result = client.post()\n .uri(\"/path\", id)\n .body(fromMultipartData(\"fieldPart\", \"value\").with(\"filePart\", resource))\n .retrieve()\n .bodyToMono(Void.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.web.reactive.function.BodyInserters.*\n\n\tclient.post()\n .uri(\"/path\", id)\n .body(fromMultipartData(\"fieldPart\", \"value\").with(\"filePart\", resource))\n .retrieve()\n .awaitBody<Unit>()\n----\n======\n\n[[partevent]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-body.adoc", "title": "client-body", "heading": "Multipart Data", "heading_level": 2, "file_order": 320, "section_index": 2, "content_hash": "204db5375821c018a4160330cf8dead24e4331e15ef598c56eabb5168fba59a8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-body.adoc"}}
{"id": "sha256:376b32f9ab6de804489d829c0bce1fb654c2e051700f50cd8009d39f4b4b0e35", "content": "To stream multipart data sequentially, you can provide multipart content through `PartEvent`\nobjects.\n\n- Form fields can be created via `FormPartEvent::create`.\n- File uploads can be created via `FilePartEvent::create`.\n\nYou can concatenate the streams returned from methods via `Flux::concat`, and create a request for\nthe `WebClient`.\n\nFor instance, this sample will POST a multipart form containing a form field and a file.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tResource resource = ...\n\tMono<String> result = webClient\n .post()\n .uri(\"https://example.com\")\n .body(Flux.concat(\n FormPartEvent.create(\"field\", \"field value\"),\n FilePartEvent.create(\"file\", resource)\n ), PartEvent.class)\n .retrieve()\n .bodyToMono(String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tvar resource: Resource = ...\n\tvar result: Mono<String> = webClient\n .post()\n .uri(\"https://example.com\")\n .body(\n Flux.concat(\n FormPartEvent.create(\"field\", \"field value\"),\n FilePartEvent.create(\"file\", resource)\n )\n )\n .retrieve()\n .bodyToMono()\n----\n======\n\nOn the server side, `PartEvent` objects that are received via `@RequestBody` or\n`ServerRequest::bodyToFlux(PartEvent.class)` can be relayed to another service\nvia the `WebClient`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-body.adoc", "title": "client-body", "heading": "`PartEvent`", "heading_level": 3, "file_order": 320, "section_index": 3, "content_hash": "376b32f9ab6de804489d829c0bce1fb654c2e051700f50cd8009d39f4b4b0e35", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-body.adoc"}}
{"id": "sha256:421e6ba7ac66cd913c91c48b9792f760aada0588719851de11eccfb3f6f7724c", "content": "[[webflux-client-builder]]\n\nThe simplest way to create `WebClient` is through one of the static factory methods:\n\n* `WebClient.create()`\n* `WebClient.create(String baseUrl)`\n\nYou can also use `WebClient.builder()` with further options:\n\n* `uriBuilderFactory`: Customized `UriBuilderFactory` to use as a base URL.\n* `defaultUriVariables`: default values to use when expanding URI templates.\n* `defaultHeader`: Headers for every request.\n* `defaultCookie`: Cookies for every request.\n* `defaultApiVersion`: API version for every request.\n* `defaultRequest`: `Consumer` to customize every request.\n* `filter`: Client filter for every request.\n* `exchangeStrategies`: HTTP message reader/writer customizations.\n* `clientConnector`: HTTP client library settings.\n* `apiVersionInserter`: to insert API version values in the request\n* `observationRegistry`: the registry to use for enabling xref:integration/observability.adoc#observability.http-client.webclient[Observability support].\n* `observationConvention`: xref:integration/observability.adoc#observability.config[an optional, custom convention to extract metadata] for recorded observations.\n\nFor example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient client = WebClient.builder()\n .codecs(configurer -> ... )\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval webClient = WebClient.builder()\n .codecs { configurer -> ... }\n .build()\n----\n======\n\nOnce built, a `WebClient` is immutable. However, you can clone it and build a\nmodified copy as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient client1 = WebClient.builder()\n .filter(filterA).filter(filterB).build();\n\n\tWebClient client2 = client1.mutate()\n .filter(filterC).filter(filterD).build();\n\n\t// client1 has filterA, filterB\n\n\t// client2 has filterA, filterB, filterC, filterD\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval client1 = WebClient.builder()\n .filter(filterA).filter(filterB).build()\n\n\tval client2 = client1.mutate()\n .filter(filterC).filter(filterD).build()\n\n\t// client1 has filterA, filterB\n\n\t// client2 has filterA, filterB, filterC, filterD\n----\n======\n\n[[webflux-client-builder-maxinmemorysize]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc", "title": "client-builder", "heading": "client-builder", "heading_level": 1, "file_order": 321, "section_index": 0, "content_hash": "421e6ba7ac66cd913c91c48b9792f760aada0588719851de11eccfb3f6f7724c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc"}}
{"id": "sha256:6920153effe94d3ccf6ce26fad689bee84afc208af4cc56071d4e775bbc888a9", "content": "Codecs have xref:web/webflux/reactive-spring.adoc#webflux-codecs-limits[limits] for buffering data in\nmemory to avoid application memory issues. By default those are set to 256KB.\nIf that's not enough you'll get the following error:\n\n----\norg.springframework.core.io.buffer.DataBufferLimitException: Exceeded limit on max bytes to buffer\n----\n\nTo change the limit for default codecs, use the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient webClient = WebClient.builder()\n .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(2 * 1024 * 1024))\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval webClient = WebClient.builder()\n .codecs { configurer -> configurer.defaultCodecs().maxInMemorySize(2 * 1024 * 1024) }\n .build()\n----\n======\n\n[[webflux-client-builder-reactor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc", "title": "client-builder", "heading": "MaxInMemorySize", "heading_level": 2, "file_order": 321, "section_index": 1, "content_hash": "6920153effe94d3ccf6ce26fad689bee84afc208af4cc56071d4e775bbc888a9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc"}}
{"id": "sha256:87801444cca05b52a15232e4a69c83f7c532c07c16890f5dd2df83675d23ab52", "content": "To customize Reactor Netty settings, provide a pre-configured `HttpClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHttpClient httpClient = HttpClient.create().secure(sslSpec -> ...);\n\n\tWebClient webClient = WebClient.builder()\n .clientConnector(new ReactorClientHttpConnector(httpClient))\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval httpClient = HttpClient.create().secure { ... }\n\n\tval webClient = WebClient.builder()\n .clientConnector(ReactorClientHttpConnector(httpClient))\n .build()\n----\n======\n\n[[webflux-client-builder-reactor-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc", "title": "client-builder", "heading": "Reactor Netty", "heading_level": 2, "file_order": 321, "section_index": 2, "content_hash": "87801444cca05b52a15232e4a69c83f7c532c07c16890f5dd2df83675d23ab52", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc"}}
{"id": "sha256:ec38824b2a85a5521f58a573ff7df80a0be9c2393f5ddfa72345a1ee918b5dfb", "content": "By default, `HttpClient` participates in the global Reactor Netty resources held in\n`reactor.netty.http.HttpResources`, including event loop threads and a connection pool.\nThis is the recommended mode, since fixed, shared resources are preferred for event loop\nconcurrency. In this mode global resources remain active until the process exits.\n\nIf the server is timed with the process, there is typically no need for an explicit\nshutdown. However, if the server can start or stop in-process (for example, a Spring MVC\napplication deployed as a WAR), you can declare a Spring-managed bean of type\n`ReactorResourceFactory` with `globalResources=true` (the default) to ensure that the Reactor\nNetty global resources are shut down when the Spring `ApplicationContext` is closed,\nas the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tpublic ReactorResourceFactory reactorResourceFactory() {\n return new ReactorResourceFactory();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tfun reactorResourceFactory() = ReactorResourceFactory()\n----\n======\n--\n\nYou can also choose not to participate in the global Reactor Netty resources. However,\nin this mode, the burden is on you to ensure that all Reactor Netty client and server\ninstances use shared resources, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tpublic ReactorResourceFactory resourceFactory() {\n ReactorResourceFactory factory = new ReactorResourceFactory();\n factory.setUseGlobalResources(false); // <1>\n return factory;\n\t}\n\n\t@Bean\n\tpublic WebClient webClient() {\n\n Function<HttpClient, HttpClient> mapper = client -> {\n // Further customizations...\n };\n\n ClientHttpConnector connector =\n new ReactorClientHttpConnector(resourceFactory(), mapper); // <2>\n\n return WebClient.builder().clientConnector(connector).build(); // <3>\n\t}\n----\n<1> Create resources independent of global ones.\n<2> Use the `ReactorClientHttpConnector` constructor with resource factory.\n<3> Plug the connector into the `WebClient.Builder`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tfun resourceFactory() = ReactorResourceFactory().apply {\n isUseGlobalResources = false // <1>\n\t}\n\n\t@Bean\n\tfun webClient(): WebClient {\n\n val mapper: (HttpClient) -> HttpClient = {\n // Further customizations...\n }\n\n val connector = ReactorClientHttpConnector(resourceFactory(), mapper) // <2>\n\n return WebClient.builder().clientConnector(connector).build() // <3>\n\t}\n----\n<1> Create resources independent of global ones.\n<2> Use the `ReactorClientHttpConnector` constructor with resource factory.\n<3> Plug the connector into the `WebClient.Builder`.\n======\n--\n\n[[webflux-client-builder-reactor-timeout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc", "title": "client-builder", "heading": "Resources", "heading_level": 3, "file_order": 321, "section_index": 3, "content_hash": "ec38824b2a85a5521f58a573ff7df80a0be9c2393f5ddfa72345a1ee918b5dfb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc"}}
{"id": "sha256:be50bb718c7a964c15920d37037c265b6e6b285f72c229bab81227f89ad8a08a", "content": "To configure a connection timeout:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport io.netty.channel.ChannelOption;\n\n\tHttpClient httpClient = HttpClient.create()\n .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000);\n\n\tWebClient webClient = WebClient.builder()\n .clientConnector(new ReactorClientHttpConnector(httpClient))\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport io.netty.channel.ChannelOption\n\n\tval httpClient = HttpClient.create()\n .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000);\n\n\tval webClient = WebClient.builder()\n .clientConnector(ReactorClientHttpConnector(httpClient))\n .build();\n----\n======\n\nTo configure a read or write timeout:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport io.netty.handler.timeout.ReadTimeoutHandler;\n\timport io.netty.handler.timeout.WriteTimeoutHandler;\n\n\tHttpClient httpClient = HttpClient.create()\n .doOnConnected(conn -> conn\n .addHandlerLast(new ReadTimeoutHandler(10))\n .addHandlerLast(new WriteTimeoutHandler(10)));\n\n\t// Create WebClient...\n\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport io.netty.handler.timeout.ReadTimeoutHandler\n\timport io.netty.handler.timeout.WriteTimeoutHandler\n\n\tval httpClient = HttpClient.create()\n .doOnConnected { conn -> conn\n .addHandlerLast(ReadTimeoutHandler(10))\n .addHandlerLast(WriteTimeoutHandler(10))\n }\n\n\t// Create WebClient...\n----\n======\n\nTo configure a response timeout for all requests:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHttpClient httpClient = HttpClient.create()\n .responseTimeout(Duration.ofSeconds(2));\n\n\t// Create WebClient...\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval httpClient = HttpClient.create()\n .responseTimeout(Duration.ofSeconds(2));\n\n\t// Create WebClient...\n----\n======\n\nTo configure a response timeout for a specific request:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient.create().get()\n .uri(\"https://example.org/path\")\n .httpRequest(httpRequest -> {\n HttpClientRequest reactorRequest = httpRequest.getNativeRequest();\n reactorRequest.responseTimeout(Duration.ofSeconds(2));\n })\n .retrieve()\n .bodyToMono(String.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient.create().get()\n .uri(\"https://example.org/path\")\n .httpRequest { httpRequest: ClientHttpRequest ->\n val reactorRequest = httpRequest.getNativeRequest<HttpClientRequest>()\n reactorRequest.responseTimeout(Duration.ofSeconds(2))\n }\n .retrieve()\n .bodyToMono(String::class.java)\n----\n======\n\n[[webflux-client-builder-jdk-httpclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc", "title": "client-builder", "heading": "Timeouts", "heading_level": 3, "file_order": 321, "section_index": 4, "content_hash": "be50bb718c7a964c15920d37037c265b6e6b285f72c229bab81227f89ad8a08a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc"}}
{"id": "sha256:e0d28f19048d8be059f4bd6e1ae92dbea9115e99f8dd49fce0316384d12e72cb", "content": "The following example shows how to customize the JDK `HttpClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHttpClient httpClient = HttpClient.newBuilder()\n .followRedirects(Redirect.NORMAL)\n .connectTimeout(Duration.ofSeconds(20))\n .build();\n\n\tClientHttpConnector connector =\n new JdkClientHttpConnector(httpClient, new DefaultDataBufferFactory());\n\n\tWebClient webClient = WebClient.builder().clientConnector(connector).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval httpClient = HttpClient.newBuilder()\n .followRedirects(Redirect.NORMAL)\n .connectTimeout(Duration.ofSeconds(20))\n .build()\n\n\tval connector = JdkClientHttpConnector(httpClient, DefaultDataBufferFactory())\n\n\tval webClient = WebClient.builder().clientConnector(connector).build()\n----\n======\n\n[[webflux-client-builder-jetty]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc", "title": "client-builder", "heading": "JDK HttpClient", "heading_level": 2, "file_order": 321, "section_index": 5, "content_hash": "e0d28f19048d8be059f4bd6e1ae92dbea9115e99f8dd49fce0316384d12e72cb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc"}}
{"id": "sha256:c98d69f3a4d6dee8491ad24ad0ef74581d5385e1bc176f415e7e34d319b9d2bc", "content": "The following example shows how to customize Jetty `HttpClient` settings:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHttpClient httpClient = new HttpClient();\n\thttpClient.setCookieStore(...);\n\n\tWebClient webClient = WebClient.builder()\n .clientConnector(new JettyClientHttpConnector(httpClient))\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval httpClient = HttpClient()\n\thttpClient.cookieStore = ...\n\n\tval webClient = WebClient.builder()\n .clientConnector(JettyClientHttpConnector(httpClient))\n .build();\n----\n======\n--\n\nBy default, `HttpClient` creates its own resources (`Executor`, `ByteBufferPool`, `Scheduler`),\nwhich remain active until the process exits or `stop()` is called.\n\nYou can share resources between multiple instances of the Jetty client (and server) and\nensure that the resources are shut down when the Spring `ApplicationContext` is closed by\ndeclaring a Spring-managed bean of type `JettyResourceFactory`, as the following example\nshows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tpublic JettyResourceFactory resourceFactory() {\n return new JettyResourceFactory();\n\t}\n\n\t@Bean\n\tpublic WebClient webClient() {\n\n HttpClient httpClient = new HttpClient();\n // Further customizations...\n\n ClientHttpConnector connector =\n new JettyClientHttpConnector(httpClient, resourceFactory()); <1>\n\n return WebClient.builder().clientConnector(connector).build(); <2>\n\t}\n----\n<1> Use the `JettyClientHttpConnector` constructor with resource factory.\n<2> Plug the connector into the `WebClient.Builder`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Bean\n\tfun resourceFactory() = JettyResourceFactory()\n\n\t@Bean\n\tfun webClient(): WebClient {\n\n val httpClient = HttpClient()\n // Further customizations...\n\n val connector = JettyClientHttpConnector(httpClient, resourceFactory()) // <1>\n\n return WebClient.builder().clientConnector(connector).build() // <2>\n\t}\n----\n<1> Use the `JettyClientHttpConnector` constructor with resource factory.\n<2> Plug the connector into the `WebClient.Builder`.\n======\n--\n\n[[webflux-client-builder-http-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc", "title": "client-builder", "heading": "Jetty", "heading_level": 2, "file_order": 321, "section_index": 6, "content_hash": "c98d69f3a4d6dee8491ad24ad0ef74581d5385e1bc176f415e7e34d319b9d2bc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc"}}
{"id": "sha256:bafece0f99c959de62e69833f7c57364244ed117aa8afdbbc5053350f82fd0ab", "content": "The following example shows how to customize Apache HttpComponents `HttpClient` settings:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHttpAsyncClientBuilder clientBuilder = HttpAsyncClients.custom();\n\tclientBuilder.setDefaultRequestConfig(...);\n\tCloseableHttpAsyncClient client = clientBuilder.build();\n\n\tClientHttpConnector connector = new HttpComponentsClientHttpConnector(client);\n\n\tWebClient webClient = WebClient.builder().clientConnector(connector).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval client = HttpAsyncClients.custom().apply {\n setDefaultRequestConfig(...)\n\t}.build()\n\tval connector = HttpComponentsClientHttpConnector(client)\n\tval webClient = WebClient.builder().clientConnector(connector).build()\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc", "title": "client-builder", "heading": "HttpComponents", "heading_level": 2, "file_order": 321, "section_index": 7, "content_hash": "bafece0f99c959de62e69833f7c57364244ed117aa8afdbbc5053350f82fd0ab", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-builder.adoc"}}
{"id": "sha256:dd80734aafe822ec6032ca4185f5f407248dc0ccb13b9d1346f26ed1c3662f60", "content": "[[webflux-client-context]]\n\nxref:web/webflux-webclient/client-attributes.adoc[Attributes] provide a convenient way to pass information to the filter\nchain but they only influence the current request. If you want to pass information that\npropagates to additional requests that are nested, for example, via `flatMap`, or executed after,\nfor example, via `concatMap`, then you'll need to use the Reactor `Context`.\n\nThe Reactor `Context` needs to be populated at the end of a reactive chain in order to\napply to all operations. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient client = WebClient.builder()\n .filter((request, next) ->\n Mono.deferContextual(contextView -> {\n String value = contextView.get(\"foo\");\n // ...\n }))\n .build();\n\n\tclient.get().uri(\"https://example.org/\")\n .retrieve()\n .bodyToMono(String.class)\n .flatMap(body -> {\n // perform nested request (context propagates automatically)...\n })\n .contextWrite(context -> context.put(\"foo\", ...));\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-context.adoc", "title": "client-context", "heading": "client-context", "heading_level": 1, "file_order": 322, "section_index": 0, "content_hash": "dd80734aafe822ec6032ca4185f5f407248dc0ccb13b9d1346f26ed1c3662f60", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-context.adoc"}}
{"id": "sha256:a702039a989211170c15a5c136e05dd790b303809cc3f8733a360bcc61b33e0f", "content": "[[webflux-client-exchange]]\n\nThe `exchangeToMono()` and `exchangeToFlux()` methods (or `awaitExchange { }` and `exchangeToFlow { }` in Kotlin)\nare useful for more advanced cases that require more control, such as to decode the response differently\ndepending on the response status:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMono<Person> entityMono = client.get()\n .uri(\"/persons/1\")\n .accept(MediaType.APPLICATION_JSON)\n .exchangeToMono(response -> {\n if (response.statusCode().equals(HttpStatus.OK)) {\n return response.bodyToMono(Person.class);\n }\n else {\n // Turn to error\n return response.createError();\n }\n });\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nval entity = client.get()\n .uri(\"/persons/1\")\n .accept(MediaType.APPLICATION_JSON)\n .awaitExchange {\n if (response.statusCode() == HttpStatus.OK) {\n return response.awaitBody<Person>()\n }\n else {\n throw response.createExceptionAndAwait()\n }\n }\n----\n======\n\nWhen using the above, after the returned `Mono` or `Flux` completes, the response body\nis checked and if not consumed it is released to prevent memory and connection leaks.\nTherefore the response cannot be decoded further downstream. It is up to the provided\nfunction to declare how to decode the response if needed.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-exchange.adoc", "title": "client-exchange", "heading": "client-exchange", "heading_level": 1, "file_order": 323, "section_index": 0, "content_hash": "a702039a989211170c15a5c136e05dd790b303809cc3f8733a360bcc61b33e0f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-exchange.adoc"}}
{"id": "sha256:3e5d9434e76c5a13034591e25f08edc4ad6d47f4c9ad77f97c54a099377f032c", "content": "[[webflux-client-filter]]\n\nYou can register a client filter (`ExchangeFilterFunction`) through the `WebClient.Builder`\nin order to intercept and modify requests, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient client = WebClient.builder()\n .filter((request, next) -> {\n\n ClientRequest filtered = ClientRequest.from(request)\n .header(\"foo\", \"bar\")\n .build();\n\n return next.exchange(filtered);\n })\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval client = WebClient.builder()\n .filter { request, next ->\n\n val filtered = ClientRequest.from(request)\n .header(\"foo\", \"bar\")\n .build()\n\n next.exchange(filtered)\n }\n .build()\n----\n======\n\nThis can be used for cross-cutting concerns, such as authentication. The following example uses\na filter for basic authentication through a static factory method:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport static org.springframework.web.reactive.function.client.ExchangeFilterFunctions.basicAuthentication;\n\n\tWebClient client = WebClient.builder()\n .filter(basicAuthentication(\"user\", \"password\"))\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.web.reactive.function.client.ExchangeFilterFunctions.basicAuthentication\n\n\tval client = WebClient.builder()\n .filter(basicAuthentication(\"user\", \"password\"))\n .build()\n----\n======\n\nFilters can be added or removed by mutating an existing `WebClient` instance, resulting\nin a new `WebClient` instance that does not affect the original one. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport static org.springframework.web.reactive.function.client.ExchangeFilterFunctions.basicAuthentication;\n\n\tWebClient client = webClient.mutate()\n .filters(filterList -> {\n filterList.add(0, basicAuthentication(\"user\", \"password\"));\n })\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval client = webClient.mutate()\n .filters { it.add(0, basicAuthentication(\"user\", \"password\")) }\n .build()\n----\n======\n\n`WebClient` is a thin facade around the chain of filters followed by an\n`ExchangeFunction`. It provides a workflow to make requests, to encode to and from higher\nlevel objects, and it helps to ensure that response content is always consumed.\nWhen filters handle the response in some way, extra care must be taken to always consume\nits content or to otherwise propagate it downstream to the `WebClient` which will ensure\nthe same. Below is a filter that handles the `UNAUTHORIZED` status code but ensures that\nany response content, whether expected or not, is released:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic ExchangeFilterFunction renewTokenFilter() {\n return (request, next) -> next.exchange(request).flatMap(response -> {\n if (response.statusCode().value() == HttpStatus.UNAUTHORIZED.value()) {\n return response.releaseBody()\n .then(renewToken())\n .flatMap(token -> {\n ClientRequest newRequest = ClientRequest.from(request).build();\n return next.exchange(newRequest);\n });\n } else {\n return Mono.just(response);\n }\n });\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun renewTokenFilter(): ExchangeFilterFunction? {\n return ExchangeFilterFunction { request: ClientRequest?, next: ExchangeFunction ->\n next.exchange(request!!).flatMap { response: ClientResponse ->\n if (response.statusCode().value() == HttpStatus.UNAUTHORIZED.value()) {\n return@flatMap response.releaseBody()\n .then(renewToken())\n .flatMap { token: String? ->\n val newRequest = ClientRequest.from(request).build()\n next.exchange(newRequest)\n }\n } else {\n return@flatMap Mono.just(response)\n }\n }\n }\n\t}\n----\n======\n\nThe example below demonstrates how to use the `ExchangeFilterFunction` interface to create\na custom filter class that helps with computing a `Content-Length` header for `PUT` and `POST`\n`multipart/form-data` requests using buffering.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class MultipartExchangeFilterFunction implements ExchangeFilterFunction {\n\n @Override\n public Mono<ClientResponse> filter(ClientRequest request, ExchangeFunction next) {\n if (MediaType.MULTIPART_FORM_DATA.includes(request.headers().getContentType())\n && (request.method() == HttpMethod.PUT || request.method() == HttpMethod.POST)) {\n return next.exchange(ClientRequest.from(request).body((outputMessage, context) ->\n request.body().insert(new BufferingDecorator(outputMessage), context)).build()\n );\n } else {\n return next.exchange(request);\n }\n }\n\n private static final class BufferingDecorator extends ClientHttpRequestDecorator {\n\n private BufferingDecorator(ClientHttpRequest delegate) {\n super(delegate);\n }\n\n @Override\n public Mono<Void> writeWith(Publisher<? extends DataBuffer> body) {\n return DataBufferUtils.join(body).flatMap(buffer -> {\n getHeaders().setContentLength(buffer.readableByteCount());\n return super.writeWith(Mono.just(buffer));\n });\n }\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MultipartExchangeFilterFunction : ExchangeFilterFunction {\n\n override fun filter(request: ClientRequest, next: ExchangeFunction): Mono<ClientResponse> {\n return if (MediaType.MULTIPART_FORM_DATA.includes(request.headers().getContentType())\n && (request.method() == HttpMethod.PUT || request.method() == HttpMethod.POST)) {\n next.exchange(ClientRequest.from(request)\n .body { message, context -> request.body().insert(BufferingDecorator(message), context) }\n .build())\n }\n else {\n next.exchange(request)\n }\n\n }\n\n private class BufferingDecorator(delegate: ClientHttpRequest) : ClientHttpRequestDecorator(delegate) {\n override fun writeWith(body: Publisher<out DataBuffer>): Mono<Void> {\n return DataBufferUtils.join(body)\n .flatMap {\n headers.contentLength = it.readableByteCount().toLong()\n super.writeWith(Mono.just(it))\n }\n }\n }\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-filter.adoc", "title": "client-filter", "heading": "client-filter", "heading_level": 1, "file_order": 324, "section_index": 0, "content_hash": "3e5d9434e76c5a13034591e25f08edc4ad6d47f4c9ad77f97c54a099377f032c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-filter.adoc"}}
{"id": "sha256:fea077a46f6c2bcc7cc0b0da795e37f90e7c561f2e31e55e755782ed53e27e3e", "content": "[[webflux-client-retrieve]]\n\nThe `retrieve()` method can be used to declare how to extract the response. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient client = WebClient.create(\"https://example.org\");\n\n\tMono<ResponseEntity<Person>> result = client.get()\n .uri(\"/persons/{id}\", id).accept(MediaType.APPLICATION_JSON)\n .retrieve()\n .toEntity(Person.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval client = WebClient.create(\"https://example.org\")\n\n\tval result = client.get()\n .uri(\"/persons/{id}\", id).accept(MediaType.APPLICATION_JSON)\n .retrieve()\n .toEntity<Person>().awaitSingle()\n----\n======\n\nOr to get only the body:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebClient client = WebClient.create(\"https://example.org\");\n\n\tMono<Person> result = client.get()\n .uri(\"/persons/{id}\", id).accept(MediaType.APPLICATION_JSON)\n .retrieve()\n .bodyToMono(Person.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval client = WebClient.create(\"https://example.org\")\n\n\tval result = client.get()\n .uri(\"/persons/{id}\", id).accept(MediaType.APPLICATION_JSON)\n .retrieve()\n .awaitBody<Person>()\n----\n======\n\nTo get a stream of decoded objects:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tFlux<Quote> result = client.get()\n .uri(\"/quotes\").accept(MediaType.TEXT_EVENT_STREAM)\n .retrieve()\n .bodyToFlux(Quote.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval result = client.get()\n .uri(\"/quotes\").accept(MediaType.TEXT_EVENT_STREAM)\n .retrieve()\n .bodyToFlow<Quote>()\n----\n======\n\nBy default, 4xx or 5xx responses result in an `WebClientResponseException`, including\nsub-classes for specific HTTP status codes. To customize the handling of error\nresponses, use `onStatus` handlers as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMono<Person> result = client.get()\n .uri(\"/persons/{id}\", id).accept(MediaType.APPLICATION_JSON)\n .retrieve()\n .onStatus(HttpStatusCode::is4xxClientError, response -> ...)\n .onStatus(HttpStatusCode::is5xxServerError, response -> ...)\n .bodyToMono(Person.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval result = client.get()\n .uri(\"/persons/{id}\", id).accept(MediaType.APPLICATION_JSON)\n .retrieve()\n .onStatus(HttpStatusCode::is4xxClientError) { ... }\n .onStatus(HttpStatusCode::is5xxServerError) { ... }\n .awaitBody<Person>()\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-retrieve.adoc", "title": "client-retrieve", "heading": "client-retrieve", "heading_level": 1, "file_order": 325, "section_index": 0, "content_hash": "fea077a46f6c2bcc7cc0b0da795e37f90e7c561f2e31e55e755782ed53e27e3e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-retrieve.adoc"}}
{"id": "sha256:da3bb2b0d58e0a9582c78be1ad6459c2783a3b2e8a17f4f6f8a578173f92cd15", "content": "[[webflux-client-synchronous]]\n\n`WebClient` can be used in synchronous style by blocking at the end for the result:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tPerson person = client.get().uri(\"/person/{id}\", i).retrieve()\n .bodyToMono(Person.class)\n .block();\n\n\tList<Person> persons = client.get().uri(\"/persons\").retrieve()\n .bodyToFlux(Person.class)\n .collectList()\n .block();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval person = runBlocking {\n client.get().uri(\"/person/{id}\", i).retrieve()\n .awaitBody<Person>()\n\t}\n\n\tval persons = runBlocking {\n client.get().uri(\"/persons\").retrieve()\n .bodyToFlow<Person>()\n .toList()\n\t}\n----\n======\n\nHowever if multiple calls need to be made, it's more efficient to avoid blocking on each\nresponse individually, and instead wait for the combined result:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMono<Person> personMono = client.get().uri(\"/person/{id}\", personId)\n .retrieve().bodyToMono(Person.class);\n\n\tMono<List<Hobby>> hobbiesMono = client.get().uri(\"/person/{id}/hobbies\", personId)\n .retrieve().bodyToFlux(Hobby.class).collectList();\n\n\tMap<String, Object> data = Mono.zip(personMono, hobbiesMono, (person, hobbies) -> {\n Map<String, String> map = new LinkedHashMap<>();\n map.put(\"person\", person);\n map.put(\"hobbies\", hobbies);\n return map;\n })\n .block();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval data = runBlocking {\n val personDeferred = async {\n client.get().uri(\"/person/{id}\", personId)\n .retrieve().awaitBody<Person>()\n }\n\n val hobbiesDeferred = async {\n client.get().uri(\"/person/{id}/hobbies\", personId)\n .retrieve().bodyToFlow<Hobby>().toList()\n }\n\n mapOf(\"person\" to personDeferred.await(), \"hobbies\" to hobbiesDeferred.await())\n }\n----\n======\n\nThe above is merely one example. There are lots of other patterns and operators for putting\ntogether a reactive pipeline that makes many remote calls, potentially some nested,\ninterdependent, without ever blocking until the end.\n\n[NOTE]\n====\nWith `Flux` or `Mono`, you should never have to block in a Spring MVC or Spring WebFlux controller.\nSimply return the resulting reactive type from the controller method. The same principle apply to\nKotlin Coroutines and Spring WebFlux, just use suspending function or return `Flow` in your\ncontroller method .\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-synchronous.adoc", "title": "client-synchronous", "heading": "client-synchronous", "heading_level": 1, "file_order": 326, "section_index": 0, "content_hash": "da3bb2b0d58e0a9582c78be1ad6459c2783a3b2e8a17f4f6f8a578173f92cd15", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-synchronous.adoc"}}
{"id": "sha256:010d03c02bfc3c3fc1802383c19962aac6672f2bdbcb8e81c19ca76e5e468a85", "content": "[[webflux-client-testing]]\n\nTo test code that uses the `WebClient`, you can use a mock web server, such as\nhttps://github.com/square/okhttp#mockwebserver[OkHttp MockWebServer] or\nhttps://wiremock.org/[WireMock]. Mock web servers accept requests over HTTP like a regular\nserver, and that means you can test with the same HTTP client that is also configured in\nthe same way as in production, which is important because there are often subtle\ndifferences in the way different clients handle network I/O. Another advantage of mock\nweb servers is the ability to simulate specific network issues and conditions at the\ntransport level, in combination with the client used in production.\n\nFor example use of MockWebServer, see\n{spring-framework-code}/spring-webflux/src/test/java/org/springframework/web/reactive/function/client/WebClientIntegrationTests.java[`WebClientIntegrationTests`]\nin the Spring Framework test suite or the\nhttps://github.com/square/okhttp/tree/master/samples/static-server[`static-server`]\nsample in the OkHttp repository.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient/client-testing.adoc", "title": "client-testing", "heading": "client-testing", "heading_level": 1, "file_order": 327, "section_index": 0, "content_hash": "010d03c02bfc3c3fc1802383c19962aac6672f2bdbcb8e81c19ca76e5e468a85", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient/client-testing.adoc"}}
{"id": "sha256:18605b81c7a427ebaff52c020eb5daf8a04c60dcb42ba7c9f86df3d623aa64ed", "content": "[[mvc-config-advanced-java]]\n\n[.small]#xref:web/webflux/config.adoc#webflux-config-advanced-java[See equivalent in the Reactive stack]#\n\n`@EnableWebMvc` imports `DelegatingWebMvcConfiguration`, which:\n\n* Provides default Spring configuration for Spring MVC applications\n* Detects and delegates to `WebMvcConfigurer` implementations to customize that configuration.\n\nFor advanced mode, you can remove `@EnableWebMvc` and extend directly from\n`DelegatingWebMvcConfiguration` instead of implementing `WebMvcConfigurer`,\nas the following example shows:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nYou can keep existing methods in `WebConfig`, but you can now also override bean declarations\nfrom the base class, and you can still have any number of other `WebMvcConfigurer` implementations on\nthe classpath.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/advanced-java.adoc", "title": "advanced-java", "heading": "advanced-java", "heading_level": 1, "file_order": 328, "section_index": 0, "content_hash": "18605b81c7a427ebaff52c020eb5daf8a04c60dcb42ba7c9f86df3d623aa64ed", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/advanced-java.adoc"}}
{"id": "sha256:73a86145035733fd63fd53d5889d9703aeb20921ddde9aa944104eab0cb9b26d", "content": "[[mvc-config-advanced-xml]]\n\nThe MVC namespace does not have an advanced mode. If you need to customize a property on\na bean that you cannot change otherwise, you can use the `BeanPostProcessor` lifecycle\nhook of the Spring `ApplicationContext`, as the following example shows:\n\ninclude-code::./MyPostProcessor[tag=snippet,indent=0]\n\nNote that you need to declare `MyPostProcessor` as a bean, either explicitly in XML or\nby letting it be detected through a `<component-scan/>` declaration.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/advanced-xml.adoc", "title": "advanced-xml", "heading": "advanced-xml", "heading_level": 1, "file_order": 329, "section_index": 0, "content_hash": "73a86145035733fd63fd53d5889d9703aeb20921ddde9aa944104eab0cb9b26d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/advanced-xml.adoc"}}
{"id": "sha256:5a5b06a42b4193c2352a22c6a5039c1ee0ce1fdc7c80d57baceb62e75b00a5e2", "content": "[[mvc-config-api-version]]\n\n[.small]#xref:web/webflux/config.adoc#webflux-config-api-version[See equivalent in the Reactive stack]#\n\nTo enable API versioning, use the `ApiVersionConfigurer` callback of `WebMvcConfigurer`:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nYou can resolve the version through one of the built-in options listed below, or\nalternatively use a custom `ApiVersionResolver`:\n\n- Request header\n- Request parameter\n- Path segment\n- Media type parameter\n\nTo resolve from a path segment, you need to specify the index of the path segment expected\nto contain the version. The path segment must be declared as a URI variable, e.g.\n\"/\\{version}\", \"/api/\\{version}\", etc. where the actual name is not important.\nAs the version is typically at the start of the path, consider configuring it externally\nas a common path prefix for all handlers through the\nxref:web/webmvc/mvc-config/path-matching.adoc[Path Matching] options.\n\nBy default, the version is parsed with `SemanticVersionParser`, but you can also configure\na custom xref:web/webmvc-versioning.adoc#mvc-versioning-parser[ApiVersionParser].\n\nSupported versions are transparently detected from versions declared in request mappings\nfor convenience, but you can turn that off through a flag in the MVC config, and\nconsider only the versions configured explicitly in the config as supported.\nRequests with a version that is not supported are rejected with\n`InvalidApiVersionException` resulting in a 400 response.\n\nYou can set an `ApiVersionDeprecationHandler` to send information about deprecated\nversions to clients. The built-in standard handler can set \"Deprecation\", \"Sunset\", and\n\"Link\" headers based on https://datatracker.ietf.org/doc/html/rfc9745[RFC 9745] and\nhttps://datatracker.ietf.org/doc/html/rfc8594[RFC 8594].\n\nOnce API versioning is configured, you can begin to map requests to\nxref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-version[controller methods]\naccording to the request version.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/api-version.adoc", "title": "api-version", "heading": "api-version", "heading_level": 1, "file_order": 330, "section_index": 0, "content_hash": "5a5b06a42b4193c2352a22c6a5039c1ee0ce1fdc7c80d57baceb62e75b00a5e2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/api-version.adoc"}}
{"id": "sha256:fc7a7668041bfddbc87efe6b971cf6d1c2d70321124e73e4611b4ca7f576c3ae", "content": "[[mvc-config-content-negotiation]]\n\n[.small]#xref:web/webflux/config.adoc#webflux-config-content-negotiation[See equivalent in the Reactive stack]#\n\nYou can configure how Spring MVC determines the requested media types from the request\n(for example, `Accept` header, URL path extension, query parameter, and others).\n\nBy default, only the `Accept` header is checked.\n\nIf you must use URL-based content type resolution, consider using the query parameter\nstrategy over path extensions. See\nxref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-suffix-pattern-match[Suffix Match]\nand xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-rfd[Suffix Match and RFD] for\nmore details.\n\nYou can customize requested content type resolution, as the following example shows:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/content-negotiation.adoc", "title": "content-negotiation", "heading": "content-negotiation", "heading_level": 1, "file_order": 331, "section_index": 0, "content_hash": "fc7a7668041bfddbc87efe6b971cf6d1c2d70321124e73e4611b4ca7f576c3ae", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/content-negotiation.adoc"}}
{"id": "sha256:4d1fa810cc9dc308697b4809f26185f857b39a77a40fff90c09c5263c694c4cf", "content": "[[mvc-config-conversion]]\n\n[.small]#xref:web/webflux/config.adoc#webflux-config-conversion[See equivalent in the Reactive stack]#\n\nBy default, formatters for various number and date types are installed, along with support\nfor customization via `@NumberFormat`, `@DurationFormat`, and `@DateTimeFormat` on fields\nand parameters.\n\nTo register custom formatters and converters, use the following:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nBy default Spring MVC considers the request Locale when parsing and formatting date\nvalues. This works for forms where dates are represented as Strings with \"input\" form\nfields. For \"date\" and \"time\" form fields, however, browsers use a fixed format defined\nin the HTML spec. For such cases date and time formatting can be customized as follows:\n\ninclude-code::./DateTimeWebConfiguration[tag=snippet,indent=0]\n\nNOTE: See xref:core/validation/format.adoc#format-FormatterRegistrar-SPI[the `FormatterRegistrar` SPI]\nand the `FormattingConversionServiceFactoryBean` for more information on when to use\nFormatterRegistrar implementations.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/conversion.adoc", "title": "conversion", "heading": "conversion", "heading_level": 1, "file_order": 332, "section_index": 0, "content_hash": "4d1fa810cc9dc308697b4809f26185f857b39a77a40fff90c09c5263c694c4cf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/conversion.adoc"}}
{"id": "sha256:8c05f70f2b67db2614ae32138693b23e8ed8f8b7839b17a073835febfbae4f80", "content": "[[mvc-config-customize]]\n\n[.small]#xref:web/webflux/config.adoc#webflux-config-customize[See equivalent in the Reactive stack]#\n\nIn Java configuration, you can implement the `WebMvcConfigurer` interface, as the\nfollowing example shows:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nIn XML, you can check attributes and sub-elements of `<mvc:annotation-driven/>`. You can\nview the https://schema.spring.io/mvc/spring-mvc.xsd[Spring MVC XML schema] or use\nthe code completion feature of your IDE to discover what attributes and\nsub-elements are available.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/customize.adoc", "title": "customize", "heading": "customize", "heading_level": 1, "file_order": 333, "section_index": 0, "content_hash": "8c05f70f2b67db2614ae32138693b23e8ed8f8b7839b17a073835febfbae4f80", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/customize.adoc"}}
{"id": "sha256:484e60bda14c0bd6bc3265b92d5dc5404716fc3da34e2f0f373c1f13b084de5a", "content": "[[mvc-default-servlet-handler]]\n\nSpring MVC allows for mapping the `DispatcherServlet` to `/` (thus overriding the mapping\nof the container's default Servlet), while still allowing static resource requests to be\nhandled by the container's default Servlet. It configures a\n`DefaultServletHttpRequestHandler` with a URL mapping of `/**` and the lowest priority\nrelative to other URL mappings.\n\nThis handler forwards all requests to the default Servlet. Therefore, it must\nremain last in the order of all other URL `HandlerMappings`. That is the\ncase if you use `<mvc:annotation-driven>`. Alternatively, if you set up your\nown customized `HandlerMapping` instance, be sure to set its `order` property to a value\nlower than that of the `DefaultServletHttpRequestHandler`, which is `Integer.MAX_VALUE`.\n\nThe following example shows how to enable the feature by using the default setup:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nThe caveat to overriding the `/` Servlet mapping is that the `RequestDispatcher` for the\ndefault Servlet must be retrieved by name rather than by path. The\n`DefaultServletHttpRequestHandler` tries to auto-detect the default Servlet for\nthe container at startup time, using a list of known names for most of the major Servlet\ncontainers (including Tomcat, Jetty, GlassFish, JBoss, WebLogic, and WebSphere).\nIf the default Servlet has been custom-configured with a different name, or if a\ndifferent Servlet container is being used where the default Servlet name is unknown,\nthen you must explicitly provide the default Servlet's name, as the following example shows:\n\ninclude-code::./CustomDefaultServletConfiguration[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/default-servlet-handler.adoc", "title": "default-servlet-handler", "heading": "default-servlet-handler", "heading_level": 1, "file_order": 334, "section_index": 0, "content_hash": "484e60bda14c0bd6bc3265b92d5dc5404716fc3da34e2f0f373c1f13b084de5a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/default-servlet-handler.adoc"}}
{"id": "sha256:8d2738e082aac206440e95b6ca4c26d5b395bdd1b9eb7cad8612ecc704bf7855", "content": "[[mvc-config-enable]]\n\n[.small]#xref:web/webflux/config.adoc#webflux-config-enable[See equivalent in the Reactive stack]#\n\nYou can use the `@EnableWebMvc` annotation to enable MVC configuration with programmatic configuration, or `<mvc:annotation-driven>` with XML configuration, as the following example shows:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nWARNING: As of 7.0, support for the XML configuration namespace for Spring MVC has been deprecated.\nThere are no plans yet for removing it completely but XML configuration will not be updated to follow\nthe Java configuration model.\n\nNOTE: When using Spring Boot, you may want to use `@Configuration` classes of type `WebMvcConfigurer` but without `@EnableWebMvc` to keep Spring Boot MVC customizations. See more details in xref:web/webmvc/mvc-config/customize.adoc[the MVC Config API section] and in {spring-boot-docs-ref}/web/servlet.html#web.servlet.spring-mvc.auto-configuration[the dedicated Spring Boot documentation].\n\nThe preceding example registers a number of Spring MVC\nxref:web/webmvc/mvc-servlet/special-bean-types.adoc[infrastructure beans] and adapts to dependencies\navailable on the classpath (for example, payload converters for JSON, XML, and others).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/enable.adoc", "title": "enable", "heading": "enable", "heading_level": 1, "file_order": 335, "section_index": 0, "content_hash": "8d2738e082aac206440e95b6ca4c26d5b395bdd1b9eb7cad8612ecc704bf7855", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/enable.adoc"}}
{"id": "sha256:dccf6a98ca05862ab49b06f78d7ca3d48443f622ce536abdc6e714a9a0d96828", "content": "[[mvc-config-interceptors]]\n\nYou can register interceptors to apply to incoming requests, as the following example shows:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nWARNING: Interceptors are not ideally suited as a security layer due to the potential for\na mismatch with annotated controller path matching. Generally, we recommend using Spring\nSecurity, or alternatively a similar approach integrated with the Servlet filter chain,\nand applied as early as possible.\n\nNOTE: The XML config declares interceptors as `MappedInterceptor` beans, and those are in\nturn detected by any `HandlerMapping` bean, including those from other frameworks.\nBy contrast, the Java config passes interceptors only to the `HandlerMapping` beans it manages.\nTo re-use the same interceptors across Spring MVC and other framework `HandlerMapping`\nbeans with the MVC Java config, either declare `MappedInterceptor` beans (and don't\nmanually add them in the Java config), or configure the same interceptors in both\nthe Java config and in other `HandlerMapping` beans.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/interceptors.adoc", "title": "interceptors", "heading": "interceptors", "heading_level": 1, "file_order": 336, "section_index": 0, "content_hash": "dccf6a98ca05862ab49b06f78d7ca3d48443f622ce536abdc6e714a9a0d96828", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/interceptors.adoc"}}
{"id": "sha256:8e87878d5414f69e6548c80a9fdbeed92a871f0c51c827cf05ed5155d6e000cc", "content": "[[mvc-config-message-converters]]\n\n[.small]#xref:web/webflux/config.adoc#webflux-config-message-codecs[See equivalent in the Reactive stack]#\n\nYou can configure the `HttpMessageConverter` instances to use by overriding\n{spring-framework-api}/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters(org.springframework.http.converter.HttpMessageConverters.Builder)[`configureMessageConverters()`].\n\nThe following example configures custom Jackson JSON and XML converters with customized mappers instead of the default\nones:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/message-converters.adoc", "title": "message-converters", "heading": "message-converters", "heading_level": 1, "file_order": 337, "section_index": 0, "content_hash": "8e87878d5414f69e6548c80a9fdbeed92a871f0c51c827cf05ed5155d6e000cc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/message-converters.adoc"}}
{"id": "sha256:952abecd939a0742bd11f39355b2d536c7d6ed17f6de5d43a2e526952496930a", "content": "[[mvc-config-path-matching]]\n\n[.small]#xref:web/webflux/config.adoc#webflux-config-path-matching[See equivalent in the Reactive stack]#\n\nYou can customize options related to path matching and treatment of the URL.\nFor details on the individual options, see the\n{spring-framework-api}/web/servlet/config/annotation/PathMatchConfigurer.html[`PathMatchConfigurer`] javadoc.\n\nThe following example shows how to customize path matching:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/path-matching.adoc", "title": "path-matching", "heading": "path-matching", "heading_level": 1, "file_order": 338, "section_index": 0, "content_hash": "952abecd939a0742bd11f39355b2d536c7d6ed17f6de5d43a2e526952496930a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/path-matching.adoc"}}
{"id": "sha256:a9b1fa75c777fbb9f4eff9e9c4228e8dfc4f67ec5045132806a8d58c3ec821c4", "content": "[[mvc-config-static-resources]]\n\n[.small]#xref:web/webflux/config.adoc#webflux-config-static-resources[See equivalent in the Reactive stack]#\n\nThis option provides a convenient way to serve static resources from a list of\n{spring-framework-api}/core/io/Resource.html[`Resource`]-based locations.\n\nIn the next example, given a request that starts with `/resources`, the relative path is\nused to find and serve static resources relative to `/public` under the web application\nroot or on the classpath under `/static`. The resources are served with a one-year future\nexpiration to ensure maximum use of the browser cache and a reduction in HTTP requests\nmade by the browser. The `Last-Modified` information is deduced from `Resource#lastModified`\nso that HTTP conditional requests are supported with `\"Last-Modified\"` headers.\n\nThe following listing shows how to do so:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nSee also\nxref:web/webmvc/mvc-caching.adoc#mvc-caching-static-resources[HTTP caching support for static resources].\n\nThe resource handler also supports a chain of\n{spring-framework-api}/web/servlet/resource/ResourceResolver.html[`ResourceResolver`] implementations and\n{spring-framework-api}/web/servlet/resource/ResourceTransformer.html[`ResourceTransformer`] implementations,\nwhich you can use to create a toolchain for working with optimized resources.\n\nYou can use the `VersionResourceResolver` for versioned resource URLs based on an MD5 hash\ncomputed from the content, a fixed application version, or other. A\n`ContentVersionStrategy` (MD5 hash) is a good choice -- with some notable exceptions, such as\nJavaScript resources used with a module loader.\n\nThe following example shows how to use `VersionResourceResolver`:\n\ninclude-code::./VersionedConfiguration[tag=snippet,indent=0]\n\nYou can then use `ResourceUrlProvider` to rewrite URLs and apply the full chain of resolvers and\ntransformers -- for example, to insert versions. The MVC configuration provides a `ResourceUrlProvider`\nbean so that it can be injected into others. You can also make the rewrite transparent with the\n`ResourceUrlEncodingFilter` for Thymeleaf, JSPs, FreeMarker, and others with URL tags that\nrely on `HttpServletResponse#encodeURL`.\n\nNote that, when using both `EncodedResourceResolver` (for example, for serving gzipped or\nbrotli-encoded resources) and `VersionResourceResolver`, you must register them in this order.\nThat ensures content-based versions are always computed reliably, based on the unencoded file.\n\nFor https://www.webjars.org/documentation[WebJars], versioned URLs like\n`/webjars/jquery/1.2.0/jquery.min.js` are the recommended and most efficient way to use them.\nThe related resource location is configured out of the box with Spring Boot (or can be configured\nmanually via `ResourceHandlerRegistry`) and does not require to add the\n`org.webjars:webjars-locator-lite` dependency.\n\nVersion-less URLs like `/webjars/jquery/jquery.min.js` are supported through the\n`WebJarsResourceResolver` which is automatically registered when the\n`org.webjars:webjars-locator-lite` library is present on the classpath. The resolver can re-write\nURLs to include the version of the jar and can also match against incoming URLs without versions\n-- for example, from `/webjars/jquery/jquery.min.js` to `/webjars/jquery/1.2.0/jquery.min.js`.\n\nTIP: The Java configuration based on `ResourceHandlerRegistry` provides further options\nfor fine-grained control, for example, last-modified behavior and optimized resource resolution.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/static-resources.adoc", "title": "static-resources", "heading": "static-resources", "heading_level": 1, "file_order": 339, "section_index": 0, "content_hash": "a9b1fa75c777fbb9f4eff9e9c4228e8dfc4f67ec5045132806a8d58c3ec821c4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/static-resources.adoc"}}
{"id": "sha256:23502059f9ebbf63336337069bc5cea296c0e05415b190b993c422c5a9145a9d", "content": "[[mvc-config-validation]]\n\n[.small]#xref:web/webflux/config.adoc#webflux-config-validation[See equivalent in the Reactive stack]#\n\nBy default, if xref:core/validation/beanvalidation.adoc#validation-beanvalidation-overview[Bean Validation] is present\non the classpath (for example, Hibernate Validator), the `LocalValidatorFactoryBean` is\nregistered as a global xref:core/validation/validator.adoc[Validator] for use with `@Valid` and\n`@Validated` on controller method arguments.\n\nYou can customize the global `Validator` instance, as the\nfollowing example shows:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nNote that you can also register `Validator` implementations locally, as the following\nexample shows:\n\ninclude-code::./MyController[tag=snippet,indent=0]\n\nTIP: If you need to have a `LocalValidatorFactoryBean` injected somewhere, create a bean and\nmark it with `@Primary` in order to avoid conflict with the one declared in the MVC configuration.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/validation.adoc", "title": "validation", "heading": "validation", "heading_level": 1, "file_order": 340, "section_index": 0, "content_hash": "23502059f9ebbf63336337069bc5cea296c0e05415b190b993c422c5a9145a9d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/validation.adoc"}}
{"id": "sha256:da69fef30af0d7c0c52de4843d50dd30244a6cc3097fdd06c511c9fa56756a17", "content": "[[mvc-config-view-controller]]\n\nThis is a shortcut for defining a `ParameterizableViewController` that immediately\nforwards to a view when invoked. You can use it in static cases when there is no Java controller\nlogic to run before the view generates the response.\n\nThe following example forwards a request for `/` to a view called `home`:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nIf an `@RequestMapping` method is mapped to a URL for any HTTP method then a view\ncontroller cannot be used to handle the same URL. This is because a match by URL to an\nannotated controller is considered a strong enough indication of endpoint ownership so\nthat a 405 (METHOD_NOT_ALLOWED), a 415 (UNSUPPORTED_MEDIA_TYPE), or similar response can\nbe sent to the client to help with debugging. For this reason it is recommended to avoid\nsplitting URL handling across an annotated controller and a view controller.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/view-controller.adoc", "title": "view-controller", "heading": "view-controller", "heading_level": 1, "file_order": 341, "section_index": 0, "content_hash": "da69fef30af0d7c0c52de4843d50dd30244a6cc3097fdd06c511c9fa56756a17", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/view-controller.adoc"}}
{"id": "sha256:2a9dd7ed7142dd690d5e3eaa426287c53160db028d1947ed1b395fa844869015", "content": "[[mvc-config-view-resolvers]]\n\n[.small]#xref:web/webflux/config.adoc#webflux-config-view-resolvers[See equivalent in the Reactive stack]#\n\nThe MVC configuration simplifies the registration of view resolvers.\n\nThe following example configures content negotiation view resolution by using JSP and Jackson as a\ndefault `View` for JSON rendering:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nNote, however, that FreeMarker, Groovy Markup, and script templates also require\nconfiguration of the underlying view technology. The following example works with FreeMarker:\n\ninclude-code::./FreeMarkerConfiguration[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/view-resolvers.adoc", "title": "view-resolvers", "heading": "view-resolvers", "heading_level": 1, "file_order": 342, "section_index": 0, "content_hash": "2a9dd7ed7142dd690d5e3eaa426287c53160db028d1947ed1b395fa844869015", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config/view-resolvers.adoc"}}
{"id": "sha256:02453bf1eefcdf4453570f3d1d6b2d5e91eabdecf173b4fcdd86203a494434ea", "content": "[[mvc-ann-arguments]]\n\n[.small]#xref:web/webflux/controller/ann-methods/arguments.adoc[See equivalent in the Reactive stack]#\n\nThe next table describes the supported controller method arguments. Reactive types are not supported\nfor any arguments.\n\n`java.util.Optional` is supported as a method argument in combination with\nannotations that have a `required` attribute (for example, `@RequestParam`, `@RequestHeader`,\nand others) and is equivalent to `required=false`.\n\n[cols=\"1,2\", options=\"header\"]\n|===\n| Controller method argument | Description\n\n| `WebRequest`, `NativeWebRequest`\n| Generic access to request parameters and request and session attributes, without direct\n use of the Servlet API.\n\n| `jakarta.servlet.ServletRequest`, `jakarta.servlet.ServletResponse`\n| Choose any specific request or response type -- for example, `ServletRequest`, `HttpServletRequest`,\n or Spring's `MultipartRequest`, `MultipartHttpServletRequest`.\n\n| `jakarta.servlet.http.HttpSession`\n| Enforces the presence of a session. As a consequence, such an argument is never `null`.\n Note that session access is not thread-safe. Consider setting the\n `RequestMappingHandlerAdapter` instance's `synchronizeOnSession` flag to `true` if multiple\n requests are allowed to concurrently access a session.\n\n| `jakarta.servlet.http.PushBuilder`\n| Servlet 4.0 push builder API for programmatic HTTP/2 resource pushes.\n Note that this API has been deprecated as of Servlet 6.1.\n\n| `java.security.Principal`\n| Currently authenticated user -- possibly a specific `Principal` implementation class if known.\n\n Note that this argument is not resolved eagerly, if it is annotated in order to allow a custom resolver to resolve it\n before falling back on default resolution via `HttpServletRequest#getUserPrincipal`.\n For example, the Spring Security `Authentication` implements `Principal` and would be injected as such via\n `HttpServletRequest#getUserPrincipal`, unless it is also annotated with `@AuthenticationPrincipal` in which case it\n is resolved by a custom Spring Security resolver through `Authentication#getPrincipal`.\n\n| `HttpMethod`\n| The HTTP method of the request.\n\n| `java.util.Locale`\n| The current request locale, determined by the most specific `LocaleResolver` available (in\n effect, the configured `LocaleResolver` or `LocaleContextResolver`).\n\n| `java.util.TimeZone` + `java.time.ZoneId`\n| The time zone associated with the current request, as determined by a `LocaleContextResolver`.\n\n| `java.io.InputStream`, `java.io.Reader`\n| For access to the raw request body as exposed by the Servlet API.\n\n| `java.io.OutputStream`, `java.io.Writer`\n| For access to the raw response body as exposed by the Servlet API.\n\n| `@PathVariable`\n| For access to URI template variables. See xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-uri-templates[URI patterns].\n\n| `@MatrixVariable`\n| For access to name-value pairs in URI path segments. See xref:web/webmvc/mvc-controller/ann-methods/matrix-variables.adoc[Matrix Variables].\n\n| `@RequestParam`\n| For access to the Servlet request parameters, including multipart files. Parameter values\n are converted to the declared method argument type. See xref:web/webmvc/mvc-controller/ann-methods/requestparam.adoc[`@RequestParam`] as well\n as xref:web/webmvc/mvc-controller/ann-methods/multipart-forms.adoc[Multipart].\n\n Note that use of `@RequestParam` is optional for simple parameter values.\n See \"`Any other argument`\", at the end of this table.\n\n| `@RequestHeader`\n| For access to request headers. Header values are converted to the declared method argument\n type. See xref:web/webmvc/mvc-controller/ann-methods/requestheader.adoc[`@RequestHeader`].\n\n| `@CookieValue`\n| For access to cookies. Cookies values are converted to the declared method argument\n type. See xref:web/webmvc/mvc-controller/ann-methods/cookievalue.adoc[`@CookieValue`].\n\n| `@RequestBody`\n| For access to the HTTP request body. Body content is converted to the declared method\n argument type by using `HttpMessageConverter` implementations. See xref:web/webmvc/mvc-controller/ann-methods/requestbody.adoc[`@RequestBody`].\n\n| `HttpEntity<B>`\n| For access to request headers and body. The body is converted with an `HttpMessageConverter`.\n See xref:web/webmvc/mvc-controller/ann-methods/httpentity.adoc[HttpEntity].\n\n| `@RequestPart`\n| For access to a part in a `multipart/form-data` request, converting the part's body\n with an `HttpMessageConverter`. See xref:web/webmvc/mvc-controller/ann-methods/multipart-forms.adoc[Multipart].\n\n| `java.util.Map`, `org.springframework.ui.Model`, `org.springframework.ui.ModelMap`\n| For access to the model that is used in HTML controllers and exposed to templates as\n part of view rendering.\n\n| `RedirectAttributes`\n| Specify attributes to use in case of a redirect (that is, to be appended to the query\n string) and flash attributes to be stored temporarily until the request after redirect.\n See xref:web/webmvc/mvc-controller/ann-methods/redirecting-passing-data.adoc[Redirect Attributes] and xref:web/webmvc/mvc-controller/ann-methods/flash-attributes.adoc[Flash Attributes].\n\n| `@ModelAttribute`\n| For access to an existing attribute in the model (instantiated if not present) with\n data binding and validation applied. See xref:web/webmvc/mvc-controller/ann-methods/modelattrib-method-args.adoc[`@ModelAttribute`] as well as\n xref:web/webmvc/mvc-controller/ann-modelattrib-methods.adoc[Model] and xref:web/webmvc/mvc-controller/ann-initbinder.adoc[`DataBinder`].\n\n Note that use of `@ModelAttribute` is optional (for example, to set its attributes).\n See \"`Any other argument`\" at the end of this table.\n\n| `Errors`, `BindingResult`\n| For access to errors from validation and data binding for a command object\n (that is, a `@ModelAttribute` argument) or errors from the validation of a `@RequestBody` or\n `@RequestPart` arguments. You must declare an `Errors`, or `BindingResult` argument\n immediately after the validated method argument.\n\n| `SessionStatus` + class-level `@SessionAttributes`\n| For marking form processing complete, which triggers cleanup of session attributes\n declared through a class-level `@SessionAttributes` annotation. See\n xref:web/webmvc/mvc-controller/ann-methods/sessionattributes.adoc[`@SessionAttributes`] for more details.\n\n| `UriComponentsBuilder`\n| For preparing a URL relative to the current request's host, port, scheme, context path, and\n the literal part of the servlet mapping. See xref:web/webmvc/mvc-uri-building.adoc[URI Links].\n\n| `@SessionAttribute`\n| For access to any session attribute, in contrast to model attributes stored in the session\n as a result of a class-level `@SessionAttributes` declaration. See\n xref:web/webmvc/mvc-controller/ann-methods/sessionattribute.adoc[`@SessionAttribute`] for more details.\n\n| `@RequestAttribute`\n| For access to request attributes. See xref:web/webmvc/mvc-controller/ann-methods/requestattrib.adoc[`@RequestAttribute`] for more details.\n\n| Any other argument\n| If a method argument is not matched to any of the earlier values in this table and it is\n a simple type (as determined by\n\t{spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty]),\n it is resolved as a `@RequestParam`. Otherwise, it is resolved as a `@ModelAttribute`.\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/arguments.adoc", "title": "arguments", "heading": "arguments", "heading_level": 1, "file_order": 343, "section_index": 0, "content_hash": "02453bf1eefcdf4453570f3d1d6b2d5e91eabdecf173b4fcdd86203a494434ea", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/arguments.adoc"}}
{"id": "sha256:7235500b221a699bea5395940f2d9d7326c4937e61a0e202cf4aaca1d0764ab9", "content": "[[mvc-ann-cookievalue]]\n\n[.small]#xref:web/webflux/controller/ann-methods/cookievalue.adoc[See equivalent in the Reactive stack]#\n\nYou can use the `@CookieValue` annotation to bind the value of an HTTP cookie to a method argument\nin a controller.\n\nConsider a request with the following cookie:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nJSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84\n----\n\nThe following example shows how to get the cookie value:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/demo\")\n\tpublic void handle(@CookieValue(\"JSESSIONID\") String cookie) { <1>\n //...\n\t}\n----\n<1> Get the value of the `JSESSIONID` cookie.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/demo\")\n\tfun handle(@CookieValue(\"JSESSIONID\") cookie: String) { // <1>\n //...\n\t}\n----\n<1> Get the value of the `JSESSIONID` cookie.\n======\n\nIf the target method parameter type is not `String`, type conversion is applied automatically.\nSee xref:web/webmvc/mvc-controller/ann-methods/typeconversion.adoc[Type Conversion].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/cookievalue.adoc", "title": "cookievalue", "heading": "cookievalue", "heading_level": 1, "file_order": 344, "section_index": 0, "content_hash": "7235500b221a699bea5395940f2d9d7326c4937e61a0e202cf4aaca1d0764ab9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/cookievalue.adoc"}}
{"id": "sha256:8c84e68d663748164502336f697eee1174534ebe8b758d681f8c7dc3000059a1", "content": "[[mvc-flash-attributes]]\n\nFlash attributes provide a way for one request to store attributes that are intended for use in\nanother. This is most commonly needed when redirecting -- for example, the\nPost-Redirect-Get pattern. Flash attributes are saved temporarily before the\nredirect (typically in the session) to be made available to the request after the\nredirect and are removed immediately.\n\nSpring MVC has two main abstractions in support of flash attributes. `FlashMap` is used\nto hold flash attributes, while `FlashMapManager` is used to store, retrieve, and manage\n`FlashMap` instances.\n\nFlash attribute support is always \"`on`\" and does not need to be enabled explicitly.\nHowever, if not used, it never causes HTTP session creation. On each request, there is an\n\"`input`\" `FlashMap` with attributes passed from a previous request (if any) and an\n\"`output`\" `FlashMap` with attributes to save for a subsequent request. Both `FlashMap`\ninstances are accessible from anywhere in Spring MVC through static methods in\n`RequestContextUtils`.\n\nAnnotated controllers typically do not need to work with `FlashMap` directly. Instead, a\n`@RequestMapping` method can accept an argument of type `RedirectAttributes` and use it\nto add flash attributes for a redirect scenario. Flash attributes added through\n`RedirectAttributes` are automatically propagated to the \"`output`\" FlashMap. Similarly,\nafter the redirect, attributes from the \"`input`\" `FlashMap` are automatically added to the\n`Model` of the controller that serves the target URL.\n\n.Matching requests to flash attributes\n****\nThe concept of flash attributes exists in many other web frameworks and has proven to sometimes\nbe exposed to concurrency issues. This is because, by definition, flash attributes\nare to be stored until the next request. However the very \"`next`\" request may not be the\nintended recipient but another asynchronous request (for example, polling or resource requests),\nin which case the flash attributes are removed too early.\n\nTo reduce the possibility of such issues, `RedirectView` automatically \"`stamps`\"\n`FlashMap` instances with the path and query parameters of the target redirect URL. In\nturn, the default `FlashMapManager` matches that information to incoming requests when\nit looks up the \"`input`\" `FlashMap`.\n\nThis does not entirely eliminate the possibility of a concurrency issue but\nreduces it greatly with information that is already available in the redirect URL.\nTherefore, we recommend that you use flash attributes mainly for redirect scenarios.\n****", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/flash-attributes.adoc", "title": "flash-attributes", "heading": "flash-attributes", "heading_level": 1, "file_order": 345, "section_index": 0, "content_hash": "8c84e68d663748164502336f697eee1174534ebe8b758d681f8c7dc3000059a1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/flash-attributes.adoc"}}
{"id": "sha256:504b05e701a23614728b6ce3e770b231a212dd40c5a73ccc1b1cb9fa515e1907", "content": "[[mvc-ann-httpentity]]\n\n[.small]#xref:web/webflux/controller/ann-methods/httpentity.adoc[See equivalent in the Reactive stack]#\n\n`HttpEntity` is more or less identical to using xref:web/webmvc/mvc-controller/ann-methods/requestbody.adoc[`@RequestBody`] but is based on a\ncontainer object that exposes request headers and body. The following listing shows an example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tpublic void handle(HttpEntity<Account> entity) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tfun handle(entity: HttpEntity<Account>) {\n // ...\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/httpentity.adoc", "title": "httpentity", "heading": "httpentity", "heading_level": 1, "file_order": 346, "section_index": 0, "content_hash": "504b05e701a23614728b6ce3e770b231a212dd40c5a73ccc1b1cb9fa515e1907", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/httpentity.adoc"}}
{"id": "sha256:35a6dc8af990c32bd4fcec816c261f6bd1545a339c83f3b3dd8f5959d70c08ab", "content": "[[mvc-ann-jackson]]\n\nSpring offers support for the Jackson JSON library.\n\n[[mvc-ann-jsonview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/jackson.adoc", "title": "jackson", "heading": "jackson", "heading_level": 1, "file_order": 347, "section_index": 0, "content_hash": "35a6dc8af990c32bd4fcec816c261f6bd1545a339c83f3b3dd8f5959d70c08ab", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/jackson.adoc"}}
{"id": "sha256:0a08b8aafda78c4b465735b542fe7ffc4856b623d67d414a819e5f83f3c60ad0", "content": "[.small]#xref:web/webflux/controller/ann-methods/jackson.adoc#webflux-ann-jsonview[See equivalent in the Reactive stack]#\n\nSpring MVC provides built-in support for\n{baeldung-blog}/jackson-json-view-annotation[Jackson's Serialization Views],\nwhich allow rendering only a subset of all fields in an `Object`. To use it with\n`@ResponseBody` or `ResponseEntity` controller methods, you can use Jackson's\n`@JsonView` annotation to activate a serialization view class, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\tpublic class UserController {\n\n @GetMapping(\"/user\")\n @JsonView(User.WithoutPasswordView.class)\n public User getUser() {\n return new User(\"eric\", \"7!jd#h23\");\n }\n\t}\n\n\tpublic class User {\n\n public interface WithoutPasswordView {};\n public interface WithPasswordView extends WithoutPasswordView {};\n\n private String username;\n private String password;\n\n public User() {\n }\n\n public User(String username, String password) {\n this.username = username;\n this.password = password;\n }\n\n @JsonView(WithoutPasswordView.class)\n public String getUsername() {\n return this.username;\n }\n\n @JsonView(WithPasswordView.class)\n public String getPassword() {\n return this.password;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\tclass UserController {\n\n @GetMapping(\"/user\")\n @JsonView(User.WithoutPasswordView::class)\n fun getUser() = User(\"eric\", \"7!jd#h23\")\n\t}\n\n\tclass User(\n @JsonView(WithoutPasswordView::class) val username: String,\n @JsonView(WithPasswordView::class) val password: String) {\n\n interface WithoutPasswordView\n interface WithPasswordView : WithoutPasswordView\n\t}\n----\n======\n\nNOTE: `@JsonView` allows an array of view classes, but you can specify only one per\ncontroller method. If you need to activate multiple views, you can use a composite interface.\n\nIf you want to do the above programmatically, instead of declaring an `@JsonView` annotation,\nwrap the return value with `MappingJacksonValue` and use it to supply the serialization view:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\tpublic class UserController {\n\n @GetMapping(\"/user\")\n public MappingJacksonValue getUser() {\n User user = new User(\"eric\", \"7!jd#h23\");\n MappingJacksonValue value = new MappingJacksonValue(user);\n value.setSerializationView(User.WithoutPasswordView.class);\n return value;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\tclass UserController {\n\n @GetMapping(\"/user\")\n fun getUser(): MappingJacksonValue {\n val value = MappingJacksonValue(User(\"eric\", \"7!jd#h23\"))\n value.serializationView = User.WithoutPasswordView::class.java\n return value\n }\n\t}\n----\n======\n\nFor controllers that rely on view resolution, you can add the serialization view class\nto the model, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class UserController extends AbstractController {\n\n @GetMapping(\"/user\")\n public String getUser(Model model) {\n model.addAttribute(\"user\", new User(\"eric\", \"7!jd#h23\"));\n model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);\n return \"userView\";\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tclass UserController : AbstractController() {\n\n @GetMapping(\"/user\")\n fun getUser(model: Model): String {\n model[\"user\"] = User(\"eric\", \"7!jd#h23\")\n model[JsonView::class.qualifiedName] = User.WithoutPasswordView::class.java\n return \"userView\"\n }\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/jackson.adoc", "title": "jackson", "heading": "JSON Views", "heading_level": 2, "file_order": 347, "section_index": 1, "content_hash": "0a08b8aafda78c4b465735b542fe7ffc4856b623d67d414a819e5f83f3c60ad0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/jackson.adoc"}}
{"id": "sha256:e9a2c5c27ee787b6bc6ef831aff63d18b59a0ce88a7dfb278f58a124910fb4a9", "content": "[[mvc-ann-matrix-variables]]\n\n[.small]#xref:web/webflux/controller/ann-methods/matrix-variables.adoc[See equivalent in the Reactive stack]#\n\n{rfc-site}/rfc3986#section-3.3[RFC 3986] discusses name-value pairs in\npath segments. In Spring MVC, we refer to those as \"`matrix variables`\" based on an\nhttps://www.w3.org/DesignIssues/MatrixURIs.html[\"`old post`\"] by Tim Berners-Lee, but they\ncan be also be referred to as URI path parameters.\n\nMatrix variables can appear in any path segment, with each variable separated by a semicolon and\nmultiple values separated by comma (for example, `/cars;color=red,green;year=2012`). Multiple\nvalues can also be specified through repeated variable names (for example,\n`color=red;color=green;color=blue`).\n\nIf a URL is expected to contain matrix variables, the request mapping for a controller\nmethod must use a URI variable to mask that variable content and ensure the request can\nbe matched successfully independent of matrix variable order and presence.\nThe following example uses a matrix variable:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /pets/42;q=11;r=22\n\n\t@GetMapping(\"/pets/{petId}\")\n\tpublic void findPet(@PathVariable String petId, @MatrixVariable int q) {\n\n // petId == 42\n // q == 11\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /pets/42;q=11;r=22\n\n\t@GetMapping(\"/pets/{petId}\")\n\tfun findPet(@PathVariable petId: String, @MatrixVariable q: Int) {\n\n // petId == 42\n // q == 11\n\t}\n----\n======\n\nGiven that all path segments may contain matrix variables, you may sometimes need to\ndisambiguate which path variable the matrix variable is expected to be in.\nThe following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /owners/42;q=11/pets/21;q=22\n\n\t@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n\tpublic void findPet(\n @MatrixVariable(name=\"q\", pathVar=\"ownerId\") int q1,\n @MatrixVariable(name=\"q\", pathVar=\"petId\") int q2) {\n\n // q1 == 11\n // q2 == 22\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /owners/42;q=11/pets/21;q=22\n\n\t@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n\tfun findPet(\n @MatrixVariable(name = \"q\", pathVar = \"ownerId\") q1: Int,\n @MatrixVariable(name = \"q\", pathVar = \"petId\") q2: Int) {\n\n // q1 == 11\n // q2 == 22\n\t}\n----\n======\n\nA matrix variable may be defined as optional and a default value specified, as the\nfollowing example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /pets/42\n\n\t@GetMapping(\"/pets/{petId}\")\n\tpublic void findPet(@MatrixVariable(required=false, defaultValue=\"1\") int q) {\n\n // q == 1\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /pets/42\n\n\t@GetMapping(\"/pets/{petId}\")\n\tfun findPet(@MatrixVariable(required = false, defaultValue = \"1\") q: Int) {\n\n // q == 1\n\t}\n----\n======\n\nTo get all matrix variables, you can use a `MultiValueMap`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /owners/42;q=11;r=12/pets/21;q=22;s=23\n\n\t@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n\tpublic void findPet(\n @MatrixVariable MultiValueMap<String, String> matrixVars,\n @MatrixVariable(pathVar=\"petId\") MultiValueMap<String, String> petMatrixVars) {\n\n // matrixVars: [\"q\" : [11,22], \"r\" : 12, \"s\" : 23]\n // petMatrixVars: [\"q\" : 22, \"s\" : 23]\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// GET /owners/42;q=11;r=12/pets/21;q=22;s=23\n\n\t@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n\tfun findPet(\n @MatrixVariable matrixVars: MultiValueMap<String, String>,\n @MatrixVariable(pathVar=\"petId\") petMatrixVars: MultiValueMap<String, String>) {\n\n // matrixVars: [\"q\" : [11,22], \"r\" : 12, \"s\" : 23]\n // petMatrixVars: [\"q\" : 22, \"s\" : 23]\n\t}\n----\n======\n\nNote that you need to enable the use of matrix variables. In the MVC XML namespace, you can set\n`<mvc:annotation-driven enable-matrix-variables=\"true\"/>`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/matrix-variables.adoc", "title": "matrix-variables", "heading": "matrix-variables", "heading_level": 1, "file_order": 348, "section_index": 0, "content_hash": "e9a2c5c27ee787b6bc6ef831aff63d18b59a0ce88a7dfb278f58a124910fb4a9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/matrix-variables.adoc"}}
{"id": "sha256:46d552e3f62df67cacfded3b688ae9a98f69edfc7526fc6fe3e1be4d5bdb2c8b", "content": "[[mvc-ann-modelattrib-method-args]]\n\n[.small]#xref:web/webflux/controller/ann-methods/modelattrib-method-args.adoc[See equivalent in the Reactive stack]#\n\nThe `@ModelAttribute` method parameter annotation binds request parameters, URI path variables,\nand request headers onto a model object. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n\tpublic String processSubmit(@ModelAttribute Pet pet) { // <1>\n // method logic...\n\t}\n----\n<1> Bind to an instance of `Pet`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\nfun processSubmit(@ModelAttribute pet: Pet): String { // <1>\n\t// method logic...\n}\n----\n<1> Bind to an instance of `Pet`.\n======\n\nRequest parameters are a Servlet API concept that includes form data from the request body,\nand query parameters. URI variables and headers are also included, but only if they don't\noverride request parameters with the same name. Dashes are stripped from header names.\n\nThe `Pet` instance above may be:\n\n* Accessed from the model where it could have been added by a\n xref:web/webmvc/mvc-controller/ann-modelattrib-methods.adoc[@ModelAttribute method].\n* Accessed from the HTTP session if the model attribute was listed in\n the class-level xref:web/webmvc/mvc-controller/ann-methods/sessionattributes.adoc[`@SessionAttributes`] annotation.\n* Obtained through a `Converter` if the model attribute name matches the name of a\n request value such as a path variable or a request parameter (example follows).\n* Instantiated through a default constructor.\n* Instantiated through a \"`primary constructor`\" with arguments that match to Servlet\n request parameters. Argument names are determined through runtime-retained parameter\n names in the bytecode.\n\nAs mentioned above, a `Converter<String, T>` may be used to obtain the model object if\nthe model attribute name matches to the name of a request value such as a path variable or a\nrequest parameter, _and_ there is a compatible `Converter<String, T>`. In the below example,\nthe model attribute name `account` matches URI path variable `account`, and there is a\nregistered `Converter<String, Account>` that perhaps retrieves it from a persistence store:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PutMapping(\"/accounts/{account}\")\n\tpublic String save(@ModelAttribute(\"account\") Account account) { // <1>\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PutMapping(\"/accounts/{account}\")\n\tfun save(@ModelAttribute(\"account\") account: Account): String { // <1>\n // ...\n\t}\n----\n======\n\nBy default, both constructor and property\nxref:core/validation/data-binding.adoc[data binding] are applied. However,\nmodel object design requires careful consideration, and for security reasons it is\nrecommended either to use an object tailored specifically for web binding, or to apply\nconstructor binding only. If property binding must still be used, then _allowedFields_\npatterns should be set to limit which properties can be set. For further details on this\nand example configuration, see\nxref:web/webmvc/mvc-controller/ann-initbinder.adoc#mvc-ann-initbinder-model-design[model design].\n\nWhen using constructor binding, you can customize request parameter names through an\n`@BindParam` annotation. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Account {\n\n private final String firstName;\n\n public Account(@BindParam(\"first-name\") String firstName) {\n this.firstName = firstName;\n }\n\t}\n----\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Account(@BindParam(\"first-name\") val firstName: String)\n----\n======\n\nNOTE: The `@BindParam` may also be placed on the fields that correspond to constructor\nparameters. While `@BindParam` is supported out of the box, you can also use a\ndifferent annotation by setting a `DataBinder.NameResolver` on `DataBinder`\n\nConstructor binding supports `List`, `Map`, and array arguments either converted from\na single string, for example, comma-separated list, or based on indexed keys such as\n`accounts[2].name` or `account[KEY].name`.\n\nIn some cases, you may want access to a model attribute without data binding. For such\ncases, you can inject the `Model` into the controller and access it directly or,\nalternatively, set `@ModelAttribute(binding=false)`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ModelAttribute\n\tpublic AccountForm setUpForm() {\n return new AccountForm();\n\t}\n\n\t@ModelAttribute\n\tpublic Account findAccount(@PathVariable String accountId) {\n return accountRepository.findOne(accountId);\n\t}\n\n\t@PostMapping(\"update\")\n\tpublic String update(AccountForm form, BindingResult result,\n @ModelAttribute(binding=false) Account account) { // <1>\n // ...\n\t}\n----\n<1> Setting `@ModelAttribute(binding=false)`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ModelAttribute\n\tfun setUpForm(): AccountForm {\n return AccountForm()\n\t}\n\n\t@ModelAttribute\n\tfun findAccount(@PathVariable accountId: String): Account {\n return accountRepository.findOne(accountId)\n\t}\n\n\t@PostMapping(\"update\")\n\tfun update(form: AccountForm, result: BindingResult,\n @ModelAttribute(binding = false) account: Account): String { // <1>\n // ...\n\t}\n----\n<1> Setting `@ModelAt\\tribute(binding=false)`.\n======\n\nIf data binding results in errors, by default a `MethodArgumentNotValidException` is raised,\nbut you can also add a `BindingResult` argument immediately next to the `@ModelAttribute`\nin order to handle such errors in the controller method. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n\tpublic String processSubmit(@ModelAttribute(\"pet\") Pet pet, BindingResult result) { // <1>\n if (result.hasErrors()) {\n return \"petForm\";\n }\n // ...\n\t}\n----\n<1> Adding a `BindingResult` next to the `@ModelAttribute`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n\tfun processSubmit(@ModelAttribute(\"pet\") pet: Pet, result: BindingResult): String { // <1>\n if (result.hasErrors()) {\n return \"petForm\"\n }\n // ...\n\t}\n----\n<1> Adding a `BindingResult` next to the `@ModelAttribute`.\n======\n\nYou can automatically apply validation after data binding by adding the\n`jakarta.validation.Valid` annotation or Spring's `@Validated` annotation.\nSee xref:core/validation/beanvalidation.adoc[Bean Validation] and\nxref:web/webmvc/mvc-config/validation.adoc[Spring validation]. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n public String processSubmit(@Valid @ModelAttribute(\"pet\") Pet pet, BindingResult result) { // <1>\n if (result.hasErrors()) {\n return \"petForm\";\n }\n // ...\n }\n----\n<1> Validate the `Pet` instance.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\n\tfun processSubmit(@Valid @ModelAttribute(\"pet\") pet: Pet, result: BindingResult): String { // <1>\n if (result.hasErrors()) {\n return \"petForm\"\n }\n // ...\n\t}\n----\n<1> Validate the `Pet` instance.\n======\n\nIf there is no `BindingResult` parameter after the `@ModelAttribute`, then\na `MethodArgumentNotValidException` is raised with the validation errors. However, if method\nvalidation applies because other parameters have `@jakarta.validation.Constraint` annotations,\nthen `HandlerMethodValidationException` is raised instead. For more details, see the section\nxref:web/webmvc/mvc-controller/ann-validation.adoc[Validation].\n\nTIP: Using `@ModelAttribute` is optional. By default, any parameter that is not a simple\nvalue type as determined by\n{spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty]\n_AND_ that is not resolved by any other argument resolver is treated as an implicit `@ModelAttribute`.\n\nWARNING: When compiling to a native image with GraalVM, the implicit `@ModelAttribute`\nsupport described above does not allow proper ahead-of-time inference of related data\nbinding reflection hints. As a consequence, it is recommended to explicitly annotate\nmethod parameters with `@ModelAttribute` for use in a GraalVM native image.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/modelattrib-method-args.adoc", "title": "modelattrib-method-args", "heading": "modelattrib-method-args", "heading_level": 1, "file_order": 349, "section_index": 0, "content_hash": "46d552e3f62df67cacfded3b688ae9a98f69edfc7526fc6fe3e1be4d5bdb2c8b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/modelattrib-method-args.adoc"}}
{"id": "sha256:9d29e6e9c67780ebb668d0dd7df06ae52ad5f410eb8825ec7e944d6f8d933b1c", "content": "[[mvc-multipart-forms]]\n\n[.small]#xref:web/webflux/controller/ann-methods/multipart-forms.adoc[See equivalent in the Reactive stack]#\n\nAfter a `MultipartResolver` has been xref:web/webmvc/mvc-servlet/multipart.adoc[enabled], the content of POST\nrequests with `multipart/form-data` is parsed and accessible as regular request\nparameters. The following example accesses one regular form field and one uploaded\nfile:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class FileUploadController {\n\n @PostMapping(\"/form\")\n public String handleFormUpload(@RequestParam(\"name\") String name,\n @RequestParam(\"file\") MultipartFile file) {\n\n if (!file.isEmpty()) {\n byte[] bytes = file.getBytes();\n // store the bytes somewhere\n return \"redirect:uploadSuccess\";\n }\n return \"redirect:uploadFailure\";\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tclass FileUploadController {\n\n @PostMapping(\"/form\")\n fun handleFormUpload(@RequestParam(\"name\") name: String,\n @RequestParam(\"file\") file: MultipartFile): String {\n\n if (!file.isEmpty) {\n val bytes = file.bytes\n // store the bytes somewhere\n return \"redirect:uploadSuccess\"\n }\n return \"redirect:uploadFailure\"\n }\n\t}\n----\n======\n\nDeclaring the argument type as a `List<MultipartFile>` allows for resolving multiple\nfiles for the same parameter name.\n\nWhen the `@RequestParam` annotation is declared as a `Map<String, MultipartFile>` or\n`MultiValueMap<String, MultipartFile>`, without a parameter name specified in the annotation,\nthen the map is populated with the multipart files for each given parameter name.\n\nNOTE: With Servlet multipart parsing, you may also declare `jakarta.servlet.http.Part`\ninstead of Spring's `MultipartFile`, as a method argument or collection value type.\n\nYou can also use multipart content as part of data binding to a\nxref:web/webmvc/mvc-controller/ann-methods/modelattrib-method-args.adoc[command object]. For example, the form field\nand file from the preceding example could be fields on a form object,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MyForm {\n\n private String name;\n\n private MultipartFile file;\n\n // ...\n\t}\n\n\t@Controller\n\tpublic class FileUploadController {\n\n @PostMapping(\"/form\")\n public String handleFormUpload(MyForm form, BindingResult errors) {\n if (!form.getFile().isEmpty()) {\n byte[] bytes = form.getFile().getBytes();\n // store the bytes somewhere\n return \"redirect:uploadSuccess\";\n }\n return \"redirect:uploadFailure\";\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass MyForm(val name: String, val file: MultipartFile, ...)\n\n\t@Controller\n\tclass FileUploadController {\n\n @PostMapping(\"/form\")\n fun handleFormUpload(form: MyForm, errors: BindingResult): String {\n if (!form.file.isEmpty) {\n val bytes = form.file.bytes\n // store the bytes somewhere\n return \"redirect:uploadSuccess\"\n }\n return \"redirect:uploadFailure\"\n }\n\t}\n----\n======\n\nMultipart requests can also be submitted from non-browser clients in a RESTful service\nscenario. The following example shows a file with JSON:\n\n[literal,subs=\"verbatim,quotes\"]\n----\nPOST /someUrl\nContent-Type: multipart/mixed\n\n--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp\nContent-Disposition: form-data; name=\"meta-data\"\nContent-Type: application/json; charset=UTF-8\nContent-Transfer-Encoding: 8bit\n\n{\n\t\"name\": \"value\"\n}\n--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp\nContent-Disposition: form-data; name=\"file-data\"; filename=\"file.properties\"\nContent-Type: text/xml\nContent-Transfer-Encoding: 8bit\n... File Data ...\n----\n\nYou can access the \"meta-data\" part with `@RequestParam` as a `String` but you'll\nprobably want it deserialized from JSON (similar to `@RequestBody`). Use the\n`@RequestPart` annotation to access a multipart after converting it with an\nxref:integration/rest-clients.adoc#rest-message-conversion[HttpMessageConverter]:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/\")\n\tpublic String handle(@RequestPart(\"meta-data\") MetaData metadata,\n @RequestPart(\"file-data\") MultipartFile file) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/\")\n\tfun handle(@RequestPart(\"meta-data\") metadata: MetaData,\n @RequestPart(\"file-data\") file: MultipartFile): String {\n // ...\n\t}\n----\n======\n\nYou can use `@RequestPart` in combination with `jakarta.validation.Valid` or use Spring's\n`@Validated` annotation, both of which cause Standard Bean Validation to be applied.\nBy default, validation errors cause a `MethodArgumentNotValidException`, which is turned\ninto a 400 (BAD_REQUEST) response. Alternatively, you can handle validation errors locally\nwithin the controller through an `Errors` or `BindingResult` argument,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/\")\n\tpublic String handle(@Valid @RequestPart(\"meta-data\") MetaData metadata, Errors errors) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/\")\n\tfun handle(@Valid @RequestPart(\"meta-data\") metadata: MetaData, errors: Errors): String {\n // ...\n\t}\n----\n======\n\nIf method validation applies because other parameters have `@Constraint` annotations,\nthen `HandlerMethodValidationException` is raised instead. For more details, see the\nsection on xref:web/webmvc/mvc-controller/ann-validation.adoc[Validation].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/multipart-forms.adoc", "title": "multipart-forms", "heading": "multipart-forms", "heading_level": 1, "file_order": 350, "section_index": 0, "content_hash": "9d29e6e9c67780ebb668d0dd7df06ae52ad5f410eb8825ec7e944d6f8d933b1c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/multipart-forms.adoc"}}
{"id": "sha256:6645c9c227da7d0d212d257da51428e569fb217b323ca5b34c2b80871d85ff64", "content": "[[mvc-redirecting-passing-data]]\n\nBy default, all model attributes are considered to be exposed as URI template variables in\nthe redirect URL. Of the remaining attributes, those that are primitive types or\ncollections or arrays of primitive types are automatically appended as query parameters.\n\nAppending primitive type attributes as query parameters can be the desired result if a\nmodel instance was prepared specifically for the redirect. However, in annotated\ncontrollers, the model can contain additional attributes added for rendering purposes (for example,\ndrop-down field values). To avoid the possibility of having such attributes appear in the\nURL, a `@RequestMapping` method can declare an argument of type `RedirectAttributes` and\nuse it to specify the exact attributes to make available to `RedirectView`. If the method\ndoes redirect, the content of `RedirectAttributes` is used. Otherwise, the content of the\nmodel is used.\n\nThe `RequestMappingHandlerAdapter` provides a flag called\n`ignoreDefaultModelOnRedirect`, which you can use to indicate that the content of the default\n`Model` should never be used if a controller method redirects. Instead, the controller\nmethod should declare an attribute of type `RedirectAttributes` or, if it does not do so,\nno attributes should be passed on to `RedirectView`. Both the MVC namespace and the MVC\nJava configuration keep this flag set to `false`, to maintain backwards compatibility.\nHowever, for new applications, we recommend setting it to `true`.\n\nNote that URI template variables from the present request are automatically made\navailable when expanding a redirect URL, and you don't need to explicitly add them\nthrough `Model` or `RedirectAttributes`. The following example shows how to define a redirect:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/files/{path}\")\n\tpublic String upload(...) {\n // ...\n return \"redirect:files/{path}\";\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/files/{path}\")\n\tfun upload(...): String {\n // ...\n return \"redirect:files/{path}\"\n\t}\n----\n======\n\nAnother way of passing data to the redirect target is by using flash attributes. Unlike other\nredirect attributes, flash attributes are saved in the HTTP session (and, hence, do not appear\nin the URL). See xref:web/webmvc/mvc-controller/ann-methods/flash-attributes.adoc[Flash Attributes]\nfor more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/redirecting-passing-data.adoc", "title": "redirecting-passing-data", "heading": "redirecting-passing-data", "heading_level": 1, "file_order": 351, "section_index": 0, "content_hash": "6645c9c227da7d0d212d257da51428e569fb217b323ca5b34c2b80871d85ff64", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/redirecting-passing-data.adoc"}}
{"id": "sha256:ba4a0a28534263ccec093a2a6be7fc43167caf88e937729a9945ce7a818fd44c", "content": "[[mvc-ann-requestattrib]]\n\n[.small]#xref:web/webflux/controller/ann-methods/requestattrib.adoc[See equivalent in the Reactive stack]#\n\nSimilar to `@SessionAttribute`, you can use the `@RequestAttribute` annotations to\naccess pre-existing request attributes created earlier (for example, by a Servlet `Filter`\nor `HandlerInterceptor`):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/\")\n\tpublic String handle(@RequestAttribute Client client) { // <1>\n // ...\n\t}\n----\n<1> Using the `@RequestAttribute` annotation.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/\")\n\tfun handle(@RequestAttribute client: Client): String { // <1>\n // ...\n\t}\n----\n<1> Using the `@RequestAttribute` annotation.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/requestattrib.adoc", "title": "requestattrib", "heading": "requestattrib", "heading_level": 1, "file_order": 352, "section_index": 0, "content_hash": "ba4a0a28534263ccec093a2a6be7fc43167caf88e937729a9945ce7a818fd44c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/requestattrib.adoc"}}
{"id": "sha256:805c0cd6a621311f6889d515d7b0e17cd2eafb43291822710f6a0ca8c7fbbe2a", "content": "[[mvc-ann-requestbody]]\n\n[.small]#xref:web/webflux/controller/ann-methods/requestbody.adoc[See equivalent in the Reactive stack]#\n\nYou can use the `@RequestBody` annotation to have the request body read and deserialized into an\n`Object` through an xref:integration/rest-clients.adoc#rest-message-conversion[`HttpMessageConverter`].\nThe following example uses a `@RequestBody` argument:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tpublic void handle(@RequestBody Account account) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tfun handle(@RequestBody account: Account) {\n // ...\n\t}\n----\n======\n\nYou can use the\nxref:web/webmvc/mvc-config/message-converters.adoc[Message Converters] option of the xref:web/webmvc/mvc-config.adoc[MVC Config]\nto configure or customize message conversion.\n\nNOTE: Form data should be read using xref:web/webmvc/mvc-controller/ann-methods/requestparam.adoc[`@RequestParam`],\nnot with `@RequestBody` which can't always be used reliably since in the Servlet API, request parameter\naccess causes the request body to be parsed, and it can't be read again.\n\nYou can use `@RequestBody` in combination with `jakarta.validation.Valid` or Spring's\n`@Validated` annotation, both of which cause Standard Bean Validation to be applied.\nBy default, validation errors cause a `MethodArgumentNotValidException`, which is turned\ninto a 400 (BAD_REQUEST) response. Alternatively, you can handle validation errors locally\nwithin the controller through an `Errors` or `BindingResult` argument,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tpublic void handle(@Valid @RequestBody Account account, Errors errors) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/accounts\")\n\tfun handle(@Valid @RequestBody account: Account, errors: Errors) {\n // ...\n\t}\n----\n======\n\nIf method validation applies because other parameters have `@Constraint` annotations,\nthen `HandlerMethodValidationException` is raised instead. For more details, see the\nsection on xref:web/webmvc/mvc-controller/ann-validation.adoc[Validation].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/requestbody.adoc", "title": "requestbody", "heading": "requestbody", "heading_level": 1, "file_order": 353, "section_index": 0, "content_hash": "805c0cd6a621311f6889d515d7b0e17cd2eafb43291822710f6a0ca8c7fbbe2a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/requestbody.adoc"}}
{"id": "sha256:10d9e3ea12421af140404393f9cec2882bbc07b0efef942178adb0ea798ae714", "content": "[[mvc-ann-requestheader]]\n\n[.small]#xref:web/webflux/controller/ann-methods/requestheader.adoc[See equivalent in the Reactive stack]#\n\nYou can use the `@RequestHeader` annotation to bind a request header to a method argument in a\ncontroller.\n\nConsider the following request, with headers:\n\n[literal]\n[subs=\"verbatim,quotes\"]\n----\nHost localhost:8080\nAccept text/html,application/xhtml+xml,application/xml;q=0.9\nAccept-Language fr,en-gb;q=0.7,en;q=0.3\nAccept-Encoding gzip,deflate\nAccept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7\nKeep-Alive 300\n----\n\nThe following example gets the value of the `Accept-Encoding` and `Keep-Alive` headers:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/demo\")\n\tpublic void handle(\n @RequestHeader(\"Accept-Encoding\") String encoding, // <1>\n @RequestHeader(\"Keep-Alive\") long keepAlive) { // <2>\n //...\n\t}\n----\n<1> Get the value of the `Accept-Encoding` header.\n<2> Get the value of the `Keep-Alive` header.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/demo\")\n\tfun handle(\n @RequestHeader(\"Accept-Encoding\") encoding: String, // <1>\n @RequestHeader(\"Keep-Alive\") keepAlive: Long) { // <2>\n //...\n\t}\n----\n<1> Get the value of the `Accept-Encoding` header.\n<2> Get the value of the `Keep-Alive` header.\n======\n\nIf the target method parameter type is not `String`, type conversion is automatically applied.\nSee xref:web/webmvc/mvc-controller/ann-methods/typeconversion.adoc[Type Conversion].\n\nWhen an `@RequestHeader` annotation is used on a `Map<String, String>`,\n`MultiValueMap<String, String>`, or `HttpHeaders` argument, the map is populated\nwith all header values.\n\nTIP: Built-in support is available for converting a comma-separated string into an\narray or collection of strings or other types known to the type conversion system. For\nexample, a method parameter annotated with `@RequestHeader(\"Accept\")` can be of type\n`String` but also `String[]` or `List<String>`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/requestheader.adoc", "title": "requestheader", "heading": "requestheader", "heading_level": 1, "file_order": 354, "section_index": 0, "content_hash": "10d9e3ea12421af140404393f9cec2882bbc07b0efef942178adb0ea798ae714", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/requestheader.adoc"}}
{"id": "sha256:a00c1871275975d4bf26acd9f42513a866f2ccc844af5fbf156da78821ba627c", "content": "[[mvc-ann-requestparam]]\n\n[.small]#xref:web/webflux/controller/ann-methods/requestparam.adoc[See equivalent in the Reactive stack]#\n\nYou can use the `@RequestParam` annotation to bind Servlet request parameters (that is,\nquery parameters or form data) to a method argument in a controller.\n\nThe following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@RequestMapping(\"/pets\")\n\tpublic class EditPetForm {\n\n // ...\n\n @GetMapping\n public String setupForm(@RequestParam(\"petId\") int petId, Model model) { <1>\n Pet pet = this.clinic.loadPet(petId);\n model.addAttribute(\"pet\", pet);\n return \"petForm\";\n }\n\n // ...\n\n\t}\n----\n<1> Using `@RequestParam` to bind `petId`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.ui.set\n\n\t@Controller\n\t@RequestMapping(\"/pets\")\n\tclass EditPetForm {\n\n // ...\n\n @GetMapping\n fun setupForm(@RequestParam(\"petId\") petId: Int, model: Model): String { // <1>\n val pet = this.clinic.loadPet(petId);\n model[\"pet\"] = pet\n return \"petForm\"\n }\n\n // ...\n\n\t}\n----\n<1> Using `@RequestParam` to bind `petId`.\n======\n\nBy default, method parameters that use this annotation are required, but you can specify that\na method parameter is optional by setting the `@RequestParam` annotation's `required` flag to\n`false` or by declaring the argument with a `java.util.Optional` wrapper.\n\nType conversion is automatically applied if the target method parameter type is not\n`String`. See xref:web/webmvc/mvc-controller/ann-methods/typeconversion.adoc[Type Conversion].\n\nDeclaring the argument type as an array or list allows for resolving multiple parameter\nvalues for the same parameter name.\n\nWhen an `@RequestParam` annotation is declared as a `Map<String, String>` or\n`MultiValueMap<String, String>`, without a parameter name specified in the annotation,\nthen the map is populated with the request parameter values for each given parameter name.\nThe following example shows how to do so with form data processing:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@RequestMapping(\"/pets\")\n\tclass EditPetForm {\n\n // ...\n\n @PostMapping(path = \"/process\", consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n public String processForm(@RequestParam MultiValueMap<String, String> params) {\n // ...\n }\n\n // ...\n\t}\n----\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@RequestMapping(\"/pets\")\n\tclass EditPetForm {\n\n // ...\n\n @PostMapping(\"/process\", consumes = [MediaType.APPLICATION_FORM_URLENCODED_VALUE])\n fun processForm(@RequestParam params: MultiValueMap<String, String>): String {\n // ...\n }\n\n // ...\n\n\t}\n----\n======\n\nNote that use of `@RequestParam` is optional (for example, to set its attributes).\nBy default, any argument that is a simple value type (as determined by\n{spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty])\nand is not resolved by any other argument resolver, is treated as if it were annotated\nwith `@RequestParam`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/requestparam.adoc", "title": "requestparam", "heading": "requestparam", "heading_level": 1, "file_order": 355, "section_index": 0, "content_hash": "a00c1871275975d4bf26acd9f42513a866f2ccc844af5fbf156da78821ba627c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/requestparam.adoc"}}
{"id": "sha256:7ed76549b1d65d74e5f15bcb6709001c78ade3215a1e6c921a7a214066a8fda5", "content": "[[mvc-ann-responsebody]]\n\n[.small]#xref:web/webflux/controller/ann-methods/responsebody.adoc[See equivalent in the Reactive stack]#\n\nYou can use the `@ResponseBody` annotation on a method to have the return serialized\nto the response body through an\nxref:integration/rest-clients.adoc#rest-message-conversion[HttpMessageConverter].\nThe following listing shows an example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/accounts/{id}\")\n\t@ResponseBody\n\tpublic Account handle() {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/accounts/{id}\")\n\t@ResponseBody\n\tfun handle(): Account {\n // ...\n\t}\n----\n======\n\n`@ResponseBody` is also supported at the class level, in which case it is inherited by\nall controller methods. This is the effect of `@RestController`, which is nothing more\nthan a meta-annotation marked with `@Controller` and `@ResponseBody`.\n\nA `Resource` object can be returned for file content, copying the `InputStream`\ncontent of the provided resource to the response `OutputStream`. Note that the\n`InputStream` should be lazily retrieved by the `Resource` handle in order to reliably\nclose it after it has been copied to the response. If you are using `InputStreamResource`\nfor such a purpose, make sure to construct it with an on-demand `InputStreamSource`\n(for example, through a lambda expression that retrieves the actual `InputStream`).\n\nYou can use `@ResponseBody` with reactive types.\nSee xref:web/webmvc/mvc-ann-async.adoc[Asynchronous Requests] and\nxref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-reactive-types[Reactive Types] for more details.\n\nYou can use the xref:web/webmvc/mvc-config/message-converters.adoc[Message Converters] option\nof the xref:web/webmvc/mvc-config.adoc[MVC Config] to configure or customize message conversion.\n\nYou can combine `@ResponseBody` methods with JSON serialization views.\nSee xref:web/webmvc/mvc-controller/ann-methods/jackson.adoc[Jackson JSON] for details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/responsebody.adoc", "title": "responsebody", "heading": "responsebody", "heading_level": 1, "file_order": 356, "section_index": 0, "content_hash": "7ed76549b1d65d74e5f15bcb6709001c78ade3215a1e6c921a7a214066a8fda5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/responsebody.adoc"}}
{"id": "sha256:a333640ad6f141e402750f94c3e8c95643f78b1e435efd25c564c887950868a2", "content": "[[mvc-ann-responseentity]]\n\n[.small]#xref:web/webflux/controller/ann-methods/responseentity.adoc[See equivalent in the Reactive stack]#\n\n`ResponseEntity` is like xref:web/webmvc/mvc-controller/ann-methods/responsebody.adoc[`@ResponseBody`]\nbut with status and headers. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/something\")\n\tpublic ResponseEntity<String> handle() {\n String body = ... ;\n String etag = ... ;\n return ResponseEntity.ok().eTag(etag).body(body);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/something\")\n\tfun handle(): ResponseEntity<String> {\n val body = ...\n val etag = ...\n return ResponseEntity.ok().eTag(etag).build(body)\n\t}\n----\n======\n\nThe body will usually be provided as a value object to be rendered to a corresponding\nresponse representation (for example, JSON) by one of the registered `HttpMessageConverters`.\n\nA `ResponseEntity<Resource>` can be returned for file content, copying the `InputStream`\ncontent of the provided resource to the response `OutputStream`. Note that the\n`InputStream` should be lazily retrieved by the `Resource` handle in order to reliably\nclose it after it has been copied to the response. If you are using `InputStreamResource`\nfor such a purpose, make sure to construct it with an on-demand `InputStreamSource`\n(for example, through a lambda expression that retrieves the actual `InputStream`). Also, custom\nsubclasses of `InputStreamResource` are only supported in combination with a custom\n`contentLength()` implementation which avoids consuming the stream for that purpose.\n\nSpring MVC supports using a single value xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-reactive-types[reactive type]\nto produce the `ResponseEntity` asynchronously, and/or single and multi-value reactive\ntypes for the body. This allows the following types of async responses:\n\n* `ResponseEntity<Mono<T>>` or `ResponseEntity<Flux<T>>` make the response status and\n headers known immediately while the body is provided asynchronously at a later point.\n Use `Mono` if the body consists of 0..1 values or `Flux` if it can produce multiple values.\n* `Mono<ResponseEntity<T>>` provides all three -- response status, headers, and body,\n asynchronously at a later point. This allows the response status and headers to vary\n depending on the outcome of asynchronous request handling.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/responseentity.adoc", "title": "responseentity", "heading": "responseentity", "heading_level": 1, "file_order": 357, "section_index": 0, "content_hash": "a333640ad6f141e402750f94c3e8c95643f78b1e435efd25c564c887950868a2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/responseentity.adoc"}}
{"id": "sha256:694ea80465729d0d57c35e81986791c09a3fa542028ff7db95628ac6fba1b5ed", "content": "[[mvc-ann-return-types]]\n\n[.small]#xref:web/webflux/controller/ann-methods/return-types.adoc[See equivalent in the Reactive stack]#\n\nThe next table describes the supported controller method return values. Reactive types are\nsupported for all return values.\n\n[cols=\"1,2\", options=\"header\"]\n|===\n| Controller method return value | Description\n\n| `@ResponseBody`\n| The return value is converted through `HttpMessageConverter` implementations and written to the\n response. See xref:web/webmvc/mvc-controller/ann-methods/responsebody.adoc[`@ResponseBody`].\n\n| `HttpEntity<B>`, `ResponseEntity<B>`\n| The return value that specifies the full response (including HTTP headers and body) is to be converted\n through `HttpMessageConverter` implementations and written to the response.\n See xref:web/webmvc/mvc-controller/ann-methods/responseentity.adoc[ResponseEntity].\n\n| `HttpHeaders`\n| For returning a response with headers and no body.\n\n| `ErrorResponse`, `ProblemDetail`\n| To render an RFC 9457 error response with details in the body,\n see xref:web/webmvc/mvc-ann-rest-exceptions.adoc[Error Responses]\n\n| `String`\n| A view name to be resolved with `ViewResolver` implementations and used together with the implicit\n model -- determined through command objects and `@ModelAttribute` methods. The handler\n method can also programmatically enrich the model by declaring a `Model` argument\n (see xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-registration[Explicit Registrations]).\n\n| `View`\n| A `View` instance to use for rendering together with the implicit model -- determined\n through command objects and `@ModelAttribute` methods. The handler method can also\n programmatically enrich the model by declaring a `Model` argument\n (see xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-registration[Explicit Registrations]).\n\n| `java.util.Map`, `org.springframework.ui.Model`\n| Attributes to be added to the implicit model, with the view name implicitly determined\n through a `RequestToViewNameTranslator`.\n\n| `@ModelAttribute`\n| An attribute to be added to the model, with the view name implicitly determined through\n a `RequestToViewNameTranslator`.\n\n Note that `@ModelAttribute` is optional. See \"Any other return value\" at the end of\n this table.\n\n| `ModelAndView` object\n| The view and model attributes to use and, optionally, a response status.\n\n| `FragmentsRendering`, `Collection<ModelAndView>`\n| For rendering one or more fragments each with its own view and model.\n See xref:web/webmvc-view/mvc-fragments.adoc[HTML Fragments] for more details.\n\n| `void`\n| A method with a `void` return type (or `null` return value) is considered to have fully\n handled the response if it also has a `ServletResponse`, an `OutputStream` argument, or\n an `@ResponseStatus` annotation. The same is also true if the controller has made a positive\n `ETag` or `lastModified` timestamp check (see xref:web/webmvc/mvc-caching.adoc#mvc-caching-etag-lastmodified[Controllers] for details).\n\n If none of the above is true, a `void` return type can also indicate \"`no response body`\" for\n REST controllers or a default view name selection for HTML controllers.\n\n| `DeferredResult<V>`\n| Produce any of the preceding return values asynchronously from any thread -- for example, as a\n result of some event or callback. See xref:web/webmvc/mvc-ann-async.adoc[Asynchronous Requests] and xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-deferredresult[`DeferredResult`].\n\n| `Callable<V>`\n| Produce any of the above return values asynchronously in a Spring MVC-managed thread.\n See xref:web/webmvc/mvc-ann-async.adoc[Asynchronous Requests] and xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-callable[`Callable`].\n\n| `ListenableFuture<V>`,\n `java.util.concurrent.CompletionStage<V>`,\n `java.util.concurrent.CompletableFuture<V>`\n| Alternative to `DeferredResult`, as a convenience (for example, when an underlying service\n returns one of those).\n\n| `ResponseBodyEmitter`, `SseEmitter`\n| Emit a stream of objects asynchronously to be written to the response with\n `HttpMessageConverter` implementations. Also supported as the body of a `ResponseEntity`.\n See xref:web/webmvc/mvc-ann-async.adoc[Asynchronous Requests] and xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-http-streaming[HTTP Streaming].\n\n| `StreamingResponseBody`\n| Write to the response `OutputStream` asynchronously. Also supported as the body of a\n `ResponseEntity`. See xref:web/webmvc/mvc-ann-async.adoc[Asynchronous Requests] and xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-http-streaming[HTTP Streaming].\n\n| Reactor and other reactive types registered via `ReactiveAdapterRegistry`\n| A single value type, for example, `Mono`, is comparable to returning `DeferredResult`.\n A multi-value type, for example, `Flux`, may be treated as a stream depending on the requested\n media type, for example, \"text/event-stream\", \"application/json+stream\", or otherwise is\n collected to a List and rendered as a single value. See xref:web/webmvc/mvc-ann-async.adoc[Asynchronous Requests] and\n xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-reactive-types[Reactive Types].\n\n| Other return values\n| If a return value remains unresolved in any other way, it is treated as a model\n attribute, unless it is a simple type as determined by\n {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty],\n in which case it remains unresolved.\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/return-types.adoc", "title": "return-types", "heading": "return-types", "heading_level": 1, "file_order": 358, "section_index": 0, "content_hash": "694ea80465729d0d57c35e81986791c09a3fa542028ff7db95628ac6fba1b5ed", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/return-types.adoc"}}
{"id": "sha256:bca459c540a0790ee6182b2ff46578b520c70a1838ab064c77b37ee6909067b8", "content": "[[mvc-ann-sessionattribute]]\n\n[.small]#xref:web/webflux/controller/ann-methods/sessionattribute.adoc[See equivalent in the Reactive stack]#\n\nIf you need access to pre-existing session attributes that are managed globally\n(that is, outside the controller -- for example, by a filter) and may or may not be present,\nyou can use the `@SessionAttribute` annotation on a method parameter,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RequestMapping(\"/\")\n\tpublic String handle(@SessionAttribute User user) { <1>\n // ...\n\t}\n----\n<1> Using a `@SessionAttribute` annotation.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RequestMapping(\"/\")\n\tfun handle(@SessionAttribute user: User): String { // <1>\n // ...\n\t}\n----\n<1> Using a `@SessionAttribute` annotation.======\n======\n\nFor use cases that require adding or removing session attributes, consider injecting\n`org.springframework.web.context.request.WebRequest` or\n`jakarta.servlet.http.HttpSession` into the controller method.\n\nFor temporary storage of model attributes in the session as part of a controller\nworkflow, consider using `@SessionAttributes` as described in\nxref:web/webmvc/mvc-controller/ann-methods/sessionattributes.adoc[`@SessionAttributes`].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/sessionattribute.adoc", "title": "sessionattribute", "heading": "sessionattribute", "heading_level": 1, "file_order": 359, "section_index": 0, "content_hash": "bca459c540a0790ee6182b2ff46578b520c70a1838ab064c77b37ee6909067b8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/sessionattribute.adoc"}}
{"id": "sha256:a46204663ce2553faf78a35e42e0f28a1781dc52b083fec2773c9471a0328342", "content": "[[mvc-ann-sessionattributes]]\n\n[.small]#xref:web/webflux/controller/ann-methods/sessionattributes.adoc[See equivalent in the Reactive stack]#\n\n`@SessionAttributes` is used to store model attributes in the HTTP Servlet session between\nrequests. It is a type-level annotation that declares the session attributes used by a\nspecific controller. This typically lists the names of model attributes or types of\nmodel attributes that should be transparently stored in the session for subsequent\nrequests to access.\n\nThe following example uses the `@SessionAttributes` annotation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@SessionAttributes(\"pet\") // <1>\n\tpublic class EditPetForm {\n // ...\n\t}\n----\n<1> Using the `@SessionAttributes` annotation.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@SessionAttributes(\"pet\") // <1>\n\tclass EditPetForm {\n // ...\n\t}\n----\n<1> Using the `@SessionAttributes` annotation.\n======\n\nOn the first request, when a model attribute with the name, `pet`, is added to the model,\nit is automatically promoted to and saved in the HTTP Servlet session. It remains there\nuntil another controller method uses a `SessionStatus` method argument to clear the\nstorage, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@SessionAttributes(\"pet\") // <1>\n\tpublic class EditPetForm {\n\n // ...\n\n @PostMapping(\"/pets/{id}\")\n public String handle(Pet pet, BindingResult errors, SessionStatus status) {\n if (errors.hasErrors) {\n // ...\n }\n status.setComplete(); // <2>\n // ...\n }\n\t}\n----\n<1> Storing the `Pet` value in the Servlet session.\n<2> Clearing the `Pet` value from the Servlet session.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n@Controller\n@SessionAttributes(\"pet\") // <1>\nclass EditPetForm {\n\n\t// ...\n\n\t@PostMapping(\"/pets/{id}\")\n\tfun handle(pet: Pet, errors: BindingResult, status: SessionStatus): String {\n if (errors.hasErrors()) {\n // ...\n }\n status.setComplete() // <2>\n // ...\n\t}\n}\n----\n<1> Storing the `Pet` value in the Servlet session.\n<2> Clearing the `Pet` value from the Servlet session.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/sessionattributes.adoc", "title": "sessionattributes", "heading": "sessionattributes", "heading_level": 1, "file_order": 360, "section_index": 0, "content_hash": "a46204663ce2553faf78a35e42e0f28a1781dc52b083fec2773c9471a0328342", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/sessionattributes.adoc"}}
{"id": "sha256:f3c0ea47d44e746d3d74bfe6b2bacfa27c4a8e713e24846bf881f842eb9caed4", "content": "[[mvc-ann-typeconversion]]\n\n[.small]#xref:web/webflux/controller/ann-methods/typeconversion.adoc[See equivalent in the Reactive stack]#\n\nSome annotated controller method arguments that represent `String`-based request input (such as\n`@RequestParam`, `@RequestHeader`, `@PathVariable`, `@MatrixVariable`, and `@CookieValue`)\ncan require type conversion if the argument is declared as something other than `String`.\n\nFor such cases, type conversion is automatically applied based on the configured converters.\nBy default, simple types (`int`, `long`, `Date`, and others) are supported. You can customize\ntype conversion through a `WebDataBinder` (see xref:web/webmvc/mvc-controller/ann-initbinder.adoc[`DataBinder`]) or by registering\n`Formatters` with the `FormattingConversionService`.\nSee xref:core/validation/format.adoc[Spring Field Formatting].\n\nA practical issue in type conversion is the treatment of an empty String source value.\nSuch a value is treated as missing if it becomes `null` as a result of type conversion.\nThis can be the case for `Long`, `UUID`, and other target types. If you want to allow `null`\nto be injected, either use the `required` flag on the argument annotation, or declare the\nargument as `@Nullable`.\n\n[NOTE]\n====\nAs of 5.3, non-null arguments will be enforced even after type conversion. If your handler\nmethod intends to accept a null value as well, either declare your argument as `@Nullable`\nor mark it as `required=false` in the corresponding `@RequestParam`, etc. annotation. This is\na best practice and the recommended solution for regressions encountered in a 5.3 upgrade.\n\nAlternatively, you may specifically handle, for example, the resulting `MissingPathVariableException`\nin the case of a required `@PathVariable`. A null value after conversion will be treated like\nan empty original value, so the corresponding `Missing...Exception` variants will be thrown.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/typeconversion.adoc", "title": "typeconversion", "heading": "typeconversion", "heading_level": 1, "file_order": 361, "section_index": 0, "content_hash": "f3c0ea47d44e746d3d74bfe6b2bacfa27c4a8e713e24846bf881f842eb9caed4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods/typeconversion.adoc"}}
{"id": "sha256:40994cf6237d2695a725bbd4c230b665e20c86702fa767e6cc129e3fd8c14fa1", "content": "[[mvc-ann-controller-advice]]\n\n[.small]#xref:web/webflux/controller/ann-advice.adoc[See equivalent in the Reactive stack]#\n\n`@ExceptionHandler`, `@InitBinder`, and `@ModelAttribute` methods apply only to the\n`@Controller` class, or class hierarchy, in which they are declared. If, instead, they\nare declared in an `@ControllerAdvice` or `@RestControllerAdvice` class, then they apply\nto any controller. Moreover, as of 5.3, `@ExceptionHandler` methods in `@ControllerAdvice`\ncan be used to handle exceptions from any `@Controller` or any other handler.\n\n`@ControllerAdvice` is meta-annotated with `@Component` and therefore can be registered as\na Spring bean through xref:core/beans/java/instantiating-container.adoc#beans-java-instantiating-container-scan[component scanning].\n\n`@RestControllerAdvice` is a shortcut annotation that combines `@ControllerAdvice`\nwith `@ResponseBody`, in effect simply an `@ControllerAdvice` whose exception handler\nmethods render to the response body.\n\nOn startup, `RequestMappingHandlerMapping` and `ExceptionHandlerExceptionResolver` detect\ncontroller advice beans and apply them at runtime. Global `@ExceptionHandler` methods,\nfrom an `@ControllerAdvice`, are applied _after_ local ones, from the `@Controller`.\nBy contrast, global `@ModelAttribute` and `@InitBinder` methods are applied _before_ local ones.\n\nBy default, both `@ControllerAdvice` and `@RestControllerAdvice` apply to any controller,\nincluding `@Controller` and `@RestController`. Use attributes of the annotation to narrow\nthe set of controllers and handlers that they apply to. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Target all Controllers annotated with @RestController\n\t@ControllerAdvice(annotations = RestController.class)\n\tpublic class ExampleAdvice1 {}\n\n\t// Target all Controllers within specific packages\n\t@ControllerAdvice(\"org.example.controllers\")\n\tpublic class ExampleAdvice2 {}\n\n\t// Target all Controllers assignable to specific classes\n\t@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})\n\tpublic class ExampleAdvice3 {}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Target all Controllers annotated with @RestController\n\t@ControllerAdvice(annotations = [RestController::class])\n\tclass ExampleAdvice1\n\n\t// Target all Controllers within specific packages\n\t@ControllerAdvice(\"org.example.controllers\")\n\tclass ExampleAdvice2\n\n\t// Target all Controllers assignable to specific classes\n\t@ControllerAdvice(assignableTypes = [ControllerInterface::class, AbstractController::class])\n\tclass ExampleAdvice3\n----\n======\n\nThe selectors in the preceding example are evaluated at runtime and may negatively impact\nperformance if used extensively. See the\n{spring-framework-api}/web/bind/annotation/ControllerAdvice.html[`@ControllerAdvice`]\njavadoc for more details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-advice.adoc", "title": "ann-advice", "heading": "ann-advice", "heading_level": 1, "file_order": 362, "section_index": 0, "content_hash": "40994cf6237d2695a725bbd4c230b665e20c86702fa767e6cc129e3fd8c14fa1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-advice.adoc"}}
{"id": "sha256:ded7bd68d249e6470579fdf0e7b6700ee0febdc0ebb3c9b57ef48bebf3066dd2", "content": "[[mvc-ann-exceptionhandler]]\n\n[.small]#xref:web/webflux/controller/ann-exceptions.adoc[See equivalent in the Reactive stack]#\n\n`@Controller` and xref:web/webmvc/mvc-controller/ann-advice.adoc[@ControllerAdvice] classes can have\n`@ExceptionHandler` methods to handle exceptions from controller methods, as the following example shows:\n\ninclude-code::./SimpleController[indent=0]\n\n[[mvc-ann-exceptionhandler-exc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-exceptionhandler.adoc", "title": "ann-exceptionhandler", "heading": "ann-exceptionhandler", "heading_level": 1, "file_order": 363, "section_index": 0, "content_hash": "ded7bd68d249e6470579fdf0e7b6700ee0febdc0ebb3c9b57ef48bebf3066dd2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-exceptionhandler.adoc"}}
{"id": "sha256:b9446c534cd1090408f36815e7aae6c47eba1686e6a90381cf2105e5206dc617", "content": "The exception may match against a top-level exception being propagated (for example, a direct\n`IOException` being thrown) or against a nested cause within a wrapper exception (for example,\nan `IOException` wrapped inside an `IllegalStateException`). As of 5.3, this can match\nat arbitrary cause levels, whereas previously only an immediate cause was considered.\n\nFor matching exception types, preferably declare the target exception as a method argument,\nas the preceding example shows. When multiple exception methods match, a root exception match is\ngenerally preferred to a cause exception match. More specifically, the `ExceptionDepthComparator`\nis used to sort exceptions based on their depth from the thrown exception type.\n\nAlternatively, the annotation declaration may narrow the exception types to match,\nas the following example shows:\n\ninclude-code::./ExceptionController[tag=narrow,indent=0]\n\nYou can even use a list of specific exception types with a very generic argument signature,\nas the following example shows:\n\ninclude-code::./ExceptionController[tag=general,indent=0]\n\n[NOTE]\n====\nThe distinction between root and cause exception matching can be surprising.\n\nIn the `IOException` variant shown earlier, the method is typically called with\nthe actual `FileSystemException` or `RemoteException` instance as the argument,\nsince both of them extend from `IOException`. However, if any such matching\nexception is propagated within a wrapper exception which is itself an `IOException`,\nthe passed-in exception instance is that wrapper exception.\n\nThe behavior is even simpler in the `handle(Exception)` variant. This is\nalways invoked with the wrapper exception in a wrapping scenario, with the\nactually matching exception to be found through `ex.getCause()` in that case.\nThe passed-in exception is the actual `FileSystemException` or\n`RemoteException` instance only when these are thrown as top-level exceptions.\n====\n\nWe generally recommend that you be as specific as possible in the argument signature,\nreducing the potential for mismatches between root and cause exception types.\nConsider breaking a multi-matching method into individual `@ExceptionHandler`\nmethods, each matching a single specific exception type through its signature.\n\nIn a multi-`@ControllerAdvice` arrangement, we recommend declaring your primary root exception\nmappings on a `@ControllerAdvice` prioritized with a corresponding order. While a root\nexception match is preferred to a cause, this is defined among the methods of a given\ncontroller or `@ControllerAdvice` class. This means a cause match on a higher-priority\n`@ControllerAdvice` bean is preferred to any match (for example, root) on a lower-priority\n`@ControllerAdvice` bean.\n\nLast but not least, an `@ExceptionHandler` method implementation can choose to back\nout of dealing with a given exception instance by rethrowing it in its original form.\nThis is useful in scenarios where you are interested only in root-level matches or in\nmatches within a specific context that cannot be statically determined. A rethrown\nexception is propagated through the remaining resolution chain, as though\nthe given `@ExceptionHandler` method would not have matched in the first place.\n\nSupport for `@ExceptionHandler` methods in Spring MVC is built on the `DispatcherServlet`\nlevel, xref:web/webmvc/mvc-servlet/exceptionhandlers.adoc[HandlerExceptionResolver] mechanism.\n\n[[mvc-ann-exceptionhandler-media]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-exceptionhandler.adoc", "title": "ann-exceptionhandler", "heading": "Exception Mapping", "heading_level": 2, "file_order": 363, "section_index": 1, "content_hash": "b9446c534cd1090408f36815e7aae6c47eba1686e6a90381cf2105e5206dc617", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-exceptionhandler.adoc"}}
{"id": "sha256:904f38de94f42505c6eede1c5772ee223f0aa0417646f346d3443a6b0b2a1813", "content": "[.small]#xref:web/webflux/controller/ann-exceptions.adoc#webflux-ann-exceptionhandler-media[See equivalent in the Reactive stack]#\n\nIn addition to exception types, `@ExceptionHandler` methods can also declare producible media types.\nThis allows to refine error responses depending on the media types requested by HTTP clients, typically in the \"Accept\" HTTP request header.\n\nApplications can declare producible media types directly on annotations, for the same exception type:\n\ninclude-code::./MediaTypeController[tag=mediatype,indent=0]\n\nHere, methods handle the same exception type but will not be rejected as duplicates.\nInstead, API clients requesting \"application/json\" will receive a JSON error, and browsers will get an HTML error view.\nEach `@ExceptionHandler` annotation can declare several producible media types,\nthe content negotiation during the error handling phase will decide which content type will be used.\n\n[[mvc-ann-exceptionhandler-args]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-exceptionhandler.adoc", "title": "ann-exceptionhandler", "heading": "Media Type Mapping", "heading_level": 2, "file_order": 363, "section_index": 2, "content_hash": "904f38de94f42505c6eede1c5772ee223f0aa0417646f346d3443a6b0b2a1813", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-exceptionhandler.adoc"}}
{"id": "sha256:b97bb8ebd27ce926d47645191ae90df21fb4a834007b6f5c8ea4d480d9b3d953", "content": "[.small]#xref:web/webflux/controller/ann-exceptions.adoc#webflux-ann-exceptionhandler-args[See equivalent in the Reactive stack]#\n\n`@ExceptionHandler` methods support the following arguments:\n\n[cols=\"1,2\", options=\"header\"]\n|===\n| Method argument | Description\n\n| Exception type\n| For access to the raised exception.\n\n| `HandlerMethod`\n| For access to the controller method that raised the exception.\n\n| `WebRequest`, `NativeWebRequest`\n| Generic access to request parameters and request and session attributes without direct\n use of the Servlet API.\n\n| `jakarta.servlet.ServletRequest`, `jakarta.servlet.ServletResponse`\n| Choose any specific request or response type (for example, `ServletRequest` or\n `HttpServletRequest` or Spring's `MultipartRequest` or `MultipartHttpServletRequest`).\n\n| `jakarta.servlet.http.HttpSession`\n| Enforces the presence of a session. As a consequence, such an argument is never `null`. +\n Note that session access is not thread-safe. Consider setting the\n `RequestMappingHandlerAdapter` instance's `synchronizeOnSession` flag to `true` if multiple\n requests are allowed to access a session concurrently.\n\n| `java.security.Principal`\n| Currently authenticated user -- possibly a specific `Principal` implementation class if known.\n\n| `HttpMethod`\n| The HTTP method of the request.\n\n| `java.util.Locale`\n| The current request locale, determined by the most specific `LocaleResolver` available -- in\n effect, the configured `LocaleResolver` or `LocaleContextResolver`.\n\n| `java.util.TimeZone`, `java.time.ZoneId`\n| The time zone associated with the current request, as determined by a `LocaleContextResolver`.\n\n| `java.io.OutputStream`, `java.io.Writer`\n| For access to the raw response body, as exposed by the Servlet API.\n\n| `java.util.Map`, `org.springframework.ui.Model`, `org.springframework.ui.ModelMap`\n| For access to the model for an error response. Always empty.\n\n| `RedirectAttributes`\n| Specify attributes to use in case of a redirect -- (that is to be appended to the query\n string) and flash attributes to be stored temporarily until the request after the redirect.\n See xref:web/webmvc/mvc-controller/ann-methods/redirecting-passing-data.adoc[Redirect Attributes] and xref:web/webmvc/mvc-controller/ann-methods/flash-attributes.adoc[Flash Attributes].\n\n| `@SessionAttribute`\n| For access to any session attribute, in contrast to model attributes stored in the\n session as a result of a class-level `@SessionAttributes` declaration.\n See xref:web/webmvc/mvc-controller/ann-methods/sessionattribute.adoc[`@SessionAttribute`] for more details.\n\n| `@RequestAttribute`\n| For access to request attributes. See xref:web/webmvc/mvc-controller/ann-methods/requestattrib.adoc[`@RequestAttribute`] for more details.\n\n|===\n\n[[mvc-ann-exceptionhandler-return-values]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-exceptionhandler.adoc", "title": "ann-exceptionhandler", "heading": "Method Arguments", "heading_level": 2, "file_order": 363, "section_index": 3, "content_hash": "b97bb8ebd27ce926d47645191ae90df21fb4a834007b6f5c8ea4d480d9b3d953", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-exceptionhandler.adoc"}}
{"id": "sha256:825b7ee393f24706981adba902ec9308d0e71889fbe20527146b1c865c1c0d49", "content": "[.small]#xref:web/webflux/controller/ann-exceptions.adoc#webflux-ann-exceptionhandler-return-values[See equivalent in the Reactive stack]#\n\n`@ExceptionHandler` methods support the following return values:\n\n[cols=\"1,2\", options=\"header\"]\n|===\n| Return value | Description\n\n| `@ResponseBody`\n| The return value is converted through `HttpMessageConverter` instances and written to the\n response. See xref:web/webmvc/mvc-controller/ann-methods/responsebody.adoc[`@ResponseBody`].\n\n| `HttpEntity<B>`, `ResponseEntity<B>`\n| The return value specifies that the full response (including the HTTP headers and the body)\n be converted through `HttpMessageConverter` instances and written to the response.\n See xref:web/webmvc/mvc-controller/ann-methods/responseentity.adoc[ResponseEntity].\n\n| `ErrorResponse`, `ProblemDetail`\n| To render an RFC 9457 error response with details in the body,\n see xref:web/webmvc/mvc-ann-rest-exceptions.adoc[Error Responses]\n\n| `String`\n| A view name to be resolved with `ViewResolver` implementations and used together with the\n implicit model -- determined through command objects and `@ModelAttribute` methods.\n The handler method can also programmatically enrich the model by declaring a `Model`\n argument (described earlier).\n\n| `View`\n| A `View` instance to use for rendering together with the implicit model -- determined\n through command objects and `@ModelAttribute` methods. The handler method may also\n programmatically enrich the model by declaring a `Model` argument (descried earlier).\n\n| `java.util.Map`, `org.springframework.ui.Model`\n| Attributes to be added to the implicit model with the view name implicitly determined\n through a `RequestToViewNameTranslator`.\n\n| `@ModelAttribute`\n| An attribute to be added to the model with the view name implicitly determined through\n a `RequestToViewNameTranslator`.\n\n Note that `@ModelAttribute` is optional. See \"`Any other return value`\" at the end of\n this table.\n\n| `ModelAndView` object\n| The view and model attributes to use and, optionally, a response status.\n\n| `void`\n| A method with a `void` return type (or `null` return value) is considered to have fully\n handled the response if it also has a `ServletResponse` an `OutputStream` argument, or\n a `@ResponseStatus` annotation. The same is also true if the controller has made a positive\n `ETag` or `lastModified` timestamp check (see xref:web/webmvc/mvc-caching.adoc#mvc-caching-etag-lastmodified[Controllers] for details).\n\n If none of the above is true, a `void` return type can also indicate \"`no response body`\" for\n REST controllers or default view name selection for HTML controllers.\n\n| Any other return value\n| If a return value is not matched to any of the above and is not a simple type (as determined by\n {spring-framework-api}/beans/BeanUtils.html#isSimpleProperty(java.lang.Class)[BeanUtils#isSimpleProperty]),\n by default, it is treated as a model attribute to be added to the model. If it is a simple type,\n it remains unresolved.\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-exceptionhandler.adoc", "title": "ann-exceptionhandler", "heading": "Return Values", "heading_level": 2, "file_order": 363, "section_index": 4, "content_hash": "825b7ee393f24706981adba902ec9308d0e71889fbe20527146b1c865c1c0d49", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-exceptionhandler.adoc"}}
{"id": "sha256:37de78862e7b8c8637b9aa2f58cd5273745890a74c7d49505b352601037f0eda", "content": "[[mvc-ann-initbinder]]\n\n[.small]#xref:web/webflux/controller/ann-initbinder.adoc[See equivalent in the Reactive stack]#\n\n`@Controller` or `@ControllerAdvice` classes can have `@InitBinder` methods to\ninitialize `WebDataBinder` instances that in turn can:\n\n* Bind request parameters to a model object.\n* Convert request values from string to object property types.\n* Format model object properties as strings when rendering HTML forms.\n\nIn an `@Controller`, `DataBinder` customizations apply locally within the controller,\nor even to a specific model attribute referenced by name through the annotation.\nIn an `@ControllerAdvice` customizations can apply to all or a subset of controllers.\n\nYou can register `PropertyEditor`, `Converter`, and `Formatter` components in the\n`DataBinder` for type conversion. Alternatively, you can use the\nxref:web/webmvc/mvc-config/conversion.adoc[MVC config] to register `Converter` and\n`Formatter` components in a globally shared `FormattingConversionService`.\n\n`@InitBinder` methods can have many of the same arguments that `@RequestMapping` methods\nhave, with the notable exception of `@ModelAttribute`. Typically, such methods have a\n`WebDataBinder` argument (for registrations) and a `void` return value, for example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class FormController {\n\n @InitBinder // <1>\n public void initBinder(WebDataBinder binder) {\n SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n dateFormat.setLenient(false);\n binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n }\n\n // ...\n\t}\n----\n<1> Defining an `@InitBinder` method.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tclass FormController {\n\n @InitBinder // <1>\n fun initBinder(binder: WebDataBinder) {\n val dateFormat = SimpleDateFormat(\"yyyy-MM-dd\")\n dateFormat.isLenient = false\n binder.registerCustomEditor(Date::class.java, CustomDateEditor(dateFormat, false))\n }\n\n // ...\n\t}\n----\n<1> Defining an `@InitBinder` method.\n======\n\nAlternatively, when you use a `Formatter`-based setup through a shared\n`FormattingConversionService`, you can re-use the same approach and register\ncontroller-specific `Formatter` implementations, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class FormController {\n\n @InitBinder // <1>\n protected void initBinder(WebDataBinder binder) {\n binder.addCustomFormatter(new DateFormatter(\"yyyy-MM-dd\"));\n }\n\n // ...\n\t}\n----\n<1> Defining an `@InitBinder` method on a custom formatter.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tclass FormController {\n\n @InitBinder // <1>\n protected fun initBinder(binder: WebDataBinder) {\n binder.addCustomFormatter(DateFormatter(\"yyyy-MM-dd\"))\n }\n\n // ...\n\t}\n----\n<1> Defining an `@InitBinder` method on a custom formatter.\n======\n\n[[mvc-ann-initbinder-model-design]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-initbinder.adoc", "title": "ann-initbinder", "heading": "ann-initbinder", "heading_level": 1, "file_order": 364, "section_index": 0, "content_hash": "37de78862e7b8c8637b9aa2f58cd5273745890a74c7d49505b352601037f0eda", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-initbinder.adoc"}}
{"id": "sha256:ad43b3e10616a204f06647bf0d2ec3e81038b7285a8685f52ee2cdcd354cfc20", "content": "[.small]#xref:web/webflux/controller/ann-initbinder.adoc#webflux-ann-initbinder-model-design[See equivalent in the Reactive stack]#\n\nxref:core/validation/data-binding.adoc[Data binding] for web requests involves\nbinding request parameters to a model object. By default, request parameters can be bound\nto any public property of the model object, which means malicious clients can provide\nextra values for properties that exist in the model object graph, but are not expected to\nbe set. This is why model object design requires careful consideration.\n\nTIP: The model object, and its nested object graph is also sometimes referred to as a\n_command object_, _form-backing object_, or _POJO_ (Plain Old Java Object).\n\nA good practice is to use a _dedicated model object_ rather than exposing your domain\nmodel such as JPA or Hibernate entities for web data binding. For example, on a form to\nchange an email address, create a `ChangeEmailForm` model object that declares only\nthe properties required for the input:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class ChangeEmailForm {\n\n\t\tprivate String oldEmailAddress;\n\t\tprivate String newEmailAddress;\n\n\t\tpublic void setOldEmailAddress(String oldEmailAddress) {\n\t\t\tthis.oldEmailAddress = oldEmailAddress;\n\t\t}\n\n\t\tpublic String getOldEmailAddress() {\n\t\t\treturn this.oldEmailAddress;\n\t\t}\n\n\t\tpublic void setNewEmailAddress(String newEmailAddress) {\n\t\t\tthis.newEmailAddress = newEmailAddress;\n\t\t}\n\n\t\tpublic String getNewEmailAddress() {\n\t\t\treturn this.newEmailAddress;\n\t\t}\n\n\t}\n----\n\nAnother good practice is to apply\nxref:core/validation/data-binding.adoc#data-binding-constructor-binding[constructor binding],\nwhich uses only the request parameters it needs for constructor arguments, and any other\ninput is ignored. This is in contrast to property binding which by default binds every\nrequest parameter for which there is a matching property.\n\nIf neither a dedicated model object nor constructor binding is sufficient, and you must\nuse property binding, we strongly recommend registering `allowedFields` patterns (case\nsensitive) on `WebDataBinder` in order to prevent unexpected properties from being set.\nFor example:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class ChangeEmailController {\n\n\t\t@InitBinder\n\t\tvoid initBinder(WebDataBinder binder) {\n\t\t\tbinder.setAllowedFields(\"oldEmailAddress\", \"newEmailAddress\");\n\t\t}\n\n\t\t// @RequestMapping methods, etc.\n\n\t}\n----\n\nYou can also register `disallowedFields`  patterns (case insensitive). However,\n\"allowed\" configuration is preferred over \"disallowed\" as it is more explicit and less\nprone to mistakes.\n\nBy default, constructor and property binding are both used. If you want to use\nconstructor binding only, you can set the `declarativeBinding` flag on `WebDataBinder`\nthrough an `@InitBinder` method either locally within a controller or globally through an\n`@ControllerAdvice`. Turning this flag on ensures that only constructor binding is used\nand that property binding is not used unless `allowedFields` patterns are configured.\nFor example:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class MyController {\n\n\t\t@InitBinder\n\t\tvoid initBinder(WebDataBinder binder) {\n\t\t\tbinder.setDeclarativeBinding(true);\n\t\t}\n\n\t\t// @RequestMapping methods, etc.\n\n\t}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-initbinder.adoc", "title": "ann-initbinder", "heading": "Model Design", "heading_level": 2, "file_order": 364, "section_index": 1, "content_hash": "ad43b3e10616a204f06647bf0d2ec3e81038b7285a8685f52ee2cdcd354cfc20", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-initbinder.adoc"}}
{"id": "sha256:158f9a6aeb5874d3efcdfe87007a588bbc40c32ee140d8b0b8fce5bc5c881439", "content": "[[mvc-ann-methods]]\n\n[.small]#xref:web/webflux/controller/ann-methods.adoc[See equivalent in the Reactive stack]#\n\n`@RequestMapping` handler methods have a flexible signature and can choose from a range of\nsupported controller method arguments and return values.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods.adoc", "title": "ann-methods", "heading": "ann-methods", "heading_level": 1, "file_order": 365, "section_index": 0, "content_hash": "158f9a6aeb5874d3efcdfe87007a588bbc40c32ee140d8b0b8fce5bc5c881439", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-methods.adoc"}}
{"id": "sha256:d20e9b92cd5a3d023d2bf92a601431ba0cd06e0989c6245609ab3a675f6dc398", "content": "[[mvc-ann-modelattrib-methods]]\n\n[.small]#xref:web/webflux/controller/ann-modelattrib-methods.adoc[See equivalent in the Reactive stack]#\n\nYou can use the `@ModelAttribute` annotation:\n\n* On a xref:web/webmvc/mvc-controller/ann-methods/modelattrib-method-args.adoc[method argument] in `@RequestMapping` methods\nto create or access an `Object` from the model and to bind it to the request through a\n`WebDataBinder`.\n* As a method-level annotation in `@Controller` or `@ControllerAdvice` classes that help\nto initialize the model prior to any `@RequestMapping` method invocation.\n* On a `@RequestMapping` method to mark its return value is a model attribute.\n\nThis section discusses `@ModelAttribute` methods -- the second item in the preceding list.\nA controller can have any number of `@ModelAttribute` methods. All such methods are\ninvoked before `@RequestMapping` methods in the same controller. A `@ModelAttribute`\nmethod can also be shared across controllers through `@ControllerAdvice`. See the section on\nxref:web/webmvc/mvc-controller/ann-advice.adoc[Controller Advice] for more details.\n\n`@ModelAttribute` methods have flexible method signatures. They support many of the same\narguments as `@RequestMapping` methods, except for `@ModelAttribute` itself or anything\nrelated to the request body.\n\nThe following example shows a `@ModelAttribute` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ModelAttribute\n\tpublic void populateModel(@RequestParam String number, Model model) {\n model.addAttribute(accountRepository.findAccount(number));\n // add more ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ModelAttribute\n\tfun populateModel(@RequestParam number: String, model: Model) {\n model.addAttribute(accountRepository.findAccount(number))\n // add more ...\n\t}\n----\n======\n\nThe following example adds only one attribute:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ModelAttribute\n\tpublic Account addAccount(@RequestParam String number) {\n return accountRepository.findAccount(number);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ModelAttribute\n\tfun addAccount(@RequestParam number: String): Account {\n return accountRepository.findAccount(number)\n\t}\n----\n======\n\nNOTE: When a name is not explicitly specified, a default name is chosen based on the `Object`\ntype, as explained in the javadoc for {spring-framework-api}/core/Conventions.html[`Conventions`].\nYou can always assign an explicit name by using the overloaded `addAttribute` method or\nthrough the `name` attribute on `@ModelAttribute` (for a return value).\n\nYou can also use `@ModelAttribute` as a method-level annotation on `@RequestMapping` methods,\nin which case the return value of the `@RequestMapping` method is interpreted as a model\nattribute. This is typically not required, as it is the default behavior in HTML controllers,\nunless the return value is a `String` that would otherwise be interpreted as a view name.\n`@ModelAttribute` can also customize the model attribute name, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/accounts/{id}\")\n\t@ModelAttribute(\"myAccount\")\n\tpublic Account handle() {\n // ...\n return account;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/accounts/{id}\")\n\t@ModelAttribute(\"myAccount\")\n\tfun handle(): Account {\n // ...\n return account\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-modelattrib-methods.adoc", "title": "ann-modelattrib-methods", "heading": "ann-modelattrib-methods", "heading_level": 1, "file_order": 366, "section_index": 0, "content_hash": "d20e9b92cd5a3d023d2bf92a601431ba0cd06e0989c6245609ab3a675f6dc398", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-modelattrib-methods.adoc"}}
{"id": "sha256:9901f4a78b38ceedd200e4e44bf77bf12d8fdce079e03d909c13290aa664510d", "content": "[[mvc-ann-requestmapping]]\n\n[.small]#xref:web/webflux/controller/ann-requestmapping.adoc[See equivalent in the Reactive stack]#\n\nThis section discusses request mapping for annotated controllers.\n\n[[mvc-ann-requestmapping-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "ann-requestmapping", "heading_level": 1, "file_order": 367, "section_index": 0, "content_hash": "9901f4a78b38ceedd200e4e44bf77bf12d8fdce079e03d909c13290aa664510d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:65bf003089b17a5db8d78b96e79f4233aa0f2f8c9bd96b7e08ba063e21b348fd", "content": "[.small]#xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-annotation[See equivalent in the Reactive stack]#\n\nYou can use the `@RequestMapping` annotation to map requests to controllers methods. It has\nvarious attributes to match by URL, HTTP method, request parameters, headers, and media\ntypes. You can use it at the class level to express shared mappings or at the method level\nto narrow down to a specific endpoint mapping.\n\nThere are also HTTP method specific shortcut variants of `@RequestMapping`:\n\n* `@GetMapping`\n* `@PostMapping`\n* `@PutMapping`\n* `@DeleteMapping`\n* `@PatchMapping`\n\nThe shortcuts are\nxref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-composed[Custom Annotations]\nthat are provided because, arguably, most controller methods should be mapped to a specific\nHTTP method versus using `@RequestMapping`, which, by default, matches to all HTTP methods.\nA `@RequestMapping` is still needed at the class level to express shared mappings.\n\nNOTE: `@RequestMapping` cannot be used in conjunction with other `@RequestMapping`\nannotations that are declared on the same element (class, interface, or method). If\nmultiple `@RequestMapping` annotations are detected on the same element, a warning will\nbe logged, and only the first mapping will be used. This also applies to composed\n`@RequestMapping` annotations such as `@GetMapping`, `@PostMapping`, etc.\n\nThe following example has type and method level mappings:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\t@RequestMapping(\"/persons\")\n\tclass PersonController {\n\n @GetMapping(\"/{id}\")\n public Person getPerson(@PathVariable Long id) {\n // ...\n }\n\n @PostMapping\n @ResponseStatus(HttpStatus.CREATED)\n public void add(@RequestBody Person person) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\t@RequestMapping(\"/persons\")\n\tclass PersonController {\n\n @GetMapping(\"/{id}\")\n fun getPerson(@PathVariable id: Long): Person {\n // ...\n }\n\n @PostMapping\n @ResponseStatus(HttpStatus.CREATED)\n fun add(@RequestBody person: Person) {\n // ...\n }\n\t}\n----\n======\n\n[[mvc-ann-requestmapping-uri-templates]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "`@RequestMapping`", "heading_level": 2, "file_order": 367, "section_index": 1, "content_hash": "65bf003089b17a5db8d78b96e79f4233aa0f2f8c9bd96b7e08ba063e21b348fd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:9674f3acfcb79ed36315135f372ddfb003ced11d0ad75611981a5b68f4290c9c", "content": "[.small]#xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-uri-templates[See equivalent in the Reactive stack]#\n\n`@RequestMapping` methods can be mapped using URL patterns.\nSpring MVC is using `PathPattern` -- a pre-parsed pattern matched against the URL path also pre-parsed as `PathContainer`.\nDesigned for web use, this solution deals effectively with encoding and path parameters, and matches efficiently.\nSee xref:web/webmvc/mvc-config/path-matching.adoc[MVC config] for customizations of path matching options.\n\nNOTE: the `AntPathMatcher` variant is now deprecated because it is less efficient and the String path input is a\nchallenge for dealing effectively with encoding and other issues with URLs.\n\nYou can map requests by using glob patterns and wildcards:\n\n[cols=\"2,3,5\"]\n|===\n|Pattern |Description |Example\n\n| `spring`\n| Literal pattern\n| `+\"/spring\"+` matches `+\"/spring\"+`\n\n| `+?+`\n| Matches one character\n| `+\"/pages/t?st.html\"+` matches `+\"/pages/test.html\"+` and `+\"/pages/t3st.html\"+`\n\n| `+*+`\n| Matches zero or more characters within a path segment\n| `+\"/resources/*.png\"+` matches `+\"/resources/file.png\"+`\n\n`+\"/projects/*/versions\"+` matches `+\"/projects/spring/versions\"+` but does not match `+\"/projects/spring/boot/versions\"+`.\n\n`+\"/projects/*\"+` matches `+\"/projects/spring\"+` but does not match `+\"/projects\"+` as the path segment is not present.\n\n| `+**+`\n| Matches zero or more path segments\n| `+\"/resources/**\"+` matches `+\"/resources\"+`, `+\"/resources/file.png\"+` and `+\"/resources/images/file.png\"+`\n\n`+\"/**/info\"+` matches `+\"/info\"+`, `+\"/spring/info\"+` and `+\"/spring/framework/info\"+`\n\n`+\"/resources/**/file.png\"+` is invalid as `+**+` is not allowed in the middle of the path.\n\n`+\"/**/spring/**\"+` is not allowed, as only a single `+**+`/`+{*path}+` instance is allowed per pattern.\n\n| `+{name}+`\n| Similar to `+*+`, but also captures the path segment as a variable named \"name\"\n| `+\"/projects/{project}/versions\"+` matches `+\"/projects/spring/versions\"+` and captures `+project=spring+`\n\n`+\"/projects/{project}/versions\"+` does not match `+\"/projects/spring/framework/versions\"+` as it captures a single path segment.\n\n| `{name:[a-z]+}`\n| Matches the regexp `\"[a-z]+\"` as a path variable named \"name\"\n| `\"/projects/{project:[a-z]+}/versions\"` matches `\"/projects/spring/versions\"` but not `\"/projects/spring1/versions\"`\n\n| `+{*path}+`\n| Similar to `+**+`, but also captures the path segments as a variable named \"path\"\n| `+\"/resources/{*file}\"+` matches `+\"/resources/images/file.png\"+` and captures `+file=/images/file.png+`\n\n`+\"{*path}/resources\"+` matches `+\"/spring/framework/resources\"+` and captures `+path=/spring/framework+`\n\n`+\"/resources/{*path}/file.png\"+` is invalid as `{*path}` is not allowed in the middle of the path.\n\n`+\"/{*path}/spring/**\"+` is not allowed, as only a single `+**+`/`+{*path}+` instance is allowed per pattern.\n\n|===\n\nCaptured URI variables can be accessed with `@PathVariable`. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n\tpublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\n\tfun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {\n // ...\n\t}\n----\n======\n\nYou can declare URI variables at the class and method levels, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@RequestMapping(\"/owners/{ownerId}\")\n\tpublic class OwnerController {\n\n @GetMapping(\"/pets/{petId}\")\n public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@RequestMapping(\"/owners/{ownerId}\")\n\tclass OwnerController {\n\n @GetMapping(\"/pets/{petId}\")\n fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {\n // ...\n }\n\t}\n----\n======\n\nURI variables are automatically converted to the appropriate type, or `TypeMismatchException`\nis raised. Simple types (`int`, `long`, `Date`, and so on) are supported by default and you can\nregister support for any other data type.\nSee xref:web/webmvc/mvc-controller/ann-methods/typeconversion.adoc[Type Conversion] and xref:web/webmvc/mvc-controller/ann-initbinder.adoc[`DataBinder`].\n\nYou can explicitly name URI variables (for example, `@PathVariable(\"customId\")`), but you can\nleave that detail out if the names are the same and your code is compiled with the `-parameters`\ncompiler flag.\n\nThe syntax `{varName:regex}` declares a URI variable with a regular expression that has\nsyntax of `{varName:regex}`. For example, given URL `\"/spring-web-3.0.5.jar\"`, the following method\nextracts the name, version, and file extension:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}\")\n\tpublic void handle(@PathVariable String name, @PathVariable String version, @PathVariable String ext) {\n // ...\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}\")\n\tfun handle(@PathVariable name: String, @PathVariable version: String, @PathVariable ext: String) {\n // ...\n\t}\n----\n======\n\nURI path patterns can also have:\n\n- Embedded `${...}` placeholders that are resolved on startup via\n`PropertySourcesPlaceholderConfigurer` against local, system, environment, and\nother property sources. This is useful, for example, to parameterize a base URL based on\nexternal configuration.\n- SpEL expression `#{...}`.\n\n[[mvc-ann-requestmapping-pattern-comparison]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "URI patterns", "heading_level": 2, "file_order": 367, "section_index": 2, "content_hash": "9674f3acfcb79ed36315135f372ddfb003ced11d0ad75611981a5b68f4290c9c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:97b30709231958ea17d5acdadd0bc8c537e452e2fb52799bab1255294064676b", "content": "[.small]#xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-pattern-comparison[See equivalent in the Reactive stack]#\n\nWhen multiple patterns match a URL, the best match must be selected. This is done with\none of the following depending on whether use of parsed `PathPattern` is enabled for use or not:\n\n* {spring-framework-api}/web/util/pattern/PathPattern.html#SPECIFICITY_COMPARATOR[`PathPattern.SPECIFICITY_COMPARATOR`]\n* {spring-framework-api}/util/AntPathMatcher.html#getPatternComparator(java.lang.String)[`AntPathMatcher.getPatternComparator(String path)`]\n\nBoth help to sort patterns with more specific ones on top. A pattern is more specific if\nit has a lower count of URI variables (counted as 1), single wildcards (counted as 1),\nand double wildcards (counted as 2). Given an equal score, the longer pattern is chosen.\nGiven the same score and length, the pattern with more URI variables than wildcards is\nchosen.\n\nThe default mapping pattern (`/{asterisk}{asterisk}`) is excluded from scoring and always\nsorted last. Also, prefix patterns (such as `/public/{asterisk}{asterisk}`) are considered less\nspecific than other pattern that do not have double wildcards.\n\nFor the full details, follow the above links to the pattern Comparators.\n\n[[mvc-ann-requestmapping-rfd]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Pattern Comparison", "heading_level": 2, "file_order": 367, "section_index": 3, "content_hash": "97b30709231958ea17d5acdadd0bc8c537e452e2fb52799bab1255294064676b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:315edcacd5d1379ec8e81bf615de4ff31231a678fc490145b403abe0cb290486", "content": "A reflected file download (RFD) attack is similar to XSS in that it relies on request input\n(for example, a query parameter and a URI variable) being reflected in the response. However, instead of\ninserting JavaScript into HTML, an RFD attack relies on the browser switching to perform a\ndownload and treating the response as an executable script when double-clicked later.\n\nIn Spring MVC, `@ResponseBody` and `ResponseEntity` methods are at risk, because\nthey can render different content types, which clients can request through URL path extensions.\nDisabling suffix pattern matching and using path extensions for content negotiation\nlower the risk but are not sufficient to prevent RFD attacks.\n\nTo prevent RFD attacks, prior to rendering the response body, Spring MVC adds a\n`Content-Disposition:inline;filename=f.txt` header to suggest a fixed and safe download\nfile. This is done only if the URL path contains a file extension that is neither\nallowed as safe nor explicitly registered for content negotiation. However, it can\npotentially have side effects when URLs are typed directly into a browser.\n\nMany common path extensions are allowed as safe by default. Applications with custom\n`HttpMessageConverter` implementations can explicitly register file extensions for content\nnegotiation to avoid having a `Content-Disposition` header added for those extensions.\nSee xref:web/webmvc/mvc-config/content-negotiation.adoc[Content Types].\n\nSee {spring-site-cve}/cve-2015-5211[CVE-2015-5211] for additional\nrecommendations related to RFD.\n\n[[mvc-ann-requestmapping-consumes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Suffix Match and RFD", "heading_level": 2, "file_order": 367, "section_index": 4, "content_hash": "315edcacd5d1379ec8e81bf615de4ff31231a678fc490145b403abe0cb290486", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:f7a6f8e724af6516176d1347e714d34ecbdce5afdc4bf8e4545bb622d3ae9828", "content": "[.small]#xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-consumes[See equivalent in the Reactive stack]#\n\nYou can narrow the request mapping based on the `Content-Type` of the request,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(path = \"/pets\", consumes = \"application/json\") // <1>\n\tpublic void addPet(@RequestBody Pet pet) {\n // ...\n\t}\n----\n<1> Using a `consumes` attribute to narrow the mapping by the content type.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping(\"/pets\", consumes = [\"application/json\"]) // <1>\n\tfun addPet(@RequestBody pet: Pet) {\n // ...\n\t}\n----\n<1> Using a `consumes` attribute to narrow the mapping by the content type.\n======\n\nThe `consumes` attribute also supports negation expressions -- for example, `!text/plain` means any\ncontent type other than `text/plain`.\n\nYou can declare a shared `consumes` attribute at the class level. Unlike most other\nrequest-mapping attributes, however, when used at the class level, a method-level `consumes` attribute\noverrides rather than extends the class-level declaration.\n\nTIP: `MediaType` provides constants for commonly used media types, such as\n`APPLICATION_JSON_VALUE` and `APPLICATION_XML_VALUE`.\n\n[[mvc-ann-requestmapping-produces]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Consumable Media Types", "heading_level": 2, "file_order": 367, "section_index": 5, "content_hash": "f7a6f8e724af6516176d1347e714d34ecbdce5afdc4bf8e4545bb622d3ae9828", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:c030c3d6bc083d320716632a261e53a7cdf3b6ffdeb1ddb4cd441977f1692108", "content": "[.small]#xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-produces[See equivalent in the Reactive stack]#\n\nYou can narrow the request mapping based on the `Accept` request header and the list of\ncontent types that a controller method produces, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(path = \"/pets/{petId}\", produces = \"application/json\") // <1>\n\t@ResponseBody\n\tpublic Pet getPet(@PathVariable String petId) {\n // ...\n\t}\n----\n<1> Using a `produces` attribute to narrow the mapping by the content type.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/pets/{petId}\", produces = [\"application/json\"]) // <1>\n\t@ResponseBody\n\tfun getPet(@PathVariable petId: String): Pet {\n // ...\n\t}\n----\n<1> Using a `produces` attribute to narrow the mapping by the content type.\n======\n\nThe media type can specify a character set. Negated expressions are supported -- for example,\n`!text/plain` means any content type other than \"text/plain\".\n\nYou can declare a shared `produces` attribute at the class level. Unlike most other\nrequest-mapping attributes, however, when used at the class level, a method-level `produces` attribute\noverrides rather than extends the class-level declaration.\n\nTIP: `MediaType` provides constants for commonly used media types, such as\n`APPLICATION_JSON_VALUE` and `APPLICATION_XML_VALUE`.\n\n[[mvc-ann-requestmapping-params-and-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Producible Media Types", "heading_level": 2, "file_order": 367, "section_index": 6, "content_hash": "c030c3d6bc083d320716632a261e53a7cdf3b6ffdeb1ddb4cd441977f1692108", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:2855a2b9306099e81713443ff931014559266ff6945861b61defeb662b9c2d9f", "content": "[.small]#xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-params-and-headers[See equivalent in the Reactive stack]#\n\nYou can narrow request mappings based on request parameter conditions. You can test for the\npresence of a request parameter (`myParam`), for the absence of one (`!myParam`), or for a\nspecific value (`myParam=myValue`). The following example shows how to test for a specific value:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(path = \"/pets/{petId}\", params = \"myParam=myValue\") // <1>\n\tpublic void findPet(@PathVariable String petId) {\n // ...\n\t}\n----\n<1> Testing whether `myParam` equals `myValue`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/pets/{petId}\", params = [\"myParam=myValue\"]) // <1>\n\tfun findPet(@PathVariable petId: String) {\n // ...\n\t}\n----\n<1> Testing whether `myParam` equals `myValue`.\n======\n\nYou can also use the same with request header conditions, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(path = \"/pets/{petId}\", headers = \"myHeader=myValue\") // <1>\n\tpublic void findPet(@PathVariable String petId) {\n // ...\n\t}\n----\n<1> Testing whether `myHeader` equals `myValue`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/pets/{petId}\", headers = [\"myHeader=myValue\"]) // <1>\n\tfun findPet(@PathVariable petId: String) {\n // ...\n\t}\n----\n<1> Testing whether `myHeader` equals `myValue`.\n======\n\nTIP: You can match `Content-Type` and `Accept` with the headers condition, but it is better to use\nxref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-consumes[consumes]\nand xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-produces[produces]\ninstead.\n\n[[mvc-ann-requestmapping-version]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Parameters, headers", "heading_level": 2, "file_order": 367, "section_index": 7, "content_hash": "2855a2b9306099e81713443ff931014559266ff6945861b61defeb662b9c2d9f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:cc75dbae76f8cd0ff9a131a90120d7211d2aa6cb3a3d47a0a2c6dac45b2bdfd5", "content": "[.small]#xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-version[See equivalent in the Reactive stack]#\n\nThere is no standard way to specify an API version, so when you enable API versioning\nin the xref:web/webmvc/mvc-config/api-version.adoc[MVC Config] you need\nto specify how to resolve the version. The MVC Config creates an\nxref:web/webmvc-versioning.adoc#mvc-versioning-strategy[ApiVersionStrategy] that in turn\nis used to map requests.\n\nOnce API versioning is enabled, you can begin to map requests with versions.\nThe `@RequestMapping` `version` attribute supports the following:\n\n- Fixed version (\"1.2\") -- matches the given version only\n- Baseline version (\"1.2+\") -- matches the given version and above\n- No value -- matches any version, but is superseded by a more specific version match\n\nIf multiple controller methods have a version less than or equal to the request version,\nthe highest of those, and closest to the request version, is the one considered,\nin effect superseding the rest.\n\nTo illustrate this, consider the following mappings:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\t@RequestMapping(\"/account/{id}\")\n\tpublic class AccountController {\n\n @GetMapping // <1>\n public Account getAccount() {\n }\n\n @GetMapping(version = \"1.1\") // <2>\n public Account getAccount1_1() {\n }\n\n @GetMapping(version = \"1.2+\") // <3>\n public Account getAccount1_2() {\n }\n\n @GetMapping(version = \"1.5\") // <4>\n public Account getAccount1_5() {\n }\n\t}\n----\n<1> match any version\n<2> match version 1.1\n<3> match version 1.2 and above\n<4> match version 1.5\n======\n\nFor request with version `\"1.3\"`:\n\n- (1) matches as it matches any version\n- (2) does not match\n- (3) matches as it matches 1.2 and above, and is *chosen* as the highest match\n- (4) is higher and does not match\n\nFor request with version `\"1.5\"`:\n\n- (1) matches as it matches any version\n- (2) does not match\n- (3) matches as it matches 1.2 and above\n- (4) matches and is *chosen* as the highest match\n\nA request with version `\"1.6\"` does not have a match. (1) and (3) do match, but are\nsuperseded by (4), which allows only a strict match, and therefore does not match.\nIn this scenario, a `NotAcceptableApiVersionException` results in a 400 response.\n\nController methods without a version are intended to support clients created before a\nversioned alternative was introduced. Therefore, even though an unversioned controller\nmethod is considered a match for any version, it is in fact given the lowest priority,\nand is effectively superseded by any alternative controller method with a version.\n\nNOTE: The above assumes the request version is a\nxref:web/webmvc/mvc-config/api-version.adoc[\"supported\" version], or otherwise it\nwould fail.\n\nSee xref:web/webmvc-versioning.adoc[API Versioning] for more details on underlying\ninfrastructure and support for API Versioning.\n\n[[mvc-ann-requestmapping-head-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "API Version", "heading_level": 2, "file_order": 367, "section_index": 8, "content_hash": "cc75dbae76f8cd0ff9a131a90120d7211d2aa6cb3a3d47a0a2c6dac45b2bdfd5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:deda5fde8f8ffaff45d3857675ae1a19624dd285b4927d5ec1d3954fe43cb297", "content": "[.small]#xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-head-options[See equivalent in the Reactive stack]#\n\n`@GetMapping` (and `@RequestMapping(method=HttpMethod.GET)`) support HTTP HEAD\ntransparently for request mapping. Controller methods do not need to change.\nA response wrapper, applied in `jakarta.servlet.http.HttpServlet`, ensures a `Content-Length`\nheader is set to the number of bytes written (without actually writing to the response).\n\nBy default, HTTP OPTIONS is handled by setting the `Allow` response header to the list of HTTP\nmethods listed in all `@RequestMapping` methods that have matching URL patterns.\n\nFor a `@RequestMapping` without HTTP method declarations, the `Allow` header is set to\n`GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`. Controller methods should always declare the\nsupported HTTP methods (for example, by using the HTTP method specific variants:\n`@GetMapping`, `@PostMapping`, and others).\n\nYou can explicitly map the `@RequestMapping` method to HTTP HEAD and HTTP OPTIONS, but that\nis not necessary in the common case.\n\n[[mvc-ann-requestmapping-composed]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "HTTP HEAD, OPTIONS", "heading_level": 2, "file_order": 367, "section_index": 9, "content_hash": "deda5fde8f8ffaff45d3857675ae1a19624dd285b4927d5ec1d3954fe43cb297", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:9139e6a040afba880061e31336e3485f6be0b533ff0ae30833490ed1a62440f3", "content": "[.small]#xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-head-options[See equivalent in the Reactive stack]#\n\nSpring MVC supports the use of xref:core/beans/classpath-scanning.adoc#beans-meta-annotations[composed annotations]\nfor request mapping. Those are annotations that are themselves meta-annotated with\n`@RequestMapping` and composed to redeclare a subset (or all) of the `@RequestMapping`\nattributes with a narrower, more specific purpose.\n\n`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, and `@PatchMapping` are\nexamples of composed annotations. They are provided because, arguably, most\ncontroller methods should be mapped to a specific HTTP method versus using `@RequestMapping`,\nwhich, by default, matches to all HTTP methods. If you need an example of how to implement\na composed annotation, look at how those are declared.\n\nNOTE: `@RequestMapping` cannot be used in conjunction with other `@RequestMapping`\nannotations that are declared on the same element (class, interface, or method). If\nmultiple `@RequestMapping` annotations are detected on the same element, a warning will\nbe logged, and only the first mapping will be used. This also applies to composed\n`@RequestMapping` annotations such as `@GetMapping`, `@PostMapping`, etc.\n\nSpring MVC also supports custom request-mapping attributes with custom request-matching\nlogic. This is a more advanced option that requires subclassing\n`RequestMappingHandlerMapping` and overriding the `getCustomMethodCondition` method, where\nyou can check the custom attribute and return your own `RequestCondition`.\n\n[[mvc-ann-requestmapping-registration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Custom Annotations", "heading_level": 2, "file_order": 367, "section_index": 10, "content_hash": "9139e6a040afba880061e31336e3485f6be0b533ff0ae30833490ed1a62440f3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:ea8205f568c72f57f2ce41dff71a56f2d6fe64ef701a96e6a08d1a5cf8a93085", "content": "[.small]#xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-registration[See equivalent in the Reactive stack]#\n\nYou can programmatically register handler methods, which you can use for dynamic\nregistrations or for advanced cases, such as different instances of the same handler\nunder different URLs. The following example registers a handler method:\n\ninclude-code::./MyConfiguration[tag=snippet,indent=0]\n\n[[mvc-ann-httpexchange-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "Explicit Registrations", "heading_level": 2, "file_order": 367, "section_index": 11, "content_hash": "ea8205f568c72f57f2ce41dff71a56f2d6fe64ef701a96e6a08d1a5cf8a93085", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:3d976f3185f40aeac0eb7fc8a70b748bbbdc224a53d29b2bb3879ef57024c007", "content": "[.small]#xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-httpexchange-annotation[See equivalent in the Reactive stack]#\n\nWhile the main purpose of `@HttpExchange` is to abstract HTTP client code with a\ngenerated proxy, the interface on which such annotations are placed is a contract neutral\nto client vs server use. In addition to simplifying client code, there are also cases\nwhere an xref:integration/rest-clients.adoc#rest-http-service-client[HTTP Service Client]\nmay be a convenient way for servers to expose their API for client access. This leads\nto increased coupling between client and server and is often not a good choice,\nespecially for public API's, but may be exactly the goal for an internal API.\nIt is an approach commonly used in Spring Cloud, and it is why `@HttpExchange` is\nsupported as an alternative to `@RequestMapping` for server side handling in\ncontroller classes.\n\nFor example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@HttpExchange(\"/persons\")\n\tinterface PersonService {\n\n @GetExchange(\"/{id}\")\n Person getPerson(@PathVariable Long id);\n\n @PostExchange\n void add(@RequestBody Person person);\n\t}\n\n\t@RestController\n\tclass PersonController implements PersonService {\n\n public Person getPerson(@PathVariable Long id) {\n // ...\n }\n\n @ResponseStatus(HttpStatus.CREATED)\n public void add(@RequestBody Person person) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@HttpExchange(\"/persons\")\n\tinterface PersonService {\n\n @GetExchange(\"/{id}\")\n fun getPerson(@PathVariable id: Long): Person\n\n @PostExchange\n fun add(@RequestBody person: Person)\n\t}\n\n\t@RestController\n\tclass PersonController : PersonService {\n\n override fun getPerson(@PathVariable id: Long): Person {\n // ...\n }\n\n @ResponseStatus(HttpStatus.CREATED)\n override fun add(@RequestBody person: Person) {\n // ...\n }\n\t}\n----\n======\n\n`@HttpExchange` and `@RequestMapping` have differences.\n`@RequestMapping` can map to any number of requests by path patterns, HTTP methods,\nand more, while `@HttpExchange` declares a single endpoint with a concrete HTTP method,\npath, and content types.\n\nFor method parameters and returns values, generally, `@HttpExchange` supports a\nsubset of the method parameters that `@RequestMapping` does. Notably, it excludes any\nserver-side specific parameter types. For details, see the list for\nxref:integration/rest-clients.adoc#rest-http-service-client-method-parameters[@HttpExchange] and\nxref:web/webmvc/mvc-controller/ann-methods/arguments.adoc[@RequestMapping].\n\n`@HttpExchange` also supports a `headers()` parameter which accepts `\"name=value\"`-like\npairs like in `@RequestMapping(headers={})` on the client side. On the server side,\nthis extends to the full syntax that\nxref:#mvc-ann-requestmapping-params-and-headers[`@RequestMapping`] supports.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc", "title": "ann-requestmapping", "heading": "`@HttpExchange`", "heading_level": 2, "file_order": 367, "section_index": 12, "content_hash": "3d976f3185f40aeac0eb7fc8a70b748bbbdc224a53d29b2bb3879ef57024c007", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-requestmapping.adoc"}}
{"id": "sha256:09bf8d37715f6c855194f230030a59a4b8b55ec170ad08070c06320eee25ace3", "content": "[[mvc-ann-validation]]\n\n[.small]#xref:web/webflux/controller/ann-validation.adoc[See equivalent in the Reactive stack]#\n\nSpring MVC has built-in xref:core/validation/validator.adoc[validation] for\n`@RequestMapping` methods, including xref:core/validation/beanvalidation.adoc[Java Bean Validation].\nValidation may be applied at one of two levels:\n\n1. Java Bean Validation is applied individually to an\nxref:web/webmvc/mvc-controller/ann-methods/modelattrib-method-args.adoc[@ModelAttribute],\nxref:web/webmvc/mvc-controller/ann-methods/requestbody.adoc[@RequestBody], and\nxref:web/webmvc/mvc-controller/ann-methods/multipart-forms.adoc[@RequestPart] method parameter\nannotated with `@jakarta.validation.Valid` or Spring's `@Validated` so long as\nit is a command object rather than a container such as `Map` or `Collection`, it does not\nhave `Errors` or `BindingResult` immediately after in the method signature, and does not\notherwise require method validation (see next). `MethodArgumentNotValidException` is the\nexception raised when validating a method parameter individually.\n\n2. Java Bean Validation is applied to the method when `@Constraint` annotations such as\n`@Min`, `@NotBlank` and others are declared directly on method parameters, or on the\nmethod for the return value, and it supersedes any validation that would be applied\notherwise to a method parameter individually because method validation covers both\nmethod parameter constraints and nested constraints via `@Valid`.\n`HandlerMethodValidationException` is the exception raised validation is applied\nto the method.\n\nApplications should handle both `MethodArgumentNotValidException` and\n`HandlerMethodValidationException` since either may be raised depending on the controller\nmethod signature. The two exceptions, however are designed to be very similar, and can be\nhandled with almost identical code. The main difference is that the former is for a single\nobject while the latter is for a list of method parameters.\n\nNOTE: `@Valid` is not a constraint annotation, but rather for nested constraints within\nan Object. Therefore, by itself `@Valid` does not lead to method validation. `@NotNull`\non the other hand is a constraint, and adding it to an `@Valid` parameter leads to method\nvalidation. For nullability specifically, you may also use the `required` flag of\n`@RequestBody` or `@ModelAttribute`.\n\nMethod validation may be used in combination with `Errors` or `BindingResult` method\nparameters. However, the controller method is called only if all validation errors are on\nmethod parameters with an `Errors` immediately after. If there are validation errors on\nany other method parameter then `HandlerMethodValidationException` is raised.\n\nYou can configure a `Validator` globally through the\nxref:web/webmvc/mvc-config/validation.adoc[WebMvc config], or locally through an\nxref:web/webmvc/mvc-controller/ann-initbinder.adoc[@InitBinder] method in an\n`@Controller` or `@ControllerAdvice`. You can also use multiple validators.\n\nNOTE: If a controller has a class level `@Validated`, then\nxref:core/validation/beanvalidation.adoc#validation-beanvalidation-spring-method[method validation is applied]\nthrough an AOP proxy. In order to take advantage of the Spring MVC built-in support for\nmethod validation added in Spring Framework 6.1, you need to remove the class level\n`@Validated` annotation from the controller.\n\nThe xref:web/webmvc/mvc-ann-rest-exceptions.adoc[Error Responses] section provides further\ndetails on how `MethodArgumentNotValidException` and `HandlerMethodValidationException`\nare handled, and also how their rendering can be customized through a `MessageSource` and\nlocale and language specific resource bundles.\n\nFor further custom handling of method validation errors, you can extend\n`ResponseEntityExceptionHandler` or use an `@ExceptionHandler` method in a controller\nor in a `@ControllerAdvice`, and handle `HandlerMethodValidationException` directly.\nThe exception contains a list of ``ParameterValidationResult``s that group validation errors\nby method parameter. You can either iterate over those, or provide a visitor with callback\nmethods by controller method parameter type:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHandlerMethodValidationException ex = ... ;\n\n\tex.visitResults(new HandlerMethodValidationException.Visitor() {\n\n @Override\n public void requestHeader(RequestHeader requestHeader, ParameterValidationResult result) {\n // ...\n }\n\n @Override\n public void requestParam(@Nullable RequestParam requestParam, ParameterValidationResult result) {\n // ...\n }\n\n @Override\n public void modelAttribute(@Nullable ModelAttribute modelAttribute, ParameterErrors errors) {\n\n // ...\n\n @Override\n public void other(ParameterValidationResult result) {\n // ...\n }\n\t});\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// HandlerMethodValidationException\n\tval ex\n\n\tex.visitResults(object : HandlerMethodValidationException.Visitor {\n\n override fun requestHeader(requestHeader: RequestHeader, result: ParameterValidationResult) {\n // ...\n }\n\n override fun requestParam(requestParam: RequestParam?, result: ParameterValidationResult) {\n // ...\n }\n\n override fun modelAttribute(modelAttribute: ModelAttribute?, errors: ParameterErrors) {\n // ...\n }\n\n // ...\n\n override fun other(result: ParameterValidationResult) {\n // ...\n }\n\t})\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-validation.adoc", "title": "ann-validation", "heading": "ann-validation", "heading_level": 1, "file_order": 368, "section_index": 0, "content_hash": "09bf8d37715f6c855194f230030a59a4b8b55ec170ad08070c06320eee25ace3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann-validation.adoc"}}
{"id": "sha256:3d8eec1a981f457730e7f2481b399c2f3adfb485367e2efaf5015370cd18bca9", "content": "[[mvc-ann-controller]]\n\n[.small]#xref:web/webflux/controller/ann.adoc[See equivalent in the Reactive stack]#\n\nYou can define controller beans by using a standard Spring bean definition in the\nServlet's `WebApplicationContext`. The `@Controller` stereotype allows for auto-detection,\naligned with Spring general support for detecting `@Component` classes in the classpath\nand auto-registering bean definitions for them. It also acts as a stereotype for the\nannotated class, indicating its role as a web component.\n\nTo enable auto-detection of such `@Controller` beans, you can add component scanning to\nyour Java configuration, as the following example shows:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\n`@RestController` is a xref:core/beans/classpath-scanning.adoc#beans-meta-annotations[composed annotation] that is\nitself meta-annotated with `@Controller` and `@ResponseBody` to indicate a controller whose\nevery method inherits the type-level `@ResponseBody` annotation and, therefore, writes\ndirectly to the response body versus view resolution and rendering with an HTML template.\n\n[[mvc-ann-requestmapping-proxying]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann.adoc", "title": "ann", "heading": "ann", "heading_level": 1, "file_order": 369, "section_index": 0, "content_hash": "3d8eec1a981f457730e7f2481b399c2f3adfb485367e2efaf5015370cd18bca9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann.adoc"}}
{"id": "sha256:3a4fa9e4d1d8800e3a4f5245c325549a68b6d0cc0937bdfb9a2d6e48664328bd", "content": "[.small]#xref:web/webflux/controller/ann.adoc#webflux-ann-requestmapping-proxying[See equivalent in the Reactive stack]#\n\nIn some cases, you may need to decorate a controller with an AOP proxy at runtime.\nOne example is if you choose to have `@Transactional` annotations directly on the\ncontroller. When this is the case, for controllers specifically, we recommend\nusing class-based proxying. This is automatically the case with such annotations\ndirectly on the controller.\n\nIf the controller implements an interface, and needs AOP proxying, you may need to\nexplicitly configure class-based proxying. For example, with `@EnableTransactionManagement`\nyou can change to `@EnableTransactionManagement(proxyTargetClass = true)`, and with\n`<tx:annotation-driven/>` you can change to `<tx:annotation-driven proxy-target-class=\"true\"/>`.\n\nNOTE: Keep in mind that as of 6.0, with interface proxying, Spring MVC no longer detects\ncontrollers based solely on a type-level `@RequestMapping` annotation on the interface.\nPlease, enable class based proxying, or otherwise the interface must also have an\n`@Controller` annotation.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann.adoc", "title": "ann", "heading": "AOP Proxies", "heading_level": 2, "file_order": 369, "section_index": 1, "content_hash": "3a4fa9e4d1d8800e3a4f5245c325549a68b6d0cc0937bdfb9a2d6e48664328bd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller/ann.adoc"}}
{"id": "sha256:a61c5c4f20d4019326063c87c62b45495dc32995b09627507e0210613bdd7b3d", "content": "[[mvc-servlet-config]]\n\n[.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[See equivalent in the Reactive stack]#\n\nApplications can declare the infrastructure beans listed in xref:web/webmvc/mvc-servlet/special-bean-types.adoc[Special Bean Types]\nthat are required to process requests. The `DispatcherServlet` checks the\n`WebApplicationContext` for each special bean. If there are no matching bean types,\nit falls back on the default types listed in\n{spring-framework-code}/spring-webmvc/src/main/resources/org/springframework/web/servlet/DispatcherServlet.properties[`DispatcherServlet.properties`].\n\nIn most cases, the xref:web/webmvc/mvc-config.adoc[MVC Config] is the best starting point. It declares the required\nbeans in either Java or XML and provides a higher-level configuration callback API to\ncustomize it.\n\nNOTE: Spring Boot relies on the MVC Java configuration to configure Spring MVC and\nprovides many extra convenient options.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/config.adoc", "title": "config", "heading": "config", "heading_level": 1, "file_order": 370, "section_index": 0, "content_hash": "a61c5c4f20d4019326063c87c62b45495dc32995b09627507e0210613bdd7b3d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/config.adoc"}}
{"id": "sha256:e2a6b927ad3f96b784743104790f4e889208f20ba788cfb2186ef56be4a27b52", "content": "[[mvc-container-config]]\n\nIn a Servlet environment, you have the option of configuring the Servlet container\nprogrammatically as an alternative or in combination with a `web.xml` file.\nThe following example registers a `DispatcherServlet`:\n\ninclude-code::./MyWebApplicationInitializer[tag=snippet,indent=0]\n\n`WebApplicationInitializer` is an interface provided by Spring MVC that ensures your\nimplementation is detected and automatically used to initialize any Servlet 3 container.\nAn abstract base class implementation of `WebApplicationInitializer` named\n`AbstractDispatcherServletInitializer` makes it even easier to register the\n`DispatcherServlet` by overriding methods to specify the servlet mapping and the\nlocation of the `DispatcherServlet` configuration.\n\nThis is recommended for applications that use programmatic Spring configuration, as the\nfollowing example shows:\n\ninclude-code::./MyWebAppInitializer[tag=snippet,indent=0]\n\nIf you use XML-based Spring configuration, you should extend directly from\n`AbstractDispatcherServletInitializer`, as the following example shows:\n\ninclude-code::./MyXmlDispatcherServletInitializer[tag=snippet,indent=0]\n\n`AbstractDispatcherServletInitializer` also provides a convenient way to add `Filter`\ninstances and have them be automatically mapped to the `DispatcherServlet`, as the\nfollowing example shows:\n\ninclude-code::./MyFilterDispatcherServletInitializer[tag=snippet,indent=0]\n\nEach filter is added with a default name based on its concrete type and automatically\nmapped to the `DispatcherServlet`.\n\nThe `isAsyncSupported` protected method of `AbstractDispatcherServletInitializer`\nprovides a single place to enable async support on the `DispatcherServlet` and all\nfilters mapped to it. By default, this flag is set to `true`.\n\nFinally, if you need to further customize the `DispatcherServlet` itself, you can\noverride the `createDispatcherServlet` method.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/container-config.adoc", "title": "container-config", "heading": "container-config", "heading_level": 1, "file_order": 371, "section_index": 0, "content_hash": "e2a6b927ad3f96b784743104790f4e889208f20ba788cfb2186ef56be4a27b52", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/container-config.adoc"}}
{"id": "sha256:ee3d91edcaa0249cc2caf197ed42f619a841cd985aa9aa92d3075f593b165060", "content": "[[mvc-servlet-context-hierarchy]]\n\n`DispatcherServlet` expects a `WebApplicationContext` (an extension of a plain\n`ApplicationContext`) for its own configuration. `WebApplicationContext` has a link to the\n`ServletContext` and the `Servlet` with which it is associated. It is also bound to the `ServletContext`\nsuch that applications can use static methods on `RequestContextUtils` to look up the\n`WebApplicationContext` if they need access to it.\n\nFor many applications, having a single `WebApplicationContext` is simple and suffices.\nIt is also possible to have a context hierarchy where one root `WebApplicationContext`\nis shared across multiple `DispatcherServlet` (or other `Servlet`) instances, each with\nits own child `WebApplicationContext` configuration.\nSee xref:core/beans/context-introduction.adoc[Additional Capabilities of the `ApplicationContext`]\nfor more on the context hierarchy feature.\n\nThe root `WebApplicationContext` typically contains infrastructure beans, such as data repositories and\nbusiness services that need to be shared across multiple `Servlet` instances. Those beans\nare effectively inherited and can be overridden (that is, re-declared) in the Servlet-specific\nchild `WebApplicationContext`, which typically contains beans local to the given `Servlet`.\nThe following image shows this relationship:\n\nimage::mvc-context-hierarchy.png[width=60%,align=\"center\"]\n\nThe following example configures a `WebApplicationContext` hierarchy, and the equivalent `web.xml`:\n\ninclude-code::./MyWebAppInitializer[tag=snippet,indent=0]\n\nTIP: If an application context hierarchy is not required, applications can return all\nconfiguration through `getRootConfigClasses()` and `null` from `getServletConfigClasses()`.\n\nTIP: If an application context hierarchy is not required, applications may configure a\n\"`root`\" context only and leave the `contextConfigLocation` Servlet parameter empty.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/context-hierarchy.adoc", "title": "context-hierarchy", "heading": "context-hierarchy", "heading_level": 1, "file_order": 372, "section_index": 0, "content_hash": "ee3d91edcaa0249cc2caf197ed42f619a841cd985aa9aa92d3075f593b165060", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/context-hierarchy.adoc"}}
{"id": "sha256:cb7f4464c04635926f3b6ad68dd955c9588b102ea6d4244e2c90de526349172b", "content": "[[mvc-exceptionhandlers]]\n\n[.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-dispatcher-exceptions[See equivalent in the Reactive stack]#\n\nIf an exception occurs during request mapping or is thrown from a request handler (such as\na `@Controller`), the `DispatcherServlet` delegates to a chain of `HandlerExceptionResolver`\nbeans to resolve the exception and provide alternative handling, which is typically an\nerror response.\n\nThe following table lists the available `HandlerExceptionResolver` implementations:\n\n[cols=\"1,2\", options=\"header\"]\n.HandlerExceptionResolver implementations\n|===\n| `HandlerExceptionResolver` | Description\n\n| `SimpleMappingExceptionResolver`\n| A mapping between exception class names and error view names. Useful for rendering\n error pages in a browser application.\n\n| {spring-framework-api}/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html[`DefaultHandlerExceptionResolver`]\n| Resolves exceptions raised by Spring MVC and maps them to HTTP status codes.\n See also alternative `ResponseEntityExceptionHandler` and xref:web/webmvc/mvc-ann-rest-exceptions.adoc[Error Responses].\n\n| `ResponseStatusExceptionResolver`\n| Resolves exceptions with the `@ResponseStatus` annotation and maps them to HTTP status\n codes based on the value in the annotation.\n\n| `ExceptionHandlerExceptionResolver`\n| Resolves exceptions by invoking an `@ExceptionHandler` method in a `@Controller` or a\n `@ControllerAdvice` class. See xref:web/webmvc/mvc-controller/ann-exceptionhandler.adoc[@ExceptionHandler methods].\n|===\n\n[[mvc-exceptionhandlers-handling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/exceptionhandlers.adoc", "title": "exceptionhandlers", "heading": "exceptionhandlers", "heading_level": 1, "file_order": 373, "section_index": 0, "content_hash": "cb7f4464c04635926f3b6ad68dd955c9588b102ea6d4244e2c90de526349172b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/exceptionhandlers.adoc"}}
{"id": "sha256:b044f51be1da648aa2abe87defa173ef58e0fbeba3d70575885d5172da13b61e", "content": "You can form an exception resolver chain by declaring multiple `HandlerExceptionResolver`\nbeans in your Spring configuration and setting their `order` properties as needed.\nThe higher the order property, the later the exception resolver is positioned.\n\nThe contract of `HandlerExceptionResolver` specifies that it can return:\n\n* a `ModelAndView` that points to an error view.\n* An empty `ModelAndView` if the exception was handled within the resolver.\n* `null` if the exception remains unresolved, for subsequent resolvers to try, and, if the\nexception remains at the end, it is allowed to bubble up to the Servlet container.\n\nThe xref:web/webmvc/mvc-config.adoc[MVC Config] automatically declares built-in resolvers for default Spring MVC\nexceptions, for `@ResponseStatus` annotated exceptions, and for support of\n`@ExceptionHandler` methods. You can customize that list or replace it.\n\n[[mvc-ann-customer-servlet-container-error-page]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/exceptionhandlers.adoc", "title": "exceptionhandlers", "heading": "Chain of Resolvers", "heading_level": 2, "file_order": 373, "section_index": 1, "content_hash": "b044f51be1da648aa2abe87defa173ef58e0fbeba3d70575885d5172da13b61e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/exceptionhandlers.adoc"}}
{"id": "sha256:336acfbd38be946936dc64a2e973e75dd7969a163af1ba29f356dd17861bad03", "content": "If an exception remains unresolved by any `HandlerExceptionResolver` and is, therefore,\nleft to propagate or if the response status is set to an error status (that is, 4xx, 5xx),\nServlet containers can render a default error page in HTML. To customize the default\nerror page of the container, you can declare an error page mapping in `web.xml`.\nThe following example shows how to do so:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<error-page>\n <location>/error</location>\n\t</error-page>\n----\n\nGiven the preceding example, when an exception bubbles up or the response has an error status, the\nServlet container makes an ERROR dispatch within the container to the configured URL\n(for example, `/error`). This is then processed by the `DispatcherServlet`, possibly mapping it\nto a `@Controller`, which could be implemented to return an error view name with a model\nor to render a JSON response, as the following example shows:\n\ninclude-code::./ErrorController[tag=snippet,indent=0]\n\nTIP: The Servlet API does not provide a way to create error page mappings in Java. You can,\nhowever, use both a `WebApplicationInitializer` and a minimal `web.xml`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/exceptionhandlers.adoc", "title": "exceptionhandlers", "heading": "Container Error Page", "heading_level": 2, "file_order": 373, "section_index": 2, "content_hash": "336acfbd38be946936dc64a2e973e75dd7969a163af1ba29f356dd17861bad03", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/exceptionhandlers.adoc"}}
{"id": "sha256:fcfcb4e1ded06885f6528c608aa4b2207604188241df13aa5843b1900970fd73", "content": "[[mvc-handlermapping-interceptor]]\n\nAll `HandlerMapping` implementations support handler interception which is useful when\nyou want to apply functionality across requests. A `HandlerInterceptor` can implement the\nfollowing:\n\n* `preHandle(..)` -- callback before the actual handler is run that returns a boolean.\nIf the method returns `true`, execution continues; if it returns `false`, the rest of the\nexecution chain is bypassed and the handler is not called.\n* `postHandle(..)` -- callback after the handler is run.\n* `afterCompletion(..)` -- callback after the complete request has finished.\n\nNOTE: For `@ResponseBody` and `ResponseEntity` controller methods, the response is written\nand committed within the `HandlerAdapter`, before `postHandle` is called. That means it is\ntoo late to change the response, such as to add an extra header. You can implement\n`ResponseBodyAdvice` and declare it as an\nxref:web/webmvc/mvc-controller/ann-advice.adoc[Controller Advice] bean or configure it\ndirectly on `RequestMappingHandlerAdapter`.\n\nSee xref:web/webmvc/mvc-config/interceptors.adoc[Interceptors] in the section on MVC configuration for examples of how to\nconfigure interceptors. You can also register them directly by using setters on individual\n`HandlerMapping` implementations.\n\nWARNING: Interceptors are not ideally suited as a security layer due to the potential for\na mismatch with annotated controller path matching. Generally, we recommend using Spring\nSecurity, or alternatively a similar approach integrated with the Servlet filter chain,\nand applied as early as possible.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/handlermapping-interceptor.adoc", "title": "handlermapping-interceptor", "heading": "handlermapping-interceptor", "heading_level": 1, "file_order": 374, "section_index": 0, "content_hash": "fcfcb4e1ded06885f6528c608aa4b2207604188241df13aa5843b1900970fd73", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/handlermapping-interceptor.adoc"}}
{"id": "sha256:26639a8f9877cb053cc86234373512fd72e61a8590ac5cff4c0cc58c392cb2c5", "content": "[[mvc-handlermapping-path]]\n\nThe Servlet API exposes the full request path as `requestURI` and further sub-divides it\ninto `contextPath`, `servletPath`, and `pathInfo` whose values vary depending on how a\nServlet is mapped. From these inputs, Spring MVC needs to determine the lookup path to\nuse for mapping handlers, which should exclude the `contextPath` and any `servletMapping`\nprefix, if applicable.\n\nThe `servletPath` and `pathInfo` are decoded and that makes them impossible to compare\ndirectly to the full `requestURI` in order to derive the lookupPath and that makes it\nnecessary to decode the `requestURI`. However this introduces its own issues because the\npath may contain encoded reserved characters such as `\"/\"` or `\";\"` that can in turn\nalter the structure of the path after they are decoded which can also lead to security\nissues. In addition, Servlet containers may normalize the `servletPath` to varying\ndegrees which makes it further impossible to perform `startsWith` comparisons against\nthe `requestURI`.\n\nThis is why it is best to avoid reliance on the `servletPath` which comes with the\nprefix-based `servletPath` mapping type. If the `DispatcherServlet` is mapped as the\ndefault Servlet with `\"/\"` or otherwise without a prefix with `\"/*\"` and the Servlet\ncontainer is 4.0+ then Spring MVC is able to detect the Servlet mapping type and avoid\nuse of the `servletPath` and `pathInfo` altogether. On a 3.1 Servlet container,\nassuming the same Servlet mapping types, the equivalent can be achieved by providing\na `UrlPathHelper` with `alwaysUseFullPath=true` via xref:web/webmvc/mvc-config/path-matching.adoc[Path Matching] in\nthe MVC config.\n\nFortunately the default Servlet mapping `\"/\"` is a good choice. However, there is still\nan issue in that the `requestURI` needs to be decoded to make it possible to compare to\ncontroller mappings. This is again undesirable because of the potential to decode\nreserved characters that alter the path structure. If such characters are not expected,\nthen you can reject them (like the Spring Security HTTP firewall), or you can configure\n`UrlPathHelper` with `urlDecode=false` but controller mappings will need to match to the\nencoded path which may not always work well. Furthermore, sometimes the\n`DispatcherServlet` needs to share the URL space with another Servlet and may need to\nbe mapped by prefix.\n\nThe above issues are addressed when using `PathPatternParser` and parsed patterns, as\nan alternative to String path matching with `AntPathMatcher`. The `PathPatternParser` has\nbeen available for use in Spring MVC from version 5.3, and is enabled by default from\nversion 6.0. Unlike `AntPathMatcher` which needs either the lookup path decoded or the\ncontroller mapping encoded, a parsed `PathPattern` matches to a parsed representation\nof the path called `RequestPath`, one path segment at a time. This allows decoding and\nsanitizing path segment values individually without the risk of altering the structure\nof the path. Parsed `PathPattern` also supports the use of `servletPath` prefix mapping\nas long as a Servlet path mapping is used and the prefix is kept simple, i.e. it has no\nencoded characters. For pattern syntax details and comparison, see\nxref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-pattern-comparison[Pattern Comparison].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/handlermapping-path.adoc", "title": "handlermapping-path", "heading": "handlermapping-path", "heading_level": 1, "file_order": 375, "section_index": 0, "content_hash": "26639a8f9877cb053cc86234373512fd72e61a8590ac5cff4c0cc58c392cb2c5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/handlermapping-path.adoc"}}
{"id": "sha256:81dab62cfc7e1abc4130949c429f040bf5dca26e312985e1061926f38010ec3f", "content": "[[mvc-localeresolver]]\n\nMost parts of Spring's architecture support internationalization, as the Spring web\nMVC framework does. `DispatcherServlet` lets you automatically resolve messages\nby using the client's locale. This is done with `LocaleResolver` objects.\n\nWhen a request comes in, the `DispatcherServlet` looks for a locale resolver and, if it\nfinds one, it tries to use it to set the locale. By using the `RequestContext.getLocale()`\nmethod, you can always retrieve the locale that was resolved by the locale resolver.\n\nIn addition to automatic locale resolution, you can also attach an interceptor to the\nhandler mapping (see xref:web/webmvc/mvc-servlet/handlermapping-interceptor.adoc[Interception] for more information on handler\nmapping interceptors) to change the locale under specific circumstances (for example,\nbased on a parameter in the request).\n\nLocale resolvers and interceptors are defined in the\n`org.springframework.web.servlet.i18n` package and are configured in your application\ncontext in the normal way. The following selection of locale resolvers is included in\nSpring.\n\n* xref:web/webmvc/mvc-servlet/localeresolver.adoc#mvc-timezone[Time Zone]\n* xref:web/webmvc/mvc-servlet/localeresolver.adoc#mvc-localeresolver-acceptheader[Header Resolver]\n* xref:web/webmvc/mvc-servlet/localeresolver.adoc#mvc-localeresolver-cookie[Cookie Resolver]\n* xref:web/webmvc/mvc-servlet/localeresolver.adoc#mvc-localeresolver-session[Session Resolver]\n* xref:web/webmvc/mvc-servlet/localeresolver.adoc#mvc-localeresolver-interceptor[Locale Interceptor]\n\n[[mvc-timezone]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/localeresolver.adoc", "title": "localeresolver", "heading": "localeresolver", "heading_level": 1, "file_order": 376, "section_index": 0, "content_hash": "81dab62cfc7e1abc4130949c429f040bf5dca26e312985e1061926f38010ec3f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/localeresolver.adoc"}}
{"id": "sha256:74b8cfdb20240798168fb3fb40e7befe6c0577a1a9c6d5cc726ac5f998362dfe", "content": "In addition to obtaining the client's locale, it is often useful to know its time zone.\nThe `LocaleContextResolver` interface offers an extension to `LocaleResolver` that lets\nresolvers provide a richer `LocaleContext`, which may include time zone information.\n\nWhen available, the user's `TimeZone` can be obtained by using the\n`RequestContext.getTimeZone()` method. Time zone information is automatically used\nby any Date/Time `Converter` and `Formatter` objects that are registered with Spring's\n`ConversionService`.\n\n[[mvc-localeresolver-acceptheader]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/localeresolver.adoc", "title": "localeresolver", "heading": "Time Zone", "heading_level": 2, "file_order": 376, "section_index": 1, "content_hash": "74b8cfdb20240798168fb3fb40e7befe6c0577a1a9c6d5cc726ac5f998362dfe", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/localeresolver.adoc"}}
{"id": "sha256:de42ede452740e2357287b1fb289ee13740f2a29e7e17ec753d81974ca420182", "content": "This locale resolver inspects the `accept-language` header in the request that was sent\nby the client (for example, a web browser). Usually, this header field contains the locale of\nthe client's operating system. Note that this resolver does not support time zone\ninformation.\n\n[[mvc-localeresolver-cookie]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/localeresolver.adoc", "title": "localeresolver", "heading": "Header Resolver", "heading_level": 2, "file_order": 376, "section_index": 2, "content_hash": "de42ede452740e2357287b1fb289ee13740f2a29e7e17ec753d81974ca420182", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/localeresolver.adoc"}}
{"id": "sha256:eeb6a183a66ec14f13d3a0784143b48062b64104c63e61c0aa76ffc69e94c101", "content": "This locale resolver inspects a `Cookie` that might exist on the client to see if a\n`Locale` or `TimeZone` is specified. If so, it uses the specified details. By using the\nproperties of this locale resolver, you can specify the name of the cookie as well as the\nmaximum age. The following example defines a `CookieLocaleResolver` bean:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\n[[mvc-localeresolver-session]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/localeresolver.adoc", "title": "localeresolver", "heading": "Cookie Resolver", "heading_level": 2, "file_order": 376, "section_index": 3, "content_hash": "eeb6a183a66ec14f13d3a0784143b48062b64104c63e61c0aa76ffc69e94c101", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/localeresolver.adoc"}}
{"id": "sha256:be31a558b22ffe0bc1d1fe8bd937c850b51af1e7644a6e5e9ca86a3db77ed2e5", "content": "The `SessionLocaleResolver` lets you retrieve `Locale` and `TimeZone` from the\nsession that might be associated with the user's request. In contrast to\n`CookieLocaleResolver`, this strategy stores locally chosen locale settings in the\nServlet container's `HttpSession`. As a consequence, those settings are temporary\nfor each session and are, therefore, lost when each session ends.\n\nNote that there is no direct relationship with external session management mechanisms,\nsuch as the Spring Session project. This `SessionLocaleResolver` evaluates and\nmodifies the corresponding `HttpSession` attributes against the current `HttpServletRequest`.\n\n[[mvc-localeresolver-interceptor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/localeresolver.adoc", "title": "localeresolver", "heading": "Session Resolver", "heading_level": 2, "file_order": 376, "section_index": 4, "content_hash": "be31a558b22ffe0bc1d1fe8bd937c850b51af1e7644a6e5e9ca86a3db77ed2e5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/localeresolver.adoc"}}
{"id": "sha256:edaa8e3cdb1e853f7cbcee3db8663927b759ace05b40ce12c98431a92c0f4a35", "content": "You can enable changing of locales by adding the `LocaleChangeInterceptor` to one of the\n`HandlerMapping` definitions. It detects a parameter in the request and changes the locale\naccordingly, calling the `setLocale` method on the `LocaleResolver` in the dispatcher's\napplication context. The next example shows that calls to all `{asterisk}.view` resources\nthat contain a parameter named `siteLanguage` now changes the locale. So, for example,\na request for the URL `https://domain.com/home.view?siteLanguage=nl` changes the site\nlanguage to Dutch. The following example shows how to intercept the locale:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0,chomp=-tags]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/localeresolver.adoc", "title": "localeresolver", "heading": "Locale Interceptor", "heading_level": 2, "file_order": 376, "section_index": 5, "content_hash": "edaa8e3cdb1e853f7cbcee3db8663927b759ace05b40ce12c98431a92c0f4a35", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/localeresolver.adoc"}}
{"id": "sha256:5ccf9c10434b94cece22af549c50c893c82a7443fa55425e61d2122916291235", "content": "[[mvc-logging]]\n\n[.small]#xref:web/webflux/reactive-spring.adoc#webflux-logging[See equivalent in the Reactive stack]#\n\nDEBUG-level logging in Spring MVC is designed to be compact, minimal, and\nhuman-friendly. It focuses on high-value bits of information that are useful over and\nover again versus others that are useful only when debugging a specific issue.\n\nTRACE-level logging generally follows the same principles as DEBUG (and, for example, also\nshould not be a fire hose) but can be used for debugging any issue. In addition, some log\nmessages may show a different level of detail at TRACE versus DEBUG.\n\nGood logging comes from the experience of using the logs. If you spot anything that does\nnot meet the stated goals, please let us know.\n\n[[mvc-logging-sensitive-data]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/logging.adoc", "title": "logging", "heading": "logging", "heading_level": 1, "file_order": 377, "section_index": 0, "content_hash": "5ccf9c10434b94cece22af549c50c893c82a7443fa55425e61d2122916291235", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/logging.adoc"}}
{"id": "sha256:9fb5f8c4ee505ed0de698fae13665be068ea3de14ad9f54d669ef9db600a3146", "content": "[.small]#xref:web/webflux/reactive-spring.adoc#webflux-logging-sensitive-data[See equivalent in the Reactive stack]#\n\nDEBUG and TRACE logging may log sensitive information. This is why request parameters and\nheaders are masked by default and their logging in full must be enabled explicitly\nthrough the `enableLoggingRequestDetails` property on `DispatcherServlet`.\n\nThe following example shows how to do so by using Java configuration:\n\ninclude-code::./MyInitializer[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/logging.adoc", "title": "logging", "heading": "Sensitive Data", "heading_level": 2, "file_order": 377, "section_index": 1, "content_hash": "9fb5f8c4ee505ed0de698fae13665be068ea3de14ad9f54d669ef9db600a3146", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/logging.adoc"}}
{"id": "sha256:c1cdf9ae7d8201340a2815101d3c0602694b25e676dbe154903a7041d42704b3", "content": "[[mvc-multipart]]\n\n[.small]#xref:web/webflux/reactive-spring.adoc#webflux-multipart[See equivalent in the Reactive stack]#\n\n`MultipartResolver` from the `org.springframework.web.multipart` package is a strategy\nfor parsing multipart requests including file uploads. There is a container-based\n`StandardServletMultipartResolver` implementation for Servlet multipart request parsing.\n\nTo enable multipart handling, you need to declare a `MultipartResolver` bean in your\n`DispatcherServlet` Spring configuration with a name of `multipartResolver`.\nThe `DispatcherServlet` detects it and applies it to the incoming request. When a POST\nwith a content type of `multipart/form-data` is received, the resolver parses the\ncontent wraps the current `HttpServletRequest` as a `MultipartHttpServletRequest` to\nprovide access to resolved files in addition to exposing parts as request parameters.\n\n[[mvc-multipart-resolver-standard]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/multipart.adoc", "title": "multipart", "heading": "multipart", "heading_level": 1, "file_order": 378, "section_index": 0, "content_hash": "c1cdf9ae7d8201340a2815101d3c0602694b25e676dbe154903a7041d42704b3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/multipart.adoc"}}
{"id": "sha256:f42836e17155b1434914481faab27ff2b1656ebce412630e3b82faad35b98b61", "content": "Servlet multipart parsing needs to be enabled through Servlet container configuration.\nTo do so:\n\n* In Java, set a `MultipartConfigElement` on the Servlet registration.\n* In `web.xml`, add a `\"<multipart-config>\"` section to the servlet declaration.\n\nThe following example shows how to set a `MultipartConfigElement` on the Servlet registration:\n\ninclude-code::./AppInitializer[tag=snippet,indent=0]\n\nOnce the Servlet multipart configuration is in place, you can add a bean of type\n`StandardServletMultipartResolver` with a name of `multipartResolver`.\n\n[NOTE]\n====\nThis resolver variant uses your Servlet container's multipart parser as-is,\npotentially exposing the application to container implementation differences.\nBy default, it will try to parse any `multipart/` content type with any HTTP\nmethod but this may not be supported across all Servlet containers. See the\n{spring-framework-api}/web/multipart/support/StandardServletMultipartResolver.html[`StandardServletMultipartResolver`]\njavadoc for details and configuration options.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/multipart.adoc", "title": "multipart", "heading": "Servlet Multipart Parsing", "heading_level": 2, "file_order": 378, "section_index": 1, "content_hash": "f42836e17155b1434914481faab27ff2b1656ebce412630e3b82faad35b98b61", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/multipart.adoc"}}
{"id": "sha256:6d2e2d326485abcb593b47a699897867adb8113292925aab205563c0e68e0e53", "content": "[[mvc-servlet-sequence]]\n\n[.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-dispatcher-handler-sequence[See equivalent in the Reactive stack]#\n\nThe `DispatcherServlet` processes requests as follows:\n\n* The `WebApplicationContext` is searched for and bound in the request as an attribute\n that the controller and other elements in the process can use. It is bound by default\n under the `DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE` key.\n* The locale resolver is bound to the request to let elements in the process\n resolve the locale to use when processing the request (rendering the view, preparing\n data, and so on). If you do not need locale resolving, you do not need the locale resolver.\n* If you specify a multipart file resolver, the request is inspected for multiparts. If\n multiparts are found, the request is wrapped in a `MultipartHttpServletRequest` for\n further processing by other elements in the process. See xref:web/webmvc/mvc-servlet/multipart.adoc[Multipart Resolver] for further\n information about multipart handling.\n* An appropriate handler is searched for. If a handler is found, the execution chain\n associated with the handler (preprocessors, postprocessors, and controllers) is\n run to prepare a model for rendering. Alternatively, for annotated\n controllers, the response can be rendered (within the `HandlerAdapter`) instead of\n returning a view.\n* If a model is returned, the view is rendered. If no model is returned (maybe due to\n a preprocessor or postprocessor intercepting the request, perhaps for security\n reasons), no view is rendered, because the request could already have been fulfilled.\n\nThe `HandlerExceptionResolver` beans declared in the `WebApplicationContext` are used to\nresolve exceptions thrown during request processing. Those exception resolvers allow\ncustomizing the logic to address exceptions. See xref:web/webmvc/mvc-servlet/exceptionhandlers.adoc[Exceptions] for more details.\n\nFor HTTP caching support, handlers can use the `checkNotModified` methods of `WebRequest`,\nalong with further options for annotated controllers as described in\nxref:web/webmvc/mvc-caching.adoc#mvc-caching-etag-lastmodified[HTTP Caching for Controllers].\n\nYou can customize individual `DispatcherServlet` instances by adding Servlet\ninitialization parameters (`init-param` elements) to the Servlet declaration in the\n`web.xml` file. The following table lists the supported parameters:\n\n[[mvc-disp-servlet-init-params-tbl]]\n.DispatcherServlet initialization parameters\n|===\n| Parameter| Explanation\n\n| `contextClass`\n| Class that implements `ConfigurableWebApplicationContext`, to be instantiated and\n locally configured by this Servlet. By default, `XmlWebApplicationContext` is used.\n\n| `contextConfigLocation`\n| String that is passed to the context instance (specified by `contextClass`) to\n indicate where contexts can be found. The string consists potentially of multiple\n strings (using a comma as a delimiter) to support multiple contexts. In the case of\n multiple context locations with beans that are defined twice, the latest location\n takes precedence.\n\n| `namespace`\n| Namespace of the `WebApplicationContext`. Defaults to `[servlet-name]-servlet`.\n\n| `throwExceptionIfNoHandlerFound`\n| Whether to throw a `NoHandlerFoundException` when no handler was found for a request.\n The exception can then be caught with a `HandlerExceptionResolver` (for example, by using an\n `@ExceptionHandler` controller method) and handled as any others.\n\n As of 6.1, this property is set to `true` and deprecated.\n\n Note that, if xref:web/webmvc/mvc-config/default-servlet-handler.adoc[default servlet handling] is\n also configured, unresolved requests are always forwarded to the default servlet\n and a 404 is never raised.\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/sequence.adoc", "title": "sequence", "heading": "sequence", "heading_level": 1, "file_order": 379, "section_index": 0, "content_hash": "6d2e2d326485abcb593b47a699897867adb8113292925aab205563c0e68e0e53", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/sequence.adoc"}}
{"id": "sha256:8e02bb23f449c65cbad8701676f467615429d3595c906a7aa50cfbb27caef845", "content": "[[mvc-servlet-special-bean-types]]\n\n[.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-special-bean-types[See equivalent in the Reactive stack]#\n\nThe `DispatcherServlet` delegates to special beans to process requests and render the\nappropriate responses. By \"`special beans`\" we mean Spring-managed `Object` instances that\nimplement framework contracts. Those usually come with built-in contracts, but\nyou can customize their properties and extend or replace them.\n\nThe following table lists the special beans detected by the `DispatcherServlet`:\n\n[[mvc-webappctx-special-beans-tbl]]\n[cols=\"1,2\", options=\"header\"]\n|===\n| Bean type| Explanation\n\n| `HandlerMapping`\n| Map a request to a handler along with a list of\n xref:web/webmvc/mvc-servlet/handlermapping-interceptor.adoc[interceptors] for pre- and post-processing.\n The mapping is based on some criteria, the details of which vary by `HandlerMapping`\n implementation.\n\n The two main `HandlerMapping` implementations are `RequestMappingHandlerMapping`\n (which supports `@RequestMapping` annotated methods) and `SimpleUrlHandlerMapping`\n (which maintains explicit registrations of URI path patterns to handlers).\n\n| `HandlerAdapter`\n| Help the `DispatcherServlet` to invoke a handler mapped to a request, regardless of\n how the handler is actually invoked. For example, invoking an annotated controller\n requires resolving annotations. The main purpose of a `HandlerAdapter` is\n to shield the `DispatcherServlet` from such details.\n\n| xref:web/webmvc/mvc-servlet/exceptionhandlers.adoc[`HandlerExceptionResolver`]\n| Strategy to resolve exceptions, possibly mapping them to handlers, to HTML error\n views, or other targets. See xref:web/webmvc/mvc-servlet/exceptionhandlers.adoc[Exceptions].\n\n| xref:web/webmvc/mvc-servlet/viewresolver.adoc[`ViewResolver`]\n| Resolve logical `String`-based view names returned from a handler to an actual `View`\n with which to render to the response. See xref:web/webmvc/mvc-servlet/viewresolver.adoc[View Resolution] and xref:web/webmvc-view.adoc[View Technologies].\n\n| xref:web/webmvc/mvc-servlet/localeresolver.adoc[`LocaleResolver`], xref:web/webmvc/mvc-servlet/localeresolver.adoc#mvc-timezone[LocaleContextResolver]\n| Resolve the `Locale` a client is using and possibly their time zone, in order to be able\n to offer internationalized views. See xref:web/webmvc/mvc-servlet/localeresolver.adoc[Locale].\n\n| xref:web/webmvc/mvc-servlet/multipart.adoc[`MultipartResolver`]\n| Abstraction for parsing a multi-part request (for example, browser form file upload) with\n the help of some multipart parsing library. See xref:web/webmvc/mvc-servlet/multipart.adoc[Multipart Resolver].\n\n| xref:web/webmvc/mvc-controller/ann-methods/flash-attributes.adoc[`FlashMapManager`]\n| Store and retrieve the \"`input`\" and the \"`output`\" `FlashMap` that can be used to pass\n attributes from one request to another, usually across a redirect.\n See xref:web/webmvc/mvc-controller/ann-methods/flash-attributes.adoc[Flash Attributes].\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/special-bean-types.adoc", "title": "special-bean-types", "heading": "special-bean-types", "heading_level": 1, "file_order": 380, "section_index": 0, "content_hash": "8e02bb23f449c65cbad8701676f467615429d3595c906a7aa50cfbb27caef845", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/special-bean-types.adoc"}}
{"id": "sha256:71268c940deb3f0e95b66b978fad276a6799a9c127ede2183b15d3e9ee669835", "content": "[[mvc-viewresolver]]\n\n[.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-viewresolution[See equivalent in the Reactive stack]#\n\nSpring MVC defines the `ViewResolver` and `View` interfaces that let you render\nmodels in a browser without tying you to a specific view technology. `ViewResolver`\nprovides a mapping between view names and actual views. `View` addresses the preparation\nof data before handing over to a specific view technology.\n\nThe following table provides more details on the `ViewResolver` hierarchy:\n\n[[mvc-view-resolvers-tbl]]\n.ViewResolver implementations\n|===\n| ViewResolver| Description\n\n| `AbstractCachingViewResolver`\n| Subclasses of `AbstractCachingViewResolver` cache view instances that they resolve.\n Caching improves performance of certain view technologies. You can turn off the\n cache by setting the `cache` property to `false`. Furthermore, if you must refresh\n a certain view at runtime (for example, when a FreeMarker template is modified),\n you can use the `removeFromCache(String viewName, Locale loc)` method.\n\n| `UrlBasedViewResolver`\n| Simple implementation of the `ViewResolver` interface that effects the direct\n resolution of logical view names to URLs without an explicit mapping definition.\n This is appropriate if your logical names match the names of your view resources\n in a straightforward manner, without the need for arbitrary mappings.\n\n| `InternalResourceViewResolver`\n| Convenient subclass of `UrlBasedViewResolver` that supports `InternalResourceView` (in\n effect, Servlets and JSPs) and subclasses such as `JstlView`. You can specify the view\n class for all views generated by this resolver by using `setViewClass(..)`.\n See the {spring-framework-api}/web/reactive/result/view/UrlBasedViewResolver.html[`UrlBasedViewResolver`]\n javadoc for details.\n\n| `FreeMarkerViewResolver`\n| Convenient subclass of `UrlBasedViewResolver` that supports `FreeMarkerView` and\n custom subclasses of them.\n\n| `ContentNegotiatingViewResolver`\n| Implementation of the `ViewResolver` interface that resolves a view based on the\n request file name or `Accept` header. See xref:web/webmvc/mvc-servlet/viewresolver.adoc#mvc-multiple-representations[Content Negotiation].\n\n| `BeanNameViewResolver`\n| Implementation of the `ViewResolver` interface that interprets a view name as a\n bean name in the current application context. This is a very flexible variant which\n allows for mixing and matching different view types based on distinct view names.\n Each such `View` can be defined as a bean, for example, in XML or in configuration classes.\n|===\n\n[[mvc-viewresolver-handling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/viewresolver.adoc", "title": "viewresolver", "heading": "viewresolver", "heading_level": 1, "file_order": 381, "section_index": 0, "content_hash": "71268c940deb3f0e95b66b978fad276a6799a9c127ede2183b15d3e9ee669835", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/viewresolver.adoc"}}
{"id": "sha256:1369a3e95cb24cd99d35640c9e8beb34ba2fb7839a52eb1347144843725fe5f0", "content": "[.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-viewresolution-handling[See equivalent in the Reactive stack]#\n\nYou can chain view resolvers by declaring more than one resolver bean and, if necessary, by\nsetting the `order` property to specify ordering. Remember, the higher the order property,\nthe later the view resolver is positioned in the chain.\n\nThe contract of a `ViewResolver` specifies that it can return null to indicate that the\nview could not be found. However, in the case of JSPs and `InternalResourceViewResolver`,\nthe only way to figure out if a JSP exists is to perform a dispatch through\n`RequestDispatcher`. Therefore, you must always configure an `InternalResourceViewResolver`\nto be last in the overall order of view resolvers.\n\nConfiguring view resolution is as simple as adding `ViewResolver` beans to your Spring\nconfiguration. The xref:web/webmvc/mvc-config.adoc[MVC Config] provides a dedicated configuration API for\nxref:web/webmvc/mvc-config/view-resolvers.adoc[View Resolvers] and for adding logic-less\nxref:web/webmvc/mvc-config/view-controller.adoc[View Controllers] which are useful for HTML template\nrendering without controller logic.\n\n[[mvc-redirecting-redirect-prefix]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/viewresolver.adoc", "title": "viewresolver", "heading": "Handling", "heading_level": 2, "file_order": 381, "section_index": 1, "content_hash": "1369a3e95cb24cd99d35640c9e8beb34ba2fb7839a52eb1347144843725fe5f0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/viewresolver.adoc"}}
{"id": "sha256:40bdeae11796d9b6f357590b1c5f059e6a00bb643da2aade318d288f29127383", "content": "[.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-redirecting-redirect-prefix[See equivalent in the Reactive stack]#\n\nThe special `redirect:` prefix in a view name lets you perform a redirect. The\n`UrlBasedViewResolver` (and its subclasses) recognize this as an instruction that a\nredirect is needed. The rest of the view name is the redirect URL.\n\nThe net effect is the same as if the controller had returned a `RedirectView`, but now\nthe controller itself can operate in terms of logical view names. A logical view\nname (such as `redirect:/myapp/some/resource`) redirects relative to the current\nServlet context, while a name such as `redirect:https://myhost.com/some/arbitrary/path`\nredirects to an absolute URL.\n\n[[mvc-redirecting-forward-prefix]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/viewresolver.adoc", "title": "viewresolver", "heading": "Redirecting", "heading_level": 2, "file_order": 381, "section_index": 2, "content_hash": "40bdeae11796d9b6f357590b1c5f059e6a00bb643da2aade318d288f29127383", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/viewresolver.adoc"}}
{"id": "sha256:c59441731bf22bcdc2aca82a83e1867f595da40f4ad7b0cff1d219052cbb95a5", "content": "You can also use a special `forward:` prefix for view names that are\nultimately resolved by `UrlBasedViewResolver` and subclasses. This creates an\n`InternalResourceView`, which does a `RequestDispatcher.forward()`.\nTherefore, this prefix is not useful with `InternalResourceViewResolver` and\n`InternalResourceView` (for JSPs), but it can be helpful if you use another view\ntechnology but still want to force a forward of a resource to be handled by the\nServlet/JSP engine. Note that you may also chain multiple view resolvers, instead.\n\n[[mvc-multiple-representations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/viewresolver.adoc", "title": "viewresolver", "heading": "Forwarding", "heading_level": 2, "file_order": 381, "section_index": 3, "content_hash": "c59441731bf22bcdc2aca82a83e1867f595da40f4ad7b0cff1d219052cbb95a5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/viewresolver.adoc"}}
{"id": "sha256:183b1315073b96669f58d400e4eb3c9e399080bf7920271dedd1e78a2a0bc4e4", "content": "[.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-multiple-representations[See equivalent in the Reactive stack]#\n\n{spring-framework-api}/web/servlet/view/ContentNegotiatingViewResolver.html[`ContentNegotiatingViewResolver`]\ndoes not resolve views itself but rather delegates\nto other view resolvers and selects the view that resembles the representation requested\nby the client. The representation can be determined from the `Accept` header or from a\nquery parameter (for example, `\"/path?format=pdf\"`).\n\nThe `ContentNegotiatingViewResolver` selects an appropriate `View` to handle the request\nby comparing the request media types with the media type (also known as\n`Content-Type`) supported by the `View` associated with each of its `ViewResolvers`. The\nfirst `View` in the list that has a compatible `Content-Type` returns the representation\nto the client. If a compatible view cannot be supplied by the `ViewResolver` chain,\nthe list of views specified through the `DefaultViews` property is consulted. This\nlatter option is appropriate for singleton `Views` that can render an appropriate\nrepresentation of the current resource regardless of the logical view name. The `Accept`\nheader can include wildcards (for example `text/{asterisk}`), in which case a `View` whose\n`Content-Type` is `text/xml` is a compatible match.\n\nSee xref:web/webmvc/mvc-config/view-resolvers.adoc[View Resolvers] under xref:web/webmvc/mvc-config.adoc[MVC Config] for configuration details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/viewresolver.adoc", "title": "viewresolver", "heading": "Content Negotiation", "heading_level": 2, "file_order": 381, "section_index": 4, "content_hash": "183b1315073b96669f58d400e4eb3c9e399080bf7920271dedd1e78a2a0bc4e4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet/viewresolver.adoc"}}
{"id": "sha256:e768bcba6dce39a8d83086ab8ae38c228f100a69717edc0c65fb063e8e6edc23", "content": "[[filters]]\n\n[.small]#xref:web/webflux/reactive-spring.adoc#webflux-filters[See equivalent in the Reactive stack]#\n\nIn the Servlet API, you can add a `jakarta.servlet.Filter` to apply interception-style logic\nbefore and after the rest of the processing chain of filters and the target `Servlet`.\n\nThe `spring-web` module has a number of built-in `Filter` implementations:\n\n* xref:web/webmvc/filters.adoc#filters-http-put[Form Data]\n* xref:web/webmvc/filters.adoc#filters-forwarded-headers[Forwarded Headers]\n* xref:web/webmvc/filters.adoc#filters-shallow-etag[Shallow ETag]\n* xref:web/webmvc/filters.adoc#filters-cors[CORS]\n* xref:web/webmvc/filters.adoc#filters.url-handler[URL Handler]\n\nThere are also base class implementations for use in Spring applications:\n\n* `GenericFilterBean` -- base class for a `Filter` configured as a Spring bean;\nintegrates with the Spring `ApplicationContext` lifecycle.\n* `OncePerRequestFilter` -- extension of `GenericFilterBean` that supports a single\ninvocation at the start of a request, i.e. during the `REQUEST` dispatch phase, and\nignoring further handling via `FORWARD` dispatches. The filter also provides control\nover whether the `Filter` gets involved in `ASYNC` and `ERROR` dispatches.\n\nServlet filters can be configured in `web.xml` or via Servlet annotations.\nIn a Spring Boot application , you can\n{spring-boot-docs}/how-to/webserver.html#howto.webserver.add-servlet-filter-listener.spring-bean[declare Filter's as beans]\nand Boot will have them configured.\n\n[[filters-http-put]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc", "title": "filters", "heading": "filters", "heading_level": 1, "file_order": 382, "section_index": 0, "content_hash": "e768bcba6dce39a8d83086ab8ae38c228f100a69717edc0c65fb063e8e6edc23", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc"}}
{"id": "sha256:7dc445724cbc16d1153140700a204daa908012437ee66689147f6d470bc40d6a", "content": "Browsers can submit form data only through HTTP GET or HTTP POST but non-browser clients can also\nuse HTTP PUT, PATCH, and DELETE. The Servlet API requires `ServletRequest.getParameter{asterisk}()`\nmethods to support form field access only for HTTP POST.\n\nThe `spring-web` module provides `FormContentFilter` to intercept HTTP PUT, PATCH, and DELETE\nrequests with a content type of `application/x-www-form-urlencoded`, read the form data from\nthe body of the request, and wrap the `ServletRequest` to make the form data\navailable through the `ServletRequest.getParameter{asterisk}()` family of methods.\n\n[[filters-forwarded-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc", "title": "filters", "heading": "Form Data", "heading_level": 2, "file_order": 382, "section_index": 1, "content_hash": "7dc445724cbc16d1153140700a204daa908012437ee66689147f6d470bc40d6a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc"}}
{"id": "sha256:940aee1e9ae3ac080e08ebb20588e52ed5ed50ce760be4962984d8c994966f55", "content": "[.small]#xref:web/webflux/reactive-spring.adoc#webflux-forwarded-headers[See equivalent in the Reactive stack]#\n\nAs a request goes through proxies such as load balancers the host, port, and\nscheme may change, and that makes it a challenge to create links that point to the correct\nhost, port, and scheme from a client perspective.\n\n{rfc-site}/rfc7239[RFC 7239] defines the `Forwarded` HTTP header\nthat proxies can use to provide information about the original request.\n\n[[forwarded-headers-non-standard]]\n=== Non-standard Headers\n\nThere are other non-standard headers, too, including `X-Forwarded-Host`, `X-Forwarded-Port`,\n`X-Forwarded-Proto`, `X-Forwarded-Ssl`, `X-Forwarded-Prefix`, and `X-Forwarded-For`.\n\n[[x-forwarded-host]]\n==== X-Forwarded-Host\n\nWhile not standard, https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host[`X-Forwarded-Host: <host>`]\nis a de-facto standard header that is used to communicate the original host to a\ndownstream server. For example, if a request of `https://example.com/resource` is sent to\na proxy which forwards the request to `http://localhost:8080/resource`, then a header of\n`X-Forwarded-Host: example.com` can be sent to inform the server that the original host was `example.com`.\n\n[[x-forwarded-port]]\n==== X-Forwarded-Port\n\nWhile not standard, `X-Forwarded-Port: <port>` is a de-facto standard header that is used to\ncommunicate the original port to a downstream server. For example, if a request of\n`https://example.com/resource` is sent to a proxy which forwards the request to\n`http://localhost:8080/resource`, then a header of `X-Forwarded-Port: 443` can be sent\nto inform the server that the original port was `443`.\n\n[[x-forwarded-proto]]\n==== X-Forwarded-Proto\n\nWhile not standard, https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto[`X-Forwarded-Proto: (https|http)`]\nis a de-facto standard header that is used to communicate the original protocol (for example, https / http)\nto a downstream server. For example, if a request of `https://example.com/resource` is sent to\na proxy which forwards the request to `http://localhost:8080/resource`, then a header of\n`X-Forwarded-Proto: https` can be sent to inform the server that the original protocol was `https`.\n\n[[x-forwarded-ssl]]\n==== X-Forwarded-Ssl\n\nWhile not standard, `X-Forwarded-Ssl: (on|off)` is a de-facto standard header that is used to communicate the\noriginal protocol (for example, https / https) to a downstream server. For example, if a request of\n`https://example.com/resource` is sent to a proxy which forwards the request to\n`http://localhost:8080/resource`, then a header of `X-Forwarded-Ssl: on` to inform the server that the\noriginal protocol was `https`.\n\n[[x-forwarded-prefix]]\n==== X-Forwarded-Prefix\n\nWhile not standard, https://microsoft.github.io/reverse-proxy/articles/transforms.html#defaults[`X-Forwarded-Prefix: <prefix>`]\nis a de-facto standard header that is used to communicate the original URL path prefix to a\ndownstream server.\n\nUse of `X-Forwarded-Prefix` can vary by deployment scenario, and needs to be flexible to\nallow replacing, removing, or prepending the path prefix of the target server.\n\n_Scenario 1: Override path prefix_\n\n[subs=\"-attributes\"]\n----\nhttps://example.com/api/{path} -> http://localhost:8080/app1/{path}\n----\n\nThe prefix is the start of the path before the capture group `+{path}+`. For the proxy,\nthe prefix is `/api` while for the server the prefix is `/app1`. In this case, the proxy\ncan send `X-Forwarded-Prefix: /api` to have the original prefix `/api` override the\nserver prefix `/app1`.\n\n_Scenario 2: Remove path prefix_\n\nAt times, an application may want to have the prefix removed. For example, consider the\nfollowing proxy to server mapping:\n\n[subs=\"-attributes\"]\n----\nhttps://app1.example.com/{path} -> http://localhost:8080/app1/{path}\nhttps://app2.example.com/{path} -> http://localhost:8080/app2/{path}\n----\n\nThe proxy has no prefix, while applications `app1` and `app2` have path prefixes\n`/app1` and `/app2` respectively. The proxy can send ``X-Forwarded-Prefix: `` to\nhave the empty prefix override server prefixes `/app1` and `/app2`.\n\n[NOTE]\n====\nA common case for this deployment scenario is where licenses are paid per\nproduction application server, and it is preferable to deploy multiple applications per\nserver to reduce fees. Another reason is to run more applications on the same server in\norder to share the resources required by the server to run.\n\nIn these scenarios, applications need a non-empty context root because there are multiple\napplications on the same server. However, this should not be visible in URL paths of\nthe public API where applications may use different subdomains that provides benefits\nsuch as:\n\n* Added security, for example, same origin policy\n* Independent scaling of applications (different domain points to different IP address)\n====\n\n_Scenario 3: Insert path prefix_\n\nIn other cases, it may be necessary to prepend a prefix. For example, consider the\nfollowing proxy to server mapping:\n\n[subs=\"-attributes\"]\n----\nhttps://example.com/api/app1/{path} -> http://localhost:8080/app1/{path}\n----\n\nIn this case, the proxy has a prefix of `/api/app1` and the server has a prefix of\n`/app1`. The proxy can send `X-Forwarded-Prefix: /api/app1` to have the original prefix\n`/api/app1` override the server prefix `/app1`.\n\n[[x-forwarded-for]]\n==== X-Forwarded-For\n\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/X-Forwarded-For[`X-Forwarded-For: <address>`]\nis a de-facto standard header that is used to communicate the original `InetSocketAddress` of the client to a\ndownstream server. For example, if a request is sent by a client at `[fd00:fefe:1::4]` to a proxy at\n`192.168.0.1`, the \"remote address\" information contained in the HTTP request will reflect the actual address of the\nclient, not the proxy.\n\n[[filters-forwarded-headers-non-forwardedheaderfilter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc", "title": "filters", "heading": "Forwarded Headers", "heading_level": 2, "file_order": 382, "section_index": 2, "content_hash": "940aee1e9ae3ac080e08ebb20588e52ed5ed50ce760be4962984d8c994966f55", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc"}}
{"id": "sha256:855b028703e84d424178d76eb592dc1121bd80a5ce44d39764fb978d1459f878", "content": "`ForwardedHeaderFilter` is a Servlet filter that modifies the request in order to\na) change the host, port, and scheme based on `Forwarded` headers, and b) to remove those\nheaders to eliminate further impact. The filter relies on wrapping the request, and\ntherefore it must be ordered ahead of other filters, such as `RequestContextFilter`, that\nshould work with the modified and not the original request.\n\n[[filters-forwarded-headers-security]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc", "title": "filters", "heading": "ForwardedHeaderFilter", "heading_level": 3, "file_order": 382, "section_index": 3, "content_hash": "855b028703e84d424178d76eb592dc1121bd80a5ce44d39764fb978d1459f878", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc"}}
{"id": "sha256:eaa6a4a03ce52d36a5de2e02bf286faa482a2223cd58b41b0ed67464e3f7d0a7", "content": "There are security considerations for forwarded headers since an application cannot know\nif the headers were added by a proxy, as intended, or by a malicious client. This is why\na proxy at the boundary of trust should be configured to remove untrusted `Forwarded`\nheaders that come from the outside. You can also configure the `ForwardedHeaderFilter`\nwith `removeOnly=true`, in which case it removes but does not use the headers.\n\n[[filters-forwarded-headers-dispatcher]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc", "title": "filters", "heading": "Security Considerations", "heading_level": 3, "file_order": 382, "section_index": 4, "content_hash": "eaa6a4a03ce52d36a5de2e02bf286faa482a2223cd58b41b0ed67464e3f7d0a7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc"}}
{"id": "sha256:22b066776e43df6444df59850f1b6e71c42bae0f56267acf142919cf9d33d675", "content": "In order to support xref:web/webmvc/mvc-ann-async.adoc[asynchronous requests] and error dispatches this\nfilter should be mapped with `DispatcherType.ASYNC` and also `DispatcherType.ERROR`.\nIf using Spring Framework's `AbstractAnnotationConfigDispatcherServletInitializer`\n(see xref:web/webmvc/mvc-servlet/container-config.adoc[Servlet Config]) all filters are automatically registered for all dispatch\ntypes. However if registering the filter via `web.xml` or in Spring Boot via a\n`FilterRegistrationBean` be sure to include `DispatcherType.ASYNC` and\n`DispatcherType.ERROR` in addition to `DispatcherType.REQUEST`.\n\n[[filters-shallow-etag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc", "title": "filters", "heading": "Dispatcher Types", "heading_level": 3, "file_order": 382, "section_index": 5, "content_hash": "22b066776e43df6444df59850f1b6e71c42bae0f56267acf142919cf9d33d675", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc"}}
{"id": "sha256:dc091d61c0e362810198b0acc1bf4d16b6c66480a42409f2ae72db2b3e2ff578", "content": "The `ShallowEtagHeaderFilter` filter creates a \"`shallow`\" ETag by caching the content\nwritten to the response and computing an MD5 hash from it. The next time a client sends,\nit does the same, but it also compares the computed value against the `If-None-Match`\nrequest header and, if the two are equal, returns a 304 (NOT_MODIFIED).\n\nThis strategy saves network bandwidth but not CPU, as the full response must be computed for each request.\nState-changing HTTP methods and other HTTP conditional request headers such as `If-Match` and\n`If-Unmodified-Since` are outside the scope of this filter. Other strategies at the controller level\ncan avoid the computation and have a broader support for HTTP conditional requests.\nSee xref:web/webmvc/mvc-caching.adoc[HTTP Caching].\n\nThis filter has a `writeWeakETag` parameter that configures the filter to write weak ETags\nsimilar to the following: `W/\"02a2d595e6ed9a0b24f027f2b63b134d6\"` (as defined in\n{rfc-site}/rfc7232#section-2.3[RFC 7232 Section 2.3]).\n\nIn order to support xref:web/webmvc/mvc-ann-async.adoc[asynchronous requests] this filter must be mapped\nwith `DispatcherType.ASYNC` so that the filter can delay and successfully generate an\nETag to the end of the last async dispatch. If using Spring Framework's\n`AbstractAnnotationConfigDispatcherServletInitializer` (see xref:web/webmvc/mvc-servlet/container-config.adoc[Servlet Config])\nall filters are automatically registered for all dispatch types. However if registering\nthe filter via `web.xml` or in Spring Boot via a `FilterRegistrationBean` be sure to include\n`DispatcherType.ASYNC`.\n\n[[filters-cors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc", "title": "filters", "heading": "Shallow ETag", "heading_level": 2, "file_order": 382, "section_index": 6, "content_hash": "dc091d61c0e362810198b0acc1bf4d16b6c66480a42409f2ae72db2b3e2ff578", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc"}}
{"id": "sha256:1bc581991ebfef678275c75923b171b447963f952f7d5c438d703a65a730e591", "content": "[.small]#xref:web/webflux/reactive-spring.adoc#webflux-filters-cors[See equivalent in the Reactive stack]#\n\nSpring MVC provides fine-grained support for CORS configuration through annotations on\ncontrollers. However, when used with Spring Security, we advise relying on the built-in\n`CorsFilter` that must be ordered ahead of Spring Security's chain of filters.\n\nSee the sections on xref:web/webmvc-cors.adoc[CORS] and the xref:web/webmvc-cors.adoc#mvc-cors-filter[CORS Filter] for more details.\n\n[[filters.url-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc", "title": "filters", "heading": "CORS", "heading_level": 2, "file_order": 382, "section_index": 7, "content_hash": "1bc581991ebfef678275c75923b171b447963f952f7d5c438d703a65a730e591", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc"}}
{"id": "sha256:e0b2426c60a15f3d577c874b22013e209bcc2fcb51c03c957264891a4a7aa0e3", "content": "[.small]#xref:web/webflux/reactive-spring.adoc#filters.url-handler[See equivalent in the Reactive stack]#\n\nYou may want your controller endpoints to match routes with or without a trailing slash in the URL path.\nFor example, both \"GET /home\" and \"GET /home/\" should be handled by a controller method annotated with `@GetMapping(\"/home\")`.\n\nSpring provides `UrlHandlerFilter` that removes the trailing slash from URL paths to ensure a consistent view of paths with or without a trailing slash.\nThis is important to avoid a mismatch between URL-based authorization decisions and web framework request mappings.\nThe filter can remove the trailing slash in one of a couple of ways:\n\n* respond with an HTTP redirect status that sends clients to the same path without a trailing slash.\n* wrap the request to remove the trailing slash.\n\nNOTE: Historically Spring MVC supported trailing slash matching of URL paths.\nThis capability was deprecated in 6.0 for security reasons and removed in 7.0 with\n`UrlHandlerFilter` providing a safer alternative.\n\nHere is how you can instantiate and configure a `UrlHandlerFilter` for a blog application:\n\ninclude-code::./UrlHandlerFilterConfiguration[tag=config,indent=0]\n\nKeep in mind the following:\n\n- the root path `\"/\"` is excluded from trailing slash handling.\n- `@RequestMapping(\"/\")` adds a trailing slash to a type-level mapping, and therefore will\nnot map when trailing slash handling applies; use `@RequestMapping` (no path attribute) instead.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc", "title": "filters", "heading": "URL Handler", "heading_level": 2, "file_order": 382, "section_index": 8, "content_hash": "e0b2426c60a15f3d577c874b22013e209bcc2fcb51c03c957264891a4a7aa0e3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/filters.adoc"}}
{"id": "sha256:520bc19ec1a0749afe3a0212c63f7a7a2834bbc561b878b4634abc0ab1bbfd1b", "content": "[[message-converters]]\n\n[.small]#xref:web/webflux/reactive-spring.adoc#webflux-codecs[See equivalent in the Reactive stack]#\n\nThe `spring-web` module contains the `HttpMessageConverter` interface for reading and writing the body of HTTP requests and responses through `InputStream` and `OutputStream`.\n`HttpMessageConverter` instances are used on the client side (for example, in the `RestClient`) and on the server side (for example, in Spring MVC REST controllers).\n\nConcrete implementations for the main media (MIME) types are provided in the framework and are, by default, registered with the `RestClient` and `RestTemplate` on the client side and with `RequestMappingHandlerAdapter` on the server side (see xref:web/webmvc/mvc-config/message-converters.adoc[Configuring Message Converters]).\n\nSeveral implementations of `HttpMessageConverter` are described below.\nRefer to the {spring-framework-api}/http/converter/HttpMessageConverter.html[`HttpMessageConverter` Javadoc] for the complete list.\nFor all converters, a default media type is used, but you can override it by setting the `supportedMediaTypes` property.\n\n[[rest-message-converters-tbl]]\n.HttpMessageConverter Implementations\n[cols=\"1,3\"]\n|===\n| MessageConverter | Description\n\n| `StringHttpMessageConverter`\n| An `HttpMessageConverter` implementation that can read and write `String` instances from the HTTP request and response.\nBy default, this converter supports all text media types(`text/{asterisk}`) and writes with a `Content-Type` of `text/plain`.\n\n| `FormHttpMessageConverter`\n| An `HttpMessageConverter` implementation that can read and write form data from the HTTP request and response.\nBy default, this converter reads and writes the `application/x-www-form-urlencoded` media type.\nForm data is read from and written into a `MultiValueMap<String, String>`.\nThe converter can also write (but not read) multipart data read from a `MultiValueMap<String, Object>`.\nBy default, `multipart/form-data` is supported.\nAdditional multipart subtypes can be supported for writing form data.\nConsult the javadoc for `FormHttpMessageConverter` for further details.\n\n| `ByteArrayHttpMessageConverter`\n| An `HttpMessageConverter` implementation that can read and write byte arrays from the HTTP request and response.\nBy default, this converter supports all media types (`{asterisk}/{asterisk}`) and writes with a `Content-Type` of `application/octet-stream`.\nYou can override this by setting the `supportedMediaTypes` property and overriding `getContentType(byte[])`.\n\n| `MarshallingHttpMessageConverter`\n| An `HttpMessageConverter` implementation that can read and write XML by using Spring's `Marshaller` and `Unmarshaller` abstractions from the `org.springframework.oxm` package.\nThis converter requires a `Marshaller` and `Unmarshaller` before it can be used.\nYou can inject these through constructor or bean properties.\nBy default, this converter supports `text/xml` and `application/xml`.\n\n| `JacksonJsonHttpMessageConverter`\n| An `HttpMessageConverter` implementation that can read and write JSON by using Jackson's `JsonMapper`.\nYou can customize JSON mapping as needed through the use of Jackson's provided annotations.\nWhen you need further control (for cases where custom JSON serializers/deserializers need to be provided for specific types), you can inject a custom `JsonMapper` through the `JsonMapper` or `JsonMapper.Builder` constructor parameters.\nBy default, this converter supports `application/json`. This requires the `tools.jackson.core:jackson-databind` dependency.\n\n| `JacksonXmlHttpMessageConverter`\n| An `HttpMessageConverter` implementation that can read and write XML by using {jackson-github-org}/jackson-dataformat-xml[Jackson XML] extension's `XmlMapper`.\nYou can customize XML mapping as needed through the use of JAXB or Jackson's provided annotations.\nWhen you need further control (for cases where custom XML serializers/deserializers need to be provided for specific types), you can inject a custom `XmlMapper` through the `JsonMapper` or `JsonMapper.Builder` constructor parameters.\nBy default, this converter supports `application/xml`. This requires the `tools.jackson.dataformat:jackson-dataformat-xml` dependency.\n\n| `KotlinSerializationJsonHttpMessageConverter`\n| An `HttpMessageConverter` implementation that can read and write JSON using `kotlinx.serialization`.\nThis converter is not configured by default, as this conflicts with Jackson.\nDevelopers must configure it as an additional converter ahead of the Jackson one.\n\n| `JacksonCborHttpMessageConverter`\n| `tools.jackson.dataformat:jackson-dataformat-cbor`\n\n| `SourceHttpMessageConverter`\n| An `HttpMessageConverter` implementation that can read and write `javax.xml.transform.Source` from the HTTP request and response.\nOnly `DOMSource`, `SAXSource`, and `StreamSource` are supported.\nBy default, this converter supports `text/xml` and `application/xml`.\n\n| `GsonHttpMessageConverter`\n| An `HttpMessageConverter` implementation that can read and write JSON by using \"Google Gson\".\nThis requires the `com.google.code.gson:gson` dependency.\n\n| `JsonbHttpMessageConverter`\n| An `HttpMessageConverter` implementation that can read and write JSON by using the Jakarta Json Bind API.\nThis requires the `jakarta.json.bind:jakarta.json.bind-api` dependency and an implementation available.\n\n| `ProtobufHttpMessageConverter`\n| An `HttpMessageConverter` implementation that can read and write Protobuf messages in binary format with the `\"application/x-protobuf\"`\ncontent type. This requires the `com.google.protobuf:protobuf-java` dependency.\n\n| `ProtobufJsonFormatHttpMessageConverter`\n| An `HttpMessageConverter` implementation that can read and write JSON documents to and from Protobuf messages.\nThis requires the `com.google.protobuf:protobuf-java-util` dependency.\n\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/message-converters.adoc", "title": "message-converters", "heading": "message-converters", "heading_level": 1, "file_order": 383, "section_index": 0, "content_hash": "520bc19ec1a0749afe3a0212c63f7a7a2834bbc561b878b4634abc0ab1bbfd1b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/message-converters.adoc"}}
{"id": "sha256:3fff95b2143618e766b811dd913e93ac9d092fb000e66b1b36c7d9716779696d", "content": "[[mvc-ann-async]]\n\nSpring MVC has an extensive integration with Servlet asynchronous request\nxref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-processing[processing]:\n\n* xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-deferredresult[`DeferredResult`],\nxref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-callable[`Callable`], and\nxref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-webasynctask[`WebAsyncTask`] return values\nin controller methods provide support for a single asynchronous return value.\n* Controllers can xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-http-streaming[stream] multiple values, including\nxref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-sse[SSE] and\nxref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-output-stream[raw data].\n* Controllers can use reactive clients and return\nxref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-reactive-types[reactive types] for response handling.\n\nFor an overview of how this differs from Spring WebFlux, see the xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-vs-webflux[Async Spring MVC compared to WebFlux] section below.\n\n[[mvc-ann-async-deferredresult]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "mvc-ann-async", "heading_level": 1, "file_order": 384, "section_index": 0, "content_hash": "3fff95b2143618e766b811dd913e93ac9d092fb000e66b1b36c7d9716779696d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:a71a0a114a7e6b6fe74a1b826f19b4d152ab160aff25a5c6270c301563a448b7", "content": "Once the asynchronous request processing feature is xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-configuration[enabled]\nin the Servlet container, controller methods can wrap any supported controller method\nreturn value with `DeferredResult`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/quotes\")\n\t@ResponseBody\n\tpublic DeferredResult<String> quotes() {\n DeferredResult<String> deferredResult = new DeferredResult<>();\n // Save the deferredResult somewhere..\n return deferredResult;\n\t}\n\n\t// From some other thread...\n\tdeferredResult.setResult(result);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/quotes\")\n\t@ResponseBody\n\tfun quotes(): DeferredResult<String> {\n val deferredResult = DeferredResult<String>()\n // Save the deferredResult somewhere..\n return deferredResult\n\t}\n\n\t// From some other thread...\n\tdeferredResult.setResult(result)\n----\n======\n\nThe controller can produce the return value asynchronously, from a different thread -- for\nexample, in response to an external event (JMS message), a scheduled task, or other event.\n\n[[mvc-ann-async-callable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "`DeferredResult`", "heading_level": 2, "file_order": 384, "section_index": 1, "content_hash": "a71a0a114a7e6b6fe74a1b826f19b4d152ab160aff25a5c6270c301563a448b7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:fe930b1a3866b2b3ad33ec05ca225530d86073abc292e72589e9d7ff53ec4215", "content": "A controller can wrap any supported return value with `java.util.concurrent.Callable`,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping\n\tpublic Callable<String> processUpload(final MultipartFile file) {\n return () -> \"someView\";\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@PostMapping\n\tfun processUpload(file: MultipartFile) = Callable<String> {\n // ...\n \"someView\"\n\t}\n----\n======\n\nThe return value can then be obtained by running the given task through the\nxref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-configuration-spring-mvc[configured] `AsyncTaskExecutor`.\n\n[[mvc-ann-async-webasynctask]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "`Callable`", "heading_level": 2, "file_order": 384, "section_index": 2, "content_hash": "fe930b1a3866b2b3ad33ec05ca225530d86073abc292e72589e9d7ff53ec4215", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:c6b1463bb4a6a276dc2edffe17190448ae6018bf0bbbd13eaf08b38c8aba95e1", "content": "`WebAsyncTask` is comparable to using xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-callable[Callable]\nbut allows customizing additional settings such a request timeout value, and the\n`AsyncTaskExecutor` to execute the `java.util.concurrent.Callable` with instead\nof the defaults set up globally for Spring MVC. Below is an example of using `WebAsyncTask`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/callable\")\n\tWebAsyncTask<String> handle() {\n return new WebAsyncTask<String>(20000L,()->{\n Thread.sleep(10000); //simulate long-running task\n return \"asynchronous request completed\";\n });\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n@GetMapping(\"/callable\")\nfun handle(): WebAsyncTask<String> {\n return WebAsyncTask(20000L) {\n Thread.sleep(10000) // simulate long-running task\n \"asynchronous request completed\"\n }\n}\n----\n======\n\n[[mvc-ann-async-processing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "`WebAsyncTask`", "heading_level": 2, "file_order": 384, "section_index": 3, "content_hash": "c6b1463bb4a6a276dc2edffe17190448ae6018bf0bbbd13eaf08b38c8aba95e1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:83cdc042a9fb577740674c3edf7618db08240ce5992709ad79c7a6df0bdaaa93", "content": "Here is a very concise overview of Servlet asynchronous request processing:\n\n* A `ServletRequest` can be put in asynchronous mode by calling `request.startAsync()`.\n The main effect of doing so is that the Servlet (as well as any filters) can exit, but\n the response remains open to let processing complete later.\n* The call to `request.startAsync()` returns `AsyncContext`, which you can use for\n further control over asynchronous processing. For example, it provides the `dispatch` method,\n which is similar to a forward from the Servlet API, except that it lets an\n application resume request processing on a Servlet container thread.\n* The `ServletRequest` provides access to the current `DispatcherType`, which you can\n use to distinguish between processing the initial request, an asynchronous\n dispatch, a forward, and other dispatcher types.\n\n`DeferredResult` processing works as follows:\n\n* The controller returns a `DeferredResult` and saves it in some in-memory\n queue or list where it can be accessed.\n* Spring MVC calls `request.startAsync()`.\n* Meanwhile, the `DispatcherServlet` and all configured filters exit the request\n processing thread, but the response remains open.\n* The application sets the `DeferredResult` from some thread, and Spring MVC\n dispatches the request back to the Servlet container.\n* The `DispatcherServlet` is invoked again, and processing resumes with the\n asynchronously produced return value.\n\n`Callable` processing works as follows:\n\n* The controller returns a `Callable`.\n* Spring MVC calls `request.startAsync()` and submits the `Callable` to\n an `AsyncTaskExecutor` for processing in a separate thread.\n* Meanwhile, the `DispatcherServlet` and all filters exit the Servlet container thread,\n but the response remains open.\n* Eventually the `Callable` produces a result, and Spring MVC dispatches the request back\n to the Servlet container to complete processing.\n* The `DispatcherServlet` is invoked again, and processing resumes with the\n asynchronously produced return value from the `Callable`.\n\nFor further background and context, you can also read\n{spring-site-blog}/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support[the\nblog posts] that introduced asynchronous request processing support in Spring MVC 3.2.\n\n[[mvc-ann-async-exceptions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "Processing", "heading_level": 2, "file_order": 384, "section_index": 4, "content_hash": "83cdc042a9fb577740674c3edf7618db08240ce5992709ad79c7a6df0bdaaa93", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:80ea448acf952b531f72360364cb4054f770f53a48135c2a36dfd36ec5f135ea", "content": "When you use a `DeferredResult`, you can choose whether to call `setResult` or\n`setErrorResult` with an exception. In both cases, Spring MVC dispatches the request back\nto the Servlet container to complete processing. It is then treated either as if the\ncontroller method returned the given value or as if it produced the given exception.\nThe exception then goes through the regular exception handling mechanism (for example, invoking\n`@ExceptionHandler` methods).\n\nWhen you use `Callable`, similar processing logic occurs, the main difference being that\nthe result is returned from the `Callable` or an exception is raised by it.\n\n[[mvc-ann-async-interception]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "Exception Handling", "heading_level": 3, "file_order": 384, "section_index": 5, "content_hash": "80ea448acf952b531f72360364cb4054f770f53a48135c2a36dfd36ec5f135ea", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:4767101ad355796db502af129c6fc49f39bc5d1f7855514c610795e648588c38", "content": "`HandlerInterceptor` instances can be of type `AsyncHandlerInterceptor`, to receive the\n`afterConcurrentHandlingStarted` callback on the initial request that starts asynchronous\nprocessing (instead of `postHandle` and `afterCompletion`).\n\n`HandlerInterceptor` implementations can also register a `CallableProcessingInterceptor`\nor a `DeferredResultProcessingInterceptor`, to integrate more deeply with the\nlifecycle of an asynchronous request (for example, to handle a timeout event). See\n{spring-framework-api}/web/servlet/AsyncHandlerInterceptor.html[`AsyncHandlerInterceptor`]\nfor more details.\n\n`DeferredResult` provides `onTimeout(Runnable)` and `onCompletion(Runnable)` callbacks.\nSee the {spring-framework-api}/web/context/request/async/DeferredResult.html[javadoc of `DeferredResult`]\nfor more details. `Callable` can be substituted for `WebAsyncTask` that exposes additional\nmethods for timeout and completion callbacks.\n\n[[mvc-ann-async-vs-webflux]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "Interception", "heading_level": 3, "file_order": 384, "section_index": 6, "content_hash": "4767101ad355796db502af129c6fc49f39bc5d1f7855514c610795e648588c38", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:931e4c88977a35aec4fc8abdd3de9488552d16278eae8ddcb71363366f1c03d4", "content": "The Servlet API was originally built for making a single pass through the Filter-Servlet\nchain. Asynchronous request processing lets applications exit the Filter-Servlet chain\nbut leave the response open for further processing. The Spring MVC asynchronous support\nis built around that mechanism. When a controller returns a `DeferredResult`, the\nFilter-Servlet chain is exited, and the Servlet container thread is released. Later, when\nthe `DeferredResult` is set, an `ASYNC` dispatch (to the same URL) is made, during which the\ncontroller is mapped again but, rather than invoking it, the `DeferredResult` value is used\n(as if the controller returned it) to resume processing.\n\nBy contrast, Spring WebFlux is neither built on the Servlet API, nor does it need such an\nasynchronous request processing feature, because it is asynchronous by design. Asynchronous\nhandling is built into all framework contracts and is intrinsically supported through all\nstages of request processing.\n\nFrom a programming model perspective, both Spring MVC and Spring WebFlux support\nasynchronous and xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-reactive-types[Reactive Types] as return values in controller methods.\nSpring MVC even supports streaming, including reactive back pressure. However, individual\nwrites to the response remain blocking (and are performed on a separate thread), unlike WebFlux,\nwhich relies on non-blocking I/O and does not need an extra thread for each write.\n\nAnother fundamental difference is that Spring MVC does not support asynchronous or reactive\ntypes in controller method arguments (for example, `@RequestBody`, `@RequestPart`, and others),\nnor does it have any explicit support for asynchronous and reactive types as model attributes.\nSpring WebFlux does support all that.\n\nFinally, from a configuration perspective the asynchronous request processing feature must be\nxref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-configuration[enabled at the Servlet container level].\n\n[[mvc-ann-async-http-streaming]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "Async Spring MVC compared to WebFlux", "heading_level": 3, "file_order": 384, "section_index": 7, "content_hash": "931e4c88977a35aec4fc8abdd3de9488552d16278eae8ddcb71363366f1c03d4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:bc7869771d5941e83696ef508caf408b3c391fb926d133c04827ea26ac528c6c", "content": "[.small]#xref:web/webflux/reactive-spring.adoc#webflux-codecs-streaming[See equivalent in the Reactive stack]#\n\nYou can use `DeferredResult` and `Callable` for a single asynchronous return value.\nWhat if you want to produce multiple asynchronous values and have those written to the\nresponse? This section describes how to do so.\n\n[[mvc-ann-async-objects]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "HTTP Streaming", "heading_level": 2, "file_order": 384, "section_index": 8, "content_hash": "bc7869771d5941e83696ef508caf408b3c391fb926d133c04827ea26ac528c6c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:2016a5ca727504469cd03473e792d0771483b02433c8c1c81b68eb9de367a171", "content": "You can use the `ResponseBodyEmitter` return value to produce a stream of objects, where\neach object is serialized with an\nxref:integration/rest-clients.adoc#rest-message-conversion[`HttpMessageConverter`] and written to the\nresponse, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/events\")\n\tpublic ResponseBodyEmitter handle() {\n ResponseBodyEmitter emitter = new ResponseBodyEmitter();\n // Save the emitter somewhere..\n return emitter;\n\t}\n\n\t// In some other thread\n\temitter.send(\"Hello once\");\n\n\t// and again later on\n\temitter.send(\"Hello again\");\n\n\t// and done at some point\n\temitter.complete();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/events\")\n\tfun handle() = ResponseBodyEmitter().apply {\n // Save the emitter somewhere..\n\t}\n\n\t// In some other thread\n\temitter.send(\"Hello once\")\n\n\t// and again later on\n\temitter.send(\"Hello again\")\n\n\t// and done at some point\n\temitter.complete()\n----\n======\n\nYou can also use `ResponseBodyEmitter` as the body in a `ResponseEntity`, letting you\ncustomize the status and headers of the response.\n\nWhen an `emitter` throws an `IOException` (for example, if the remote client went away), applications\nare not responsible for cleaning up the connection and should not invoke `emitter.complete`\nor `emitter.completeWithError`. Instead, the servlet container automatically initiates an\n`AsyncListener` error notification, in which Spring MVC makes a `completeWithError` call.\nThis call, in turn, performs one final `ASYNC` dispatch to the application, during which Spring MVC\ninvokes the configured exception resolvers and completes the request.\n\n[[mvc-ann-async-sse]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "Objects", "heading_level": 3, "file_order": 384, "section_index": 9, "content_hash": "2016a5ca727504469cd03473e792d0771483b02433c8c1c81b68eb9de367a171", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:efc7a3e79514745512186cf48704467be97e070a4423f69bab1dea639a4b294d", "content": "`SseEmitter` (a subclass of `ResponseBodyEmitter`) provides support for\nhttps://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events], where events sent from the server\nare formatted according to the W3C SSE specification. To produce an SSE\nstream from a controller, return `SseEmitter`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(path=\"/events\", produces=MediaType.TEXT_EVENT_STREAM_VALUE)\n\tpublic SseEmitter handle() {\n SseEmitter emitter = new SseEmitter();\n // Save the emitter somewhere..\n return emitter;\n\t}\n\n\t// In some other thread\n\temitter.send(\"Hello once\");\n\n\t// and again later on\n\temitter.send(\"Hello again\");\n\n\t// and done at some point\n\temitter.complete();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/events\", produces = [MediaType.TEXT_EVENT_STREAM_VALUE])\n\tfun handle() = SseEmitter().apply {\n // Save the emitter somewhere..\n\t}\n\n\t// In some other thread\n\temitter.send(\"Hello once\")\n\n\t// and again later on\n\temitter.send(\"Hello again\")\n\n\t// and done at some point\n\temitter.complete()\n----\n======\n\nWhile SSE is the main option for streaming into browsers, note that Internet Explorer\ndoes not support Server-Sent Events. Consider using Spring's\nxref:web/websocket.adoc[WebSocket messaging] with\nxref:web/websocket/fallback.adoc[SockJS fallback] transports (including SSE) that target\na wide range of browsers.\n\nSee also xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-objects[previous section] for notes on exception handling.\n\n[[mvc-ann-async-output-stream]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "SSE", "heading_level": 3, "file_order": 384, "section_index": 10, "content_hash": "efc7a3e79514745512186cf48704467be97e070a4423f69bab1dea639a4b294d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:26ff4bd31bbca884e9b13bc189ec1a5974aa32c58702cbe62bb0f12b0ce766bc", "content": "Sometimes, it is useful to bypass message conversion and stream directly to the response\n`OutputStream` (for example, for a file download). You can use the `StreamingResponseBody`\nreturn value type to do so, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/download\")\n\tpublic StreamingResponseBody handle() {\n return new StreamingResponseBody() {\n @Override\n public void writeTo(OutputStream outputStream) throws IOException {\n // write...\n }\n };\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/download\")\n\tfun handle() = StreamingResponseBody {\n // write...\n\t}\n----\n======\n\nYou can use `StreamingResponseBody` as the body in a `ResponseEntity` to\ncustomize the status and headers of the response.\n\n[[mvc-ann-async-reactive-types]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "Raw Data", "heading_level": 3, "file_order": 384, "section_index": 11, "content_hash": "26ff4bd31bbca884e9b13bc189ec1a5974aa32c58702cbe62bb0f12b0ce766bc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:6c117dc0f0c4c9548375937dfa577b3ae5a1d9f9bfe375d81a6ac06e564486b8", "content": "[.small]#xref:web/webflux/reactive-spring.adoc#webflux-codecs-streaming[See equivalent in the Reactive stack]#\n\nSpring MVC supports use of reactive client libraries in a controller (also read\nxref:web/webflux-reactive-libraries.adoc[Reactive Libraries] in the WebFlux section).\nThis includes the `WebClient` from `spring-webflux` and others, such as Spring Data\nreactive data repositories. In such scenarios, it is convenient to be able to return\nreactive types from the controller method.\n\nReactive return values are handled as follows:\n\n* A single-value promise is adapted to, similar to using `DeferredResult`. Examples\ninclude `CompletionStage` (JDK), `Mono` (Reactor), and `Single` (RxJava).\n* A multi-value stream with a streaming media type (such as `application/x-ndjson`\nor `text/event-stream`) is adapted to, similar to using `ResponseBodyEmitter` or\n`SseEmitter`. Examples include `Flux` (Reactor) or `Observable` (RxJava).\nApplications can also return `Flux<ServerSentEvent>` or `Observable<ServerSentEvent>`.\n* A multi-value stream with any other media type (such as `application/json`) is adapted\nto, similar to using `DeferredResult<List<?>>`.\n\nTIP: Spring MVC supports Reactor and RxJava through the\n{spring-framework-api}/core/ReactiveAdapterRegistry.html[`ReactiveAdapterRegistry`] from\n`spring-core`, which lets it adapt from multiple reactive libraries.\n\nFor streaming to the response, reactive back pressure is supported, but writes to the\nresponse are still blocking and are run on a separate thread through the\nxref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-configuration-spring-mvc[configured]\n`AsyncTaskExecutor`, to avoid blocking the upstream source such as a `Flux` returned\nfrom `WebClient`.\n\n[[mvc-ann-async-context-propagation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "Reactive Types", "heading_level": 2, "file_order": 384, "section_index": 12, "content_hash": "6c117dc0f0c4c9548375937dfa577b3ae5a1d9f9bfe375d81a6ac06e564486b8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:c11b60563704ab5cfd6eec547c8737edfab1c68f9d041c8970ef019c0ac5de16", "content": "It is common to propagate context via `java.lang.ThreadLocal`. This works transparently\nfor handling on the same thread, but requires additional work for asynchronous handling\nacross multiple threads. The Micrometer\nhttps://github.com/micrometer-metrics/context-propagation#context-propagation-library[Context Propagation]\nlibrary simplifies context propagation across threads, and across context mechanisms such\nas `ThreadLocal` values,\nReactor {reactor-site}/docs/core/release/reference/#context[context],\nGraphQL Java https://www.graphql-java.com/documentation/concerns/#context-objects[context],\nand others.\n\nIf Micrometer Context Propagation is present on the classpath, when a controller method\nreturns a xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-reactive-types[reactive type] such as `Flux` or `Mono`, all\n`ThreadLocal` values, for which there is a registered `io.micrometer.ThreadLocalAccessor`,\nare written to the Reactor `Context` as key-value pairs, using the key assigned by the\n`ThreadLocalAccessor`.\n\nFor other asynchronous handling scenarios, you can use the Context Propagation library\ndirectly. For example:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n.Java\n----\n\t// Capture ThreadLocal values from the main thread ...\n\tContextSnapshot snapshot = ContextSnapshot.captureAll();\n\n\t// On a different thread: restore ThreadLocal values\n\ttry (ContextSnapshot.Scope scope = snapshot.setThreadLocals()) {\n // ...\n\t}\n----\n\nThe following `ThreadLocalAccessor` implementations are provided out of the box:\n\n* `LocaleContextThreadLocalAccessor` -- propagates `LocaleContext` via `LocaleContextHolder`\n* `RequestAttributesThreadLocalAccessor` -- propagates `RequestAttributes` via `RequestContextHolder`\n\nThe above are not registered automatically. You need to register them via `ContextRegistry.getInstance()` on startup.\n\nFor more details, see the {micrometer-context-propagation-docs}/[documentation] of the\nMicrometer Context Propagation library.\n\n[[mvc-ann-async-disconnects]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "Context Propagation", "heading_level": 2, "file_order": 384, "section_index": 13, "content_hash": "c11b60563704ab5cfd6eec547c8737edfab1c68f9d041c8970ef019c0ac5de16", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:d0ba71050e12d8c9cb8c43f616b2a8d1c290c99b241e96d98c961dc32fa16237", "content": "[.small]#xref:web/webflux/reactive-spring.adoc#webflux-codecs-streaming[See equivalent in the Reactive stack]#\n\nThe Servlet API does not provide any notification when a remote client goes away.\nTherefore, while streaming to the response, whether through xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-sse[SseEmitter]\nor xref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-reactive-types[reactive types], it is important to send data periodically,\nsince the write fails if the client has disconnected. The send could take the form of an\nempty (comment-only) SSE event or any other data that the other side would have to interpret\nas a heartbeat and ignore.\n\nAlternatively, consider using web messaging solutions (such as\nxref:web/websocket/stomp.adoc[STOMP over WebSocket] or WebSocket with xref:web/websocket/fallback.adoc[SockJS])\nthat have a built-in heartbeat mechanism.\n\n[[mvc-ann-async-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "Disconnects", "heading_level": 2, "file_order": 384, "section_index": 14, "content_hash": "d0ba71050e12d8c9cb8c43f616b2a8d1c290c99b241e96d98c961dc32fa16237", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:e18d4f5921ab9cde4a4ac45f0751ae9ff88a6a705e233e36f9293c6b8eb37064", "content": "The asynchronous request processing feature must be enabled at the Servlet container level.\nThe MVC configuration also exposes several options for asynchronous requests.\n\n[[mvc-ann-async-configuration-servlet3]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "Configuration", "heading_level": 2, "file_order": 384, "section_index": 15, "content_hash": "e18d4f5921ab9cde4a4ac45f0751ae9ff88a6a705e233e36f9293c6b8eb37064", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:ff99faa18e491f5bb7c18d4712511c8ff328d84709aed72026b12db6847861f0", "content": "Filter and Servlet declarations have an `asyncSupported` flag that needs to be set to `true`\nto enable asynchronous request processing. In addition, Filter mappings should be\ndeclared to handle the `ASYNC` `jakarta.servlet.DispatchType`.\n\nIn Java configuration, when you use `AbstractAnnotationConfigDispatcherServletInitializer`\nto initialize the Servlet container, this is done automatically.\n\nIn `web.xml` configuration, you can add `<async-supported>true</async-supported>` to the\n`DispatcherServlet` and to `Filter` declarations and add\n`<dispatcher>ASYNC</dispatcher>` to filter mappings.\n\n[[mvc-ann-async-configuration-spring-mvc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "Servlet Container", "heading_level": 3, "file_order": 384, "section_index": 16, "content_hash": "ff99faa18e491f5bb7c18d4712511c8ff328d84709aed72026b12db6847861f0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:6566be3c8371b86d4d39979ef688a136bba4229bdea68702f84a11205af18011", "content": "The MVC configuration exposes the following options for asynchronous request processing:\n\n* Java configuration: Use the `configureAsyncSupport` callback on `WebMvcConfigurer`.\n* XML namespace: Use the `<async-support>` element under `<mvc:annotation-driven>`.\n\nYou can configure the following:\n\n* The default timeout value for async requests depends\non the underlying Servlet container, unless it is set explicitly.\n* `AsyncTaskExecutor` to use for blocking writes when streaming with\nxref:web/webmvc/mvc-ann-async.adoc#mvc-ann-async-reactive-types[Reactive Types] and for\nexecuting `Callable` instances returned from controller methods.\nThe one used by default is not suitable for production under load.\n* `DeferredResultProcessingInterceptor` implementations and `CallableProcessingInterceptor` implementations.\n\nNote that you can also set the default timeout value on a `DeferredResult`,\na `ResponseBodyEmitter`, and an `SseEmitter`. For a `Callable`, you can use\n`WebAsyncTask` to provide a timeout value.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc", "title": "mvc-ann-async", "heading": "Spring MVC", "heading_level": 3, "file_order": 384, "section_index": 17, "content_hash": "6566be3c8371b86d4d39979ef688a136bba4229bdea68702f84a11205af18011", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-async.adoc"}}
{"id": "sha256:f10c8651e5f8279f7e9a92cb92eb94eca6caa8852698d0e4970cdc5b48435df3", "content": "[[mvc-ann-rest-exceptions]]\n\n[.small]#xref:web/webflux/ann-rest-exceptions.adoc[See equivalent in the Reactive stack]#\n\nA common requirement for REST services is to include details in the body of error\nresponses. The Spring Framework supports the \"Problem Details for HTTP APIs\"\nspecification, {rfc-site}/rfc9457[RFC 9457].\n\nThe following are the main abstractions for this support:\n\n- `ProblemDetail` -- representation for an RFC 9457 problem detail; a simple container\nfor both standard fields defined in the spec, and for non-standard ones.\n- `ErrorResponse` -- contract to expose HTTP error response details including HTTP\nstatus, response headers, and a body in the format of RFC 9457; this allows exceptions to\nencapsulate and expose the details of how they map to an HTTP response. All Spring MVC\nexceptions implement this.\n- `ErrorResponseException` -- basic `ErrorResponse` implementation that others\ncan use as a convenient base class.\n- `ResponseEntityExceptionHandler` -- convenient base class for an\nxref:web/webmvc/mvc-controller/ann-advice.adoc[@ControllerAdvice] that handles all Spring MVC exceptions,\nand any `ErrorResponseException`, and renders an error response with a body.\n\n[[mvc-ann-rest-exceptions-render]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-rest-exceptions.adoc", "title": "mvc-ann-rest-exceptions", "heading": "mvc-ann-rest-exceptions", "heading_level": 1, "file_order": 385, "section_index": 0, "content_hash": "f10c8651e5f8279f7e9a92cb92eb94eca6caa8852698d0e4970cdc5b48435df3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-rest-exceptions.adoc"}}
{"id": "sha256:644d9e53cd299827324a5aeb6fa625fd98494f24d6f200cc310644fa448cd9f2", "content": "[.small]#xref:web/webflux/ann-rest-exceptions.adoc#webflux-ann-rest-exceptions-render[See equivalent in the Reactive stack]#\n\nYou can return `ProblemDetail` or `ErrorResponse` from any `@ExceptionHandler` or from\nany `@RequestMapping` method to render an RFC 9457 response. This is processed as follows:\n\n- The `status` property of `ProblemDetail` determines the HTTP status.\n- The `instance` property of `ProblemDetail` is set from the current URL path, if not\nalready set.\n- The Jackson JSON and XML codecs use \"application/problem+json\" or\n\"application/problem+xml\" respectively as the producible media types for `ProblemDetail`\nto ensure they are favored for content negotiation.\n\nTo enable RFC 9457 responses for Spring MVC exceptions and for any\n`ErrorResponseException`, extend `ResponseEntityExceptionHandler` and declare it as an\nxref:web/webmvc/mvc-controller/ann-advice.adoc[@ControllerAdvice] in Spring configuration. The handler\nhas an `@ExceptionHandler` method that handles any `ErrorResponse` exception, which\nincludes all built-in web exceptions. You can add more exception handling methods, and\nuse a protected method to map any exception to a `ProblemDetail`.\n\nYou can register `ErrorResponse` interceptors through the\nxref:web/webmvc/mvc-config.adoc[MVC Config] with a `WebMvcConfigurer`. Use that to intercept\nany RFC 9457 response and take some action.\n\n[[mvc-ann-rest-exceptions-non-standard]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-rest-exceptions.adoc", "title": "mvc-ann-rest-exceptions", "heading": "Render", "heading_level": 2, "file_order": 385, "section_index": 1, "content_hash": "644d9e53cd299827324a5aeb6fa625fd98494f24d6f200cc310644fa448cd9f2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-rest-exceptions.adoc"}}
{"id": "sha256:0ae83a59631513f3ac468654dc14aad5c97c7cf382e46910bdc1ff270e805b45", "content": "[.small]#xref:web/webflux/ann-rest-exceptions.adoc#webflux-ann-rest-exceptions-non-standard[See equivalent in the Reactive stack]#\n\nYou can extend an RFC 9457 response with non-standard fields in one of two ways.\n\nOne, insert into the \"properties\" `Map` of `ProblemDetail`. When using the Jackson\nlibrary, the Spring Framework registers `ProblemDetailJacksonMixin` that ensures this\n\"properties\" `Map` is unwrapped and rendered as top level JSON properties in the\nresponse, and likewise any unknown property during deserialization is inserted into\nthis `Map`.\n\nYou can also extend `ProblemDetail` to add dedicated non-standard properties.\nThe copy constructor in `ProblemDetail` allows a subclass to make it easy to be created\nfrom an existing `ProblemDetail`. This could be done centrally, for example, from an\n`@ControllerAdvice` such as `ResponseEntityExceptionHandler` that re-creates the\n`ProblemDetail` of an exception into a subclass with the additional non-standard fields.\n\nTIP: In Spring Boot, the `spring.mvc.problemdetails.enabled` property autoconfigures\na `ResponseEntityExceptionHandler` that handles built-in exceptions with problem details.\nIn that case, you may prefer to create another `@ControllerAdvice` instead of extending\n`ResponseEntityExceptionHandler` if you want to take over the handling of a specific\nbuilt-in exception. You'll need to ensure your handler is ordered ahead of the one\nconfigured by Spring Boot whose order is 0.\n\n[[mvc-ann-rest-exceptions-i18n]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-rest-exceptions.adoc", "title": "mvc-ann-rest-exceptions", "heading": "Non-Standard Fields", "heading_level": 2, "file_order": 385, "section_index": 2, "content_hash": "0ae83a59631513f3ac468654dc14aad5c97c7cf382e46910bdc1ff270e805b45", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-rest-exceptions.adoc"}}
{"id": "sha256:2a32c625cb75df82202ebf05b5083e68017e5c6ef17843656e35430146ff397f", "content": "[.small]#xref:web/webflux/ann-rest-exceptions.adoc#webflux-ann-rest-exceptions-i18n[See equivalent in the Reactive stack]#\n\nIt is a common requirement to customize and internationalize error response details.\nIt is also good practice to customize the problem details for Spring MVC exceptions\nto avoid revealing implementation details. This section describes the support for that.\n\nAn `ErrorResponse` exposes message codes for \"type\", \"title\", and \"detail\", as well as\nmessage code arguments for the \"detail\" field. `ResponseEntityExceptionHandler` resolves\nthese through a xref:core/beans/context-introduction.adoc#context-functionality-messagesource[MessageSource]\nand updates the corresponding `ProblemDetail` fields accordingly.\n\nThe default strategy for message codes is as follows:\n\n* \"type\": `problemDetail.type.[fully qualified exception class name]`\n* \"title\": `problemDetail.title.[fully qualified exception class name]`\n* \"detail\": `problemDetail.[fully qualified exception class name][suffix]`\n\nAn `ErrorResponse` may expose more than one message code, typically adding a suffix\nto the default message code. The table below lists message codes, and arguments for\nSpring MVC exceptions:\n\n[[mvc-ann-rest-exceptions-codes]]\n[cols=\"1,1,2\", options=\"header\"]\n|===\n| Exception | Message Code | Message Code Arguments\n\n| `AsyncRequestTimeoutException`\n| (default)\n|\n\n| `ConversionNotSupportedException`\n| (default)\n| `+{0}+` property name, `+{1}+` property value\n\n| `HandlerMethodValidationException`\n| (default)\n| `+{0}+` list all validation errors.\nMessage codes and arguments for each error are also resolved via `MessageSource`.\n\n| `HttpMediaTypeNotAcceptableException`\n| (default)\n| `+{0}+` list of supported media types\n\n| `HttpMediaTypeNotAcceptableException`\n| (default) + \".parseError\"\n|\n\n| `HttpMediaTypeNotSupportedException`\n| (default)\n| `+{0}+` the media type that is not supported, `+{1}+` list of supported media types\n\n| `HttpMediaTypeNotSupportedException`\n| (default) + \".parseError\"\n|\n\n| `HttpMessageNotReadableException`\n| (default)\n|\n\n| `HttpMessageNotWritableException`\n| (default)\n|\n\n| `HttpRequestMethodNotSupportedException`\n| (default)\n| `+{0}+` the current HTTP method, `+{1}+` the list of supported HTTP methods\n\n| `MethodArgumentNotValidException`\n| (default)\n| `+{0}+` the list of global errors, `+{1}+` the list of field errors.\n Message codes and arguments for each error are also resolved via `MessageSource`.\n\n| `MissingRequestHeaderException`\n| (default)\n| `+{0}+` the header name\n\n| `MissingServletRequestParameterException`\n| (default)\n| `+{0}+` the request parameter name\n\n| `MissingMatrixVariableException`\n| (default)\n| `+{0}+` the matrix variable name\n\n| `MissingPathVariableException`\n| (default)\n| `+{0}+` the path variable name\n\n| `MissingRequestCookieException`\n| (default)\n| `+{0}+` the cookie name\n\n| `MissingServletRequestPartException`\n| (default)\n| `+{0}+` the part name\n\n| `NoHandlerFoundException`\n| (default)\n|\n\n| `NoResourceFoundException`\n| (default)\n| `+{0}+` the request path (or portion of) used to find a resource\n\n| `TypeMismatchException`\n| (default)\n| `+{0}+` property name, `+{1}+` property value, `+{2}+` simple name of required type\n\n| `UnsatisfiedServletRequestParameterException`\n| (default)\n| `+{0}+` the list of parameter conditions\n\n|===\n\nNOTE: Unlike other exceptions, the message arguments for\n`MethodArgumentNotValidException` and `HandlerMethodValidationException` are based on a list of\n`MessageSourceResolvable` errors that can also be customized through a\nxref:core/beans/context-introduction.adoc#context-functionality-messagesource[MessageSource]\nresource bundle. See\nxref:core/validation/beanvalidation.adoc#validation-beanvalidation-spring-method-i18n[Customizing Validation Errors]\nfor more details.\n\n[[mvc-ann-rest-exceptions-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-rest-exceptions.adoc", "title": "mvc-ann-rest-exceptions", "heading": "Customization and i18n", "heading_level": 2, "file_order": 385, "section_index": 3, "content_hash": "2a32c625cb75df82202ebf05b5083e68017e5c6ef17843656e35430146ff397f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-rest-exceptions.adoc"}}
{"id": "sha256:f4a2d954a5890e1fd11bc409467779490fcaf708edfbb65b10c7a3f384d83cee", "content": "[.small]#xref:web/webflux/ann-rest-exceptions.adoc#webflux-ann-rest-exceptions-client[See equivalent in the Reactive stack]#\n\nA client application can catch `WebClientResponseException`, when using the `WebClient`,\nor `RestClientResponseException` when using the `RestTemplate`, and use their\n`getResponseBodyAs` methods to decode the error response body to any target type such as\n`ProblemDetail`, or a subclass of `ProblemDetail`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-rest-exceptions.adoc", "title": "mvc-ann-rest-exceptions", "heading": "Client Handling", "heading_level": 2, "file_order": 385, "section_index": 4, "content_hash": "f4a2d954a5890e1fd11bc409467779490fcaf708edfbb65b10c7a3f384d83cee", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-ann-rest-exceptions.adoc"}}
{"id": "sha256:189e8b8eba1d8ad148ebeaf45b7d606e8bda3a9a365cbd022eabf7132be8a8b2", "content": "[[mvc-caching]]\n\n[.small]#xref:web/webflux/caching.adoc[See equivalent in the Reactive stack]#\n\nHTTP caching can significantly improve the performance of a web application. HTTP caching\nrevolves around the `Cache-Control` response header and, subsequently, conditional request\nheaders (such as `Last-Modified` and `ETag`). `Cache-Control` advises private (for example, browser)\nand public (for example, proxy) caches on how to cache and re-use responses. An `ETag` header is used\nto make a conditional request that may result in a 304 (NOT_MODIFIED) without a body,\nif the content has not changed. `ETag` can be seen as a more sophisticated successor to\nthe `Last-Modified` header.\n\nThis section describes the HTTP caching-related options that are available in Spring Web MVC.\n\n[[mvc-caching-cachecontrol]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-caching.adoc", "title": "mvc-caching", "heading": "mvc-caching", "heading_level": 1, "file_order": 386, "section_index": 0, "content_hash": "189e8b8eba1d8ad148ebeaf45b7d606e8bda3a9a365cbd022eabf7132be8a8b2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-caching.adoc"}}
{"id": "sha256:4a7db0b125e468882f31d22e0f6cf72c32651e7dc180deeb67bbe4ae64a2aa19", "content": "[.small]#xref:web/webflux/caching.adoc#webflux-caching-cachecontrol[See equivalent in the Reactive stack]#\n\n{spring-framework-api}/http/CacheControl.html[`CacheControl`] provides support for\nconfiguring settings related to the `Cache-Control` header and is accepted as an argument\nin a number of places:\n\n* {spring-framework-api}/web/servlet/mvc/WebContentInterceptor.html[`WebContentInterceptor`]\n* {spring-framework-api}/web/servlet/support/WebContentGenerator.html[`WebContentGenerator`]\n* xref:web/webmvc/mvc-caching.adoc#mvc-caching-etag-lastmodified[Controllers]\n* xref:web/webmvc/mvc-caching.adoc#mvc-caching-static-resources[Static Resources]\n\nWhile {rfc-site}/rfc7234#section-5.2.2[RFC 7234] describes all possible\ndirectives for the `Cache-Control` response header, the `CacheControl` type takes a\nuse case-oriented approach that focuses on the common scenarios:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Cache for an hour - \"Cache-Control: max-age=3600\"\n\tCacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);\n\n\t// Prevent caching - \"Cache-Control: no-store\"\n\tCacheControl ccNoStore = CacheControl.noStore();\n\n\t// Cache for ten days in public and private caches,\n\t// public caches should not transform the response\n\t// \"Cache-Control: max-age=864000, public, no-transform\"\n\tCacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// Cache for an hour - \"Cache-Control: max-age=3600\"\n\tval ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS)\n\n\t// Prevent caching - \"Cache-Control: no-store\"\n\tval ccNoStore = CacheControl.noStore()\n\n\t// Cache for ten days in public and private caches,\n\t// public caches should not transform the response\n\t// \"Cache-Control: max-age=864000, public, no-transform\"\n\tval ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic()\n----\n======\n\n`WebContentGenerator` also accepts a simpler `cachePeriod` property (defined in seconds) that\nworks as follows:\n\n* A `-1` value does not generate a `Cache-Control` response header.\n* A `0` value prevents caching by using the `'Cache-Control: no-store'` directive.\n* An `n > 0` value caches the given response for `n` seconds by using the\n`'Cache-Control: max-age=n'` directive.\n\n[[mvc-caching-etag-lastmodified]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-caching.adoc", "title": "mvc-caching", "heading": "`CacheControl`", "heading_level": 2, "file_order": 386, "section_index": 1, "content_hash": "4a7db0b125e468882f31d22e0f6cf72c32651e7dc180deeb67bbe4ae64a2aa19", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-caching.adoc"}}
{"id": "sha256:1ae0ed69d3e06634e5e17515705b2a9703517eb154c073e348f39665d0e26e88", "content": "[.small]#xref:web/webflux/caching.adoc#webflux-caching-etag-lastmodified[See equivalent in the Reactive stack]#\n\nControllers can add explicit support for HTTP caching. We recommended doing so, since the\n`lastModified` or `ETag` value for a resource needs to be calculated before it can be compared\nagainst conditional request headers. A controller can add an `ETag` header and `Cache-Control`\nsettings to a `ResponseEntity`, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/book/{id}\")\n\tpublic ResponseEntity<Book> showBook(@PathVariable Long id) {\n\n Book book = findBook(id);\n String version = book.getVersion();\n\n return ResponseEntity\n .ok()\n .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))\n .eTag(version) // lastModified is also available\n .body(book);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping(\"/book/{id}\")\n\tfun showBook(@PathVariable id: Long): ResponseEntity<Book> {\n\n val book = findBook(id);\n val version = book.getVersion()\n\n return ResponseEntity\n .ok()\n .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))\n .eTag(version) // lastModified is also available\n .body(book)\n\t}\n----\n======\n--\n\nThe preceding example sends a 304 (NOT_MODIFIED) response with an empty body if the comparison\nto the conditional request headers indicates that the content has not changed. Otherwise, the\n`ETag` and `Cache-Control` headers are added to the response.\n\nYou can also make the check against conditional request headers in the controller,\nas the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RequestMapping\n\tpublic String myHandleMethod(WebRequest request, Model model) {\n\n long eTag = ... // <1>\n\n if (request.checkNotModified(eTag)) {\n return null; // <2>\n }\n\n model.addAttribute(...); // <3>\n return \"myViewName\";\n\t}\n----\n<1> Application-specific calculation.\n<2> The response has been set to 304 (NOT_MODIFIED) -- no further processing.\n<3> Continue with the request processing.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RequestMapping\n\tfun myHandleMethod(request: WebRequest, model: Model): String? {\n\n val eTag: Long = ... // <1>\n\n if (request.checkNotModified(eTag)) {\n return null // <2>\n }\n\n model[...] = ... // <3>\n return \"myViewName\"\n\t}\n----\n<1> Application-specific calculation.\n<2> The response has been set to 304 (NOT_MODIFIED) -- no further processing.\n<3> Continue with the request processing.\n======\n--\n\nThere are three variants for checking conditional requests against `eTag` values, `lastModified`\nvalues, or both. For conditional `GET` and `HEAD` requests, you can set the response to\n304 (NOT_MODIFIED). For conditional `POST`, `PUT`, and `DELETE`, you can instead set the response\nto 412 (PRECONDITION_FAILED), to prevent concurrent modification.\n\n[[mvc-caching-static-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-caching.adoc", "title": "mvc-caching", "heading": "Controllers", "heading_level": 2, "file_order": 386, "section_index": 2, "content_hash": "1ae0ed69d3e06634e5e17515705b2a9703517eb154c073e348f39665d0e26e88", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-caching.adoc"}}
{"id": "sha256:a8fa77eecf1551902e19a6b18676e97b6d74567ca0b7580561fc41a7e1153a7b", "content": "[.small]#xref:web/webflux/caching.adoc#webflux-caching-static-resources[See equivalent in the Reactive stack]#\n\nYou should serve static resources with a `Cache-Control` and conditional response headers\nfor optimal performance. See the section on configuring xref:web/webmvc/mvc-config/static-resources.adoc[Static Resources].\n\n[[mvc-httpcaching-shallowetag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-caching.adoc", "title": "mvc-caching", "heading": "Static Resources", "heading_level": 2, "file_order": 386, "section_index": 3, "content_hash": "a8fa77eecf1551902e19a6b18676e97b6d74567ca0b7580561fc41a7e1153a7b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-caching.adoc"}}
{"id": "sha256:87de8bab12fa5cfd1704b4fac2818e417182ac8246d99b5eecf0acb844ac0a80", "content": "You can use the `ShallowEtagHeaderFilter` to add \"`shallow`\" `eTag` values that are computed from the\nresponse content and, thus, save bandwidth but not CPU time. See xref:web/webmvc/filters.adoc#filters-shallow-etag[Shallow ETag].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-caching.adoc", "title": "mvc-caching", "heading": "`ETag` Filter", "heading_level": 2, "file_order": 386, "section_index": 4, "content_hash": "87de8bab12fa5cfd1704b4fac2818e417182ac8246d99b5eecf0acb844ac0a80", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-caching.adoc"}}
{"id": "sha256:f41afe098b3fe1d25ee8e163dbe0f1c7f8671658e97bffd72f29a68ce3e45735", "content": "[[mvc-config]]\n\n[.small]#xref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[See equivalent in the Reactive stack]#\n\nThe MVC Java configuration and the MVC XML namespace provide default configuration\nsuitable for most applications and a configuration API to customize it.\n\nFor more advanced customizations, which are not available in the configuration API,\nsee xref:web/webmvc/mvc-config/advanced-java.adoc[Advanced Java Config] and xref:web/webmvc/mvc-config/advanced-xml.adoc[Advanced XML Config].\n\nYou do not need to understand the underlying beans created by the MVC Java configuration\nand the MVC namespace. If you want to learn more, see xref:web/webmvc/mvc-servlet/special-bean-types.adoc[Special Bean Types]\nand xref:web/webmvc/mvc-servlet/config.adoc[Web MVC Config].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-config.adoc", "title": "mvc-config", "heading": "mvc-config", "heading_level": 1, "file_order": 387, "section_index": 0, "content_hash": "f41afe098b3fe1d25ee8e163dbe0f1c7f8671658e97bffd72f29a68ce3e45735", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-config.adoc"}}
{"id": "sha256:9ac33c16c1baacfa92209cc43fbb27bd1ff4b7ba7a897c564ead1d7870a4fa55", "content": "[[mvc-controller]]\n\n[.small]#xref:web/webflux/controller.adoc[See equivalent in the Reactive stack]#\n\nSpring MVC provides an annotation-based programming model where `@Controller` and\n`@RestController` components use annotations to express request mappings, request input,\nexception handling, and more. Annotated controllers have flexible method signatures and\ndo not have to extend base classes nor implement specific interfaces.\nThe following example shows a controller defined by annotations:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class HelloController {\n\n @GetMapping(\"/hello\")\n public String handle(Model model) {\n model.addAttribute(\"message\", \"Hello World!\");\n return \"index\";\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.ui.set\n\n\t@Controller\n\tclass HelloController {\n\n @GetMapping(\"/hello\")\n fun handle(model: Model): String {\n model[\"message\"] = \"Hello World!\"\n return \"index\"\n }\n\t}\n----\n======\n\nIn the preceding example, the method accepts a `Model` and returns a view name as a `String`,\nbut many other options exist and are explained later in this chapter.\n\nTIP: Guides and tutorials on {spring-site-guides}[spring.io] use the annotation-based\nprogramming model described in this section.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller.adoc", "title": "mvc-controller", "heading": "mvc-controller", "heading_level": 1, "file_order": 388, "section_index": 0, "content_hash": "9ac33c16c1baacfa92209cc43fbb27bd1ff4b7ba7a897c564ead1d7870a4fa55", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-controller.adoc"}}
{"id": "sha256:b887aff37b9d1662fbd7965dd4ed38af14a2d32aa7fcdb89b2ffbcfdb15528af", "content": "[[mvc-http2]]\n\n[.small]#xref:web/webflux/http2.adoc[See equivalent in the Reactive stack]#\n\nServlet 4 containers are required to support HTTP/2, and Spring Framework requires\nServlet API 6.1. From a programming model perspective, there is nothing specific that\napplications need to do. However, there are considerations related to server configuration.\nFor more details, see the\n{spring-framework-wiki}/HTTP-2-support[HTTP/2 wiki page].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-http2.adoc", "title": "mvc-http2", "heading": "mvc-http2", "heading_level": 1, "file_order": 389, "section_index": 0, "content_hash": "b887aff37b9d1662fbd7965dd4ed38af14a2d32aa7fcdb89b2ffbcfdb15528af", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-http2.adoc"}}
{"id": "sha256:43ed7b5a5ab2ae207c0c269df0b37d58c4dd1d3d7e7dfd54f9617896380a766c", "content": "[[mvc-range]]\n\n[.small]#xref:web/webflux/range.adoc[See equivalent in the Reactive stack]#\n\nSpring MVC supports https://datatracker.ietf.org/doc/html/rfc9110#section-14[RFC 9110]\nrange requests. For an overview, see the\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Range_requests[Ranger Requests]\nMozilla guide.\n\nThe `Range` header is parsed and handled transparently in Spring MVC when an annotated\ncontroller returns a `Resource` or `ResponseEntity<Resource>`, or a functional endpoint\nxref:web/webmvc-functional.adoc#webmvc-fn-resources[serves a `Resource`]. `Range` header\nsupport is also transparently handled when serving\nxref:web/webmvc/mvc-config/static-resources.adoc[static resources].\n\nTIP: The `Resource` must not be an `InputStreamResource` and with `ResponseEntity<Resource>`,\nthe status of the response must be 200.\n\nThe underlying support is in the `HttpRange` class, which exposes methods to parse\n`Range` headers and split a `Resource` into a `List<ResourceRegion>` that in turn can be\nthen written to the response via `ResourceRegionHttpMessageConverter`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-range.adoc", "title": "mvc-range", "heading": "mvc-range", "heading_level": 1, "file_order": 390, "section_index": 0, "content_hash": "43ed7b5a5ab2ae207c0c269df0b37d58c4dd1d3d7e7dfd54f9617896380a766c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-range.adoc"}}
{"id": "sha256:fe5def10a4b2be3b900c876586d6ce94503aa0584f58353a0f97ee941ed1f764", "content": "[[mvc-web-security]]\n\n[.small]#xref:web/webflux/security.adoc[See equivalent in the Reactive stack]#\n\nThe {spring-site-projects}/spring-security[Spring Security] project provides support\nfor protecting web applications from malicious exploits. See the Spring Security\nreference documentation, including:\n\n* {docs-spring-security}/servlet/integrations/mvc.html[Spring MVC Security]\n* {docs-spring-security}/servlet/test/mockmvc/setup.html[Spring MVC Test Support]\n* {docs-spring-security}/features/exploits/csrf.html#csrf-protection[CSRF protection]\n* {docs-spring-security}/features/exploits/headers.html[Security Response Headers]\n\nhttps://github.com/hdiv/hdiv[HDIV] is another web security framework that integrates with Spring MVC.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-security.adoc", "title": "mvc-security", "heading": "mvc-security", "heading_level": 1, "file_order": 391, "section_index": 0, "content_hash": "fe5def10a4b2be3b900c876586d6ce94503aa0584f58353a0f97ee941ed1f764", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-security.adoc"}}
{"id": "sha256:661fe8cc068af334bc909b74ae8f5bdf364b7c086fd2b56b62623926a796ddd0", "content": "[[mvc-servlet]]\n\n[.small]#xref:web/webflux/dispatcher-handler.adoc[See equivalent in the Reactive stack]#\n\nSpring MVC, as many other web frameworks, is designed around the front controller\npattern where a central `Servlet`, the `DispatcherServlet`, provides a shared algorithm\nfor request processing, while actual work is performed by configurable delegate components.\nThis model is flexible and supports diverse workflows.\n\nThe `DispatcherServlet`, as any `Servlet`, needs to be declared and mapped according\nto the Servlet specification by using Java configuration or in `web.xml`.\nIn turn, the `DispatcherServlet` uses Spring configuration to discover\nthe delegate components it needs for request mapping, view resolution, exception\nhandling, xref:web/webmvc/mvc-servlet/special-bean-types.adoc[and more].\n\nThe following example shows the programmatic registration and initialization of\nthe `DispatcherServlet`, which is auto-detected by the Servlet container\n(see xref:web/webmvc/mvc-servlet/container-config.adoc[Servlet Config]), and the\nequivalent `web.xml`:\n\ninclude-code::./MyWebApplicationInitializer[tag=snippet,indent=0]\n\nNOTE: In addition to using the ServletContext API directly, you can also extend\n`AbstractAnnotationConfigDispatcherServletInitializer` and override specific methods\n(see the example under xref:web/webmvc/mvc-servlet/context-hierarchy.adoc[Context Hierarchy]).\n\nNOTE: For programmatic use cases, a `GenericWebApplicationContext` can be used as an\nalternative to `AnnotationConfigWebApplicationContext`. See the\n{spring-framework-api}/web/context/support/GenericWebApplicationContext.html[`GenericWebApplicationContext`]\njavadoc for details.\n\nNOTE: Spring Boot follows a different initialization sequence. Rather than hooking into\nthe lifecycle of the Servlet container, Spring Boot uses Spring configuration to\nbootstrap itself and the embedded Servlet container. `Filter` and `Servlet` declarations\nare detected in Spring configuration and registered with the Servlet container.\nFor more details, see the\n{spring-boot-docs-ref}/web/servlet.html#web.servlet.embedded-container[Spring Boot documentation].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet.adoc", "title": "mvc-servlet", "heading": "mvc-servlet", "heading_level": 1, "file_order": 392, "section_index": 0, "content_hash": "661fe8cc068af334bc909b74ae8f5bdf364b7c086fd2b56b62623926a796ddd0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-servlet.adoc"}}
{"id": "sha256:985ff069bace09aea7aa13bc0b2994fe424a4cefa95ec2a4b962f02ab4b8e00d", "content": "[[mvc-uri-building]]\n\n[.small]#xref:web/webflux/uri-building.adoc[See equivalent in the Reactive stack]#\n\nThis section describes various options available in the Spring Framework to work with URI's.\n\n[[uricomponents]]\n= UriComponents\n[.small]#Spring MVC and Spring WebFlux#\n\n`UriComponentsBuilder` helps to build URI's from URI templates with variables, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tUriComponents uriComponents = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}\") // <1>\n\t\t\t.queryParam(\"q\", \"{q}\") // <2>\n\t\t\t.encode() // <3>\n\t\t\t.build(); // <4>\n\n\tURI uri = uriComponents.expand(\"Westin\", \"123\").toUri(); // <5>\n----\n<1> Static factory method with a URI template.\n<2> Add or replace URI components.\n<3> Request to have the URI template and URI variables encoded.\n<4> Build a `UriComponents`.\n<5> Expand variables and obtain the `URI`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uriComponents = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}\") // <1>\n\t\t\t.queryParam(\"q\", \"{q}\") // <2>\n\t\t\t.encode() // <3>\n\t\t\t.build() // <4>\n\n\tval uri = uriComponents.expand(\"Westin\", \"123\").toUri() // <5>\n----\n<1> Static factory method with a URI template.\n<2> Add or replace URI components.\n<3> Request to have the URI template and URI variables encoded.\n<4> Build a `UriComponents`.\n<5> Expand variables and obtain the `URI`.\n======\n\nThe preceding example can be consolidated into one chain and shortened with `buildAndExpand`,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tURI uri = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.encode()\n\t\t\t.buildAndExpand(\"Westin\", \"123\")\n\t\t\t.toUri();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uri = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.encode()\n\t\t\t.buildAndExpand(\"Westin\", \"123\")\n\t\t\t.toUri()\n----\n======\n\nYou can shorten it further by going directly to a URI (which implies encoding),\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tURI uri = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.build(\"Westin\", \"123\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uri = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.build(\"Westin\", \"123\")\n----\n======\n\nYou can shorten it further still with a full URI template, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tURI uri = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}?q={q}\")\n\t\t\t.build(\"Westin\", \"123\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uri = UriComponentsBuilder\n\t\t\t.fromUriString(\"https://example.com/hotels/{hotel}?q={q}\")\n\t\t\t.build(\"Westin\", \"123\")\n----\n======\n\n\n\n[[uribuilder]]\n= UriBuilder\n[.small]#Spring MVC and Spring WebFlux#\n\n<<web-uricomponents, `UriComponentsBuilder`>> implements `UriBuilder`. You can create a\n`UriBuilder`, in turn, with a `UriBuilderFactory`. Together, `UriBuilderFactory` and\n`UriBuilder` provide a pluggable mechanism to build URIs from URI templates, based on\nshared configuration, such as a base URL, encoding preferences, and other details.\n\nYou can configure `RestTemplate` and `WebClient` with a `UriBuilderFactory`\nto customize the preparation of URIs. `DefaultUriBuilderFactory` is a default\nimplementation of `UriBuilderFactory` that uses `UriComponentsBuilder` internally and\nexposes shared configuration options.\n\nThe following example shows how to configure a `RestTemplate`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;\n\n\tString baseUrl = \"https://example.org\";\n\tDefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);\n\tfactory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);\n\n\tRestTemplate restTemplate = new RestTemplate();\n\trestTemplate.setUriTemplateHandler(factory);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode\n\n\tval baseUrl = \"https://example.org\"\n\tval factory = DefaultUriBuilderFactory(baseUrl)\n\tfactory.encodingMode = EncodingMode.TEMPLATE_AND_VALUES\n\n\tval restTemplate = RestTemplate()\n\trestTemplate.uriTemplateHandler = factory\n----\n======\n\nThe following example configures a `WebClient`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;\n\n\tString baseUrl = \"https://example.org\";\n\tDefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);\n\tfactory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);\n\n\tWebClient client = WebClient.builder().uriBuilderFactory(factory).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode\n\n\tval baseUrl = \"https://example.org\"\n\tval factory = DefaultUriBuilderFactory(baseUrl)\n\tfactory.encodingMode = EncodingMode.TEMPLATE_AND_VALUES\n\n\tval client = WebClient.builder().uriBuilderFactory(factory).build()\n----\n======\n\nIn addition, you can also use `DefaultUriBuilderFactory` directly. It is similar to using\n`UriComponentsBuilder` but, instead of static factory methods, it is an actual instance\nthat holds configuration and preferences, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString baseUrl = \"https://example.com\";\n\tDefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);\n\n\tURI uri = uriBuilderFactory.uriString(\"/hotels/{hotel}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.build(\"Westin\", \"123\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval baseUrl = \"https://example.com\"\n\tval uriBuilderFactory = DefaultUriBuilderFactory(baseUrl)\n\n\tval uri = uriBuilderFactory.uriString(\"/hotels/{hotel}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.build(\"Westin\", \"123\")\n----\n======\n\n\n[[uri-parsing]]\n= URI Parsing\n[.small]#Spring MVC and Spring WebFlux#\n\n`UriComponentsBuilder` supports two URI parser types:\n\n1. RFC parser -- this parser type expects URI strings to conform to RFC 3986 syntax,\nand treats deviations from the syntax as illegal.\n\n2. WhatWG parser -- this parser is based on the\nhttps://github.com/web-platform-tests/wpt/tree/master/url[URL parsing algorithm] in the\nhttps://url.spec.whatwg.org[WhatWG URL Living standard]. It provides lenient handling of\na wide range of cases of unexpected input. Browsers implement this in order to handle\nleniently user typed URL's. For more details, see the URL Living Standard and URL parsing\nhttps://github.com/web-platform-tests/wpt/tree/master/url[test cases].\n\nBy default, `RestClient`, `WebClient`, and `RestTemplate` use the RFC parser type, and\nexpect applications to provide with URL templates that conform to RFC syntax. To change\nthat you can customize the `UriBuilderFactory` on any of the clients.\n\nApplications and frameworks may further rely on `UriComponentsBuilder` for their own needs\nto parse user provided URL's in order to inspect and possibly validated URI components\nsuch as the scheme, host, port, path, and query. Such components can decide to use the\nWhatWG parser type in order to handle URL's more leniently, and to align with the way\nbrowsers parse URI's, in case of a redirect to the input URL or if it is included in a\nresponse to a browser.\n\n\n[[uri-encoding]]\n= URI Encoding\n[.small]#Spring MVC and Spring WebFlux#\n\n`UriComponentsBuilder` exposes encoding options at two levels:\n\n* {spring-framework-api}/web/util/UriComponentsBuilder.html#encode()[UriComponentsBuilder#encode()]:\nPre-encodes the URI template first and then strictly encodes URI variables when expanded.\n* {spring-framework-api}/web/util/UriComponents.html#encode()[UriComponents#encode()]:\nEncodes URI components _after_ URI variables are expanded.\n\nBoth options replace non-ASCII and illegal characters with escaped octets. However, the first option\nalso replaces characters with reserved meaning that appear in URI variables.\n\nTIP: Consider \";\", which is legal in a path but has reserved meaning. The first option replaces\n\";\" with \"%3B\" in URI variables but not in the URI template. By contrast, the second option never\nreplaces \";\", since it is a legal character in a path.\n\nFor most cases, the first option is likely to give the expected result, because it treats URI\nvariables as opaque data to be fully encoded, while the second option is useful if URI\nvariables do intentionally contain reserved characters. The second option is also useful\nwhen not expanding URI variables at all since that will also encode anything that\nincidentally looks like a URI variable.\n\nThe following example uses the first option:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tURI uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.encode()\n\t\t\t.buildAndExpand(\"New York\", \"foo+bar\")\n\t\t\t.toUri();\n\n\t// Result is \"/hotel%20list/New%20York?q=foo%2Bbar\"\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.encode()\n\t\t\t.buildAndExpand(\"New York\", \"foo+bar\")\n\t\t\t.toUri()\n\n\t// Result is \"/hotel%20list/New%20York?q=foo%2Bbar\"\n----\n======\n\nYou can shorten the preceding example by going directly to the URI (which implies encoding),\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tURI uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.build(\"New York\", \"foo+bar\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\")\n\t\t\t.queryParam(\"q\", \"{q}\")\n\t\t\t.build(\"New York\", \"foo+bar\")\n----\n======\n\nYou can shorten it further still with a full URI template, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tURI uri = UriComponentsBuilder.fromUriString(\"/hotel list/{city}?q={q}\")\n\t\t\t.build(\"New York\", \"foo+bar\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uri = UriComponentsBuilder.fromUriString(\"/hotel list/{city}?q={q}\")\n\t\t\t.build(\"New York\", \"foo+bar\")\n----\n======\n\nThe `WebClient` and the `RestTemplate` expand and encode URI templates internally through\nthe `UriBuilderFactory` strategy. Both can be configured with a custom strategy,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString baseUrl = \"https://example.com\";\n\tDefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl)\n\tfactory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);\n\n\t// Customize the RestTemplate..\n\tRestTemplate restTemplate = new RestTemplate();\n\trestTemplate.setUriTemplateHandler(factory);\n\n\t// Customize the WebClient..\n\tWebClient client = WebClient.builder().uriBuilderFactory(factory).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval baseUrl = \"https://example.com\"\n\tval factory = DefaultUriBuilderFactory(baseUrl).apply {\n\t\tencodingMode = EncodingMode.TEMPLATE_AND_VALUES\n\t}\n\n\t// Customize the RestTemplate..\n\tval restTemplate = RestTemplate().apply {\n\t\turiTemplateHandler = factory\n\t}\n\n\t// Customize the WebClient..\n\tval client = WebClient.builder().uriBuilderFactory(factory).build()\n----\n======\n\nThe `DefaultUriBuilderFactory` implementation uses `UriComponentsBuilder` internally to\nexpand and encode URI templates. As a factory, it provides a single place to configure\nthe approach to encoding, based on one of the below encoding modes:\n\n* `TEMPLATE_AND_VALUES`: Uses `UriComponentsBuilder#encode()`, corresponding to\nthe first option in the earlier list, to pre-encode the URI template and strictly encode URI variables when\nexpanded.\n* `VALUES_ONLY`: Does not encode the URI template and, instead, applies strict encoding\nto URI variables through `UriUtils#encodeUriVariables` prior to expanding them into the\ntemplate.\n* `URI_COMPONENT`: Uses `UriComponents#encode()`, corresponding to the second option in the earlier list, to\nencode URI component value _after_ URI variables are expanded.\n* `NONE`: No encoding is applied.\n\nThe `RestTemplate` is set to `EncodingMode.URI_COMPONENT` for historical\nreasons and for backwards compatibility. The `WebClient` relies on the default value\nin `DefaultUriBuilderFactory`, which was changed from `EncodingMode.URI_COMPONENT` in\n5.0.x to `EncodingMode.TEMPLATE_AND_VALUES` in 5.1.\n\n[[mvc-servleturicomponentsbuilder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-uri-building.adoc", "title": "mvc-uri-building", "heading": "mvc-uri-building", "heading_level": 1, "file_order": 393, "section_index": 0, "content_hash": "985ff069bace09aea7aa13bc0b2994fe424a4cefa95ec2a4b962f02ab4b8e00d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-uri-building.adoc"}}
{"id": "sha256:9ffa1e75ff6e7717e4f8a059721c38726a3189184cdec0eabe3bafc77ba7495f", "content": "You can use `ServletUriComponentsBuilder` to create URIs relative to the current request,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHttpServletRequest request = ...\n\n\t// Re-uses scheme, host, port, path, and query string...\n\n\tURI uri = ServletUriComponentsBuilder.fromRequest(request)\n .replaceQueryParam(\"accountId\", \"{id}\")\n .build(\"123\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval request: HttpServletRequest = ...\n\n\t// Re-uses scheme, host, port, path, and query string...\n\n\tval uri = ServletUriComponentsBuilder.fromRequest(request)\n .replaceQueryParam(\"accountId\", \"{id}\")\n .build(\"123\")\n----\n======\n\nYou can create URIs relative to the context path, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHttpServletRequest request = ...\n\n\t// Re-uses scheme, host, port, and context path...\n\n\tURI uri = ServletUriComponentsBuilder.fromContextPath(request)\n .path(\"/accounts\")\n .build()\n .toUri();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval request: HttpServletRequest = ...\n\n\t// Re-uses scheme, host, port, and context path...\n\n\tval uri = ServletUriComponentsBuilder.fromContextPath(request)\n .path(\"/accounts\")\n .build()\n .toUri()\n----\n======\n\nYou can create URIs relative to a Servlet (for example, `/main/{asterisk}`),\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHttpServletRequest request = ...\n\n\t// Re-uses scheme, host, port, context path, and Servlet mapping prefix...\n\n\tURI uri = ServletUriComponentsBuilder.fromServletMapping(request)\n .path(\"/accounts\")\n .build()\n .toUri();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval request: HttpServletRequest = ...\n\n\t// Re-uses scheme, host, port, context path, and Servlet mapping prefix...\n\n\tval uri = ServletUriComponentsBuilder.fromServletMapping(request)\n .path(\"/accounts\")\n .build()\n .toUri()\n----\n======\n\nNOTE: As of 5.1, `ServletUriComponentsBuilder` ignores information from the `Forwarded` and\n`X-Forwarded-*` headers, which specify the client-originated address. Consider using the\nxref:web/webmvc/filters.adoc#filters-forwarded-headers[`ForwardedHeaderFilter`] to extract and use or to discard\nsuch headers.\n\n[[mvc-links-to-controllers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-uri-building.adoc", "title": "mvc-uri-building", "heading": "Relative Servlet Requests", "heading_level": 2, "file_order": 393, "section_index": 1, "content_hash": "9ffa1e75ff6e7717e4f8a059721c38726a3189184cdec0eabe3bafc77ba7495f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-uri-building.adoc"}}
{"id": "sha256:0e7e008516b30fe1e8374bc23e1ef78bae74f5a5e0efb28166b63027c75ba5ed", "content": "Spring MVC provides a mechanism to prepare links to controller methods. For example,\nthe following MVC controller allows for link creation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@RequestMapping(\"/hotels/{hotel}\")\n\tpublic class BookingController {\n\n @GetMapping(\"/bookings/{booking}\")\n public ModelAndView getBooking(@PathVariable Long booking) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\t@RequestMapping(\"/hotels/{hotel}\")\n\tclass BookingController {\n\n @GetMapping(\"/bookings/{booking}\")\n fun getBooking(@PathVariable booking: Long): ModelAndView {\n // ...\n }\n\t}\n----\n======\n\nYou can prepare a link by referring to the method by name, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tUriComponents uriComponents = MvcUriComponentsBuilder\n .fromMethodName(BookingController.class, \"getBooking\", 21).buildAndExpand(42);\n\n\tURI uri = uriComponents.encode().toUri();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uriComponents = MvcUriComponentsBuilder\n .fromMethodName(BookingController::class.java, \"getBooking\", 21).buildAndExpand(42)\n\n\tval uri = uriComponents.encode().toUri()\n----\n======\n\nIn the preceding example, we provide actual method argument values (in this case, the long value: `21`)\nto be used as a path variable and inserted into the URL. Furthermore, we provide the\nvalue, `42`, to fill in any remaining URI variables, such as the `hotel` variable inherited\nfrom the type-level request mapping. If the method had more arguments, we could supply null for\narguments not needed for the URL. In general, only `@PathVariable` and `@RequestParam` arguments\nare relevant for constructing the URL.\n\nThere are additional ways to use `MvcUriComponentsBuilder`. For example, you can use a technique\nakin to mock testing through proxies to avoid referring to the controller method by name, as the following example shows\n(the example assumes static import of `MvcUriComponentsBuilder.on`):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tUriComponents uriComponents = MvcUriComponentsBuilder\n .fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);\n\n\tURI uri = uriComponents.encode().toUri();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval uriComponents = MvcUriComponentsBuilder\n .fromMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42)\n\n\tval uri = uriComponents.encode().toUri()\n----\n======\n\nNOTE: Controller method signatures are limited in their design when they are supposed to be usable for\nlink creation with `fromMethodCall`. Aside from needing a proper parameter signature,\nthere is a technical limitation on the return type (namely, generating a runtime proxy\nfor link builder invocations), so the return type must not be `final`. In particular,\nthe common `String` return type for view names does not work here. You should use `ModelAndView`\nor even plain `Object` (with a `String` return value) instead.\n\nThe earlier examples use static methods in `MvcUriComponentsBuilder`. Internally, they rely\non `ServletUriComponentsBuilder` to prepare a base URL from the scheme, host, port,\ncontext path, and servlet path of the current request. This works well in most cases.\nHowever, sometimes, it can be insufficient. For example, you may be outside the context of\na request (such as a batch process that prepares links) or perhaps you need to insert a path\nprefix (such as a locale prefix that was removed from the request path and needs to be\nre-inserted into links).\n\nFor such cases, you can use the static `fromXxx` overloaded methods that accept a\n`UriComponentsBuilder` to use a base URL. Alternatively, you can create an instance of `MvcUriComponentsBuilder`\nwith a base URL and then use the instance-based `withXxx` methods. For example, the\nfollowing listing uses `withMethodCall`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tUriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path(\"/en\");\n\tMvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);\n\tbuilder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);\n\n\tURI uri = uriComponents.encode().toUri();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval base = ServletUriComponentsBuilder.fromCurrentContextPath().path(\"/en\")\n\tval builder = MvcUriComponentsBuilder.relativeTo(base)\n\tbuilder.withMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42)\n\n\tval uri = uriComponents.encode().toUri()\n----\n======\n\nNOTE: As of 5.1, `MvcUriComponentsBuilder` ignores information from the `Forwarded` and\n`X-Forwarded-*` headers, which specify the client-originated address. Consider using the\nxref:web/webmvc/filters.adoc#filters-forwarded-headers[ForwardedHeaderFilter] to extract and use or to discard\nsuch headers.\n\n[[mvc-links-to-controllers-from-views]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-uri-building.adoc", "title": "mvc-uri-building", "heading": "Links to Controllers", "heading_level": 2, "file_order": 393, "section_index": 2, "content_hash": "0e7e008516b30fe1e8374bc23e1ef78bae74f5a5e0efb28166b63027c75ba5ed", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-uri-building.adoc"}}
{"id": "sha256:719b57d047dd7ca5d7707530869b69539b3638341d5245b4c52f54bccc2171a8", "content": "In views such as Thymeleaf, FreeMarker, or JSP, you can build links to annotated controllers\nby referring to the implicitly or explicitly assigned name for each request mapping.\n\nConsider the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RequestMapping(\"/people/{id}/addresses\")\n\tpublic class PersonAddressController {\n\n @RequestMapping(\"/{country}\")\n public HttpEntity<PersonAddress> getAddress(@PathVariable String country) { ... }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RequestMapping(\"/people/{id}/addresses\")\n\tclass PersonAddressController {\n\n @RequestMapping(\"/{country}\")\n fun getAddress(@PathVariable country: String): HttpEntity<PersonAddress> { ... }\n\t}\n----\n======\n\nGiven the preceding controller, you can prepare a link from a JSP, as follows:\n\n[source,jsp,indent=0,subs=\"verbatim,quotes\"]\n----\n<%@ taglib uri=\"http://www.springframework.org/tags\" prefix=\"s\" %>\n...\n<a href=\"${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}\">Get Address</a>\n----\n\nThe preceding example relies on the `mvcUrl` function declared in the Spring tag library\n(that is, META-INF/spring.tld), but it is easy to define your own function or prepare a\nsimilar one for other templating technologies.\n\nHere is how this works. On startup, every `@RequestMapping` is assigned a default name\nthrough `HandlerMethodMappingNamingStrategy`, whose default implementation uses the\ncapital letters of the class and the method name (for example, the `getThing` method in\n`ThingController` becomes \"TC#getThing\"). If there is a name clash, you can use\n`@RequestMapping(name=\"..\")` to assign an explicit name or implement your own\n`HandlerMethodMappingNamingStrategy`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc/mvc-uri-building.adoc", "title": "mvc-uri-building", "heading": "Links in Views", "heading_level": 2, "file_order": 393, "section_index": 3, "content_hash": "719b57d047dd7ca5d7707530869b69539b3638341d5245b4c52f54bccc2171a8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc/mvc-uri-building.adoc"}}
{"id": "sha256:026a32a3e8b1ec0326c33195b73b9a639d9e8352dcfee3c62a071b64b630b7d4", "content": "[[mvc-view-document]]\n\nSpring offers ways to return output other than HTML, including PDF and Excel spreadsheets.\nThis section describes how to use those features.\n\nWARNING: As of Spring Framework 7.0, view classes in the `org.springframework.web.servlet.view.document`\npackage are deprecated. Instead, libraries can adapt this existing code to provide support with their own `*View` types.\nAs an alternative, applications can perform direct rendering in web handlers.\n\n[[mvc-view-document-intro]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-document.adoc", "title": "mvc-document", "heading": "mvc-document", "heading_level": 1, "file_order": 394, "section_index": 0, "content_hash": "026a32a3e8b1ec0326c33195b73b9a639d9e8352dcfee3c62a071b64b630b7d4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-document.adoc"}}
{"id": "sha256:84d42f8120a8a29ab97b2ff38486da19629965f0aea3e80dde12991a60c68aa3", "content": "An HTML page is not always the best way for the user to view the model output,\nand Spring makes it simple to generate a PDF document or an Excel spreadsheet\ndynamically from the model data. The document is the view and is streamed from the\nserver with the correct content type, to (hopefully) enable the client PC to run their\nspreadsheet or PDF viewer application in response.\n\nIn order to use Excel views, you need to add the Apache POI library to your classpath.\nFor PDF generation, you need to add (preferably) the OpenPDF library.\n\nNOTE: You should use the latest versions of the underlying document-generation libraries,\nif possible. In particular, we strongly recommend OpenPDF (for example, OpenPDF 1.2.12)\ninstead of the outdated original iText 2.1.7, since OpenPDF is actively maintained and\nfixes an important vulnerability for untrusted PDF content.\n\n[[mvc-view-document-pdf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-document.adoc", "title": "mvc-document", "heading": "Introduction to Document Views", "heading_level": 2, "file_order": 394, "section_index": 1, "content_hash": "84d42f8120a8a29ab97b2ff38486da19629965f0aea3e80dde12991a60c68aa3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-document.adoc"}}
{"id": "sha256:2e89c839a765f9083b538cc0af388d0aeeef623a8d49f8bb1823c805cfbf2aa9", "content": "A simple PDF view for a word list could extend\n`org.springframework.web.servlet.view.document.AbstractPdfView` and implement the\n`buildPdfDocument()` method, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class PdfWordList extends AbstractPdfView {\n\n protected void buildPdfDocument(Map<String, Object> model, Document doc, PdfWriter writer,\n HttpServletRequest request, HttpServletResponse response) throws Exception {\n\n List<String> words = (List<String>) model.get(\"wordList\");\n for (String word : words) {\n doc.add(new Paragraph(word));\n }\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass PdfWordList : AbstractPdfView() {\n\n override fun buildPdfDocument(model: Map<String, Any>, doc: Document, writer: PdfWriter,\n request: HttpServletRequest, response: HttpServletResponse) {\n\n val words = model[\"wordList\"] as List<String>\n for (word in words) {\n doc.add(Paragraph(word))\n }\n }\n\t}\n----\n======\n\nA controller can return such a view either from an external view definition\n(referencing it by name) or as a `View` instance from the handler method.\n\n[[mvc-view-document-excel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-document.adoc", "title": "mvc-document", "heading": "PDF Views", "heading_level": 2, "file_order": 394, "section_index": 2, "content_hash": "2e89c839a765f9083b538cc0af388d0aeeef623a8d49f8bb1823c805cfbf2aa9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-document.adoc"}}
{"id": "sha256:0bb7ec79bfba93987d3f073d7ae89ed1d2f61c1eeb5d75408dbde93342651b0f", "content": "Since Spring Framework 4.2,\n`org.springframework.web.servlet.view.document.AbstractXlsView` is provided as a base\nclass for Excel views. It is based on Apache POI, with specialized subclasses (`AbstractXlsxView`\nand `AbstractXlsxStreamingView`) that supersede the outdated `AbstractExcelView` class.\n\nThe programming model is similar to `AbstractPdfView`, with `buildExcelDocument()`\nas the central template method and controllers being able to return such a view from\nan external definition (by name) or as a `View` instance from the handler method.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-document.adoc", "title": "mvc-document", "heading": "Excel Views", "heading_level": 2, "file_order": 394, "section_index": 3, "content_hash": "0bb7ec79bfba93987d3f073d7ae89ed1d2f61c1eeb5d75408dbde93342651b0f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-document.adoc"}}
{"id": "sha256:571233caa2a787cf37b756305465c364d783a5873c39b4458b8741376d838c62", "content": "[[mvc-view-feeds]]\n\nWARNING: As of Spring Framework 7.0, view classes in the `org.springframework.web.servlet.view.feed`\npackage are deprecated. Instead, libraries can adapt this existing code to provide support with their own `*View` types.\nAs an alternative, applications can perform direct rendering in web handlers.\n\nBoth `AbstractAtomFeedView` and `AbstractRssFeedView` inherit from the\n`AbstractFeedView` base class and are used to provide Atom and RSS Feed views, respectively. They\nare based on https://rometools.github.io/rome/[ROME] project and are located in the\npackage `org.springframework.web.servlet.view.feed`.\n\n`AbstractAtomFeedView` requires you to implement the `buildFeedEntries()` method and\noptionally override the `buildFeedMetadata()` method (the default implementation is\nempty). The following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SampleContentAtomView extends AbstractAtomFeedView {\n\n @Override\n protected void buildFeedMetadata(Map<String, Object> model,\n Feed feed, HttpServletRequest request) {\n // implementation omitted\n }\n\n @Override\n protected List<Entry> buildFeedEntries(Map<String, Object> model,\n HttpServletRequest request, HttpServletResponse response) throws Exception {\n // implementation omitted\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass SampleContentAtomView : AbstractAtomFeedView() {\n\n override fun buildFeedMetadata(model: Map<String, Any>,\n feed: Feed, request: HttpServletRequest) {\n // implementation omitted\n }\n\n override fun buildFeedEntries(model: Map<String, Any>,\n request: HttpServletRequest, response: HttpServletResponse): List<Entry> {\n // implementation omitted\n }\n\t}\n----\n======\n\nSimilar requirements apply for implementing `AbstractRssFeedView`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class SampleContentRssView extends AbstractRssFeedView {\n\n @Override\n protected void buildFeedMetadata(Map<String, Object> model,\n Channel feed, HttpServletRequest request) {\n // implementation omitted\n }\n\n @Override\n protected List<Item> buildFeedItems(Map<String, Object> model,\n HttpServletRequest request, HttpServletResponse response) throws Exception {\n // implementation omitted\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass SampleContentRssView : AbstractRssFeedView() {\n\n override fun buildFeedMetadata(model: Map<String, Any>,\n feed: Channel, request: HttpServletRequest) {\n // implementation omitted\n }\n\n override fun buildFeedItems(model: Map<String, Any>,\n request: HttpServletRequest, response: HttpServletResponse): List<Item> {\n // implementation omitted\n }\n\t}\n----\n======\n\nThe `buildFeedItems()` and `buildFeedEntries()` methods pass in the HTTP request, in case\nyou need to access the Locale. The HTTP response is passed in only for the setting of\ncookies or other HTTP headers. The feed is automatically written to the response\nobject after the method returns.\n\nFor an example of creating an Atom view, see Alef Arendsen's Spring Team Blog\n{spring-site-blog}/2009/03/16/adding-an-atom-view-to-an-application-using-spring-s-rest-support[entry].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-feeds.adoc", "title": "mvc-feeds", "heading": "mvc-feeds", "heading_level": 1, "file_order": 395, "section_index": 0, "content_hash": "571233caa2a787cf37b756305465c364d783a5873c39b4458b8741376d838c62", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-feeds.adoc"}}
{"id": "sha256:58ed31b89aedc89c609f1280df05ab85f71e710ac26f2cc91cec5d550a7a18fa", "content": "[[mvc-view-fragments]]\n\n[.small]#xref:web/webflux-view.adoc#webflux-view-fragments[See equivalent in the Reactive stack]#\n\nhttps://htmx.org/[HTMX] and https://turbo.hotwired.dev/[Hotwire Turbo] emphasize an\nHTML-over-the-wire approach where clients receive server updates in HTML rather than in JSON.\nThis allows the benefits of an SPA (single page app) without having to write much or even\nany JavaScript. For a good overview and to learn more, please visit their respective\nwebsites.\n\nIn Spring MVC, view rendering typically involves specifying one view and one model.\nHowever, in HTML-over-the-wire a common capability is to send multiple HTML fragments that\nthe browser can use to update different parts of the page. For this, controller methods\ncan return `Collection<ModelAndView>`. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping\n\tList<ModelAndView> handle() {\n return List.of(new ModelAndView(\"posts\"), new ModelAndView(\"comments\"));\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping\n\tfun handle(): List<ModelAndView> {\n return listOf(ModelAndView(\"posts\"), ModelAndView(\"comments\"))\n\t}\n----\n======\n\nThe same can be done also by returning the dedicated type `FragmentsRendering`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping\n\tFragmentsRendering handle() {\n return FragmentsRendering.fragment(\"posts\").fragment(\"comments\").build();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping\n\tfun handle(): FragmentsRendering {\n return FragmentsRendering.fragment(\"posts\").fragment(\"comments\").build()\n\t}\n----\n======\n\nEach fragment can have an independent model, and that model inherits attributes from the\nshared model for the request.\n\nHTMX and Hotwire Turbo support streaming updates over SSE (server-sent events).\nA controller can use `SseEmitter` to send `ModelAndView` to render a fragment per event:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping\n\tSseEmitter handle() {\n SseEmitter emitter = new SseEmitter();\n startWorkerThread(() -> {\n try {\n emitter.send(SseEmitter.event().data(new ModelAndView(\"posts\")));\n emitter.send(SseEmitter.event().data(new ModelAndView(\"comments\")));\n // ...\n }\n catch (IOException ex) {\n // Cancel sending\n }\n });\n return emitter;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping\n\tfun handle(): SseEmitter {\n val emitter = SseEmitter()\n startWorkerThread{\n try {\n emitter.send(SseEmitter.event().data(ModelAndView(\"posts\")))\n emitter.send(SseEmitter.event().data(ModelAndView(\"comments\")))\n // ...\n }\n catch (ex: IOException) {\n // Cancel sending\n }\n }\n return emitter\n\t}\n----\n======\n\nThe same can also be done by returning `Flux<ModelAndView>`, or any other type adaptable\nto a Reactive Streams `Publisher` through the `ReactiveAdapterRegistry`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-fragments.adoc", "title": "mvc-fragments", "heading": "mvc-fragments", "heading_level": 1, "file_order": 396, "section_index": 0, "content_hash": "58ed31b89aedc89c609f1280df05ab85f71e710ac26f2cc91cec5d550a7a18fa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-fragments.adoc"}}
{"id": "sha256:3f6a91432d50f62c95646e600b98e8a17ceb3d4e66c479991c35654ee0e13ac3", "content": "[[mvc-view-freemarker]]\n\n[.small]#xref:web/webflux-view.adoc#webflux-view-freemarker[See equivalent in the Reactive stack]#\n\nhttps://freemarker.apache.org/[Apache FreeMarker] is a template engine for generating any\nkind of text output from HTML to email and others. The Spring Framework has built-in\nintegration for using Spring MVC with FreeMarker templates.\n\n[[mvc-view-freemarker-contextconfig]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc", "title": "mvc-freemarker", "heading": "mvc-freemarker", "heading_level": 1, "file_order": 397, "section_index": 0, "content_hash": "3f6a91432d50f62c95646e600b98e8a17ceb3d4e66c479991c35654ee0e13ac3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc"}}
{"id": "sha256:1ef8b7b9514c50cf6bac486326138e217607b17d24dc0bb85ded03e24a6e9761", "content": "[.small]#xref:web/webflux-view.adoc#webflux-view-freemarker-contextconfig[See equivalent in the Reactive stack]#\n\nThe following example shows how to configure FreeMarker as a view technology:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nYour templates need to be stored in the directory specified by the `FreeMarkerConfigurer`\nshown in the preceding example. Given the preceding configuration, if your controller\nreturns a view name of `welcome`, the resolver looks for the\n`/WEB-INF/freemarker/welcome.ftl` template.\n\n[[mvc-views-freemarker]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc", "title": "mvc-freemarker", "heading": "View Configuration", "heading_level": 2, "file_order": 397, "section_index": 1, "content_hash": "1ef8b7b9514c50cf6bac486326138e217607b17d24dc0bb85ded03e24a6e9761", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc"}}
{"id": "sha256:2c0713c33af3a547ba6c551e65f4398c55a586be94eeaf87a260a0d58628ed98", "content": "[.small]#xref:web/webflux-view.adoc#webflux-views-freemarker[See equivalent in the Reactive stack]#\n\nYou can pass FreeMarker 'Settings' and 'SharedVariables' directly to the FreeMarker\n`Configuration` object (which is managed by Spring) by setting the appropriate bean\nproperties on the `FreeMarkerConfigurer` bean. The `freemarkerSettings` property requires\na `java.util.Properties` object, and the `freemarkerVariables` property requires a\n`java.util.Map`. The following example shows how to use a `FreeMarkerConfigurer`:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nSee the FreeMarker documentation for details of settings and variables as they apply to\nthe `Configuration` object.\n\n[[mvc-view-freemarker-forms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc", "title": "mvc-freemarker", "heading": "FreeMarker Configuration", "heading_level": 2, "file_order": 397, "section_index": 2, "content_hash": "2c0713c33af3a547ba6c551e65f4398c55a586be94eeaf87a260a0d58628ed98", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc"}}
{"id": "sha256:ed1e668d1c4cf929c6b56ea50526a9b6d24d6f578d4935728f43f0c5f914c83f", "content": "[.small]#xref:web/webflux-view.adoc#webflux-view-freemarker-forms[See equivalent in the Reactive stack]#\n\nSpring provides a tag library for use in JSPs that contains, among others, a\n`<spring:bind/>` element. This element primarily lets forms display values from\nform-backing objects and show the results of failed validations from a `Validator` in the\nweb or business tier. Spring also has support for the same functionality in FreeMarker,\nwith additional convenience macros for generating form input elements themselves.\n\n[[mvc-view-bind-macros]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc", "title": "mvc-freemarker", "heading": "Form Handling", "heading_level": 2, "file_order": 397, "section_index": 3, "content_hash": "ed1e668d1c4cf929c6b56ea50526a9b6d24d6f578d4935728f43f0c5f914c83f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc"}}
{"id": "sha256:2e68e2bd34db2942c9c0775e5fed99eac8153df7c01165dbfaf288013060ba4b", "content": "[.small]#xref:web/webflux-view.adoc#webflux-view-bind-macros[See equivalent in the Reactive stack]#\n\nA standard set of macros are maintained within the `spring-webmvc.jar` file for\nFreeMarker, so they are always available to a suitably configured application.\n\nSome of the macros defined in the Spring templating libraries are considered internal\n(private), but no such scoping exists in the macro definitions, making all macros visible\nto calling code and user templates. The following sections concentrate only on the macros\nyou need to directly call from within your templates. If you wish to view the macro code\ndirectly, the file is called `spring.ftl` and is in the\n`org.springframework.web.servlet.view.freemarker` package.\n\n[[mvc-view-simple-binding]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc", "title": "mvc-freemarker", "heading": "The Bind Macros", "heading_level": 3, "file_order": 397, "section_index": 4, "content_hash": "2e68e2bd34db2942c9c0775e5fed99eac8153df7c01165dbfaf288013060ba4b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc"}}
{"id": "sha256:08839d231623acf3a68e09df22453174e893e6cb2a860cc7b10b2599371aeb52", "content": "In your HTML forms based on FreeMarker templates that act as a form view for a Spring MVC\ncontroller, you can use code similar to the next example to bind to field values and\ndisplay error messages for each input field in similar fashion to the JSP equivalent. The\nfollowing example shows a `personForm` view:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<!-- FreeMarker macros have to be imported into a namespace.\n We strongly recommend sticking to 'spring'. -->\n\t<#import \"/spring.ftl\" as spring/>\n\t<html>\n ...\n <form action=\"\" method=\"POST\">\n Name:\n <@spring.bind \"personForm.name\"/>\n <input type=\"text\"\n name=\"${spring.status.expression}\"\n value=\"${spring.status.value?html}\"/><br />\n <#list spring.status.errorMessages as error> <b>${error}</b> <br /> </#list>\n <br />\n ...\n <input type=\"submit\" value=\"submit\"/>\n </form>\n ...\n\t</html>\n----\n\n`<@spring.bind>` requires a 'path' argument, which consists of the name of your command\nobject (it is 'command', unless you changed it in your controller configuration) followed\nby a period and the name of the field on the command object to which you wish to bind. You\ncan also use nested fields, such as `command.address.street`. The `bind` macro assumes the\ndefault HTML escaping behavior specified by the `ServletContext` parameter\n`defaultHtmlEscape` in `web.xml`.\n\nAn alternative form of the macro called `<@spring.bindEscaped>` takes a second argument\nthat explicitly specifies whether HTML escaping should be used in the status error\nmessages or values. You can set it to `true` or `false` as required. Additional form\nhandling macros simplify the use of HTML escaping, and you should use these macros\nwherever possible. They are explained in the next section.\n\n[[mvc-views-form-macros]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc", "title": "mvc-freemarker", "heading": "Simple Binding", "heading_level": 3, "file_order": 397, "section_index": 5, "content_hash": "08839d231623acf3a68e09df22453174e893e6cb2a860cc7b10b2599371aeb52", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc"}}
{"id": "sha256:24bedf6bc1afe0e0e41709b98f39ed73285d951decb2600a4052b09a8acd25bf", "content": "Additional convenience macros for FreeMarker simplify both binding and form generation\n(including validation error display). It is never necessary to use these macros to\ngenerate form input fields, and you can mix and match them with simple HTML or direct\ncalls to the Spring bind macros that we highlighted previously.\n\nThe following table of available macros shows the FreeMarker Template (FTL) definitions\nand the parameter list that each takes:\n\n[[views-macros-defs-tbl]]\n.Table of macro definitions\n[cols=\"3,1\"]\n|===\n| macro | FTL definition\n\n| `message` (output a string from a resource bundle based on the code parameter)\n| <@spring.message code/>\n\n| `messageText` (output a string from a resource bundle based on the code parameter,\n falling back to the value of the default parameter)\n| <@spring.messageText code, text/>\n\n| `url` (prefix a relative URL with the application's context root)\n| <@spring.url relativeUrl/>\n\n| `formInput` (standard input field for gathering user input)\n| <@spring.formInput path, attributes, fieldType/>\n\n| `formHiddenInput` (hidden input field for submitting non-user input)\n| <@spring.formHiddenInput path, attributes/>\n\n| `formPasswordInput` (standard input field for gathering passwords. Note that no\n value is ever populated in fields of this type.)\n| <@spring.formPasswordInput path, attributes/>\n\n| `formTextarea` (large text field for gathering long, freeform text input)\n| <@spring.formTextarea path, attributes/>\n\n| `formSingleSelect` (drop down box of options that let a single required value be\n selected)\n| <@spring.formSingleSelect path, options, attributes/>\n\n| `formMultiSelect` (a list box of options that let the user select 0 or more values)\n| <@spring.formMultiSelect path, options, attributes/>\n\n| `formRadioButtons` (a set of radio buttons that let a single selection be made\n from the available choices)\n| <@spring.formRadioButtons path, options separator, attributes/>\n\n| `formCheckboxes` (a set of checkboxes that let 0 or more values be selected)\n| <@spring.formCheckboxes path, options, separator, attributes/>\n\n| `formCheckbox` (a single checkbox)\n| <@spring.formCheckbox path, attributes/>\n\n| `showErrors` (simplify display of validation errors for the bound field)\n| <@spring.showErrors separator, classOrStyle/>\n|===\n\nNOTE: In FreeMarker templates, `formHiddenInput` and `formPasswordInput` are not actually\nrequired, as you can use the normal `formInput` macro, specifying `hidden` or `password`\nas the value for the `fieldType` parameter.\n\nThe parameters to any of the above macros have consistent meanings:\n\n* `path`: The name of the field to bind to (for example, \"command.name\")\n* `options`: A `Map` of all the available values that can be selected from in the input\n field. The keys to the map represent the values that are POSTed back from the form\n and bound to the command object. Map objects stored against the keys are the labels\n displayed on the form to the user and may be different from the corresponding values\n posted back by the form. Usually, such a map is supplied as reference data by the\n controller. You can use any `Map` implementation, depending on required behavior.\n For strictly sorted maps, you can use a `SortedMap` (such as a `TreeMap`) with a\n suitable `Comparator` and, for arbitrary Maps that should return values in insertion\n order, use a `LinkedHashMap` or a `LinkedMap` from `commons-collections`.\n* `separator`: Where multiple options are available as discreet elements (radio buttons\n or checkboxes), the sequence of characters used to separate each one in the list\n (such as `<br>`).\n* `attributes`: An additional string of arbitrary tags or text to be included within\n the HTML tag itself. This string is echoed literally by the macro. For example, in a\n `textarea` field, you may supply attributes (such as 'rows=\"5\" cols=\"60\"'), or you\n could pass style information such as 'style=\"border:1px solid silver\"'.\n* `classOrStyle`: For the `showErrors` macro, the name of the CSS class that the `span`\n element that wraps each error uses. If no information is supplied (or the value is\n empty), the errors are wrapped in `<b></b>` tags.\n\nThe following sections outline examples of the macros.\n\n[[mvc-views-form-macros-input]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc", "title": "mvc-freemarker", "heading": "Input Macros", "heading_level": 3, "file_order": 397, "section_index": 6, "content_hash": "24bedf6bc1afe0e0e41709b98f39ed73285d951decb2600a4052b09a8acd25bf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc"}}
{"id": "sha256:b8b7bcf866a5a3bb8a276b2bb09c8d14be5f3616a26c6876dd6efa7fc882196f", "content": "The `formInput` macro takes the `path` parameter (`command.name`) and an additional `attributes`\nparameter (which is empty in the upcoming example). The macro, along with all other form\ngeneration macros, performs an implicit Spring bind on the path parameter. The binding\nremains valid until a new bind occurs, so the `showErrors` macro does not need to pass the\npath parameter again -- it operates on the field for which a binding was last created.\n\nThe `showErrors` macro takes a separator parameter (the characters that are used to\nseparate multiple errors on a given field) and also accepts a second parameter -- this\ntime, a class name or style attribute. Note that FreeMarker can specify default\nvalues for the attributes parameter. The following example shows how to use the `formInput`\nand `showErrors` macros:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<@spring.formInput \"command.name\"/>\n\t<@spring.showErrors \"<br>\"/>\n----\n\nThe next example shows the output of the form fragment, generating the name field and displaying a\nvalidation error after the form was submitted with no value in the field. Validation\noccurs through Spring's Validation framework.\n\nThe generated HTML resembles the following example:\n\n[source,jsp,indent=0,subs=\"verbatim,quotes\"]\n----\n\tName:\n\t<input type=\"text\" name=\"name\" value=\"\">\n\t<br>\n <b>required</b>\n\t<br>\n\t<br>\n----\n\nThe `formTextarea` macro works the same way as the `formInput` macro and accepts the same\nparameter list. Commonly, the second parameter (`attributes`) is used to pass style\ninformation or `rows` and `cols` attributes for the `textarea`.\n\n[[mvc-views-form-macros-select]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc", "title": "mvc-freemarker", "heading": "Input Fields", "heading_level": 4, "file_order": 397, "section_index": 7, "content_hash": "b8b7bcf866a5a3bb8a276b2bb09c8d14be5f3616a26c6876dd6efa7fc882196f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc"}}
{"id": "sha256:b30558ac0fe26146fad849561d70ec8dd2adc96cc9a3a9e92da843dc7e669279", "content": "You can use four selection field macros to generate common UI value selection inputs in\nyour HTML forms:\n\n* `formSingleSelect`\n* `formMultiSelect`\n* `formRadioButtons`\n* `formCheckboxes`\n\nEach of the four macros accepts a `Map` of options that contains the value for the form\nfield and the label that corresponds to that value. The value and the label can be the\nsame.\n\nThe next example is for radio buttons in FTL. The form-backing object specifies a default\nvalue of 'London' for this field, so no validation is necessary. When the form is\nrendered, the entire list of cities to choose from is supplied as reference data in the\nmodel under the name 'cityMap'. The following listing shows the example:\n\n[source,jsp,indent=0,subs=\"verbatim,quotes\"]\n----\n\t...\n\tTown:\n\t<@spring.formRadioButtons \"command.address.town\", cityMap, \"\"/><br><br>\n----\n\nThe preceding listing renders a line of radio buttons, one for each value in `cityMap`, and uses a\nseparator of `\"\"`. No additional attributes are supplied (the last parameter to the macro is\nmissing). The `cityMap` uses the same `String` for each key-value pair in the map. The map's\nkeys are what the form actually submits as `POST` request parameters. The map values are the\nlabels that the user sees. In the preceding example, given a list of three well known cities\nand a default value in the form backing object, the HTML resembles the following:\n\n[source,jsp,indent=0,subs=\"verbatim,quotes\"]\n----\n\tTown:\n\t<input type=\"radio\" name=\"address.town\" value=\"London\">London</input>\n\t<input type=\"radio\" name=\"address.town\" value=\"Paris\" checked=\"checked\">Paris</input>\n\t<input type=\"radio\" name=\"address.town\" value=\"New York\">New York</input>\n----\n\nIf your application expects to handle cities by internal codes (for example), you can create the map of\ncodes with suitable keys, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tprotected Map<String, ?> referenceData(HttpServletRequest request) throws Exception {\n Map<String, String> cityMap = new LinkedHashMap<>();\n cityMap.put(\"LDN\", \"London\");\n cityMap.put(\"PRS\", \"Paris\");\n cityMap.put(\"NYC\", \"New York\");\n\n Map<String, Object> model = new HashMap<>();\n model.put(\"cityMap\", cityMap);\n return model;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tprotected fun referenceData(request: HttpServletRequest): Map<String, *> {\n val cityMap = linkedMapOf(\n \"LDN\" to \"London\",\n \"PRS\" to \"Paris\",\n \"NYC\" to \"New York\"\n )\n return hashMapOf(\"cityMap\" to cityMap)\n\t}\n----\n======\n\nThe code now produces output where the radio values are the relevant codes, but the\nuser still sees the more user-friendly city names, as follows:\n\n[source,jsp,indent=0,subs=\"verbatim,quotes\"]\n----\n\tTown:\n\t<input type=\"radio\" name=\"address.town\" value=\"LDN\">London</input>\n\t<input type=\"radio\" name=\"address.town\" value=\"PRS\" checked=\"checked\">Paris</input>\n\t<input type=\"radio\" name=\"address.town\" value=\"NYC\">New York</input>\n----\n\n[[mvc-views-form-macros-html-escaping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc", "title": "mvc-freemarker", "heading": "Selection Fields", "heading_level": 4, "file_order": 397, "section_index": 8, "content_hash": "b30558ac0fe26146fad849561d70ec8dd2adc96cc9a3a9e92da843dc7e669279", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc"}}
{"id": "sha256:834ff166a114bdd9dc1fa0bd717c692a672769a0fd67ee41bab746e57d9a39af", "content": "Default usage of the form macros described earlier results in HTML elements that are HTML 4.01\ncompliant and that use the default value for HTML escaping defined in your `web.xml` file, as\nused by Spring's bind support. To make the elements be XHTML compliant or to override\nthe default HTML escaping value, you can specify two variables in your template (or in\nyour model, where they are visible to your templates). The advantage of specifying\nthem in the templates is that they can be changed to different values later in the\ntemplate processing to provide different behavior for different fields in your form.\n\nTo switch to XHTML compliance for your tags, specify a value of `true` for a\nmodel or context variable named `xhtmlCompliant`, as the following example shows:\n\n[source,jsp,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<#-- for FreeMarker -->\n\t<#assign xhtmlCompliant = true>\n----\n\nAfter processing this directive, any elements generated by the Spring macros are now XHTML\ncompliant.\n\nIn similar fashion, you can specify HTML escaping per field, as the following example shows:\n\n[source,jsp,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<#-- until this point, default HTML escaping is used -->\n\n\t<#assign htmlEscape = true>\n\t<#-- next field will use HTML escaping -->\n\t<@spring.formInput \"command.name\"/>\n\n\t<#assign htmlEscape = false in spring>\n\t<#-- all future fields will be bound with HTML escaping off -->\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc", "title": "mvc-freemarker", "heading": "HTML Escaping", "heading_level": 3, "file_order": 397, "section_index": 9, "content_hash": "834ff166a114bdd9dc1fa0bd717c692a672769a0fd67ee41bab746e57d9a39af", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-freemarker.adoc"}}
{"id": "sha256:b18d7ec1c76641e21516778108b335b0a62b3d5ba930c2f2968d0e7ac87e15c1", "content": "[[mvc-view-groovymarkup]]\n\nThe https://groovy-lang.org/templating.html#_the_markuptemplateengine[Groovy Markup Template Engine]\nis primarily aimed at generating XML-like markup (XML, XHTML, HTML5, and others), but you can\nuse it to generate any text-based content. The Spring Framework has a built-in\nintegration for using Spring MVC with Groovy Markup.\n\nNOTE: The Groovy Markup Template engine requires Groovy 2.3.1+.\n\n[[mvc-view-groovymarkup-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-groovymarkup.adoc", "title": "mvc-groovymarkup", "heading": "mvc-groovymarkup", "heading_level": 1, "file_order": 398, "section_index": 0, "content_hash": "b18d7ec1c76641e21516778108b335b0a62b3d5ba930c2f2968d0e7ac87e15c1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-groovymarkup.adoc"}}
{"id": "sha256:08a1476df26505b2a878e8e65902b408b96ae4a50adcd267f3bb01a0ec728e57", "content": "The following example shows how to configure the Groovy Markup Template Engine:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\n[[mvc-view-groovymarkup-example]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-groovymarkup.adoc", "title": "mvc-groovymarkup", "heading": "Configuration", "heading_level": 2, "file_order": 398, "section_index": 1, "content_hash": "08a1476df26505b2a878e8e65902b408b96ae4a50adcd267f3bb01a0ec728e57", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-groovymarkup.adoc"}}
{"id": "sha256:839e721b64dd1ed85c4fd85870940633a3ca2f781f195c2494aac1edd37ed24e", "content": "Unlike traditional template engines, Groovy Markup relies on a DSL that uses a builder\nsyntax. The following example shows a sample template for an HTML page:\n\n[source,groovy,indent=0,subs=\"verbatim,quotes\"]\n----\n\tyieldUnescaped '<!DOCTYPE html>'\n\thtml(lang:'en') {\n head {\n meta('http-equiv':'\"Content-Type\" content=\"text/html; charset=utf-8\"')\n title('My page')\n }\n body {\n p('This is an example of HTML contents')\n }\n\t}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-groovymarkup.adoc", "title": "mvc-groovymarkup", "heading": "Example", "heading_level": 2, "file_order": 398, "section_index": 2, "content_hash": "839e721b64dd1ed85c4fd85870940633a3ca2f781f195c2494aac1edd37ed24e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-groovymarkup.adoc"}}
{"id": "sha256:43c65058dfe856f6e15c8c74804d8664a97185377c0a3c333a7231c07099b3be", "content": "[[mvc-view-jackson]]\n\n[.small]#xref:web/webflux-view.adoc#webflux-view-httpmessagewriter[See equivalent in the Reactive stack]#\n\nSpring offers support for the Jackson JSON library.\n\n[[mvc-view-json-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jackson.adoc", "title": "mvc-jackson", "heading": "mvc-jackson", "heading_level": 1, "file_order": 399, "section_index": 0, "content_hash": "43c65058dfe856f6e15c8c74804d8664a97185377c0a3c333a7231c07099b3be", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jackson.adoc"}}
{"id": "sha256:7228c1f5a3cae869a41c3f83167ab1bb7cd73e67350f877b0d611bce404d3f7d", "content": "[.small]#xref:web/webflux-view.adoc#webflux-view-httpmessagewriter[See equivalent in the Reactive stack]#\n\nThe `JacksonJsonView` uses the Jackson library's `JsonMapper` to render the response\ncontent as JSON. By default, the entire contents of the model map (with the exception of\nframework-specific classes) are encoded as JSON. For cases where the contents of the\nmap need to be filtered, you can specify a specific set of model attributes to encode\nby using the `modelKeys` property. You can also use the `extractValueFromSingleKeyModel`\nproperty to have the value in single-key models extracted and serialized directly rather\nthan as a map of model attributes.\n\nYou can customize JSON mapping as needed by using Jackson's provided annotations. When\nyou need further control, you can inject a custom `JsonMapper` through the `JsonMapper`\nor `JsonMapper.Builder` constructor parameters, for cases where you need to provide\ncustom JSON serializers and deserializers for specific types.\n\n[[mvc-view-xml-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jackson.adoc", "title": "mvc-jackson", "heading": "Jackson-based JSON MVC Views", "heading_level": 2, "file_order": 399, "section_index": 1, "content_hash": "7228c1f5a3cae869a41c3f83167ab1bb7cd73e67350f877b0d611bce404d3f7d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jackson.adoc"}}
{"id": "sha256:19f1a48e8de76861893c4bb0dab2870061f1f104ca1e035e463943e81d3ad707", "content": "[.small]#xref:web/webflux-view.adoc#webflux-view-httpmessagewriter[See equivalent in the Reactive stack]#\n\n`JacksonXmlView` uses the\n{jackson-github-org}/jackson-dataformat-xml[Jackson XML extension's] `XmlMapper`\nto render the response content as XML. If the model contains multiple entries, you should\nexplicitly set the object to be serialized by using the `modelKey` bean property. If the\nmodel contains a single entry, it is serialized automatically.\n\nYou can customize XML mapping as needed by using JAXB or Jackson's provided\nannotations. When you need further control, you can inject a custom `XmlMapper`\ncreated via `XmlMapper.Builder` for cases where custom XML you need to provide\nserializers and deserializers for specific types.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jackson.adoc", "title": "mvc-jackson", "heading": "Jackson-based XML Views", "heading_level": 2, "file_order": 399, "section_index": 2, "content_hash": "19f1a48e8de76861893c4bb0dab2870061f1f104ca1e035e463943e81d3ad707", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jackson.adoc"}}
{"id": "sha256:01747ed25d3b3faa749bee09492e98c2888aeb7dc8b87401f15f90c7232d172d", "content": "[[mvc-view-jsp]]\n\nThe Spring Framework has a built-in integration for using Spring MVC with JSP and JSTL.\n\n[[mvc-view-jsp-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "mvc-jsp", "heading_level": 1, "file_order": 400, "section_index": 0, "content_hash": "01747ed25d3b3faa749bee09492e98c2888aeb7dc8b87401f15f90c7232d172d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:2bf29ea1b94a3cd1a54424fa7b69d7bf7ecd8811a3e01bb0dbc116816a0d7be4", "content": "When developing with JSPs, you typically declare an `InternalResourceViewResolver` bean.\n\n`InternalResourceViewResolver` can be used for dispatching to any Servlet resource but in\nparticular for JSPs. As a best practice, we strongly encourage placing your JSP files in\na directory under the `WEB-INF` directory so there can be no direct access by clients.\n\nThis is what is done by the configuration below which registers a JSP view resolver using\na default view name prefix of `\"/WEB-INF/\"` and a default suffix of `\".jsp\"`.\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\n[NOTE]\nYou can specify custom prefix and suffix.\n\n[[mvc-view-jsp-jstl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "View Resolvers", "heading_level": 2, "file_order": 400, "section_index": 1, "content_hash": "2bf29ea1b94a3cd1a54424fa7b69d7bf7ecd8811a3e01bb0dbc116816a0d7be4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:23469dfd8adc2e8a00630ad1ccf5135223c25a8b9881d088f80d8d0dfc95bb21", "content": "When using the JSP Standard Tag Library (JSTL) you must use a special view class, the\n`JstlView`, as JSTL needs some preparation before things such as the I18N features can work.\n\n[[mvc-view-jsp-tags]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "JSPs versus JSTL", "heading_level": 2, "file_order": 400, "section_index": 2, "content_hash": "23469dfd8adc2e8a00630ad1ccf5135223c25a8b9881d088f80d8d0dfc95bb21", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:4a9e90c0ccb571568e8686f4035c8a2092d50c72f2063285374de6565bf9a59f", "content": "Spring provides data binding of request parameters to command objects, as described in\nearlier chapters. To facilitate the development of JSP pages in combination with those\ndata binding features, Spring provides a few tags that make things even easier. All\nSpring tags have HTML escaping features to enable or disable escaping of characters.\n\nThe `spring.tld` tag library descriptor (TLD) is included in the `spring-webmvc.jar`.\nFor a comprehensive reference on individual tags, browse the\n{spring-framework-api}/web/servlet/tags/package-summary.html#package.description[API reference]\nor see the tag library description.\n\n[[mvc-view-jsp-formtaglib]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "Spring's JSP Tag Library", "heading_level": 2, "file_order": 400, "section_index": 3, "content_hash": "4a9e90c0ccb571568e8686f4035c8a2092d50c72f2063285374de6565bf9a59f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:9d2e0309f8848ccfa2858c825493874cf4df1fad8cfd79dbcfe900bceb7d912c", "content": "As of version 2.0, Spring provides a comprehensive set of data binding-aware tags for\nhandling form elements when using JSP and Spring Web MVC. Each tag provides support for\nthe set of attributes of its corresponding HTML tag counterpart, making the tags\nfamiliar and intuitive to use. The tag-generated HTML is HTML 4.01/XHTML 1.0 compliant.\n\nUnlike other form/input tag libraries, Spring's form tag library is integrated with\nSpring Web MVC, giving the tags access to the command object and reference data your\ncontroller deals with. As we show in the following examples, the form tags make\nJSPs easier to develop, read, and maintain.\n\nWe go through the form tags and look at an example of how each tag is used. We have\nincluded generated HTML snippets where certain tags require further commentary.\n\n[[mvc-view-jsp-formtaglib-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "Spring's form tag library", "heading_level": 2, "file_order": 400, "section_index": 4, "content_hash": "9d2e0309f8848ccfa2858c825493874cf4df1fad8cfd79dbcfe900bceb7d912c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:855c7e71805596624d10f5ef70af60e82c8715750bb6f1df857d869d7acaa025", "content": "The form tag library comes bundled in `spring-webmvc.jar`. The library descriptor is\ncalled `spring-form.tld`.\n\nTo use the tags from this library, add the following directive to the top of your JSP\npage:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %>\n----\nwhere `form` is the tag name prefix you want to use for the tags from this library.\n\n[[mvc-view-jsp-formtaglib-formtag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "Configuration", "heading_level": 3, "file_order": 400, "section_index": 5, "content_hash": "855c7e71805596624d10f5ef70af60e82c8715750bb6f1df857d869d7acaa025", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:0dfbfa07a6976464d214fac5bda66c38bd964aa959233a5841baa284886386f9", "content": "This tag renders an HTML 'form' element and exposes a binding path to inner tags for\nbinding. It puts the command object in the `PageContext` so that the command object can\nbe accessed by inner tags. All the other tags in this library are nested tags of the\n`form` tag.\n\nAssume that we have a domain object called `User`. It is a JavaBean with properties\nsuch as `firstName` and `lastName`. We can use it as the form-backing object of our\nform controller, which returns `form.jsp`. The following example shows what `form.jsp` could\nlook like:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<form:form>\n <table>\n <tr>\n <td>First Name:</td>\n <td><form:input path=\"firstName\"/></td>\n </tr>\n <tr>\n <td>Last Name:</td>\n <td><form:input path=\"lastName\"/></td>\n </tr>\n <tr>\n <td colspan=\"2\">\n <input type=\"submit\" value=\"Save Changes\"/>\n </td>\n </tr>\n </table>\n\t</form:form>\n----\n\nThe `firstName` and `lastName` values are retrieved from the command object placed in\nthe `PageContext` by the page controller. Keep reading to see more complex examples of\nhow inner tags are used with the `form` tag.\n\nThe following listing shows the generated HTML, which looks like a standard form:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<form method=\"POST\">\n <table>\n <tr>\n <td>First Name:</td>\n <td><input name=\"firstName\" type=\"text\" value=\"Harry\"/></td>\n </tr>\n <tr>\n <td>Last Name:</td>\n <td><input name=\"lastName\" type=\"text\" value=\"Potter\"/></td>\n </tr>\n <tr>\n <td colspan=\"2\">\n <input type=\"submit\" value=\"Save Changes\"/>\n </td>\n </tr>\n </table>\n\t</form>\n----\n\nThe preceding JSP assumes that the variable name of the form-backing object is\n`command`. If you have put the form-backing object into the model under another name\n(definitely a best practice), you can bind the form to the named variable, as the\nfollowing example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<form:form modelAttribute=\"user\">\n <table>\n <tr>\n <td>First Name:</td>\n <td><form:input path=\"firstName\"/></td>\n </tr>\n <tr>\n <td>Last Name:</td>\n <td><form:input path=\"lastName\"/></td>\n </tr>\n <tr>\n <td colspan=\"2\">\n <input type=\"submit\" value=\"Save Changes\"/>\n </td>\n </tr>\n </table>\n\t</form:form>\n----\n\n[[mvc-view-jsp-formtaglib-inputtag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The Form Tag", "heading_level": 3, "file_order": 400, "section_index": 6, "content_hash": "0dfbfa07a6976464d214fac5bda66c38bd964aa959233a5841baa284886386f9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:dbd3b2eba830878910b3e9e0ddffd0fd4feddade70a2590be06a854f8fc7b27c", "content": "This tag renders an HTML `input` element with the bound value and `type='text'` by default.\nFor an example of this tag, see xref:web/webmvc-view/mvc-jsp.adoc#mvc-view-jsp-formtaglib-formtag[The Form Tag]. You can also use\nHTML5-specific types, such as `email`, `tel`, `date`, and others.\n\n[[mvc-view-jsp-formtaglib-checkboxtag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The `input` Tag", "heading_level": 3, "file_order": 400, "section_index": 7, "content_hash": "dbd3b2eba830878910b3e9e0ddffd0fd4feddade70a2590be06a854f8fc7b27c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:ed484d517461b5b186fbc8452958d3f1c35e793cf8462cbcc004912f1924d8aa", "content": "This tag renders an HTML `input` tag with the `type` set to `checkbox`.\n\nAssume that our `User` has preferences such as newsletter subscription and a list of\nhobbies. The following example shows the `Preferences` class:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class Preferences {\n\n private boolean receiveNewsletter;\n private String[] interests;\n private String favouriteWord;\n\n public boolean isReceiveNewsletter() {\n return receiveNewsletter;\n }\n\n public void setReceiveNewsletter(boolean receiveNewsletter) {\n this.receiveNewsletter = receiveNewsletter;\n }\n\n public String[] getInterests() {\n return interests;\n }\n\n public void setInterests(String[] interests) {\n this.interests = interests;\n }\n\n public String getFavouriteWord() {\n return favouriteWord;\n }\n\n public void setFavouriteWord(String favouriteWord) {\n this.favouriteWord = favouriteWord;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass Preferences(\n var receiveNewsletter: Boolean,\n var interests: StringArray,\n var favouriteWord: String\n\t)\n----\n======\n\nThe corresponding `form.jsp` could then resemble the following:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<form:form>\n <table>\n <tr>\n <td>Subscribe to newsletter?:</td>\n <%-- Approach 1: Property is of type java.lang.Boolean --%>\n <td><form:checkbox path=\"preferences.receiveNewsletter\"/></td>\n </tr>\n\n <tr>\n <td>Interests:</td>\n <%-- Approach 2: Property is of an array or of type java.util.Collection --%>\n <td>\n Quidditch: <form:checkbox path=\"preferences.interests\" value=\"Quidditch\"/>\n Herbology: <form:checkbox path=\"preferences.interests\" value=\"Herbology\"/>\n Defence Against the Dark Arts: <form:checkbox path=\"preferences.interests\" value=\"Defence Against the Dark Arts\"/>\n </td>\n </tr>\n\n <tr>\n <td>Favourite Word:</td>\n <%-- Approach 3: Property is of type java.lang.Object --%>\n <td>\n Magic: <form:checkbox path=\"preferences.favouriteWord\" value=\"Magic\"/>\n </td>\n </tr>\n </table>\n\t</form:form>\n----\n\nThere are three approaches to the `checkbox` tag, which should meet all your checkbox needs.\n\n* Approach One: When the bound value is of type `java.lang.Boolean`, the\n `input(checkbox)` is marked as `checked` if the bound value is `true`. The `value`\n attribute corresponds to the resolved value of the `setValue(Object)` value property.\n* Approach Two: When the bound value is of type `array` or `java.util.Collection`, the\n `input(checkbox)` is marked as `checked` if the configured `setValue(Object)` value is\n present in the bound `Collection`.\n* Approach Three: For any other bound value type, the `input(checkbox)` is marked as\n `checked` if the configured `setValue(Object)` is equal to the bound value.\n\nNote that, regardless of the approach, the same HTML structure is generated. The following\nHTML snippet defines some checkboxes:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tr>\n <td>Interests:</td>\n <td>\n Quidditch: <input name=\"preferences.interests\" type=\"checkbox\" value=\"Quidditch\"/>\n <input type=\"hidden\" value=\"1\" name=\"_preferences.interests\"/>\n Herbology: <input name=\"preferences.interests\" type=\"checkbox\" value=\"Herbology\"/>\n <input type=\"hidden\" value=\"1\" name=\"_preferences.interests\"/>\n Defence Against the Dark Arts: <input name=\"preferences.interests\" type=\"checkbox\" value=\"Defence Against the Dark Arts\"/>\n <input type=\"hidden\" value=\"1\" name=\"_preferences.interests\"/>\n </td>\n\t</tr>\n----\n\nYou might not expect to see the additional hidden field after each checkbox.\nWhen a checkbox in an HTML page is not checked, its value is not sent to the\nserver as part of the HTTP request parameters once the form is submitted, so we need a\nworkaround for this quirk in HTML for Spring form data binding to work. The\n`checkbox` tag follows the existing Spring convention of including a hidden parameter\nprefixed by an underscore (`_`) for each checkbox. By doing this, you are effectively\ntelling Spring that \"`the checkbox was visible in the form, and I want my object to\nwhich the form data binds to reflect the state of the checkbox, no matter what.`\"\n\n[[mvc-view-jsp-formtaglib-checkboxestag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The `checkbox` Tag", "heading_level": 3, "file_order": 400, "section_index": 8, "content_hash": "ed484d517461b5b186fbc8452958d3f1c35e793cf8462cbcc004912f1924d8aa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:b92eea2149f3cf5ea5ded46d7caaaa23a08918b1a16fb0ccfebc24e14a1c3732", "content": "This tag renders multiple HTML `input` tags with the `type` set to `checkbox`.\n\nThis section build on the example from the previous `checkbox` tag section. Sometimes, you prefer\nnot to have to list all the possible hobbies in your JSP page. You would rather provide\na list at runtime of the available options and pass that in to the tag. That is the\npurpose of the `checkboxes` tag. You can pass in an `Array`, a `List`, or a `Map` that contains\nthe available options in the `items` property. Typically, the bound property is a\ncollection so that it can hold multiple values selected by the user. The following example\nshows a JSP that uses this tag:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<form:form>\n <table>\n <tr>\n <td>Interests:</td>\n <td>\n <%-- Property is of an array or of type java.util.Collection --%>\n <form:checkboxes path=\"preferences.interests\" items=\"${interestList}\"/>\n </td>\n </tr>\n </table>\n\t</form:form>\n----\n\nThis example assumes that the `interestList` is a `List` available as a model attribute\nthat contains strings of the values to be selected from. If you use a `Map`,\nthe map entry key is used as the value, and the map entry's value is used as\nthe label to be displayed. You can also use a custom object where you can provide the\nproperty names for the value by using `itemValue` and the label by using `itemLabel`.\n\n[[mvc-view-jsp-formtaglib-radiobuttontag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The `checkboxes` Tag", "heading_level": 3, "file_order": 400, "section_index": 9, "content_hash": "b92eea2149f3cf5ea5ded46d7caaaa23a08918b1a16fb0ccfebc24e14a1c3732", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:b9f934fb7a1522a284154d0e72efafae608936e2e622feca920f4e06050b3be8", "content": "This tag renders an HTML `input` element with the `type` set to `radio`.\n\nA typical usage pattern involves multiple tag instances bound to the same property\nbut with different values, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tr>\n <td>Sex:</td>\n <td>\n Male: <form:radiobutton path=\"sex\" value=\"M\"/> <br/>\n Female: <form:radiobutton path=\"sex\" value=\"F\"/>\n </td>\n\t</tr>\n----\n\n[[mvc-view-jsp-formtaglib-radiobuttonstag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The `radiobutton` Tag", "heading_level": 3, "file_order": 400, "section_index": 10, "content_hash": "b9f934fb7a1522a284154d0e72efafae608936e2e622feca920f4e06050b3be8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:95b575925181cab2563a1d9822499ad08a1491d5d008b6d88aa3825c8b038965", "content": "This tag renders multiple HTML `input` elements with the `type` set to `radio`.\n\nAs with the xref:web/webmvc-view/mvc-jsp.adoc#mvc-view-jsp-formtaglib-checkboxestag[`checkboxes` tag], you might want to\npass in the available options as a runtime variable. For this usage, you can use the\n`radiobuttons` tag. You pass in an `Array`, a `List`, or a `Map` that contains the\navailable options in the `items` property. If you use a `Map`, the map entry key is\nused as the value and the map entry's value are used as the label to be displayed.\nYou can also use a custom object where you can provide the property names for the value\nby using `itemValue` and the label by using `itemLabel`, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tr>\n <td>Sex:</td>\n <td><form:radiobuttons path=\"sex\" items=\"${sexOptions}\"/></td>\n\t</tr>\n----\n\n[[mvc-view-jsp-formtaglib-passwordtag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The `radiobuttons` Tag", "heading_level": 3, "file_order": 400, "section_index": 11, "content_hash": "95b575925181cab2563a1d9822499ad08a1491d5d008b6d88aa3825c8b038965", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:d7f9788e885b8f47e2797ac0cfb0288986b82d41640954593bd17281352c3b3e", "content": "This tag renders an HTML `input` tag with the type set to `password` with the bound value.\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tr>\n <td>Password:</td>\n <td>\n <form:password path=\"password\"/>\n </td>\n\t</tr>\n----\n\nNote that, by default, the password value is not shown. If you do want the\npassword value to be shown, you can set the value of the `showPassword` attribute to\n`true`, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tr>\n <td>Password:</td>\n <td>\n <form:password path=\"password\" value=\"^76525bvHGq\" showPassword=\"true\"/>\n </td>\n\t</tr>\n----\n\n[[mvc-view-jsp-formtaglib-selecttag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The `password` Tag", "heading_level": 3, "file_order": 400, "section_index": 12, "content_hash": "d7f9788e885b8f47e2797ac0cfb0288986b82d41640954593bd17281352c3b3e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:ad5d070110057d5cecd88588630839f11e9ba80dc30a47313aea1ace2e7422ae", "content": "This tag renders an HTML 'select' element. It supports data binding to the selected\noption as well as the use of nested `option` and `options` tags.\n\nAssume that a `User` has a list of skills. The corresponding HTML could be as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tr>\n <td>Skills:</td>\n <td><form:select path=\"skills\" items=\"${skills}\"/></td>\n\t</tr>\n----\n\nIf the `User's` skill are in Herbology, the HTML source of the 'Skills' row could be\nas follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tr>\n <td>Skills:</td>\n <td>\n <select name=\"skills\" multiple=\"true\">\n <option value=\"Potions\">Potions</option>\n <option value=\"Herbology\" selected=\"selected\">Herbology</option>\n <option value=\"Quidditch\">Quidditch</option>\n </select>\n </td>\n\t</tr>\n----\n\n[[mvc-view-jsp-formtaglib-optiontag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The `select` Tag", "heading_level": 3, "file_order": 400, "section_index": 13, "content_hash": "ad5d070110057d5cecd88588630839f11e9ba80dc30a47313aea1ace2e7422ae", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:68fdc8223e1a13b4cd65ac49777a0a9d1bab0a8e8676694b7ea06f7ec4569af8", "content": "This tag renders an HTML `option` element. It sets `selected`, based on the bound\nvalue. The following HTML shows typical output for it:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tr>\n <td>House:</td>\n <td>\n <form:select path=\"house\">\n <form:option value=\"Gryffindor\"/>\n <form:option value=\"Hufflepuff\"/>\n <form:option value=\"Ravenclaw\"/>\n <form:option value=\"Slytherin\"/>\n </form:select>\n </td>\n\t</tr>\n----\n\nIf the `User's` house was in Gryffindor, the HTML source of the 'House' row would be\nas follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tr>\n <td>House:</td>\n <td>\n <select name=\"house\">\n <option value=\"Gryffindor\" selected=\"selected\">Gryffindor</option> <1>\n <option value=\"Hufflepuff\">Hufflepuff</option>\n <option value=\"Ravenclaw\">Ravenclaw</option>\n <option value=\"Slytherin\">Slytherin</option>\n </select>\n </td>\n\t</tr>\n----\n<1> Note the addition of a `selected` attribute.\n\n[[mvc-view-jsp-formtaglib-optionstag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The `option` Tag", "heading_level": 3, "file_order": 400, "section_index": 14, "content_hash": "68fdc8223e1a13b4cd65ac49777a0a9d1bab0a8e8676694b7ea06f7ec4569af8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:36d89ba47b4db96f45a951d2e97f09dfed93fa06aa06649e6b0bb368b5ae1dd8", "content": "This tag renders a list of HTML `option` elements. It sets the `selected` attribute,\nbased on the bound value. The following HTML shows typical output for it:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tr>\n <td>Country:</td>\n <td>\n <form:select path=\"country\">\n <form:option value=\"-\" label=\"--Please Select\"/>\n <form:options items=\"${countryList}\" itemValue=\"code\" itemLabel=\"name\"/>\n </form:select>\n </td>\n\t</tr>\n----\n\nIf the `User` lived in the UK, the HTML source of the 'Country' row would be as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tr>\n <td>Country:</td>\n <td>\n <select name=\"country\">\n <option value=\"-\">--Please Select</option>\n <option value=\"AT\">Austria</option>\n <option value=\"UK\" selected=\"selected\">United Kingdom</option> <1>\n <option value=\"US\">United States</option>\n </select>\n </td>\n\t</tr>\n----\n<1> Note the addition of a `selected` attribute.\n\nAs the preceding example shows, the combined usage of an `option` tag with the `options` tag\ngenerates the same standard HTML but lets you explicitly specify a value in the\nJSP that is for display only (where it belongs), such as the default string in the\nexample: \"-- Please Select\".\n\nThe `items` attribute is typically populated with a collection or array of item objects.\n`itemValue` and `itemLabel` refer to bean properties of those item objects, if\nspecified. Otherwise, the item objects themselves are turned into strings. Alternatively,\nyou can specify a `Map` of items, in which case the map keys are interpreted as option\nvalues and the map values correspond to option labels. If `itemValue` or `itemLabel` (or both)\nhappen to be specified as well, the item value property applies to the map key, and\nthe item label property applies to the map value.\n\n[[mvc-view-jsp-formtaglib-textareatag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The `options` Tag", "heading_level": 3, "file_order": 400, "section_index": 15, "content_hash": "36d89ba47b4db96f45a951d2e97f09dfed93fa06aa06649e6b0bb368b5ae1dd8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:3240328ef003f9a3b55edfb8eb0a149c8be44082967deef7fc21306c0a1fbd87", "content": "This tag renders an HTML `textarea` element. The following HTML shows typical output for it:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<tr>\n <td>Notes:</td>\n <td><form:textarea path=\"notes\" rows=\"3\" cols=\"20\"/></td>\n <td><form:errors path=\"notes\"/></td>\n\t</tr>\n----\n\n[[mvc-view-jsp-formtaglib-hiddeninputtag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The `textarea` Tag", "heading_level": 3, "file_order": 400, "section_index": 16, "content_hash": "3240328ef003f9a3b55edfb8eb0a149c8be44082967deef7fc21306c0a1fbd87", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:01bc87237a4a873cbdefe4fcae2e0c6d991e37b51eed8a4004f77eb146e9c50c", "content": "This tag renders an HTML `input` tag with the `type` set to `hidden` with the bound value. To submit\nan unbound hidden value, use the HTML `input` tag with the `type` set to `hidden`.\nThe following HTML shows typical output for it:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<form:hidden path=\"house\"/>\n----\n\nIf we choose to submit the `house` value as a hidden one, the HTML would be as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<input name=\"house\" type=\"hidden\" value=\"Gryffindor\"/>\n\n----\n\n[[mvc-view-jsp-formtaglib-errorstag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The `hidden` Tag", "heading_level": 3, "file_order": 400, "section_index": 17, "content_hash": "01bc87237a4a873cbdefe4fcae2e0c6d991e37b51eed8a4004f77eb146e9c50c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:0572adacb406d71757631a3f977d8a1fca742d2d32a76db7f7ef7f3682256546", "content": "This tag renders field errors in an HTML `span` element. It provides access to the errors\ncreated in your controller or those that were created by any validators associated with\nyour controller.\n\nAssume that we want to display all error messages for the `firstName` and `lastName`\nfields once we submit the form. We have a validator for instances of the `User` class\ncalled `UserValidator`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class UserValidator implements Validator {\n\n public boolean supports(Class candidate) {\n return User.class.isAssignableFrom(candidate);\n }\n\n public void validate(Object obj, Errors errors) {\n ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"firstName\", \"required\", \"Field is required.\");\n ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"lastName\", \"required\", \"Field is required.\");\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass UserValidator : Validator {\n\n override fun supports(candidate: Class<*>): Boolean {\n return User::class.java.isAssignableFrom(candidate)\n }\n\n override fun validate(obj: Any, errors: Errors) {\n ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"firstName\", \"required\", \"Field is required.\")\n ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"lastName\", \"required\", \"Field is required.\")\n }\n\t}\n----\n======\n\nThe `form.jsp` could be as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<form:form>\n <table>\n <tr>\n <td>First Name:</td>\n <td><form:input path=\"firstName\"/></td>\n <%-- Show errors for firstName field --%>\n <td><form:errors path=\"firstName\"/></td>\n </tr>\n\n <tr>\n <td>Last Name:</td>\n <td><form:input path=\"lastName\"/></td>\n <%-- Show errors for lastName field --%>\n <td><form:errors path=\"lastName\"/></td>\n </tr>\n <tr>\n <td colspan=\"3\">\n <input type=\"submit\" value=\"Save Changes\"/>\n </td>\n </tr>\n </table>\n\t</form:form>\n----\n\nIf we submit a form with empty values in the `firstName` and `lastName` fields,\nthe HTML would be as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<form method=\"POST\">\n <table>\n <tr>\n <td>First Name:</td>\n <td><input name=\"firstName\" type=\"text\" value=\"\"/></td>\n <%-- Associated errors to firstName field displayed --%>\n <td><span name=\"firstName.errors\">Field is required.</span></td>\n </tr>\n\n <tr>\n <td>Last Name:</td>\n <td><input name=\"lastName\" type=\"text\" value=\"\"/></td>\n <%-- Associated errors to lastName field displayed --%>\n <td><span name=\"lastName.errors\">Field is required.</span></td>\n </tr>\n <tr>\n <td colspan=\"3\">\n <input type=\"submit\" value=\"Save Changes\"/>\n </td>\n </tr>\n </table>\n\t</form>\n----\n\nWhat if we want to display the entire list of errors for a given page? The next example\nshows that the `errors` tag also supports some basic wildcard functionality.\n\n* `path=\"{asterisk}\"`: Displays all errors.\n* `path=\"lastName\"`: Displays all errors associated with the `lastName` field.\n* If `path` is omitted, only object errors are displayed.\n\nThe following example displays a list of errors at the top of the page, followed by\nfield-specific errors next to the fields:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<form:form>\n <form:errors path=\"*\" cssClass=\"errorBox\"/>\n <table>\n <tr>\n <td>First Name:</td>\n <td><form:input path=\"firstName\"/></td>\n <td><form:errors path=\"firstName\"/></td>\n </tr>\n <tr>\n <td>Last Name:</td>\n <td><form:input path=\"lastName\"/></td>\n <td><form:errors path=\"lastName\"/></td>\n </tr>\n <tr>\n <td colspan=\"3\">\n <input type=\"submit\" value=\"Save Changes\"/>\n </td>\n </tr>\n </table>\n\t</form:form>\n----\n\nThe HTML would be as follows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<form method=\"POST\">\n <span name=\"*.errors\" class=\"errorBox\">Field is required.<br/>Field is required.</span>\n <table>\n <tr>\n <td>First Name:</td>\n <td><input name=\"firstName\" type=\"text\" value=\"\"/></td>\n <td><span name=\"firstName.errors\">Field is required.</span></td>\n </tr>\n\n <tr>\n <td>Last Name:</td>\n <td><input name=\"lastName\" type=\"text\" value=\"\"/></td>\n <td><span name=\"lastName.errors\">Field is required.</span></td>\n </tr>\n <tr>\n <td colspan=\"3\">\n <input type=\"submit\" value=\"Save Changes\"/>\n </td>\n </tr>\n </table>\n\t</form>\n----\n\nThe `spring-form.tld` tag library descriptor (TLD) is included in the `spring-webmvc.jar`.\nFor a comprehensive reference on individual tags, browse the\n{spring-framework-api}/web/servlet/tags/form/package-summary.html#package.description[API reference]\nor see the tag library description.\n\n[[mvc-rest-method-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "The `errors` Tag", "heading_level": 3, "file_order": 400, "section_index": 18, "content_hash": "0572adacb406d71757631a3f977d8a1fca742d2d32a76db7f7ef7f3682256546", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:bbc7ab6cd66d576779220cd4f09df5b76632a59361a3273eefaa299d334d73a6", "content": "A key principle of REST is the use of the \"`Uniform Interface`\". This means that all\nresources (URLs) can be manipulated by using the same four HTTP methods: GET, PUT, POST,\nand DELETE. For each method, the HTTP specification defines the exact semantics. For\ninstance, a GET should always be a safe operation, meaning that it has no side effects,\nand a PUT or DELETE should be idempotent, meaning that you can repeat these operations\nover and over again, but the end result should be the same. While HTTP defines these\nfour methods, HTML only supports two: GET and POST. Fortunately, there are two possible\nworkarounds: you can either use JavaScript to do your PUT or DELETE, or you can do a POST\nwith the \"`real`\" method as an additional parameter (modeled as a hidden input field in an\nHTML form). Spring's `HiddenHttpMethodFilter` uses this latter trick. This\nfilter is a plain Servlet filter and, therefore, it can be used in combination with any\nweb framework (not just Spring MVC). Add this filter to your web.xml, and a POST\nwith a hidden `method` parameter is converted into the corresponding HTTP method\nrequest.\n\nTo support HTTP method conversion, the Spring MVC form tag was updated to support setting\nthe HTTP method. For example, the following snippet comes from the Pet Clinic sample:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<form:form method=\"delete\">\n <p class=\"submit\"><input type=\"submit\" value=\"Delete Pet\"/></p>\n\t</form:form>\n----\n\nThe preceding example performs an HTTP POST, with the \"`real`\" DELETE method hidden behind\na request parameter. It is picked up by the `HiddenHttpMethodFilter`, which is defined in\nweb.xml, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<filter>\n <filter-name>httpMethodFilter</filter-name>\n <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n\t</filter>\n\n\t<filter-mapping>\n <filter-name>httpMethodFilter</filter-name>\n <servlet-name>petclinic</servlet-name>\n\t</filter-mapping>\n----\n\nThe following example shows the corresponding `@Controller` method:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RequestMapping(method = RequestMethod.DELETE)\n\tpublic String deletePet(@PathVariable int ownerId, @PathVariable int petId) {\n this.clinic.deletePet(petId);\n return \"redirect:/owners/\" + ownerId;\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RequestMapping(method = [RequestMethod.DELETE])\n\tfun deletePet(@PathVariable ownerId: Int, @PathVariable petId: Int): String {\n clinic.deletePet(petId)\n return \"redirect:/owners/$ownerId\"\n\t}\n----\n======\n\n[[mvc-view-jsp-formtaglib-html5]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "HTTP Method Conversion", "heading_level": 3, "file_order": 400, "section_index": 19, "content_hash": "bbc7ab6cd66d576779220cd4f09df5b76632a59361a3273eefaa299d334d73a6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:6c07902785331f68c161ad343174fc2fea859143280b50026fc1d9535bd12368", "content": "The Spring form tag library allows entering dynamic attributes, which means you can\nenter any HTML5 specific attributes.\n\nThe form `input` tag supports entering a type attribute other than `text`. This is\nintended to allow rendering new HTML5 specific input types, such as `email`, `date`,\n`range`, and others. Note that entering `type='text'` is not required, since `text`\nis the default type.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc", "title": "mvc-jsp", "heading": "HTML5 Tags", "heading_level": 3, "file_order": 400, "section_index": 20, "content_hash": "6c07902785331f68c161ad343174fc2fea859143280b50026fc1d9535bd12368", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-jsp.adoc"}}
{"id": "sha256:438a5b613a48354cf264a1dffbe3611aab06f7cc4fd1f14650828cebb00d6d20", "content": "[[mvc-view-script]]\n\n[.small]#xref:web/webflux-view.adoc#webflux-view-script[See equivalent in the Reactive stack]#\n\nThe Spring Framework has a built-in integration for using Spring MVC with any\ntemplating library that can run on top of the\n{JSR}223[JSR-223] Java scripting engine. We have tested the following\ntemplating libraries on different script engines:\n\n[%header]\n|===\n|Scripting Library |Scripting Engine\n|https://docs.ruby-lang.org/en/master/ERB.html[ERB] |https://www.jruby.org[JRuby]\n|https://docs.python.org/2/library/string.html#template-strings[String templates] |https://www.jython.org/[Jython]\n|===\n\nTIP: The basic rule for integrating any other script engine is that it must implement the\n`ScriptEngine` and `Invocable` interfaces.\n\n[[mvc-view-script-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-script.adoc", "title": "mvc-script", "heading": "mvc-script", "heading_level": 1, "file_order": 401, "section_index": 0, "content_hash": "438a5b613a48354cf264a1dffbe3611aab06f7cc4fd1f14650828cebb00d6d20", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-script.adoc"}}
{"id": "sha256:997adedbdc8608258a857cbfdbb8b977936e7d7ee1cb6b7b548d63d4de84de27", "content": "[.small]#xref:web/webflux-view.adoc#webflux-view-script-dependencies[See equivalent in the Reactive stack]#\n\nYou need to have the script engine on your classpath, the details of which vary by script engine:\n\n* https://www.jruby.org[JRuby] should be added as a dependency for Ruby support.\n* https://www.jython.org[Jython] should be added as a dependency for Python support.\n\n[[mvc-view-script-integrate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-script.adoc", "title": "mvc-script", "heading": "Requirements", "heading_level": 2, "file_order": 401, "section_index": 1, "content_hash": "997adedbdc8608258a857cbfdbb8b977936e7d7ee1cb6b7b548d63d4de84de27", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-script.adoc"}}
{"id": "sha256:72bbb3f610d74da9095d9a856e72989edb992590f5e39e97d0d2f66911440400", "content": "[.small]#xref:web/webflux-view.adoc#webflux-view-script-integrate[See equivalent in the Reactive stack]#\n\nYou can declare a `ScriptTemplateConfigurer` bean to specify the script engine to use,\nthe script files to load, what function to call to render templates, and so on.\nThe following example uses the Jython Python engine:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\nThe render function is called with the following parameters:\n\n* `String template`: The template content\n* `Map model`: The view model\n* `RenderingContext renderingContext`: The\n{spring-framework-api}/web/servlet/view/script/RenderingContext.html[`RenderingContext`]\nthat gives access to the application context, the locale, the template loader, and the\nURL\n\nThe controller is used to populate the model attributes and specify the view name, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class SampleController {\n\n @GetMapping(\"/sample\")\n public String test(Model model) {\n model.addAttribute(\"title\", \"Sample title\");\n model.addAttribute(\"body\", \"Sample body\");\n return \"template\";\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tclass SampleController {\n\n @GetMapping(\"/sample\")\n fun test(model: Model): String {\n model[\"title\"] = \"Sample title\"\n model[\"body\"] = \"Sample body\"\n return \"template\"\n }\n\t}\n----\n======\n\nCheck out the Spring Framework unit tests,\n{spring-framework-code}/spring-webmvc/src/test/java/org/springframework/web/servlet/view/script[Java], and\n{spring-framework-code}/spring-webmvc/src/test/resources/org/springframework/web/servlet/view/script[resources],\nfor more configuration examples.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-script.adoc", "title": "mvc-script", "heading": "Script Templates", "heading_level": 2, "file_order": 401, "section_index": 2, "content_hash": "72bbb3f610d74da9095d9a856e72989edb992590f5e39e97d0d2f66911440400", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-script.adoc"}}
{"id": "sha256:e4777d592ae7cada663dc4db275fcdeb5bfeeedd3ad365238ebd6d57818fc367", "content": "[[mvc-view-thymeleaf]]\n\n[.small]#xref:web/webflux-view.adoc#webflux-view-thymeleaf[See equivalent in the Reactive stack]#\n\nThymeleaf is a modern server-side Java template engine that emphasizes natural HTML\ntemplates that can be previewed in a browser by double-clicking, which is very helpful\nfor independent work on UI templates (for example, by a designer) without the need for\na running server. If you want to replace JSPs, Thymeleaf offers one of the most\nextensive sets of features to make such a transition easier. Thymeleaf is actively\ndeveloped and maintained. For a more complete introduction, see the\nhttps://www.thymeleaf.org/[Thymeleaf] project home page.\n\nThe Thymeleaf integration with Spring MVC is managed by the Thymeleaf project.\nThe configuration involves a few bean declarations, such as\n`ServletContextTemplateResolver`, `SpringTemplateEngine`, and `ThymeleafViewResolver`.\nSee https://www.thymeleaf.org/documentation.html[Thymeleaf+Spring] for more details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-thymeleaf.adoc", "title": "mvc-thymeleaf", "heading": "mvc-thymeleaf", "heading_level": 1, "file_order": 402, "section_index": 0, "content_hash": "e4777d592ae7cada663dc4db275fcdeb5bfeeedd3ad365238ebd6d57818fc367", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-thymeleaf.adoc"}}
{"id": "sha256:48c19408c56738939cc3c3508a68bf1c7dcfa8443262629ace2619949c4dd355", "content": "[[mvc-view-xml-marshalling]]\n\nThe `MarshallingView` uses an XML `Marshaller` (defined in the `org.springframework.oxm`\npackage) to render the response content as XML. You can explicitly set the object to be\nmarshalled by using a `MarshallingView` instance's `modelKey` bean property. Alternatively,\nthe view iterates over all model properties and marshals the first type that is supported\nby the `Marshaller`. For more information on the functionality in the\n`org.springframework.oxm` package, see xref:data-access/oxm.adoc[Marshalling XML using O/X Mappers].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-xml-marshalling.adoc", "title": "mvc-xml-marshalling", "heading": "mvc-xml-marshalling", "heading_level": 1, "file_order": 403, "section_index": 0, "content_hash": "48c19408c56738939cc3c3508a68bf1c7dcfa8443262629ace2619949c4dd355", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-xml-marshalling.adoc"}}
{"id": "sha256:5415c6bb0653372ecead7d6f4fec7847fc73038de33e640c69a3d224fc673e8a", "content": "[[mvc-view-xslt]]\n\nXSLT is a transformation language for XML and is popular as a view technology within web\napplications. XSLT can be a good choice as a view technology if your application\nnaturally deals with XML or if your model can easily be converted to XML. The following\nsection shows how to produce an XML document as model data and have it transformed with\nXSLT in a Spring Web MVC application.\n\nThis example is a trivial Spring application that creates a list of words in the\n`Controller` and adds them to the model map. The map is returned, along with the view\nname of our XSLT view. See xref:web/webmvc/mvc-controller.adoc[Annotated Controllers]\nfor details of Spring Web MVC's `Controller` interface. The XSLT controller turns the\nlist of words into a simple XML document ready for transformation.\n\n[[mvc-view-xslt-beandefs]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-xslt.adoc", "title": "mvc-xslt", "heading": "mvc-xslt", "heading_level": 1, "file_order": 404, "section_index": 0, "content_hash": "5415c6bb0653372ecead7d6f4fec7847fc73038de33e640c69a3d224fc673e8a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-xslt.adoc"}}
{"id": "sha256:361b62013ae033580031b4b1aaa28c975b09486b4c43d50d8057e3e3450a1d27", "content": "Configuration is standard for a simple Spring web application: The MVC configuration\nhas to define an `XsltViewResolver` bean and regular MVC annotation configuration.\nThe following example shows how to do so:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\n[[mvc-view-xslt-controllercode]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-xslt.adoc", "title": "mvc-xslt", "heading": "Beans", "heading_level": 2, "file_order": 404, "section_index": 1, "content_hash": "361b62013ae033580031b4b1aaa28c975b09486b4c43d50d8057e3e3450a1d27", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-xslt.adoc"}}
{"id": "sha256:39b4d6da8c6e0c33c6a241c215a4f9b4c2b94313b099c8838c7d219816778eb9", "content": "We also need a Controller that encapsulates our word-generation logic.\n\nThe controller logic is encapsulated in a `@Controller` class, with the\nhandler method being defined as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class XsltController {\n\n @RequestMapping(\"/\")\n public String home(Model model) throws Exception {\n Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();\n Element root = document.createElement(\"wordList\");\n\n List<String> words = Arrays.asList(\"Hello\", \"Spring\", \"Framework\");\n for (String word : words) {\n Element wordNode = document.createElement(\"word\");\n Text textNode = document.createTextNode(word);\n wordNode.appendChild(textNode);\n root.appendChild(wordNode);\n }\n\n model.addAttribute(\"wordList\", root);\n return \"home\";\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.ui.set\n\n\t@Controller\n\tclass XsltController {\n\n @RequestMapping(\"/\")\n fun home(model: Model): String {\n val document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument()\n val root = document.createElement(\"wordList\")\n\n val words = listOf(\"Hello\", \"Spring\", \"Framework\")\n for (word in words) {\n val wordNode = document.createElement(\"word\")\n val textNode = document.createTextNode(word)\n wordNode.appendChild(textNode)\n root.appendChild(wordNode)\n }\n\n model[\"wordList\"] = root\n return \"home\"\n }\n\t}\n----\n======\n\nSo far, we have only created a DOM document and added it to the Model map. Note that you\ncan also load an XML file as a `Resource` and use it instead of a custom DOM document.\n\nThere are software packages available that automatically 'domify'\nan object graph, but, within Spring, you have complete flexibility to create the DOM\nfrom your model in any way you choose. This prevents the transformation of XML playing\ntoo great a part in the structure of your model data, which is a danger when using tools\nto manage the DOMification process.\n\n[[mvc-view-xslt-transforming]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-xslt.adoc", "title": "mvc-xslt", "heading": "Controller", "heading_level": 2, "file_order": 404, "section_index": 2, "content_hash": "39b4d6da8c6e0c33c6a241c215a4f9b4c2b94313b099c8838c7d219816778eb9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-xslt.adoc"}}
{"id": "sha256:e03a4867e28aceab06e32ea956a9d82604d44975006195e945e01644472eed49", "content": "Finally, the `XsltViewResolver` resolves the \"`home`\" XSLT template file and merges the\nDOM document into it to generate our view. As shown in the `XsltViewResolver`\nconfiguration, XSLT templates live in the `war` file in the `WEB-INF/xsl` directory\nand end with an `xslt` file extension.\n\nThe following example shows an XSLT transform:\n\n[source,xml,indent=0,subs=\"verbatim,quotes\"]\n----\n\t<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n\n <xsl:output method=\"html\" omit-xml-declaration=\"yes\"/>\n\n <xsl:template match=\"/\">\n <html>\n <head><title>Hello!</title></head>\n <body>\n <h1>My First Words</h1>\n <ul>\n <xsl:apply-templates/>\n </ul>\n </body>\n </html>\n </xsl:template>\n\n <xsl:template match=\"word\">\n <li><xsl:value-of select=\".\"/></li>\n </xsl:template>\n\n\t</xsl:stylesheet>\n----\n\nThe preceding transform is rendered as the following HTML:\n\n[source,html,indent=0,subs=\"verbatim,quotes\"]\n----\n<html>\n\t<head>\n <META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n <title>Hello!</title>\n\t</head>\n\t<body>\n <h1>My First Words</h1>\n <ul>\n <li>Hello</li>\n <li>Spring</li>\n <li>Framework</li>\n </ul>\n\t</body>\n</html>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-xslt.adoc", "title": "mvc-xslt", "heading": "Transformation", "heading_level": 2, "file_order": 404, "section_index": 3, "content_hash": "e03a4867e28aceab06e32ea956a9d82604d44975006195e945e01644472eed49", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view/mvc-xslt.adoc"}}
{"id": "sha256:2274a7aa96dfe24ff9c085d94b7753a09e58e222f8fb7e31c4758ac7887617b0", "content": "[[websocket-stomp-application-context-events]]\n\nSeveral `ApplicationContext` events are published and can be\nreceived by implementing Spring's `ApplicationListener` interface:\n\n* `BrokerAvailabilityEvent`: Indicates when the broker becomes available or unavailable.\nWhile the \"`simple`\" broker becomes available immediately on startup and remains so while\nthe application is running, the STOMP \"`broker relay`\" can lose its connection\nto the full featured broker (for example, if the broker is restarted). The broker relay\nhas reconnect logic and re-establishes the \"`system`\" connection to the broker\nwhen it comes back. As a result, this event is published whenever the state changes from connected\nto disconnected and vice-versa. Components that use the `SimpMessagingTemplate` should\nsubscribe to this event and avoid sending messages at times when the broker is not\navailable. In any case, they should be prepared to handle `MessageDeliveryException`\nwhen sending a message.\n* `SessionConnectEvent`: Published when a new STOMP CONNECT is received to\nindicate the start of a new client session. The event contains the message that represents the\nconnect, including the session ID, user information (if any), and any custom headers the client\nsent. This is useful for tracking client sessions. Components subscribed\nto this event can wrap the contained message with `SimpMessageHeaderAccessor` or\n`StompMessageHeaderAccessor`.\n* `SessionConnectedEvent`: Published shortly after a `SessionConnectEvent` when the\nbroker has sent a STOMP CONNECTED frame in response to the CONNECT. At this point, the\nSTOMP session can be considered fully established.\n* `SessionSubscribeEvent`: Published when a new STOMP SUBSCRIBE is received.\n* `SessionUnsubscribeEvent`: Published when a new STOMP UNSUBSCRIBE is received.\n* `SessionDisconnectEvent`: Published when a STOMP session ends. The DISCONNECT may\nhave been sent from the client or it may be automatically generated when the\nWebSocket session is closed. In some cases, this event is published more than once\nper session. Components should be idempotent with regard to multiple disconnect events.\n\nNOTE: When you use a full-featured broker, the STOMP \"`broker relay`\" automatically reconnects the\n\"`system`\" connection if broker becomes temporarily unavailable. Client connections,\nhowever, are not automatically reconnected. Assuming heartbeats are enabled, the client\ntypically notices the broker is not responding within 10 seconds. Clients need to\nimplement their own reconnecting logic.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/application-context-events.adoc", "title": "application-context-events", "heading": "application-context-events", "heading_level": 1, "file_order": 405, "section_index": 0, "content_hash": "2274a7aa96dfe24ff9c085d94b7753a09e58e222f8fb7e31c4758ac7887617b0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/application-context-events.adoc"}}
{"id": "sha256:a2b52bc7f65ad6f288dfa28bcf5d266f151c398041fc479da32b229b16019326", "content": "[[websocket-stomp-authentication-token-based]]\n\n{spring-github-org}/spring-security-oauth[Spring Security OAuth]\nprovides support for token based security, including JSON Web Token (JWT).\nYou can use this as the authentication mechanism in Web applications,\nincluding STOMP over WebSocket interactions, as described in the previous\nsection (that is, to maintain identity through a cookie-based session).\n\nAt the same time, cookie-based sessions are not always the best fit (for example,\nin applications that do not maintain a server-side session or in\nmobile applications where it is common to use headers for authentication).\n\nThe {rfc-site}/rfc6455#section-10.5[WebSocket protocol, RFC 6455]\n\"doesn't prescribe any particular way that servers can authenticate clients during\nthe WebSocket handshake.\" In practice, however, browser clients can use only standard\nauthentication headers (that is, basic HTTP authentication) or cookies and cannot (for example)\nprovide custom headers. Likewise, the SockJS JavaScript client does not provide\na way to send HTTP headers with SockJS transport requests. See\n{sockjs-client}/issues/196[sockjs-client issue 196].\nInstead, it does allow sending query parameters that you can use to send a token,\nbut that has its own drawbacks (for example, the token may be inadvertently\nlogged with the URL in server logs).\n\nNOTE: The preceding limitations are for browser-based clients and do not apply to the\nSpring Java-based STOMP client, which does support sending headers with both\nWebSocket and SockJS requests.\n\nTherefore, applications that wish to avoid the use of cookies may not have any good\nalternatives for authentication at the HTTP protocol level. Instead of using cookies,\nthey may prefer to authenticate with headers at the STOMP messaging protocol level.\nDoing so requires two simple steps:\n\n. Use the STOMP client to pass authentication headers at connect time.\n. Process the authentication headers with a `ChannelInterceptor`.\n\nThe next example uses server-side configuration to register a custom authentication\ninterceptor. Note that an interceptor needs only to authenticate and set\nthe user header on the CONNECT `Message`. Spring notes and saves the authenticated\nuser and associate it with subsequent STOMP messages on the same session. The following\nexample shows how to register a custom authentication interceptor:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\nAlso, note that, when you use Spring Security's authorization for messages, at present,\nyou need to ensure that the authentication `ChannelInterceptor` config is ordered\nahead of Spring Security's. This is best done by declaring the custom interceptor in\nits own implementation of `WebSocketMessageBrokerConfigurer` that is marked with\n`@Order(Ordered.HIGHEST_PRECEDENCE + 99)`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/authentication-token-based.adoc", "title": "authentication-token-based", "heading": "authentication-token-based", "heading_level": 1, "file_order": 406, "section_index": 0, "content_hash": "a2b52bc7f65ad6f288dfa28bcf5d266f151c398041fc479da32b229b16019326", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/authentication-token-based.adoc"}}
{"id": "sha256:20f1c63f19739e1c732a555f6754281f9db1c3e9d4c6e22b466fd1c26c2917d3", "content": "[[websocket-stomp-authentication]]\n\nEvery STOMP over WebSocket messaging session begins with an HTTP request.\nThat can be a request to upgrade to WebSockets (that is, a WebSocket handshake)\nor, in the case of SockJS fallbacks, a series of SockJS HTTP transport requests.\n\nMany web applications already have authentication and authorization in place to\nsecure HTTP requests. Typically, a user is authenticated through Spring Security\nby using some mechanism such as a login page, HTTP basic authentication, or another way.\nThe security context for the authenticated user is saved in the HTTP session\nand is associated with subsequent requests in the same cookie-based session.\n\nTherefore, for a WebSocket handshake or for SockJS HTTP transport requests,\ntypically, there is already an authenticated user accessible through\n`HttpServletRequest#getUserPrincipal()`. Spring automatically associates that user\nwith a WebSocket or SockJS session created for them and, subsequently, with all\nSTOMP messages transported over that session through a user header.\n\nIn short, a typical web application needs to do nothing\nbeyond what it already does for security. The user is authenticated at\nthe HTTP request level with a security context that is maintained through a cookie-based\nHTTP session (which is then associated with WebSocket or SockJS sessions created\nfor that user) and results in a user header being stamped on every `Message` flowing\nthrough the application.\n\nThe STOMP protocol does have `login` and `passcode` headers on the `CONNECT` frame.\nThose were originally designed for and are needed for STOMP over TCP. However, for STOMP\nover WebSocket, by default, Spring ignores authentication headers at the STOMP protocol\nlevel, and assumes that the user is already authenticated at the HTTP transport level.\nThe expectation is that the WebSocket or SockJS session contain the authenticated user.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/authentication.adoc", "title": "authentication", "heading": "authentication", "heading_level": 1, "file_order": 407, "section_index": 0, "content_hash": "20f1c63f19739e1c732a555f6754281f9db1c3e9d4c6e22b466fd1c26c2917d3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/authentication.adoc"}}
{"id": "sha256:f91107ce2b2577701a956e2f109aa23fad865e1f90bb13b41c92e678391e649a", "content": "[[websocket-stomp-authorization]]\n\nSpring Security provides\n{docs-spring-security}/servlet/integrations/websocket.html#websocket-authorization[WebSocket sub-protocol authorization]\nthat uses a `ChannelInterceptor` to authorize messages based on the user header in them.\nAlso, Spring Session provides\n{docs-spring-session}/web-socket.html[WebSocket integration]\nthat ensures the user's HTTP session does not expire while the WebSocket session is still active.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/authorization.adoc", "title": "authorization", "heading": "authorization", "heading_level": 1, "file_order": 408, "section_index": 0, "content_hash": "f91107ce2b2577701a956e2f109aa23fad865e1f90bb13b41c92e678391e649a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/authorization.adoc"}}
{"id": "sha256:26741896ed38d2f40167862f48e77293384a8cd0e5bfcc1d826f32f16f8b2629", "content": "[[websocket-stomp-benefits]]\n\nUsing STOMP as a sub-protocol lets the Spring Framework and Spring Security\nprovide a richer programming model versus using raw WebSockets. The same point can be\nmade about HTTP versus raw TCP and how it lets Spring MVC and other web frameworks\nprovide rich functionality. The following is a list of benefits:\n\n* No need to invent a custom messaging protocol and message format.\n* STOMP clients, including a xref:web/websocket/stomp/client.adoc[Java client]\nin the Spring Framework, are available.\n* You can (optionally) use message brokers (such as RabbitMQ, ActiveMQ, and others) to\nmanage subscriptions and broadcast messages.\n* Application logic can be organized in any number of `@Controller` instances and messages can be\nrouted to them based on the STOMP destination header versus handling raw WebSocket messages\nwith a single `WebSocketHandler` for a given connection.\n* You can use Spring Security to secure messages based on STOMP destinations and message types.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/benefits.adoc", "title": "benefits", "heading": "benefits", "heading_level": 1, "file_order": 409, "section_index": 0, "content_hash": "26741896ed38d2f40167862f48e77293384a8cd0e5bfcc1d826f32f16f8b2629", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/benefits.adoc"}}
{"id": "sha256:179dc4a6cf3979ce6cd90300746ee45267f779d4ebb68e012b566ed011e19a1c", "content": "[[websocket-stomp-client]]\n\nSpring provides a STOMP over WebSocket client and a STOMP over TCP client.\n\nTo begin, you can create and configure `WebSocketStompClient`, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebSocketClient webSocketClient = new StandardWebSocketClient();\n\tWebSocketStompClient stompClient = new WebSocketStompClient(webSocketClient);\n\tstompClient.setMessageConverter(new StringMessageConverter());\n\tstompClient.setTaskScheduler(taskScheduler); // for heartbeats\n----\n\nIn the preceding example, you could replace `StandardWebSocketClient` with `SockJsClient`,\nsince that is also an implementation of `WebSocketClient`. The `SockJsClient` can\nuse WebSocket or HTTP-based transport as a fallback. For more details, see\nxref:web/websocket/fallback.adoc#websocket-fallback-sockjs-client[`SockJsClient`].\n\nNext, you can establish a connection and provide a handler for the STOMP session,\nas the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString url = \"ws://127.0.0.1:8080/endpoint\";\n\tStompSessionHandler sessionHandler = new MyStompSessionHandler();\n\tstompClient.connect(url, sessionHandler);\n----\n\nWhen the session is ready for use, the handler is notified, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\npublic class MyStompSessionHandler extends StompSessionHandlerAdapter {\n\n\t@Override\n\tpublic void afterConnected(StompSession session, StompHeaders connectedHeaders) {\n // ...\n\t}\n}\n----\n\nOnce the session is established, any payload can be sent and is\nserialized with the configured `MessageConverter`, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\nsession.send(\"/topic/something\", \"payload\");\n----\n\nYou can also subscribe to destinations. The `subscribe` methods require a handler\nfor messages on the subscription and returns a `Subscription` handle that you can\nuse to unsubscribe. For each received message, the handler can specify the target\n`Object` type to which the payload should be deserialized, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\nsession.subscribe(\"/topic/something\", new StompFrameHandler() {\n\n\t@Override\n\tpublic Type getPayloadType(StompHeaders headers) {\n return String.class;\n\t}\n\n\t@Override\n\tpublic void handleFrame(StompHeaders headers, Object payload) {\n // ...\n\t}\n\n});\n----\n\nTo enable STOMP heartbeat, you can configure `WebSocketStompClient` with a `TaskScheduler`\nand optionally customize the heartbeat intervals (10 seconds for write inactivity,\nwhich causes a heartbeat to be sent, and 10 seconds for read inactivity, which\ncloses the connection).\n\n`WebSocketStompClient` sends a heartbeat only in case of inactivity, i.e. when no\nother messages are sent. This can present a challenge when using an external broker\nsince messages with a non-broker destination represent activity but aren't actually\nforwarded to the broker. In that case you can configure a `TaskScheduler`\nwhen initializing the xref:web/websocket/stomp/handle-broker-relay.adoc[External Broker] which ensures a\nheartbeat is forwarded to the broker also when only messages with a non-broker\ndestination are sent.\n\nNOTE: When you use `WebSocketStompClient` for performance tests to simulate thousands\nof clients from the same machine, consider turning off heartbeats, since each\nconnection schedules its own heartbeat tasks and that is not optimized for\na large number of clients running on the same machine.\n\nThe STOMP protocol also supports receipts, where the client must add a `receipt`\nheader to which the server responds with a RECEIPT frame after the send or\nsubscribe are processed. To support this, the `StompSession` offers\n`setAutoReceipt(boolean)` that causes a `receipt` header to be\nadded on every subsequent send or subscribe event.\nAlternatively, you can also manually add a receipt header to the `StompHeaders`.\nBoth send and subscribe return an instance of `Receiptable`\nthat you can use to register for receipt success and failure callbacks.\nFor this feature, you must configure the client with a `TaskScheduler`\nand the amount of time before a receipt expires (15 seconds by default).\n\nNote that `StompSessionHandler` itself is a `StompFrameHandler`, which lets\nit handle ERROR frames in addition to the `handleException` callback for\nexceptions from the handling of messages and `handleTransportError` for\ntransport-level errors including `ConnectionLostException`.\n\nYou can use the `inboundMessageSizeLimit` and `outboundMessageSizeLimit` properties of\n`WebSocketStompClient` to limit the maximum size of inbound and outbound WebSocket\nmessages. When an outbound STOMP message exceeds the limit, it is split into partial frames,\nwhich the receiver would have to reassemble. By default, there is no size limit for outbound\nmessages. When an inbound STOMP message size exceeds the configured limit, a\n`StompConversionException` is thrown. The default size limit for inbound messages is `64KB`.\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebSocketClient webSocketClient = new StandardWebSocketClient();\n\tWebSocketStompClient stompClient = new WebSocketStompClient(webSocketClient);\n\tstompClient.setInboundMessageSizeLimit(64 * 1024); // 64KB\n\tstompClient.setOutboundMessageSizeLimit(64 * 1024); // 64KB\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/client.adoc", "title": "client", "heading": "client", "heading_level": 1, "file_order": 410, "section_index": 0, "content_hash": "179dc4a6cf3979ce6cd90300746ee45267f779d4ebb68e012b566ed011e19a1c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/client.adoc"}}
{"id": "sha256:06f4cb7edbda3dd2f878193376051a35f0821aceb59bb1ce84d52b5ba0fe1139", "content": "[[websocket-stomp-configuration-performance]]\n\nThere is no silver bullet when it comes to performance. Many factors\naffect it, including the size and volume of messages, whether application\nmethods perform work that requires blocking, and external factors\n(such as network speed and other issues). The goal of this section is to provide\nan overview of the available configuration options along with some thoughts\non how to reason about scaling.\n\nIn a messaging application, messages are passed through channels for asynchronous\nexecutions that are backed by thread pools. Configuring such an application requires\ngood knowledge of the channels and the flow of messages. Therefore, it is\nrecommended to review xref:web/websocket/stomp/message-flow.adoc[Flow of Messages].\n\nThe obvious place to start is to configure the thread pools that back the\n`clientInboundChannel` and the `clientOutboundChannel`. By default, both\nare configured at twice the number of available processors.\n\nIf the handling of messages in annotated methods is mainly CPU-bound, the\nnumber of threads for the `clientInboundChannel` should remain close to the\nnumber of processors. If the work they do is more IO-bound and requires blocking\nor waiting on a database or other external system, the thread pool size\nprobably needs to be increased.\n\n[NOTE]\n====\n`ThreadPoolExecutor` has three important properties: the core thread pool size,\nthe max thread pool size, and the capacity for the queue to store\ntasks for which there are no available threads.\n\nA common point of confusion is that configuring the core pool size (for example, 10)\nand max pool size (for example, 20) results in a thread pool with 10 to 20 threads.\nIn fact, if the capacity is left at its default value of Integer.MAX_VALUE,\nthe thread pool never increases beyond the core pool size, since\nall additional tasks are queued.\n\nSee the javadoc of `ThreadPoolExecutor` to learn how these properties work and\nunderstand the various queuing strategies.\n====\n\nOn the `clientOutboundChannel` side, it is all about sending messages to WebSocket\nclients. If clients are on a fast network, the number of threads should\nremain close to the number of available processors. If they are slow or on\nlow bandwidth, they take longer to consume messages and put a burden on the\nthread pool. Therefore, increasing the thread pool size becomes necessary.\n\nWhile the workload for the `clientInboundChannel` is possible to predict --\nafter all, it is based on what the application does -- how to configure the\n\"clientOutboundChannel\" is harder, as it is based on factors beyond\nthe control of the application. For this reason, two additional\nproperties relate to the sending of messages: `sendTimeLimit`\nand `sendBufferSizeLimit`. You can use those methods to configure how long a\nsend is allowed to take and how much data can be buffered when sending\nmessages to a client.\n\nThe general idea is that, at any given time, only a single thread can be used\nto send to a client. All additional messages, meanwhile, get buffered, and you\ncan use these properties to decide how long sending a message is allowed to\ntake and how much data can be buffered in the meantime. See the javadoc and\ndocumentation of the XML schema for important additional details.\n\nThe following example shows a possible configuration:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\nYou can also use the WebSocket transport configuration shown earlier to configure the\nmaximum allowed size for incoming STOMP messages. In theory, a WebSocket\nmessage can be almost unlimited in size. In practice, WebSocket servers impose\nlimits -- for example, 8K on Tomcat and 64K on Jetty. For this reason, STOMP clients\nsuch as https://github.com/stomp-js/stompjs[`stomp-js/stompjs`] and others split larger\nSTOMP messages at 16K boundaries and send them as multiple WebSocket messages,\nwhich requires the server to buffer and re-assemble.\n\nSpring's STOMP-over-WebSocket support does this, so applications can configure the\nmaximum size for STOMP messages irrespective of WebSocket server-specific message\nsizes. Keep in mind that the WebSocket message size is automatically\nadjusted, if necessary, to ensure they can carry 16K WebSocket messages at a\nminimum.\n\nThe following example shows one possible configuration:\n\ninclude-code::./MessageSizeLimitWebSocketConfiguration[tag=snippet,indent=0]\n\nAn important point about scaling involves using multiple application instances.\nCurrently, you cannot do that with the simple broker.\nHowever, when you use a full-featured broker (such as RabbitMQ), each application\ninstance connects to the broker, and messages broadcast from one application\ninstance can be broadcast through the broker to WebSocket clients connected\nthrough any other application instances.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/configuration-performance.adoc", "title": "configuration-performance", "heading": "configuration-performance", "heading_level": 1, "file_order": 411, "section_index": 0, "content_hash": "06f4cb7edbda3dd2f878193376051a35f0821aceb59bb1ce84d52b5ba0fe1139", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/configuration-performance.adoc"}}
{"id": "sha256:e4443885c412a367379068d9258f6481e2fe1ab4e8df868089081beebc05b28c", "content": "[[websocket-stomp-destination-separator]]\n\nWhen messages are routed to `@MessageMapping` methods, they are matched with\n`AntPathMatcher`. By default, patterns are expected to use slash (`/`) as the separator.\nThis is a good convention in web applications and similar to HTTP URLs. However, if\nyou are more used to messaging conventions, you can switch to using dot (`.`) as the separator.\n\nThe following example shows how to do so:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\nAfter that, a controller can use a dot (`.`) as the separator in `@MessageMapping` methods,\nas the following example shows:\n\ninclude-code::./RedController[tag=snippet,indent=0]\n\nThe client can now send a message to `/app/red.blue.green123`.\n\nIn the preceding example, we did not change the prefixes on the \"`broker relay`\", because those\ndepend entirely on the external message broker. See the STOMP documentation pages for\nthe broker you use to see what conventions it supports for the destination header.\n\nThe \"`simple broker`\", on the other hand, does rely on the configured `PathMatcher`, so, if\nyou switch the separator, that change also applies to the broker and the way the broker matches\ndestinations from a message to patterns in subscriptions.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/destination-separator.adoc", "title": "destination-separator", "heading": "destination-separator", "heading_level": 1, "file_order": 412, "section_index": 0, "content_hash": "e4443885c412a367379068d9258f6481e2fe1ab4e8df868089081beebc05b28c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/destination-separator.adoc"}}
{"id": "sha256:8850b3d78947fbacf55394e378ccd2797179c333c3ff76186135b32f8d1ceff9", "content": "[[websocket-stomp-enable]]\n\nSTOMP over WebSocket support is available in the `spring-messaging` and\n`spring-websocket` modules. Once you have those dependencies, you can expose a STOMP\nendpoint over WebSocket, as the following example shows:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\nNOTE: For the built-in simple broker, the `/topic` and `/queue` prefixes do not have any special\nmeaning. They are merely a convention to differentiate between pub-sub versus point-to-point\nmessaging (that is, many subscribers versus one consumer). When you use an external broker,\ncheck the STOMP page of the broker to understand what kind of STOMP destinations and\nprefixes it supports.\n\nTo connect from a browser, for STOMP, you can use\nhttps://github.com/stomp-js/stompjs[`stomp-js/stompjs`] which is the most\nactively maintained JavaScript library.\n\nThe following example code is based on it:\n\n[source,javascript,indent=0,subs=\"verbatim,quotes\"]\n----\n\tconst stompClient = new StompJs.Client({\n brokerURL: 'ws://domain.com/portfolio',\n onConnect: () => {\n // ...\n }\n\t});\n----\n\nAlternatively, if you connect through SockJS, you can enable the\nxref:web/websocket/fallback.adoc[SockJS Fallback] on server-side with\n`registry.addEndpoint(\"/portfolio\").withSockJS()` and on JavaScript side,\nby following\nhttps://stomp-js.github.io/guide/stompjs/rx-stomp/using-stomp-with-sockjs.html[those instructions].\n\nNote that `stompClient` in the preceding example does not need to specify `login`\nand `passcode` headers. Even if it did, they would be ignored (or, rather,\noverridden) on the server side. See xref:web/websocket/stomp/handle-broker-relay-configure.adoc[Connecting to a Broker]\nand xref:web/websocket/stomp/authentication.adoc[Authentication] for more information on authentication.\n\nFor more example code see:\n\n* {spring-site-guides}/gs/messaging-stomp-websocket/[Using WebSocket to build an\ninteractive web application] -- a getting started guide.\n* https://github.com/rstoyanchev/spring-websocket-portfolio[Stock Portfolio] -- a sample\napplication.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/enable.adoc", "title": "enable", "heading": "enable", "heading_level": 1, "file_order": 413, "section_index": 0, "content_hash": "8850b3d78947fbacf55394e378ccd2797179c333c3ff76186135b32f8d1ceff9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/enable.adoc"}}
{"id": "sha256:b17ac87674b8ad1c327952c9590ed8ec637c37b657d379c0e74f7a5d31b88b62", "content": "[[websocket-stomp-handle-annotations]]\n\nApplications can use annotated `@Controller` classes to handle messages from clients.\nSuch classes can declare `@MessageMapping`, `@SubscribeMapping`, and `@ExceptionHandler`\nmethods, as described in the following topics:\n\n* xref:web/websocket/stomp/handle-annotations.adoc#websocket-stomp-message-mapping[`@MessageMapping`]\n* xref:web/websocket/stomp/handle-annotations.adoc#websocket-stomp-subscribe-mapping[`@SubscribeMapping`]\n* xref:web/websocket/stomp/handle-annotations.adoc#websocket-stomp-exception-handler[`@MessageExceptionHandler`]\n\n[[websocket-stomp-message-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-annotations.adoc", "title": "handle-annotations", "heading": "handle-annotations", "heading_level": 1, "file_order": 414, "section_index": 0, "content_hash": "b17ac87674b8ad1c327952c9590ed8ec637c37b657d379c0e74f7a5d31b88b62", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-annotations.adoc"}}
{"id": "sha256:3a4854a81c829a80fb9a343ecbc69ed12df3e4d6d01298af1a18624d923ba7af", "content": "You can use `@MessageMapping` to annotate methods that route messages based on their\ndestination. It is supported at the method level as well as at the type level. At the type\nlevel, `@MessageMapping` is used to express shared mappings across all methods in a\ncontroller.\n\nBy default, the mapping values are Ant-style path patterns (for example `/thing*`, `/thing/**`),\nincluding support for template variables (for example, pass:q[`/thing/{id}`]). The values can be\nreferenced through `@DestinationVariable` method arguments. Applications can also switch to\na dot-separated destination convention for mappings, as explained in\nxref:web/websocket/stomp/destination-separator.adoc[Dots as Separators].\n\n[[supported-method-arguments]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-annotations.adoc", "title": "handle-annotations", "heading": "`@MessageMapping`", "heading_level": 2, "file_order": 414, "section_index": 1, "content_hash": "3a4854a81c829a80fb9a343ecbc69ed12df3e4d6d01298af1a18624d923ba7af", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-annotations.adoc"}}
{"id": "sha256:defca265070d0c07fa578c1f9364e0b7ddfba95b9524544aaefc5a587f126d42", "content": "The following table describes the method arguments:\n\n[cols=\"1,2\", options=\"header\"]\n|===\n| Method argument | Description\n\n| `Message`\n| For access to the complete message.\n\n| `MessageHeaders`\n| For access to the headers within the `Message`.\n\n| `MessageHeaderAccessor`, `SimpMessageHeaderAccessor`, and `StompHeaderAccessor`\n| For access to the headers through typed accessor methods.\n\n| `@Payload`\n| For access to the payload of the message, converted (for example, from JSON) by a configured\n`MessageConverter`.\n\nThe presence of this annotation is not required since it is, by default, assumed if no\nother argument is matched.\n\nYou can annotate payload arguments with `@jakarta.validation.Valid` or Spring's `@Validated`,\nto have the payload arguments be automatically validated.\n\n| `@Header`\n| For access to a specific header value -- along with type conversion using an\n`org.springframework.core.convert.converter.Converter`, if necessary.\n\n| `@Headers`\n| For access to all headers in the message. This argument must be assignable to\n`java.util.Map`.\n\n| `@DestinationVariable`\n| For access to template variables extracted from the message destination.\nValues are converted to the declared method argument type as necessary.\n\n| `java.security.Principal`\n| Reflects the user logged in at the time of the WebSocket HTTP handshake.\n\n|===\n\n[[return-values]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-annotations.adoc", "title": "handle-annotations", "heading": "Supported Method Arguments", "heading_level": 3, "file_order": 414, "section_index": 2, "content_hash": "defca265070d0c07fa578c1f9364e0b7ddfba95b9524544aaefc5a587f126d42", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-annotations.adoc"}}
{"id": "sha256:630742132266ff309958f53bac3cfb69006f58d078d8d2056d54f359eec0d887", "content": "By default, the return value from a `@MessageMapping` method is serialized to a payload\nthrough a matching `MessageConverter` and sent as a `Message` to the `brokerChannel`,\nfrom where it is broadcast to subscribers. The destination of the outbound message is the\nsame as that of the inbound message but prefixed with `/topic`.\n\nYou can use the `@SendTo` and `@SendToUser` annotations to customize the destination of\nthe output message. `@SendTo` is used to customize the target destination or to\nspecify multiple destinations. `@SendToUser` is used to direct the output message\nto only the user associated with the input message. See xref:web/websocket/stomp/user-destination.adoc[User Destinations].\n\nYou can use both `@SendTo` and `@SendToUser` at the same time on the same method, and both\nare supported at the class level, in which case they act as a default for methods in the\nclass. However, keep in mind that any method-level `@SendTo` or `@SendToUser` annotations\noverride any such annotations at the class level.\n\nMessages can be handled asynchronously and a `@MessageMapping` method can return\n`ListenableFuture`, `CompletableFuture`, or `CompletionStage`.\n\nNote that `@SendTo` and `@SendToUser` are merely a convenience that amounts to using the\n`SimpMessagingTemplate` to send messages. If necessary, for more advanced scenarios,\n`@MessageMapping` methods can fall back on using the `SimpMessagingTemplate` directly.\nThis can be done instead of, or possibly in addition to, returning a value.\nSee xref:web/websocket/stomp/handle-send.adoc[Sending Messages].\n\n[[websocket-stomp-subscribe-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-annotations.adoc", "title": "handle-annotations", "heading": "Return Values", "heading_level": 3, "file_order": 414, "section_index": 3, "content_hash": "630742132266ff309958f53bac3cfb69006f58d078d8d2056d54f359eec0d887", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-annotations.adoc"}}
{"id": "sha256:9f9336429b0ec3b71fbcac089319ae8dba2d54a374d2f82c5fc4d2347b968ab6", "content": "`@SubscribeMapping` is similar to `@MessageMapping` but narrows the mapping to\nsubscription messages only. It supports the same\nxref:web/websocket/stomp/handle-annotations.adoc#websocket-stomp-message-mapping[method arguments] as `@MessageMapping`. However\nfor the return value, by default, a message is sent directly to the client (through\n`clientOutboundChannel`, in response to the subscription) and not to the broker (through\n`brokerChannel`, as a broadcast to matching subscriptions). Adding `@SendTo` or\n`@SendToUser` overrides this behavior and sends to the broker instead.\n\nWhen is this useful? Assume that the broker is mapped to `/topic` and `/queue`, while\napplication controllers are mapped to `/app`. In this setup, the broker stores all\nsubscriptions to `/topic` and `/queue` that are intended for repeated broadcasts, and\nthere is no need for the application to get involved. A client could also subscribe to\nsome `/app` destination, and a controller could return a value in response to that\nsubscription without involving the broker without storing or using the subscription again\n(effectively a one-time request-reply exchange). One use case for this is populating a UI\nwith initial data on startup.\n\nWhen is this not useful? Do not try to map broker and controllers to the same destination\nprefix unless you want both to independently process messages, including subscriptions,\nfor some reason. Inbound messages are handled in parallel. There are no guarantees whether\na broker or a controller processes a given message first. If the goal is to be notified\nwhen a subscription is stored and ready for broadcasts, a client should ask for a\nreceipt if the server supports it (simple broker does not). For example, with the Java\nxref:web/websocket/stomp/client.adoc[STOMP client], you could do the following to add a receipt:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Autowired\n\tprivate TaskScheduler messageBrokerTaskScheduler;\n\n\t// During initialization..\n\tstompClient.setTaskScheduler(this.messageBrokerTaskScheduler);\n\n\t// When subscribing..\n\tStompHeaders headers = new StompHeaders();\n\theaders.setDestination(\"/topic/...\");\n\theaders.setReceipt(\"r1\");\n\tFrameHandler handler = ...;\n\tstompSession.subscribe(headers, handler).addReceiptTask(receiptHeaders -> {\n // Subscription ready...\n\t});\n----\n\nA server side option is xref:web/websocket/stomp/interceptors.adoc[to register] an\n`ExecutorChannelInterceptor` on the `brokerChannel` and implement the `afterMessageHandled`\nmethod that is invoked after messages, including subscriptions, have been handled.\n\n[[websocket-stomp-exception-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-annotations.adoc", "title": "handle-annotations", "heading": "`@SubscribeMapping`", "heading_level": 2, "file_order": 414, "section_index": 4, "content_hash": "9f9336429b0ec3b71fbcac089319ae8dba2d54a374d2f82c5fc4d2347b968ab6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-annotations.adoc"}}
{"id": "sha256:ba0e4bf1a3875b21f8dc383915eed78fc7375d0d9fa1a248e5978ce3b1380151", "content": "An application can use `@MessageExceptionHandler` methods to handle exceptions from\n`@MessageMapping` methods. You can declare exceptions in the annotation\nitself or through a method argument if you want to get access to the exception instance.\nThe following example declares an exception through a method argument:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class MyController {\n\n // ...\n\n @MessageExceptionHandler\n public ApplicationError handleException(MyException exception) {\n // ...\n return appError;\n }\n\t}\n----\n\n`@MessageExceptionHandler` methods support flexible method signatures and support\nthe same method argument types and return values as\nxref:web/websocket/stomp/handle-annotations.adoc#websocket-stomp-message-mapping[`@MessageMapping`] methods.\n\nTypically, `@MessageExceptionHandler` methods apply within the `@Controller` class\n(or class hierarchy) in which they are declared. If you want such methods to apply\nmore globally (across controllers), you can declare them in a class marked with\n`@ControllerAdvice`. This is comparable to the\nxref:web/webmvc/mvc-controller/ann-advice.adoc[similar support] available in Spring MVC.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-annotations.adoc", "title": "handle-annotations", "heading": "`@MessageExceptionHandler`", "heading_level": 2, "file_order": 414, "section_index": 5, "content_hash": "ba0e4bf1a3875b21f8dc383915eed78fc7375d0d9fa1a248e5978ce3b1380151", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-annotations.adoc"}}
{"id": "sha256:1da9df375a2ee66a725af44507704dcd8e4c904e115bba7152703fec3d0b83bb", "content": "[[websocket-stomp-handle-broker-relay-configure]]\n\nA STOMP broker relay maintains a single \"`system`\" TCP connection to the broker.\nThis connection is used for messages originating from the server-side application\nonly, not for receiving messages. You can configure the STOMP credentials (that is,\nthe STOMP frame `login` and `passcode` headers) for this connection. This is exposed\nin both the XML namespace and Java configuration as the `systemLogin` and\n`systemPasscode` properties with default values of `guest` and `guest`.\n\nThe STOMP broker relay also creates a separate TCP connection for every connected\nWebSocket client. You can configure the STOMP credentials that are used for all TCP\nconnections created on behalf of clients. This is exposed in both the XML namespace\nand Java configuration as the `clientLogin` and `clientPasscode` properties with default\nvalues of `guest` and `guest`.\n\nNOTE: The STOMP broker relay always sets the `login` and `passcode` headers on every `CONNECT`\nframe that it forwards to the broker on behalf of clients. Therefore, WebSocket clients\nneed not set those headers. They are ignored. As the xref:web/websocket/stomp/authentication.adoc[Authentication]\nsection explains, WebSocket clients should instead rely on HTTP authentication to protect\nthe WebSocket endpoint and establish the client identity.\n\nThe STOMP broker relay also sends and receives heartbeats to and from the message\nbroker over the \"`system`\" TCP connection. You can configure the intervals for sending\nand receiving heartbeats (10 seconds each by default). If connectivity to the broker\nis lost, the broker relay continues to try to reconnect, every 5 seconds,\nuntil it succeeds.\n\nAny Spring bean can implement `ApplicationListener<BrokerAvailabilityEvent>`\nto receive notifications when the \"`system`\" connection to the broker is lost and\nre-established. For example, a Stock Quote service that broadcasts stock quotes can\nstop trying to send messages when there is no active \"`system`\" connection.\n\nBy default, the STOMP broker relay always connects, and reconnects as needed if\nconnectivity is lost, to the same host and port. If you wish to supply multiple addresses,\non each attempt to connect, you can configure a supplier of addresses, instead of a\nfixed host and port. The following example shows how to do that:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\nYou can also configure the STOMP broker relay with a `virtualHost` property.\nThe value of this property is set as the `host` header of every `CONNECT` frame\nand can be useful (for example, in a cloud environment where the actual host to which\nthe TCP connection is established differs from the host that provides the\ncloud-based STOMP service).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-broker-relay-configure.adoc", "title": "handle-broker-relay-configure", "heading": "handle-broker-relay-configure", "heading_level": 1, "file_order": 415, "section_index": 0, "content_hash": "1da9df375a2ee66a725af44507704dcd8e4c904e115bba7152703fec3d0b83bb", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-broker-relay-configure.adoc"}}
{"id": "sha256:fe5f2e7b0f3dd3fb4ae00bb9f7120b616eee203dec38df93096951c76d94d03b", "content": "[[websocket-stomp-handle-broker-relay]]\n\nThe simple broker is great for getting started but supports only a subset of\nSTOMP commands (it does not support acks, receipts, and some other features),\nrelies on a simple message-sending loop, and is not suitable for clustering.\nAs an alternative, you can upgrade your applications to use a full-featured\nmessage broker.\n\nSee the STOMP documentation for your message broker of choice (such as\nhttps://www.rabbitmq.com/stomp.html[RabbitMQ],\nhttps://activemq.apache.org/stomp.html[ActiveMQ], and others), install the broker,\nand run it with STOMP support enabled. Then you can enable the STOMP broker relay\n(instead of the simple broker) in the Spring configuration.\n\nThe following example configuration enables a full-featured broker:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\nThe STOMP broker relay in the preceding configuration is a Spring\n{spring-framework-api}/messaging/MessageHandler.html[`MessageHandler`]\nthat handles messages by forwarding them to an external message broker.\nTo do so, it establishes TCP connections to the broker, forwards all messages to it,\nand then forwards all messages received from the broker to clients through their\nWebSocket sessions. Essentially, it acts as a \"`relay`\" that forwards messages\nin both directions.\n\nNOTE: Add `io.projectreactor.netty:reactor-netty` and `io.netty:netty-all`\ndependencies to your project for TCP connection management.\n\nFurthermore, application components (such as HTTP request handling methods,\nbusiness services, and others) can also send messages to the broker relay, as described\nin xref:web/websocket/stomp/handle-send.adoc[Sending Messages], to broadcast messages to subscribed WebSocket clients.\n\nIn effect, the broker relay enables robust and scalable message broadcasting.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-broker-relay.adoc", "title": "handle-broker-relay", "heading": "handle-broker-relay", "heading_level": 1, "file_order": 416, "section_index": 0, "content_hash": "fe5f2e7b0f3dd3fb4ae00bb9f7120b616eee203dec38df93096951c76d94d03b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-broker-relay.adoc"}}
{"id": "sha256:41bd70692fb67a613b377f9affc94c1f075e2fd066e4be27585eac9f5f84abd3", "content": "[[websocket-stomp-handle-send]]\n\nWhat if you want to send messages to connected clients from any part of the\napplication? Any application component can send messages to the `brokerChannel`.\nThe easiest way to do so is to inject a `SimpMessagingTemplate` and\nuse it to send messages. Typically, you would inject it by\ntype, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class GreetingController {\n\n private SimpMessagingTemplate template;\n\n @Autowired\n public GreetingController(SimpMessagingTemplate template) {\n this.template = template;\n }\n\n @RequestMapping(path=\"/greetings\", method=POST)\n public void greet(String greeting) {\n String text = \"[\" + getTimestamp() + \"]:\" + greeting;\n this.template.convertAndSend(\"/topic/greetings\", text);\n }\n\n\t}\n----\n\nHowever, you can also qualify it by its name (`brokerMessagingTemplate`), if another\nbean of the same type exists.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-send.adoc", "title": "handle-send", "heading": "handle-send", "heading_level": 1, "file_order": 417, "section_index": 0, "content_hash": "41bd70692fb67a613b377f9affc94c1f075e2fd066e4be27585eac9f5f84abd3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-send.adoc"}}
{"id": "sha256:f03afdf4b839bc812e7e15df3635cf1401c4038ee799a5015448054cc40c7350", "content": "[[websocket-stomp-handle-simple-broker]]\n\nThe built-in simple message broker handles subscription requests from clients,\nstores them in memory, and broadcasts messages to connected clients that have matching\ndestinations. The broker supports path-like destinations, including subscriptions\nto Ant-style destination patterns.\n\nNOTE: Applications can also use dot-separated (rather than slash-separated) destinations.\nSee xref:web/websocket/stomp/destination-separator.adoc[Dots as Separators].\n\nIf configured with a task scheduler, the simple broker supports\nhttps://stomp.github.io/stomp-specification-1.2.html#Heart-beating[STOMP heartbeats].\nTo configure a scheduler, you can declare your own `TaskScheduler` bean and set it through\nthe `MessageBrokerRegistry`. Alternatively, you can use the one that is automatically\ndeclared in the built-in WebSocket configuration, however, you'll need `@Lazy` to avoid\na cycle between the built-in WebSocket configuration and your\n`WebSocketMessageBrokerConfigurer`. For example:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-simple-broker.adoc", "title": "handle-simple-broker", "heading": "handle-simple-broker", "heading_level": 1, "file_order": 418, "section_index": 0, "content_hash": "f03afdf4b839bc812e7e15df3635cf1401c4038ee799a5015448054cc40c7350", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/handle-simple-broker.adoc"}}
{"id": "sha256:e0e27f4d2babcbc6e7a0b5bf75dbf6d472f4bb374616a507b408ab0fca3b2d5d", "content": "[[websocket-stomp-interceptors]]\n\nxref:web/websocket/stomp/application-context-events.adoc[Events] provide notifications for the lifecycle\nof a STOMP connection but not for every client message. Applications can also register a\n`ChannelInterceptor` to intercept any message and in any part of the processing chain.\nThe following example shows how to intercept inbound messages from clients:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\nA custom `ChannelInterceptor` can use `StompHeaderAccessor` or `SimpMessageHeaderAccessor`\nto access information about the message, as the following example shows:\n\ninclude-code::./MyChannelInterceptor[tag=snippet,indent=0]\n\nApplications can also implement `ExecutorChannelInterceptor`, which is a sub-interface\nof `ChannelInterceptor` with callbacks in the thread in which the messages are handled.\nWhile a `ChannelInterceptor` is invoked once for each message sent to a channel, the\n`ExecutorChannelInterceptor` provides hooks in the thread of each `MessageHandler`\nsubscribed to messages from the channel.\n\nNote that, as with the `SessionDisconnectEvent` described earlier, a DISCONNECT message\ncan be from the client or it can also be automatically generated when\nthe WebSocket session is closed. In some cases, an interceptor may intercept this\nmessage more than once for each session. Components should be idempotent with regard to\nmultiple disconnect events.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/interceptors.adoc", "title": "interceptors", "heading": "interceptors", "heading_level": 1, "file_order": 419, "section_index": 0, "content_hash": "e0e27f4d2babcbc6e7a0b5bf75dbf6d472f4bb374616a507b408ab0fca3b2d5d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/interceptors.adoc"}}
{"id": "sha256:a1bd9add891c99c63a721adac1ce69ef8a4f8119c851ba4e1e169e2a2285ab17", "content": "[[websocket-stomp-message-flow]]\n\nOnce a STOMP endpoint is exposed, the Spring application becomes a STOMP broker for\nconnected clients. This section describes the flow of messages on the server side.\n\nThe `spring-messaging` module contains foundational support for messaging applications\nthat originated in https://spring.io/spring-integration[Spring Integration] and was\nlater extracted and incorporated into the Spring Framework for broader use across many\n{spring-site-projects}[Spring projects] and application scenarios.\nThe following list briefly describes a few of the available messaging abstractions:\n\n* {spring-framework-api}/messaging/Message.html[Message]:\nSimple representation for a message, including headers and payload.\n* {spring-framework-api}/messaging/MessageHandler.html[MessageHandler]:\nContract for handling a message.\n* {spring-framework-api}/messaging/MessageChannel.html[MessageChannel]:\nContract for sending a message that enables loose coupling between producers and consumers.\n* {spring-framework-api}/messaging/SubscribableChannel.html[SubscribableChannel]:\n`MessageChannel` with `MessageHandler` subscribers.\n* {spring-framework-api}/messaging/support/ExecutorSubscribableChannel.html[ExecutorSubscribableChannel]:\n`SubscribableChannel` that uses an `Executor` for delivering messages.\n\nBoth the Java configuration (that is, `@EnableWebSocketMessageBroker`) and the XML namespace configuration\n(that is, `<websocket:message-broker>`) use the preceding components to assemble a message\nworkflow. The following diagram shows the components used when the simple built-in message\nbroker is enabled:\n\nimage::message-flow-simple-broker.png[]\n\nThe preceding diagram shows three message channels:\n\n* `clientInboundChannel`: For passing messages received from WebSocket clients.\n* `clientOutboundChannel`: For sending server messages to WebSocket clients.\n* `brokerChannel`: For sending messages to the message broker from within\nserver-side application code.\n\nThe next diagram shows the components used when an external broker (such as RabbitMQ)\nis configured for managing subscriptions and broadcasting messages:\n\nimage::message-flow-broker-relay.png[]\n\nThe main difference between the two preceding diagrams is the use of the \"`broker relay`\" for passing\nmessages up to the external STOMP broker over TCP and for passing messages down from the\nbroker to subscribed clients.\n\nWhen messages are received from a WebSocket connection, they are decoded to STOMP frames,\nturned into a Spring `Message` representation, and sent to the\n`clientInboundChannel` for further processing. For example, STOMP messages whose\ndestination headers start with `/app` may be routed to `@MessageMapping` methods in\nannotated controllers, while `/topic` and `/queue` messages may be routed directly\nto the message broker.\n\nAn annotated `@Controller` that handles a STOMP message from a client may send a message to\nthe message broker through the `brokerChannel`, and the broker broadcasts the\nmessage to matching subscribers through the `clientOutboundChannel`. The same\ncontroller can also do the same in response to HTTP requests, so a client can perform an\nHTTP POST, and then a `@PostMapping` method can send a message to the message broker\nto broadcast to subscribed clients.\n\nWe can trace the flow through a simple example. Consider the following example, which sets up a server:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\ninclude-code::./GreetingController[tag=snippet,indent=0]\n\nThe preceding example supports the following flow:\n\n. The client connects to `http://localhost:8080/portfolio` and, once a WebSocket connection\nis established, STOMP frames begin to flow on it.\n. The client sends a SUBSCRIBE frame with a destination header of `/topic/greeting`. Once received\nand decoded, the message is sent to the `clientInboundChannel` and is then routed to the\nmessage broker, which stores the client subscription.\n. The client sends a SEND frame to `/app/greeting`. The `/app` prefix helps to route it to\nannotated controllers. After the `/app` prefix is stripped, the remaining `/greeting`\npart of the destination is mapped to the `@MessageMapping` method in `GreetingController`.\n. The value returned from `GreetingController` is turned into a Spring `Message` with\na payload based on the return value and a default destination header of\n`/topic/greeting` (derived from the input destination with `/app` replaced by\n`/topic`). The resulting message is sent to the `brokerChannel` and handled\nby the message broker.\n. The message broker finds all matching subscribers and sends a MESSAGE frame to each one\nthrough the `clientOutboundChannel`, from where messages are encoded as STOMP frames\nand sent on the WebSocket connection.\n\nThe next section provides more details on annotated methods, including the\nkinds of arguments and return values that are supported.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/message-flow.adoc", "title": "message-flow", "heading": "message-flow", "heading_level": 1, "file_order": 420, "section_index": 0, "content_hash": "a1bd9add891c99c63a721adac1ce69ef8a4f8119c851ba4e1e169e2a2285ab17", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/message-flow.adoc"}}
{"id": "sha256:1be606aa547f7ce8141b3197e7b063e685b862bb19973ab2cef0ac7cfbe0dcf7", "content": "[[websocket-stomp-ordered-messages]]\n\nMessages from the broker are published to the `clientOutboundChannel`, from where they are\nwritten to WebSocket sessions. As the channel is backed by a `ThreadPoolExecutor`, messages\nare processed in different threads, and the resulting sequence received by the client may\nnot match the exact order of publication.\n\nTo enable ordered publishing, set the `setPreservePublishOrder` flag as follows:\n\ninclude-code::./PublishOrderWebSocketConfiguration[tag=snippet,indent=0]\n\nWhen the flag is set, messages within the same client session are published to the\n`clientOutboundChannel` one at a time, so that the order of publication is guaranteed.\nNote that this incurs a small performance overhead, so you should enable it only if it is required.\n\nThe same also applies to messages from the client, which are sent to the `clientInboundChannel`,\nfrom where they are handled according to their destination prefix. As the channel is backed by\na `ThreadPoolExecutor`, messages are processed in different threads, and the resulting sequence\nof handling may not match the exact order in which they were received.\n\nTo enable ordered receiving, set the `setPreserveReceiveOrder` flag as follows:\n\ninclude-code::./ReceiveOrderWebSocketConfiguration[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/ordered-messages.adoc", "title": "ordered-messages", "heading": "ordered-messages", "heading_level": 1, "file_order": 421, "section_index": 0, "content_hash": "1be606aa547f7ce8141b3197e7b063e685b862bb19973ab2cef0ac7cfbe0dcf7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/ordered-messages.adoc"}}
{"id": "sha256:973792228f716f68ae6b2a7739d81e2218b9e75139579bbbae2d5028025a0e9b", "content": "[[websocket-stomp-overview]]\n\nhttps://stomp.github.io/stomp-specification-1.2.html#Abstract[STOMP] (Simple\nText Oriented Messaging Protocol) was originally created for scripting languages\n(such as Ruby, Python, and Perl) to connect to enterprise message brokers. It is\ndesigned to address a minimal subset of commonly used messaging patterns. STOMP can be\nused over any reliable two-way streaming network protocol, such as TCP and WebSocket.\nAlthough STOMP is a text-oriented protocol, message payloads can be\neither text or binary.\n\nSTOMP is a frame-based protocol whose frames are modeled on HTTP. The following listing shows the structure\nof a STOMP frame:\n\n----\nCOMMAND\nheader1:value1\nheader2:value2\n\nBody^@\n----\n\nClients can use the `SEND` or `SUBSCRIBE` commands to send or subscribe for\nmessages, along with a `destination` header that describes what the\nmessage is about and who should receive it. This enables a simple\npublish-subscribe mechanism that you can use to send messages through the broker\nto other connected clients or to send messages to the server to request that\nsome work be performed.\n\nWhen you use Spring's STOMP support, the Spring WebSocket application acts\nas the STOMP broker to clients. Messages are routed to `@Controller` message-handling\nmethods or to a simple in-memory broker that keeps track of subscriptions and\nbroadcasts messages to subscribed users. You can also configure Spring to work\nwith a dedicated STOMP broker (such as RabbitMQ, ActiveMQ, and others) for the actual\nbroadcasting of messages. In that case, Spring maintains\nTCP connections to the broker, relays messages to it, and passes messages\nfrom it down to connected WebSocket clients. Thus, Spring web applications can\nrely on unified HTTP-based security, common validation, and a familiar programming\nmodel for message handling.\n\nThe following example shows a client subscribing to receive stock quotes, which\nthe server may emit periodically (for example, via a scheduled task that sends messages\nthrough a `SimpMessagingTemplate` to the broker):\n\n----\nSUBSCRIBE\nid:sub-1\ndestination:/topic/price.stock.*\n\n^@\n----\n\nThe following example shows a client that sends a trade request, which the server\ncan handle through an `@MessageMapping` method:\n\n----\nSEND\ndestination:/queue/trade\ncontent-type:application/json\ncontent-length:44\n\n{\"action\":\"BUY\",\"ticker\":\"MMM\",\"shares\":44}^@\n----\n\nAfter the execution, the server can\nbroadcast a trade confirmation message and details down to the client.\n\nThe meaning of a destination is intentionally left opaque in the STOMP spec. It can\nbe any string, and it is entirely up to STOMP servers to define the semantics and\nthe syntax of the destinations that they support. It is very common, however, for\ndestinations to be path-like strings where `/topic/..` implies publish-subscribe\n(one-to-many) and `/queue/` implies point-to-point (one-to-one) message\nexchanges.\n\nSTOMP servers can use the `MESSAGE` command to broadcast messages to all subscribers.\nThe following example shows a server sending a stock quote to a subscribed client:\n\n----\nMESSAGE\nmessage-id:nxahklf6-1\nsubscription:sub-1\ndestination:/topic/price.stock.MMM\n\n{\"ticker\":\"MMM\",\"price\":129.45}^@\n----\n\nA server cannot send unsolicited messages. All messages\nfrom a server must be in response to a specific client subscription, and the\n`subscription` header of the server message must match the `id` header of the\nclient subscription.\n\nThe preceding overview is intended to provide the most basic understanding of the\nSTOMP protocol. We recommended reviewing the protocol\nhttps://stomp.github.io/stomp-specification-1.2.html[specification] in full.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/overview.adoc", "title": "overview", "heading": "overview", "heading_level": 1, "file_order": 422, "section_index": 0, "content_hash": "973792228f716f68ae6b2a7739d81e2218b9e75139579bbbae2d5028025a0e9b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/overview.adoc"}}
{"id": "sha256:cf9bbeff671adf0889caad5d21bc6b713e58ad84dc05e86e19dc01bd3ea85848", "content": "[[websocket-stomp-websocket-scope]]\n\nEach WebSocket session has a map of attributes. The map is attached as a header to inbound\nclient messages and may be accessed from a controller method, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n@Controller\npublic class MyController {\n\n\t@MessageMapping(\"/action\")\n\tpublic void handle(SimpMessageHeaderAccessor headerAccessor) {\n Map<String, Object> attrs = headerAccessor.getSessionAttributes();\n // ...\n\t}\n}\n----\n\nYou can declare a Spring-managed bean in the `websocket` scope.\nYou can inject WebSocket-scoped beans into controllers and any channel interceptors\nregistered on the `clientInboundChannel`. Those are typically singletons and live\nlonger than any individual WebSocket session. Therefore, you need to use\nWebSocket-scoped beans in proxy mode, conveniently defined with `@WebSocketScope`:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Component\n\t@WebSocketScope\n\tpublic class MyBean {\n\n @PostConstruct\n public void init() {\n // Invoked after dependencies injected\n }\n\n // ...\n\n @PreDestroy\n public void destroy() {\n // Invoked when the WebSocket session ends\n }\n\t}\n\n\t@Controller\n\tpublic class MyController {\n\n private final MyBean myBean;\n\n @Autowired\n public MyController(MyBean myBean) {\n this.myBean = myBean;\n }\n\n @MessageMapping(\"/action\")\n public void handle() {\n // this.myBean from the current WebSocket session\n }\n\t}\n----\n\nAs with any custom scope, Spring initializes a new `MyBean` instance the first\ntime it is accessed from the controller and stores the instance in the WebSocket\nsession attributes. The same instance is subsequently returned until the session\nends. WebSocket-scoped beans have all Spring lifecycle methods invoked, as\nshown in the preceding examples.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/scope.adoc", "title": "scope", "heading": "scope", "heading_level": 1, "file_order": 423, "section_index": 0, "content_hash": "cf9bbeff671adf0889caad5d21bc6b713e58ad84dc05e86e19dc01bd3ea85848", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/scope.adoc"}}
{"id": "sha256:98035185fa612ba42631fa0b3a3b6cea8f6dbe0f72a0627f6697ece181a7bed4", "content": "[[websocket-stomp-server-config]]\n\nThis section explains how to configure the underlying WebSocket server transport.\n\nFor Jakarta WebSocket servers, add a `ServletServerContainerFactoryBean` to your\nconfiguration. For examples, see\nxref:web/websocket/server.adoc#websocket-server-runtime-configuration[Configuring the Server]\nunder the WebSocket section.\n\nFor Jetty WebSocket servers, customize the `JettyRequestUpgradeStrategy` as follows:\n\ninclude-code::./JettyWebSocketConfiguration[tag=snippet,indent=0]\n\nIn addition to WebSocket server properties, there are also STOMP WebSocket transport properties\nto customize as follows:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/server-config.adoc", "title": "server-config", "heading": "server-config", "heading_level": 1, "file_order": 424, "section_index": 0, "content_hash": "98035185fa612ba42631fa0b3a3b6cea8f6dbe0f72a0627f6697ece181a7bed4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/server-config.adoc"}}
{"id": "sha256:677c9cb474e34c014d83b55f1ca8d7d8b9dd8b56a3b391808ebb633cfe6a2e6c", "content": "[[websocket-stomp-stats]]\n\nWhen you use `@EnableWebSocketMessageBroker` or `<websocket:message-broker>`, key\ninfrastructure components automatically gather statistics and counters that provide\nimportant insight into the internal state of the application. The configuration\nalso declares a bean of type `WebSocketMessageBrokerStats` that gathers all\navailable information in one place and by default logs it at the `INFO` level once\nevery 30 minutes. This bean can be exported to JMX through Spring's\n`MBeanExporter` for viewing at runtime (for example, through JDK's `jconsole`).\nThe following list summarizes the available information:\n\nClient WebSocket Sessions::\n\tCurrent::: Indicates how many client sessions there are\n\tcurrently, with the count further broken down by WebSocket versus HTTP\n\tstreaming and polling SockJS sessions.\n\tTotal::: Indicates how many total sessions have been established.\n\tAbnormally Closed:::\n Connect Failures:::: Sessions that got established but were\n closed after not having received any messages within 60 seconds. This is\n usually an indication of proxy or network issues.\n Send Limit Exceeded:::: Sessions closed after exceeding the configured send\n timeout or the send buffer limits, which can occur with slow clients\n (see previous section).\n Transport Errors:::: Sessions closed after a transport error, such as\n failure to read or write to a WebSocket connection or\n HTTP request or response.\n\tSTOMP Frames::: The total number of CONNECT, CONNECTED, and DISCONNECT frames\n\tprocessed, indicating how many clients connected on the STOMP level. Note that\n\tthe DISCONNECT count may be lower when sessions get closed abnormally or when\n\tclients close without sending a DISCONNECT frame.\nSTOMP Broker Relay::\n\tTCP Connections::: Indicates how many TCP connections on behalf of client\n\tWebSocket sessions are established to the broker. This should be equal to the\n\tnumber of client WebSocket sessions + 1 additional shared \"`system`\" connection\n\tfor sending messages from within the application.\n\tSTOMP Frames::: The total number of CONNECT, CONNECTED, and DISCONNECT frames\n\tforwarded to or received from the broker on behalf of clients. Note that a\n\tDISCONNECT frame is sent to the broker regardless of how the client WebSocket\n\tsession was closed. Therefore, a lower DISCONNECT frame count is an indication\n\tthat the broker is pro-actively closing connections (maybe because of a\n\theartbeat that did not arrive in time, an invalid input frame, or other issue).\nClient Inbound Channel:: Statistics from the thread pool that backs the `clientInboundChannel`\n\tthat provide insight into the health of incoming message processing. Tasks queueing\n\tup here is an indication that the application may be too slow to handle messages.\n\tIf there I/O bound tasks (for example, slow database queries, HTTP requests to third party\n\tREST API, and so on), consider increasing the thread pool size.\nClient Outbound Channel:: Statistics from the thread pool that backs the `clientOutboundChannel`\n\tthat provides insight into the health of broadcasting messages to clients. Tasks\n\tqueueing up here is an indication clients are too slow to consume messages.\n\tOne way to address this is to increase the thread pool size to accommodate the\n\texpected number of concurrent slow clients. Another option is to reduce the\n\tsend timeout and send buffer size limits (see the previous section).\nSockJS Task Scheduler:: Statistics from the thread pool of the SockJS task scheduler that\n\tis used to send heartbeats. Note that, when heartbeats are negotiated on the\n\tSTOMP level, the SockJS heartbeats are disabled.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/stats.adoc", "title": "stats", "heading": "stats", "heading_level": 1, "file_order": 425, "section_index": 0, "content_hash": "677c9cb474e34c014d83b55f1ca8d7d8b9dd8b56a3b391808ebb633cfe6a2e6c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/stats.adoc"}}
{"id": "sha256:732a0b7d1aa7f0a137d6d697d71c5959dec4ad719b6e29379fb2a27c3430bf70", "content": "[[websocket-stomp-testing]]\n\nThere are two main approaches to testing applications when you use Spring's STOMP-over-WebSocket\nsupport. The first is to write server-side tests to verify the functionality\nof controllers and their annotated message-handling methods. The second is to write\nfull end-to-end tests that involve running a client and a server.\n\nThe two approaches are not mutually exclusive. On the contrary, each has a place\nin an overall test strategy. Server-side tests are more focused and easier to write\nand maintain. End-to-end integration tests, on the other hand, are more complete and\ntest much more, but they are also more involved to write and maintain.\n\nThe simplest form of server-side tests is to write controller unit tests. However,\nthis is not useful enough, since much of what a controller does depends on its\nannotations. Pure unit tests simply cannot test that.\n\nIdeally, controllers under test should be invoked as they are at runtime, much like\nthe approach to testing controllers that handle HTTP requests by using the Spring MVC Test\nframework -- that is, without running a Servlet container but relying on the Spring Framework\nto invoke the annotated controllers. As with Spring MVC Test, you have two\npossible alternatives here, either use a \"`context-based`\" or use a \"`standalone`\" setup:\n\n* Load the actual Spring configuration with the help of the\nSpring TestContext framework, inject `clientInboundChannel` as a test field, and\nuse it to send messages to be handled by controller methods.\n\n* Manually set up the minimum Spring framework infrastructure required to invoke\ncontrollers (namely the `SimpAnnotationMethodMessageHandler`) and pass messages for\ncontrollers directly to it.\n\nBoth of these setup scenarios are demonstrated in the\nhttps://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web[tests for the stock portfolio]\nsample application.\n\nThe second approach is to create end-to-end integration tests. For that, you need\nto run a WebSocket server in embedded mode and connect to it as a WebSocket client\nthat sends WebSocket messages containing STOMP frames.\nThe https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web[tests for the stock portfolio]\nsample application also demonstrate this approach by using Tomcat as the embedded\nWebSocket server and a simple STOMP client for test purposes.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/testing.adoc", "title": "testing", "heading": "testing", "heading_level": 1, "file_order": 426, "section_index": 0, "content_hash": "732a0b7d1aa7f0a137d6d697d71c5959dec4ad719b6e29379fb2a27c3430bf70", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/testing.adoc"}}
{"id": "sha256:2895b87153cf457b281144606fa2da5372db07cbd4ee24ef9e026e361165b63b", "content": "[[websocket-stomp-user-destination]]\n\nAn application can send messages that target a specific user, and Spring's STOMP support\nrecognizes destinations prefixed with `/user/` for this purpose.\nFor example, a client might subscribe to the `/user/queue/position-updates` destination.\n`UserDestinationMessageHandler` handles this destination and transforms it into a\ndestination unique to the user session (such as `/queue/position-updates-user123`).\nThis provides the convenience of subscribing to a generically named destination while,\nat the same time, ensuring no collisions with other users who subscribe to the same\ndestination so that each user can receive unique stock position updates.\n\nTIP: When working with user destinations, it is important to configure broker and\napplication destination prefixes as shown in xref:web/websocket/stomp/enable.adoc[Enable STOMP], or otherwise the\nbroker would handle \"/user\" prefixed messages that should only be handled by\n`UserDestinationMessageHandler`.\n\nOn the sending side, messages can be sent to a destination such as\npass:q[`/user/{username}/queue/position-updates`], which in turn is translated\nby the `UserDestinationMessageHandler` into one or more destinations, one for each\nsession associated with the user. This lets any component within the application\nsend messages that target a specific user without necessarily knowing anything more\nthan their name and the generic destination. This is also supported through an\nannotation and a messaging template.\n\nA message-handling method can send messages to the user associated with\nthe message being handled through the `@SendToUser` annotation (also supported on\nthe class-level to share a common destination), as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class PortfolioController {\n\n @MessageMapping(\"/trade\")\n @SendToUser(\"/queue/position-updates\")\n public TradeResult executeTrade(Trade trade, Principal principal) {\n // ...\n return tradeResult;\n }\n\t}\n----\n\nIf the user has more than one session, by default, all of the sessions subscribed\nto the given destination are targeted. However, sometimes, it may be necessary to\ntarget only the session that sent the message being handled. You can do so by\nsetting the `broadcast` attribute to false, as the following example shows:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class MyController {\n\n @MessageMapping(\"/action\")\n public void handleAction() throws Exception{\n // raise MyBusinessException here\n }\n\n @MessageExceptionHandler\n @SendToUser(destinations=\"/queue/errors\", broadcast=false)\n public ApplicationError handleException(MyBusinessException exception) {\n // ...\n return appError;\n }\n\t}\n----\n\nNOTE: While user destinations generally imply an authenticated user, it is not strictly required.\nA WebSocket session that is not associated with an authenticated user\ncan subscribe to a user destination. In such cases, the `@SendToUser` annotation\nbehaves exactly the same as with `broadcast=false` (that is, targeting only the\nsession that sent the message being handled).\n\nYou can send a message to user destinations from any application\ncomponent by, for example, injecting the `SimpMessagingTemplate` created by the Java configuration or\nthe XML namespace. (The bean name is `brokerMessagingTemplate` if required\nfor qualification with `@Qualifier`.) The following example shows how to do so:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n@Service\npublic class TradeServiceImpl implements TradeService {\n\n\tprivate final SimpMessagingTemplate messagingTemplate;\n\n\t@Autowired\n\tpublic TradeServiceImpl(SimpMessagingTemplate messagingTemplate) {\n this.messagingTemplate = messagingTemplate;\n\t}\n\n\t// ...\n\n\tpublic void afterTradeExecuted(Trade trade) {\n this.messagingTemplate.convertAndSendToUser(\n trade.getUserName(), \"/queue/position-updates\", trade.getResult());\n\t}\n}\n----\n\nNOTE: When you use user destinations with an external message broker, you should check the broker\ndocumentation on how to manage inactive queues, so that, when the user session is\nover, all unique user queues are removed. For example, RabbitMQ creates auto-delete\nqueues when you use destinations such as `/exchange/amq.direct/position-updates`.\nSo, in that case, the client could subscribe to `/user/exchange/amq.direct/position-updates`.\nSimilarly, ActiveMQ has\nhttps://activemq.apache.org/delete-inactive-destinations.html[configuration options]\nfor purging inactive destinations.\n\nIn a multi-application server scenario, a user destination may remain unresolved because\nthe user is connected to a different server. In such cases, you can configure a\ndestination to broadcast unresolved messages so that other servers have a chance to try.\nThis can be done through the `userDestinationBroadcast` property of the\n`MessageBrokerRegistry` in Java configuration and the `user-destination-broadcast` attribute\nof the `message-broker` element in XML.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp/user-destination.adoc", "title": "user-destination", "heading": "user-destination", "heading_level": 1, "file_order": 427, "section_index": 0, "content_hash": "2895b87153cf457b281144606fa2da5372db07cbd4ee24ef9e026e361165b63b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp/user-destination.adoc"}}
{"id": "sha256:44ee7c77ad67f569eebd307639d1bb819df8de3d86237684427dfb1cf91e3372", "content": "[[websocket-fallback]]\n\nOver the public Internet, restrictive proxies outside your control may preclude WebSocket\ninteractions, either because they are not configured to pass on the `Upgrade` header or\nbecause they close long-lived connections that appear to be idle.\n\nThe solution to this problem is WebSocket emulation -- that is, attempting to use WebSocket\nfirst and then falling back on HTTP-based techniques that emulate a WebSocket\ninteraction and expose the same application-level API.\n\nOn the Servlet stack, the Spring Framework provides both server (and also client) support\nfor the SockJS protocol.\n\n[[websocket-fallback-sockjs-overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc", "title": "fallback", "heading": "fallback", "heading_level": 1, "file_order": 428, "section_index": 0, "content_hash": "44ee7c77ad67f569eebd307639d1bb819df8de3d86237684427dfb1cf91e3372", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc"}}
{"id": "sha256:37cf931b73c0a9f5918dbec42a5db8e047d03335ea68a52e3bb2a66ac8bc5e11", "content": "The goal of SockJS is to let applications use a WebSocket API but fall back to\nnon-WebSocket alternatives when necessary at runtime, without the need to\nchange application code.\n\nSockJS consists of:\n\n* The {sockjs-protocol}[SockJS protocol]\ndefined in the form of executable\n{sockjs-protocol-site}/sockjs-protocol-0.3.3.html[narrated tests].\n* The {sockjs-client}[SockJS JavaScript client] -- a client library for use in browsers.\n* SockJS server implementations, including one in the Spring Framework `spring-websocket` module.\n* A SockJS Java client in the `spring-websocket` module (since version 4.1).\n\nSockJS is designed for use in browsers. It uses a variety of techniques\nto support a wide range of browser versions.\nFor the full list of SockJS transport types and browsers, see the\n{sockjs-client}[SockJS client] page. Transports\nfall in three general categories: WebSocket, HTTP Streaming, and HTTP Long Polling.\nFor an overview of these categories, see\n{spring-site-blog}/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[this blog post].\n\nThe SockJS client begins by sending `GET /info` to\nobtain basic information from the server. After that, it must decide what transport\nto use. If possible, WebSocket is used. If not, in most browsers,\nthere is at least one HTTP streaming option. If not, then HTTP (long)\npolling is used.\n\nAll transport requests have the following URL structure:\n\n----\nhttps://host:port/myApp/myEndpoint/{server-id}/{session-id}/{transport}\n----\n\nwhere:\n\n* pass:q[`{server-id}`] is useful for routing requests in a cluster but is not used otherwise.\n* pass:q[`{session-id}`] correlates HTTP requests belonging to a SockJS session.\n* pass:q[`{transport}`] indicates the transport type (for example, `websocket`, `xhr-streaming`, and others).\n\nThe WebSocket transport needs only a single HTTP request to do the WebSocket handshake.\nAll messages thereafter are exchanged on that socket.\n\nHTTP transports require more requests. Ajax/XHR streaming, for example, relies on\none long-running request for server-to-client messages and additional HTTP POST\nrequests for client-to-server messages. Long polling is similar, except that it\nends the current request after each server-to-client send.\n\nSockJS adds minimal message framing. For example, the server sends the letter `o`\n(\"`open`\" frame) initially, messages are sent as `a[\"message1\",\"message2\"]`\n(JSON-encoded array), the letter `h` (\"`heartbeat`\" frame) if no messages flow\nfor 25 seconds (by default), and the letter `c` (\"`close`\" frame) to close the session.\n\nTo learn more, run an example in a browser and watch the HTTP requests.\nThe SockJS client allows fixing the list of transports, so it is possible to\nsee each transport one at a time. The SockJS client also provides a debug flag,\nwhich enables helpful messages in the browser console. On the server side, you can enable\n`TRACE` logging for `org.springframework.web.socket`.\nFor even more detail, see the SockJS protocol\nhttps://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html[narrated test].\n\n[[websocket-fallback-sockjs-enable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc", "title": "fallback", "heading": "Overview", "heading_level": 2, "file_order": 428, "section_index": 1, "content_hash": "37cf931b73c0a9f5918dbec42a5db8e047d03335ea68a52e3bb2a66ac8bc5e11", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc"}}
{"id": "sha256:5df66f6d4397fb83dadc1f5cf120e027d8f34f2999a72f3019628ac9ac2e7879", "content": "You can enable SockJS through configuration, as the following example shows:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\nThe preceding example is for use in Spring MVC applications and should be included in the\nconfiguration of a xref:web/webmvc/mvc-servlet.adoc[`DispatcherServlet`]. However, Spring's WebSocket\nand SockJS support does not depend on Spring MVC. It is relatively simple to\nintegrate into other HTTP serving environments with the help of\n{spring-framework-api}/web/socket/sockjs/support/SockJsHttpRequestHandler.html[`SockJsHttpRequestHandler`].\n\nOn the browser side, applications can use the\n{sockjs-client}[`sockjs-client`] (version 1.0.x). It\nemulates the W3C WebSocket API and communicates with the server to select the best\ntransport option, depending on the browser in which it runs. See the\n{sockjs-client}[sockjs-client] page and the list of\ntransport types supported by browser. The client also provides several\nconfiguration options -- for example, to specify which transports to include.\n\n[[websocket-fallback-xhr-vs-iframe]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc", "title": "fallback", "heading": "Enabling SockJS", "heading_level": 2, "file_order": 428, "section_index": 2, "content_hash": "5df66f6d4397fb83dadc1f5cf120e027d8f34f2999a72f3019628ac9ac2e7879", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc"}}
{"id": "sha256:e9a846cdf445e6ad0033b944442e81f61edfefc2d42990dcd5aa2957cfb84bda", "content": "Internet Explorer 8 and 9 remain in use. They are\na key reason for having SockJS. This section covers important\nconsiderations about running in those browsers.\n\nThe SockJS client supports Ajax/XHR streaming in IE 8 and 9 by using Microsoft's\nhttps://web.archive.org/web/20160219230343/https://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx[`XDomainRequest`].\nThat works across domains but does not support sending cookies.\nCookies are often essential for Java applications.\nHowever, since the SockJS client can be used with many server\ntypes (not just Java ones), it needs to know whether cookies matter.\nIf so, the SockJS client prefers Ajax/XHR for streaming. Otherwise, it\nrelies on an iframe-based technique.\n\nThe first `/info` request from the SockJS client is a request for\ninformation that can influence the client's choice of transports.\nOne of those details is whether the server application relies on cookies\n(for example, for authentication purposes or clustering with sticky sessions).\nSpring's SockJS support includes a property called `sessionCookieNeeded`.\nIt is enabled by default, since most Java applications rely on the `JSESSIONID`\ncookie. If your application does not need it, you can turn off this option,\nand SockJS client should then choose `xdr-streaming` in IE 8 and 9.\n\nIf you do use an iframe-based transport, keep in mind\nthat browsers can be instructed to block the use of IFrames on a given page by\nsetting the HTTP response header `X-Frame-Options` to `DENY`,\n`SAMEORIGIN`, or `ALLOW-FROM <origin>`. This is used to prevent\nhttps://www.owasp.org/index.php/Clickjacking[clickjacking].\n\n[NOTE]\n====\nSpring Security 3.2+ provides support for setting `X-Frame-Options` on every\nresponse. By default, the Spring Security Java configuration sets it to `DENY`.\nIn 3.2, the Spring Security XML namespace does not set that header by default\nbut can be configured to do so. In the future, it may set it by default.\n\nSee {docs-spring-security}/features/exploits/headers.html#headers-default[Default Security Headers]\nof the Spring Security documentation for details on how to configure the\nsetting of the `X-Frame-Options` header. You can also see\n{spring-github-org}/spring-security/issues/2718[gh-2718]\nfor additional background.\n====\n\nIf your application adds the `X-Frame-Options` response header (as it should!)\nand relies on an iframe-based transport, you need to set the header value to\n`SAMEORIGIN` or `ALLOW-FROM <origin>`. The Spring SockJS\nsupport also needs to know the location of the SockJS client, because it is loaded\nfrom the iframe. By default, the iframe is set to download the SockJS client\nfrom a CDN location. It is a good idea to configure this option to use\na URL from the same origin as the application.\n\nThe following example shows how to configure it:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\nNOTE: During initial development, do enable the SockJS client `devel` mode that prevents\nthe browser from caching SockJS requests (like the iframe) that would otherwise\nbe cached. For details on how to enable it see the\n{sockjs-client}[SockJS client] page.\n\n[[websocket-fallback-sockjs-heartbeat]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc", "title": "fallback", "heading": "IE 8 and 9", "heading_level": 2, "file_order": 428, "section_index": 3, "content_hash": "e9a846cdf445e6ad0033b944442e81f61edfefc2d42990dcd5aa2957cfb84bda", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc"}}
{"id": "sha256:b9d1505aa059571aea004d4be6dddfc8fa46f605b5142ca6016132c7ca72e8df", "content": "The SockJS protocol requires servers to send heartbeat messages to preclude proxies\nfrom concluding that a connection is hung. The Spring SockJS configuration has a property\ncalled `heartbeatTime` that you can use to customize the frequency. By default, a\nheartbeat is sent after 25 seconds, assuming no other messages were sent on that\nconnection. This 25-second value is in line with the following\n{rfc-site}/rfc6202[IETF recommendation] for public Internet applications.\n\nNOTE: When using STOMP over WebSocket and SockJS, if the STOMP client and server negotiate\nheartbeats to be exchanged, the SockJS heartbeats are disabled.\n\nThe Spring SockJS support also lets you configure the `TaskScheduler` to\nschedule heartbeats tasks. The task scheduler is backed by a thread pool,\nwith default settings based on the number of available processors. You\nshould consider customizing the settings according to your specific needs.\n\n[[websocket-fallback-sockjs-servlet3-async]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc", "title": "fallback", "heading": "Heartbeats", "heading_level": 2, "file_order": 428, "section_index": 4, "content_hash": "b9d1505aa059571aea004d4be6dddfc8fa46f605b5142ca6016132c7ca72e8df", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc"}}
{"id": "sha256:ac61f49c7b1df415a303c9192084c99b259a76db951d0a9002398aeb5369d5a6", "content": "HTTP streaming and HTTP long polling SockJS transports require a connection to remain\nopen longer than usual. For an overview of these techniques, see\n{spring-site-blog}/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[this blog post].\n\nIn Servlet containers, this is done through Servlet 3 asynchronous support that\nallows exiting the Servlet container thread, processing a request, and continuing\nto write to the response from another thread.\n\nA specific issue is that the Servlet API does not provide notifications for a client\nthat has gone away. See https://github.com/eclipse-ee4j/servlet-api/issues/44[eclipse-ee4j/servlet-api#44].\nHowever, Servlet containers raise an exception on subsequent attempts to write\nto the response. Since Spring's SockJS Service supports server-sent heartbeats (every\n25 seconds by default), that means a client disconnect is usually detected within that\ntime period (or earlier, if messages are sent more frequently).\n\nNOTE: As a result, network I/O failures can occur because a client has disconnected, which\ncan fill the log with unnecessary stack traces. Spring makes a best effort to identify\nsuch network failures that represent client disconnects (specific to each server) and log\na minimal message by using the dedicated log category, `DISCONNECTED_CLIENT_LOG_CATEGORY`\n(defined in `AbstractSockJsSession`). If you need to see the stack traces, you can set that\nlog category to TRACE.\n\n[[websocket-fallback-cors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc", "title": "fallback", "heading": "Client Disconnects", "heading_level": 2, "file_order": 428, "section_index": 5, "content_hash": "ac61f49c7b1df415a303c9192084c99b259a76db951d0a9002398aeb5369d5a6", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc"}}
{"id": "sha256:b382652fca58eff3814e63d5d64bd690ceb1fb95469cf0d7cb9fb2360c6edded", "content": "If you allow cross-origin requests (see\nxref:web/websocket/server.adoc#websocket-server-allowed-origins[Allowed Origins]), the SockJS\nprotocol uses CORS for cross-domain support in the XHR streaming and polling transports.\nTherefore, CORS headers are added automatically, unless the presence of CORS headers in the\nresponse is detected. So, if an application is already configured to provide CORS support\n(for example, through a Servlet Filter), Spring's `SockJsService` skips this part.\n\nIt is also possible to disable the addition of these CORS headers by setting the\n`suppressCors` property in Spring's SockJsService.\n\nSockJS expects the following headers and values:\n\n* `Access-Control-Allow-Origin`: Initialized from the value of the `Origin` request header.\n* `Access-Control-Allow-Credentials`: Always set to `true`.\n* `Access-Control-Request-Headers`: Initialized from values from the equivalent request header.\n* `Access-Control-Allow-Methods`: The HTTP methods a transport supports (see `TransportType` enum).\n* `Access-Control-Max-Age`: Set to 31536000 (1 year).\n\nFor the exact implementation, see `addCorsHeaders` in `AbstractSockJsService` and\nthe `TransportType` enum in the source code.\n\nAlternatively, if the CORS configuration allows it, consider excluding URLs with the\nSockJS endpoint prefix, thus letting Spring's `SockJsService` handle it.\n\n[[websocket-fallback-sockjs-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc", "title": "fallback", "heading": "SockJS and CORS", "heading_level": 2, "file_order": 428, "section_index": 6, "content_hash": "b382652fca58eff3814e63d5d64bd690ceb1fb95469cf0d7cb9fb2360c6edded", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc"}}
{"id": "sha256:d2d1fe1b00506ae1825c6686a53511c30ea55fe9af995b96d3f16c5230e97e96", "content": "Spring provides a SockJS Java client to connect to remote SockJS endpoints without\nusing a browser. This can be especially useful when there is a need for bidirectional\ncommunication between two servers over a public network (that is, where network proxies can\npreclude the use of the WebSocket protocol). A SockJS Java client is also very useful\nfor testing purposes (for example, to simulate a large number of concurrent users).\n\nThe SockJS Java client supports the `websocket`, `xhr-streaming`, and `xhr-polling`\ntransports. The remaining ones only make sense for use in a browser.\n\nYou can configure the `WebSocketTransport` with:\n\n* `StandardWebSocketClient` in a JSR-356 runtime.\n* `JettyWebSocketClient` by using the Jetty 9+ native WebSocket API.\n* Any implementation of Spring's `WebSocketClient`.\n\nAn `XhrTransport`, by definition, supports both `xhr-streaming` and `xhr-polling`, since,\nfrom a client perspective, there is no difference other than in the URL used to connect\nto the server. At present there are two implementations:\n\n* `RestTemplateXhrTransport` uses Spring's `RestTemplate` for HTTP requests.\n* `JettyXhrTransport` uses Jetty's `HttpClient` for HTTP requests.\n\nThe following example shows how to create a SockJS client and connect to a SockJS endpoint:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n List<Transport> transports = new ArrayList<>(2);\n transports.add(new WebSocketTransport(new StandardWebSocketClient()));\n transports.add(new RestTemplateXhrTransport());\n\n SockJsClient sockJsClient = new SockJsClient(transports);\n sockJsClient.doHandshake(new MyWebSocketHandler(), \"ws://example.com:8080/sockjs\");\n----\n\nNOTE: SockJS uses JSON formatted arrays for messages. By default, Jackson 2 is used and needs\nto be on the classpath. Alternatively, you can configure a custom implementation of\n`SockJsMessageCodec` and configure it on the `SockJsClient`.\n\nTo use `SockJsClient` to simulate a large number of concurrent users, you\nneed to configure the underlying HTTP client (for XHR transports) to allow a sufficient\nnumber of connections and threads. The following example shows how to do so with Jetty:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\nHttpClient jettyHttpClient = new HttpClient();\njettyHttpClient.setMaxConnectionsPerDestination(1000);\njettyHttpClient.setExecutor(new QueuedThreadPool(1000));\n----\n\nThe following example shows the server-side SockJS-related properties (see javadoc for details)\nthat you should also consider customizing:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc", "title": "fallback", "heading": "`SockJsClient`", "heading_level": 2, "file_order": 428, "section_index": 7, "content_hash": "d2d1fe1b00506ae1825c6686a53511c30ea55fe9af995b96d3f16c5230e97e96", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/fallback.adoc"}}
{"id": "sha256:61ad3a56b28a4446039906bc5fe109c58371bf61907faedee88efc6c3c93c147", "content": "[[websocket-server]]\n\n[.small]#xref:web/webflux-websocket.adoc#webflux-websocket-server[See equivalent in the Reactive stack]#\n\nThe Spring Framework provides a WebSocket API that you can use to write client- and\nserver-side applications that handle WebSocket messages.\n\n[[websocket-server-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/server.adoc", "title": "server", "heading": "server", "heading_level": 1, "file_order": 429, "section_index": 0, "content_hash": "61ad3a56b28a4446039906bc5fe109c58371bf61907faedee88efc6c3c93c147", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/server.adoc"}}
{"id": "sha256:bc3d81cb3089117ec526fa6cce9728ab1e5d7ff27aa245191ab0b54a0d240065", "content": "[.small]#xref:web/webflux-websocket.adoc#webflux-websocket-server-handler[See equivalent in the Reactive stack]#\n\nCreating a WebSocket server is as simple as implementing `WebSocketHandler` or, more\nlikely, extending either `TextWebSocketHandler` or `BinaryWebSocketHandler`. The following\nexample uses `TextWebSocketHandler`:\n\ninclude-code::./MyHandler[tag=snippet,indent=0]\n\nThere is dedicated WebSocket programmatic configuration and XML namespace support for mapping the preceding\nWebSocket handler to a specific URL, as the following example shows:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\nThe preceding example is for use in Spring MVC applications and should be included\nin the configuration of a xref:web/webmvc/mvc-servlet.adoc[`DispatcherServlet`]. However, Spring's\nWebSocket support does not depend on Spring MVC. It is relatively simple to\nintegrate a `WebSocketHandler` into other HTTP-serving environments with the help of\n{spring-framework-api}/web/socket/server/support/WebSocketHttpRequestHandler.html[`WebSocketHttpRequestHandler`].\n\nWhen using the `WebSocketHandler` API directly vs indirectly, for example, through the\nxref:web/websocket/stomp.adoc[STOMP] messaging, the application must synchronize the sending of messages\nsince the underlying standard WebSocket session (JSR-356) does not allow concurrent\nsending. One option is to wrap the `WebSocketSession` with\n{spring-framework-api}/web/socket/handler/ConcurrentWebSocketSessionDecorator.html[`ConcurrentWebSocketSessionDecorator`].\n\n[[websocket-server-handshake]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/server.adoc", "title": "server", "heading": "`WebSocketHandler`", "heading_level": 2, "file_order": 429, "section_index": 1, "content_hash": "bc3d81cb3089117ec526fa6cce9728ab1e5d7ff27aa245191ab0b54a0d240065", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/server.adoc"}}
{"id": "sha256:d3f86d87718c714ba943b76cfef928a378127eea745a96824a2fc0ee4f3ab264", "content": "[.small]#xref:web/webflux-websocket.adoc#webflux-websocket-server-handshake[See equivalent in the Reactive stack]#\n\nThe easiest way to customize the initial HTTP WebSocket handshake request is through\na `HandshakeInterceptor`, which exposes methods for \"`before`\" and \"`after`\" the handshake.\nYou can use such an interceptor to preclude the handshake or to make any attributes\navailable to the `WebSocketSession`. The following example uses a built-in interceptor\nto pass HTTP session attributes to the WebSocket session:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\nA more advanced option is to extend the `DefaultHandshakeHandler` that performs\nthe steps of the WebSocket handshake, including validating the client origin,\nnegotiating a sub-protocol, and other details. An application may also need to use this\noption if it needs to configure a custom `RequestUpgradeStrategy` in order to\nadapt to a WebSocket server engine and version that is not yet supported\n(see xref:web/websocket/server.adoc#websocket-server-deployment[Deployment] for more on this subject).\nBoth the Java configuration and XML namespace make it possible to configure a custom\n`HandshakeHandler`.\n\nTIP: Spring provides a `WebSocketHandlerDecorator` base class that you can use to decorate\na `WebSocketHandler` with additional behavior. Logging and exception handling\nimplementations are provided and added by default when using the WebSocket Java configuration\nor XML namespace. The `ExceptionWebSocketHandlerDecorator` catches all uncaught\nexceptions that arise from any `WebSocketHandler` method and closes the WebSocket\nsession with status `1011`, which indicates a server error.\n\n[[websocket-server-deployment]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/server.adoc", "title": "server", "heading": "WebSocket Handshake", "heading_level": 2, "file_order": 429, "section_index": 2, "content_hash": "d3f86d87718c714ba943b76cfef928a378127eea745a96824a2fc0ee4f3ab264", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/server.adoc"}}
{"id": "sha256:9c65305d66227cd954d886541b48bdc66ff7c6983ffd78d25c1df0b9b67b3520", "content": "The Spring WebSocket API is easy to integrate into a Spring MVC application where\nthe `DispatcherServlet` serves both HTTP WebSocket handshake and other\nHTTP requests. It is also easy to integrate into other HTTP processing scenarios\nby invoking `WebSocketHttpRequestHandler`. This is convenient and easy to\nunderstand. However, special considerations apply with regards to JSR-356 runtimes.\n\nThe Jakarta WebSocket API (JSR-356) provides two deployment mechanisms. The first\ninvolves a Servlet container classpath scan (a Servlet 3 feature) at startup.\nThe other is a registration API to use at Servlet container initialization.\nNeither of these mechanism makes it possible to use a single \"`front controller`\"\nfor all HTTP processing -- including WebSocket handshake and all other HTTP\nrequests -- such as Spring MVC's `DispatcherServlet`.\n\nThis is a significant limitation of JSR-356 that Spring's WebSocket support addresses with\na standard `RequestUpgradeStrategy` implementation when running in a WebSocket API 2.1+ runtime.\n\nA secondary consideration is that Servlet containers with JSR-356 support are expected\nto perform a `ServletContainerInitializer` (SCI) scan that can slow down application\nstartup -- in some cases, dramatically. If a significant impact is observed after an\nupgrade to a Servlet container version with JSR-356 support, it should\nbe possible to selectively enable or disable web fragments (and SCI scanning)\nthrough the use of the `<absolute-ordering />` element in `web.xml`, as the following example shows:\n\n[source,xml,indent=0,subs=\"verbatim,quotes,attributes\"]\n----\n\t<web-app xmlns=\"https://jakarta.ee/xml/ns/jakartaee\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"\n https://jakarta.ee/xml/ns/jakartaee\n https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd\"\n version=\"5.0\">\n\n <absolute-ordering/>\n\n\t</web-app>\n----\n\nYou can then selectively enable web fragments by name, such as Spring's own\n`SpringServletContainerInitializer` that provides support for the Servlet 3\nJava initialization API. The following example shows how to do so:\n\n[source,xml,indent=0,subs=\"verbatim,quotes,attributes\"]\n----\n\t<web-app xmlns=\"https://jakarta.ee/xml/ns/jakartaee\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xsi:schemaLocation=\"\n https://jakarta.ee/xml/ns/jakartaee\n https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd\"\n version=\"5.0\">\n\n <absolute-ordering>\n <name>spring_web</name>\n </absolute-ordering>\n\n\t</web-app>\n----\n\n[[websocket-server-runtime-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/server.adoc", "title": "server", "heading": "Deployment", "heading_level": 2, "file_order": 429, "section_index": 3, "content_hash": "9c65305d66227cd954d886541b48bdc66ff7c6983ffd78d25c1df0b9b67b3520", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/server.adoc"}}
{"id": "sha256:e6aa441061428d6dccd73f5f617ac43a8031186c26540b3624052901bcb3b982", "content": "[.small]#xref:web/webflux-websocket.adoc#webflux-websocket-server-config[See equivalent in the Reactive stack]#\n\nYou can configure of the underlying WebSocket server such as input message buffer size,\nidle timeout, and more.\n\nFor Jakarta WebSocket servers, you can add a `ServletServerContainerFactoryBean` to your\nconfiguration. For example:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]\n\nNOTE: For client Jakarta WebSocket configuration, use\nContainerProvider.getWebSocketContainer() in programmatic configuration, or\n`WebSocketContainerFactoryBean` in XML.\n\nFor Jetty, you can supply a callback to configure the WebSocket server:\n\ninclude-code::./JettyWebSocketConfiguration[tag=snippet,indent=0]\n\nTIP: When using STOMP over WebSocket, you will also need to configure\nxref:web/websocket/stomp/server-config.adoc[STOMP WebSocket transport]\nproperties.\n\n[[websocket-server-allowed-origins]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/server.adoc", "title": "server", "heading": "Configuring the Server", "heading_level": 2, "file_order": 429, "section_index": 4, "content_hash": "e6aa441061428d6dccd73f5f617ac43a8031186c26540b3624052901bcb3b982", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/server.adoc"}}
{"id": "sha256:c9884b9a8c401e21a789742697b6ba45ff204a538af3acc48e82bf28b795f2ff", "content": "[.small]#xref:web/webflux-websocket.adoc#webflux-websocket-server-cors[See equivalent in the Reactive stack]#\n\nAs of Spring Framework 4.1.5, the default behavior for WebSocket and SockJS is to accept\nonly same-origin requests. It is also possible to allow all or a specified list of origins.\nThis check is mostly designed for browser clients. Nothing prevents other types\nof clients from modifying the `Origin` header value (see\n{rfc-site}/rfc6454[RFC 6454: The Web Origin Concept] for more details).\n\nThe three possible behaviors are:\n\n * Allow only same-origin requests (default): In this mode, when SockJS is enabled, the\n Iframe HTTP response header `X-Frame-Options` is set to `SAMEORIGIN`, and JSONP\n transport is disabled, since it does not allow checking the origin of a request.\n As a consequence, IE6 and IE7 are not supported when this mode is enabled.\n * Allow a specified list of origins: Each allowed origin must start with `http://`\n or `https://`. In this mode, when SockJS is enabled, IFrame transport is disabled.\n As a consequence, IE6 through IE9 are not supported when this\n mode is enabled.\n * Allow all origins: To enable this mode, you should provide `{asterisk}` as the allowed origin\n value. In this mode, all transports are available.\n\nYou can configure WebSocket and SockJS allowed origins, as the following example shows:\n\ninclude-code::./WebSocketConfiguration[tag=snippet,indent=0]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/server.adoc", "title": "server", "heading": "Allowed Origins", "heading_level": 2, "file_order": 429, "section_index": 5, "content_hash": "c9884b9a8c401e21a789742697b6ba45ff204a538af3acc48e82bf28b795f2ff", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/server.adoc"}}
{"id": "sha256:ee7d8bd73c2725539b80dcf97e56788a854eb643a2c776e22fb834c8579f232d", "content": "[[websocket-stomp]]\n\nThe WebSocket protocol defines two types of messages (text and binary), but their\ncontent is undefined. The protocol defines a mechanism for client and server to negotiate a\nsub-protocol (that is, a higher-level messaging protocol) to use on top of WebSocket to\ndefine what kind of messages each can send, what the format is, the content of each\nmessage, and so on. The use of a sub-protocol is optional but, either way, the client and\nthe server need to agree on some protocol that defines message content.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket/stomp.adoc", "title": "stomp", "heading": "stomp", "heading_level": 1, "file_order": 430, "section_index": 0, "content_hash": "ee7d8bd73c2725539b80dcf97e56788a854eb643a2c776e22fb834c8579f232d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket/stomp.adoc"}}
{"id": "sha256:9109b8f4e1b3d2fb79e3925e77e5c189c23381e45f29b54c915b4a50f15eee55", "content": "[[webflux-cors]]\n\n[.small]#xref:web/webmvc-cors.adoc[See equivalent in the Servlet stack]#\n\nSpring WebFlux lets you handle CORS (Cross-Origin Resource Sharing). This section\ndescribes how to do so.\n\n[[webflux-cors-intro]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-cors.adoc", "title": "webflux-cors", "heading": "webflux-cors", "heading_level": 1, "file_order": 431, "section_index": 0, "content_hash": "9109b8f4e1b3d2fb79e3925e77e5c189c23381e45f29b54c915b4a50f15eee55", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-cors.adoc"}}
{"id": "sha256:ac7a75b399cefdf5b9a0d58ee8517d32a2e11af94da3f79562adc9365a3459fd", "content": "[.small]#xref:web/webmvc-cors.adoc#mvc-cors-intro[See equivalent in the Servlet stack]#\n\nFor security reasons, browsers prohibit AJAX calls to resources outside the current origin.\nFor example, you could have your bank account in one tab and evil.com in another. Scripts\nfrom evil.com should not be able to make AJAX requests to your bank API with your\ncredentials -- for example, withdrawing money from your account!\n\nCross-Origin Resource Sharing (CORS) is a https://www.w3.org/TR/cors/[W3C specification]\nimplemented by https://caniuse.com/#feat=cors[most browsers] that lets you specify\nwhat kind of cross-domain requests are authorized, rather than using less secure and less\npowerful workarounds based on IFRAME or JSONP.\n\n[[webflux-cors-processing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-cors.adoc", "title": "webflux-cors", "heading": "Introduction", "heading_level": 2, "file_order": 431, "section_index": 1, "content_hash": "ac7a75b399cefdf5b9a0d58ee8517d32a2e11af94da3f79562adc9365a3459fd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-cors.adoc"}}
{"id": "sha256:e7eea22aea383d893ea29805b689f228869062471b02e3648594767e4ae7e91f", "content": "[.small]#xref:web/webmvc-cors.adoc#mvc-cors-processing[See equivalent in the Servlet stack]#\n\nThe CORS specification distinguishes between preflight, simple, and actual requests.\nTo learn how CORS works, you can read\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[this article], among\nmany others, or see the specification for more details.\n\nSpring WebFlux `HandlerMapping` implementations provide built-in support for CORS. After successfully\nmapping a request to a handler, a `HandlerMapping` checks the CORS configuration for the\ngiven request and handler and takes further actions. Preflight requests are handled\ndirectly, while simple and actual CORS requests are intercepted, validated, and have the\nrequired CORS response headers set.\n\nIn order to enable cross-origin requests (that is, the `Origin` header is present and\ndiffers from the host of the request), you need to have some explicitly declared CORS\nconfiguration. If no matching CORS configuration is found, no CORS headers are added to\nthe responses to preflight, simple and actual CORS requests and, consequently, browsers\nreject them.\n\nEach `HandlerMapping` can be\n{spring-framework-api}/web/reactive/handler/AbstractHandlerMapping.html#setCorsConfigurations(java.util.Map)[configured]\nindividually with URL pattern-based `CorsConfiguration` mappings. In most cases, applications\nuse the WebFlux Java configuration to declare such mappings, which results in a single,\nglobal map passed to all `HandlerMapping` implementations.\n\nYou can combine global CORS configuration at the `HandlerMapping` level with more\nfine-grained, handler-level CORS configuration. For example, annotated controllers can use\nclass- or method-level `@CrossOrigin` annotations (other handlers can implement\n`CorsConfigurationSource`).\n\nThe rules for combining global and local configuration are generally additive -- for example,\nall global and all local origins. For those attributes where only a single value can be\naccepted, such as `allowCredentials` and `maxAge`, the local overrides the global value. See\n{spring-framework-api}/web/cors/CorsConfiguration.html#combine(org.springframework.web.cors.CorsConfiguration)[`CorsConfiguration#combine(CorsConfiguration)`]\nfor more details.\n\n[TIP]\n====\nTo learn more from the source or to make advanced customizations, see:\n\n* `CorsConfiguration`\n* `CorsProcessor` and `DefaultCorsProcessor`\n* `AbstractHandlerMapping`\n====\n\n[[webflux-cors-credentialed-requests]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-cors.adoc", "title": "webflux-cors", "heading": "Processing", "heading_level": 2, "file_order": 431, "section_index": 2, "content_hash": "e7eea22aea383d893ea29805b689f228869062471b02e3648594767e4ae7e91f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-cors.adoc"}}
{"id": "sha256:d2bcecc4921e5e3e02ce22905cfb5ac35ba9774857f1647cb2b55e985e53a998", "content": "[.small]#xref:web/webmvc-cors.adoc#mvc-cors-credentialed-requests[See equivalent in the Servlet stack]#\n\nUsing CORS with credentialed requests requires enabling `allowedCredentials`. Be aware that\nthis option establishes a high level of trust with the configured domains and also increases\nthe surface of attack of the web application by exposing sensitive user-specific information\nsuch as cookies and CSRF tokens.\n\nEnabling credentials also impacts how the configured `\"*\"` CORS wildcards are processed:\n\n* Wildcards are not authorized in `allowOrigins`, but alternatively\nthe `allowOriginPatterns` property may be used to match to a dynamic set of origins.\n* When set on `allowedHeaders` or `allowedMethods`, the `Access-Control-Allow-Headers`\nand `Access-Control-Allow-Methods` response headers are handled by copying the related\nheaders and method specified in the CORS preflight request.\n* When set on `exposedHeaders`, `Access-Control-Expose-Headers` response header is set\neither to the configured list of headers or to the wildcard character. While the CORS spec\ndoes not allow the wildcard character when `Access-Control-Allow-Credentials` is set to\n`true`, most browsers support it and the response headers are not all available during the\nCORS processing, so as a consequence the wildcard character is the header value used when\nspecified regardless of the value of the `allowCredentials` property.\n\nWARNING: While such wildcard configuration can be handy, it is recommended when possible to configure\na finite set of values instead to provide a higher level of security.\n\n[[webflux-cors-controller]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-cors.adoc", "title": "webflux-cors", "heading": "Credentialed Requests", "heading_level": 2, "file_order": 431, "section_index": 3, "content_hash": "d2bcecc4921e5e3e02ce22905cfb5ac35ba9774857f1647cb2b55e985e53a998", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-cors.adoc"}}
{"id": "sha256:2a37b315e88565b13c3892330a8ee5234865a7d4ee8598441312d2627871b0e3", "content": "[.small]#xref:web/webmvc-cors.adoc#mvc-cors-controller[See equivalent in the Servlet stack]#\n\nThe {spring-framework-api}/web/bind/annotation/CrossOrigin.html[`@CrossOrigin`]\nannotation enables cross-origin requests on annotated controller methods, as the\nfollowing example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\t@RequestMapping(\"/account\")\n\tpublic class AccountController {\n\n @CrossOrigin\n @GetMapping(\"/{id}\")\n public Mono<Account> retrieve(@PathVariable Long id) {\n // ...\n }\n\n @DeleteMapping(\"/{id}\")\n public Mono<Void> remove(@PathVariable Long id) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\t@RequestMapping(\"/account\")\n\tclass AccountController {\n\n @CrossOrigin\n @GetMapping(\"/{id}\")\n suspend fun retrieve(@PathVariable id: Long): Account {\n // ...\n }\n\n @DeleteMapping(\"/{id}\")\n suspend fun remove(@PathVariable id: Long) {\n // ...\n }\n\t}\n----\n======\n--\n\nBy default, `@CrossOrigin` allows:\n\n* All origins.\n* All headers.\n* All HTTP methods to which the controller method is mapped.\n\n`allowCredentials` is not enabled by default, since that establishes a trust level\nthat exposes sensitive user-specific information (such as cookies and CSRF tokens) and\nshould be used only where appropriate. When it is enabled either `allowOrigins` must be\nset to one or more specific domain (but not the special value `\"*\"`) or alternatively\nthe `allowOriginPatterns` property may be used to match to a dynamic set of origins.\n\n`maxAge` is set to 30 minutes.\n\n`@CrossOrigin` is supported at the class level, too, and inherited by all methods.\nThe following example specifies a certain domain and sets `maxAge` to an hour:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@CrossOrigin(origins = \"https://domain2.com\", maxAge = 3600)\n\t@RestController\n\t@RequestMapping(\"/account\")\n\tpublic class AccountController {\n\n @GetMapping(\"/{id}\")\n public Mono<Account> retrieve(@PathVariable Long id) {\n // ...\n }\n\n @DeleteMapping(\"/{id}\")\n public Mono<Void> remove(@PathVariable Long id) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@CrossOrigin(\"https://domain2.com\", maxAge = 3600)\n\t@RestController\n\t@RequestMapping(\"/account\")\n\tclass AccountController {\n\n @GetMapping(\"/{id}\")\n suspend fun retrieve(@PathVariable id: Long): Account {\n // ...\n }\n\n @DeleteMapping(\"/{id}\")\n suspend fun remove(@PathVariable id: Long) {\n // ...\n }\n\t}\n----\n======\n--\n\nYou can use `@CrossOrigin` at both the class and the method level,\nas the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@CrossOrigin(maxAge = 3600) // <1>\n\t@RestController\n\t@RequestMapping(\"/account\")\n\tpublic class AccountController {\n\n @CrossOrigin(\"https://domain2.com\") // <2>\n @GetMapping(\"/{id}\")\n public Mono<Account> retrieve(@PathVariable Long id) {\n // ...\n }\n\n @DeleteMapping(\"/{id}\")\n public Mono<Void> remove(@PathVariable Long id) {\n // ...\n }\n\t}\n----\n<1> Using `@CrossOrigin` at the class level.\n<2> Using `@CrossOrigin` at the method level.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@CrossOrigin(maxAge = 3600) // <1>\n\t@RestController\n\t@RequestMapping(\"/account\")\n\tclass AccountController {\n\n @CrossOrigin(\"https://domain2.com\") // <2>\n @GetMapping(\"/{id}\")\n suspend fun retrieve(@PathVariable id: Long): Account {\n // ...\n }\n\n @DeleteMapping(\"/{id}\")\n suspend fun remove(@PathVariable id: Long) {\n // ...\n }\n\t}\n----\n<1> Using `@CrossOrigin` at the class level.\n<2> Using `@CrossOrigin` at the method level.\n======\n--\n\n[[webflux-cors-global]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-cors.adoc", "title": "webflux-cors", "heading": "`@CrossOrigin`", "heading_level": 2, "file_order": 431, "section_index": 4, "content_hash": "2a37b315e88565b13c3892330a8ee5234865a7d4ee8598441312d2627871b0e3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-cors.adoc"}}
{"id": "sha256:088418877718dd69bcf506cb7e61f6f4735559ec735fb54b5cebefd0d165066b", "content": "[.small]#xref:web/webmvc-cors.adoc#mvc-cors-global[See equivalent in the Servlet stack]#\n\nIn addition to fine-grained, controller method-level configuration, you probably want to\ndefine some global CORS configuration, too. You can set URL-based `CorsConfiguration`\nmappings individually on any `HandlerMapping`. Most applications, however, use the\nWebFlux Java configuration to do that.\n\nBy default global configuration enables the following:\n\n* All origins.\n* All headers.\n* `GET`, `HEAD`, and `POST` methods.\n\n`allowedCredentials` is not enabled by default, since that establishes a trust level\nthat exposes sensitive user-specific information (such as cookies and CSRF tokens) and\nshould be used only where appropriate. When it is enabled either `allowOrigins` must be\nset to one or more specific domain (but not the special value `\"*\"`) or alternatively\nthe `allowOriginPatterns` property may be used to match to a dynamic set of origins.\n\n`maxAge` is set to 30 minutes.\n\nTo enable CORS in the WebFlux Java configuration, you can use the `CorsRegistry` callback,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Override\n public void addCorsMappings(CorsRegistry registry) {\n\n registry.addMapping(\"/api/**\")\n .allowedOrigins(\"https://domain2.com\")\n .allowedMethods(\"PUT\", \"DELETE\")\n .allowedHeaders(\"header1\", \"header2\", \"header3\")\n .exposedHeaders(\"header1\", \"header2\")\n .allowCredentials(true).maxAge(3600);\n\n // Add more mappings...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n override fun addCorsMappings(registry: CorsRegistry) {\n\n registry.addMapping(\"/api/**\")\n .allowedOrigins(\"https://domain2.com\")\n .allowedMethods(\"PUT\", \"DELETE\")\n .allowedHeaders(\"header1\", \"header2\", \"header3\")\n .exposedHeaders(\"header1\", \"header2\")\n .allowCredentials(true).maxAge(3600)\n\n // Add more mappings...\n }\n\t}\n----\n======\n\n[[webflux-cors-webfilter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-cors.adoc", "title": "webflux-cors", "heading": "Global Configuration", "heading_level": 2, "file_order": 431, "section_index": 5, "content_hash": "088418877718dd69bcf506cb7e61f6f4735559ec735fb54b5cebefd0d165066b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-cors.adoc"}}
{"id": "sha256:5d8ce6a3145491423abc99200bb21685926b58e2de2c55043d5963a737669fa9", "content": "[.small]#xref:web/webmvc-cors.adoc#mvc-cors-filter[See equivalent in the Servlet stack]#\n\nYou can apply CORS support through the built-in\n{spring-framework-api}/web/cors/reactive/CorsWebFilter.html[`CorsWebFilter`], which is a\ngood fit with xref:web/webflux-functional.adoc[functional endpoints].\n\nNOTE: If you try to use the `CorsFilter` with Spring Security, keep in mind that Spring\nSecurity has {docs-spring-security}/servlet/integrations/cors.html[built-in support] for\nCORS.\n\nTo configure the filter, you can declare a `CorsWebFilter` bean and pass a\n`CorsConfigurationSource` to its constructor, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\t@Bean\n\tCorsWebFilter corsFilter() {\n\n CorsConfiguration config = new CorsConfiguration();\n\n // Possibly...\n // config.applyPermitDefaultValues()\n\n config.setAllowCredentials(true);\n config.addAllowedOrigin(\"https://domain1.com\");\n config.addAllowedHeader(\"*\");\n config.addAllowedMethod(\"*\");\n\n UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n source.registerCorsConfiguration(\"/**\", config);\n\n return new CorsWebFilter(source);\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\t@Bean\n\tfun corsFilter(): CorsWebFilter {\n\n val config = CorsConfiguration()\n\n // Possibly...\n // config.applyPermitDefaultValues()\n\n config.allowCredentials = true\n config.addAllowedOrigin(\"https://domain1.com\")\n config.addAllowedHeader(\"*\")\n config.addAllowedMethod(\"*\")\n\n val source = UrlBasedCorsConfigurationSource().apply {\n registerCorsConfiguration(\"/**\", config)\n }\n return CorsWebFilter(source)\n\t}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-cors.adoc", "title": "webflux-cors", "heading": "CORS `WebFilter`", "heading_level": 2, "file_order": 431, "section_index": 6, "content_hash": "5d8ce6a3145491423abc99200bb21685926b58e2de2c55043d5963a737669fa9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-cors.adoc"}}
{"id": "sha256:9e48167d06cee11240ffd97115e01e3f9846f86990180998f6e6af524349e34b", "content": "[[webflux-fn]]\n\n[.small]#xref:web/webmvc-functional.adoc[See equivalent in the Servlet stack]#\n\nSpring WebFlux includes WebFlux.fn, a lightweight functional programming model in which functions\nare used to route and handle requests and contracts are designed for immutability.\nIt is an alternative to the annotation-based programming model but otherwise runs on\nthe same xref:web/webflux/reactive-spring.adoc[Reactive Core] foundation.\n\n[[webflux-fn-overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "webflux-functional", "heading_level": 1, "file_order": 432, "section_index": 0, "content_hash": "9e48167d06cee11240ffd97115e01e3f9846f86990180998f6e6af524349e34b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:f2c4ea7e06c5a8160667448d676c350ae5a961aceaaf248c1cb79c51c314328d", "content": "[.small]#xref:web/webmvc-functional.adoc#webmvc-fn-overview[See equivalent in the Servlet stack]#\n\nIn WebFlux.fn, an HTTP request is handled with a `HandlerFunction`: a function that takes a\n`ServerRequest` and returns a delayed `ServerResponse` (i.e. `Mono<ServerResponse>`).\nBoth the request and the response object have immutable contracts that offer convenient\naccess to the HTTP request and response.\n`HandlerFunction` is the equivalent of the body of a `@RequestMapping` method in the\nannotation-based programming model.\n\nIncoming requests are routed to a handler function with a `RouterFunction`: a function that\ntakes `ServerRequest` and returns a delayed `HandlerFunction` (i.e. `Mono<HandlerFunction>`).\nWhen the router function matches, a handler function is returned; otherwise an empty Mono.\n`RouterFunction` is the equivalent of a `@RequestMapping` annotation, but with the major\ndifference that router functions provide not just data, but also behavior.\n\n`RouterFunctions.route()` provides a router builder that facilitates the creation of routers,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport static org.springframework.http.MediaType.APPLICATION_JSON;\n\timport static org.springframework.web.reactive.function.server.RequestPredicates.*;\n\timport static org.springframework.web.reactive.function.server.RouterFunctions.route;\n\n\tPersonRepository repository = ...\n\tPersonHandler handler = new PersonHandler(repository);\n\n\tRouterFunction<ServerResponse> route = route() <1>\n .GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson)\n .GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople)\n .POST(\"/person\", handler::createPerson)\n .build();\n\n\tpublic class PersonHandler {\n\n // ...\n\n public Mono<ServerResponse> listPeople(ServerRequest request) {\n // ...\n }\n\n public Mono<ServerResponse> createPerson(ServerRequest request) {\n // ...\n }\n\n public Mono<ServerResponse> getPerson(ServerRequest request) {\n // ...\n }\n\t}\n----\n<1> Create router using `route()`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval repository: PersonRepository = ...\n\tval handler = PersonHandler(repository)\n\n\tval route = coRouter { // <1>\n accept(APPLICATION_JSON).nest {\n GET(\"/person/{id}\", handler::getPerson)\n GET(\"/person\", handler::listPeople)\n }\n POST(\"/person\", handler::createPerson)\n\t}\n\n\tclass PersonHandler(private val repository: PersonRepository) {\n\n // ...\n\n suspend fun listPeople(request: ServerRequest): ServerResponse {\n // ...\n }\n\n suspend fun createPerson(request: ServerRequest): ServerResponse {\n // ...\n }\n\n suspend fun getPerson(request: ServerRequest): ServerResponse {\n // ...\n }\n\t}\n----\n<1> Create router using Coroutines router DSL; a Reactive alternative is also available via `router { }`.\n======\n\nOne way to run a `RouterFunction` is to turn it into an `HttpHandler` and install it\nthrough one of the built-in xref:web/webflux/reactive-spring.adoc#webflux-httphandler[server adapters]:\n\n* `RouterFunctions.toHttpHandler(RouterFunction)`\n* `RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)`\n\nMost applications can run through the WebFlux Java configuration, see xref:web/webflux-functional.adoc#webflux-fn-running[Running a Server].\n\n[[webflux-fn-handler-functions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "Overview", "heading_level": 2, "file_order": 432, "section_index": 1, "content_hash": "f2c4ea7e06c5a8160667448d676c350ae5a961aceaaf248c1cb79c51c314328d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:e73e3222bc05ec6b057293e4a02df2aa463fcac56cdd0d98b80c62396c8e6d2c", "content": "[.small]#xref:web/webmvc-functional.adoc#webmvc-fn-handler-functions[See equivalent in the Servlet stack]#\n\n`ServerRequest` and `ServerResponse` are immutable interfaces that offer convenient\naccess to the HTTP request and response.\nBoth request and response provide {reactive-streams-site}[Reactive Streams] back pressure\nagainst the body streams.\nThe request body is represented with a Reactor `Flux` or `Mono`.\nThe response body is represented with any Reactive Streams `Publisher`, including `Flux` and `Mono`.\nFor more on that, see xref:web/webflux-reactive-libraries.adoc[Reactive Libraries].\n\n[[webflux-fn-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "HandlerFunction", "heading_level": 2, "file_order": 432, "section_index": 2, "content_hash": "e73e3222bc05ec6b057293e4a02df2aa463fcac56cdd0d98b80c62396c8e6d2c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:64fdd0c6d0fcc9299e0fc916355d37759e919fab079c8f81a6ac73a0cc8294da", "content": "`ServerRequest` provides access to the HTTP method, URI, headers, and query parameters,\nwhile access to the body is provided through the `body` methods.\n\nThe following example extracts the request body to a `Mono<String>`:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nMono<String> string = request.bodyToMono(String.class);\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nval string = request.awaitBody<String>()\n----\n======\n\nThe following example extracts the body to a `Flux<Person>` (or a `Flow<Person>` in Kotlin),\nwhere `Person` objects are decoded from some serialized form, such as JSON or XML:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nFlux<Person> people = request.bodyToFlux(Person.class);\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nval people = request.bodyToFlow<Person>()\n----\n======\n\nThe preceding examples are shortcuts that use the more general `ServerRequest.body(BodyExtractor)`,\nwhich accepts the `BodyExtractor` functional strategy interface. The utility class\n`BodyExtractors` provides access to a number of instances. For example, the preceding examples can\nalso be written as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nMono<String> string = request.body(BodyExtractors.toMono(String.class));\nFlux<Person> people = request.body(BodyExtractors.toFlux(Person.class));\n----\n\nKotlin::\n+\n[source,kotlin]\n----\n\tval string = request.body(BodyExtractors.toMono(String::class.java)).awaitSingle()\n\tval people = request.body(BodyExtractors.toFlux(Person::class.java)).asFlow()\n----\n======\n\nThe following example shows how to access form data:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nMono<MultiValueMap<String, String>> map = request.formData();\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nval map = request.awaitFormData()\n----\n======\n\nThe following example shows how to access multipart data as a map:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nMono<MultiValueMap<String, Part>> map = request.multipartData();\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nval map = request.awaitMultipartData()\n----\n======\n\nThe following example shows how to access multipart data, one at a time, in streaming fashion:\n\ninclude-code::./PartEventHandler[tag=snippet,indent=0]\n\nNOTE: The body contents of the `PartEvent` objects must be completely consumed, relayed, or released to avoid memory leaks.\n\nThe following shows how to bind request parameters, URI variables, or headers via `DataBinder`,\nand also shows how to customize the `DataBinder`:\n\ninclude-code::./RequestHandler[tag=snippet,indent=0]\n\n[[webflux-fn-response]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "ServerRequest", "heading_level": 3, "file_order": 432, "section_index": 3, "content_hash": "64fdd0c6d0fcc9299e0fc916355d37759e919fab079c8f81a6ac73a0cc8294da", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:657882a905501d9662a0cc6824c5552976450ca5a9c6dd000757dfb5575d8d9a", "content": "`ServerResponse` provides access to the HTTP response and, since it is immutable, you can use\na `build` method to create it. You can use the builder to set the response status, to add response\nheaders, or to provide a body. The following example creates a 200 (OK) response with JSON\ncontent:\n\ninclude-code::./ResponseHandler[tag=snippet,indent=0]\n\nThe following example shows how to build a 201 (CREATED) response with a `Location` header and no body:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nURI location = ...\nreturn ServerResponse.created(location).build();\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nval location: URI = ...\nreturn ServerResponse.created(location).build()\n----\n======\n\nDepending on the codec used, it is possible to pass hint parameters to customize how the\nbody is serialized or deserialized. For example, to specify a {baeldung-blog}/jackson-json-view-annotation[Jackson JSON view]:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nreturn ServerResponse.ok().hint(JacksonCodecSupport.JSON_VIEW_HINT, MyJacksonView.class).body(...);\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nreturn ServerResponse.ok().hint(JacksonCodecSupport.JSON_VIEW_HINT, MyJacksonView::class.java).body(...)\n----\n======\n\n[[webflux-fn-handler-classes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "ServerResponse", "heading_level": 3, "file_order": 432, "section_index": 4, "content_hash": "657882a905501d9662a0cc6824c5552976450ca5a9c6dd000757dfb5575d8d9a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:5ef2cf8433568e588b7b9b5bdf0f1a6be601cc27a64cabae9ee928acf2fa294c", "content": "We can write a handler function as a lambda, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\nHandlerFunction<ServerResponse> helloWorld =\n request -> ServerResponse.ok().bodyValue(\"Hello World\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nval helloWorld = HandlerFunction<ServerResponse> { ServerResponse.ok().bodyValue(\"Hello World\") }\n----\n======\n--\n\nThat is convenient, but in an application we need multiple functions, and multiple inline\nlambda's can get messy.\nTherefore, it is useful to group related handler functions together into a handler class, which\nhas a similar role as `@Controller` in an annotation-based application.\nFor example, the following class exposes a reactive `Person` repository:\n\ninclude-code::./PersonHandler[tag=snippet,indent=0]\n\n[[webflux-fn-handler-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "Handler Classes", "heading_level": 3, "file_order": 432, "section_index": 5, "content_hash": "5ef2cf8433568e588b7b9b5bdf0f1a6be601cc27a64cabae9ee928acf2fa294c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:a4eee85f468b55b0249a8680e6b9d6b820ee350eb9db6bc6e68109b8df98038a", "content": "A functional endpoint can use Spring's xref:web/webmvc/mvc-config/validation.adoc[validation facilities] to\napply validation to the request body. For example, given a custom Spring\nxref:web/webmvc/mvc-config/validation.adoc[Validator] implementation for a `Person`:\n\ninclude-code::./PersonHandler[tag=snippet,indent=0]\n\nHandlers can also use the standard bean validation API (JSR-303) by creating and injecting\na global `Validator` instance based on `LocalValidatorFactoryBean`.\nSee xref:core/validation/beanvalidation.adoc[Spring Validation].\n\n[[webflux-fn-router-functions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "Validation", "heading_level": 3, "file_order": 432, "section_index": 6, "content_hash": "a4eee85f468b55b0249a8680e6b9d6b820ee350eb9db6bc6e68109b8df98038a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:954c95ce4b3dda232efa517452b1a0b16a99fe6e4f49fd61fba38e40a21d080b", "content": "[.small]#xref:web/webmvc-functional.adoc#webmvc-fn-router-functions[See equivalent in the Servlet stack]#\n\nRouter functions are used to route the requests to the corresponding `HandlerFunction`.\nTypically, you do not write router functions yourself, but rather use a method on the\n`RouterFunctions` utility class to create one.\n`RouterFunctions.route()` (no parameters) provides you with a fluent builder for creating a router\nfunction, whereas `RouterFunctions.route(RequestPredicate, HandlerFunction)` offers a direct way\nto create a router.\n\nGenerally, it is recommended to use the `route()` builder, as it provides\nconvenient short-cuts for typical mapping scenarios without requiring hard-to-discover\nstatic imports.\nFor instance, the router function builder offers the method `GET(String, HandlerFunction)`\nto create a mapping for GET requests; and `POST(String, HandlerFunction)` for POSTs.\n\nBesides HTTP method-based mapping, the route builder offers a way to introduce additional\npredicates when mapping to requests.\nFor each HTTP method there is an overloaded variant that takes a `RequestPredicate` as a\nparameter, though which additional constraints can be expressed.\n\n[[webflux-fn-predicates]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "`RouterFunction`", "heading_level": 2, "file_order": 432, "section_index": 7, "content_hash": "954c95ce4b3dda232efa517452b1a0b16a99fe6e4f49fd61fba38e40a21d080b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:58e0142b3001a261b5dcb5227c717eff11033d9b76c9ade61ab92bd9d8758585", "content": "You can write your own `RequestPredicate`, but the `RequestPredicates` utility class\noffers built-in options for common needs for matching based on the HTTP method, request\npath, headers, xref:#api-version[API version], and more.\n\nThe following example uses an `Accept` header, request predicate:\n\ninclude-code::./RouterConfiguration[tag=snippet,indent=0]\n\nYou can compose multiple request predicates together by using:\n\n* `RequestPredicate.and(RequestPredicate)` -- both must match.\n* `RequestPredicate.or(RequestPredicate)` -- either can match.\n\nMany of the predicates from `RequestPredicates` are composed.\nFor example, `RequestPredicates.GET(String)` is composed from `RequestPredicates.method(HttpMethod)`\nand `RequestPredicates.path(String)`.\nThe example shown above also uses two request predicates, as the builder uses\n`RequestPredicates.GET` internally, and composes that with the `accept` predicate.\n\n[[webflux-fn-routes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "Predicates", "heading_level": 3, "file_order": 432, "section_index": 8, "content_hash": "58e0142b3001a261b5dcb5227c717eff11033d9b76c9ade61ab92bd9d8758585", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:6fe2028355c019cb3712e0fbfa5e0361b5d8e30b2c547299d8e3d3e1307282e1", "content": "Router functions are evaluated in order: if the first route does not match, the\nsecond is evaluated, and so on.\nTherefore, it makes sense to declare more specific routes before general ones.\nThis is also important when registering router functions as Spring beans, as will\nbe described later.\nNote that this behavior is different from the annotation-based programming model, where the\n\"most specific\" controller method is picked automatically.\n\nWhen using the router function builder, all defined routes are composed into one\n`RouterFunction` that is returned from `build()`.\nThere are also other ways to compose multiple router functions together:\n\n* `add(RouterFunction)` on the `RouterFunctions.route()` builder\n* `RouterFunction.and(RouterFunction)`\n* `RouterFunction.andRoute(RequestPredicate, HandlerFunction)` -- shortcut for\n`RouterFunction.and()` with nested `RouterFunctions.route()`.\n\nThe following example shows the composition of four routes:\n\ninclude-code::./RouterConfiguration[tag=snippet,indent=0]\n\n[[nested-routes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "Routes", "heading_level": 3, "file_order": 432, "section_index": 9, "content_hash": "6fe2028355c019cb3712e0fbfa5e0361b5d8e30b2c547299d8e3d3e1307282e1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:0cb07d292530b3558a91bfa22f9df07cc0b84f3e025b23e29e9f750f750a8104", "content": "It is common for a group of router functions to have a shared predicate, for instance a\nshared path. In the example above, the shared predicate would be a path predicate that\nmatches `/person`, used by three of the routes. When using annotations, you would remove\nthis duplication by using a type-level `@RequestMapping` annotation that maps to\n`/person`. In WebFlux.fn, path predicates can be shared through the `path` method on the\nrouter function builder. For instance, the last few lines of the example above can be\nimproved in the following way by using nested routes:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\nRouterFunction<ServerResponse> route = route()\n\t.path(\"/person\", builder -> builder // <1>\n .GET(\"/{id}\", accept(APPLICATION_JSON), handler::getPerson)\n .GET(accept(APPLICATION_JSON), handler::listPeople)\n .POST(handler::createPerson))\n\t.build();\n----\n<1> Note that second parameter of `path` is a consumer that takes the router builder.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval route = coRouter { // <1>\n \"/person\".nest {\n GET(\"/{id}\", accept(APPLICATION_JSON), handler::getPerson)\n GET(accept(APPLICATION_JSON), handler::listPeople)\n POST(handler::createPerson)\n }\n\t}\n----\n<1> Create router using Coroutines router DSL; a Reactive alternative is also available via `router { }`.\n======\n\nThough path-based nesting is the most common, you can nest on any kind of predicate by using\nthe `nest` method on the builder.\nThe above still contains some duplication in the form of the shared `Accept`-header predicate.\nWe can further improve by using the `nest` method together with `accept`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRouterFunction<ServerResponse> route = route()\n .path(\"/person\", b1 -> b1\n .nest(accept(APPLICATION_JSON), b2 -> b2\n .GET(\"/{id}\", handler::getPerson)\n .GET(handler::listPeople))\n .POST(handler::createPerson))\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval route = coRouter {\n \"/person\".nest {\n accept(APPLICATION_JSON).nest {\n GET(\"/{id}\", handler::getPerson)\n GET(handler::listPeople)\n POST(handler::createPerson)\n }\n }\n\t}\n----\n======\n\n[[api-version]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "Nested Routes", "heading_level": 3, "file_order": 432, "section_index": 10, "content_hash": "0cb07d292530b3558a91bfa22f9df07cc0b84f3e025b23e29e9f750f750a8104", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:069d25922db63b7bf3e6bada701c1deb41efba42dcb345f1667da7b8d2ea996f", "content": "Router functions support matching by API version.\n\nFirst, enable API versioning in the\nxref:web/webflux/config.adoc#webflux-config-api-version[WebFlux Config], and then you can\nuse the `version` xref:#webflux-fn-predicates[predicate] as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRouterFunction<ServerResponse> route = RouterFunctions.route()\n .GET(\"/hello-world\", version(\"1.2\"),\n request -> ServerResponse.ok().bodyValue(\"Hello World\")).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval route = coRouter {\n GET(\"/hello-world\", version(\"1.2\")) {\n ServerResponse.ok().bodyValueAndAwait(\"Hello World\")\n }\n\t}\n----\n======\n\nThe `version` predicate can be:\n\n- Fixed version (\"1.2\") -- matches the given version only\n- Baseline version (\"1.2+\") -- matches the given version and above, up to the highest\nxref:web/webmvc/mvc-config/api-version.adoc[supported version].\n\nSee xref:web/webflux-versioning.adoc[API Versioning] for more details on underlying\ninfrastructure and support for API Versioning.\n\n[[webflux-fn-serving-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "API Version", "heading_level": 3, "file_order": 432, "section_index": 11, "content_hash": "069d25922db63b7bf3e6bada701c1deb41efba42dcb345f1667da7b8d2ea996f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:212597797ef29146c886fc8b774dcc2f2926c535e4cf7498b2ca5d086d6f5f30", "content": "WebFlux.fn provides built-in support for serving resources.\n\nNOTE: In addition to the capabilities described below, it is possible to implement even more flexible resource handling thanks to\n{spring-framework-api}++/web/reactive/function/server/RouterFunctions.html#resources(java.util.function.Function)++[`RouterFunctions#resource(java.util.function.Function)`].\n\n[[webflux-fn-resource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "Serving Resources", "heading_level": 2, "file_order": 432, "section_index": 12, "content_hash": "212597797ef29146c886fc8b774dcc2f2926c535e4cf7498b2ca5d086d6f5f30", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:0c6cf1b9ce9c102efcde501a0a20fd868e1301c92301c110d2e337485701e364", "content": "It is possible to redirect requests matching a specified predicate to a resource. This can be useful, for example,\nfor handling redirects in Single Page Applications.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tClassPathResource index = new ClassPathResource(\"static/index.html\");\n\tRequestPredicate spaPredicate = path(\"/api/**\").or(path(\"/error\")).negate();\n\tRouterFunction<ServerResponse> redirectToIndex = route()\n .resource(spaPredicate, index)\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval redirectToIndex = router {\n val index = ClassPathResource(\"static/index.html\")\n val spaPredicate = !(path(\"/api/**\") or path(\"/error\"))\n resource(spaPredicate, index)\n\t}\n----\n======\n\n[[webflux-fn-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "Redirecting to a resource", "heading_level": 3, "file_order": 432, "section_index": 13, "content_hash": "0c6cf1b9ce9c102efcde501a0a20fd868e1301c92301c110d2e337485701e364", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:9a75d076780e0b6ae44c86e21155077433e96abfed01cdcd2451c2f991bbdf84", "content": "It is also possible to route requests that match a given pattern to resources relative to a given root location.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n Resource location = new FileUrlResource(\"public-resources/\");\n RouterFunction<ServerResponse> resources = RouterFunctions.resources(\"/resources/**\", location);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n val location = FileUrlResource(\"public-resources/\")\n val resources = router { resources(\"/resources/**\", location) }\n----\n======\n\n[[webflux-fn-running]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "Serving resources from a root location", "heading_level": 3, "file_order": 432, "section_index": 14, "content_hash": "9a75d076780e0b6ae44c86e21155077433e96abfed01cdcd2451c2f991bbdf84", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:ecb45aa68dec35df6be5cbc62717cbdc2bd03b016cfd4774a352da3277caa94c", "content": "[.small]#xref:web/webmvc-functional.adoc#webmvc-fn-running[See equivalent in the Servlet stack]#\n\nHow do you run a router function in an HTTP server? A simple option is to convert a router\nfunction to an `HttpHandler` by using one of the following:\n\n* `RouterFunctions.toHttpHandler(RouterFunction)`\n* `RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)`\n\nYou can then use the returned `HttpHandler` with a number of server adapters by following\nxref:web/webflux/reactive-spring.adoc#webflux-httphandler[HttpHandler] for server-specific instructions.\n\nA more typical option, also used by Spring Boot, is to run with a\nxref:web/webflux/dispatcher-handler.adoc[`DispatcherHandler`]-based setup through the\nxref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[WebFlux Config], which uses Spring configuration to declare the\ncomponents required to process requests. The WebFlux Java configuration declares the following\ninfrastructure components to support functional endpoints:\n\n* `RouterFunctionMapping`: Detects one or more `RouterFunction<?>` beans in the Spring\nconfiguration, xref:core/beans/annotation-config/autowired.adoc#beans-factory-ordered[orders them], combines them through\n`RouterFunction.andOther`, and routes requests to the resulting composed `RouterFunction`.\n* `HandlerFunctionAdapter`: Simple adapter that lets `DispatcherHandler` invoke\na `HandlerFunction` that was mapped to a request.\n* `ServerResponseResultHandler`: Handles the result from the invocation of a\n`HandlerFunction` by invoking the `writeTo` method of the `ServerResponse`.\n\nThe preceding components let functional endpoints fit within the `DispatcherHandler` request\nprocessing lifecycle and also (potentially) run side by side with annotated controllers, if\nany are declared. It is also how functional endpoints are enabled by the Spring Boot WebFlux\nstarter.\n\nThe following example shows a WebFlux Java configuration (see\nxref:web/webflux/dispatcher-handler.adoc[DispatcherHandler] for how to run it):\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfig implements WebFluxConfigurer {\n\n @Bean\n public RouterFunction<?> routerFunctionA() {\n // ...\n }\n\n @Bean\n public RouterFunction<?> routerFunctionB() {\n // ...\n }\n\n // ...\n\n @Override\n public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {\n // configure message conversion...\n }\n\n @Override\n public void addCorsMappings(CorsRegistry registry) {\n // configure CORS...\n }\n\n @Override\n public void configureViewResolvers(ViewResolverRegistry registry) {\n // configure view resolution for HTML rendering...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig : WebFluxConfigurer {\n\n @Bean\n fun routerFunctionA(): RouterFunction<*> {\n // ...\n }\n\n @Bean\n fun routerFunctionB(): RouterFunction<*> {\n // ...\n }\n\n // ...\n\n override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) {\n // configure message conversion...\n }\n\n override fun addCorsMappings(registry: CorsRegistry) {\n // configure CORS...\n }\n\n override fun configureViewResolvers(registry: ViewResolverRegistry) {\n // configure view resolution for HTML rendering...\n }\n\t}\n----\n======\n\n[[webflux-fn-handler-filter-function]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "Running a Server", "heading_level": 2, "file_order": 432, "section_index": 15, "content_hash": "ecb45aa68dec35df6be5cbc62717cbdc2bd03b016cfd4774a352da3277caa94c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:ba0bf7a0895fdd7e149caa69900187369e935d58c4983e31a27a568bc65e052c", "content": "[.small]#xref:web/webmvc-functional.adoc#webmvc-fn-handler-filter-function[See equivalent in the Servlet stack]#\n\nYou can filter handler functions by using the `before`, `after`, or `filter` methods on the routing\nfunction builder.\nWith annotations, you can achieve similar functionality by using `@ControllerAdvice`, a `ServletFilter`, or both.\nThe filter will apply to all routes that are built by the builder.\nThis means that filters defined in nested routes do not apply to \"top-level\" routes.\nFor instance, consider the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRouterFunction<ServerResponse> route = route()\n .path(\"/person\", b1 -> b1\n .nest(accept(APPLICATION_JSON), b2 -> b2\n .GET(\"/{id}\", handler::getPerson)\n .GET(handler::listPeople)\n .before(request -> ServerRequest.from(request) // <1>\n .header(\"X-RequestHeader\", \"Value\")\n .build()))\n .POST(handler::createPerson))\n .after((request, response) -> logResponse(response)) // <2>\n .build();\n----\n<1> The `before` filter that adds a custom request header is only applied to the two GET routes.\n<2> The `after` filter that logs the response is applied to all routes, including the nested ones.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval route = router {\n (\"/person\" and accept(APPLICATION_JSON)).nest {\n GET(\"/{id}\", handler::getPerson)\n GET(handler::listPeople)\n before { // <1>\n ServerRequest.from(it)\n .header(\"X-RequestHeader\", \"Value\").build()\n }\n POST(handler::createPerson)\n after { _, response -> // <2>\n logResponse(response)\n }\n }\n\t}\n----\n<1> The `before` filter that adds a custom request header is only applied to the two GET routes.\n<2> The `after` filter that logs the response is applied to all routes, including the nested ones.\n======\n\nThe `filter` method on the router builder takes a `HandlerFilterFunction`: a\nfunction that takes a `ServerRequest` and `HandlerFunction` and returns a `ServerResponse`.\nThe handler function parameter represents the next element in the chain.\nThis is typically the handler that is routed to, but it can also be another\nfilter if multiple are applied.\n\nNow we can add a simple security filter to our route, assuming that we have a `SecurityManager` that\ncan determine whether a particular path is allowed.\nThe following example shows how to do so:\n\ninclude-code::./RouterConfiguration[tag=snippet,indent=0]\n\nThe preceding example demonstrates that invoking the `next.handle(ServerRequest)` is optional.\nWe only let the handler function be run when access is allowed.\n\nBesides using the `filter` method on the router function builder, it is possible to apply a\nfilter to an existing router function via `RouterFunction.filter(HandlerFilterFunction)`.\n\nNOTE: CORS support for functional endpoints is provided through a dedicated\nxref:web/webflux-cors.adoc#webflux-cors-webfilter[`CorsWebFilter`].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-functional.adoc", "title": "webflux-functional", "heading": "Filtering Handler Functions", "heading_level": 2, "file_order": 432, "section_index": 16, "content_hash": "ba0bf7a0895fdd7e149caa69900187369e935d58c4983e31a27a568bc65e052c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-functional.adoc"}}
{"id": "sha256:be42381912f74a9d987e9ef556bee1db29857c8bcbdc58f9af264ca24a275cc0", "content": "[[webflux-http-service-client]]\n\nThe Spring Frameworks lets you define an HTTP service as a Java interface with HTTP\nexchange methods. You can then generate a proxy that implements this interface and\nperforms the exchanges. This helps to simplify HTTP remote access and provides additional\nflexibility in choosing an API style such as synchronous or reactive.\n\nSee xref:integration/rest-clients.adoc#rest-http-service-client[HTTP Service Clients] for details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-http-service-client.adoc", "title": "webflux-http-service-client", "heading": "webflux-http-service-client", "heading_level": 1, "file_order": 433, "section_index": 0, "content_hash": "be42381912f74a9d987e9ef556bee1db29857c8bcbdc58f9af264ca24a275cc0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-http-service-client.adoc"}}
{"id": "sha256:a50221f35b4c79c4cf667850e9c2b4d77fb642789e8a81460aeb63a404a60d9f", "content": "[[webflux-reactive-libraries]]\n\n`spring-webflux` depends on `reactor-core` and uses it internally to compose asynchronous\nlogic and to provide Reactive Streams support. Generally, WebFlux APIs return `Flux` or\n`Mono` (since those are used internally) and leniently accept any Reactive Streams\n`Publisher` implementation as input.\nWhen a `Publisher` is provided, it can be treated only as a stream with unknown semantics (0..N).\nIf, however, the semantics are known, you should wrap it with `Flux` or `Mono.from(Publisher)` instead\nof passing the raw `Publisher`.\nThe use of `Flux` versus `Mono` is important, because it helps to express cardinality --\nfor example, whether a single or multiple asynchronous values are expected,\nand that can be essential for making decisions (for example, when encoding or decoding HTTP messages).\n\nFor annotated controllers, WebFlux transparently adapts to the reactive library chosen by\nthe application. This is done with the help of the\n{spring-framework-api}/core/ReactiveAdapterRegistry.html[`ReactiveAdapterRegistry`], which\nprovides pluggable support for reactive library and other asynchronous types. The registry\nhas built-in support for RxJava 3, Kotlin coroutines and SmallRye Mutiny, but you can\nregister others, too.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-reactive-libraries.adoc", "title": "webflux-reactive-libraries", "heading": "webflux-reactive-libraries", "heading_level": 1, "file_order": 434, "section_index": 0, "content_hash": "a50221f35b4c79c4cf667850e9c2b4d77fb642789e8a81460aeb63a404a60d9f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-reactive-libraries.adoc"}}
{"id": "sha256:4e6184d401cd73ac3fda44c3f51a61e29b3db9ec60c3965c1b388b577a4c578f", "content": "[[webflux-test]]\n[.small]#xref:web/webmvc-test.adoc[Same in Spring MVC]#\n\nThe `spring-test` module provides mock implementations of `ServerHttpRequest`,\n`ServerHttpResponse`, and `ServerWebExchange`.\nSee xref:testing/unit.adoc#mock-objects-web-reactive[Spring Web Reactive] for a\ndiscussion of mock objects.\n\nxref:testing/webtestclient.adoc[`WebTestClient`] builds on these mock request and\nresponse objects to provide support for testing WebFlux applications without an HTTP\nserver. You can use the `WebTestClient` for end-to-end integration tests, too.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-test.adoc", "title": "webflux-test", "heading": "webflux-test", "heading_level": 1, "file_order": 435, "section_index": 0, "content_hash": "4e6184d401cd73ac3fda44c3f51a61e29b3db9ec60c3965c1b388b577a4c578f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-test.adoc"}}
{"id": "sha256:bf66eddffba53ac266133b5c7ece972a246d22455893410006e9008ccc7aca5f", "content": "[[webflux-versioning]]\n\n[.small]#xref:web/webmvc-versioning.adoc[See equivalent in the Servlet stack]#\n\nSpring WebFlux supports API versioning. This section provides an overview of the support\nand underlying strategies.\n\nPlease, see also related content in:\n\n- Configure xref:web/webflux/config.adoc#webflux-config-api-version[API versioning]\nin the WebFlux Config\n- xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-version[Map requests]\nto annotated controller methods with an API version\n- xref:web/webflux-functional.adoc#api-version[Route requests]\nto functional endpoints with an API version\n\nClient support for API versioning is available also in `RestClient`, `WebClient`, and\nxref:integration/rest-clients.adoc#rest-http-service-client[HTTP Service] clients, as well as\nfor testing in `WebTestClient`.\n\n[[webflux-versioning-strategy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc", "title": "webflux-versioning", "heading": "webflux-versioning", "heading_level": 1, "file_order": 436, "section_index": 0, "content_hash": "bf66eddffba53ac266133b5c7ece972a246d22455893410006e9008ccc7aca5f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc"}}
{"id": "sha256:f2d29b98173505cedc882644259c6048b2e817ef61393ec75ec66824fabc837a", "content": "[.small]#xref:web/webmvc-versioning.adoc#mvc-versioning-strategy[See equivalent in the Servlet stack]#\n\nThis is the central strategy for API versioning that holds all configured preferences\nrelated to versioning. It does the following:\n\n- Resolves versions from the requests via xref:#webflux-versioning-resolver[ApiVersionResolver]\n- Parses raw version values into `Comparable<?>` with xref:#webflux-versioning-parser[ApiVersionParser]\n- xref:#webflux-versioning-validation[Validates] request versions\n\n`ApiVersionStrategy` helps to map requests to `@RequestMapping` controller methods,\nand is initialized by the WebFlux config. Typically, applications do not interact\ndirectly with it.\n\n[[webflux-versioning-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc", "title": "webflux-versioning", "heading": "ApiVersionStrategy", "heading_level": 2, "file_order": 436, "section_index": 1, "content_hash": "f2d29b98173505cedc882644259c6048b2e817ef61393ec75ec66824fabc837a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc"}}
{"id": "sha256:eb420b67be0d808084b83091eb71a7bc683cc5e7a3f55ec9414b1cbad900e919", "content": "[.small]#xref:web/webmvc-versioning.adoc#mvc-versioning-resolver[See equivalent in the Servlet stack]#\n\nThis strategy resolves the API version from a request. The WebFlux config provides built-in\noptions to resolve from a header, query parameter, media type parameter,\nor from the URL path. You can also use a custom `ApiVersionResolver`.\n\nNOTE: The path resolver always resolves the version from the specified path segment, or\nraises `InvalidApiVersionException` otherwise, and therefore it cannot yield to other\nresolvers.\n\n[[webflux-versioning-parser]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc", "title": "webflux-versioning", "heading": "ApiVersionResolver", "heading_level": 2, "file_order": 436, "section_index": 2, "content_hash": "eb420b67be0d808084b83091eb71a7bc683cc5e7a3f55ec9414b1cbad900e919", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc"}}
{"id": "sha256:fba088f6fd165c3642ba79ad0f1acddd7698c214524b7c9c1de43a22d59798a5", "content": "[.small]#xref:web/webmvc-versioning.adoc#mvc-versioning-parser[See equivalent in the Servlet stack]#\n\nThis strategy helps to parse raw version values into `Comparable<?>`, which helps to\ncompare, sort, and select versions. By default, the built-in `SemanticApiVersionParser`\nparses a version into `major`, `minor`, and `patWebFluxch` integer values. Minor and patch\nvalues are set to 0 if not present.\n\n[[webflux-versioning-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc", "title": "webflux-versioning", "heading": "ApiVersionParser", "heading_level": 2, "file_order": 436, "section_index": 3, "content_hash": "fba088f6fd165c3642ba79ad0f1acddd7698c214524b7c9c1de43a22d59798a5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc"}}
{"id": "sha256:864f66023e9fbd926c90b5c135d9d36aacecf2e150f2f3f7eedcc1981fe95b35", "content": "[.small]#xref:web/webmvc-versioning.adoc#mvc-versioning-validation[See equivalent in the Servlet stack]#\n\nIf a request version is not supported, `InvalidApiVersionException` is raised resulting\nin a 400 response. By default, the list of supported versions is initialized from declared\nversions in annotated controller mappings, but you can turn that off through a flag in the\nWebFlux config, and use only the versions configured explicitly in the config.\n\nBy default, a version is required when API versioning is enabled, and\n`MissingApiVersionException` is raised resulting in a 400 response if not present.\nYou can make it optional in which case the most recent version is used.\nYou can also specify a default version to use.\n\n[[webflux-versioning-deprecation-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc", "title": "webflux-versioning", "heading": "Validation", "heading_level": 2, "file_order": 436, "section_index": 4, "content_hash": "864f66023e9fbd926c90b5c135d9d36aacecf2e150f2f3f7eedcc1981fe95b35", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc"}}
{"id": "sha256:eea1644d874a9fd6c438a2c22e5507eaf32798391ea34a741bdf464a83ce6131", "content": "[.small]#xref:web/webmvc-versioning.adoc#mvc-versioning-deprecation-handler[See equivalent in the Reactive stack]#\n\nThis strategy can be configured to send hints and information about deprecated versions to\nclients via response headers. The built-in `StandardApiVersionDeprecationHandler`\ncan set the \"Deprecation\" \"Sunset\" headers and \"Link\" headers as defined in\nhttps://datatracker.ietf.org/doc/html/rfc9745[RFC 9745] and\nhttps://datatracker.ietf.org/doc/html/rfc8594[RFC 8594]. You can also configure a custom\nhandler for different headers.\n\n[[webflux-versioning-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc", "title": "webflux-versioning", "heading": "ApiVersionDeprecationHandler", "heading_level": 2, "file_order": 436, "section_index": 5, "content_hash": "eea1644d874a9fd6c438a2c22e5507eaf32798391ea34a741bdf464a83ce6131", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc"}}
{"id": "sha256:0112d14a5e8ee1832dc885abc0ada7959bf021616b704dcdff9ab8de6d3720ea", "content": "[.small]#xref:web/webmvc-versioning.adoc#mvc-versioning-mapping[See equivalent in the Servlet stack]#\n\n`ApiVersionStrategy` supports the mapping of requests to annotated controller methods.\nSee xref:web/webflux/controller/ann-requestmapping.adoc#webflux-ann-requestmapping-version[API Versions]\nfor more details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc", "title": "webflux-versioning", "heading": "Request Mapping", "heading_level": 2, "file_order": 436, "section_index": 6, "content_hash": "0112d14a5e8ee1832dc885abc0ada7959bf021616b704dcdff9ab8de6d3720ea", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-versioning.adoc"}}
{"id": "sha256:4990da7f4204828ace5dc30e293c77844dd09369397941452233dce73901e3be", "content": "[[webflux-view]]\n\n[.small]#xref:web/webmvc-view.adoc[See equivalent in the Servlet stack]#\n\nThe rendering of views in Spring WebFlux is pluggable. Whether you decide to\nuse Thymeleaf, FreeMarker, or some other view technology is primarily a matter of a\nconfiguration change. This chapter covers the view technologies integrated with Spring\nWebFlux.\n\nFor more context on view rendering, please see xref:web/webflux/dispatcher-handler.adoc#webflux-viewresolution[View Resolution].\n\nWARNING: The views of a Spring WebFlux application live within internal trust boundaries\nof the application. Views have access to beans in the application context, and as\nsuch, we do not recommend use the Spring WebFlux template support in applications where\nthe templates are editable by external sources, since this can have security implications.\n\n[[webflux-view-thymeleaf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "webflux-view", "heading_level": 1, "file_order": 437, "section_index": 0, "content_hash": "4990da7f4204828ace5dc30e293c77844dd09369397941452233dce73901e3be", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:5276e52a34127ecee32a798495d740951c6cff352ef47a67a05d6060f1b8e17d", "content": "[.small]#xref:web/webmvc-view/mvc-thymeleaf.adoc[See equivalent in the Servlet stack]#\n\nThymeleaf is a modern server-side Java template engine that emphasizes natural HTML\ntemplates that can be previewed in a browser by double-clicking, which is very\nhelpful for independent work on UI templates (for example, by a designer) without the need for a\nrunning server. Thymeleaf offers an extensive set of features, and it is actively developed\nand maintained. For a more complete introduction, see the\nhttps://www.thymeleaf.org/[Thymeleaf] project home page.\n\nThe Thymeleaf integration with Spring WebFlux is managed by the Thymeleaf project. The\nconfiguration involves a few bean declarations, such as\n`SpringResourceTemplateResolver`, `SpringWebFluxTemplateEngine`, and\n`ThymeleafReactiveViewResolver`. For more details, see\nhttps://www.thymeleaf.org/documentation.html[Thymeleaf+Spring] and the WebFlux integration\nhttps://web.archive.org/web/20210623051330/http%3A//forum.thymeleaf.org/Thymeleaf-3-0-8-JUST-PUBLISHED-td4030687.html[announcement].\n\n[[webflux-view-freemarker]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "Thymeleaf", "heading_level": 2, "file_order": 437, "section_index": 1, "content_hash": "5276e52a34127ecee32a798495d740951c6cff352ef47a67a05d6060f1b8e17d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:cfa4d02887a5f73dab081b886a56f665f101db4670629b7f418104c71d352b8a", "content": "[.small]#xref:web/webmvc-view/mvc-freemarker.adoc[See equivalent in the Servlet stack]#\n\nhttps://freemarker.apache.org/[Apache FreeMarker] is a template engine for generating any\nkind of text output from HTML to email and others. The Spring Framework has built-in\nintegration for using Spring WebFlux with FreeMarker templates.\n\n[[webflux-view-freemarker-contextconfig]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "FreeMarker", "heading_level": 2, "file_order": 437, "section_index": 2, "content_hash": "cfa4d02887a5f73dab081b886a56f665f101db4670629b7f418104c71d352b8a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:5bd74cc6296b8c8006cc1adeb0316a71a3f6bad454edc0e82f5acad305f07486", "content": "[.small]#xref:web/webmvc-view/mvc-freemarker.adoc#mvc-view-freemarker-contextconfig[See equivalent in the Servlet stack]#\n\nThe following example shows how to configure FreeMarker as a view technology:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfiguration implements WebFluxConfigurer {\n\n @Override\n public void configureViewResolvers(ViewResolverRegistry registry) {\n registry.freeMarker();\n }\n\n // Configure FreeMarker...\n\n @Bean\n public FreeMarkerConfigurer freeMarkerConfigurer() {\n FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n configurer.setTemplateLoaderPath(\"classpath:/templates/freemarker\");\n return configurer;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfiguration : WebFluxConfigurer {\n\n override fun configureViewResolvers(registry: ViewResolverRegistry) {\n registry.freeMarker()\n }\n\n // Configure FreeMarker...\n\n @Bean\n fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {\n setTemplateLoaderPath(\"classpath:/templates/freemarker\")\n }\n\t}\n----\n======\n\nYour templates need to be stored in the directory specified by the `FreeMarkerConfigurer`,\nshown in the preceding example. Given the preceding configuration, if your controller\nreturns the view name, `welcome`, the resolver looks for the\n`classpath:/templates/freemarker/welcome.ftl` template.\n\n[[webflux-views-freemarker]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "View Configuration", "heading_level": 3, "file_order": 437, "section_index": 3, "content_hash": "5bd74cc6296b8c8006cc1adeb0316a71a3f6bad454edc0e82f5acad305f07486", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:7f748df883bde5722a5f2edf6b02ff006c59ca9e68980b2abc95fad320e2ee35", "content": "[.small]#xref:web/webmvc-view/mvc-freemarker.adoc#mvc-views-freemarker[See equivalent in the Servlet stack]#\n\nYou can pass FreeMarker 'Settings' and 'SharedVariables' directly to the FreeMarker\n`Configuration` object (which is managed by Spring) by setting the appropriate bean\nproperties on the `FreeMarkerConfigurer` bean. The `freemarkerSettings` property requires\na `java.util.Properties` object, and the `freemarkerVariables` property requires a\n`java.util.Map`. The following example shows how to use a `FreeMarkerConfigurer`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfiguration implements WebFluxConfigurer {\n\n // ...\n\n @Bean\n public FreeMarkerConfigurer freeMarkerConfigurer() {\n Map<String, Object> variables = new HashMap<>();\n variables.put(\"xml_escape\", new XmlEscape());\n\n FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n configurer.setTemplateLoaderPath(\"classpath:/templates\");\n configurer.setFreemarkerVariables(variables);\n return configurer;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfiguration : WebFluxConfigurer {\n\n // ...\n\n @Bean\n fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {\n setTemplateLoaderPath(\"classpath:/templates\")\n setFreemarkerVariables(mapOf(\"xml_escape\" to XmlEscape()))\n }\n\t}\n----\n======\n\nSee the FreeMarker documentation for details of settings and variables as they apply to\nthe `Configuration` object.\n\n[[webflux-view-freemarker-forms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "FreeMarker Configuration", "heading_level": 3, "file_order": 437, "section_index": 4, "content_hash": "7f748df883bde5722a5f2edf6b02ff006c59ca9e68980b2abc95fad320e2ee35", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:9db8697caf5015116570508aad3cc6ac449d10a818ff91b517dc2dc136e0baf1", "content": "[.small]#xref:web/webmvc-view/mvc-freemarker.adoc#mvc-view-freemarker-forms[See equivalent in the Servlet stack]#\n\nSpring provides a tag library for use in JSPs that contains, among others, a\n`<spring:bind/>` element. This element primarily lets forms display values from\nform-backing objects and show the results of failed validations from a `Validator` in the\nweb or business tier. Spring also has support for the same functionality in FreeMarker,\nwith additional convenience macros for generating form input elements themselves.\n\n[[webflux-view-bind-macros]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "Form Handling", "heading_level": 3, "file_order": 437, "section_index": 5, "content_hash": "9db8697caf5015116570508aad3cc6ac449d10a818ff91b517dc2dc136e0baf1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:fc200af1439df7fc6e784fb73abfdeac983741317802aaf833026cd02e2b2d98", "content": "[.small]#xref:web/webmvc-view/mvc-freemarker.adoc#mvc-view-bind-macros[See equivalent in the Servlet stack]#\n\nA standard set of macros are maintained within the `spring-webflux.jar` file for\nFreeMarker, so they are always available to a suitably configured application.\n\nSome of the macros defined in the Spring templating libraries are considered internal\n(private), but no such scoping exists in the macro definitions, making all macros visible\nto calling code and user templates. The following sections concentrate only on the macros\nyou need to directly call from within your templates. If you wish to view the macro code\ndirectly, the file is called `spring.ftl` and is in the\n`org.springframework.web.reactive.result.view.freemarker` package.\n\nFor additional details on binding support, see xref:web/webmvc-view/mvc-freemarker.adoc#mvc-view-simple-binding[Simple Binding]\n for Spring MVC.\n\n[[webflux-views-form-macros]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "The Bind Macros", "heading_level": 4, "file_order": 437, "section_index": 6, "content_hash": "fc200af1439df7fc6e784fb73abfdeac983741317802aaf833026cd02e2b2d98", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:098fb05e524380049df0c517bac8a62c4ae35f1c5eb45263d1d0e13872adddd5", "content": "For details on Spring's form macro support for FreeMarker templates, consult the following\nsections of the Spring MVC documentation.\n\n* xref:web/webmvc-view/mvc-freemarker.adoc#mvc-views-form-macros[Input Macros]\n* xref:web/webmvc-view/mvc-freemarker.adoc#mvc-views-form-macros-input[Input Fields]\n* xref:web/webmvc-view/mvc-freemarker.adoc#mvc-views-form-macros-select[Selection Fields]\n* xref:web/webmvc-view/mvc-freemarker.adoc#mvc-views-form-macros-html-escaping[HTML Escaping]\n\n[[webflux-view-script]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "Form Macros", "heading_level": 4, "file_order": 437, "section_index": 7, "content_hash": "098fb05e524380049df0c517bac8a62c4ae35f1c5eb45263d1d0e13872adddd5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:9beff6646e47f024d028bd9f68bf1a9cd4bdf6bdb7587d00d766dd44b9630f60", "content": "[.small]#xref:web/webmvc-view/mvc-script.adoc[See equivalent in the Servlet stack]#\n\nThe Spring Framework has a built-in integration for using Spring WebFlux with any\ntemplating library that can run on top of the\n{JSR}223[JSR-223] Java scripting engine.\nThe following table shows the templating libraries that we have tested on different script engines:\n\n[%header]\n|===\n|Scripting Library |Scripting Engine\n|https://docs.ruby-lang.org/en/master/ERB.html[ERB] |https://www.jruby.org[JRuby]\n|https://docs.python.org/2/library/string.html#template-strings[String templates] |https://www.jython.org/[Jython]\n|===\n\nTIP: The basic rule for integrating any other script engine is that it must implement the\n`ScriptEngine` and `Invocable` interfaces.\n\n[[webflux-view-script-dependencies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "Script Views", "heading_level": 2, "file_order": 437, "section_index": 8, "content_hash": "9beff6646e47f024d028bd9f68bf1a9cd4bdf6bdb7587d00d766dd44b9630f60", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:7acac19e62d0508859289a4768a90404c6510201821d60a4eff8de680d9f384a", "content": "[.small]#xref:web/webmvc-view/mvc-script.adoc#mvc-view-script-dependencies[See equivalent in the Servlet stack]#\n\nYou need to have the script engine on your classpath, the details of which vary by script engine:\n\n* https://www.jruby.org[JRuby] should be added as a dependency for Ruby support.\n* https://www.jython.org[Jython] should be added as a dependency for Python support.\n\n[[webflux-view-script-integrate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "Requirements", "heading_level": 3, "file_order": 437, "section_index": 9, "content_hash": "7acac19e62d0508859289a4768a90404c6510201821d60a4eff8de680d9f384a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:a54bcc106a3099a42d3d6d7211280af9d91f1e6f70fef255b8e5f64e93f9c327", "content": "[.small]#xref:web/webmvc-view/mvc-script.adoc#mvc-view-script-integrate[See equivalent in the Servlet stack]#\n\nYou can declare a `ScriptTemplateConfigurer` bean to specify the script engine to use,\nthe script files to load, what function to call to render templates, and so on.\nThe following example uses the Jython Python engine:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tpublic class WebConfiguration implements WebFluxConfigurer {\n\n @Override\n public void configureViewResolvers(ViewResolverRegistry registry) {\n registry.scriptTemplate();\n }\n\n @Bean\n public ScriptTemplateConfigurer configurer() {\n ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();\n configurer.setEngineName(\"jython\");\n configurer.setScripts(\"render.py\");\n configurer.setRenderFunction(\"render\");\n return configurer;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfiguration : WebFluxConfigurer {\n\n override fun configureViewResolvers(registry: ViewResolverRegistry) {\n registry.scriptTemplate()\n }\n\n @Bean\n fun configurer() = ScriptTemplateConfigurer().apply {\n engineName = \"jython\"\n setScripts(\"render.py\")\n renderFunction = \"render\"\n }\n\t}\n----\n======\n\nThe `render` function is called with the following parameters:\n\n* `String template`: The template content\n* `Map model`: The view model\n* `RenderingContext renderingContext`: The\n {spring-framework-api}/web/servlet/view/script/RenderingContext.html[`RenderingContext`]\n that gives access to the application context, the locale, the template loader, and the\n URL\n\nCheck out the Spring Framework unit tests,\n{spring-framework-code}/spring-webflux/src/test/java/org/springframework/web/reactive/result/view/script[Java], and\n{spring-framework-code}/spring-webflux/src/test/resources/org/springframework/web/reactive/result/view/script[resources],\nfor more configuration examples.\n\n[[webflux-view-fragments]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "Script Templates", "heading_level": 3, "file_order": 437, "section_index": 10, "content_hash": "a54bcc106a3099a42d3d6d7211280af9d91f1e6f70fef255b8e5f64e93f9c327", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:70f0649f7e95676380153ed74c84fcb67a3d4186b40b354fe8d7397044170d91", "content": "[.small]#xref:web/webmvc-view/mvc-fragments.adoc[See equivalent in the Servlet stack]#\n\nhttps://htmx.org/[HTMX] and https://turbo.hotwired.dev/[Hotwire Turbo] emphasize an\nHTML-over-the-wire approach where clients receive server updates in HTML rather than in JSON.\nThis allows the benefits of an SPA (single page app) without having to write much or even\nany JavaScript. For a good overview and to learn more, please visit their respective\nwebsites.\n\nIn Spring WebFlux, view rendering typically involves specifying one view and one model.\nHowever, in HTML-over-the-wire a common capability is to send multiple HTML fragments that\nthe browser can use to update different parts of the page. For this, controller methods\ncan return `Collection<Fragment>`. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping\n\tList<Fragment> handle() {\n return List.of(Fragment.create(\"posts\"), Fragment.create(\"comments\"));\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping\n\tfun handle(): List<Fragment> {\n return listOf(Fragment.create(\"posts\"), Fragment.create(\"comments\"))\n\t}\n----\n======\n\nThe same can be done also by returning the dedicated type `FragmentsRendering`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping\n\tFragmentsRendering handle() {\n return FragmentsRendering.fragment(\"posts\").fragment(\"comments\").build();\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@GetMapping\n\tfun handle(): FragmentsRendering {\n return FragmentsRendering.fragment(\"posts\").fragment(\"comments\").build()\n\t}\n----\n======\n\nEach fragment can have an independent model, and that model inherits attributes from the\nshared model for the request.\n\nHTMX and Hotwire Turbo support streaming updates over SSE (server-sent events).\nA controller can create `FragmentsRendering` with a `Flux<Fragment>`, or with any other\nreactive producer adaptable to a Reactive Streams `Publisher` via `ReactiveAdapterRegistry`.\nIt is also possible to return `Flux<Fragment>` directly without the `FragmentsRendering`\nwrapper.\n\n[[webflux-view-httpmessagewriter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "HTML Fragment", "heading_level": 2, "file_order": 437, "section_index": 11, "content_hash": "70f0649f7e95676380153ed74c84fcb67a3d4186b40b354fe8d7397044170d91", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:88ac91bdda45d91db9bb66da1222168046e46871429e058afcaa9614e201385e", "content": "[.small]#xref:web/webmvc-view/mvc-jackson.adoc[See equivalent in the Servlet stack]#\n\nFor xref:web/webflux/dispatcher-handler.adoc#webflux-multiple-representations[Content Negotiation]\npurposes, it is useful to be able to alternate between rendering a model with an HTML template\nor as other formats (such as JSON or XML), depending on the content type requested by the client.\nTo support doing so, Spring WebFlux provides the `HttpMessageWriterView`, which you can use to\nplug in any of the available xref:web/webflux/reactive-spring.adoc#webflux-codecs[Codecs] from\n`spring-web`, such as `JacksonJsonEncoder`, `JacksonSmileEncoder`, or `Jaxb2XmlEncoder`.\n\nUnlike other view technologies, `HttpMessageWriterView` does not require a `ViewResolver` but is\ninstead xref:web/webflux/config.adoc#webflux-config-view-resolvers[configured] as a default view.\nYou can configure one or more such default views, wrapping different `HttpMessageWriter` instances\nor `Encoder` instances. The one that matches the requested content type is used at runtime.\n\nIn most cases, a model contains multiple attributes. To determine which one to serialize,\nyou can configure `HttpMessageWriterView` with the name of the model attribute to use for\nrendering. If the model contains only one attribute, that one is used.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-view.adoc", "title": "webflux-view", "heading": "JSON and XML", "heading_level": 2, "file_order": 437, "section_index": 12, "content_hash": "88ac91bdda45d91db9bb66da1222168046e46871429e058afcaa9614e201385e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-view.adoc"}}
{"id": "sha256:108403a7d8ca92e2f8f92ed1dfbfe5a6d1e2cce5f9886e56d4391f831990dff5", "content": "[[webflux-client]]\n\nSpring WebFlux includes a client to perform HTTP requests. `WebClient` has a\nfunctional, fluent API based on Reactor (see xref:web/webflux-reactive-libraries.adoc[Reactive Libraries])\nwhich enables declarative composition of asynchronous logic without the need to deal with\nthreads or concurrency. It is fully non-blocking, supports streaming, and relies on\nthe same xref:web/webflux/reactive-spring.adoc#webflux-codecs[codecs] that are also used to encode and\ndecode request and response content on the server side.\n\n`WebClient` needs an HTTP client library to perform requests. There is built-in\nsupport for the following:\n\n* {reactor-github-org}/reactor-netty[Reactor Netty]\n* {java-api}/java.net.http/java/net/http/HttpClient.html[JDK HttpClient]\n* https://github.com/jetty-project/jetty-reactive-httpclient[Jetty Reactive HttpClient]\n* https://hc.apache.org/index.html[Apache HttpComponents]\n* Others can be plugged in via `ClientHttpConnector`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-webclient.adoc", "title": "webflux-webclient", "heading": "webflux-webclient", "heading_level": 1, "file_order": 438, "section_index": 0, "content_hash": "108403a7d8ca92e2f8f92ed1dfbfe5a6d1e2cce5f9886e56d4391f831990dff5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-webclient.adoc"}}
{"id": "sha256:2e3336818f12404c0b0630173194555dbdff010cf74dd685782f8bf832f77339", "content": "[[webflux-websocket]]\n\n[.small]#xref:web/websocket.adoc[See equivalent in the Servlet stack]#\n\nThis part of the reference documentation covers support for reactive-stack WebSocket\nmessaging.\n\n[[introduction-to-websocket]]\n= Introduction to WebSocket\n\nThe WebSocket protocol, {rfc-site}/rfc6455[RFC 6455], provides a standardized\nway to establish a full-duplex, two-way communication channel between client and server\nover a single TCP connection. It is a different TCP protocol from HTTP but is designed to\nwork over HTTP, using ports 80 and 443 and allowing re-use of existing firewall rules.\n\nA WebSocket interaction begins with an HTTP request that uses the HTTP `Upgrade` header\nto upgrade or, in this case, to switch to the WebSocket protocol. The following example\nshows such an interaction:\n\n[source,yaml,indent=0,subs=\"verbatim,quotes\"]\n----\n\tGET /spring-websocket-portfolio/portfolio HTTP/1.1\n\tHost: localhost:8080\n\tUpgrade: websocket <1>\n\tConnection: Upgrade <2>\n\tSec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==\n\tSec-WebSocket-Protocol: v10.stomp, v11.stomp\n\tSec-WebSocket-Version: 13\n\tOrigin: http://localhost:8080\n----\n<1> The `Upgrade` header.\n<2> Using the `Upgrade` connection.\n\n\nInstead of the usual 200 status code, a server with WebSocket support returns output\nsimilar to the following:\n\n[source,yaml,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHTTP/1.1 101 Switching Protocols <1>\n\tUpgrade: websocket\n\tConnection: Upgrade\n\tSec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=\n\tSec-WebSocket-Protocol: v10.stomp\n----\n<1> Protocol switch\n\n\nAfter a successful handshake, the TCP socket underlying the HTTP upgrade request remains\nopen for both the client and the server to continue to send and receive messages.\n\nA complete introduction of how WebSockets work is beyond the scope of this document.\nSee RFC 6455, the WebSocket chapter of HTML5, or any of the many introductions and\ntutorials on the Web.\n\nNote that, if a WebSocket server is running behind a web server (for example, nginx), you\nlikely need to configure it to pass WebSocket upgrade requests on to the WebSocket\nserver. Likewise, if the application runs in a cloud environment, check the\ninstructions of the cloud provider related to WebSocket support.\n\n\n[[http-versus-websocket]]\n== HTTP Versus WebSocket\n\nEven though WebSocket is designed to be HTTP-compatible and starts with an HTTP request,\nit is important to understand that the two protocols lead to very different\narchitectures and application programming models.\n\nIn HTTP and REST, an application is modeled as many URLs. To interact with the application,\nclients access those URLs, request-response style. Servers route requests to the\nappropriate handler based on the HTTP URL, method, and headers.\n\nBy contrast, in WebSockets, there is usually only one URL for the initial connect.\nSubsequently, all application messages flow on that same TCP connection. This points to\nan entirely different asynchronous, event-driven, messaging architecture.\n\nWebSocket is also a low-level transport protocol, which, unlike HTTP, does not prescribe\nany semantics to the content of messages. That means that there is no way to route or process\na message unless the client and the server agree on message semantics.\n\nWebSocket clients and servers can negotiate the use of a higher-level, messaging protocol\n(for example, STOMP), through the `Sec-WebSocket-Protocol` header on the HTTP handshake request.\nIn the absence of that, they need to come up with their own conventions.\n\n\n[[when-to-use-websockets]]\n== When to Use WebSockets\n\nWebSockets can make a web page be dynamic and interactive. However, in many cases,\na combination of AJAX and HTTP streaming or long polling can provide a simple and\neffective solution.\n\nFor example, news, mail, and social feeds need to update dynamically, but it may be\nperfectly okay to do so every few minutes. Collaboration, games, and financial apps, on\nthe other hand, need to be much closer to real-time.\n\nLatency alone is not a deciding factor. If the volume of messages is relatively low (for example,\nmonitoring network failures) HTTP streaming or polling can provide an effective solution.\nIt is the combination of low latency, high frequency, and high volume that make the best\ncase for the use of WebSocket.\n\nKeep in mind also that over the Internet, restrictive proxies that are outside of your control\nmay preclude WebSocket interactions, either because they are not configured to pass on the\n`Upgrade` header or because they close long-lived connections that appear idle. This\nmeans that the use of WebSocket for internal applications within the firewall is a more\nstraightforward decision than it is for public facing applications.\n\n[[webflux-websocket-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc", "title": "webflux-websocket", "heading": "webflux-websocket", "heading_level": 1, "file_order": 439, "section_index": 0, "content_hash": "2e3336818f12404c0b0630173194555dbdff010cf74dd685782f8bf832f77339", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc"}}
{"id": "sha256:fdcd7b38946936683d8ab42779efc1cdd7c0da995290d5b75856cb9e42a507bd", "content": "[.small]#xref:web/websocket/stomp/server-config.adoc[See equivalent in the Servlet stack]#\n\nThe Spring Framework provides a WebSocket API that you can use to write client- and\nserver-side applications that handle WebSocket messages.\n\n[[webflux-websocket-server-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc", "title": "webflux-websocket", "heading": "WebSocket API", "heading_level": 2, "file_order": 439, "section_index": 1, "content_hash": "fdcd7b38946936683d8ab42779efc1cdd7c0da995290d5b75856cb9e42a507bd", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc"}}
{"id": "sha256:eaee2b1a075c48dee774bab5171f6eb420107d69d72fd3a743d21c26f568a57e", "content": "[.small]#xref:web/websocket/server.adoc#websocket-server-handler[See equivalent in the Servlet stack]#\n\nTo create a WebSocket server, you can first create a `WebSocketHandler`.\nThe following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.web.reactive.socket.WebSocketHandler;\n\timport org.springframework.web.reactive.socket.WebSocketSession;\n\n\tpublic class MyWebSocketHandler implements WebSocketHandler {\n\n @Override\n public Mono<Void> handle(WebSocketSession session) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.web.reactive.socket.WebSocketHandler\n\timport org.springframework.web.reactive.socket.WebSocketSession\n\n\tclass MyWebSocketHandler : WebSocketHandler {\n\n override fun handle(session: WebSocketSession): Mono<Void> {\n // ...\n }\n\t}\n----\n======\n\nThen you can map it to a URL:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig {\n\n @Bean\n public HandlerMapping handlerMapping() {\n Map<String, WebSocketHandler> map = new HashMap<>();\n map.put(\"/path\", new MyWebSocketHandler());\n int order = -1; // before annotated controllers\n\n return new SimpleUrlHandlerMapping(map, order);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig {\n\n @Bean\n fun handlerMapping(): HandlerMapping {\n val map = mapOf(\"/path\" to MyWebSocketHandler())\n val order = -1 // before annotated controllers\n\n return SimpleUrlHandlerMapping(map, order)\n }\n\t}\n----\n======\n\nIf using the xref:web/webflux/dispatcher-handler.adoc#webflux-framework-config[WebFlux Config] there is nothing\nfurther to do, or otherwise if not using the WebFlux config you'll need to declare a\n`WebSocketHandlerAdapter` as shown below:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig {\n\n // ...\n\n @Bean\n public WebSocketHandlerAdapter handlerAdapter() {\n return new WebSocketHandlerAdapter();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig {\n\n // ...\n\n @Bean\n fun handlerAdapter() = WebSocketHandlerAdapter()\n\t}\n----\n======\n\n[[webflux-websockethandler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc", "title": "webflux-websocket", "heading": "Server", "heading_level": 3, "file_order": 439, "section_index": 2, "content_hash": "eaee2b1a075c48dee774bab5171f6eb420107d69d72fd3a743d21c26f568a57e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc"}}
{"id": "sha256:525bb91020112e0fba965e844c44aeb9ee84042ca305f0c3b89c8f2a45a10842", "content": "The `handle` method of `WebSocketHandler` takes `WebSocketSession` and returns `Mono<Void>`\nto indicate when application handling of the session is complete. The session is handled\nthrough two streams, one for inbound and one for outbound messages. The following table\ndescribes the two methods that handle the streams:\n\n[options=\"header\"]\n|===\n| `WebSocketSession` method | Description\n\n| `Flux<WebSocketMessage> receive()`\n| Provides access to the inbound message stream and completes when the connection is closed.\n\n| `Mono<Void> send(Publisher<WebSocketMessage>)`\n| Takes a source for outgoing messages, writes the messages, and returns a `Mono<Void>` that\n completes when the source completes and writing is done.\n\n|===\n\nA `WebSocketHandler` must compose the inbound and outbound streams into a unified flow and\nreturn a `Mono<Void>` that reflects the completion of that flow. Depending on application\nrequirements, the unified flow completes when:\n\n* Either the inbound or the outbound message stream completes.\n* The inbound stream completes (that is, the connection closed), while the outbound stream is infinite.\n* At a chosen point, through the `close` method of `WebSocketSession`.\n\nWhen inbound and outbound message streams are composed together, there is no need to\ncheck if the connection is open, since Reactive Streams signals end activity.\nThe inbound stream receives a completion or error signal, and the outbound stream\nreceives a cancellation signal.\n\nThe most basic implementation of a handler is one that handles the inbound stream. The\nfollowing example shows such an implementation:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ExampleHandler implements WebSocketHandler {\n\n @Override\n public Mono<Void> handle(WebSocketSession session) {\n return session.receive() // <1>\n .doOnNext(message -> {\n // ... // <2>\n })\n .concatMap(message -> {\n // ... // <3>\n })\n .then(); // <4>\n }\n\t}\n----\n<1> Access the stream of inbound messages.\n<2> Do something with each message.\n<3> Perform nested asynchronous operations that use the message content.\n<4> Return a `Mono<Void>` that completes when receiving completes.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ExampleHandler : WebSocketHandler {\n\n override fun handle(session: WebSocketSession): Mono<Void> {\n return session.receive() // <1>\n .doOnNext {\n // ... // <2>\n }\n .concatMap {\n // ... // <3>\n }\n .then() // <4>\n }\n\t}\n----\n<1> Access the stream of inbound messages.\n<2> Do something with each message.\n<3> Perform nested asynchronous operations that use the message content.\n<4> Return a `Mono<Void>` that completes when receiving completes.\n======\n\nTIP: For nested, asynchronous operations, you may need to call `message.retain()` on underlying\nservers that use pooled data buffers (for example, Netty). Otherwise, the data buffer may be\nreleased before you have had a chance to read the data. For more background, see\nxref:core/databuffer-codec.adoc[Data Buffers and Codecs].\n\nThe following implementation combines the inbound and outbound streams:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ExampleHandler implements WebSocketHandler {\n\n @Override\n public Mono<Void> handle(WebSocketSession session) {\n\n Flux<WebSocketMessage> output = session.receive() // <1>\n .doOnNext(message -> {\n // ...\n })\n .concatMap(message -> {\n // ...\n })\n .map(value -> session.textMessage(\"Echo \" + value));\t// <2>\n\n return session.send(output); // <3>\n }\n\t}\n----\n<1> Handle the inbound message stream.\n<2> Create the outbound message, producing a combined flow.\n<3> Return a `Mono<Void>` that does not complete while we continue to receive.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ExampleHandler : WebSocketHandler {\n\n override fun handle(session: WebSocketSession): Mono<Void> {\n\n val output = session.receive() // <1>\n .doOnNext {\n // ...\n }\n .concatMap {\n // ...\n }\n .map { session.textMessage(\"Echo $it\") }\t// <2>\n\n return session.send(output) // <3>\n }\n\t}\n----\n<1> Handle the inbound message stream.\n<2> Create the outbound message, producing a combined flow.\n<3> Return a `Mono<Void>` that does not complete while we continue to receive.\n======\n\nInbound and outbound streams can be independent and be joined only for completion,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ExampleHandler implements WebSocketHandler {\n\n @Override\n public Mono<Void> handle(WebSocketSession session) {\n\n Mono<Void> input = session.receive() <1>\n .doOnNext(message -> {\n // ...\n })\n .concatMap(message -> {\n // ...\n })\n .then();\n\n Flux<String> source = ... ;\n Mono<Void> output = session.send(source.map(session::textMessage));\t<2>\n\n return input.and(output); <3>\n }\n\t}\n----\n<1> Handle inbound message stream.\n<2> Send outgoing messages.\n<3> Join the streams and return a `Mono<Void>` that completes when either stream ends.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass ExampleHandler : WebSocketHandler {\n\n override fun handle(session: WebSocketSession): Mono<Void> {\n\n val input = session.receive() // <1>\n .doOnNext {\n // ...\n }\n .concatMap {\n // ...\n }\n .then()\n\n val source: Flux<String> = ...\n val output = session.send(source.map(session::textMessage)) // <2>\n\n return input.and(output) // <3>\n }\n\t}\n----\n<1> Handle inbound message stream.\n<2> Send outgoing messages.\n<3> Join the streams and return a `Mono<Void>` that completes when either stream ends.\n======\n\n[[webflux-websocket-databuffer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc", "title": "webflux-websocket", "heading": "`WebSocketHandler`", "heading_level": 3, "file_order": 439, "section_index": 3, "content_hash": "525bb91020112e0fba965e844c44aeb9ee84042ca305f0c3b89c8f2a45a10842", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc"}}
{"id": "sha256:ca88653d8bc0cb8c54008d39c180af2c1bf1af51dce44beca73ca9bea396939c", "content": "`DataBuffer` is the representation for a byte buffer in WebFlux. The Spring Core part of\nthe reference has more on that in the section on\nxref:core/databuffer-codec.adoc[Data Buffers and Codecs]. The key point to understand is that on some\nservers like Netty, byte buffers are pooled and reference counted, and must be released\nwhen consumed to avoid memory leaks.\n\nWhen running on Netty, applications must use `DataBufferUtils.retain(dataBuffer)` if they\nwish to hold on input data buffers in order to ensure they are not released, and\nsubsequently use `DataBufferUtils.release(dataBuffer)` when the buffers are consumed.\n\n[[webflux-websocket-server-handshake]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc", "title": "webflux-websocket", "heading": "`DataBuffer`", "heading_level": 3, "file_order": 439, "section_index": 4, "content_hash": "ca88653d8bc0cb8c54008d39c180af2c1bf1af51dce44beca73ca9bea396939c", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc"}}
{"id": "sha256:8a0cb2ba75543ec388008708d9ad3df9ceef2b1dad11a7d031606f8de777732d", "content": "[.small]#xref:web/websocket/server.adoc#websocket-server-handshake[See equivalent in the Servlet stack]#\n\n`WebSocketHandlerAdapter` delegates to a `WebSocketService`. By default, that is an instance\nof `HandshakeWebSocketService`, which performs basic checks on the WebSocket request and\nthen uses `RequestUpgradeStrategy` for the server in use. Currently, there is built-in\nsupport for Reactor Netty, Tomcat, and Jetty.\n\n`HandshakeWebSocketService` exposes a `sessionAttributePredicate` property that allows\nsetting a `Predicate<String>` to extract attributes from the `WebSession` and insert them\ninto the attributes of the `WebSocketSession`.\n\n[[webflux-websocket-server-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc", "title": "webflux-websocket", "heading": "Handshake", "heading_level": 3, "file_order": 439, "section_index": 5, "content_hash": "8a0cb2ba75543ec388008708d9ad3df9ceef2b1dad11a7d031606f8de777732d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc"}}
{"id": "sha256:1ff51994c9ab8156cab1bc2c4333a5f4b35ff74f94c5ccdf81b707362022c554", "content": "[.small]#xref:web/websocket/server.adoc#websocket-server-runtime-configuration[See equivalent in the Servlet stack]#\n\nThe `RequestUpgradeStrategy` for each server exposes configuration specific to the\nunderlying WebSocket server engine. When using the WebFlux Java config you can customize\nsuch properties as shown in the corresponding section of the\nxref:web/webflux/config.adoc#webflux-config-websocket-service[WebFlux Config], or otherwise if\nnot using the WebFlux config, use the below:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig {\n\n @Bean\n public WebSocketHandlerAdapter handlerAdapter() {\n return new WebSocketHandlerAdapter(webSocketService());\n }\n\n @Bean\n public WebSocketService webSocketService() {\n TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();\n strategy.setMaxSessionIdleTimeout(0L);\n return new HandshakeWebSocketService(strategy);\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass WebConfig {\n\n @Bean\n fun handlerAdapter() =\n WebSocketHandlerAdapter(webSocketService())\n\n @Bean\n fun webSocketService(): WebSocketService {\n val strategy = TomcatRequestUpgradeStrategy().apply {\n setMaxSessionIdleTimeout(0L)\n }\n return HandshakeWebSocketService(strategy)\n }\n\t}\n----\n======\n\nCheck the upgrade strategy for your server to see what options are available. Currently,\nonly Tomcat and Jetty expose such options.\n\n[[webflux-websocket-server-cors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc", "title": "webflux-websocket", "heading": "Server Configuration", "heading_level": 3, "file_order": 439, "section_index": 6, "content_hash": "1ff51994c9ab8156cab1bc2c4333a5f4b35ff74f94c5ccdf81b707362022c554", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc"}}
{"id": "sha256:539d1baed9ba9e18fee461dc0ff4b1fbcc5e6a7d7c6c35be4d032230df3fa559", "content": "[.small]#xref:web/websocket/server.adoc#websocket-server-allowed-origins[See equivalent in the Servlet stack]#\n\nThe easiest way to configure CORS and restrict access to a WebSocket endpoint is to\nhave your `WebSocketHandler` implement `CorsConfigurationSource` and return a\n`CorsConfiguration` with allowed origins, headers, and other details. If you cannot do\nthat, you can also set the `corsConfigurations` property on the `SimpleUrlHandler` to\nspecify CORS settings by URL pattern. If both are specified, they are combined by using the\n`combine` method on `CorsConfiguration`.\n\n[[webflux-websocket-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc", "title": "webflux-websocket", "heading": "CORS", "heading_level": 3, "file_order": 439, "section_index": 7, "content_hash": "539d1baed9ba9e18fee461dc0ff4b1fbcc5e6a7d7c6c35be4d032230df3fa559", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc"}}
{"id": "sha256:e1bf82c57881eb2c3bdf14a41783459af3b2fcd25c0be46b59a5cbf7e7436f95", "content": "Spring WebFlux provides a `WebSocketClient` abstraction with implementations for\nReactor Netty, Tomcat, Jetty, and standard Java (that is, JSR-356).\n\nNOTE: The Tomcat client is effectively an extension of the standard Java one with some extra\nfunctionality in the `WebSocketSession` handling to take advantage of the Tomcat-specific\nAPI to suspend receiving messages for back pressure.\n\nTo start a WebSocket session, you can create an instance of the client and use its `execute`\nmethods:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tWebSocketClient client = new ReactorNettyWebSocketClient();\n\n\tURI url = new URI(\"ws://localhost:8080/path\");\n\tclient.execute(url, session ->\n session.receive()\n .doOnNext(System.out::println)\n .then());\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval client = ReactorNettyWebSocketClient()\n\n val url = URI(\"ws://localhost:8080/path\")\n client.execute(url) { session ->\n session.receive()\n .doOnNext(::println)\n .then()\n }\n----\n======\n\nSome clients, such as Jetty, implement `Lifecycle` and need to be stopped and started\nbefore you can use them. All clients have constructor options related to configuration\nof the underlying WebSocket client.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc", "title": "webflux-websocket", "heading": "Client", "heading_level": 3, "file_order": 439, "section_index": 8, "content_hash": "e1bf82c57881eb2c3bdf14a41783459af3b2fcd25c0be46b59a5cbf7e7436f95", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux-websocket.adoc"}}
{"id": "sha256:25b4a4e304e0e752e543a7e3d6001756263543c3721efdf0f8e16dc9d3b7f3ec", "content": "[[webflux]]\n[[spring-webflux]]\n\nThe original web framework included in the Spring Framework, Spring Web MVC, was\npurpose-built for the Servlet API and Servlet containers. The reactive-stack web framework,\nSpring WebFlux, was added later in version 5.0. It is fully non-blocking, supports\n{reactive-streams-site}/[Reactive Streams] back pressure, and runs on such servers as\nNetty, and Servlet containers.\n\nBoth web frameworks mirror the names of their source modules\n({spring-framework-code}/spring-webmvc[spring-webmvc] and\n{spring-framework-code}/spring-webflux[spring-webflux]) and co-exist side by side in the\nSpring Framework. Each module is optional. Applications can use one or the other module or,\nin some cases, both -- for example, Spring MVC controllers with the reactive `WebClient`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webflux.adoc", "title": "webflux", "heading": "webflux", "heading_level": 1, "file_order": 440, "section_index": 0, "content_hash": "25b4a4e304e0e752e543a7e3d6001756263543c3721efdf0f8e16dc9d3b7f3ec", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webflux.adoc"}}
{"id": "sha256:e7201ed9264ba38367a86898b75c618346b89fa95ab9c0a5b184734b29042961", "content": "[[webmvc-client]]\n\nThis section describes options for client-side access to REST endpoints.\n\n[[webmvc-restclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-client.adoc", "title": "webmvc-client", "heading": "webmvc-client", "heading_level": 1, "file_order": 441, "section_index": 0, "content_hash": "e7201ed9264ba38367a86898b75c618346b89fa95ab9c0a5b184734b29042961", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-client.adoc"}}
{"id": "sha256:25c69a9215906891494276c2b131b8705cb1e1bbd57d034bf567ec5b77c4beb1", "content": "`RestClient` is a synchronous HTTP client that exposes a modern, fluent API.\n\nSee xref:integration/rest-clients.adoc#rest-restclient[`RestClient`] for more details.\n\n[[webmvc-webclient]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-client.adoc", "title": "webmvc-client", "heading": "`RestClient`", "heading_level": 2, "file_order": 441, "section_index": 1, "content_hash": "25c69a9215906891494276c2b131b8705cb1e1bbd57d034bf567ec5b77c4beb1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-client.adoc"}}
{"id": "sha256:90cf04935407f45fef6befe12319e72327e5811eab605bce97f1104014061bde", "content": "`WebClient` is a reactive client for making HTTP requests with a fluent API.\n\nSee xref:web/webflux-webclient.adoc[`WebClient`] for more details.\n\n[[webmvc-resttemplate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-client.adoc", "title": "webmvc-client", "heading": "`WebClient`", "heading_level": 2, "file_order": 441, "section_index": 2, "content_hash": "90cf04935407f45fef6befe12319e72327e5811eab605bce97f1104014061bde", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-client.adoc"}}
{"id": "sha256:c60dfd3fe4b1d38c55a31b441fb980cbb10825c8d46622db001dd750656debff", "content": "`RestTemplate` is a synchronous client for making HTTP requests. It is the original\nSpring REST client and exposes a simple, template-method API over underlying HTTP client\nlibraries.\n\nSee xref:integration/rest-clients.adoc#rest-resttemplate[`RestTemplate`] for details.\n\n[[webmvc-http-service-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-client.adoc", "title": "webmvc-client", "heading": "`RestTemplate`", "heading_level": 2, "file_order": 441, "section_index": 3, "content_hash": "c60dfd3fe4b1d38c55a31b441fb980cbb10825c8d46622db001dd750656debff", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-client.adoc"}}
{"id": "sha256:f8d30e41357b3326f8bfa589745a38b898dfcb5ecde221436ab83957aaacbdc7", "content": "The Spring Framework lets you define an HTTP service as a Java interface with HTTP\nexchange methods. You can then generate a proxy that implements this interface and\nperforms the exchanges. This helps to simplify HTTP remote access and provides additional\nflexibility for choosing an API style such as synchronous or reactive.\n\nSee xref:integration/rest-clients.adoc#rest-http-service-client[HTTP Service Client] for details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-client.adoc", "title": "webmvc-client", "heading": "HTTP Service Client", "heading_level": 2, "file_order": 441, "section_index": 4, "content_hash": "f8d30e41357b3326f8bfa589745a38b898dfcb5ecde221436ab83957aaacbdc7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-client.adoc"}}
{"id": "sha256:3e971998b9da8ade8b85419d8d2e076183f265c8954391117e2733fb72306349", "content": "[[mvc-cors]]\n\n[.small]#xref:web/webflux-cors.adoc[See equivalent in the Reactive stack]#\n\nSpring MVC lets you handle CORS (Cross-Origin Resource Sharing). This section\ndescribes how to do so.\n\n[[mvc-cors-intro]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc", "title": "webmvc-cors", "heading": "webmvc-cors", "heading_level": 1, "file_order": 442, "section_index": 0, "content_hash": "3e971998b9da8ade8b85419d8d2e076183f265c8954391117e2733fb72306349", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc"}}
{"id": "sha256:12c1383d442c9cd3b0c4c00621835baa7f8cb12b291a67389b764d4c35ca7894", "content": "[.small]#xref:web/webflux-cors.adoc#webflux-cors-intro[See equivalent in the Reactive stack]#\n\nFor security reasons, browsers prohibit AJAX calls to resources outside the current origin.\nFor example, you could have your bank account in one tab and evil.com in another. Scripts\nfrom evil.com should not be able to make AJAX requests to your bank API with your\ncredentials -- for example withdrawing money from your account!\n\nCross-Origin Resource Sharing (CORS) is a https://www.w3.org/TR/cors/[W3C specification]\nimplemented by https://caniuse.com/#feat=cors[most browsers] that lets you specify\nwhat kind of cross-domain requests are authorized, rather than using less secure and less\npowerful workarounds based on IFRAME or JSONP.\n\n[[mvc-cors-credentialed-requests]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc", "title": "webmvc-cors", "heading": "Introduction", "heading_level": 2, "file_order": 442, "section_index": 1, "content_hash": "12c1383d442c9cd3b0c4c00621835baa7f8cb12b291a67389b764d4c35ca7894", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc"}}
{"id": "sha256:7f6f45215f1f29790ee91ea47d2293bd0398a563e9c6d7e802b5110bc5fe277a", "content": "[.small]#xref:web/webflux-cors.adoc#webflux-cors-credentialed-requests[See equivalent in the Reactive stack]#\n\nUsing CORS with credentialed requests requires enabling `allowedCredentials`. Be aware that\nthis option establishes a high level of trust with the configured domains and also increases\nthe surface of attack of the web application by exposing sensitive user-specific information\nsuch as cookies and CSRF tokens.\n\nEnabling credentials also impacts how the configured `\"*\"` CORS wildcards are processed:\n\n* Wildcards are not authorized in `allowOrigins`, but alternatively\nthe `allowOriginPatterns` property may be used to match to a dynamic set of origins.\n* When set on `allowedHeaders` or `allowedMethods`, the `Access-Control-Allow-Headers`\nand `Access-Control-Allow-Methods` response headers are handled by copying the related\nheaders and method specified in the CORS preflight request.\n* When set on `exposedHeaders`, `Access-Control-Expose-Headers` response header is set\neither to the configured list of headers or to the wildcard character. While the CORS spec\ndoes not allow the wildcard character when `Access-Control-Allow-Credentials` is set to\n`true`, most browsers support it and the response headers are not all available during the\nCORS processing, so as a consequence the wildcard character is the header value used when\nspecified regardless of the value of the `allowCredentials` property.\n\nWARNING: While such wildcard configuration can be handy, it is recommended when possible to configure\na finite set of values instead to provide a higher level of security.\n\n[[mvc-cors-processing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc", "title": "webmvc-cors", "heading": "Credentialed Requests", "heading_level": 2, "file_order": 442, "section_index": 2, "content_hash": "7f6f45215f1f29790ee91ea47d2293bd0398a563e9c6d7e802b5110bc5fe277a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc"}}
{"id": "sha256:480a0f93281866de98c5f0c121549045e25c9a7bd3a8ac59bf87471ece52e88b", "content": "[.small]#xref:web/webflux-cors.adoc#webflux-cors-processing[See equivalent in the Reactive stack]#\n\nThe CORS specification distinguishes between preflight, simple, and actual requests.\nTo learn how CORS works, you can read\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/CORS[this article], among\nmany others, or see the specification for more details.\n\nSpring MVC `HandlerMapping` implementations provide built-in support for CORS. After successfully\nmapping a request to a handler, `HandlerMapping` implementations check the CORS configuration for the\ngiven request and handler and take further actions. Preflight requests are handled\ndirectly, while simple and actual CORS requests are intercepted, validated, and have\nrequired CORS response headers set.\n\nIn order to enable cross-origin requests (that is, the `Origin` header is present and\ndiffers from the host of the request), you need to have some explicitly declared CORS\nconfiguration. If no matching CORS configuration is found, no CORS headers are added to\nthe responses to preflight, simple and actual CORS requests and, consequently, browsers\nreject them.\n\nEach `HandlerMapping` can be\n{spring-framework-api}/web/servlet/handler/AbstractHandlerMapping.html#setCorsConfigurations(java.util.Map)[configured]\nindividually with URL pattern-based `CorsConfiguration` mappings. In most cases, applications\nuse the MVC Java configuration or the XML namespace to declare such mappings, which results\nin a single global map being passed to all `HandlerMapping` instances.\n\nYou can combine global CORS configuration at the `HandlerMapping` level with more\nfine-grained, handler-level CORS configuration. For example, annotated controllers can use\nclass- or method-level `@CrossOrigin` annotations (other handlers can implement\n`CorsConfigurationSource`).\n\nThe rules for combining global and local configuration are generally additive -- for example,\nall global and all local origins. For those attributes where only a single value can be\naccepted, for example, `allowCredentials` and `maxAge`, the local overrides the global value. See\n{spring-framework-api}/web/cors/CorsConfiguration.html#combine(org.springframework.web.cors.CorsConfiguration)[`CorsConfiguration#combine(CorsConfiguration)`]\nfor more details.\n\n[TIP]\n====\nTo learn more from the source or make advanced customizations, check the code behind:\n\n* `CorsConfiguration`\n* `CorsProcessor`, `DefaultCorsProcessor`\n* `AbstractHandlerMapping`\n====\n\n[[mvc-cors-controller]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc", "title": "webmvc-cors", "heading": "Processing", "heading_level": 2, "file_order": 442, "section_index": 3, "content_hash": "480a0f93281866de98c5f0c121549045e25c9a7bd3a8ac59bf87471ece52e88b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc"}}
{"id": "sha256:4672e1be192bfbce2f5a0c3119616613989334da8c88dd76d6a7bb5b856335df", "content": "[.small]#xref:web/webflux-cors.adoc#webflux-cors-controller[See equivalent in the Reactive stack]#\n\nThe {spring-framework-api}/web/bind/annotation/CrossOrigin.html[`@CrossOrigin`]\nannotation enables cross-origin requests on annotated controller methods,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\t@RequestMapping(\"/account\")\n\tpublic class AccountController {\n\n @CrossOrigin\n @GetMapping(\"/{id}\")\n public Account retrieve(@PathVariable Long id) {\n // ...\n }\n\n @DeleteMapping(\"/{id}\")\n public void remove(@PathVariable Long id) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@RestController\n\t@RequestMapping(\"/account\")\n\tclass AccountController {\n\n @CrossOrigin\n @GetMapping(\"/{id}\")\n fun retrieve(@PathVariable id: Long): Account {\n // ...\n }\n\n @DeleteMapping(\"/{id}\")\n fun remove(@PathVariable id: Long) {\n // ...\n }\n\t}\n----\n======\n\nBy default, `@CrossOrigin` allows:\n\n* All origins.\n* All headers.\n* All HTTP methods to which the controller method is mapped.\n\n`allowCredentials` is not enabled by default, since that establishes a trust level\nthat exposes sensitive user-specific information (such as cookies and CSRF tokens) and\nshould only be used where appropriate. When it is enabled either `allowOrigins` must be\nset to one or more specific domain (but not the special value `\"*\"`) or alternatively\nthe `allowOriginPatterns` property may be used to match to a dynamic set of origins.\n\n`maxAge` is set to 30 minutes.\n\n`@CrossOrigin` is supported at the class level, too, and is inherited by all methods,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n@CrossOrigin(origins = \"https://domain2.com\", maxAge = 3600)\n@RestController\n@RequestMapping(\"/account\")\npublic class AccountController {\n\n\t@GetMapping(\"/{id}\")\n\tpublic Account retrieve(@PathVariable Long id) {\n // ...\n\t}\n\n\t@DeleteMapping(\"/{id}\")\n\tpublic void remove(@PathVariable Long id) {\n // ...\n\t}\n}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@CrossOrigin(origins = [\"https://domain2.com\"], maxAge = 3600)\n\t@RestController\n\t@RequestMapping(\"/account\")\n\tclass AccountController {\n\n @GetMapping(\"/{id}\")\n fun retrieve(@PathVariable id: Long): Account {\n // ...\n }\n\n @DeleteMapping(\"/{id}\")\n fun remove(@PathVariable id: Long) {\n // ...\n }\n\t}\n----\n======\n\nYou can use `@CrossOrigin` at both the class level and the method level,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@CrossOrigin(maxAge = 3600)\n\t@RestController\n\t@RequestMapping(\"/account\")\n\tpublic class AccountController {\n\n @CrossOrigin(\"https://domain2.com\")\n @GetMapping(\"/{id}\")\n public Account retrieve(@PathVariable Long id) {\n // ...\n }\n\n @DeleteMapping(\"/{id}\")\n public void remove(@PathVariable Long id) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@CrossOrigin(maxAge = 3600)\n\t@RestController\n\t@RequestMapping(\"/account\")\n\tclass AccountController {\n\n @CrossOrigin(\"https://domain2.com\")\n @GetMapping(\"/{id}\")\n fun retrieve(@PathVariable id: Long): Account {\n // ...\n }\n\n @DeleteMapping(\"/{id}\")\n fun remove(@PathVariable id: Long) {\n // ...\n }\n\t}\n----\n======\n\n[[mvc-cors-global]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc", "title": "webmvc-cors", "heading": "`@CrossOrigin`", "heading_level": 2, "file_order": 442, "section_index": 4, "content_hash": "4672e1be192bfbce2f5a0c3119616613989334da8c88dd76d6a7bb5b856335df", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc"}}
{"id": "sha256:3e10c5ee6da803a47adc2f7e36bf4e34bf0d54a1ddb86036c894a53328d92338", "content": "[.small]#xref:web/webflux-cors.adoc#webflux-cors-global[See equivalent in the Reactive stack]#\n\nIn addition to fine-grained, controller method level configuration, you probably want to\ndefine some global CORS configuration, too. You can set URL-based `CorsConfiguration`\nmappings individually on any `HandlerMapping`. Most applications, however, use the\nMVC Java configuration or the MVC XML namespace to do that.\n\nBy default, global configuration enables the following:\n\n* All origins.\n* All headers.\n* `GET`, `HEAD`, and `POST` methods.\n\n`allowCredentials` is not enabled by default, since that establishes a trust level\nthat exposes sensitive user-specific information (such as cookies and CSRF tokens) and\nshould only be used where appropriate. When it is enabled either `allowOrigins` must be\nset to one or more specific domain (but not the special value `\"*\"`) or alternatively\nthe `allowOriginPatterns` property may be used to match to a dynamic set of origins.\n\n`maxAge` is set to 30 minutes.\n\nYou can enable CORS in the Spring MVC configuration as the following example shows:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\n[[mvc-cors-filter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc", "title": "webmvc-cors", "heading": "Global Configuration", "heading_level": 2, "file_order": 442, "section_index": 5, "content_hash": "3e10c5ee6da803a47adc2f7e36bf4e34bf0d54a1ddb86036c894a53328d92338", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc"}}
{"id": "sha256:01eb3dcbba709c3c2104660ef7af6faa01f7e0fef6ca636b1e78b24bd0764031", "content": "[.small]#xref:web/webflux-cors.adoc#webflux-cors-webfilter[See equivalent in the Reactive stack]#\n\nYou can apply CORS support through the built-in\n{spring-framework-api}/web/filter/CorsFilter.html[`CorsFilter`].\n\nNOTE: If you try to use the `CorsFilter` with Spring Security, keep in mind that Spring\nSecurity has {docs-spring-security}/servlet/integrations/cors.html[built-in support] for\nCORS.\n\nTo configure the filter, pass a `CorsConfigurationSource` to its constructor, as the\nfollowing example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim\"]\n----\n\tCorsConfiguration config = new CorsConfiguration();\n\n\t// Possibly...\n\t// config.applyPermitDefaultValues()\n\n\tconfig.setAllowCredentials(true);\n\tconfig.addAllowedOrigin(\"https://domain1.com\");\n\tconfig.addAllowedHeader(\"*\");\n\tconfig.addAllowedMethod(\"*\");\n\n\tUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n\tsource.registerCorsConfiguration(\"/**\", config);\n\n\tCorsFilter filter = new CorsFilter(source);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim\"]\n----\n\tval config = CorsConfiguration()\n\n\t// Possibly...\n\t// config.applyPermitDefaultValues()\n\n\tconfig.allowCredentials = true\n\tconfig.addAllowedOrigin(\"https://domain1.com\")\n\tconfig.addAllowedHeader(\"*\")\n\tconfig.addAllowedMethod(\"*\")\n\n\tval source = UrlBasedCorsConfigurationSource()\n\tsource.registerCorsConfiguration(\"/**\", config)\n\n\tval filter = CorsFilter(source)\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc", "title": "webmvc-cors", "heading": "CORS Filter", "heading_level": 2, "file_order": 442, "section_index": 6, "content_hash": "01eb3dcbba709c3c2104660ef7af6faa01f7e0fef6ca636b1e78b24bd0764031", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-cors.adoc"}}
{"id": "sha256:d922281bd3eb625263ef86dfbb5c8434516958891acf321558d328b1650743c8", "content": "[[webmvc-fn]]\n\n[.small]#xref:web/webflux-functional.adoc[See equivalent in the Reactive stack]#\n\nSpring Web MVC includes WebMvc.fn, a lightweight functional programming model in which functions\nare used to route and handle requests and contracts are designed for immutability.\nIt is an alternative to the annotation-based programming model but otherwise runs on\nthe same xref:web/webmvc/mvc-servlet.adoc[DispatcherServlet].\n\n[[webmvc-fn-overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "webmvc-functional", "heading_level": 1, "file_order": 443, "section_index": 0, "content_hash": "d922281bd3eb625263ef86dfbb5c8434516958891acf321558d328b1650743c8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:6c868da1f221e4c14e98b0a340be760d2f01b8135e15e6baf636284fd010f8c8", "content": "[.small]#xref:web/webflux-functional.adoc#webflux-fn-overview[See equivalent in the Reactive stack]#\n\nIn WebMvc.fn, an HTTP request is handled with a `HandlerFunction`: a function that takes\n`ServerRequest` and returns a `ServerResponse`.\nBoth the request and the response object have immutable contracts that offer convenient\naccess to the HTTP request and response.\n`HandlerFunction` is the equivalent of the body of a `@RequestMapping` method in the\nannotation-based programming model.\n\nIncoming requests are routed to a handler function with a `RouterFunction`: a function that\ntakes `ServerRequest` and returns an optional `HandlerFunction` (i.e. `Optional<HandlerFunction>`).\nWhen the router function matches, a handler function is returned; otherwise an empty Optional.\n`RouterFunction` is the equivalent of a `@RequestMapping` annotation, but with the major\ndifference that router functions provide not just data, but also behavior.\n\n`RouterFunctions.route()` provides a router builder that facilitates the creation of routers,\nas the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport static org.springframework.http.MediaType.APPLICATION_JSON;\n\timport static org.springframework.web.servlet.function.RequestPredicates.*;\n\timport static org.springframework.web.servlet.function.RouterFunctions.route;\n\n\tPersonRepository repository = ...\n\tPersonHandler handler = new PersonHandler(repository);\n\n\tRouterFunction<ServerResponse> route = route() // <1>\n .GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson)\n .GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople)\n .POST(\"/person\", handler::createPerson)\n .build();\n\n\tpublic class PersonHandler {\n\n // ...\n\n public ServerResponse listPeople(ServerRequest request) {\n // ...\n }\n\n public ServerResponse createPerson(ServerRequest request) {\n // ...\n }\n\n public ServerResponse getPerson(ServerRequest request) {\n // ...\n }\n\t}\n----\n<1> Create router using `route()`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.web.servlet.function.router\n\n\tval repository: PersonRepository = ...\n\tval handler = PersonHandler(repository)\n\n\tval route = router { // <1>\n accept(APPLICATION_JSON).nest {\n GET(\"/person/{id}\", handler::getPerson)\n GET(\"/person\", handler::listPeople)\n }\n POST(\"/person\", handler::createPerson)\n\t}\n\n\tclass PersonHandler(private val repository: PersonRepository) {\n\n // ...\n\n fun listPeople(request: ServerRequest): ServerResponse {\n // ...\n }\n\n fun createPerson(request: ServerRequest): ServerResponse {\n // ...\n }\n\n fun getPerson(request: ServerRequest): ServerResponse {\n // ...\n }\n\t}\n----\n<1> Create router using the router DSL.\n======\n\nIf you register the `RouterFunction` as a bean, for instance by exposing it in a\n`@Configuration` class, it will be auto-detected by the servlet, as explained in\nxref:web/webmvc-functional.adoc#webmvc-fn-running[Running a Server].\n\n[[webmvc-fn-handler-functions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "Overview", "heading_level": 2, "file_order": 443, "section_index": 1, "content_hash": "6c868da1f221e4c14e98b0a340be760d2f01b8135e15e6baf636284fd010f8c8", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:4f5b1fdf1e9e19a9e0fe5363888acaf9815ea4c7f781b29329d7dce7b37de6e5", "content": "[.small]#xref:web/webflux-functional.adoc#webflux-fn-handler-functions[See equivalent in the Reactive stack]#\n\n`ServerRequest` and `ServerResponse` are immutable interfaces that offer convenient\naccess to the HTTP request and response, including headers, body, method, and status code.\n\n[[webmvc-fn-request]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "HandlerFunction", "heading_level": 2, "file_order": 443, "section_index": 2, "content_hash": "4f5b1fdf1e9e19a9e0fe5363888acaf9815ea4c7f781b29329d7dce7b37de6e5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:7e3ac75813fbdbf38f79e0f15aeb1e1c38b2cbd1f74fc9d0c4e08efb33918a36", "content": "`ServerRequest` provides access to the HTTP method, URI, headers, and query parameters,\nwhile access to the body is provided through the `body` methods.\n\nThe following example extracts the request body to a `String`:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nString string = request.body(String.class);\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nval string = request.body<String>()\n----\n======\n\nThe following example extracts the body to a `List<Person>`,\nwhere `Person` objects are decoded from a serialized form, such as JSON or XML:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nList<Person> people = request.body(new ParameterizedTypeReference<List<Person>>() {});\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nval people = request.body<Person>()\n----\n======\n\nThe following example shows how to access parameters:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nMultiValueMap<String, String> params = request.params();\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nval map = request.params()\n----\n======\n\nThe following shows how to bind request parameters, URI variables, or headers via `DataBinder`,\nand also shows how to customize the `DataBinder`:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nPet pet = request.bind(Pet.class, dataBinder -> dataBinder.setAllowedFields(\"name\"));\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nval pet = request.bind(Pet::class.java, {dataBinder -> dataBinder.setAllowedFields(\"name\")})\n----\n======\n\n[[webmvc-fn-response]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "ServerRequest", "heading_level": 3, "file_order": 443, "section_index": 3, "content_hash": "7e3ac75813fbdbf38f79e0f15aeb1e1c38b2cbd1f74fc9d0c4e08efb33918a36", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:378d80a2756352613cc54389bfece7da05b1bef3721b4db79e69bb4b7cfa3d4b", "content": "`ServerResponse` provides access to the HTTP response and, since it is immutable, you can use\na `build` method to create it. You can use the builder to set the response status, to add response\nheaders, or to provide a body. The following example creates a 200 (OK) response with JSON\ncontent:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nPerson person = ...\nServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nval person: Person = ...\nServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person)\n----\n======\n\nThe following example shows how to build a 201 (CREATED) response with a `Location` header and no body:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nURI location = ...\nServerResponse.created(location).build();\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nval location: URI = ...\nServerResponse.created(location).build()\n----\n======\n\nYou can also use an asynchronous result as the body, in the form of a `CompletableFuture`,\n`Publisher`, or any other type supported by the `ReactiveAdapterRegistry`. For instance:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nMono<Person> person = webClient.get().retrieve().bodyToMono(Person.class);\nServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person);\n----\n\nKotlin::\n+\n[source,kotlin]\n----\nval person = webClient.get().retrieve().awaitBody<Person>()\nServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person)\n----\n======\n\nIf not just the body, but also the status or headers are based on an asynchronous type,\nyou can use the static `async` method on `ServerResponse`, which\naccepts `CompletableFuture<ServerResponse>`, `Publisher<ServerResponse>`, or\nany other asynchronous type supported by the `ReactiveAdapterRegistry`. For instance:\n\n[tabs]\n======\nJava::\n+\n[source,java]\n----\nMono<ServerResponse> asyncResponse = webClient.get().retrieve().bodyToMono(Person.class)\n .map(p -> ServerResponse.ok().header(\"Name\", p.name()).body(p));\nServerResponse.async(asyncResponse);\n----\n======\n\nhttps://html.spec.whatwg.org/multipage/server-sent-events.html[Server-Sent Events] can be provided via the\nstatic `sse` method on `ServerResponse`. The builder provided by that method\nallows you to send Strings, or other objects as JSON. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic RouterFunction<ServerResponse> sse() {\n return route(GET(\"/sse\"), request -> ServerResponse.sse(sseBuilder -> {\n // Save the sseBuilder object somewhere..\n }));\n\t}\n\n\t// In some other thread, sending a String\n\tsseBuilder.send(\"Hello world\");\n\n\t// Or an object, which will be transformed into JSON\n\tPerson person = ...\n\tsseBuilder.send(person);\n\n\t// Customize the event by using the other methods\n\tsseBuilder.id(\"42\")\n .event(\"sse event\")\n .data(person);\n\n\t// and done at some point\n\tsseBuilder.complete();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tfun sse(): RouterFunction<ServerResponse> = router {\n GET(\"/sse\") { request -> ServerResponse.sse { sseBuilder ->\n // Save the sseBuilder object somewhere..\n }\n\t}\n\n\t// In some other thread, sending a String\n\tsseBuilder.send(\"Hello world\")\n\n\t// Or an object, which will be transformed into JSON\n\tval person = ...\n\tsseBuilder.send(person)\n\n\t// Customize the event by using the other methods\n\tsseBuilder.id(\"42\")\n .event(\"sse event\")\n .data(person)\n\n\t// and done at some point\n\tsseBuilder.complete()\n----\n======\n\n[[webmvc-fn-handler-classes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "ServerResponse", "heading_level": 3, "file_order": 443, "section_index": 4, "content_hash": "378d80a2756352613cc54389bfece7da05b1bef3721b4db79e69bb4b7cfa3d4b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:b80d3968fde362ff6b492006229b5216fac7d9ffd7d290d53a2b1407dff87892", "content": "We can write a handler function as a lambda, as the following example shows:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\nHandlerFunction<ServerResponse> helloWorld =\n request -> ServerResponse.ok().body(\"Hello World\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\nval helloWorld: (ServerRequest) -> ServerResponse =\n { ServerResponse.ok().body(\"Hello World\") }\n----\n======\n--\n\nThat is convenient, but in an application we need multiple functions, and multiple inline\nlambda's can get messy.\nTherefore, it is useful to group related handler functions together into a handler class, which\nhas a similar role as `@Controller` in an annotation-based application.\nFor example, the following class exposes a reactive `Person` repository:\n\n--\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\nimport static org.springframework.http.MediaType.APPLICATION_JSON;\nimport static org.springframework.web.reactive.function.server.ServerResponse.ok;\n\npublic class PersonHandler {\n\n\tprivate final PersonRepository repository;\n\n\tpublic PersonHandler(PersonRepository repository) {\n this.repository = repository;\n\t}\n\n\tpublic ServerResponse listPeople(ServerRequest request) { // <1>\n List<Person> people = repository.allPeople();\n return ok().contentType(APPLICATION_JSON).body(people);\n\t}\n\n\tpublic ServerResponse createPerson(ServerRequest request) throws Exception { // <2>\n Person person = request.body(Person.class);\n repository.savePerson(person);\n return ok().build();\n\t}\n\n\tpublic ServerResponse getPerson(ServerRequest request) { // <3>\n int personId = Integer.parseInt(request.pathVariable(\"id\"));\n Person person = repository.getPerson(personId);\n if (person != null) {\n return ok().contentType(APPLICATION_JSON).body(person);\n }\n else {\n return ServerResponse.notFound().build();\n }\n\t}\n\n}\n----\n<1> `listPeople` is a handler function that returns all `Person` objects found in the repository as\nJSON.\n<2> `createPerson` is a handler function that stores a new `Person` contained in the request body.\n<3> `getPerson` is a handler function that returns a single person, identified by the `id` path\nvariable. We retrieve that `Person` from the repository and create a JSON response, if it is\nfound. If it is not found, we return a 404 Not Found response.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass PersonHandler(private val repository: PersonRepository) {\n\n fun listPeople(request: ServerRequest): ServerResponse { // <1>\n val people: List<Person> = repository.allPeople()\n return ok().contentType(APPLICATION_JSON).body(people);\n }\n\n fun createPerson(request: ServerRequest): ServerResponse { // <2>\n val person = request.body<Person>()\n repository.savePerson(person)\n return ok().build()\n }\n\n fun getPerson(request: ServerRequest): ServerResponse { // <3>\n val personId = request.pathVariable(\"id\").toInt()\n return repository.getPerson(personId)?.let { ok().contentType(APPLICATION_JSON).body(it) }\n ?: ServerResponse.notFound().build()\n\n }\n\t}\n----\n<1> `listPeople` is a handler function that returns all `Person` objects found in the repository as\nJSON.\n<2> `createPerson` is a handler function that stores a new `Person` contained in the request body.\n<3> `getPerson` is a handler function that returns a single person, identified by the `id` path\nvariable. We retrieve that `Person` from the repository and create a JSON response, if it is\nfound. If it is not found, we return a 404 Not Found response.\n======\n--\n\n[[webmvc-fn-handler-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "Handler Classes", "heading_level": 3, "file_order": 443, "section_index": 5, "content_hash": "b80d3968fde362ff6b492006229b5216fac7d9ffd7d290d53a2b1407dff87892", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:20105ea8eb1ca6ee9d7190cbe9ffd9005dbb05e404d82f08a2a83bd1ce602ed4", "content": "A functional endpoint can use Spring's xref:web/webmvc/mvc-config/validation.adoc[validation facilities] to\napply validation to the request body. For example, given a custom Spring\nxref:web/webmvc/mvc-config/validation.adoc[Validator] implementation for a `Person`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic class PersonHandler {\n\n private final Validator validator = new PersonValidator(); // <1>\n\n // ...\n\n public ServerResponse createPerson(ServerRequest request) {\n Person person = request.body(Person.class);\n validate(person); // <2>\n repository.savePerson(person);\n return ok().build();\n }\n\n private void validate(Person person) {\n Errors errors = new BeanPropertyBindingResult(person, \"person\");\n validator.validate(person, errors);\n if (errors.hasErrors()) {\n throw new ServerWebInputException(errors.toString()); // <3>\n }\n }\n\t}\n----\n<1> Create `Validator` instance.\n<2> Apply validation.\n<3> Raise exception for a 400 response.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tclass PersonHandler(private val repository: PersonRepository) {\n\n private val validator = PersonValidator() // <1>\n\n // ...\n\n fun createPerson(request: ServerRequest): ServerResponse {\n val person = request.body<Person>()\n validate(person) // <2>\n repository.savePerson(person)\n return ok().build()\n }\n\n private fun validate(person: Person) {\n val errors: Errors = BeanPropertyBindingResult(person, \"person\")\n validator.validate(person, errors)\n if (errors.hasErrors()) {\n throw ServerWebInputException(errors.toString()) // <3>\n }\n }\n\t}\n----\n<1> Create `Validator` instance.\n<2> Apply validation.\n<3> Raise exception for a 400 response.\n======\n\nHandlers can also use the standard bean validation API (JSR-303) by creating and injecting\na global `Validator` instance based on `LocalValidatorFactoryBean`.\nSee xref:core/validation/beanvalidation.adoc[Spring Validation].\n\n[[webmvc-fn-router-functions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "Validation", "heading_level": 3, "file_order": 443, "section_index": 6, "content_hash": "20105ea8eb1ca6ee9d7190cbe9ffd9005dbb05e404d82f08a2a83bd1ce602ed4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:2efd9744f3be5cee9297e01f334245e00fa93b2df7d2a7d2ab345b16d66a9be7", "content": "[.small]#xref:web/webflux-functional.adoc#webflux-fn-router-functions[See equivalent in the Reactive stack]#\n\nRouter functions are used to route the requests to the corresponding `HandlerFunction`.\nTypically, you do not write router functions yourself, but rather use a method on the\n`RouterFunctions` utility class to create one.\n`RouterFunctions.route()` (no parameters) provides you with a fluent builder for creating a router\nfunction, whereas `RouterFunctions.route(RequestPredicate, HandlerFunction)` offers a direct way\nto create a router.\n\nGenerally, it is recommended to use the `route()` builder, as it provides\nconvenient short-cuts for typical mapping scenarios without requiring hard-to-discover\nstatic imports.\nFor instance, the router function builder offers the method `GET(String, HandlerFunction)`\nto create a mapping for GET requests; and `POST(String, HandlerFunction)` for POSTs.\n\nBesides HTTP method-based mapping, the route builder offers a way to introduce additional\npredicates when mapping to requests.\nFor each HTTP method there is an overloaded variant that takes a `RequestPredicate` as a\nparameter, through which additional constraints can be expressed.\n\n[[webmvc-fn-predicates]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "`RouterFunction`", "heading_level": 2, "file_order": 443, "section_index": 7, "content_hash": "2efd9744f3be5cee9297e01f334245e00fa93b2df7d2a7d2ab345b16d66a9be7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:10240e62e823a8735d1932b66e704f615646c03e511b9aa167c31ba1ba41e841", "content": "You can write your own `RequestPredicate`, but the `RequestPredicates` utility class\noffers built-in options for common needs for matching based on the HTTP method, request\npath, headers, xref:#api-version[API version], and more.\n\nThe following example uses an `Accept` header, request predicate:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRouterFunction<ServerResponse> route = RouterFunctions.route()\n .GET(\"/hello-world\", accept(MediaType.TEXT_PLAIN),\n request -> ServerResponse.ok().body(\"Hello World\")).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.web.servlet.function.router\n\n\tval route = router {\n GET(\"/hello-world\", accept(TEXT_PLAIN)) {\n ServerResponse.ok().body(\"Hello World\")\n }\n\t}\n----\n======\n\nYou can compose multiple request predicates together by using:\n\n* `RequestPredicate.and(RequestPredicate)` -- both must match.\n* `RequestPredicate.or(RequestPredicate)` -- either can match.\n\nMany of the predicates from `RequestPredicates` are composed.\nFor example, `RequestPredicates.GET(String)` is composed from `RequestPredicates.method(HttpMethod)`\nand `RequestPredicates.path(String)`.\nThe example shown above also uses two request predicates, as the builder uses\n`RequestPredicates.GET` internally, and composes that with the `accept` predicate.\n\n[[webmvc-fn-routes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "Predicates", "heading_level": 3, "file_order": 443, "section_index": 8, "content_hash": "10240e62e823a8735d1932b66e704f615646c03e511b9aa167c31ba1ba41e841", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:8fa8fe49a480b4e1062baca6e7e7750ef5025bc84cc9789e50f110f2bd6f1d18", "content": "Router functions are evaluated in order: if the first route does not match, the\nsecond is evaluated, and so on.\nTherefore, it makes sense to declare more specific routes before general ones.\nThis is also important when registering router functions as Spring beans, as will\nbe described later.\nNote that this behavior is different from the annotation-based programming model, where the\n\"most specific\" controller method is picked automatically.\n\nWhen using the router function builder, all defined routes are composed into one\n`RouterFunction` that is returned from `build()`.\nThere are also other ways to compose multiple router functions together:\n\n* `add(RouterFunction)` on the `RouterFunctions.route()` builder\n* `RouterFunction.and(RouterFunction)`\n* `RouterFunction.andRoute(RequestPredicate, HandlerFunction)` -- shortcut for\n`RouterFunction.and()` with nested `RouterFunctions.route()`.\n\nThe following example shows the composition of four routes:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport static org.springframework.http.MediaType.APPLICATION_JSON;\n\timport static org.springframework.web.servlet.function.RequestPredicates.*;\n\n\tPersonRepository repository = ...\n\tPersonHandler handler = new PersonHandler(repository);\n\n\tRouterFunction<ServerResponse> otherRoute = ...\n\n\tRouterFunction<ServerResponse> route = route()\n .GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson) // <1>\n .GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople) // <2>\n .POST(\"/person\", handler::createPerson) // <3>\n .add(otherRoute) // <4>\n .build();\n----\n<1> pass:q[`GET /person/{id}`] with an `Accept` header that matches JSON is routed to\n`PersonHandler.getPerson`\n<2> `GET /person` with an `Accept` header that matches JSON is routed to\n`PersonHandler.listPeople`\n<3> `POST /person` with no additional predicates is mapped to\n`PersonHandler.createPerson`, and\n<4> `otherRoute` is a router function that is created elsewhere, and added to the route built.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.http.MediaType.APPLICATION_JSON\n\timport org.springframework.web.servlet.function.router\n\n\tval repository: PersonRepository = ...\n\tval handler = PersonHandler(repository);\n\n\tval otherRoute = router { }\n\n\tval route = router {\n GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson) // <1>\n GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople) // <2>\n POST(\"/person\", handler::createPerson) // <3>\n\t}.and(otherRoute) // <4>\n----\n<1> pass:q[`GET /person/{id}`] with an `Accept` header that matches JSON is routed to\n`PersonHandler.getPerson`\n<2> `GET /person` with an `Accept` header that matches JSON is routed to\n`PersonHandler.listPeople`\n<3> `POST /person` with no additional predicates is mapped to\n`PersonHandler.createPerson`, and\n<4> `otherRoute` is a router function that is created elsewhere, and added to the route built.\n======\n\n[[nested-routes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "Routes", "heading_level": 3, "file_order": 443, "section_index": 9, "content_hash": "8fa8fe49a480b4e1062baca6e7e7750ef5025bc84cc9789e50f110f2bd6f1d18", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:3c4376587a172a1f6ef6168993d621da4e316c12f81fe624eac3b5a1e1546569", "content": "It is common for a group of router functions to have a shared predicate, for instance a shared\npath.\nIn the example above, the shared predicate would be a path predicate that matches `/person`,\nused by three of the routes.\nWhen using annotations, you would remove this duplication by using a type-level `@RequestMapping`\n annotation that maps to `/person`.\nIn WebMvc.fn, path predicates can be shared through the `path` method on the router function builder.\nFor instance, the last few lines of the example above can be improved in the following way by using nested routes:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\nRouterFunction<ServerResponse> route = route()\n\t.path(\"/person\", builder -> builder // <1>\n .GET(\"/{id}\", accept(APPLICATION_JSON), handler::getPerson)\n .GET(accept(APPLICATION_JSON), handler::listPeople)\n .POST(handler::createPerson))\n\t.build();\n----\n<1> Note that second parameter of `path` is a consumer that takes the router builder.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.web.servlet.function.router\n\n\tval route = router {\n \"/person\".nest { // <1>\n GET(\"/{id}\", accept(APPLICATION_JSON), handler::getPerson)\n GET(accept(APPLICATION_JSON), handler::listPeople)\n POST(handler::createPerson)\n }\n\t}\n----\n<1> Using `nest` DSL.\n======\n\nThough path-based nesting is the most common, you can nest on any kind of predicate by using\nthe `nest` method on the builder.\nThe above still contains some duplication in the form of the shared `Accept`-header predicate.\nWe can further improve by using the `nest` method together with `accept`:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRouterFunction<ServerResponse> route = route()\n .path(\"/person\", b1 -> b1\n .nest(accept(APPLICATION_JSON), b2 -> b2\n .GET(\"/{id}\", handler::getPerson)\n .GET(handler::listPeople))\n .POST(handler::createPerson))\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.web.servlet.function.router\n\n\tval route = router {\n \"/person\".nest {\n accept(APPLICATION_JSON).nest {\n GET(\"/{id}\", handler::getPerson)\n GET(\"\", handler::listPeople)\n POST(handler::createPerson)\n }\n }\n\t}\n----\n======\n\n[[api-version]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "Nested Routes", "heading_level": 3, "file_order": 443, "section_index": 10, "content_hash": "3c4376587a172a1f6ef6168993d621da4e316c12f81fe624eac3b5a1e1546569", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:a47a22cd2b34bd7596614dde0eb88b494ca52d75866606190f217506ca40cbc0", "content": "Router functions support matching by API version.\n\nFirst, enable API versioning in the\nxref:web/webmvc/mvc-config/api-version.adoc[MVC Config], and then you can use the\n`version` xref:#webmvc-fn-predicates[predicate] as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRouterFunction<ServerResponse> route = RouterFunctions.route()\n .GET(\"/hello-world\", version(\"1.2\"),\n request -> ServerResponse.ok().body(\"Hello World\")).build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval route = router {\n GET(\"/hello-world\", version(\"1.2\")) {\n ServerResponse.ok().body(\"Hello World\")\n }\n\t}\n----\n======\n\nThe `version` predicate can be:\n\n- Fixed version (\"1.2\") -- matches the given version only\n- Baseline version (\"1.2+\") -- matches the given version and above, up to the highest\nxref:web/webmvc/mvc-config/api-version.adoc[supported version].\n\nSee xref:web/webmvc-versioning.adoc[API Versioning] for more details on underlying\ninfrastructure and support for API Versioning.\n\n[[webmvc-fn-serving-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "API Version", "heading_level": 3, "file_order": 443, "section_index": 11, "content_hash": "a47a22cd2b34bd7596614dde0eb88b494ca52d75866606190f217506ca40cbc0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:1bb01b240cdf849fe5083efd0dc3e92aec5a8966c987f234633c5d89cb00ef22", "content": "WebMvc.fn provides built-in support for serving resources.\n\nNOTE: In addition to the capabilities described below, it is possible to implement even more flexible resource handling thanks to\n{spring-framework-api}++/web/servlet/function/RouterFunctions.html#resources(java.util.function.Function)++[`RouterFunctions#resource(java.util.function.Function)`].\n\n[[webmvc-fn-resource]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "Serving Resources", "heading_level": 2, "file_order": 443, "section_index": 12, "content_hash": "1bb01b240cdf849fe5083efd0dc3e92aec5a8966c987f234633c5d89cb00ef22", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:20badbe5276529e0156144d6614785de6b352015b5823c545e97d82f1cd96eb3", "content": "It is possible to redirect requests matching a specified predicate to a resource. This can be useful, for example,\nfor handling redirects in Single Page Applications.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tClassPathResource index = new ClassPathResource(\"static/index.html\");\n\tRequestPredicate spaPredicate = path(\"/api/**\").or(path(\"/error\")).negate();\n\tRouterFunction<ServerResponse> redirectToIndex = route()\n .resource(spaPredicate, index)\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval redirectToIndex = router {\n val index = ClassPathResource(\"static/index.html\")\n val spaPredicate = !(path(\"/api/**\") or path(\"/error\"))\n resource(spaPredicate, index)\n\t}\n----\n======\n\n[[webmvc-fn-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "Redirecting to a resource", "heading_level": 3, "file_order": 443, "section_index": 13, "content_hash": "20badbe5276529e0156144d6614785de6b352015b5823c545e97d82f1cd96eb3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:962503cccd44139f08d5b8035dde51f69107f084f1c791a029001dd7f2a61187", "content": "It is also possible to route requests that match a given pattern to resources relative to a given root location.\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tResource location = new FileUrlResource(\"public-resources/\");\n\tRouterFunction<ServerResponse> resources = RouterFunctions.resources(\"/resources/**\", location);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval location = FileUrlResource(\"public-resources/\")\n\tval resources = router { resources(\"/resources/**\", location) }\n----\n======\n\n[[webmvc-fn-running]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "Serving resources from a root location", "heading_level": 3, "file_order": 443, "section_index": 14, "content_hash": "962503cccd44139f08d5b8035dde51f69107f084f1c791a029001dd7f2a61187", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:a5bea8b16dab4cb577766001359b6edf021ea36644e4d413809ac7bfcecfc836", "content": "[.small]#xref:web/webflux-functional.adoc#webflux-fn-running[See equivalent in the Reactive stack]#\n\nYou typically run router functions in a xref:web/webmvc/mvc-servlet.adoc[`DispatcherHandler`]-based setup through the\nxref:web/webmvc/mvc-config.adoc[MVC Config], which uses Spring configuration to declare the\ncomponents required to process requests. The MVC Java configuration declares the following\ninfrastructure components to support functional endpoints:\n\n* `RouterFunctionMapping`: Detects one or more `RouterFunction<?>` beans in the Spring\nconfiguration, xref:core/beans/annotation-config/autowired.adoc#beans-factory-ordered[orders them], combines them through\n`RouterFunction.andOther`, and routes requests to the resulting composed `RouterFunction`.\n* `HandlerFunctionAdapter`: Simple adapter that lets `DispatcherHandler` invoke\na `HandlerFunction` that was mapped to a request.\n\nThe preceding components let functional endpoints fit within the `DispatcherServlet` request\nprocessing lifecycle and also (potentially) run side by side with annotated controllers, if\nany are declared. It is also how functional endpoints are enabled by the Spring Boot Web\nstarter.\n\nThe following example shows a related Spring MVC configuration:\n\ninclude-code::./WebConfiguration[tag=snippet,indent=0]\n\n[[webmvc-fn-handler-filter-function]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "Running a Server", "heading_level": 2, "file_order": 443, "section_index": 15, "content_hash": "a5bea8b16dab4cb577766001359b6edf021ea36644e4d413809ac7bfcecfc836", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:105d8a480782c87ba69588346fd16d1e41161107dd4c47c7cb076bbe8cea7a0e", "content": "[.small]#xref:web/webflux-functional.adoc#webflux-fn-handler-filter-function[See equivalent in the Reactive stack]#\n\nYou can filter handler functions by using the `before`, `after`, or `filter` methods on the routing\nfunction builder.\nWith annotations, you can achieve similar functionality by using `@ControllerAdvice`, a `ServletFilter`, or both.\nThe filter will apply to all routes that are built by the builder.\nThis means that filters defined in nested routes do not apply to \"top-level\" routes.\nFor instance, consider the following example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRouterFunction<ServerResponse> route = route()\n .path(\"/person\", b1 -> b1\n .nest(accept(APPLICATION_JSON), b2 -> b2\n .GET(\"/{id}\", handler::getPerson)\n .GET(handler::listPeople)\n .before(request -> ServerRequest.from(request) // <1>\n .header(\"X-RequestHeader\", \"Value\")\n .build()))\n .POST(handler::createPerson))\n .after((request, response) -> logResponse(response)) // <2>\n .build();\n----\n<1> The `before` filter that adds a custom request header is only applied to the two GET routes.\n<2> The `after` filter that logs the response is applied to all routes, including the nested ones.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.web.servlet.function.router\n\n\tval route = router {\n \"/person\".nest {\n GET(\"/{id}\", handler::getPerson)\n GET(handler::listPeople)\n before { // <1>\n ServerRequest.from(it)\n .header(\"X-RequestHeader\", \"Value\").build()\n }\n }\n POST(handler::createPerson)\n after { _, response -> // <2>\n logResponse(response)\n }\n\t}\n----\n<1> The `before` filter that adds a custom request header is only applied to the two GET routes.\n<2> The `after` filter that logs the response is applied to all routes, including the nested ones.\n======\n\nThe `filter` method on the router builder takes a `HandlerFilterFunction`: a\nfunction that takes a `ServerRequest` and `HandlerFunction` and returns a `ServerResponse`.\nThe handler function parameter represents the next element in the chain.\nThis is typically the handler that is routed to, but it can also be another\nfilter if multiple are applied.\n\nNow we can add a simple security filter to our route, assuming that we have a `SecurityManager` that\ncan determine whether a particular path is allowed.\nThe following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tSecurityManager securityManager = ...\n\n\tRouterFunction<ServerResponse> route = route()\n .path(\"/person\", b1 -> b1\n .nest(accept(APPLICATION_JSON), b2 -> b2\n .GET(\"/{id}\", handler::getPerson)\n .GET(handler::listPeople))\n .POST(handler::createPerson))\n .filter((request, next) -> {\n if (securityManager.allowAccessTo(request.path())) {\n return next.handle(request);\n }\n else {\n return ServerResponse.status(UNAUTHORIZED).build();\n }\n })\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.web.servlet.function.router\n\n\tval securityManager: SecurityManager = ...\n\n\tval route = router {\n (\"/person\" and accept(APPLICATION_JSON)).nest {\n GET(\"/{id}\", handler::getPerson)\n GET(\"\", handler::listPeople)\n POST(handler::createPerson)\n filter { request, next ->\n if (securityManager.allowAccessTo(request.path())) {\n next(request)\n }\n else {\n status(UNAUTHORIZED).build();\n }\n }\n }\n\t}\n----\n======\n\nThe preceding example demonstrates that invoking the `next.handle(ServerRequest)` is optional.\nWe only let the handler function be run when access is allowed.\n\nBesides using the `filter` method on the router function builder, it is possible to apply a\nfilter to an existing router function via `RouterFunction.filter(HandlerFilterFunction)`.\n\nNOTE: CORS support for functional endpoints is provided through a dedicated\nxref:web/webmvc-cors.adoc#mvc-cors-filter[`CorsFilter`].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc", "title": "webmvc-functional", "heading": "Filtering Handler Functions", "heading_level": 2, "file_order": 443, "section_index": 16, "content_hash": "105d8a480782c87ba69588346fd16d1e41161107dd4c47c7cb076bbe8cea7a0e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-functional.adoc"}}
{"id": "sha256:d197b2796ba2f3a3b3e323098b398441392bc948c4f78d5717c230702d2c928d", "content": "[[test]]\n[.small]#xref:web-reactive.adoc#webflux-test[See equivalent in the Reactive stack]#\n\nThis section summarizes the options available in `spring-test` for Spring MVC applications.\n\n* Servlet API Mocks: Mock implementations of Servlet API contracts for unit testing controllers,\nfilters, and other web components. See xref:testing/unit.adoc#mock-objects-servlet[Servlet API]\nmock objects for more details.\n\n* TestContext Framework: Support for loading Spring configuration in JUnit and TestNG tests,\nincluding efficient caching of the loaded configuration across test methods and support for\nloading a `WebApplicationContext` with a `MockServletContext`.\nSee xref:testing/testcontext-framework.adoc[TestContext Framework] for more details.\n\n* Spring MVC Test: A framework, also known as `MockMvc`, for testing annotated controllers\nthrough the `DispatcherServlet` (that is, supporting annotations), complete with the\nSpring MVC infrastructure but without an HTTP server.\nSee xref:testing/mockmvc.adoc[Spring MVC Test] for more details.\n\n* Client-side REST: `spring-test` provides a `MockRestServiceServer` that you can use as\na mock server for testing client-side code that internally uses the `RestTemplate`.\nSee xref:testing/spring-mvc-test-client.adoc[Client REST Tests] for more details.\n\n* `WebTestClient`: Built for testing WebFlux applications, but it can also be used for\nend-to-end integration testing, to any server, over an HTTP connection. It is a\nnon-blocking, reactive client and is well suited for testing asynchronous and streaming\nscenarios. See xref:testing/webtestclient.adoc[`WebTestClient`] for more details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-test.adoc", "title": "webmvc-test", "heading": "webmvc-test", "heading_level": 1, "file_order": 444, "section_index": 0, "content_hash": "d197b2796ba2f3a3b3e323098b398441392bc948c4f78d5717c230702d2c928d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-test.adoc"}}
{"id": "sha256:90b36128eadf942f3672d6b39c25b72746e0dcd6cff531ea9562434a8195f8ca", "content": "[[mvc-versioning]]\n\n[.small]#xref:web/webflux-versioning.adoc[See equivalent in the Reactive stack]#\n\nSpring MVC supports API versioning. This section provides an overview of the support\nand underlying strategies.\n\nPlease, see also related content in:\n\n- Configure xref:web/webmvc/mvc-config/api-version.adoc[API versioning] in the MVC Config\n- xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-version[Map requests]\nto annotated controller methods with an API version\n- xref:web/webmvc-functional.adoc#api-version[Route requests]\nto functional endpoints with an API version\n\nClient support for API versioning is available also in `RestClient`, `WebClient`, and\nxref:integration/rest-clients.adoc#rest-http-service-client[HTTP Service] clients, as well as\nfor testing in MockMvc and `WebTestClient`.\n\n[[mvc-versioning-strategy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc", "title": "webmvc-versioning", "heading": "webmvc-versioning", "heading_level": 1, "file_order": 445, "section_index": 0, "content_hash": "90b36128eadf942f3672d6b39c25b72746e0dcd6cff531ea9562434a8195f8ca", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc"}}
{"id": "sha256:124961cb13ef2cd97ee80f7be5e23b323a94ec2a235f18d8cfe23b54bfceb899", "content": "[.small]#xref:web/webflux-versioning.adoc#webflux-versioning-strategy[See equivalent in the Reactive stack]#\n\nThis is the central strategy for API versioning that holds all configured preferences\nrelated to versioning. It does the following:\n\n- Resolves versions from the requests via xref:#mvc-versioning-resolver[ApiVersionResolver]\n- Parses raw version values into `Comparable<?>` with an xref:#mvc-versioning-parser[ApiVersionParser]\n- xref:#mvc-versioning-validation[Validates] request versions\n- Sends deprecation hints in the responses\n\n`ApiVersionStrategy` helps to map requests to `@RequestMapping` controller methods,\nand is initialized by the MVC config. Typically, applications do not interact\ndirectly with it.\n\n[[mvc-versioning-resolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc", "title": "webmvc-versioning", "heading": "ApiVersionStrategy", "heading_level": 2, "file_order": 445, "section_index": 1, "content_hash": "124961cb13ef2cd97ee80f7be5e23b323a94ec2a235f18d8cfe23b54bfceb899", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc"}}
{"id": "sha256:66bd43e5748ac88cbd23e2a8309f69243d0983c191070180a2a4f9a750ba11a3", "content": "[.small]#xref:web/webflux-versioning.adoc#webflux-versioning-resolver[See equivalent in the Reactive stack]#\n\nThis strategy resolves the API version from a request. The MVC config provides built-in\noptions to resolve from a header, query parameter, media type parameter,\nor from the URL path. You can also use a custom `ApiVersionResolver`.\n\nNOTE: The path resolver always resolves the version from the specified path segment, or\nraises `InvalidApiVersionException` otherwise, and therefore it cannot yield to other\nresolvers.\n\n[[mvc-versioning-parser]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc", "title": "webmvc-versioning", "heading": "ApiVersionResolver", "heading_level": 2, "file_order": 445, "section_index": 2, "content_hash": "66bd43e5748ac88cbd23e2a8309f69243d0983c191070180a2a4f9a750ba11a3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc"}}
{"id": "sha256:33194c9ded5a0e532d63a92e286ca34f104590787f3052db62de92f43c0f76f5", "content": "[.small]#xref:web/webflux-versioning.adoc#webflux-versioning-parser[See equivalent in the Reactive stack]#\n\nThis strategy helps to parse raw version values into `Comparable<?>`, which helps to\ncompare, sort, and select versions. By default, the built-in `SemanticApiVersionParser`\nparses a version into `major`, `minor`, and `patch` integer values. Minor and patch\nvalues are set to 0 if not present.\n\n[[mvc-versioning-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc", "title": "webmvc-versioning", "heading": "ApiVersionParser", "heading_level": 2, "file_order": 445, "section_index": 3, "content_hash": "33194c9ded5a0e532d63a92e286ca34f104590787f3052db62de92f43c0f76f5", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc"}}
{"id": "sha256:7132df2ef70e869b3b7003e30129715ce7017708bc07de775f453152abaab482", "content": "[.small]#xref:web/webflux-versioning.adoc#webflux-versioning-validation[See equivalent in the Reactive stack]#\n\nIf a request version is not supported, `InvalidApiVersionException` is raised resulting\nin a 400 response. By default, the list of supported versions is initialized from declared\nversions in annotated controller mappings, but you can turn that off through a flag in the\nMVC config, and use only the versions configured explicitly in the config.\n\nBy default, a version is required when API versioning is enabled, and\n`MissingApiVersionException` is raised resulting in a 400 response if not present.\nYou can make it optional in which case the most recent version is used.\nYou can also specify a default version to use.\n\n[[mvc-versioning-deprecation-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc", "title": "webmvc-versioning", "heading": "Validation", "heading_level": 2, "file_order": 445, "section_index": 4, "content_hash": "7132df2ef70e869b3b7003e30129715ce7017708bc07de775f453152abaab482", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc"}}
{"id": "sha256:afc1927688bfffec07427f5918ebc0cc8331f5324e0423fc500513dfde3defb0", "content": "[.small]#xref:web/webflux-versioning.adoc#webflux-versioning-deprecation-handler[See equivalent in the Reactive stack]#\n\nThis strategy can be configured to send hints and information about deprecated versions to\nclients via response headers. The built-in `StandardApiVersionDeprecationHandler`\ncan set the \"Deprecation\" \"Sunset\" headers and \"Link\" headers as defined in\nhttps://datatracker.ietf.org/doc/html/rfc9745[RFC 9745] and\nhttps://datatracker.ietf.org/doc/html/rfc8594[RFC 8594]. You can also configure a custom\nhandler for different headers.\n\n[[mvc-versioning-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc", "title": "webmvc-versioning", "heading": "ApiVersionDeprecationHandler", "heading_level": 2, "file_order": 445, "section_index": 5, "content_hash": "afc1927688bfffec07427f5918ebc0cc8331f5324e0423fc500513dfde3defb0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc"}}
{"id": "sha256:8603ec32e92b3d74d9191f07347bcc37de0dca989abf77030da0642b64a14182", "content": "[.small]#xref:web/webflux-versioning.adoc#webflux-versioning-mapping[See equivalent in the Reactive stack]#\n\n`ApiVersionStrategy` supports the mapping of requests to annotated controller methods.\nSee xref:web/webmvc/mvc-controller/ann-requestmapping.adoc#mvc-ann-requestmapping-version[API Version]\nfor more details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc", "title": "webmvc-versioning", "heading": "Request Mapping", "heading_level": 2, "file_order": 445, "section_index": 6, "content_hash": "8603ec32e92b3d74d9191f07347bcc37de0dca989abf77030da0642b64a14182", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-versioning.adoc"}}
{"id": "sha256:a64f92b854d53c84f1d40c0e8f7ffdd9d36fb1ad44f1d7975c0f560559600e7f", "content": "[[mvc-view]]\n\n[.small]#xref:web/webflux-view.adoc[See equivalent in the Reactive stack]#\n\nThe rendering of views in Spring MVC is pluggable. Whether you decide to use\nThymeleaf, Groovy Markup Templates, JSPs, or other technologies is primarily a matter of\na configuration change. This chapter covers view technologies integrated with Spring MVC.\n\nFor more context on view rendering, please see xref:web/webmvc/mvc-servlet/viewresolver.adoc[View Resolution].\n\nWARNING: The views of a Spring MVC application live within the internal trust boundaries\nof that application. Views have access to all the beans of your application context. As\nsuch, it is not recommended to use Spring MVC's template support in applications where\nthe templates are editable by external sources, since this can have security implications.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc-view.adoc", "title": "webmvc-view", "heading": "webmvc-view", "heading_level": 1, "file_order": 446, "section_index": 0, "content_hash": "a64f92b854d53c84f1d40c0e8f7ffdd9d36fb1ad44f1d7975c0f560559600e7f", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc-view.adoc"}}
{"id": "sha256:0f97531b024f36b1bcb4eb8c0bbae4751fde5ca71391e92d12cc54477edf3db1", "content": "[[mvc]]\n[[spring-web-mvc]]\n\nSpring Web MVC is the original web framework built on the Servlet API and has been included\nin the Spring Framework from the very beginning. The formal name, \"Spring Web MVC,\"\ncomes from the name of its source module\n({spring-framework-code}/spring-webmvc[`spring-webmvc`]),\nbut it is more commonly known as \"Spring MVC\".\n\nParallel to Spring Web MVC, Spring Framework 5.0 introduced a reactive-stack web framework\nwhose name, \"Spring WebFlux,\" is also based on its source module\n({spring-framework-code}/spring-webflux[`spring-webflux`]).\nThis chapter covers Spring Web MVC. For reactive-stack web applications, see\nxref:web-reactive.adoc[Web on Reactive Stack].\n\nFor baseline information and compatibility with Servlet container and Jakarta EE version\nranges, see the Spring Framework\n{spring-framework-wiki}/Spring-Framework-Versions[Wiki].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/webmvc.adoc", "title": "webmvc", "heading": "webmvc", "heading_level": 1, "file_order": 447, "section_index": 0, "content_hash": "0f97531b024f36b1bcb4eb8c0bbae4751fde5ca71391e92d12cc54477edf3db1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/webmvc.adoc"}}
{"id": "sha256:7463a9d2e2370e7d62972b57a28f1b3a44c2bdef160b484e7f2482142b595e2b", "content": "[[websocket]]\n\n[.small]#xref:web/webflux-websocket.adoc[See equivalent in the Reactive stack]#\n\nThis part of the reference documentation covers support for Servlet stack, WebSocket\nmessaging that includes raw WebSocket interactions, WebSocket emulation through SockJS, and\npublish-subscribe messaging through STOMP as a sub-protocol over WebSocket.\n\n[[introduction-to-websocket]]\n= Introduction to WebSocket\n\nThe WebSocket protocol, {rfc-site}/rfc6455[RFC 6455], provides a standardized\nway to establish a full-duplex, two-way communication channel between client and server\nover a single TCP connection. It is a different TCP protocol from HTTP but is designed to\nwork over HTTP, using ports 80 and 443 and allowing re-use of existing firewall rules.\n\nA WebSocket interaction begins with an HTTP request that uses the HTTP `Upgrade` header\nto upgrade or, in this case, to switch to the WebSocket protocol. The following example\nshows such an interaction:\n\n[source,yaml,indent=0,subs=\"verbatim,quotes\"]\n----\n\tGET /spring-websocket-portfolio/portfolio HTTP/1.1\n\tHost: localhost:8080\n\tUpgrade: websocket <1>\n\tConnection: Upgrade <2>\n\tSec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==\n\tSec-WebSocket-Protocol: v10.stomp, v11.stomp\n\tSec-WebSocket-Version: 13\n\tOrigin: http://localhost:8080\n----\n<1> The `Upgrade` header.\n<2> Using the `Upgrade` connection.\n\n\nInstead of the usual 200 status code, a server with WebSocket support returns output\nsimilar to the following:\n\n[source,yaml,indent=0,subs=\"verbatim,quotes\"]\n----\n\tHTTP/1.1 101 Switching Protocols <1>\n\tUpgrade: websocket\n\tConnection: Upgrade\n\tSec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=\n\tSec-WebSocket-Protocol: v10.stomp\n----\n<1> Protocol switch\n\n\nAfter a successful handshake, the TCP socket underlying the HTTP upgrade request remains\nopen for both the client and the server to continue to send and receive messages.\n\nA complete introduction of how WebSockets work is beyond the scope of this document.\nSee RFC 6455, the WebSocket chapter of HTML5, or any of the many introductions and\ntutorials on the Web.\n\nNote that, if a WebSocket server is running behind a web server (for example, nginx), you\nlikely need to configure it to pass WebSocket upgrade requests on to the WebSocket\nserver. Likewise, if the application runs in a cloud environment, check the\ninstructions of the cloud provider related to WebSocket support.\n\n\n[[http-versus-websocket]]\n== HTTP Versus WebSocket\n\nEven though WebSocket is designed to be HTTP-compatible and starts with an HTTP request,\nit is important to understand that the two protocols lead to very different\narchitectures and application programming models.\n\nIn HTTP and REST, an application is modeled as many URLs. To interact with the application,\nclients access those URLs, request-response style. Servers route requests to the\nappropriate handler based on the HTTP URL, method, and headers.\n\nBy contrast, in WebSockets, there is usually only one URL for the initial connect.\nSubsequently, all application messages flow on that same TCP connection. This points to\nan entirely different asynchronous, event-driven, messaging architecture.\n\nWebSocket is also a low-level transport protocol, which, unlike HTTP, does not prescribe\nany semantics to the content of messages. That means that there is no way to route or process\na message unless the client and the server agree on message semantics.\n\nWebSocket clients and servers can negotiate the use of a higher-level, messaging protocol\n(for example, STOMP), through the `Sec-WebSocket-Protocol` header on the HTTP handshake request.\nIn the absence of that, they need to come up with their own conventions.\n\n\n[[when-to-use-websockets]]\n== When to Use WebSockets\n\nWebSockets can make a web page be dynamic and interactive. However, in many cases,\na combination of AJAX and HTTP streaming or long polling can provide a simple and\neffective solution.\n\nFor example, news, mail, and social feeds need to update dynamically, but it may be\nperfectly okay to do so every few minutes. Collaboration, games, and financial apps, on\nthe other hand, need to be much closer to real-time.\n\nLatency alone is not a deciding factor. If the volume of messages is relatively low (for example,\nmonitoring network failures) HTTP streaming or polling can provide an effective solution.\nIt is the combination of low latency, high frequency, and high volume that make the best\ncase for the use of WebSocket.\n\nKeep in mind also that over the Internet, restrictive proxies that are outside of your control\nmay preclude WebSocket interactions, either because they are not configured to pass on the\n`Upgrade` header or because they close long-lived connections that appear idle. This\nmeans that the use of WebSocket for internal applications within the firewall is a more\nstraightforward decision than it is for public facing applications.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web/websocket.adoc", "title": "websocket", "heading": "websocket", "heading_level": 1, "file_order": 448, "section_index": 0, "content_hash": "7463a9d2e2370e7d62972b57a28f1b3a44c2bdef160b484e7f2482142b595e2b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web/websocket.adoc"}}
{"id": "sha256:420ade15bde45ff09ba47f490d6ce8e2782f7178d5202af9adbcacd39a53ccab", "content": "[[appendix]]\n\nThis part of the reference documentation covers topics that apply to multiple modules\nwithin the core Spring Framework.\n\n[[appendix-spring-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "appendix", "heading_level": 1, "file_order": 449, "section_index": 0, "content_hash": "420ade15bde45ff09ba47f490d6ce8e2782f7178d5202af9adbcacd39a53ccab", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:4da80be0de66a4143cc92722a7897af3626e07df84994db156c8c846c6117385", "content": "{spring-framework-api}/core/SpringProperties.html[`SpringProperties`] is a static holder\nfor properties that control certain low-level aspects of the Spring Framework. Users can\nconfigure these properties via JVM system properties or programmatically via the\n`SpringProperties.setProperty(String key, String value)` method. The latter may be\nnecessary if the deployment environment disallows custom JVM system properties. As an\nalternative, these properties may be configured in a `spring.properties` file in the root\nof the classpath -- for example, deployed within the application's JAR file.\n\nThe following table lists all currently supported Spring properties.\n\n.Supported Spring Properties\n[cols=\"1,1\"]\n|===\n| Name | Description\n\n| `spring.aop.ajc.ignore`\n| Instructs Spring to ignore ajc-compiled aspects for Spring AOP proxying, restoring traditional\nSpring behavior for scenarios where both weaving and AspectJ auto-proxying are enabled. See\n{spring-framework-api}++/aop/aspectj/annotation/AbstractAspectJAdvisorFactory.html#IGNORE_AJC_PROPERTY_NAME++[`AbstractAspectJAdvisorFactory`]\nfor details.\n\n| `spring.aot.enabled`\n| Indicates the application should run with AOT generated artifacts. See\nxref:core/aot.adoc[Ahead of Time Optimizations] and\n{spring-framework-api}++/aot/AotDetector.html#AOT_ENABLED++[`AotDetector`]\nfor details.\n\n| `spring.beaninfo.ignore`\n| Instructs Spring to use the `Introspector.IGNORE_ALL_BEANINFO` mode when calling the\nJavaBeans `Introspector`. See\n{spring-framework-api}++/beans/StandardBeanInfoFactory.html#IGNORE_BEANINFO_PROPERTY_NAME++[`StandardBeanInfoFactory`]\nfor details.\n\n| `spring.cache.reactivestreams.ignore`\n| Instructs Spring's caching infrastructure to ignore the presence of Reactive Streams,\nin particular Reactor's `Mono`/`Flux` in `@Cacheable` method return type declarations. See\n{spring-framework-api}++/cache/interceptor/CacheAspectSupport.html#IGNORE_REACTIVESTREAMS_PROPERTY_NAME++[`CacheAspectSupport`]\nfor details.\n\n| `spring.classformat.ignore`\n| Instructs Spring to ignore class format exceptions during classpath scanning, in\nparticular for unsupported class file versions. See\n{spring-framework-api}++/context/annotation/ClassPathScanningCandidateComponentProvider.html#IGNORE_CLASSFORMAT_PROPERTY_NAME++[`ClassPathScanningCandidateComponentProvider`]\nfor details.\n\n| `spring.context.checkpoint`\n| Property that specifies a common context checkpoint. See\nxref:integration/checkpoint-restore.adoc#_automatic_checkpointrestore_at_startup[Automatic checkpoint/restore at startup] and\n{spring-framework-api}++/context/support/DefaultLifecycleProcessor.html#CHECKPOINT_PROPERTY_NAME++[`DefaultLifecycleProcessor`]\nfor details.\n\n| `spring.context.exit`\n| Property for terminating the JVM when the context reaches a specific phase. See\nxref:integration/checkpoint-restore.adoc#_automatic_checkpointrestore_at_startup[Automatic checkpoint/restore at startup] and\n{spring-framework-api}++/context/support/DefaultLifecycleProcessor.html#EXIT_PROPERTY_NAME++[`DefaultLifecycleProcessor`]\nfor details.\n\n| `spring.context.expression.maxLength`\n| The maximum length for\nxref:core/expressions/evaluation.adoc#expressions-parser-configuration[Spring Expression Language]\nexpressions used in XML bean definitions, `@Value`, etc.\n\n| `spring.expression.compiler.mode`\n| The mode to use when compiling expressions for the\nxref:core/expressions/evaluation.adoc#expressions-compiler-configuration[Spring Expression Language].\n\n| `spring.getenv.ignore`\n| Instructs Spring to ignore operating system environment variables if a Spring\n`Environment` property -- for example, a placeholder in a configuration String -- isn't\nresolvable otherwise. See\n{spring-framework-api}++/core/env/AbstractEnvironment.html#IGNORE_GETENV_PROPERTY_NAME++[`AbstractEnvironment`]\nfor details.\n\n| `spring.jdbc.getParameterType.ignore`\n| Instructs Spring to ignore `java.sql.ParameterMetaData.getParameterType` completely.\nSee the note in xref:data-access/jdbc/advanced.adoc#jdbc-batch-list[Batch Operations with a List of Objects].\n\n| `spring.jndi.ignore`\n| Instructs Spring to ignore a default JNDI environment, as an optimization for scenarios\nwhere nothing is ever to be found for such JNDI fallback searches to begin with, avoiding\nthe repeated JNDI lookup overhead. See\n{spring-framework-api}++/jndi/JndiLocatorDelegate.html#IGNORE_JNDI_PROPERTY_NAME++[`JndiLocatorDelegate`]\nfor details.\n\n| `spring.locking.strict`\n| Instructs Spring to enforce strict locking during bean creation, rather than the mix of\nstrict and lenient locking that 6.2 applies by default. See\n{spring-framework-api}++/beans/factory/support/DefaultListableBeanFactory.html#STRICT_LOCKING_PROPERTY_NAME++[`DefaultListableBeanFactory`]\nfor details.\n\n| `spring.objenesis.ignore`\n| Instructs Spring to ignore Objenesis, not even attempting to use it. See\n{spring-framework-api}++/objenesis/SpringObjenesis.html#IGNORE_OBJENESIS_PROPERTY_NAME++[`SpringObjenesis`]\nfor details.\n\n| `spring.placeholder.escapeCharacter.default`\n| The default escape character for property placeholder support. If not set, `'\\'` will\nbe used. Can be set to a custom escape character or an empty string to disable support\nfor an escape character. The default escape character be explicitly overridden in\n`PropertySourcesPlaceholderConfigurer` and subclasses of `AbstractPropertyResolver`. See\n{spring-framework-api}++/core/env/AbstractPropertyResolver.html#DEFAULT_PLACEHOLDER_ESCAPE_CHARACTER_PROPERTY_NAME++[`AbstractPropertyResolver`]\nfor details.\n\n| `spring.test.aot.processing.failOnError`\n| A boolean flag that controls whether errors encountered during AOT processing in the\n_Spring TestContext Framework_ should result in an exception that fails the overall process.\nSee xref:testing/testcontext-framework/aot.adoc[Ahead of Time Support for Tests].\n\n| `spring.test.constructor.autowire.mode`\n| The default _test constructor autowire mode_ to use if `@TestConstructor` is not present\non a test class. See xref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-testconstructor[Changing the default test constructor autowire mode].\n\n| `spring.test.context.cache.maxSize`\n| The maximum size of the context cache in the _Spring TestContext Framework_. See\nxref:testing/testcontext-framework/ctx-management/caching.adoc[Context Caching].\n\n| `spring.test.context.cache.pause`\n| The pause mode for the context cache in the _Spring TestContext Framework_. See\nxref:testing/testcontext-framework/ctx-management/context-pausing.adoc[Context Pausing].\n\n| `spring.test.context.failure.threshold`\n| The failure threshold for errors encountered while attempting to load an `ApplicationContext`\nin the _Spring TestContext Framework_. See\nxref:testing/testcontext-framework/ctx-management/failure-threshold.adoc[Context Failure Threshold].\n\n| `spring.test.enclosing.configuration`\n| The default _enclosing configuration inheritance mode_ to use if\n`@NestedTestConfiguration` is not present on a test class. See\nxref:testing/annotations/integration-junit-jupiter.adoc#integration-testing-annotations-nestedtestconfiguration[Changing the default enclosing configuration inheritance mode].\n\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/appendix.adoc", "title": "appendix", "heading": "Spring Properties", "heading_level": 2, "file_order": 449, "section_index": 1, "content_hash": "4da80be0de66a4143cc92722a7897af3626e07df84994db156c8c846c6117385", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/appendix.adoc"}}
{"id": "sha256:b04ec8db982837920e00769571bf89607843f9bd6e793e4e778faf0094c2e260", "content": "[[spring-core]]\n\nThis part of the reference documentation covers all the technologies that are\nabsolutely integral to the Spring Framework.\n\nForemost amongst these is the Spring Framework's Inversion of Control (IoC) container.\nA thorough treatment of the Spring Framework's IoC container is closely followed by\ncomprehensive coverage of Spring's Aspect-Oriented Programming (AOP) technologies.\nThe Spring Framework has its own AOP framework, which is conceptually easy to\nunderstand and which successfully addresses the 80% sweet spot of AOP requirements\nin Java enterprise programming.\n\nCoverage of Spring's integration with AspectJ (currently the richest -- in terms of\nfeatures -- and certainly most mature AOP implementation in the Java enterprise space)\nis also provided.\n\nAOT processing can be used to optimize your application ahead-of-time. It is typically\nused for native image deployment using GraalVM.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/core.adoc", "title": "core", "heading": "core", "heading_level": 1, "file_order": 450, "section_index": 0, "content_hash": "b04ec8db982837920e00769571bf89607843f9bd6e793e4e778faf0094c2e260", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/core.adoc"}}
{"id": "sha256:e0ab48dcc2d291b4f364a1753b9a86e8d62a53cbd9d06a4160a872e31124e567", "content": "[[spring-data-tier]]\n\nThis part of the reference documentation is concerned with data access and the\ninteraction between the data access layer and the business or service layer.\n\nSpring's comprehensive transaction management support is covered in some detail,\nfollowed by thorough coverage of the various data access frameworks and technologies\nwith which the Spring Framework integrates.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/data-access.adoc", "title": "data-access", "heading": "data-access", "heading_level": 1, "file_order": 451, "section_index": 0, "content_hash": "e0ab48dcc2d291b4f364a1753b9a86e8d62a53cbd9d06a4160a872e31124e567", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/data-access.adoc"}}
{"id": "sha256:092f786bd67ce1b4ba60d4fe6027a17ae31a9a39b113309880215ec6e18c6881", "content": "[[spring-framework-documentation]]\n\n[horizontal]\nxref:overview.adoc[Overview] :: History, Design Philosophy, Feedback,\nGetting Started.\nxref:core.adoc[Core] :: IoC Container, Events, Resources, i18n,\nValidation, Data Binding, Type Conversion, SpEL, AOP, AOT.\nxref:testing.adoc[Testing] :: Mock Objects, TestContext Framework,\nSpring MVC Test, WebTestClient.\nxref:data-access.adoc[Data Access] :: Transactions, DAO Support,\nJDBC, R2DBC, O/R Mapping, XML Marshalling.\nxref:web.adoc[Web Servlet] :: Spring MVC, WebSocket, SockJS,\nSTOMP Messaging.\nxref:web-reactive.adoc[Web Reactive] :: Spring WebFlux, WebClient,\nWebSocket, RSocket.\nxref:integration.adoc[Integration] :: REST Clients, JMS, JCA, JMX,\nEmail, Tasks, Scheduling, Caching, Observability, JVM Checkpoint Restore.\nxref:languages.adoc[Languages] :: Kotlin, Groovy, Dynamic Languages.\nxref:appendix.adoc[Appendix] :: Spring properties.\n{spring-framework-wiki}[Wiki] :: What's New,\nUpgrade Notes, Supported Versions, additional cross-version information.\n\nRod Johnson, Juergen Hoeller, Keith Donald, Colin Sampaleanu, Rob Harrop, Thomas Risberg,\nAlef Arendsen, Darren Davison, Dmitriy Kopylenko, Mark Pollack, Thierry Templier, Erwin\nVervaet, Portia Tung, Ben Hale, Adrian Colyer, John Lewis, Costin Leau, Mark Fisher, Sam\nBrannen, Ramnivas Laddad, Arjen Poutsma, Chris Beams, Tareq Abedrabbo, Andy Clement, Dave\nSyer, Oliver Gierke, Rossen Stoyanchev, Phillip Webb, Rob Winch, Brian Clozel, Stephane\nNicoll, Sebastien Deleuze, Jay Bryant, Mark Paluch\n\nCopies of this document may be made for your own use and for distribution to others,\nprovided that you do not charge any fee for such copies and further provided that each\ncopy contains the Copyright Notice, whether distributed in print or electronically.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 452, "section_index": 0, "content_hash": "092f786bd67ce1b4ba60d4fe6027a17ae31a9a39b113309880215ec6e18c6881", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:6ff93440f3ee0c0a12e082fdeca82b793f2c025ed5f97db719f8f5a3b73160ef", "content": "[[spring-integration]]\n\nThis part of the reference documentation covers Spring Framework's integration with\na number of technologies.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/integration.adoc", "title": "integration", "heading": "integration", "heading_level": 1, "file_order": 453, "section_index": 0, "content_hash": "6ff93440f3ee0c0a12e082fdeca82b793f2c025ed5f97db719f8f5a3b73160ef", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/integration.adoc"}}
{"id": "sha256:9cd9e96c775167c49ab0757cd73f27be25329268e56a84be747622b40fb822aa", "content": "[[languages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/languages.adoc", "title": "languages", "heading": "languages", "heading_level": 1, "file_order": 454, "section_index": 0, "content_hash": "9cd9e96c775167c49ab0757cd73f27be25329268e56a84be747622b40fb822aa", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/languages.adoc"}}
{"id": "sha256:f74cf64ea3c61649767a2a760f4ff6be574d294df5e2d82a88e1899c359efc79", "content": "[[overview]]\n\nSpring makes it easy to create Java enterprise applications. It provides everything you\nneed to embrace the Java language in an enterprise environment, with support for Groovy\nand Kotlin as alternative languages on the JVM, and with the flexibility to create many\nkinds of architectures depending on an application's needs. As of Spring Framework 6.0,\nSpring requires Java 17+.\n\nSpring supports a wide range of application scenarios. In a large enterprise, applications\noften exist for a long time and have to run on a JDK and application server whose upgrade\ncycle is beyond the developer's control. Others may run as a single jar with the server embedded,\npossibly in a cloud environment. Yet others may be standalone applications (such as batch\nor integration workloads) that do not need a server.\n\nSpring is open source. It has a large and active community that provides continuous feedback\nbased on a diverse range of real-world use cases. This has helped Spring to successfully\nevolve over a very long time.\n\n[[overview-spring]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "overview", "heading_level": 1, "file_order": 455, "section_index": 0, "content_hash": "f74cf64ea3c61649767a2a760f4ff6be574d294df5e2d82a88e1899c359efc79", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:0085f9cca5d40f481c91adaca7e49224a20488b51c0fc9fa66450db02403fc89", "content": "The term \"Spring\" means different things in different contexts. It can be used to refer to\nthe Spring Framework project itself, which is where it all started. Over time, other Spring\nprojects have been built on top of the Spring Framework. Most often, when people say\n\"Spring\", they mean the entire family of projects. This reference documentation focuses on\nthe foundation: the Spring Framework itself.\n\nThe Spring Framework is divided into modules. Applications can choose which modules they need.\nAt the heart are the modules of the core container, including a configuration model and a\ndependency injection mechanism. Beyond that, the Spring Framework provides foundational\nsupport for different application architectures, including messaging, transactional data and\npersistence, and web. It also includes the Servlet-based Spring MVC web framework and, in\nparallel, the Spring WebFlux reactive web framework.\n\nA note about modules: Spring Framework's jars allow for deployment to the module path (Java\nModule System). For use in module-enabled applications, the Spring Framework jars come with\n`Automatic-Module-Name` manifest entries which define stable language-level module names\n(`spring.core`, `spring.context`, etc.) independent from jar artifact names. The jars follow\nthe same naming pattern with `-` instead of `.` â€“ for example, `spring-core` and `spring-context`.\nOf course, Spring Framework's jars also work fine on the classpath.\n\n[[overview-history]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "What We Mean by \"Spring\"", "heading_level": 2, "file_order": 455, "section_index": 1, "content_hash": "0085f9cca5d40f481c91adaca7e49224a20488b51c0fc9fa66450db02403fc89", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:e5e1c4c1d372ef39db530be37255446a77ba0c726ea0db1dcca9111531b55efe", "content": "Spring came into being in 2003 as a response to the complexity of the early\nhttps://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition[J2EE] specifications.\nWhile some consider Java EE and its modern-day successor Jakarta EE to be in\ncompetition with Spring, they are in fact complementary. The Spring programming\nmodel does not embrace the Jakarta EE platform specification; rather, it integrates\nwith carefully selected individual specifications from the traditional EE umbrella:\n\n* Servlet API ({JSR}340[JSR 340])\n* WebSocket API ({JSR}356[JSR 356])\n* Concurrency Utilities ({JSR}236[JSR 236])\n* JSON Binding API ({JSR}367[JSR 367])\n* Bean Validation ({JSR}303[JSR 303])\n* JPA ({JSR}338[JSR 338])\n* JMS ({JSR}914[JSR 914])\n* as well as JTA/JCA setups for transaction coordination, if necessary.\n\nThe Spring Framework also supports the Dependency Injection\n({JSR}330[JSR 330]) and Common Annotations\n({JSR}250[JSR 250]) specifications, which application\ndevelopers may choose to use instead of the Spring-specific mechanisms provided\nby the Spring Framework. Originally, those were based on common `javax` packages.\n\nAs of Spring Framework 6.0, Spring has been upgraded to the Jakarta EE 9 level\n(for example, Servlet 5.0+, JPA 3.0+), based on the `jakarta` namespace instead of the\ntraditional `javax` packages. With EE 9 as the minimum and EE 10 supported already,\nSpring is prepared to provide out-of-the-box support for the further evolution of\nthe Jakarta EE APIs. Spring Framework 6.0 is fully compatible with Tomcat 10.1,\nJetty 11 as web servers, and also with Hibernate ORM 6.1.\n\nOver time, the role of Java/Jakarta EE in application development has evolved. In the\nearly days of J2EE and Spring, applications were created to be deployed to an application\nserver. Today, with the help of Spring Boot, applications are created in a devops- and\ncloud-friendly way, with the Servlet container embedded and trivial to change. As of\nSpring Framework 5, a WebFlux application does not even use the Servlet API directly\nand can run on servers (such as Netty) that are not Servlet containers.\n\nSpring continues to innovate and to evolve. Beyond the Spring Framework, there are other\nprojects, such as Spring Boot, Spring Security, Spring Data, Spring Cloud, Spring Batch,\namong others. Itâ€™s important to remember that each project has its own source code repository,\nissue tracker, and release cadence. See {spring-site-projects}[spring.io/projects] for\nthe complete list of Spring projects.\n\n[[overview-philosophy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "History of Spring and the Spring Framework", "heading_level": 2, "file_order": 455, "section_index": 2, "content_hash": "e5e1c4c1d372ef39db530be37255446a77ba0c726ea0db1dcca9111531b55efe", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:1e1d3c628f14c17ca2098c39b139e22bf69a428283a22145cf7d0676137ead29", "content": "When you learn about a framework, itâ€™s important to know not only what it does but what\nprinciples it follows. Here are the guiding principles of the Spring Framework:\n\n* Provide choice at every level. Spring lets you defer design decisions as late as possible.\nFor example, you can switch persistence providers through configuration without changing\nyour code. The same is true for many other infrastructure concerns and integration with\nthird-party APIs.\n* Accommodate diverse perspectives. Spring embraces flexibility and is not opinionated\nabout how things should be done. It supports a wide range of application needs with\ndifferent perspectives.\n* Maintain strong backward compatibility. Springâ€™s evolution has been carefully managed\nto force few breaking changes between versions. Spring supports a carefully chosen range\nof JDK versions and third-party libraries to facilitate maintenance of applications and\nlibraries that depend on Spring.\n* Care about API design. The Spring team puts a lot of thought and time into making APIs\nthat are intuitive and that hold up across many versions and many years.\n* Set high standards for code quality. The Spring Framework puts a strong emphasis on\nmeaningful, current, and accurate javadoc. It is one of very few projects that can claim\nclean code structure with no circular dependencies between packages.\n\n[[overview-feedback]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Design Philosophy", "heading_level": 2, "file_order": 455, "section_index": 3, "content_hash": "1e1d3c628f14c17ca2098c39b139e22bf69a428283a22145cf7d0676137ead29", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:6251a4920c0291f58b0f2ae591038269940f6eed1ef865a54319c56d60e13dbf", "content": "For how-to questions or diagnosing or debugging issues, we suggest using Stack Overflow. Click\n{stackoverflow-spring-tag}+or+spring-mvc+or+spring-aop+or+spring-jdbc+or+spring-r2dbc+or+spring-transactions+or+spring-annotations+or+spring-jms+or+spring-el+or+spring-test+or+spring+or+spring-orm+or+spring-jmx+or+spring-cache+or+spring-webflux+or+spring-rsocket?tab=Newest[here]\nfor a list of the suggested tags to use on Stack Overflow. If you're fairly certain that\nthere is a problem in the Spring Framework or would like to suggest a feature, please use\nthe {spring-framework-issues}[GitHub Issues].\n\nIf you have a solution in mind or a suggested fix, you can submit a pull request on\n{spring-framework-github}[Github]. However, please keep in mind\nthat, for all but the most trivial issues, we expect a ticket to be filed in the issue\ntracker, where discussions take place and leave a record for future reference.\n\nFor more details see the guidelines at the {spring-framework-code}/CONTRIBUTING.md[CONTRIBUTING],\ntop-level project page.\n\n[[overview-getting-started]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Feedback and Contributions", "heading_level": 2, "file_order": 455, "section_index": 4, "content_hash": "6251a4920c0291f58b0f2ae591038269940f6eed1ef865a54319c56d60e13dbf", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:10642bf15294ed0b71d24b37ebf1e05397752f0ed3b061adfb0eafdec9e58a21", "content": "If you are just getting started with Spring, you may want to begin using the Spring\nFramework by creating a {spring-site-projects}/spring-boot/[Spring Boot]-based\napplication. Spring Boot provides a quick (and opinionated) way to create a\nproduction-ready Spring-based application. It is based on the Spring Framework, favors\nconvention over configuration, and is designed to get you up and running as quickly\nas possible.\n\nYou can use https://start.spring.io/[start.spring.io] to generate a basic project or follow\none of the {spring-site-guides}[\"Getting Started\" guides], such as\n{spring-site-guides}/gs/rest-service/[Getting Started Building a RESTful Web Service].\nAs well as being easier to digest, these guides are very task focused, and most of them\nare based on Spring Boot. They also cover other projects from the Spring portfolio that\nyou might want to consider when solving a particular problem.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Getting Started", "heading_level": 2, "file_order": 455, "section_index": 5, "content_hash": "10642bf15294ed0b71d24b37ebf1e05397752f0ed3b061adfb0eafdec9e58a21", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:164f6bbcb3bd54b62c18949c00a5a24674f5205d2f1cadfa25d314541ce7e17b", "content": "[[rsocket]]\n\nThis section describes Spring Framework's support for the RSocket protocol.\n\n[[rsocket-overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "rsocket", "heading_level": 1, "file_order": 457, "section_index": 0, "content_hash": "164f6bbcb3bd54b62c18949c00a5a24674f5205d2f1cadfa25d314541ce7e17b", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:5538cb355bf026ee02b2486741d3f42bbfd12cc3fc7d45c1344165d23fcc4ff9", "content": "RSocket is an application protocol for multiplexed, duplex communication over TCP,\nWebSocket, and other byte stream transports, using one of the following interaction\nmodels:\n\n* `Request-Response` -- send one message and receive one back.\n* `Request-Stream` -- send one message and receive a stream of messages back.\n* `Channel` -- send streams of messages in both directions.\n* `Fire-and-Forget` -- send a one-way message.\n\nOnce the initial connection is made, the \"client\" vs \"server\" distinction is lost as\nboth sides become symmetrical and each side can initiate one of the above interactions.\nThis is why in the protocol calls the participating sides \"requester\" and \"responder\"\nwhile the above interactions are called \"request streams\" or simply \"requests\".\n\nThese are the key features and benefits of the RSocket protocol:\n\n* {reactive-streams-site}/[Reactive Streams] semantics across network boundary --\nfor streaming requests such as `Request-Stream` and `Channel`, back pressure signals\ntravel between requester and responder, allowing a requester to slow down a responder at\nthe source, hence reducing reliance on network layer congestion control, and the need\nfor buffering at the network level or at any level.\n* Request throttling -- this feature is named \"Leasing\" after the `LEASE` frame that\ncan be sent from each end to limit the total number of requests allowed by other end\nfor a given time. Leases are renewed periodically.\n* Session resumption -- this is designed for loss of connectivity and requires some state\nto be maintained. The state management is transparent for applications, and works well\nin combination with back pressure which can stop a producer when possible and reduce\nthe amount of state required.\n* Fragmentation and re-assembly of large messages.\n* Keepalive (heartbeats).\n\nRSocket has {rsocket-github-org}[implementations] in multiple languages. The\n{rsocket-java}[Java library] is built on {reactor-site}/[Project Reactor],\nand {reactor-github-org}/reactor-netty[Reactor Netty] for the transport. That means\nsignals from Reactive Streams Publishers in your application propagate transparently\nthrough RSocket across the network.\n\n[[rsocket-protocol]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Overview", "heading_level": 2, "file_order": 457, "section_index": 1, "content_hash": "5538cb355bf026ee02b2486741d3f42bbfd12cc3fc7d45c1344165d23fcc4ff9", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:7f07bfa07e068f67cb11f38dc3c48e0de3a90dee4368a68f8baad02e161936b3", "content": "One of the benefits of RSocket is that it has well defined behavior on the wire and an\neasy to read {rsocket-site}/about/protocol[specification] along with some protocol\n{rsocket-protocol-extensions}[extensions]. Therefore it is\na good idea to read the spec, independent of language implementations and higher level\nframework APIs. This section provides a succinct overview to establish some context.\n\n**Connecting**\n\nInitially a client connects to a server via some low level streaming transport such\nas TCP or WebSocket and sends a `SETUP` frame to the server to set parameters for the\nconnection.\n\nThe server may reject the `SETUP` frame, but generally after it is sent (for the client)\nand received (for the server), both sides can begin to make requests, unless `SETUP`\nindicates use of leasing semantics to limit the number of requests, in which case\nboth sides must wait for a `LEASE` frame from the other end to permit making requests.\n\n**Making Requests**\n\nOnce a connection is established, both sides may initiate a request through one of the\nframes `REQUEST_RESPONSE`, `REQUEST_STREAM`, `REQUEST_CHANNEL`, or `REQUEST_FNF`. Each of\nthose frames carries one message from the requester to the responder.\n\nThe responder may then return `PAYLOAD` frames with response messages, and in the case\nof `REQUEST_CHANNEL` the requester may also send `PAYLOAD` frames with more request\nmessages.\n\nWhen a request involves a stream of messages such as `Request-Stream` and `Channel`,\nthe responder must respect demand signals from the requester. Demand is expressed as a\nnumber of messages. Initial demand is specified in `REQUEST_STREAM` and\n`REQUEST_CHANNEL` frames. Subsequent demand is signaled via `REQUEST_N` frames.\n\nEach side may also send metadata notifications, via the `METADATA_PUSH` frame, that do not\npertain to any individual request but rather to the connection as a whole.\n\n**Message Format**\n\nRSocket messages contain data and metadata. Metadata can be used to send a route, a\nsecurity token, etc. Data and metadata can be formatted differently. Mime types for each\nare declared in the `SETUP` frame and apply to all requests on a given connection.\n\nWhile all messages can have metadata, typically metadata such as a route are per-request\nand therefore only included in the first message on a request, i.e. with one of the frames\n`REQUEST_RESPONSE`, `REQUEST_STREAM`, `REQUEST_CHANNEL`, or `REQUEST_FNF`.\n\nProtocol extensions define common metadata formats for use in applications:\n\n* {rsocket-protocol-extensions}/CompositeMetadata.md[Composite Metadata]-- multiple,\n independently formatted metadata entries.\n* {rsocket-protocol-extensions}/Routing.md[Routing] -- the route for a request.\n\n[[rsocket-java]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "The Protocol", "heading_level": 3, "file_order": 457, "section_index": 2, "content_hash": "7f07bfa07e068f67cb11f38dc3c48e0de3a90dee4368a68f8baad02e161936b3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:33a331ea5160f8999b32cb40fc0cac9e9efd8b23dd79e07072a68853be20052a", "content": "The {rsocket-java}[Java implementation] for RSocket is built on\n{reactor-site}/[Project Reactor]. The transports for TCP and WebSocket are\nbuilt on {reactor-github-org}/reactor-netty[Reactor Netty]. As a Reactive Streams\nlibrary, Reactor simplifies the job of implementing the protocol. For applications it is\na natural fit to use `Flux` and `Mono` with declarative operators and transparent back\npressure support.\n\nThe API in RSocket Java is intentionally minimal and basic. It focuses on protocol\nfeatures and leaves the application programming model (for example, RPC codegen vs other) as a\nhigher level, independent concern.\n\nThe main contract\n{rsocket-java-code}/rsocket-core/src/main/java/io/rsocket/RSocket.java[io.rsocket.RSocket]\nmodels the four request interaction types with `Mono` representing a promise for a\nsingle message, `Flux` a stream of messages, and `io.rsocket.Payload` the actual\nmessage with access to data and metadata as byte buffers. The `RSocket` contract is used\nsymmetrically. For requesting, the application is given an `RSocket` to perform\nrequests with. For responding, the application implements `RSocket` to handle requests.\n\nThis is not meant to be a thorough introduction. For the most part, Spring applications\nwill not have to use its API directly. However it may be important to see or experiment\nwith RSocket independent of Spring. The RSocket Java repository contains a number of\n{rsocket-java-code}/rsocket-examples[sample apps] that\ndemonstrate its API and protocol features.\n\n[[rsocket-spring]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Java Implementation", "heading_level": 3, "file_order": 457, "section_index": 3, "content_hash": "33a331ea5160f8999b32cb40fc0cac9e9efd8b23dd79e07072a68853be20052a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:3a1036160569bc187cfa09ddf34d83f76898d7269bb4b512f6621aeaf1288f8d", "content": "The `spring-messaging` module contains the following:\n\n* xref:rsocket.adoc#rsocket-requester[RSocketRequester] -- fluent API to make requests\nthrough an `io.rsocket.RSocket` with data and metadata encoding/decoding.\n* xref:rsocket.adoc#rsocket-annot-responders[Annotated Responders] -- `@MessageMapping`\n and `@RSocketExchange` annotated handler methods for responding.\n* xref:rsocket.adoc#rsocket-interface[RSocket Interface] -- RSocket service declaration\nas Java interface with `@RSocketExchange` methods, for use as requester or responder.\n\nThe `spring-web` module contains `Encoder` and `Decoder` implementations such as Jackson\nCBOR/JSON, and Protobuf that RSocket applications will likely need. It also contains the\n`PathPatternParser` that can be plugged in for efficient route matching.\n\nSpring Boot 2.2 supports standing up an RSocket server over TCP or WebSocket, including\nthe option to expose RSocket over WebSocket in a WebFlux server. There is also client\nsupport and auto-configuration for an `RSocketRequester.Builder` and `RSocketStrategies`.\nSee the\n{spring-boot-docs}/messaging.html#messaging.rsocket[RSocket section]\nin the Spring Boot reference for more details.\n\nSpring Security 5.2 provides RSocket support.\n\nSpring Integration 5.2 provides inbound and outbound gateways to interact with RSocket\nclients and servers. See the Spring Integration Reference Manual for more details.\n\nSpring Cloud Gateway supports RSocket connections.\n\n[[rsocket-requester]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Spring Support", "heading_level": 3, "file_order": 457, "section_index": 4, "content_hash": "3a1036160569bc187cfa09ddf34d83f76898d7269bb4b512f6621aeaf1288f8d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:c9d59b982f6dc9f94fe04e357bc6f9a309fe8607637aec3c854c844129f68841", "content": "`RSocketRequester` provides a fluent API to perform RSocket requests, accepting and\nreturning objects for data and metadata instead of low level data buffers. It can be used\nsymmetrically, to make requests from clients and to make requests from servers.\n\n[[rsocket-requester-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "RSocketRequester", "heading_level": 2, "file_order": 457, "section_index": 5, "content_hash": "c9d59b982f6dc9f94fe04e357bc6f9a309fe8607637aec3c854c844129f68841", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:640239d78ca689509507799ca725243a72cddde74983d88e8d66b2f369e111bc", "content": "To obtain an `RSocketRequester` on the client side is to connect to a server which involves\nsending an RSocket `SETUP` frame with connection settings. `RSocketRequester` provides a\nbuilder that helps to prepare an `io.rsocket.core.RSocketConnector` including connection\nsettings for the `SETUP` frame.\n\nThis is the most basic way to connect with default settings:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRSocketRequester requester = RSocketRequester.builder().tcp(\"localhost\", 7000);\n\n\tURI url = URI.create(\"https://example.org:8080/rsocket\");\n\tRSocketRequester requester = RSocketRequester.builder().webSocket(url);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval requester = RSocketRequester.builder().tcp(\"localhost\", 7000)\n\n\tURI url = URI.create(\"https://example.org:8080/rsocket\");\n\tval requester = RSocketRequester.builder().webSocket(url)\n----\n======\n\nThe above does not connect immediately. When requests are made, a shared connection is\nestablished transparently and used.\n\n[[rsocket-requester-client-setup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Client Requester", "heading_level": 3, "file_order": 457, "section_index": 6, "content_hash": "640239d78ca689509507799ca725243a72cddde74983d88e8d66b2f369e111bc", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:26a26aca9de45170b63121026af63388819cbfd361051fbdddce6c97217805f7", "content": "`RSocketRequester.Builder` provides the following to customize the initial `SETUP` frame:\n\n* `dataMimeType(MimeType)` -- set the mime type for data on the connection.\n* `metadataMimeType(MimeType)` -- set the mime type for metadata on the connection.\n* `setupData(Object)` -- data to include in the `SETUP`.\n* `setupRoute(String, Object...)` -- route in the metadata to include in the `SETUP`.\n* `setupMetadata(Object, MimeType)` -- other metadata to include in the `SETUP`.\n\nFor data, the default mime type is derived from the first configured `Decoder`. For\nmetadata, the default mime type is\n{rsocket-protocol-extensions}/CompositeMetadata.md[composite metadata] which allows multiple\nmetadata value and mime type pairs per request. Typically both don't need to be changed.\n\nData and metadata in the `SETUP` frame is optional. On the server side,\nxref:rsocket.adoc#rsocket-annot-connectmapping[@ConnectMapping] methods can be used to\nhandle the start of a connection and the content of the `SETUP` frame. Metadata may be\nused for connection level security.\n\n[[rsocket-requester-client-strategies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Connection Setup", "heading_level": 4, "file_order": 457, "section_index": 7, "content_hash": "26a26aca9de45170b63121026af63388819cbfd361051fbdddce6c97217805f7", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:9db3d0b65403b85df21443a0a9acbdb2eafc55c366d23c0fb8338e1b4d80dfb3", "content": "`RSocketRequester.Builder` accepts `RSocketStrategies` to configure the requester.\nYou'll need to use this to provide encoders and decoders for (de)-serialization of data and\nmetadata values. By default only the basic codecs from `spring-core` for `String`,\n`byte[]`, and `ByteBuffer` are registered. Adding `spring-web` provides access to more that\ncan be registered as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRSocketStrategies strategies = RSocketStrategies.builder()\n .encoders(encoders -> encoders.add(new JacksonCborEncoder()))\n .decoders(decoders -> decoders.add(new JacksonCborDecoder()))\n .build();\n\n\tRSocketRequester requester = RSocketRequester.builder()\n .rsocketStrategies(strategies)\n .tcp(\"localhost\", 7000);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval strategies = RSocketStrategies.builder()\n .encoders { it.add(JacksonCborEncoder()) }\n .decoders { it.add(JacksonCborDecoder()) }\n .build()\n\n\tval requester = RSocketRequester.builder()\n .rsocketStrategies(strategies)\n .tcp(\"localhost\", 7000)\n----\n======\n\n`RSocketStrategies` is designed for re-use. In some scenarios, for example, client and server in\nthe same application, it may be preferable to declare it in Spring configuration.\n\n[[rsocket-requester-client-responder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Strategies", "heading_level": 4, "file_order": 457, "section_index": 8, "content_hash": "9db3d0b65403b85df21443a0a9acbdb2eafc55c366d23c0fb8338e1b4d80dfb3", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:524180afbf5bfcd351c98a8fd806ba983a7a3d99996118e74bd4e9da6f94029e", "content": "`RSocketRequester.Builder` can be used to configure responders to requests from the\nserver.\n\nYou can use annotated handlers for client-side responding based on the same\ninfrastructure that's used on a server, but registered programmatically as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRSocketStrategies strategies = RSocketStrategies.builder()\n .routeMatcher(new PathPatternRouteMatcher()) // <1>\n .build();\n\n\tSocketAcceptor responder =\n RSocketMessageHandler.responder(strategies, new ClientHandler()); // <2>\n\n\tRSocketRequester requester = RSocketRequester.builder()\n .rsocketConnector(connector -> connector.acceptor(responder)) // <3>\n .tcp(\"localhost\", 7000);\n----\n<1> Use `PathPatternRouteMatcher`, if `spring-web` is present, for efficient\n route matching.\n<2> Create a responder from a class with `@MessageMapping` and/or `@ConnectMapping` methods.\n<3> Register the responder.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval strategies = RSocketStrategies.builder()\n .routeMatcher(PathPatternRouteMatcher()) // <1>\n .build()\n\n\tval responder =\n RSocketMessageHandler.responder(strategies, new ClientHandler()); // <2>\n\n\tval requester = RSocketRequester.builder()\n .rsocketConnector { it.acceptor(responder) } // <3>\n .tcp(\"localhost\", 7000)\n----\n<1> Use `PathPatternRouteMatcher`, if `spring-web` is present, for efficient\nroute matching.\n<2> Create a responder from a class with `@MessageMapping` and/or `@ConnectMapping` methods.\n<3> Register the responder.\n======\n\nNote the above is only a shortcut designed for programmatic registration of client\nresponders. For alternative scenarios, where client responders are in Spring configuration,\nyou can still declare `RSocketMessageHandler` as a Spring bean and then apply as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext context = ... ;\n\tRSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);\n\n\tRSocketRequester requester = RSocketRequester.builder()\n .rsocketConnector(connector -> connector.acceptor(handler.responder()))\n .tcp(\"localhost\", 7000);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\tval context: ApplicationContext = ...\n\tval handler = context.getBean<RSocketMessageHandler>()\n\n\tval requester = RSocketRequester.builder()\n .rsocketConnector { it.acceptor(handler.responder()) }\n .tcp(\"localhost\", 7000)\n----\n======\n\nFor the above you may also need to use `setHandlerPredicate` in `RSocketMessageHandler` to\nswitch to a different strategy for detecting client responders, for example, based on a custom\nannotation such as `@RSocketClientResponder` vs the default `@Controller`. This\nis necessary in scenarios with client and server, or multiple clients in the same\napplication.\n\nSee also xref:rsocket.adoc#rsocket-annot-responders[Annotated Responders], for more on the programming model.\n\n[[rsocket-requester-client-advanced]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Client Responders", "heading_level": 4, "file_order": 457, "section_index": 9, "content_hash": "524180afbf5bfcd351c98a8fd806ba983a7a3d99996118e74bd4e9da6f94029e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:e99da5a6967c3be1c3214d304f4a801f35185e5b2d67ea5722a0958e7c492d4d", "content": "`RSocketRequesterBuilder` provides a callback to expose the underlying\n`io.rsocket.core.RSocketConnector` for further configuration options for keepalive\nintervals, session resumption, interceptors, and more. You can configure options\nat that level as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRSocketRequester requester = RSocketRequester.builder()\n .rsocketConnector(connector -> {\n // ...\n })\n .tcp(\"localhost\", 7000);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval requester = RSocketRequester.builder()\n .rsocketConnector {\n //...\n }\n .tcp(\"localhost\", 7000)\n----\n======\n\n[[rsocket-requester-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Advanced", "heading_level": 4, "file_order": 457, "section_index": 10, "content_hash": "e99da5a6967c3be1c3214d304f4a801f35185e5b2d67ea5722a0958e7c492d4d", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:2339743932fca75cc8b57586099dac71a77b9d874049f0cfa0cd142dbdee5cb2", "content": "To make requests from a server to connected clients is a matter of obtaining the\nrequester for the connected client from the server.\n\nIn xref:rsocket.adoc#rsocket-annot-responders[Annotated Responders], `@ConnectMapping` and `@MessageMapping` methods support an\n`RSocketRequester` argument. Use it to access the requester for the connection. Keep in\nmind that `@ConnectMapping` methods are essentially handlers of the `SETUP` frame which\nmust be handled before requests can begin. Therefore, requests at the very start must be\ndecoupled from handling. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ConnectMapping\n\tMono<Void> handle(RSocketRequester requester) {\n requester.route(\"status\").data(\"5\")\n .retrieveFlux(StatusReport.class)\n .subscribe(bar -> { // <1>\n // ...\n });\n return ... // <2>\n\t}\n----\n<1> Start the request asynchronously, independent from handling.\n<2> Perform handling and return completion `Mono<Void>`.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@ConnectMapping\n\tsuspend fun handle(requester: RSocketRequester) {\n GlobalScope.launch {\n requester.route(\"status\").data(\"5\").retrieveFlow<StatusReport>().collect { // <1>\n // ...\n }\n }\n /// ... <2>\n\t}\n----\n<1> Start the request asynchronously, independent from handling.\n<2> Perform handling in the suspending function.\n======\n\n[[rsocket-requester-requests]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Server Requester", "heading_level": 3, "file_order": 457, "section_index": 11, "content_hash": "2339743932fca75cc8b57586099dac71a77b9d874049f0cfa0cd142dbdee5cb2", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:2efbb7c1e95208226750a92517c7972b31f9d164ad1639153500f027184f5a8a", "content": "Once you have a xref:rsocket.adoc#rsocket-requester-client[client] or\nxref:rsocket.adoc#rsocket-requester-server[server] requester, you can make requests as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tViewBox viewBox = ... ;\n\n\tFlux<AirportLocation> locations = requester.route(\"locate.radars.within\") // <1>\n .data(viewBox) // <2>\n .retrieveFlux(AirportLocation.class); // <3>\n\n----\n<1> Specify a route to include in the metadata of the request message.\n<2> Provide data for the request message.\n<3> Declare the expected response.\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tval viewBox: ViewBox = ...\n\n\tval locations = requester.route(\"locate.radars.within\") // <1>\n .data(viewBox) // <2>\n .retrieveFlow<AirportLocation>() // <3>\n----\n<1> Specify a route to include in the metadata of the request message.\n<2> Provide data for the request message.\n<3> Declare the expected response.\n======\n\nThe interaction type is determined implicitly from the cardinality of the input and\noutput. The above example is a `Request-Stream` because one value is sent and a stream\nof values is received. For the most part you don't need to think about this as long as the\nchoice of input and output matches an RSocket interaction type and the types of input and\noutput expected by the responder. The only example of an invalid combination is many-to-one.\n\nThe `data(Object)` method also accepts any Reactive Streams `Publisher`, including\n`Flux` and `Mono`, as well as any other producer of value(s) that is registered in the\n`ReactiveAdapterRegistry`. For a multi-value `Publisher` such as `Flux` which produces the\nsame types of values, consider using one of the overloaded `data` methods to avoid having\ntype checks and `Encoder` lookup on every element:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\ndata(Object producer, Class<?> elementClass);\ndata(Object producer, ParameterizedTypeReference<?> elementTypeRef);\n----\n\nThe `data(Object)` step is optional. Skip it for requests that don't send data:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tMono<AirportLocation> location = requester.route(\"find.radar.EWR\"))\n .retrieveMono(AirportLocation.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.messaging.rsocket.retrieveAndAwait\n\n\tval location = requester.route(\"find.radar.EWR\")\n .retrieveAndAwait<AirportLocation>()\n----\n======\n\nExtra metadata values can be added if using\n{rsocket-protocol-extensions}/CompositeMetadata.md[composite metadata] (the default) and if the\nvalues are supported by a registered `Encoder`. For example:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tString securityToken = ... ;\n\tViewBox viewBox = ... ;\n\tMimeType mimeType = MimeType.valueOf(\"message/x.rsocket.authentication.bearer.v0\");\n\n\tFlux<AirportLocation> locations = requester.route(\"locate.radars.within\")\n .metadata(securityToken, mimeType)\n .data(viewBox)\n .retrieveFlux(AirportLocation.class);\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.messaging.rsocket.retrieveFlow\n\n\tval requester: RSocketRequester = ...\n\n\tval securityToken: String = ...\n\tval viewBox: ViewBox = ...\n\tval mimeType = MimeType.valueOf(\"message/x.rsocket.authentication.bearer.v0\")\n\n\tval locations = requester.route(\"locate.radars.within\")\n .metadata(securityToken, mimeType)\n .data(viewBox)\n .retrieveFlow<AirportLocation>()\n----\n======\n\nFor `Fire-and-Forget` use the `send()` method that returns `Mono<Void>`. Note that the `Mono`\nindicates only that the message was successfully sent, and not that it was handled.\n\nFor `Metadata-Push` use the `sendMetadata()` method with a `Mono<Void>` return value.\n\n[[rsocket-annot-responders]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Requests", "heading_level": 3, "file_order": 457, "section_index": 12, "content_hash": "2efbb7c1e95208226750a92517c7972b31f9d164ad1639153500f027184f5a8a", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:7411c3e231d1e6aa2c6c1b071f2219e2de11d504e3244d47098df8b7e37dc519", "content": "RSocket responders can be implemented as `@MessageMapping` and `@ConnectMapping` methods.\n`@MessageMapping` methods handle individual requests while `@ConnectMapping` methods handle\nconnection-level events (setup and metadata push). Annotated responders are supported\nsymmetrically, for responding from the server side and for responding from the client side.\n\n[[rsocket-annot-responders-server]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Annotated Responders", "heading_level": 2, "file_order": 457, "section_index": 13, "content_hash": "7411c3e231d1e6aa2c6c1b071f2219e2de11d504e3244d47098df8b7e37dc519", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:dfaf1404242b709b76ac373d1766b1e58ce11c1caac16e8d97a2868201ea3ae0", "content": "To use annotated responders on the server side, add `RSocketMessageHandler` to your Spring\nconfiguration to detect `@Controller` beans with `@MessageMapping` and `@ConnectMapping`\nmethods:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tstatic class ServerConfig {\n\n @Bean\n public RSocketMessageHandler rsocketMessageHandler() {\n RSocketMessageHandler handler = new RSocketMessageHandler();\n handler.routeMatcher(new PathPatternRouteMatcher());\n return handler;\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass ServerConfig {\n\n @Bean\n fun rsocketMessageHandler() = RSocketMessageHandler().apply {\n routeMatcher = PathPatternRouteMatcher()\n }\n\t}\n----\n======\n\nThen start an RSocket server through the Java RSocket API and plug the\n`RSocketMessageHandler` for the responder as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tApplicationContext context = ... ;\n\tRSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);\n\n\tCloseableChannel server =\n RSocketServer.create(handler.responder())\n .bind(TcpServerTransport.create(\"localhost\", 7000))\n .block();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.beans.factory.getBean\n\n\tval context: ApplicationContext = ...\n\tval handler = context.getBean<RSocketMessageHandler>()\n\n\tval server = RSocketServer.create(handler.responder())\n .bind(TcpServerTransport.create(\"localhost\", 7000))\n .awaitSingle()\n----\n======\n\n`RSocketMessageHandler` supports\n{rsocket-protocol-extensions}/CompositeMetadata.md[composite] and\n{rsocket-protocol-extensions}/Routing.md[routing] metadata by default. You can set its\nxref:rsocket.adoc#rsocket-metadata-extractor[MetadataExtractor] if you need to switch to a\ndifferent mime type or register additional metadata mime types.\n\nYou'll need to set the `Encoder` and `Decoder` instances required for metadata and data\nformats to support. You'll likely need the `spring-web` module for codec implementations.\n\nBy default `SimpleRouteMatcher` is used for matching routes via `AntPathMatcher`.\nWe recommend plugging in the `PathPatternRouteMatcher` from `spring-web` for\nefficient route matching. RSocket routes can be hierarchical but are not URL paths.\nBoth route matchers are configured to use \".\" as separator by default and there is no URL\ndecoding as with HTTP URLs.\n\n`RSocketMessageHandler` can be configured via `RSocketStrategies` which may be useful if\nyou need to share configuration between a client and a server in the same process:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tstatic class ServerConfig {\n\n @Bean\n public RSocketMessageHandler rsocketMessageHandler() {\n RSocketMessageHandler handler = new RSocketMessageHandler();\n handler.setRSocketStrategies(rsocketStrategies());\n return handler;\n }\n\n @Bean\n public RSocketStrategies rsocketStrategies() {\n return RSocketStrategies.builder()\n .encoders(encoders -> encoders.add(new JacksonCborEncoder()))\n .decoders(decoders -> decoders.add(new JacksonCborDecoder()))\n .routeMatcher(new PathPatternRouteMatcher())\n .build();\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Configuration\n\tclass ServerConfig {\n\n @Bean\n fun rsocketMessageHandler() = RSocketMessageHandler().apply {\n rSocketStrategies = rsocketStrategies()\n }\n\n @Bean\n fun rsocketStrategies() = RSocketStrategies.builder()\n .encoders { it.add(JacksonCborEncoder()) }\n .decoders { it.add(JacksonCborDecoder()) }\n .routeMatcher(PathPatternRouteMatcher())\n .build()\n\t}\n----\n======\n\n[[rsocket-annot-responders-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Server Responders", "heading_level": 3, "file_order": 457, "section_index": 14, "content_hash": "dfaf1404242b709b76ac373d1766b1e58ce11c1caac16e8d97a2868201ea3ae0", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:8ee50b651c4f1a761daf4230e51a6fc448a09e0c9df90ed07e7333cdcb9f3956", "content": "Annotated responders on the client side need to be configured in the\n`RSocketRequester.Builder`. For details, see\nxref:rsocket.adoc#rsocket-requester-client-responder[Client Responders].\n\n[[rsocket-annot-messagemapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Client Responders", "heading_level": 3, "file_order": 457, "section_index": 15, "content_hash": "8ee50b651c4f1a761daf4230e51a6fc448a09e0c9df90ed07e7333cdcb9f3956", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:628fd8bf951e016cf328650e2d96a181f74becece48b79a70f176caa8b53c9a1", "content": "Once xref:rsocket.adoc#rsocket-annot-responders-server[server] or\nxref:rsocket.adoc#rsocket-annot-responders-client[client] responder configuration is in place,\n`@MessageMapping` methods can be used as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\t@Controller\n\tpublic class RadarsController {\n\n @MessageMapping(\"locate.radars.within\")\n public Flux<AirportLocation> radars(MapRequest request) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n@Controller\nclass RadarsController {\n\n\t@MessageMapping(\"locate.radars.within\")\n\tfun radars(request: MapRequest): Flow<AirportLocation> {\n // ...\n\t}\n}\n----\n======\n\nThe above `@MessageMapping` method responds to a Request-Stream interaction having the\nroute \"locate.radars.within\". It supports a flexible method signature with the option to\nuse the following method arguments:\n\n[cols=\"1,3\",options=\"header\"]\n|===\n| Method Argument\n| Description\n\n| `@Payload`\n| The payload of the request. This can be a concrete value of asynchronous types like\n `Mono` or `Flux`.\n\n *Note:* Use of the annotation is optional. A method argument that is not a simple type\n and is not any of the other supported arguments, is assumed to be the expected payload.\n\n| `RSocketRequester`\n| Requester for making requests to the remote end.\n\n| `@DestinationVariable`\n| Value extracted from the route based on variables in the mapping pattern, for example,\n pass:q[`@MessageMapping(\"find.radar.{id}\")`].\n\n| `@Header`\n| Metadata value registered for extraction as described in xref:rsocket.adoc#rsocket-metadata-extractor[MetadataExtractor].\n\n| `@Headers Map<String, Object>`\n| All metadata values registered for extraction as described in xref:rsocket.adoc#rsocket-metadata-extractor[MetadataExtractor].\n\n|===\n\nThe return value is expected to be one or more Objects to be serialized as response\npayloads. That can be asynchronous types like `Mono` or `Flux`, a concrete value, or\neither `void` or a no-value asynchronous type such as `Mono<Void>`.\n\nThe RSocket interaction type that an `@MessageMapping` method supports is determined from\nthe cardinality of the input (i.e. `@Payload` argument) and of the output, where\ncardinality means the following:\n\n[%autowidth]\n[cols=2*,options=\"header\"]\n|===\n| Cardinality\n| Description\n\n| 1\n| Either an explicit value, or a single-value asynchronous type such as `Mono<T>`.\n\n| Many\n| A multi-value asynchronous type such as `Flux<T>`.\n\n| 0\n| For input this means the method does not have an `@Payload` argument.\n\n For output this is `void` or a no-value asynchronous type such as `Mono<Void>`.\n|===\n\nThe table below shows all input and output cardinality combinations and the corresponding\ninteraction type(s):\n\n[%autowidth]\n[cols=3*,options=\"header\"]\n|===\n| Input Cardinality\n| Output Cardinality\n| Interaction Types\n\n| 0, 1\n| 0\n| Fire-and-Forget, Request-Response\n\n| 0, 1\n| 1\n| Request-Response\n\n| 0, 1\n| Many\n| Request-Stream\n\n| Many\n| 0, 1, Many\n| Request-Channel\n\n|===\n\n[[rsocket-annot-rsocketexchange]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "@MessageMapping", "heading_level": 3, "file_order": 457, "section_index": 16, "content_hash": "628fd8bf951e016cf328650e2d96a181f74becece48b79a70f176caa8b53c9a1", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:7bdd9f8d5382d7d767d3a87deca67f96b11446deac1c909571e0db658a675294", "content": "As an alternative to `@MessageMapping`, you can also handle requests with\n`@RSocketExchange` methods. Such methods are declared on an\nxref:rsocket-interface[RSocket Interface] and can be used as a requester via\n`RSocketServiceProxyFactory` or implemented by a responder.\n\nFor example, to handle requests as a responder:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tpublic interface RadarsService {\n\n @RSocketExchange(\"locate.radars.within\")\n Flux<AirportLocation> radars(MapRequest request);\n\t}\n\n\t@Controller\n\tpublic class RadarsController implements RadarsService {\n\n public Flux<AirportLocation> radars(MapRequest request) {\n // ...\n }\n\t}\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\tinterface RadarsService {\n\n @RSocketExchange(\"locate.radars.within\")\n fun radars(request: MapRequest): Flow<AirportLocation>\n\t}\n\n\t@Controller\n\tclass RadarsController : RadarsService {\n\n override fun radars(request: MapRequest): Flow<AirportLocation> {\n // ...\n }\n\t}\n----\n======\n\nThere some differences between `@RSocketExhange` and `@MessageMapping` since the\nformer needs to remain suitable for requester and responder use. For example, while\n`@MessageMapping` can be declared to handle any number of routes and each route can\nbe a pattern, `@RSocketExchange` must be declared with a single, concrete route. There are\nalso small differences in the supported method parameters related to metadata, see\nxref:rsocket-annot-messagemapping[@MessageMapping] and\nxref:rsocket-interface[RSocket Interface] for a list of supported parameters.\n\n`@RSocketExchange` can be used at the type level to specify a common prefix for all routes\nfor a given RSocket service interface.\n\n[[rsocket-annot-connectmapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "@RSocketExchange", "heading_level": 3, "file_order": 457, "section_index": 17, "content_hash": "7bdd9f8d5382d7d767d3a87deca67f96b11446deac1c909571e0db658a675294", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:bd542141b238704cfadca20515fd29736736dcf3847f13c00fd7a8a3716e00ee", "content": "`@ConnectMapping` handles the `SETUP` frame at the start of an RSocket connection, and\nany subsequent metadata push notifications through the `METADATA_PUSH` frame, i.e.\n`metadataPush(Payload)` in `io.rsocket.RSocket`.\n\n`@ConnectMapping` methods support the same arguments as\nxref:rsocket.adoc#rsocket-annot-messagemapping[@MessageMapping] but based on metadata and data from the `SETUP` and\n`METADATA_PUSH` frames. `@ConnectMapping` can have a pattern to narrow handling to\nspecific connections that have a route in the metadata, or if no patterns are declared\nthen all connections match.\n\n`@ConnectMapping` methods cannot return data and must be declared with `void` or\n`Mono<Void>` as the return value. If handling returns an error for a new\nconnection then the connection is rejected. Handling must not be held up to make\nrequests to the `RSocketRequester` for the connection. See\nxref:rsocket.adoc#rsocket-requester-server[Server Requester] for details.\n\n[[rsocket-metadata-extractor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "@ConnectMapping", "heading_level": 3, "file_order": 457, "section_index": 18, "content_hash": "bd542141b238704cfadca20515fd29736736dcf3847f13c00fd7a8a3716e00ee", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:62818ce881e98be7df929ccdfcded84ebec80099d307fe7235b8f8a37cf9e568", "content": "Responders must interpret metadata.\n{rsocket-protocol-extensions}/CompositeMetadata.md[Composite metadata] allows independently\nformatted metadata values (for example, for routing, security, tracing) each with its own mime\ntype. Applications need a way to configure metadata mime types to support, and a way\nto access extracted values.\n\n`MetadataExtractor` is a contract to take serialized metadata and return decoded\nname-value pairs that can then be accessed like headers by name, for example via `@Header`\nin annotated handler methods.\n\n`DefaultMetadataExtractor` can be given `Decoder` instances to decode metadata. Out of\nthe box it has built-in support for\n{rsocket-protocol-extensions}/Routing.md[\"message/x.rsocket.routing.v0\"] which it decodes to\n`String` and saves under the \"route\" key. For any other mime type you'll need to provide\na `Decoder` and register the mime type as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tDefaultMetadataExtractor extractor = new DefaultMetadataExtractor(metadataDecoders);\n\textractor.metadataToExtract(fooMimeType, Foo.class, \"foo\");\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.messaging.rsocket.metadataToExtract\n\n\tval extractor = DefaultMetadataExtractor(metadataDecoders)\n\textractor.metadataToExtract<Foo>(fooMimeType, \"foo\")\n----\n======\n\nComposite metadata works well to combine independent metadata values. However the\nrequester might not support composite metadata, or may choose not to use it. For this,\n`DefaultMetadataExtractor` may needs custom logic to map the decoded value to the output\nmap. Here is an example where JSON is used for metadata:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tDefaultMetadataExtractor extractor = new DefaultMetadataExtractor(metadataDecoders);\n\textractor.metadataToExtract(\n MimeType.valueOf(\"application/vnd.myapp.metadata+json\"),\n new ParameterizedTypeReference<Map<String,String>>() {},\n (jsonMap, outputMap) -> {\n outputMap.putAll(jsonMap);\n });\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.messaging.rsocket.metadataToExtract\n\n\tval extractor = DefaultMetadataExtractor(metadataDecoders)\n\textractor.metadataToExtract<Map<String, String>>(MimeType.valueOf(\"application/vnd.myapp.metadata+json\")) { jsonMap, outputMap ->\n outputMap.putAll(jsonMap)\n\t}\n----\n======\n\nWhen configuring `MetadataExtractor` through `RSocketStrategies`, you can let\n`RSocketStrategies.Builder` create the extractor with the configured decoders, and\nsimply use a callback to customize registrations as follows:\n\n[tabs]\n======\nJava::\n+\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRSocketStrategies strategies = RSocketStrategies.builder()\n .metadataExtractorRegistry(registry -> {\n registry.metadataToExtract(fooMimeType, Foo.class, \"foo\");\n // ...\n })\n .build();\n----\n\nKotlin::\n+\n[source,kotlin,indent=0,subs=\"verbatim,quotes\"]\n----\n\timport org.springframework.messaging.rsocket.metadataToExtract\n\n\tval strategies = RSocketStrategies.builder()\n .metadataExtractorRegistry { registry: MetadataExtractorRegistry ->\n registry.metadataToExtract<Foo>(fooMimeType, \"foo\")\n // ...\n }\n .build()\n----\n======\n\n[[rsocket-interface]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "MetadataExtractor", "heading_level": 2, "file_order": 457, "section_index": 19, "content_hash": "62818ce881e98be7df929ccdfcded84ebec80099d307fe7235b8f8a37cf9e568", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:54bdcd0304d65b7578dab698fe8112e3cedfd8d40cc144dafc67e539ce229910", "content": "The Spring Framework lets you define an RSocket service as a Java interface with\n`@RSocketExchange` methods. You can pass such an interface to `RSocketServiceProxyFactory`\nto create a proxy which performs requests through an\nxref:rsocket.adoc#rsocket-requester[RSocketRequester]. You can also implement the\ninterface as a responder that handles requests.\n\nStart by creating the interface with `@RSocketExchange` methods:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tinterface RadarService {\n\n @RSocketExchange(\"radars\")\n Flux<AirportLocation> getRadars(@Payload MapRequest request);\n\n // more RSocket exchange methods...\n\n\t}\n----\n\nNow you can create a proxy that performs requests when methods are called:\n\n[source,java,indent=0,subs=\"verbatim,quotes\"]\n----\n\tRSocketRequester requester = ... ;\n\tRSocketServiceProxyFactory factory = RSocketServiceProxyFactory.builder(requester).build();\n\n\tRadarService service = factory.createClient(RadarService.class);\n----\n\nYou can also implement the interface to handle requests as a responder.\nSee xref:rsocket.adoc#rsocket-annot-rsocketexchange[Annotated Responders].\n\n[[rsocket-interface-method-parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "RSocket Interface", "heading_level": 2, "file_order": 457, "section_index": 20, "content_hash": "54bdcd0304d65b7578dab698fe8112e3cedfd8d40cc144dafc67e539ce229910", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:2e77825aec12fcd1b1d2f98538db0dc0f1fbd2469c110e41bacb425758fdf985", "content": "Annotated, RSocket exchange methods support flexible method signatures with the following\nmethod parameters:\n\n[cols=\"1,2\", options=\"header\"]\n|===\n| Method argument | Description\n\n| `@DestinationVariable`\n| Add a route variable to pass to `RSocketRequester` along with the route from the\n `@RSocketExchange` annotation in order to expand template placeholders in the route.\n This variable can be a String or any Object, which is then formatted via `toString()`.\n\n| `@Payload`\n| Set the input payload(s) for the request. This can be a concrete value, or any producer\n of values that can be adapted to a Reactive Streams `Publisher` via\n `ReactiveAdapterRegistry`. A payload must be provided unless the `required` attribute\n is set to `false`, or the parameter is marked optional as determined by\n {spring-framework-api}/core/MethodParameter.html#isOptional()[`MethodParameter#isOptional`].\n\n| `Object`, if followed by `MimeType`\n| The value for a metadata entry in the input payload. This can be any `Object` as long\n as the next argument is the metadata entry `MimeType`. The value can be a concrete\n value or any producer of a single value that can be adapted to a Reactive Streams\n `Publisher` via `ReactiveAdapterRegistry`.\n\n| `MimeType`\n| The `MimeType` for a metadata entry. The preceding method argument is expected to be\n the metadata value.\n\n|===\n\n[[rsocket-interface-return-values]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Method Parameters", "heading_level": 3, "file_order": 457, "section_index": 21, "content_hash": "2e77825aec12fcd1b1d2f98538db0dc0f1fbd2469c110e41bacb425758fdf985", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:3471ba34819233548b9d4bfbb673f32ac67ca192143274d8f980cfe155e5fd85", "content": "Annotated, RSocket exchange methods support return values that are concrete value(s), or\nany producer of value(s) that can be adapted to a Reactive Streams `Publisher` via\n`ReactiveAdapterRegistry`.\n\nBy default, the behavior of RSocket service methods with synchronous (blocking) method\nsignature depends on response timeout settings of the underlying RSocket `ClientTransport`\nas well as RSocket keep-alive settings. `RSocketServiceProxyFactory.Builder` does expose a\n`blockTimeout` option that also lets you configure the maximum time to block for a response,\nbut we recommend configuring timeout values at the RSocket level for more control.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Return Values", "heading_level": 3, "file_order": 457, "section_index": 22, "content_hash": "3471ba34819233548b9d4bfbb673f32ac67ca192143274d8f980cfe155e5fd85", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:dc91c834772f90458fc8adb0616a5b3879b23ea21ad9652d04435c062f1b493e", "content": "[[testing]]\n\nThis chapter covers Spring's support for integration testing and best practices for unit\ntesting. The Spring team advocates test-driven development (TDD). The Spring team has\nfound that the correct use of inversion of control (IoC) certainly does make both unit\nand integration testing easier (in that the presence of setter methods and appropriate\nconstructors on classes makes them easier to wire together in a test without having to\nset up service locator registries and similar structures).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "testing", "heading_level": 1, "file_order": 458, "section_index": 0, "content_hash": "dc91c834772f90458fc8adb0616a5b3879b23ea21ad9652d04435c062f1b493e", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:f017c76f88c175b008fb7b7498cadeccfc8aae938dfe24e2ca55fd8bcb0c72a4", "content": "[[spring-web-reactive]]\n\nThis part of the documentation covers support for reactive-stack web applications built\non a {reactive-streams-site}/[Reactive Streams] API to run on non-blocking servers,\nsuch as Netty and Servlet containers. Individual chapters cover\nthe xref:web/webflux.adoc#webflux[Spring WebFlux] framework,\nthe reactive xref:web/webflux-webclient.adoc[`WebClient`],\nsupport for xref:web/webflux-test.adoc[testing],\nand xref:web/webflux-reactive-libraries.adoc[reactive libraries].\n\nFor Servlet-stack web applications, see xref:web.adoc[Web on Servlet Stack].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web-reactive.adoc", "title": "web-reactive", "heading": "web-reactive", "heading_level": 1, "file_order": 459, "section_index": 0, "content_hash": "f017c76f88c175b008fb7b7498cadeccfc8aae938dfe24e2ca55fd8bcb0c72a4", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web-reactive.adoc"}}
{"id": "sha256:2d8d571ecf893a9838a1f3b01fb5e7edef47c1e2b482000af799625fc6711ace", "content": "[[spring-web]]\n\nThis part of the documentation covers support for Servlet-stack web applications built\non the Servlet API and deployed to Servlet containers. Individual chapters include\nxref:web/webmvc.adoc#mvc[Spring MVC],\nxref:web/webmvc-view.adoc[View Technologies],\nxref:web/webmvc-cors.adoc[CORS Support], and\nxref:web/websocket.adoc[WebSocket Support].\n\nFor reactive-stack web applications, see xref:web-reactive.adoc[Web on Reactive Stack].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-framework", "path": "framework-docs/modules/ROOT/pages/web.adoc", "title": "web", "heading": "web", "heading_level": 1, "file_order": 460, "section_index": 0, "content_hash": "2d8d571ecf893a9838a1f3b01fb5e7edef47c1e2b482000af799625fc6711ace", "source_url": "https://github.com/spring-projects/spring-framework/blob/22bd8bd704390ee618f19d32e5ecc6ad1cd0b39c/framework-docs/modules/ROOT/pages/web.adoc"}}
