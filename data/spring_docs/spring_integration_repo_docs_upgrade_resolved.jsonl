{"id": "sha256:e46dad15b74b2144abcfa8abda97329aed76418206e07a585adce9639cb7467d", "content": "[[alternative-confirms-returns]]\n\nWhen the connection factory is configured for publisher confirms and returns, the sections above discuss the configuration of message channels to receive the `confirms` and `returns` asynchronously.\nStarting with version 5.4, there is an additional mechanism that is generally easier to use.\n\nIn this case, do not configure a `confirm-correlation-expression` or the `confirm` and `return` channels.\nInstead, add a `CorrelationData` instance in the `AmqpHeaders.PUBLISH_CONFIRM_CORRELATION` header; you can then wait for the result(s) later, by checking the state of the future in the `CorrelationData` instances for which you have sent messages.\nThe `returnedMessage` field will always be populated (if a message is returned) before the future is completed.\n\n[source, java]\n----\nCorrelationData corr = new CorrelationData(\"someId\"); // <--- Unique \"id\" is required for returns\nsomeFlow.getInputChannel().send(MessageBuilder.withPayload(\"test\")\n .setHeader(\"rk\", \"someKeyThatWontRoute\")\n .setHeader(AmqpHeaders.PUBLISH_CONFIRM_CORRELATION, corr)\n .build());\n...\ntry {\n Confirm Confirm = corr.getFuture().get(10, TimeUnit.SECONDS);\n Message returned = corr.getReturnedMessage();\n if (returned !- null) {\n // message could not be routed\n }\n}\ncatch { ... }\n----\n\nTo improve performance, you may wish to send multiple messages and wait for the confirmations later, rather than one-at-a-time.\nThe returned message is the raw message after conversion; you can subclass a `CorrelationData` with whatever additional data you need.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/alternative-confirms-returns.adoc", "title": "alternative-confirms-returns", "heading": "alternative-confirms-returns", "heading_level": 1, "file_order": 0, "section_index": 0, "content_hash": "e46dad15b74b2144abcfa8abda97329aed76418206e07a585adce9639cb7467d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/alternative-confirms-returns.adoc"}}
{"id": "sha256:705d90cce5da410a0a522fd15665fac76c2a0a58cd0203015e2925c612ae04e0", "content": "[[amqp-1.0]]\n\nStarting with version 7.0, Spring Integration provides channel adapters for RabbitMQ AMQP 1.0 support.\nThese channel adapters are based on the `org.springframework.amqp:spring-rabbitmq-client` library.\n\nThe Spring AMQP documentation provides more details about https://docs.spring.io/spring-amqp/reference/4.0/rabbitmq-amqp-client.html[RabbitMQ AMQP 1.0 support].\n\n[[amqp-1.0-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/amqp-1.0.adoc", "title": "amqp-1.0", "heading": "amqp-1.0", "heading_level": 1, "file_order": 1, "section_index": 0, "content_hash": "705d90cce5da410a0a522fd15665fac76c2a0a58cd0203015e2925c612ae04e0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/amqp-1.0.adoc"}}
{"id": "sha256:f2a007b252bcab1adf889ff072984ad16d1e55385e44b0fbed2cb520aad272ee", "content": "The `AmqpClientMessageHandler` is an `AbstractReplyProducingMessageHandler` implementation and can act as a one-way channel adapter or as an outbound gateway depending on the `setRequiresReply()` configuration.\nThe instance of this channel adapter requires an `AsyncAmqpTemplate` implementation for AMQP 1.0 protocol, e.g. `RabbitAmqpTemplate` from the mentioned above `spring-rabbitmq-client` library.\nThis message handler is asynchronous by default; therefore, publication errors should be handled via `errorChannel` header in the request message or global default `errorChannel` in the application context.\n\nThe `exchange` to publish message (together with optional `routingKey`) is mutually exclusive with a `queue` to publish.\nIf neither is provided, then `AsyncAmqpTemplate` implementation must ensure some defaults for those destination parts; otherwise the message is going to be rejected as not delivered.\n\nBy default, the `MessageConverter` is an `org.springframework.amqp.support.converter.SimpleMessageConverter` that handles String, Serializable instances, and byte arrays.\nAlso, a default `AmqpHeaderMapper` is a xref:amqp/message-headers.adoc[`DefaultAmqpHeaderMapper.outboundMapper()`].\nThis header mapper is also used for mapping AMQP message properties to headers back on the reply.\n\nIn a gateway mode, the `replyPayloadType` could be supplied to convert a reply message body.\nHowever, the `MessageConverter` has to be an implementation of the `SmartMessageConverter` like a `JacksonJsonMessageConverter`.\nAlso, a mutually exclusive to the `replyPayloadType`, a `returnMessage` flag could be set to `true` to return the whole instance of `org.springframework.amqp.core.Message` as a reply message payload.\n\nThe following example demonstrates how to configure an `AmqpClientMessageHandler` as a simple `@ServiceActivator`:\n\n[tabs]\n======\nJava DSL::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nIntegrationFlow sendFlow(RabbitAmqpTemplate rabbitTemplate) {\n return f -> f\n .handle(AmqpClient.outboundAdapter(rabbitTemplate)\n .exchange(\"e1\")\n .routingKeyExpression(\"'k1'\"));\n}\n----\n\nKotlin DSL::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun sendFlow(rabbitTemplate: RabbitAmqpTemplate) =\n integrationFlow {\n handle(AmqpClient.outboundAdapter(rabbitTemplate)\n .apply {\n exchange(\"e1\")\n routingKeyExpression(\"'k1'\")\n }\n )\n }\n----\n\nGroovy DSL::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\nsendFlow() {\n integrationFlow {\n handle(AmqpClient.outboundAdapter(rabbitTemplate)\n .with {\n exchange 'e1'\n routingKeyExpression '''k1'''\n }\n )\n }\n}\n----\n\nJava::\n+\n[source,java,role=\"secondary\"]\n----\n@Bean\n@ServiceActivator(inputChannel = \"amqpClientSendChannel\")\nAmqpClientMessageHandler amqpClientMessageHandler(RabbitAmqpTemplate rabbitTemplate) {\n AmqpClientMessageHandler messageHandler = new AmqpClientMessageHandler(rabbitTemplate);\n messageHandler.setExchangeExpressionString(\"headers[exchange]\");\n messageHandler.setRoutingKeyExpressionString(\"headers[routingKey]\");\n return messageHandler;\n}\n----\n======\n\nThe gateway variant for the `AmqpClientMessageHandler` could be like:\n\n[tabs]\n======\nJava DSL::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nIntegrationFlow requestReplyOutboundFlow(RabbitAmqpTemplate rabbitTemplate) {\n return f -> f\n .handle(AmqpClient.outboundGateway(rabbitTemplate)\n .queueFunction(m -> \"requestReply\"));\n}\n----\n\nKotlin DSL::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun sendFlow(rabbitTemplate: RabbitAmqpTemplate) =\n integrationFlow {\n handle(AmqpClient.outboundGateway(rabbitTemplate)\n .queueFunction { \"requestReply\" }\n )\n }\n----\n\nGroovy DSL::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\nsendFlow() {\n integrationFlow {\n handle(AmqpClient.outboundGateway(rabbitTemplate)\n .with {\n queueFunction { 'requestReply' }\n }\n )\n }\n}\n----\n\nJava::\n+\n[source,java,role=\"secondary\"]\n----\n@Bean\n@ServiceActivator(inputChannel = \"amqpClientSendAndReceiveChannel\")\nAmqpClientMessageHandler amqpClientGateway(RabbitAmqpTemplate rabbitTemplate) {\n AmqpClientMessageHandler messageHandler = new AmqpClientMessageHandler(rabbitTemplate);\n messageHandler.setRequiresReply(true);\n messageHandler.setReplyPayloadType(String.class);\n messageHandler.setMessageConverter(new JacksonJsonMessageConverter());\n messageHandler.setQueue(\"q1\");\n return messageHandler;\n}\n----\n======\n\n[[amqp-1.0-message-driver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/amqp-1.0.adoc", "title": "amqp-1.0", "heading": "AMQP 1.0 Outbound Channel Adapters", "heading_level": 2, "file_order": 1, "section_index": 1, "content_hash": "f2a007b252bcab1adf889ff072984ad16d1e55385e44b0fbed2cb520aad272ee", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/amqp-1.0.adoc"}}
{"id": "sha256:f7f844b6d756d46d26962bbf621cdaa07f846fd37ec9569685122be5ef7f48e5", "content": "The `AmqpClientMessageProducer` is a `MessageProducerSupport` implementation as a Message-Driver Channel Adapter to consume messages from queues over RabbitMQ AMQP 1.0 protocol.\nIt requires an `AmqpConnectionFactory` and at least one queue to consume.\nIts logic internally is based on the `RabbitAmqpListenerContainer` and `IntegrationRabbitAmqpMessageListener` to relay consumed AMQP messages (after conversion) to the `outputChannel`.\nSome of `RabbitAmqpListenerContainer` configuration options are exposed as setters from the `AmqpClientMessageProducer`.\n\nBy default, the `MessageConverter` is an `org.springframework.amqp.support.converter.SimpleMessageConverter` that handles String, Serializable instances, and byte arrays.\nAlso, a default `AmqpHeaderMapper` is a xref:amqp/message-headers.adoc[`DefaultAmqpHeaderMapper.inboundMapper()`].\nThe `messageConverter` option can be set to `null` to fully skip conversion (including header mapping), and return the received AMQP message as a payload of the Spring message to produce.\n\nAlso, the `AmqpClientMessageProducer` implements a `Pausable` contract and delegates to the respective `RabbitAmqpListenerContainer` API.\n\nWhen `AmqpClientMessageProducer.setBatchSize() > 1`, this channel adapter works in a batch mode.\nIn this case received messages are gathered until the batch size is fulfilled, or `batchReceiveTimeout` period is exhausted.\nAll the batched AMQP messages then converted to Spring messages, and a result list is produced as a payload of a wrapping message to send to the `outputChannel`.\nThe batch mode gives some performance gain due to the settlement for all the batched messages at once.\n\nWhen `autoSettle` flag is set to `false`, the `AcknowledgmentCallback` instance is provided as an `IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK` message header to make settlement decision for the received message or the whole batch.\n\nThe following example demonstrates how to configure an `AmqpClientMessageProducer` as a simple inbound endpoint:\n\n[tabs]\n======\nJava DSL::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nIntegrationFlow receiveFlow(AmqpConnectionFactory connectionFactory) {\n return IntegrationFlow.from(AmqpClient.inboundChannelAdapter(connectionFactory, \"q1\"))\n .channel(c -> c.queue(\"receiveChannel\"))\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun receiveFlow(connectionFactory: AmqpConnectionFactory) =\n integrationFlow(AmqpClient.inboundChannelAdapter(connectionFactory, \"q1\")) {\n channel(\"inputChannel\")\n }\n----\n\nGroovy DSL::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\nreceiveFlow(AmqpConnectionFactory connectionFactory) {\n integrationFlow(AmqpClient.inboundChannelAdapter(connectionFactory, 'q1')) {\n channel 'inputChannel'\n }\n}\n----\n\nJava::\n+\n[source,java,role=\"secondary\"]\n----\n@Bean\nAmqpClientMessageProducer batchAmqpClientMessageProducer(AmqpConnectionFactory connectionFactory,\n QueueChannel inputChannel) {\n\n AmqpClientMessageProducer amqpClientMessageProducer = new AmqpClientMessageProducer(connectionFactory, \"q3\");\n amqpClientMessageProducer.setOutputChannel(inputChannel);\n amqpClientMessageProducer.setBatchSize(2);\n return amqpClientMessageProducer;\n}\n----\n======\n\n[[amqp-1.0-inbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/amqp-1.0.adoc", "title": "amqp-1.0", "heading": "AMQP 1.0 Message-Driver Channel Adapter", "heading_level": 2, "file_order": 1, "section_index": 2, "content_hash": "f7f844b6d756d46d26962bbf621cdaa07f846fd37ec9569685122be5ef7f48e5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/amqp-1.0.adoc"}}
{"id": "sha256:c62c75193b4ba5a3bd6057752510c60aa0ef2287bde0f71bc416d76c079fa7ed", "content": "The `AmqpClientInboundGateway` is a `MessagingGatewaySupport` implementation for receiving request and producing replies over RabbitMQ AMQP 1.0 protocol.\nIt is similar to the `AmqpClientMessageProducer` mentioned above and share many `RabbitAmqpListenerContainer` configuration options.\nIn addition, to produce AMQP 1.0 replies, the `AmqpClientInboundGateway` uses internally a `RabbitAmqpTemplate`.\n\nFor automatic replies correlation with their requests, a `replyTo` property of the request message must be supplied.\nFor example, the `RabbitAmqpTemplate.sendAndReceive()` relies on the `RpcClient` from RabbitMQ AMQP 1.0 library which generates an exclusive and auto-deleted queue.\nAlternatively, the reply address could be set as a `replyExchange`(and optional `replyRoutingKey`) or `replyQueue` (but not both) on the `AmqpClientInboundGateway` which are delegated to the `RabbitAmqpTemplate` default options.\nThe `messageId` or `correlationId` request message properties can be used for associating with replies.\nThe `RpcClient` in the `RabbitAmqpTemplate.sendAndReceive()` generates one if missed.\nThe `AmqpClientInboundGateway` is able to map back such a correlation key into a reply message.\n\nThe following example demonstrates how to configure an `AmqpClientInboundGateway` as a simple inbound gateway:\n\n[tabs]\n======\nJava DSL::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nIntegrationFlow amqpClientInboundGatewayFlow(AmqpConnectionFactory connectionFactory) {\n return IntegrationFlow.from(AmqpClient.inboundGateway(connectionFactory, \"requestReply\"))\n .channel(c -> c.queue(\"inputChannel\"))\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun receiveFlow(connectionFactory: AmqpConnectionFactory) =\n integrationFlow(AmqpClient.inboundGateway(connectionFactory, \"requestReply\")) {\n channel { queue(\"inputChannel\") }\n }\n----\n\nGroovy DSL::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\nreceiveFlow(AmqpConnectionFactory connectionFactory) {\n integrationFlow(AmqpClient.inboundGateway(connectionFactory, 'requestReply')) {\n channel { queue 'inputChannel' }\n }\n}\n----\n\nJava::\n+\n[source,java,role=\"secondary\"]\n----\n@Bean\nAmqpClientInboundGateway amqpClientInboundGateway(AmqpConnectionFactory connectionFactory) {\n AmqpClientInboundGateway amqpClientInboundGateway = new AmqpClientInboundGateway(connectionFactory, \"requestReply\");\n amqpClientInboundGateway.setRequestChannelName(\"inputChannel\");\n return amqpClientInboundGateway;\n}\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/amqp-1.0.adoc", "title": "amqp-1.0", "heading": "AMQP 1.0 Inbound Gateway", "heading_level": 2, "file_order": 1, "section_index": 3, "content_hash": "c62c75193b4ba5a3bd6057752510c60aa0ef2287bde0f71bc416d76c079fa7ed", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/amqp-1.0.adoc"}}
{"id": "sha256:d591cd17f567d5b5e05b59f6aa74ccb5c0f4b47e806b1f48e119d99858b1249c", "content": "[[amqp-async-outbound-gateway]]\n\nThe gateway discussed in the previous section is synchronous, in that the sending thread is suspended until a\nreply is received (or a timeout occurs).\nSpring Integration version 4.3 added an asynchronous gateway, which uses the `AsyncRabbitTemplate` from Spring AMQP.\nWhen a message is sent, the thread returns immediately after the send operation completes, and, when the message is received, the reply is sent on the template's listener container thread.\nThis can be useful when the gateway is invoked on a poller thread.\nThe thread is released and is available for other tasks in the framework.\n\nThe following listing shows the possible configuration options for an AMQP asynchronous outbound gateway:\n\n[tabs]\n======\nJava DSL::\n+\n[source,java,role=\"primary\"]\n----\n@Configuration\npublic class AmqpAsyncApplication {\n\n @Bean\n public IntegrationFlow asyncAmqpOutbound(AsyncRabbitTemplate asyncRabbitTemplate) {\n return f -> f\n .handle(Amqp.asyncOutboundGateway(asyncRabbitTemplate)\n .routingKey(\"queue1\")); // default exchange - route to queue 'queue1'\n }\n\n @MessagingGateway(defaultRequestChannel = \"asyncAmqpOutbound.input\")\n public interface MyGateway {\n\n String sendToRabbit(String data);\n\n }\n\n}\n----\n\nJava::\n+\n[source,java,role=\"secondary\"]\n----\n@Configuration\npublic class AmqpAsyncConfig {\n\n @Bean\n @ServiceActivator(inputChannel = \"amqpOutboundChannel\")\n public AsyncAmqpOutboundGateway amqpOutbound(AsyncRabbitTemplate asyncTemplate) {\n AsyncAmqpOutboundGateway outbound = new AsyncAmqpOutboundGateway(asyncTemplate);\n outbound.setRoutingKey(\"foo\"); // default exchange - route to queue 'foo'\n return outbound;\n }\n\n @Bean\n public AsyncRabbitTemplate asyncTemplate(RabbitTemplate rabbitTemplate,\n SimpleMessageListenerContainer replyContainer) {\n\n return new AsyncRabbitTemplate(rabbitTemplate, replyContainer);\n }\n\n @Bean\n public SimpleMessageListenerContainer replyContainer() {\n SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(ccf);\n container.setQueueNames(\"asyncRQ1\");\n return container;\n }\n\n @Bean\n public MessageChannel amqpOutboundChannel() {\n return new DirectChannel();\n }\n\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<int-amqp:outbound-async-gateway id=\"asyncOutboundGateway\" <1>\n request-channel=\"myRequestChannel\" <2>\n async-template=\"\" <3>\n exchange-name=\"\" <4>\n exchange-name-expression=\"\" <5>\n order=\"1\" <6>\n reply-channel=\"\" <7>\n reply-timeout=\"\" <8>\n requires-reply=\"\" <9>\n routing-key=\"\" <10>\n routing-key-expression=\"\" <11>\n default-delivery-mode\"\" <12>\n confirm-correlation-expression=\"\" <13>\n confirm-ack-channel=\"\" <14>\n confirm-nack-channel=\"\" <15>\n confirm-timeout=\"\" <16>\n return-channel=\"\" <17>\n lazy-connect=\"true\" /> <18>\n\n----\n======\n\n<1> The unique ID for this adapter.\nOptional.\n<2> Message channel to which messages should be sent in order to have them converted and published to an AMQP exchange.\nRequired.\n<3> Bean reference to the configured `AsyncRabbitTemplate`.\nOptional (it defaults to `asyncRabbitTemplate`).\n<4> The name of the AMQP exchange to which messages should be sent.\nIf not provided, messages are sent to the default, no-name exchange.\nMutually exclusive with 'exchange-name-expression'.\nOptional.\n<5> A SpEL expression that is evaluated to determine the name of the AMQP exchange to which messages are sent, with the message as the root object.\nIf not provided, messages are sent to the default, no-name exchange.\nMutually exclusive with 'exchange-name'.\nOptional.\n<6> The order for this consumer when multiple consumers are registered, thereby enabling load-balancing and failover.\nOptional (it defaults to `Ordered.LOWEST_PRECEDENCE [=Integer.MAX_VALUE]`).\n<7> Message channel to which replies should be sent after being received from an AMQP queue and converted.\nOptional.\n<8> The time the gateway waits when sending the reply message to the `reply-channel`.\nThis only applies if the `reply-channel` can block -- such as a `QueueChannel` with a capacity limit that is currently full.\nThe default is infinity.\n<9> When no reply message is received within the `AsyncRabbitTemplate`'s `receiveTimeout` property and this setting is `true`, the gateway sends an error message to the inbound message's `errorChannel` header.\nWhen no reply message is received within the `AsyncRabbitTemplate`'s `receiveTimeout` property and this setting is `false`, the gateway sends an error message to the default `errorChannel` (if available).\nIt defaults to `true`.\n<10> The routing-key to use when sending Messages.\nBy default, this is an empty `String`.\nMutually exclusive with 'routing-key-expression'.\nOptional.\n<11> A SpEL expression that is evaluated to determine the routing-key to use when sending messages,\nwith the message as the root object, (for example, `payload.key`).\nBy default, this is an empty `String`.\nMutually exclusive with `routing-key`.\nOptional.\n<12> The default delivery mode for messages: `PERSISTENT` or `NON_PERSISTENT`.\nOverridden if the `header-mapper` sets the delivery mode.\nIf the Spring Integration message header (`amqp_deliveryMode`) is present, the `DefaultHeaderMapper` sets the value.\nIf this attribute is not supplied and the header mapper does not set it, the default depends on the underlying Spring AMQP `MessagePropertiesConverter` used by the `RabbitTemplate`.\nIf that is not customized, the default is `PERSISTENT`.\nOptional.\n<13> An expression that defines correlation data.\nWhen provided, this configures the underlying AMQP template to receive publisher confirmations.\nRequires a dedicated `RabbitTemplate` and a `CachingConnectionFactory` with its `publisherConfirms` property set to `true`.\nWhen a publisher confirmation is received and correlation data is supplied, the confirmation is written to either the `confirm-ack-channel` or the `confirm-nack-channel`, depending on the confirmation type.\nThe payload of the confirmation is the correlation data as defined by this expression, and the message has its 'amqp_publishConfirm' header set to `true` (`ack`) or `false` (`nack`).\nFor `nack` instances, an additional header (`amqp_publishConfirmNackCause`) is provided.\nExamples: `headers['myCorrelationData']`, `payload`.\nIf the expression resolves to a `Message<?>` instance (such as \"`#this`\"), the message emitted on the `ack`/`nack` channel is based on that message, with the additional headers added.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nOptional.\n<14> The channel to which positive (`ack`) publisher confirmations are sent.\nThe payload is the correlation data defined by the `confirm-correlation-expression`.\nRequires the underlying `AsyncRabbitTemplate` to have its `enableConfirms` property set to `true`.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nOptional (the default is `nullChannel`).\n<15> Since version 4.2.\nThe channel to which negative (`nack`) publisher confirmations are sent.\nThe payload is the correlation data defined by the `confirm-correlation-expression`.\nRequires the underlying `AsyncRabbitTemplate` to have its `enableConfirms` property set to `true`.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nOptional (the default is `nullChannel`).\n<16> When set, the gateway will synthesize a negative acknowledgment (nack) if a publisher confirm is not received within this time in milliseconds.\nPending confirms are checked every 50% of this value, so the actual time a nack is sent will be between 1x and 1.5x this value.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nDefault none (nacks will not be generated).\n<17> The channel to which returned messages are sent.\nWhen provided, the underlying AMQP template is configured to return undeliverable messages to the gateway.\nThe message is constructed from the data received from AMQP, with the following additional headers: `amqp_returnReplyCode`, `amqp_returnReplyText`, `amqp_returnExchange`, and `amqp_returnRoutingKey`.\nRequires the underlying `AsyncRabbitTemplate` to have its `mandatory` property set to `true`.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nOptional.\n<18> When set to `false`, the endpoint tries to connect to the broker during application context initialization.\nDoing so allows \"`fail fast`\" detection of bad configuration by logging an error message if the broker is down.\nWhen `true` (the default), the connection is established (if it does not already exist because some other component established\nit) when the first message is sent.\n\nSee also xref:service-activator.adoc#async-service-activator[Asynchronous Service Activator] for more information.\n\n[IMPORTANT]\n.RabbitTemplate\n====\nWhen you use confirmations and returns, we recommend that the `RabbitTemplate` wired into the `AsyncRabbitTemplate` be dedicated.\nOtherwise, unexpected side effects may be encountered.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/async-outbound-gateway.adoc", "title": "async-outbound-gateway", "heading": "async-outbound-gateway", "heading_level": 1, "file_order": 2, "section_index": 0, "content_hash": "d591cd17f567d5b5e05b59f6aa74ccb5c0f4b47e806b1f48e119d99858b1249c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/async-outbound-gateway.adoc"}}
{"id": "sha256:99f78f598d9bbf83bdb18925e1ce4808b02e79b4f9d110c6c700fb08944312db", "content": "[[amqp-channels]]\n\nThere are two message channel implementations available.\nOne is `point-to-point`, and the other is `publish-subscribe`.\nBoth of these channels provide a wide range of configuration attributes for the underlying `AmqpTemplate` and `SimpleMessageListenerContainer` (as shown earlier in this chapter for the channel adapters and gateways).\nHowever, the examples we show here have minimal configuration.\nExplore the XML schema to view the available attributes.\n\nA point-to-point channel might look like the following example:\n\n[source,xml]\n----\n<int-amqp:channel id=\"p2pChannel\"/>\n----\n\nUnder the covers, the preceding example causes a `Queue` named `si.p2pChannel` to be declared, and this channel sends to that `Queue` (technically, by sending to the no-name direct exchange with a routing key that matches the name of this `Queue`).\nThis channel also registers a consumer on that `Queue`.\nIf you want the channel to be \"`pollable`\" instead of message-driven, provide the `message-driven` flag with a value of `false`, as the following example shows:\n\n[source,xml]\n----\n<int-amqp:channel id=\"p2pPollableChannel\" message-driven=\"false\"/>\n----\n\nA publish-subscribe channel might look like the following:\n\n[source,xml]\n----\n<int-amqp:publish-subscribe-channel id=\"pubSubChannel\"/>\n----\n\nUnder the covers, the preceding example causes a fanout exchange named `si.fanout.pubSubChannel` to be declared, and this channel sends to that fanout exchange.\nThis channel also declares a server-named exclusive, auto-delete, non-durable `Queue` and binds that to the fanout exchange while registering a consumer on that `Queue` to receive messages.\nThere is no \"`pollable`\" option for a publish-subscribe-channel.\nIt must be message-driven.\n\nStarting with version 4.1, AMQP-backed message channels (in conjunction with `channel-transacted`) support\n`template-channel-transacted` to separate `transactional` configuration for the `AbstractMessageListenerContainer` and\nfor the `RabbitTemplate`.\nNote that, previously, `channel-transacted` was `true` by default.\nNow, by default, it is `false` for the `AbstractMessageListenerContainer`.\n\nPrior to version 4.3, AMQP-backed channels only supported messages with `Serializable` payloads and headers.\nThe entire message was converted, (serialized) and sent to RabbitMQ.\nNow, you can set the `extract-payload` attribute (or `setExtractPayload()` when using Java configuration) to `true`.\nWhen this flag is `true`, the message payload is converted and the headers are mapped, in a manner similar to when you use channel adapters.\nThis arrangement lets AMQP-backed channels be used with non-serializable payloads (perhaps with another message converter, such as the `Jackson2JsonMessageConverter`).\nSee xref:amqp/message-headers.adoc[AMQP Message Headers] for more about the default mapped headers.\nYou can modify the mapping by providing custom mappers that use the `outbound-header-mapper` and `inbound-header-mapper` attributes.\nYou can now also specify a `default-delivery-mode`, which is used to set the delivery mode when there is no `amqp_deliveryMode` header.\nBy default, Spring AMQP `MessageProperties` uses `PERSISTENT` delivery mode.\n\nIMPORTANT: As with other persistence-backed channels, AMQP-backed channels are intended to provide message persistence to avoid message loss.\nThey are not intended to distribute work to other peer applications.\nFor that purpose, use channel adapters instead.\n\nIMPORTANT: Starting with version 5.0, the pollable channel now blocks the poller thread for the specified `receiveTimeout` (the default is 1 second).\nPreviously, unlike other `PollableChannel` implementations, the thread returned immediately to the scheduler if no message was available, regardless of the receive timeout.\nBlocking is a little more expensive than using a `basicGet()` to retrieve a message (with no timeout), because a consumer has to be created to receive each message.\nTo restore the previous behavior, set the poller's `receiveTimeout` to 0.\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/channels.adoc", "title": "channels", "heading": "channels", "heading_level": 1, "file_order": 3, "section_index": 0, "content_hash": "99f78f598d9bbf83bdb18925e1ce4808b02e79b4f9d110c6c700fb08944312db", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/channels.adoc"}}
{"id": "sha256:920f00c13c3b62e4c85e1b0d495b4f39e9eeadc58a2996c97e412237be15b2ff", "content": "The following example shows how to configure the channels with Java configuration:\n\n[source, java]\n----\n@Bean\npublic AmqpChannelFactoryBean pollable(ConnectionFactory connectionFactory) {\n AmqpChannelFactoryBean factoryBean = new AmqpChannelFactoryBean();\n factoryBean.setConnectionFactory(connectionFactory);\n factoryBean.setQueueName(\"foo\");\n factoryBean.setPubSub(false);\n return factoryBean;\n}\n\n@Bean\npublic AmqpChannelFactoryBean messageDriven(ConnectionFactory connectionFactory) {\n AmqpChannelFactoryBean factoryBean = new AmqpChannelFactoryBean(true);\n factoryBean.setConnectionFactory(connectionFactory);\n factoryBean.setQueueName(\"bar\");\n factoryBean.setPubSub(false);\n return factoryBean;\n}\n\n@Bean\npublic AmqpChannelFactoryBean pubSub(ConnectionFactory connectionFactory) {\n AmqpChannelFactoryBean factoryBean = new AmqpChannelFactoryBean(true);\n factoryBean.setConnectionFactory(connectionFactory);\n factoryBean.setQueueName(\"baz\");\n factoryBean.setPubSub(false);\n return factoryBean;\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/channels.adoc", "title": "channels", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 3, "section_index": 1, "content_hash": "920f00c13c3b62e4c85e1b0d495b4f39e9eeadc58a2996c97e412237be15b2ff", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/channels.adoc"}}
{"id": "sha256:1035a8136e33a0eadfb199044e1a1dc8446daf796451c49da86450076574eaf9", "content": "The following example shows how to configure the channels with the Java DSL:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow pollableInFlow(ConnectionFactory connectionFactory) {\n return IntegrationFlow.from(...)\n ...\n .channel(Amqp.pollableChannel(connectionFactory)\n .queueName(\"foo\"))\n ...\n .get();\n}\n\n@Bean\npublic IntegrationFlow messageDrivenInFow(ConnectionFactory connectionFactory) {\n return IntegrationFlow.from(...)\n ...\n .channel(Amqp.channel(connectionFactory)\n .queueName(\"bar\"))\n ...\n .get();\n}\n\n@Bean\npublic IntegrationFlow pubSubInFlow(ConnectionFactory connectionFactory) {\n return IntegrationFlow.from(...)\n ...\n .channel(Amqp.publishSubscribeChannel(connectionFactory)\n .queueName(\"baz\"))\n ...\n .get();\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/channels.adoc", "title": "channels", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 3, "section_index": 2, "content_hash": "1035a8136e33a0eadfb199044e1a1dc8446daf796451c49da86450076574eaf9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/channels.adoc"}}
{"id": "sha256:d6ec0e27c6ed4979cb1479cfa9b968f359ae8e807b157500774d18d08f0ad69a", "content": "[[content-type-conversion-outbound]]\n\nSpring AMQP 1.4 introduced the `ContentTypeDelegatingMessageConverter`, where the actual converter is selected based\non the incoming content type message property.\nThis can be used by inbound endpoints.\n\nAs of Spring Integration version 4.3, you can use the `ContentTypeDelegatingMessageConverter` on outbound endpoints as well, with the `contentType` header specifying which converter is used.\n\nThe following example configures a `ContentTypeDelegatingMessageConverter`, with the default converter being the `SimpleMessageConverter` (which handles Java serialization and plain text), together with a JSON converter:\n\n[source, xml]\n----\n<amqp:outbound-channel-adapter id=\"withContentTypeConverter\" channel=\"ctRequestChannel\"\n exchange-name=\"someExchange\"\n routing-key=\"someKey\"\n amqp-template=\"amqpTemplateContentTypeConverter\" />\n\n<int:channel id=\"ctRequestChannel\"/>\n\n<rabbit:template id=\"amqpTemplateContentTypeConverter\"\n connection-factory=\"connectionFactory\" message-converter=\"ctConverter\" />\n\n<bean id=\"ctConverter\"\n class=\"o.s.amqp.support.converter.ContentTypeDelegatingMessageConverter\">\n <property name=\"delegates\">\n <map>\n <entry key=\"application/json\">\n <bean class=\"o.s.amqp.support.converter.Jackson2JsonMessageConverter\" />\n </entry>\n </map>\n </property>\n</bean>\n----\n\nSending a message to `ctRequestChannel` with the `contentType` header set to `application/json` causes the JSON converter to be selected.\n\nThis applies to both the outbound channel adapter and gateway.\n\n[NOTE]\n====\nStarting with version 5.0, headers that are added to the `MessageProperties` of the outbound message are never overwritten by mapped headers (by default).\nPreviously, this was only the case if the message converter was a `ContentTypeDelegatingMessageConverter` (in that case, the header was mapped first so that the proper converter could be selected).\nFor other converters, such as the `SimpleMessageConverter`, mapped headers overwrote any headers added by the converter.\nThis caused problems when an outbound message had some leftover `contentType` headers (perhaps from an inbound channel adapter) and the correct outbound `contentType` was incorrectly overwritten.\nThe work-around was to use a header filter to remove the header before sending the message to the outbound endpoint.\n\nThere are, however, cases where the previous behavior is desired -- for example, when a `String` payload that contains JSON, the `SimpleMessageConverter` is not aware of the content and sets the `contentType` message property to `text/plain` but your application would like to override that to `application/json` by setting the `contentType` header of the message sent to the outbound endpoint.\nThe `ObjectToJsonTransformer` does exactly that (by default).\n\nThere is now a property called `headersMappedLast` on the outbound channel adapter and gateway (as well as on AMQP-backed channels).\nSetting this to `true` restores the behavior of overwriting the property added by the converter.\n\nStarting with version 5.1.9, a similar `replyHeadersMappedLast` is provided for the `AmqpInboundGateway` when we produce a reply and would like to override headers populated by the converter.\nSee its Javadocs for more information.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/content-type-conversion-outbound.adoc", "title": "content-type-conversion-outbound", "heading": "content-type-conversion-outbound", "heading_level": 1, "file_order": 4, "section_index": 0, "content_hash": "d6ec0e27c6ed4979cb1479cfa9b968f359ae8e807b157500774d18d08f0ad69a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/content-type-conversion-outbound.adoc"}}
{"id": "sha256:7c864a3a73f19c04eabd146f6997b946fb806c60f45e5238a76fbef75daeff1a", "content": "[[amqp-conversion-inbound]]\n\nInbound messages, arriving at the channel adapter or gateway, are converted to the `spring-messaging` `Message<?>` payload using a message converter.\nBy default, a `SimpleMessageConverter` is used, which handles java serialization and text.\nHeaders are mapped using the `DefaultHeaderMapper.inboundMapper()` by default.\nIf a conversion error occurs, and there is no error channel defined, the exception is thrown to the container and handled by the listener container's error handler.\nThe default error handler treats conversion errors as fatal, and the message will be rejected (and routed to a dead-letter exchange if the queue is so configured).\nIf an error channel is defined, the `ErrorMessage` payload is a `ListenerExecutionFailedException` with properties `failedMessage` (the Spring AMQP message that could not be converted) and the `cause`.\nIf the container `AcknowledgeMode` is `AUTO` (the default) and the error flow consumes the error without throwing an exception, the original message will be acknowledged.\nIf the error flow throws an exception, the exception type, in conjunction with the container's error handler, will determine whether the message is requeued.\nIf the container is configured with `AcknowledgeMode.MANUAL`, the payload is a `ManualAckListenerExecutionFailedException` with additional properties `channel` and `deliveryTag`.\nThis enables the error flow to call `basicAck` or `basicNack` (or `basicReject`) for the message, to control its disposition.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/conversion-inbound.adoc", "title": "conversion-inbound", "heading": "conversion-inbound", "heading_level": 1, "file_order": 5, "section_index": 0, "content_hash": "7c864a3a73f19c04eabd146f6997b946fb806c60f45e5238a76fbef75daeff1a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/conversion-inbound.adoc"}}
{"id": "sha256:4165ae252f40890e3bb67a071cb7e3b861814f93efb7cf58b7bcabe73c19d043", "content": "[[amqp-delay]]\n\nSpring AMQP supports the https://docs.spring.io/spring-amqp/reference/html/#delayed-message-exchange[RabbitMQ Delayed Message Exchange Plugin].\nFor inbound messages, the `x-delay` header is mapped to the `AmqpHeaders.RECEIVED_DELAY` header.\nSetting the `AMQPHeaders.DELAY` header causes the corresponding `x-delay` header to be set in outbound messages.\nYou can also specify the `delay` and `delayExpression` properties on outbound endpoints (`delay-expression` when using XML configuration).\nThese properties take precedence over the `AmqpHeaders.DELAY` header.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/delay.adoc", "title": "delay", "heading": "delay", "heading_level": 1, "file_order": 6, "section_index": 0, "content_hash": "4165ae252f40890e3bb67a071cb7e3b861814f93efb7cf58b7bcabe73c19d043", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/delay.adoc"}}
{"id": "sha256:4ad1ab60c0b0007bf07286d9e88e5282e28acf45cddf5f08099a784e7e1a608f", "content": "[[amqp-inbound-ack]]\n\nBy default, the inbound endpoints use the `AUTO` acknowledge mode, which means the container automatically acknowledges the message when the downstream integration flow completes (or a message is handed off to another thread by using a `QueueChannel` or `ExecutorChannel`).\nSetting the mode to `NONE` configures the consumer such that acknowledgments are not used at all (the broker automatically acknowledges the message as soon as it is sent).\nSetting the mode to `MANUAL` lets user code acknowledge the message at some other point during processing.\nTo support this, with this mode, the endpoints provide the `Channel` and `deliveryTag` in the `amqp_channel` and `amqp_deliveryTag` headers, respectively.\n\nYou can perform any valid Rabbit command on the `Channel` but, generally, only `basicAck` and `basicNack` (or `basicReject`) are used.\nIn order to not interfere with the operation of the container, you should not retain a reference to the channel and use it only in the context of the current message.\n\nNOTE: Since the `Channel` is a reference to a \"`live`\" object, it cannot be serialized and is lost if a message is persisted.\n\nThe following example shows how you might use `MANUAL` acknowledgement:\n\n[source,java]\n----\n@ServiceActivator(inputChannel = \"foo\", outputChannel = \"bar\")\npublic Object handle(@Payload String payload, @Header(AmqpHeaders.CHANNEL) Channel channel,\n @Header(AmqpHeaders.DELIVERY_TAG) Long deliveryTag) throws Exception {\n\n // Do some processing\n\n if (allOK) {\n channel.basicAck(deliveryTag, false);\n\n // perhaps do some more processing\n\n }\n else {\n channel.basicNack(deliveryTag, false, true);\n }\n return someResultForDownStreamProcessing;\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/inbound-ack.adoc", "title": "inbound-ack", "heading": "inbound-ack", "heading_level": 1, "file_order": 7, "section_index": 0, "content_hash": "4ad1ab60c0b0007bf07286d9e88e5282e28acf45cddf5f08099a784e7e1a608f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/inbound-ack.adoc"}}
{"id": "sha256:2d1fd90a2b0697580311eb622322aec38d41e9ba17e3483879277364898cdb1f", "content": "[[amqp-inbound-channel-adapter]]\n\nThe following listing shows the possible configuration options for an AMQP Inbound Channel Adapter:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow amqpInbound(ConnectionFactory connectionFactory) {\n return IntegrationFlow.from(Amqp.inboundAdapter(connectionFactory, \"aName\"))\n .handle(m -> System.out.println(m.getPayload()))\n .get();\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\npublic MessageChannel amqpInputChannel() {\n return new DirectChannel();\n}\n\n@Bean\npublic AmqpInboundChannelAdapter inbound(SimpleMessageListenerContainer listenerContainer,\n @Qualifier(\"amqpInputChannel\") MessageChannel channel) {\n AmqpInboundChannelAdapter adapter = new AmqpInboundChannelAdapter(listenerContainer);\n adapter.setOutputChannel(channel);\n return adapter;\n}\n\n@Bean\npublic SimpleMessageListenerContainer container(ConnectionFactory connectionFactory) {\n SimpleMessageListenerContainer container =\n new SimpleMessageListenerContainer(connectionFactory);\n container.setQueueNames(\"aName\");\n container.setConcurrentConsumers(2);\n // ...\n return container;\n}\n\n@Bean\n@ServiceActivator(inputChannel = \"amqpInputChannel\")\npublic MessageHandler handler() {\n return new MessageHandler() {\n\n @Override\n public void handleMessage(Message<?> message) throws MessagingException {\n System.out.println(message.getPayload());\n }\n\n };\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-amqp:inbound-channel-adapter\n id=\"inboundAmqp\" <1>\n channel=\"inboundChannel\" <2>\n queue-names=\"si.test.queue\" <3>\n acknowledge-mode=\"AUTO\" <4>\n advice-chain=\"\" <5>\n channel-transacted=\"\" <6>\n concurrent-consumers=\"\" <7>\n connection-factory=\"\" <8>\n error-channel=\"\" <9>\n expose-listener-channel=\"\" <10>\n header-mapper=\"\" <11>\n mapped-request-headers=\"\" <12>\n listener-container=\"\" <13>\n message-converter=\"\" <14>\n message-properties-converter=\"\" <15>\n phase=\"\" <16>\n prefetch-count=\"\" <17>\n receive-timeout=\"\" <18>\n recovery-interval=\"\" <19>\n missing-queues-fatal=\"\" <20>\n shutdown-timeout=\"\" <21>\n task-executor=\"\" <22>\n transaction-attribute=\"\" <23>\n transaction-manager=\"\" <24>\n batch-size=\"\" <25>\n consumers-per-queue <26>\n batch-mode=\"MESSAGES\"/> <27>\n----\n======\n<1> The unique ID for this adapter.\nOptional.\n<2> Message channel to which converted messages should be sent.\nRequired.\n<3> Names of the AMQP queues (comma-separated list) from which messages should be consumed.\nRequired.\n<4> Acknowledge mode for the `MessageListenerContainer`.\nWhen set to `MANUAL`, the delivery tag and channel are provided in message headers `amqp_deliveryTag` and `amqp_channel`, respectively.\nThe user application is responsible for acknowledgement.\n`NONE` means no acknowledgements (`autoAck`).\n`AUTO` means the adapter's container acknowledges when the downstream flow completes.\nOptional (defaults to AUTO).\nSee xref:amqp/inbound-ack.adoc[Inbound Endpoint Acknowledge Mode].\n<5> Extra AOP Advices to handle cross-cutting behavior associated with this inbound channel adapter.\nOptional.\n<6> Flag to indicate that channels created by this component are transactional.\nIf true, it tells the framework to use a transactional channel and to end all operations (send or receive) with a commit or rollback, depending on the outcome, with an exception that signals a rollback.\nOptional (Defaults to false).\n<7> Specify the number of concurrent consumers to create.\nThe default is `1`.\nWe recommend raising the number of concurrent consumers to scale the consumption of messages coming in from a queue.\nHowever, note that any ordering guarantees are lost once multiple consumers are registered.\nIn general, use one consumer for low-volume queues.\nNot allowed when 'consumers-per-queue' is set.\nOptional.\n<8> Bean reference to the RabbitMQ `ConnectionFactory`.\nOptional (defaults to `connectionFactory`).\n<9> Message channel to which error messages should be sent.\nOptional.\n<10> Whether the listener channel (com.rabbitmq.client.Channel) is exposed to a registered `ChannelAwareMessageListener`.\nOptional (defaults to true).\n<11> A reference to an `AmqpHeaderMapper` to use when receiving AMQP Messages.\nOptional.\nBy default, only standard AMQP properties (such as `contentType`) are copied to Spring Integration `MessageHeaders`.\nAny user-defined headers within the AMQP `MessageProperties` are NOT copied to the message by the default `DefaultAmqpHeaderMapper`.\nNot allowed if `request-header-names` is provided.\n<12> Comma-separated list of the names of AMQP Headers to be mapped from the AMQP request into the `MessageHeaders`.\nThis can only be provided if the 'header-mapper' reference is not provided.\nThe values in this list can also be simple patterns to be matched against the header names (such as \"\\*\" or \"thing1*, thing2\" or \"*something\").\n<13> Reference to the `AbstractMessageListenerContainer` to use for receiving AMQP Messages.\nIf this attribute is provided, no other attribute related to the listener container configuration should be provided.\nIn other words, by setting this reference, you must take full responsibility for the listener container configuration.\nThe only exception is the `MessageListener` itself.\nSince that is actually the core responsibility of this channel adapter implementation, the referenced listener container must not yet have its own `MessageListener`.\nOptional.\n<14> The `MessageConverter` to use when receiving AMQP messages.\nOptional.\n<15> The `MessagePropertiesConverter` to use when receiving AMQP messages.\nOptional.\n<16> Specifies the phase in which the underlying `AbstractMessageListenerContainer` should be started and stopped.\nThe startup order proceeds from lowest to highest, and the shutdown order is the reverse of that.\nBy default, this value is `Integer.MAX_VALUE`, meaning that this container starts as late as possible and stops as soon as possible.\nOptional.\n<17> Tells the AMQP broker how many messages to send to each consumer in a single request.\nOften, you can set this value high to improve throughput.\nIt should be greater than or equal to the transaction size (see the `batch-size` attribute, later in this list).\nOptional (defaults to `1`).\n<18> Receive timeout in milliseconds.\nOptional (defaults to `1000`).\n<19> Specifies the interval between recovery attempts of the underlying `AbstractMessageListenerContainer` (in milliseconds).\nOptional (defaults to `5000`).\n<20> If 'true' and none of the queues are available on the broker, the container throws a fatal exception during startup and stops if the queues are deleted when the container is running (after making three attempts to passively declare the queues).\nIf `false`, the container does not throw an exception and goes into recovery mode, attempting to restart according to the `recovery-interval`.\nOptional (defaults to `true`).\n<21> The time to wait for workers (in milliseconds) after the underlying `AbstractMessageListenerContainer` is stopped and before the AMQP connection is forced closed.\nIf any workers are active when the shutdown signal comes, they are allowed to finish processing as long as they can finish within this timeout.\nOtherwise, the connection is closed and messages remain unacknowledged (if the channel is transactional).\nOptional (defaults to `5000`).\n<22> By default, the underlying `AbstractMessageListenerContainer` uses a `SimpleAsyncTaskExecutor` implementation, that fires up a new thread for each task, running it asynchronously.\nBy default, the number of concurrent threads is unlimited.\nNote that this implementation does not reuse threads.\nConsider using a thread-pooling `TaskExecutor` implementation as an alternative.\nOptional (defaults to `SimpleAsyncTaskExecutor`).\n<23> By default, the underlying `AbstractMessageListenerContainer` creates a new instance of the `DefaultTransactionAttribute` (it takes the EJB approach to rolling back on runtime but not checked exceptions).\nOptional (defaults to `DefaultTransactionAttribute`).\n<24> Sets a bean reference to an external `PlatformTransactionManager` on the underlying `AbstractMessageListenerContainer`.\nThe transaction manager works in conjunction with the `channel-transacted` attribute.\nIf there is already a transaction in progress when the framework is sending or receiving a message and the `channelTransacted` flag is `true`, the commit or rollback of the messaging transaction is deferred until the end of the current transaction.\nIf the `channelTransacted` flag is `false`, no transaction semantics apply to the messaging operation (it is auto-acked).\nFor further information, see https://docs.spring.io/spring-amqp/reference/html/%255Freference.html#%5Ftransactions[Transactions with Spring AMQP].\nOptional.\n<25> Tells the `SimpleMessageListenerContainer` how many messages to process in a single request.\nFor best results, it should be less than or equal to the value set in `prefetch-count`.\nNot allowed when 'consumers-per-queue' is set.\nOptional (defaults to `1`).\n<26> Indicates that the underlying listener container should be a `DirectMessageListenerContainer` instead of the default `SimpleMessageListenerContainer`.\nSee the https://docs.spring.io/spring-amqp/reference/html/[Spring AMQP Reference Manual] for more information.\n<27> When the container's `consumerBatchEnabled` is `true`, determines how the adapter presents the batch of messages in the message payload.\nWhen set to `MESSAGES` (default), the payload is a `List<Message<?>>` where each message has headers mapped from the incoming AMQP `Message` and the payload is the converted `body`.\nWhen set to `EXTRACT_PAYLOADS`, the payload is a `List<?>` where the elements are converted from the AMQP `Message` body.\n`EXTRACT_PAYLOADS_WITH_HEADERS` is similar to `EXTRACT_PAYLOADS` but, in addition, the headers from each message are mapped from the `MessageProperties` into a `List<Map<String, Object>` at the corresponding index; the header name is `AmqpInboundChannelAdapter.CONSOLIDATED_HEADERS`.\n\n[NOTE]\n.container\n====\nNote that when configuring an external container with XML, you cannot use the Spring AMQP namespace to define the container.\nThis is because the namespace requires at least one `<listener/>` element.\nIn this environment, the listener is internal to the adapter.\nFor this reason, you must define the container by using a normal Spring `<bean/>` definition, as the following example shows:\n\n[source,xml]\n----\n\n<bean id=\"container\"\n class=\"org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer\">\n <property name=\"connectionFactory\" ref=\"connectionFactory\" />\n <property name=\"queueNames\" value=\"aName.queue\" />\n <property name=\"defaultRequeueRejected\" value=\"false\"/>\n</bean>\n----\n====\n\nIMPORTANT: Even though the Spring Integration JMS and AMQP support is similar, important differences exist.\nThe JMS inbound channel adapter is using a `JmsDestinationPollingSource` under the covers and expects a configured poller.\nThe AMQP inbound channel adapter uses an `AbstractMessageListenerContainer` and is message driven.\nIn that regard, it is more similar to the JMS message-driven channel adapter.\n\nStarting with version 5.5, the `AmqpInboundChannelAdapter` can be configured with an `org.springframework.amqp.rabbit.retry.MessageRecoverer` strategy which is used in the `RecoveryCallback` when the retry operation is called internally.\nSee `setMessageRecoverer()` JavaDocs for more information.\n\nThe `@Publisher` annotation also can be used in combination with a `@RabbitListener`:\n\n[source, java]\n----\n@Configuration\n@EnableIntegration\n@EnableRabbit\n@EnablePublisher\npublic static class ContextConfiguration {\n\n @Bean\n QueueChannel fromRabbitViaPublisher() {\n return new QueueChannel();\n }\n\n @RabbitListener(queuesToDeclare = @Queue(\"publisherQueue\"))\n @Publisher(\"fromRabbitViaPublisher\")\n @Payload(\"#args.payload.toUpperCase()\")\n public void consumeForPublisher(String payload) {\n\n }\n\n}\n----\n\nBy default, the `@Publisher` AOP interceptor deals with a return value from a method call.\nHowever, the return value from a `@RabbitListener` method is treated as an AMQP reply message.\nTherefore, such an approach cannot be used together with a `@Publisher`, so a `@Payload` annotation with respective SpEL expression against method arguments is a recommended way for this combination.\nSee more information about the `@Publisher` in the xref:message-publishing.adoc#publisher-annotation[Annotation-driven Configuration] section.\n\nIMPORTANT: When using exclusive or single-active consumers in the listener container, it is recommended that you set the container property `forceStop` to `true`.\nThis will prevent a race condition where, after stopping the container, another consumer could start consuming messages before this instance has fully stopped.\n\n[[amqp-debatching]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/inbound-channel-adapter.adoc", "title": "inbound-channel-adapter", "heading": "inbound-channel-adapter", "heading_level": 1, "file_order": 8, "section_index": 0, "content_hash": "2d1fd90a2b0697580311eb622322aec38d41e9ba17e3483879277364898cdb1f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/inbound-channel-adapter.adoc"}}
{"id": "sha256:85e17abe72542ff1586e6283b4204d32783e2348c6c4ae22782dfa6b0f3bf1de", "content": "See https://docs.spring.io/spring-amqp/docs/current/reference/html/#template-batching[the Spring AMQP Documentation] for more information about batched messages.\n\nTo produce batched messages with Spring Integration, simply configure the outbound endpoint with a `BatchingRabbitTemplate`.\n\nWhen receiving batched messages, by default, the listener containers extract each fragment message and the adapter will produce a `Message<?>` for each fragment.\nStarting with version 5.2, if the container's `deBatchingEnabled` property is set to `false`, the de-batching is performed by the adapter instead, and a single `Message<List<?>>` is produced with the payload being a list of the fragment payloads (after conversion if appropriate).\n\nThe default `BatchingStrategy` is the `SimpleBatchingStrategy`, but this can be overridden on the adapter.\n\nNOTE: The `org.springframework.amqp.rabbit.retry.MessageBatchRecoverer` must be used with batches when recovery is required for retry operations.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/inbound-channel-adapter.adoc", "title": "inbound-channel-adapter", "heading": "Batched Messages", "heading_level": 2, "file_order": 8, "section_index": 1, "content_hash": "85e17abe72542ff1586e6283b4204d32783e2348c6c4ae22782dfa6b0f3bf1de", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/inbound-channel-adapter.adoc"}}
{"id": "sha256:c1061667ca34fb4a5218889c66d25002b011f43e351efc076d70b0c6fbda3f6f", "content": "[[amqp-inbound-gateway]]\n\nThe inbound gateway supports all the attributes on the inbound channel adapter (except that `channel` is replaced by `request-channel`), plus some additional attributes.\nThe following listing shows the available attributes:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean // return the upper-cased payload\npublic IntegrationFlow amqpInboundGateway(ConnectionFactory connectionFactory) {\n return IntegrationFlow.from(Amqp.inboundGateway(connectionFactory, \"foo\"))\n .transform(String.class, String::toUpperCase)\n .get();\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\npublic MessageChannel amqpInputChannel() {\n return new DirectChannel();\n}\n\n@Bean\npublic AmqpInboundGateway inbound(SimpleMessageListenerContainer listenerContainer,\n @Qualifier(\"amqpInputChannel\") MessageChannel channel) {\n AmqpInboundGateway gateway = new AmqpInboundGateway(listenerContainer);\n gateway.setRequestChannel(channel);\n gateway.setDefaultReplyTo(\"bar\");\n return gateway;\n}\n\n@Bean\npublic SimpleMessageListenerContainer container(ConnectionFactory connectionFactory) {\n SimpleMessageListenerContainer container =\n new SimpleMessageListenerContainer(connectionFactory);\n container.setQueueNames(\"foo\");\n container.setConcurrentConsumers(2);\n // ...\n return container;\n}\n\n@Bean\n@ServiceActivator(inputChannel = \"amqpInputChannel\")\npublic MessageHandler handler() {\n return new AbstractReplyProducingMessageHandler() {\n\n @Override\n protected Object handleRequestMessage(Message<?> requestMessage) {\n return \"reply to \" + requestMessage.getPayload();\n }\n\n };\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-amqp:inbound-gateway\n id=\"inboundGateway\" <1>\n request-channel=\"myRequestChannel\" <2>\n header-mapper=\"\" <3>\n mapped-request-headers=\"\" <4>\n mapped-reply-headers=\"\" <5>\n reply-channel=\"myReplyChannel\" <6>\n reply-timeout=\"1000\" <7>\n amqp-template=\"\" <8>\n default-reply-to=\"\" /> <9>\n\n----\n======\n\n<1> The Unique ID for this adapter.\nOptional.\n<2> Message channel to which converted messages are sent.\nRequired.\n<3> A reference to an `AmqpHeaderMapper` to use when receiving AMQP Messages.\nOptional.\nBy default, only standard AMQP properties (such as `contentType`) are copied to and from Spring Integration `MessageHeaders`.\nAny user-defined headers within the AMQP `MessageProperties` are not copied to or from an AMQP message by the default `DefaultAmqpHeaderMapper`.\nNot allowed if 'request-header-names' or 'reply-header-names' is provided.\n<4> Comma-separated list of names of AMQP Headers to be mapped from the AMQP request into the `MessageHeaders`.\nThis attribute can be provided only if the 'header-mapper' reference is not provided.\nThe values in this list can also be simple patterns to be matched against the header names (e.g. `\"\\*\"` or `\"thing1*, thing2\"` or `\"*thing1\"`).\n<5> Comma-separated list of names of `MessageHeaders` to be mapped into the AMQP message properties of the AMQP reply message.\nAll standard Headers (such as `contentType`) are mapped to AMQP Message Properties, while user-defined headers are mapped to the 'headers' property.\nThis attribute can only be provided if the 'header-mapper' reference is not provided.\nThe values in this list can also be simple patterns to be matched against the header names (for example, `\"\\*\"` or `\"foo*, bar\"` or `\"*foo\"`).\n<6> Message Channel where reply Messages are expected.\nOptional.\n<7> Sets the `receiveTimeout` on the underlying `o.s.i.core.MessagingTemplate` for receiving messages from the reply channel.\nIf not specified, this property defaults to `1000` (1 second).\nOnly applies if the container thread hands off to another thread before the reply is sent.\n<8> The customized `AmqpTemplate` bean reference (to have more control over the reply messages to send).\nYou can provide an alternative implementation to the `RabbitTemplate`.\n<9> The `replyTo` `o.s.amqp.core.Address` to be used when the `requestMessage` does not have a `replyTo`\nproperty.\nIf this option is not specified, no `amqp-template` is provided, no `replyTo` property exists in the request message, and\nan `IllegalStateException` is thrown because the reply cannot be routed.\nIf this option is not specified and an external `amqp-template` is provided, no exception is thrown.\nYou must either specify this option or configure a default `exchange` and `routingKey` on that template,\nif you anticipate cases when no `replyTo` property exists in the request message.\n\nSee the note in xref:amqp/inbound-channel-adapter.adoc[Inbound Channel Adapter] about configuring the `listener-container` attribute.\n\nStarting with version 5.5, the `AmqpInboundChannelAdapter` can be configured with an `org.springframework.amqp.rabbit.retry.MessageRecoverer` strategy which is used in the `RecoveryCallback` when the retry operation is called internally.\nSee `setMessageRecoverer()` JavaDocs for more information.\n\n[[amqp-gateway-debatching]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/inbound-gateway.adoc", "title": "inbound-gateway", "heading": "inbound-gateway", "heading_level": 1, "file_order": 9, "section_index": 0, "content_hash": "c1061667ca34fb4a5218889c66d25002b011f43e351efc076d70b0c6fbda3f6f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/inbound-gateway.adoc"}}
{"id": "sha256:a8728206e647b54b67b13b4060414a01dfd785eb154ec90a0d78a228749ddab5", "content": "See xref:amqp/inbound-channel-adapter.adoc#amqp-debatching[Batched Messages].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/inbound-gateway.adoc", "title": "inbound-gateway", "heading": "Batched Messages", "heading_level": 2, "file_order": 9, "section_index": 1, "content_hash": "a8728206e647b54b67b13b4060414a01dfd785eb154ec90a0d78a228749ddab5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/inbound-gateway.adoc"}}
{"id": "sha256:7c94c4835c7ea24fd4c81fded353fb2b43d19a4715eedc690e2e9868e29c2d3f", "content": "[[amqp-message-headers]]\n\n[[overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/message-headers.adoc", "title": "message-headers", "heading": "message-headers", "heading_level": 1, "file_order": 10, "section_index": 0, "content_hash": "7c94c4835c7ea24fd4c81fded353fb2b43d19a4715eedc690e2e9868e29c2d3f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/message-headers.adoc"}}
{"id": "sha256:fe345ea09eb9340007e1087f1f6ed29619881c85db0abfb25facf29f00273cd4", "content": "The Spring Integration AMQP Adapters automatically map all AMQP properties and headers.\n(This is a change from 4.3 - previously, only standard headers were mapped).\nBy default, these properties are copied to and from Spring Integration `MessageHeaders` by using the\nhttps://docs.spring.io/spring-integration/api/org/springframework/integration/amqp/support/DefaultAmqpHeaderMapper.html[`DefaultAmqpHeaderMapper`].\n\nYou can pass in your own implementation of AMQP-specific header mappers, as the adapters have properties to support doing so.\n\nAny user-defined headers within the AMQP https://docs.spring.io/spring-amqp/api/org/springframework/amqp/core/MessageProperties.html[`MessageProperties`] are copied to or from an AMQP message, unless explicitly negated by the `requestHeaderNames` or `replyHeaderNames` properties of the `DefaultAmqpHeaderMapper`.\nBy default, for an outbound mapper, no `x-*` headers are mapped.\nSee the xref:amqp/message-headers.adoc#header-copy-caution[caution] that appears later in this section for why.\n\nTo override the default and revert to the pre-4.3 behavior, use `STANDARD_REQUEST_HEADERS` and\n`STANDARD_REPLY_HEADERS` in the properties.\n\nTIP: When mapping user-defined headers, the values can also contain simple wildcard patterns (such as `thing*` or `\\*thing`) to be matched.\nThe `*` matches all headers.\n\nStarting with version 4.1, the `AbstractHeaderMapper` (a `DefaultAmqpHeaderMapper` superclass) lets the `NON_STANDARD_HEADERS` token be configured for the `requestHeaderNames` and `replyHeaderNames` properties (in addition to the existing `STANDARD_REQUEST_HEADERS` and `STANDARD_REPLY_HEADERS`) to map all user-defined headers.\n\nThe `org.springframework.amqp.support.AmqpHeaders` class identifies the default headers that are used by the `DefaultAmqpHeaderMapper`:\n\n* `amqp_appId`\n* `amqp_clusterId`\n* `amqp_contentEncoding`\n* `amqp_contentLength`\n* `content-type` (see xref:amqp/message-headers.adoc#amqp-content-type[The `contentType` Header])\n* `amqp_correlationId`\n* `amqp_delay`\n* `amqp_deliveryMode`\n* `amqp_deliveryTag`\n* `amqp_expiration`\n* `amqp_messageCount`\n* `amqp_messageId`\n* `amqp_receivedDelay`\n* `amqp_receivedDeliveryMode`\n* `amqp_receivedExchange`\n* `amqp_receivedRoutingKey`\n* `amqp_redelivered`\n* `amqp_replyTo`\n* `amqp_timestamp`\n* `amqp_type`\n* `amqp_userId`\n* `amqp_publishConfirm`\n* `amqp_publishConfirmNackCause`\n* `amqp_returnReplyCode`\n* `amqp_returnReplyText`\n* `amqp_returnExchange`\n* `amqp_returnRoutingKey`\n* `amqp_channel`\n* `amqp_consumerTag`\n* `amqp_consumerQueue`\n\n[[header-copy-caution]]\nCAUTION: As mentioned earlier in this section, using a header mapping pattern of `\\*` is a common way to copy all headers.\nHowever, this can have some unexpected side effects, because certain RabbitMQ proprietary properties/headers are also copied.\nFor example, when you use https://www.rabbitmq.com/federated-exchanges.html[federation], the received message may have a property named `x-received-from`, which contains the node that sent the message.\nIf you use the wildcard character `*` for the request and reply header mapping on the inbound gateway, this header is copied, which may cause some issues with federation.\nThis reply message may be federated back to the sending broker, which may think that a message is looping and, as a result, silently drop it.\nIf you wish to use the convenience of wildcard header mapping, you may need to filter out some headers in the downstream flow.\nFor example, to avoid copying the `x-received-from` header back to the reply you can use `<int:header-filter ... header-names=\"x-received-from\">` before sending the reply to the AMQP inbound gateway.\nAlternatively, you can explicitly list those properties that you actually want mapped, instead of using wildcards.\nFor these reasons, for inbound messages, the mapper (by default) does not map any `x-*` headers.\nIt also does not map the `deliveryMode` to the `amqp_deliveryMode` header, to avoid propagation of that header from an inbound message to an outbound message.\nInstead, this header is mapped to `amqp_receivedDeliveryMode`, which is not mapped on output.\n\nStarting with version 4.3, patterns in the header mappings can be negated by preceding the pattern with `!`.\nNegated patterns get priority, so a list such as `STANDARD_REQUEST_HEADERS,thing1,ba*,!thing2,!thing3,qux,!thing1` does not map `thing1` (nor `thing2` nor `thing3`).\nThe standard headers plus `bad` and `qux` are mapped.\nThe negation technique can be useful, for example, to not map JSON type headers for incoming messages when a JSON deserialization logic is done in the receiver downstream a different way.\nFor this purpose a `!json_*` pattern should be configured for header mapper of the inbound channel adapter/gateway.\n\nIMPORTANT: If you have a user-defined header that begins with `!` that you do wish to map, you need to escape it with `\\`, as follows: `STANDARD_REQUEST_HEADERS,\\!myBangHeader`.\nThe header named `!myBangHeader` is now mapped.\n\nNOTE: Starting with version 5.1, the `DefaultAmqpHeaderMapper` will fall back to mapping `MessageHeaders.ID` and `MessageHeaders.TIMESTAMP` to `MessageProperties.messageId` and `MessageProperties.timestamp` respectively, if the corresponding `amqp_messageId` or `amqp_timestamp` headers are not present on outbound messages.\nInbound properties will be mapped to the `amqp_*` headers as before.\nIt is useful to populate the `messageId` property when message consumers are using stateful retry.\n\n[[amqp-content-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/message-headers.adoc", "title": "message-headers", "heading": "Overview", "heading_level": 2, "file_order": 10, "section_index": 1, "content_hash": "fe345ea09eb9340007e1087f1f6ed29619881c85db0abfb25facf29f00273cd4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/message-headers.adoc"}}
{"id": "sha256:8ab32769d7dea86857f7051d520bc1c46ac2afb654886faa8fc53c303f24b58c", "content": "Unlike other headers, the `AmqpHeaders.CONTENT_TYPE` is not prefixed with `amqp_`; this allows transparent passing of the contentType header across different technologies.\nFor example, an inbound HTTP message sent to a RabbitMQ queue.\n\nThe `contentType` header is mapped to Spring AMQP's `MessageProperties.contentType` property and that is subsequently mapped to RabbitMQ `content_type` property.\n\nPrior to version 5.1, this header was also mapped as an entry in the `MessageProperties.headers` map; this was incorrect and, furthermore, the value could be wrong since the underlying Spring AMQP message converter might have changed the content type.\nSuch a change would be reflected in the first-class `content_type` property, but not in the RabbitMQ headers map.\nInbound mapping ignored the header map value.\n`contentType` is no longer mapped to an entry in the header map.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/message-headers.adoc", "title": "message-headers", "heading": "The `contentType` Header", "heading_level": 2, "file_order": 10, "section_index": 2, "content_hash": "8ab32769d7dea86857f7051d520bc1c46ac2afb654886faa8fc53c303f24b58c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/message-headers.adoc"}}
{"id": "sha256:3c2f3bd239792816e70098df8a2a699a649a98b19c7c616cc470aea5fbf9c339", "content": "[[amqp-outbound-channel-adapter]]\n\nThe following example shows the available properties for an AMQP outbound channel adapter:\n\n[tabs]\n======\nJava DSL::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow amqpOutbound(AmqpTemplate amqpTemplate,\n MessageChannel amqpOutboundChannel) {\n return IntegrationFlow.from(amqpOutboundChannel)\n .handle(Amqp.outboundAdapter(amqpTemplate)\n .routingKey(\"queue1\")) // default exchange - route to queue 'queue1'\n .get();\n}\n----\n\nJava::\n+\n[source,java,role=\"secondary\"]\n----\n@Bean\n@ServiceActivator(inputChannel = \"amqpOutboundChannel\")\npublic AmqpOutboundEndpoint amqpOutbound(AmqpTemplate amqpTemplate) {\n AmqpOutboundEndpoint outbound = new AmqpOutboundEndpoint(amqpTemplate);\n outbound.setRoutingKey(\"queue1\"); // default exchange - route to queue 'queue1'\n return outbound;\n}\n\n@Bean\npublic MessageChannel amqpOutboundChannel() {\n return new DirectChannel();\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<int-amqp:outbound-channel-adapter id=\"outboundAmqp\" <1>\n channel=\"outboundChannel\" <2>\n amqp-template=\"myAmqpTemplate\" <3>\n exchange-name=\"\" <4>\n exchange-name-expression=\"\" <5>\n order=\"1\" <6>\n routing-key=\"\" <7>\n routing-key-expression=\"\" <8>\n default-delivery-mode\"\" <9>\n confirm-correlation-expression=\"\" <10>\n confirm-ack-channel=\"\" <11>\n confirm-nack-channel=\"\" <12>\n confirm-timeout=\"\" <13>\n wait-for-confirm=\"\" <14>\n return-channel=\"\" <15>\n error-message-strategy=\"\" <16>\n header-mapper=\"\" <17>\n mapped-request-headers=\"\" <18>\n lazy-connect=\"true\" <19>\n multi-send=\"false\"/> <20>\n----\n======\n\n<1> The unique ID for this adapter.\nOptional.\n<2> Message channel to which messages should be sent to have them converted and published to an AMQP exchange.\nRequired.\n<3> Bean reference to the configured AMQP template.\nOptional (defaults to `amqpTemplate`).\n<4> The name of the AMQP exchange to which messages are sent.\nIf not provided, messages are sent to the default, no-name exchange.\nMutually exclusive with 'exchange-name-expression'.\nOptional.\n<5> A SpEL expression that is evaluated to determine the name of the AMQP exchange to which messages are sent, with the message as the root object.\nIf not provided, messages are sent to the default, no-name exchange.\nMutually exclusive with 'exchange-name'.\nOptional.\n<6> The order for this consumer when multiple consumers are registered, thereby enabling load-balancing and failover.\nOptional (defaults to `Ordered.LOWEST_PRECEDENCE [=Integer.MAX_VALUE]`).\n<7> The fixed routing-key to use when sending messages.\nBy default, this is an empty `String`.\nMutually exclusive with 'routing-key-expression'.\nOptional.\n<8> A SpEL expression that is evaluated to determine the routing key to use when sending messages, with the message as the root object (for example, 'payload.key').\nBy default, this is an empty `String`.\nMutually exclusive with `routing-key`.\nOptional.\n<9> The default delivery mode for messages: `PERSISTENT` or `NON_PERSISTENT`.\nOverridden if the `header-mapper` sets the delivery mode.\nIf the Spring Integration message header `amqp_deliveryMode` is present, the `DefaultHeaderMapper` sets the value.\nIf this attribute is not supplied and the header mapper does not set it, the default depends on the underlying Spring AMQP `MessagePropertiesConverter` used by the `RabbitTemplate`.\nIf that is not customized at all, the default is `PERSISTENT`.\nOptional.\n<10> An expression that defines correlation data.\nWhen provided, this configures the underlying AMQP template to receive publisher confirmations.\nRequires a dedicated `RabbitTemplate` and a `CachingConnectionFactory` with the `publisherConfirms` property set to `true`.\nWhen a publisher confirmation is received and correlation data is supplied, it is written to either the `confirm-ack-channel` or the `confirm-nack-channel`, depending on the confirmation type.\nThe payload of the confirmation is the correlation data, as defined by this expression.\nThe message has an 'amqp_publishConfirm' header set to `true` (`ack`) or `false` (`nack`).\nExamples: `headers['myCorrelationData']` and `payload`.\nVersion 4.1 introduced the `amqp_publishConfirmNackCause` message header.\nIt contains the `cause` of a 'nack' for a publisher confirmation.\nStarting with version 4.2, if the expression resolves to a `Message<?>` instance (such as `#this`), the message emitted on the `ack`/`nack` channel is based on that message, with the additional header(s) added.\nPreviously, a new message was created with the correlation data as its payload, regardless of type.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nOptional.\n<11> The channel to which positive (`ack`) publisher confirms are sent.\nThe payload is the correlation data defined by the `confirm-correlation-expression`.\nIf the expression is `#root` or `#this`, the message is built from the original message, with the `amqp_publishConfirm` header set to `true`.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nOptional (the default is `nullChannel`).\n<12> The channel to which negative (`nack`) publisher confirmations are sent.\nThe payload is the correlation data defined by the `confirm-correlation-expression` (if there is no `ErrorMessageStrategy` configured).\nIf the expression is `#root` or `#this`, the message is built from the original message, with the `amqp_publishConfirm` header set to `false`.\nWhen there is an `ErrorMessageStrategy`, the message is an `ErrorMessage` with a `NackedAmqpMessageException` payload.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nOptional (the default is `nullChannel`).\n<13> When set, the adapter will synthesize a negative acknowledgment (nack) if a publisher confirm is not received within this time in milliseconds.\nPending confirms are checked every 50% of this value, so the actual time a nack is sent will be between 1x and 1.5x this value.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nDefault none (nacks will not be generated).\n<14> When set to true, the calling thread will block, waiting for a publisher confirmation.\nThis requires a `RabbitTemplate` configured for `confirms` as well as a `confirm-correlation-expression`.\nThe thread will block for up to `confirm-timeout` (or 5 seconds by default).\nIf a timeout occurs, a `MessageTimeoutException` will be thrown.\nIf returns are enabled and a message is returned, or any other exception occurs while awaiting the confirmation, a `MessageHandlingException` will be thrown, with an appropriate message.\n<15> The channel to which returned messages are sent.\nWhen provided, the underlying AMQP template is configured to return undeliverable messages to the adapter.\nWhen there is no `ErrorMessageStrategy` configured, the message is constructed from the data received from AMQP, with the following additional headers: `amqp_returnReplyCode`, `amqp_returnReplyText`, `amqp_returnExchange`, `amqp_returnRoutingKey`.\nWhen there is an `ErrorMessageStrategy`, the message is an `ErrorMessage` with a `ReturnedAmqpMessageException` payload.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nOptional.\n<16> A reference to an `ErrorMessageStrategy` implementation used to build `ErrorMessage` instances when sending returned or negatively acknowledged messages.\n<17> A reference to an `AmqpHeaderMapper` to use when sending AMQP Messages.\nBy default, only standard AMQP properties (such as `contentType`) are copied to the Spring Integration `MessageHeaders`.\nAny user-defined headers are not copied to the message by the default`DefaultAmqpHeaderMapper`.\nNot allowed if `request-header-names` is provided.\nOptional.\n<18> Comma-separated list of names of AMQP Headers to be mapped from the `MessageHeaders` to the AMQP Message.\nNot allowed if the 'header-mapper' reference is provided.\nThe values in this list can also be simple patterns to be matched against the header names (e.g. `\"\\*\"` or `\"thing1*, thing2\"` or `\"*thing1\"`).\n<19> When set to `false`, the endpoint attempts to connect to the broker during application context initialization.\nThis allows \"`fail fast`\" detection of bad configuration but also causes initialization to fail if the broker is down.\nWhen `true` (the default), the connection is established (if it does not already exist because some other component established it) when the first message is sent.\n<20> When set to `true`, payloads of type `Iterable<Message<?>>` will be sent as discrete messages on the same channel within the scope of a single `RabbitTemplate` invocation.\nRequires a `RabbitTemplate`.\nWhen `wait-for-confirms` is true, `RabbitTemplate.waitForConfirmsOrDie()` is invoked after the messages have been sent.\nWith a transactional template, the sending will be performed in either a new transaction or one that has already been started (if present).\n\n[IMPORTANT]\n.return-channel\n=====\nUsing a `return-channel` requires a `RabbitTemplate` with the `mandatory` property set to `true` and a `CachingConnectionFactory` with the `publisherReturns` property set to `true`.\nWhen using multiple outbound endpoints with returns, a separate `RabbitTemplate` is needed for each endpoint.\n=====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "outbound-channel-adapter", "heading_level": 1, "file_order": 11, "section_index": 0, "content_hash": "3c2f3bd239792816e70098df8a2a699a649a98b19c7c616cc470aea5fbf9c339", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/outbound-channel-adapter.adoc"}}
{"id": "sha256:b2d9bfe2986251c56c6872ac835a1cb2c81f6f8fdfe104c5273823930cc5f06a", "content": "[[amqp-outbound-endpoints]]\n\nThe following outbound endpoints have many similar configuration options.\nStarting with version 5.2, the `confirm-timeout` has been added.\nNormally, when a publisher confirms are enabled, the broker will quickly return an ack (or nack) which will be sent to the appropriate channel.\nIf a channel is closed before the `confirm` is received, the Spring AMQP framework will synthesize a nack.\n\"Missing\" acks should never occur, but, if you set this property, the endpoint will periodically check for them and synthesize a nack if the time elapses without a `confirm` being received.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/outbound-endpoints.adoc", "title": "outbound-endpoints", "heading": "outbound-endpoints", "heading_level": 1, "file_order": 12, "section_index": 0, "content_hash": "b2d9bfe2986251c56c6872ac835a1cb2c81f6f8fdfe104c5273823930cc5f06a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/outbound-endpoints.adoc"}}
{"id": "sha256:3321db88012770208fd06ef19937c28472c5dcaf3e1014a1325af1d08d0dae28", "content": "[[amqp-outbound-gateway]]\n\nThe following listing shows the possible properties for an AMQP Outbound Gateway:\n\n[tabs]\n======\nJava DSL::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow amqpOutbound(AmqpTemplate amqpTemplate) {\n return f -> f.handle(Amqp.outboundGateway(amqpTemplate)\n .routingKey(\"foo\")) // default exchange - route to queue 'foo'\n .get();\n}\n\n@MessagingGateway(defaultRequestChannel = \"amqpOutbound.input\")\npublic interface MyGateway {\n\n String sendToRabbit(String data);\n\n}\n----\n\nJava::\n+\n[source,java,role=\"secondary\"]\n----\n@Bean\n@ServiceActivator(inputChannel = \"amqpOutboundChannel\")\npublic AmqpOutboundEndpoint amqpOutbound(AmqpTemplate amqpTemplate) {\n AmqpOutboundEndpoint outbound = new AmqpOutboundEndpoint(amqpTemplate);\n outbound.setExpectReply(true);\n outbound.setRoutingKey(\"foo\"); // default exchange - route to queue 'foo'\n return outbound;\n}\n\n@Bean\npublic MessageChannel amqpOutboundChannel() {\n return new DirectChannel();\n}\n\n@MessagingGateway(defaultRequestChannel = \"amqpOutboundChannel\")\npublic interface MyGateway {\n\n String sendToRabbit(String data);\n\n}\n----\n\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<int-amqp:outbound-gateway id=\"outboundGateway\" <1>\n request-channel=\"myRequestChannel\" <2>\n amqp-template=\"\" <3>\n exchange-name=\"\" <4>\n exchange-name-expression=\"\" <5>\n order=\"1\" <6>\n reply-channel=\"\" <7>\n reply-timeout=\"\" <8>\n requires-reply=\"\" <9>\n routing-key=\"\" <10>\n routing-key-expression=\"\" <11>\n default-delivery-mode\"\" <12>\n confirm-correlation-expression=\"\" <13>\n confirm-ack-channel=\"\" <14>\n confirm-nack-channel=\"\" <15>\n confirm-timeout=\"\" <16>\n return-channel=\"\" <17>\n error-message-strategy=\"\" <18>\n lazy-connect=\"true\" /> <19>\n\n----\n======\n\n<1> The unique ID for this adapter.\nOptional.\n<2> Message channel to which messages are sent to have them converted and published to an AMQP exchange.\nRequired.\n<3> Bean reference to the configured AMQP template.\nOptional (defaults to `amqpTemplate`).\n<4> The name of the AMQP exchange to which messages should be sent.\nIf not provided, messages are sent to the default, no-name cxchange.\nMutually exclusive with 'exchange-name-expression'.\nOptional.\n<5> A SpEL expression that is evaluated to determine the name of the AMQP exchange to which messages should be sent, with the message as the root object.\nIf not provided, messages are sent to the default, no-name exchange.\nMutually exclusive with 'exchange-name'.\nOptional.\n<6> The order for this consumer when multiple consumers are registered, thereby enabling load-balancing and failover.\nOptional (defaults to `Ordered.LOWEST_PRECEDENCE [=Integer.MAX_VALUE]`).\n<7> Message channel to which replies should be sent after being received from an AMQP queue and converted.\nOptional.\n<8> The time the gateway waits when sending the reply message to the `reply-channel`.\nThis only applies if the `reply-channel` can block -- such as a `QueueChannel` with a capacity limit that is currently full.\nDefaults to infinity.\n<9> When `true`, the gateway throws an exception if no reply message is received within the `AmqpTemplate`'s `replyTimeout` property.\nDefaults to `true`.\n<10> The `routing-key` to use when sending messages.\nBy default, this is an empty `String`.\nMutually exclusive with 'routing-key-expression'.\nOptional.\n<11> A SpEL expression that is evaluated to determine the `routing-key` to use when sending messages, with the message as the root object (for example, 'payload.key').\nBy default, this is an empty `String`.\nMutually exclusive with `routing-key`.\nOptional.\n<12> The default delivery mode for messages: `PERSISTENT` or `NON_PERSISTENT`.\nOverridden if the `header-mapper` sets the delivery mode.\nIf the Spring Integration message header `amqp_deliveryMode` is present, the `DefaultHeaderMapper` sets the value.\nIf this attribute is not supplied and the header mapper does not set it, the default depends on the underlying Spring AMQP `MessagePropertiesConverter` used by the `RabbitTemplate`.\nIf that is not customized at all, the default is `PERSISTENT`.\nOptional.\n<13> Since version 4.2.\nAn expression defining correlation data.\nWhen provided, this configures the underlying AMQP template to receive publisher confirms.\nRequires a dedicated `RabbitTemplate` and a `CachingConnectionFactory` with the `publisherConfirms` property set to `true`.\nWhen a publisher `confirm` is received and correlation data is supplied, it is written to either the `confirm-ack-channel` or the `confirm-nack-channel`, depending on the confirmation type.\nThe payload of the `confirm` is the correlation data, as defined by this expression.\nThe message has a header 'amqp_publishConfirm' set to `true` (`ack`) or `false` (`nack`).\nFor `nack` confirmations, Spring Integration provides an additional header `amqp_publishConfirmNackCause`.\nExamples: `headers['myCorrelationData']` and `payload`.\nIf the expression resolves to a `Message<?>` instance (such as `#this`), the message\nemitted on the `ack`/`nack` channel is based on that message, with the additional headers added.\nPreviously, a new message was created with the correlation data as its payload, regardless of type.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nOptional.\n<14> The channel to which positive (`ack`) publisher confirmations are sent.\nThe payload is the correlation data defined by `confirm-correlation-expression`.\nIf the expression is `#root` or `#this`, the message is built from the original message, with the `amqp_publishConfirm` header set to `true`.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nOptional (the default is `nullChannel`).\n<15> The channel to which negative (`nack`) publisher confirmations are sent.\nThe payload is the correlation data defined by `confirm-correlation-expression` (if there is no `ErrorMessageStrategy` configured).\nIf the expression is `#root` or `#this`, the message is built from the original message, with the `amqp_publishConfirm` header set to `false`.\nWhen there is an `ErrorMessageStrategy`, the message is an `ErrorMessage` with a `NackedAmqpMessageException` payload.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nOptional (the default is `nullChannel`).\n<16> When set, the gateway will synthesize a negative acknowledgment (nack) if a publisher confirm is not received within this time in milliseconds.\nPending confirms are checked every 50% of this value, so the actual time a nack is sent will be between 1x and 1.5x this value.\nDefault none (nacks will not be generated).\n<17> The channel to which returned messages are sent.\nWhen provided, the underlying AMQP template is configured to return undeliverable messages to the adapter.\nWhen there is no `ErrorMessageStrategy` configured, the message is constructed from the data received from AMQP, with the following additional headers: `amqp_returnReplyCode`, `amqp_returnReplyText`, `amqp_returnExchange`, and `amqp_returnRoutingKey`.\nWhen there is an `ErrorMessageStrategy`, the message is an `ErrorMessage` with a `ReturnedAmqpMessageException` payload.\nAlso see xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns].\nOptional.\n<18> A reference to an `ErrorMessageStrategy` implementation used to build `ErrorMessage` instances when sending returned or negatively acknowledged messages.\n<19> When set to `false`, the endpoint attempts to connect to the broker during application context initialization.\nThis allows \"`fail fast`\" detection of bad configuration by logging an error message if the broker is down.\nWhen `true` (the default), the connection is established (if it does not already exist because some other component established it) when the first message is sent.\n\n[IMPORTANT]\n.return-channel\n=====\nUsing a `return-channel` requires a `RabbitTemplate` with the `mandatory` property set to `true` and a `CachingConnectionFactory` with the `publisherReturns` property set to `true`.\nWhen using multiple outbound endpoints with returns, a separate `RabbitTemplate` is needed for each endpoint.\n=====\n\nIMPORTANT: The underlying `AmqpTemplate` has a default `replyTimeout` of five seconds.\nIf you require a longer timeout, you must configure it on the `template`.\n\nNote that the only difference between the outbound adapter and outbound gateway configuration is the setting of the `expectReply` property.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "outbound-gateway", "heading_level": 1, "file_order": 13, "section_index": 0, "content_hash": "3321db88012770208fd06ef19937c28472c5dcaf3e1014a1325af1d08d0dae28", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/outbound-gateway.adoc"}}
{"id": "sha256:fc0062baa643842b4f8ebc4c9342a15ee8f82716854c3d124d72a78b411a0e99", "content": "[[polled-inbound-channel-adapter]]\n\n[[overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/polled-inbound-channel-adapter.adoc", "title": "polled-inbound-channel-adapter", "heading": "polled-inbound-channel-adapter", "heading_level": 1, "file_order": 14, "section_index": 0, "content_hash": "fc0062baa643842b4f8ebc4c9342a15ee8f82716854c3d124d72a78b411a0e99", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/polled-inbound-channel-adapter.adoc"}}
{"id": "sha256:d64029232346f071df594a42fbfe955ba5071239c5447188861e31cdc85c9477", "content": "Version 5.0.1 introduced a polled channel adapter, letting you fetch individual messages on demand -- for example, with a `MessageSourcePollingTemplate` or a poller.\nSee xref:polling-consumer.adoc#deferred-acks-message-source[Deferred Acknowledgment Pollable Message Source] for more information.\n\nIt does not currently support XML configuration.\n\nThe following example shows how to configure an `AmqpMessageSource`:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow flow() {\n return IntegrationFlow.from(Amqp.inboundPolledAdapter(connectionFactory(), DSL_QUEUE),\n e -> e.poller(Pollers.fixedDelay(1_000)).autoStartup(false))\n .handle(p -> {\n ...\n })\n .get();\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\npublic AmqpMessageSource source(ConnectionFactory connectionFactory) {\n return new AmqpMessageSource(connectionFactory, \"someQueue\");\n}\n----\n======\n\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/amqp/inbound/AmqpMessageSource.html[Javadoc] for configuration properties.\n\n[[amqp-polled-debatching]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/polled-inbound-channel-adapter.adoc", "title": "polled-inbound-channel-adapter", "heading": "Overview", "heading_level": 2, "file_order": 14, "section_index": 1, "content_hash": "d64029232346f071df594a42fbfe955ba5071239c5447188861e31cdc85c9477", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/polled-inbound-channel-adapter.adoc"}}
{"id": "sha256:7cc9b12b44b1c8bb3ef273819ed30f93680535b6678a5d4c6cf7f5407164b3a8", "content": "See xref:amqp/inbound-channel-adapter.adoc#amqp-debatching[Batched Messages].\n\nFor the polled adapter, there is no listener container; batched messages are always debatched (if the `BatchingStrategy` supports doing so).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/polled-inbound-channel-adapter.adoc", "title": "polled-inbound-channel-adapter", "heading": "Batched Messages", "heading_level": 2, "file_order": 14, "section_index": 2, "content_hash": "7cc9b12b44b1c8bb3ef273819ed30f93680535b6678a5d4c6cf7f5407164b3a8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/polled-inbound-channel-adapter.adoc"}}
{"id": "sha256:1a5c34a952d96d17efc679d6e3cf466feebb535f4c683e78c06be1a12a4ebc18", "content": "[[rmq-streams]]\n\nVersion 6.0 introduced support for RabbitMQ Stream Queues.\n\nThe DSL factory class for these endpoints is `RabbitStream`.\n\n[[rmq-stream-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/rmq-streams.adoc", "title": "rmq-streams", "heading": "rmq-streams", "heading_level": 1, "file_order": 15, "section_index": 0, "content_hash": "1a5c34a952d96d17efc679d6e3cf466feebb535f4c683e78c06be1a12a4ebc18", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/rmq-streams.adoc"}}
{"id": "sha256:c7ae11db9e2587451a4f6c8cb19c29c5d9c3a181fe871a19e109e71d805b426a", "content": "[source, java]\n----\n@Bean\nIntegrationFlow simpleStream(Environment env) {\n\treturn IntegrationFlow.from(RabbitStream.inboundAdapter(env).streamName(\"my.stream\"))\n // ...\n .get();\n}\n\n@Bean\nIntegrationFlow superStream(Environment env) {\n\treturn IntegrationFlow.from(RabbitStream.inboundAdapter(env).superStream(\"my.super.stream\", \"my.consumer\"))\n // ...\n .get();\n}\n----\n\n[[rmq-stream-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/rmq-streams.adoc", "title": "rmq-streams", "heading": "RabbitMQ Stream Inbound Channel Adapter", "heading_level": 2, "file_order": 15, "section_index": 1, "content_hash": "c7ae11db9e2587451a4f6c8cb19c29c5d9c3a181fe871a19e109e71d805b426a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/rmq-streams.adoc"}}
{"id": "sha256:d71b67444758907942b2178f23ea96ff51ae6039b68c85f0272752e8ee1f88e8", "content": "[source, java]\n----\n@Bean\nIntegrationFlow outbound(Environment env) {\n return f -> f\n // ...\n .handle(RabbitStream.outboundStreamAdapter(env, \"my.stream\"));\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/rmq-streams.adoc", "title": "rmq-streams", "heading": "RabbitMQ Stream Outbound Channel Adapter", "heading_level": 2, "file_order": 15, "section_index": 2, "content_hash": "d71b67444758907942b2178f23ea96ff51ae6039b68c85f0272752e8ee1f88e8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/rmq-streams.adoc"}}
{"id": "sha256:e4e8deed63739cc266f9f9aaf03d4137992a822a68a144be904e085205f03562", "content": "[[amqp-samples]]\n\nTo experiment with the AMQP adapters, check out the samples available in the Spring Integration samples git repository at https://github.com/spring-projects/spring-integration-samples[https://github.com/SpringSource/spring-integration-samples]\n\nCurrently, one sample demonstrates the basic functionality of the Spring Integration AMQP adapter by using an outbound channel adapter and an inbound channel adapter.\nAs AMQP broker implementation in the sample uses https://www.rabbitmq.com/[RabbitMQ].\n\nNOTE: In order to run the example, you need a running instance of RabbitMQ.\nA local installation with just the basic defaults suffices.\nFor detailed RabbitMQ installation procedures, see https://www.rabbitmq.com/install.html[https://www.rabbitmq.com/install.html]\n\nOnce the sample application is started, enter some text on the command prompt and a message containing that entered text is dispatched to the AMQP queue.\nIn return, that message is retrieved by Spring Integration and printed to the console.\n\nThe following image illustrates the basic set of Spring Integration components used in this sample:\n\n.The Spring Integration graph of the AMQP sample\nimage::spring-integration-amqp-sample-graph.png[align=\"center\"]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/samples.adoc", "title": "samples", "heading": "samples", "heading_level": 1, "file_order": 16, "section_index": 0, "content_hash": "e4e8deed63739cc266f9f9aaf03d4137992a822a68a144be904e085205f03562", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/samples.adoc"}}
{"id": "sha256:ad1989b21010cfb3f9866b6c3c0a54f8df855377a3c9b88347702a8dc71513b7", "content": "[[amqp-strict-ordering]]\n\nThis section describes message ordering for inbound and outbound messages.\n\n[[inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/strict-ordering.adoc", "title": "strict-ordering", "heading": "strict-ordering", "heading_level": 1, "file_order": 17, "section_index": 0, "content_hash": "ad1989b21010cfb3f9866b6c3c0a54f8df855377a3c9b88347702a8dc71513b7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/strict-ordering.adoc"}}
{"id": "sha256:fe9416412aa135e2978efce1eebb9c92dbd4fd3e57bcd7828f1ecc297b233816", "content": "If you require strict ordering of inbound messages, you must configure the inbound listener container's `prefetchCount` property to `1`.\nThis is because, if a message fails and is redelivered, it arrives after existing prefetched messages.\nSince Spring AMQP version 2.0, the `prefetchCount` defaults to `250` for improved performance.\nStrict ordering requirements come at the cost of decreased performance.\n\n[[outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/strict-ordering.adoc", "title": "strict-ordering", "heading": "Inbound", "heading_level": 2, "file_order": 17, "section_index": 1, "content_hash": "fe9416412aa135e2978efce1eebb9c92dbd4fd3e57bcd7828f1ecc297b233816", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/strict-ordering.adoc"}}
{"id": "sha256:80bd01e640920e5c31ef63fcc09e7d42dfc5a81aba33790ff8ff5adcd0b87c53", "content": "Consider the following integration flow:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow flow(RabbitTemplate template) {\n return IntegrationFlow.from(Gateway.class)\n .splitWith(s -> s.delimiters(\",\"))\n .<String, String>transform(String::toUpperCase)\n .handle(Amqp.outboundAdapter(template).routingKey(\"rk\"))\n .get();\n}\n----\n\nSuppose we send messages `A`, `B` and `C` to the gateway.\nWhile it is likely that messages `A`, `B`, `C` are sent in order, there is no guarantee.\nThis is because the template \"`borrows`\" a channel from the cache for each send operation, and there is no guarantee that the same channel is used for each message.\nOne solution is to start a transaction before the splitter, but transactions are expensive in RabbitMQ and can reduce performance several hundred-fold.\n\nTo solve this problem in a more efficient manner, starting with version 5.1, Spring Integration provides the `BoundRabbitChannelAdvice` which is a `HandleMessageAdvice`.\nSee xref:handler-advice/handle-message.adoc[Handling Message Advice].\nWhen applied before the splitter, it ensures that all downstream operations are performed on the same channel and, optionally, can wait until publisher confirmations for all sent messages are received (if the connection factory is configured for confirmations).\nThe following example shows how to use `BoundRabbitChannelAdvice`:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow flow(RabbitTemplate template) {\n return IntegrationFlow.from(Gateway.class)\n .splitWith(s -> s.delimiters(\",\")\n .advice(new BoundRabbitChannelAdvice(template, Duration.ofSeconds(10))))\n .<String, String>transform(String::toUpperCase)\n .handle(Amqp.outboundAdapter(template).routingKey(\"rk\"))\n .get();\n}\n----\n\nNotice that the same `RabbitTemplate` (which implements `RabbitOperations`) is used in the advice and the outbound adapter.\nThe advice runs the downstream flow within the template's `invoke` method so that all operations run on the same channel.\nIf the optional timeout is provided, when the flow completes, the advice calls the `waitForConfirmsOrDie` method, which throws an exception if the confirmations are not received within the specified time.\n\nIMPORTANT: There must be no thread hands-off in the downstream flow (`QueueChannel`, `ExecutorChannel`, and others).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/strict-ordering.adoc", "title": "strict-ordering", "heading": "Outbound", "heading_level": 2, "file_order": 17, "section_index": 2, "content_hash": "80bd01e640920e5c31ef63fcc09e7d42dfc5a81aba33790ff8ff5adcd0b87c53", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/strict-ordering.adoc"}}
{"id": "sha256:751da8d07e0f80b03b8c97e57595fb39a48904d6d90f7b82cb6a48b1a4107971", "content": "[[amqp-user-id]]\n\nSpring AMQP version 1.6 introduced a mechanism to allow the specification of a default user ID for outbound messages.\nIt has always been possible to set the `AmqpHeaders.USER_ID` header, which now takes precedence over the default.\nThis might be useful to message recipients.\nFor inbound messages, if the message publisher sets the property, it is made available in the `AmqpHeaders.RECEIVED_USER_ID` header.\nNote that RabbitMQ https://www.rabbitmq.com/validated-user-id.html[validates that the user ID is the actual user ID for the connection or that the connection allows impersonation].\n\nTo configure a default user ID for outbound messages, configure it on a `RabbitTemplate` and configure the outbound adapter or gateway to use that template.\nSimilarly, to set the user ID property on replies, inject an appropriately configured template into the inbound gateway.\nSee the https://docs.spring.io/spring-amqp/reference/html/_reference.html#template-user-id[Spring AMQP documentation] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp/user-id.adoc", "title": "user-id", "heading": "user-id", "heading_level": 1, "file_order": 18, "section_index": 0, "content_hash": "751da8d07e0f80b03b8c97e57595fb39a48904d6d90f7b82cb6a48b1a4107971", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp/user-id.adoc"}}
{"id": "sha256:4074282e5b2d4dea1245be46d04d5b9dfd892f6cdeece63b7119200458e9b2f3", "content": "[[channel-configuration]]\n\nTo create a message channel instance, you can use the `<channel/>` element for xml or `DirectChannel` instance for Java configuration, as follows:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic MessageChannel exampleChannel() {\n return new DirectChannel();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"exampleChannel\"/>\n----\n======\n\nWhen you use the `<channel/>` element without any sub-elements, it creates a `DirectChannel` instance (a `SubscribableChannel`).\n\nTo create a publish-subscribe channel, use the `<publish-subscribe-channel/>` element (the `PublishSubscribeChannel` in Java), as follows:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic MessageChannel exampleChannel() {\n return new PublishSubscribeChannel();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:publish-subscribe-channel id=\"exampleChannel\"/>\n----\n======\n\nYou can alternatively provide a variety of `<queue/>` sub-elements to create any of the pollable channel types (as described in xref:channel/implementations.adoc[Message Channel Implementations]).\nThe following sections show examples of each channel type.\n\n[[channel-configuration-directchannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "configuration", "heading_level": 1, "file_order": 19, "section_index": 0, "content_hash": "4074282e5b2d4dea1245be46d04d5b9dfd892f6cdeece63b7119200458e9b2f3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:fff1409ea94feadb27b1232a7a114f0d31f22a7adeaa7590261dc2421b6d18db", "content": "As mentioned earlier, `DirectChannel` is the default type.\nThe following listing shows who to define one:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic MessageChannel directChannel() {\n return new DirectChannel();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"directChannel\"/>\n----\n======\n\nA default channel has a round-robin load-balancer and also has failover enabled (see xref:channel/implementations.adoc#channel-implementations-directchannel[`DirectChannel`] for more detail).\nTo disable one or both of these, add a `<dispatcher/>` sub-element (a `LoadBalancingStrategy` constructor of the `DirectChannel`) and configure the attributes as follows:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic MessageChannel failFastChannel() {\n DirectChannel channel = new DirectChannel();\n channel.setFailover(false);\n return channel;\n}\n\n@Bean\npublic MessageChannel failFastChannel() {\n return new DirectChannel(null);\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"failFastChannel\">\n <int:dispatcher failover=\"false\"/>\n</channel>\n\n<int:channel id=\"channelWithFixedOrderSequenceFailover\">\n <int:dispatcher load-balancer=\"none\"/>\n</int:channel>\n----\n======\n\nStarting with version 6.3, all the `MessageChannel` implementations based on the `UnicastingDispatcher` can be configured with a `Predicate<Exception> failoverStrategy` instead of plain `failover` option.\nThis predicate makes a decision to failover or not to the next `MessageHandler` based on an exception thrown from the current one.\nThe more complex error analysis should be done using xref:router/implementations.adoc#router-implementations-exception-router[`ErrorMessageExceptionTypeRouter`].\n\n[[channel-datatype-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "`DirectChannel` Configuration", "heading_level": 2, "file_order": 19, "section_index": 1, "content_hash": "fff1409ea94feadb27b1232a7a114f0d31f22a7adeaa7590261dc2421b6d18db", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:2fd86603dde387b93da4a6a3ec91c74ac69cbacae85c08972478af79d7cff53d", "content": "Sometimes, a consumer can process only a particular type of payload, forcing you to ensure the payload type of the input messages.\nThe first thing that comes to mind may be to use a message filter.\nHowever, all that message filter can do is filter out messages that are not compliant with the requirements of the consumer.\nAnother way would be to use a content-based router and route messages with non-compliant data-types to specific transformers to enforce transformation and conversion to the required data type.\nThis would work, but a simpler way to accomplish the same thing is to apply the https://www.enterpriseintegrationpatterns.com/DatatypeChannel.html[Datatype Channel] pattern.\nYou can use separate datatype channels for each specific payload data type.\n\nTo create a datatype channel that accepts only messages that contain a certain payload type, provide the data type's fully qualified class name in the channel element's `datatype` attribute, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic MessageChannel numberChannel() {\n DirectChannel channel = new DirectChannel();\n channel.setDatatypes(Number.class);\n return channel;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"numberChannel\" datatype=\"java.lang.Number\"/>\n----\n======\n\nNote that the type check passes for any type that is assignable to the channel's datatype.\nIn other words, the `numberChannel` in the preceding example would accept messages whose payload is `java.lang.Integer` or `java.lang.Double`.\nMultiple types can be provided as a comma-delimited list, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic MessageChannel numberChannel() {\n DirectChannel channel = new DirectChannel();\n channel.setDatatypes(String.class, Number.class);\n return channel;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"stringOrNumberChannel\" datatype=\"java.lang.String,java.lang.Number\"/>\n----\n======\n\nSo the 'numberChannel' in the preceding example accepts only messages with a data type of `java.lang.Number`.\nBut what happens if the payload of the message is not of the required type?\nIt depends on whether you have defined a bean named `integrationConversionService` that is an instance of Spring's https://docs.spring.io/spring/docs/current/spring-framework-reference/html/validation.html#core-convert-ConversionService-API[Conversion Service].\nIf not, then an `Exception` would be thrown immediately.\nHowever, if you have defined an `integrationConversionService` bean, it is used in an attempt to convert the message's payload to the acceptable type.\n\nYou can even register custom converters.\nFor example, suppose you send a message with a `String` payload to the 'numberChannel' we configured above.\nYou might handle the message as follows:\n\n[source,java]\n----\nMessageChannel inChannel = context.getBean(\"numberChannel\", MessageChannel.class);\ninChannel.send(new GenericMessage<String>(\"5\"));\n----\n\nTypically, this would be a perfectly legal operation.\nHowever, since we use Datatype Channel, the result of such an operation would generate an exception similar to the following:\n\n[source]\n----\nException in thread \"main\" org.springframework.integration.MessageDeliveryException:\nChannel 'numberChannel'\nexpected one of the following datataypes [class java.lang.Number],\nbut received [class java.lang.String]\n\n----\n\nThe exception happens because we require the payload type to be a `Number`, but we sent a `String`.\nSo we need something to convert a `String` to a `Number`.\nFor that, we can implement a converter similar to the following example:\n\n[source,java]\n----\npublic static class StringToIntegerConverter implements Converter<String, Integer> {\n public Integer convert(String source) {\n return Integer.parseInt(source);\n }\n}\n----\n\nThen we can register it as a converter with the Integration Conversion Service, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\n@IntegrationConverter\npublic StringToIntegerConverter strToInt() {\n return new StringToIntegerConverter();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:converter ref=\"strToInt\"/>\n\n<bean id=\"strToInt\" class=\"org.springframework.integration.util.Demo.StringToIntegerConverter\"/>\n----\n======\n\nOr on the `StringToIntegerConverter` class when it is marked with the `@Component` annotation for auto-scanning.\n\nWhen the 'converter' element is parsed, it creates the `integrationConversionService` bean if one is not already defined.\nWith that converter in place, the `send` operation would now be successful, because the datatype channel uses that converter to convert the `String` payload to an `Integer`.\n\nFor more information regarding payload type conversion, see xref:endpoint.adoc#payload-type-conversion[Payload Type Conversion].\n\nBeginning with version 4.0, the `integrationConversionService` is invoked by the `DefaultDatatypeChannelMessageConverter`, which looks up the conversion service in the application context.\nTo use a different conversion technique, you can specify the `message-converter` attribute on the channel.\nThis must be a reference to a `MessageConverter` implementation.\nOnly the `fromMessage` method is used.\nIt provides the converter with access to the message headers (in case the conversion might need information from the headers, such as `content-type`).\nThe method can return only the converted payload or a full `Message` object.\nIf the latter, the converter must be careful to copy all the headers from the inbound message.\n\nAlternatively, you can declare a `<bean/>` of type `MessageConverter` with an ID of `datatypeChannelMessageConverter`, and that converter is used by all channels with a `datatype`.\n\n[[channel-configuration-queuechannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "Datatype Channel Configuration", "heading_level": 2, "file_order": 19, "section_index": 2, "content_hash": "2fd86603dde387b93da4a6a3ec91c74ac69cbacae85c08972478af79d7cff53d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:660c3201e6565e7544884beb870e9b757a21e88df3816e19a48a660fac7bf6e6", "content": "To create a `QueueChannel`, use the `<queue/>` sub-element.\nYou may specify the channel's capacity as follows:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic PollableChannel queueChannel() {\n return new QueueChannel(25);\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"queueChannel\">\n <queue capacity=\"25\"/>\n</int:channel>\n----\n======\n\nNOTE: If you do not provide a value for the 'capacity' attribute on this `<queue/>` sub-element, the resulting queue is unbounded.\nTo avoid issues such as running out of memory, we highly recommend that you set an explicit value for a bounded queue.\n\n[[persistent-queuechannel-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "`QueueChannel` Configuration", "heading_level": 2, "file_order": 19, "section_index": 3, "content_hash": "660c3201e6565e7544884beb870e9b757a21e88df3816e19a48a660fac7bf6e6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:725f053db5eae41f2ac8a997e6becd7aa6d9416a53b4d947cb0ea405aa9ffabf", "content": "Since a `QueueChannel` provides the capability to buffer messages but does so in-memory only by default, it also introduces a possibility that messages could be lost in the event of a system failure.\nTo mitigate this risk, a `QueueChannel` may be backed by a persistent implementation of the `MessageGroupStore` strategy interface.\nFor more details on `MessageGroupStore` and `MessageStore`, see xref:message-store.adoc[Message Store].\n\nIMPORTANT: The `capacity` attribute is not allowed when the `message-store` attribute is used.\n\nWhen a `QueueChannel` receives a `Message`, it adds the message to the message store.\nWhen a `Message` is polled from a `QueueChannel`, it is removed from the message store.\n\nBy default, a `QueueChannel` stores its messages in an in-memory queue, which can lead to the lost message scenario mentioned earlier.\nHowever, Spring Integration provides persistent stores, such as the `JdbcChannelMessageStore`.\n\nYou can configure a message store for any `QueueChannel` by adding the `message-store` attribute, as the following example shows:\n\n[source,xml]\n----\n<int:channel id=\"dbBackedChannel\">\n <int:queue message-store=\"channelStore\"/>\n</int:channel>\n\n<bean id=\"channelStore\" class=\"o.s.i.jdbc.store.JdbcChannelMessageStore\">\n <property name=\"dataSource\" ref=\"dataSource\"/>\n <property name=\"channelMessageStoreQueryProvider\" ref=\"queryProvider\"/>\n</bean>\n----\n\n(See samples below for Java/Kotlin Configuration options.)\n\nThe Spring Integration JDBC module also provides a schema Data Definition Language (DDL) for a number of popular databases.\nThese schemas are located in the org.springframework.integration.jdbc.store.channel package of that module (`spring-integration-jdbc`).\n\nIMPORTANT: One important feature is that, with any transactional persistent store (such as `JdbcChannelMessageStore`), as long as the poller has a transaction configured, a message removed from the store can be permanently removed only if the transaction completes successfully.\nOtherwise, the transaction rolls back, and the `Message` is not lost.\n\nMany other implementations of the message store are available as the growing number of Spring projects related to \"`NoSQL`\" data stores comes to provide underlying support for these stores.\nYou can also provide your own implementation of the `MessageGroupStore` interface if you cannot find one that meets your particular needs.\n\nSince version 4.0, we recommend that `QueueChannel` instances be configured to use a `ChannelMessageStore`, if possible.\nThese are generally optimized for this use, as compared to a general message store.\nIf the `ChannelMessageStore` is a `ChannelPriorityMessageStore`, the messages are received in FIFO within priority order.\nThe notion of priority is determined by the message store implementation.\nFor example, the following example shows the Java configuration for the xref:mongodb.adoc#mongodb-priority-channel-message-store[MongoDB Channel Message Store]:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic BasicMessageGroupStore mongoDbChannelMessageStore(MongoDbFactory mongoDbFactory) {\n MongoDbChannelMessageStore store = new MongoDbChannelMessageStore(mongoDbFactory);\n store.setPriorityEnabled(true);\n return store;\n}\n\n@Bean\npublic PollableChannel priorityQueue(BasicMessageGroupStore mongoDbChannelMessageStore) {\n return new PriorityChannel(new MessageGroupQueue(mongoDbChannelMessageStore, \"priorityQueue\"));\n}\n----\n\nJava DSL::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\npublic IntegrationFlow priorityFlow(PriorityCapableChannelMessageStore mongoDbChannelMessageStore) {\n return IntegrationFlow.from((Channels c) ->\n c.priority(\"priorityChannel\", mongoDbChannelMessageStore, \"priorityGroup\"))\n ....\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun priorityFlow(mongoDbChannelMessageStore: PriorityCapableChannelMessageStore) =\n integrationFlow {\n channel { priority(\"priorityChannel\", mongoDbChannelMessageStore, \"priorityGroup\") }\n }\n----\n======\n\nNOTE: Pay attention to the `MessageGroupQueue` class.\nThat is a `BlockingQueue` implementation to use the `MessageGroupStore` operations.\n\nAnother option to customize the `QueueChannel` environment is provided by the `ref` attribute of the `<int:queue>` sub-element or its particular constructor.\nThis attribute supplies the reference to any `java.util.Queue` implementation.\nFor example, a Hazelcast distributed https://hazelcast.com/use-cases/imdg/imdg-messaging/[`IQueue`] can be configured as follows:\n\n[source,java]\n----\n@Bean\npublic HazelcastInstance hazelcastInstance() {\n return Hazelcast.newHazelcastInstance(new Config()\n .setProperty(\"hazelcast.logging.type\", \"log4j\"));\n}\n\n@Bean\npublic PollableChannel distributedQueue() {\n return new QueueChannel(hazelcastInstance()\n .getQueue(\"springIntegrationQueue\"));\n}\n----\n\n[[channel-configuration-pubsubchannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "Persistent `QueueChannel` Configuration", "heading_level": 3, "file_order": 19, "section_index": 4, "content_hash": "725f053db5eae41f2ac8a997e6becd7aa6d9416a53b4d947cb0ea405aa9ffabf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:6937fa3d37cce8e2a79d9eb3febae0e915515721966995eaf65c0b5ae7eb2b04", "content": "To create a `PublishSubscribeChannel`, use the <publish-subscribe-channel/> element.\nWhen using this element, you can also specify the `task-executor` used for publishing messages (if none is specified, it publishes in the sender's thread), as follows:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic MessageChannel pubsubChannel() {\n return new PublishSubscribeChannel(someExecutor());\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:publish-subscribe-channel id=\"pubsubChannel\" task-executor=\"someExecutor\"/>\n----\n======\n\nIf you provide a resequencer or aggregator downstream from a `PublishSubscribeChannel`, you can set the 'apply-sequence' property on the channel to `true`.\nDoing so indicates that the channel should set the `sequence-size` and `sequence-number` message headers as well as the correlation ID prior to passing along the messages.\nFor example, if there are five subscribers, the `sequence-size` would be set to `5`, and the messages would have `sequence-number` header values ranging from `1` to `5`.\n\nAlong with the `Executor`, you can also configure an `ErrorHandler`.\nBy default, the `PublishSubscribeChannel` uses a `MessagePublishingErrorHandler` implementation to send an error to the `MessageChannel` from the `errorChannel` header or into the global `errorChannel` instance.\nIf an `Executor` is not configured, the `ErrorHandler` is ignored and exceptions are thrown directly to the caller's thread.\n\nIf you provide a `Resequencer` or `Aggregator` downstream from a `PublishSubscribeChannel`, you can set the 'apply-sequence' property on the channel to `true`.\nDoing so indicates that the channel should set the sequence-size and sequence-number message headers as well as the correlation ID prior to passing along the messages.\nFor example, if there are five subscribers, the sequence-size would be set to `5`, and the messages would have sequence-number header values ranging from `1` to `5`.\n\nThe following example shows how to set the `apply-sequence` header to `true`:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic MessageChannel pubsubChannel() {\n PublishSubscribeChannel channel = new PublishSubscribeChannel();\n channel.setApplySequence(true);\n return channel;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:publish-subscribe-channel id=\"pubsubChannel\" apply-sequence=\"true\"/>\n----\n======\n\nNOTE: The `apply-sequence` value is `false` by default so that a publish-subscribe channel can send the exact same message instances to multiple outbound channels.\nSince Spring Integration enforces immutability of the payload and header references, when the flag is set to `true`, the channel creates new `Message` instances with the same payload reference but different header values.\n\nStarting with version 5.4.3, the `PublishSubscribeChannel` can also be configured with the `requireSubscribers` option of its `BroadcastingDispatcher` to indicate that this channel will not ignore a message silently when it has no subscribers.\nA `MessageDispatchingException` with a `Dispatcher has no subscribers` message is thrown when there are no subscribers and this option is set to `true`.\n\n[[channel-configuration-executorchannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "`PublishSubscribeChannel` Configuration", "heading_level": 2, "file_order": 19, "section_index": 5, "content_hash": "6937fa3d37cce8e2a79d9eb3febae0e915515721966995eaf65c0b5ae7eb2b04", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:ac03494de94ec4017adeed12ca117e226db89bca5b0b4953c09ca52bc6a98c43", "content": "To create an `ExecutorChannel`, add the `<dispatcher>` sub-element with a `task-executor` attribute.\nThe attribute's value can reference any `TaskExecutor` within the context.\nFor example, doing so enables configuration of a thread pool for dispatching messages to subscribed handlers.\nAs mentioned earlier, doing so breaks the single-threaded execution context between sender and receiver so that any active transaction context is not shared by the invocation of the handler (that is, the handler may throw an `Exception`, but the `send` invocation has already returned successfully).\nThe following example shows how to use the `dispatcher` element and specify an executor in the `task-executor` attribute:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic MessageChannel executorChannel() {\n return new ExecutorChannel(someExecutor());\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"executorChannel\">\n <int:dispatcher task-executor=\"someExecutor\"/>\n</int:channel>\n----\n======\n\n[NOTE]\n=====\nThe `load-balancer` and `failover` options are also both available on the `<dispatcher/>` subelement, as described earlier in xref:channel/configuration.adoc#channel-configuration-directchannel[`DirectChannel` Configuration].\nThe same defaults apply.\nConsequently, the channel has a round-robin load-balancing strategy with failover enabled unless explicit configuration is provided for one or both of those attributes, as the following example shows:\n\n[source,xml]\n----\n<int:channel id=\"executorChannelWithoutFailover\">\n <int:dispatcher task-executor=\"someExecutor\" failover=\"false\"/>\n</int:channel>\n----\n=====\n\n[[channel-configuration-prioritychannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "`ExecutorChannel`", "heading_level": 2, "file_order": 19, "section_index": 6, "content_hash": "ac03494de94ec4017adeed12ca117e226db89bca5b0b4953c09ca52bc6a98c43", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:f9649caad04d03da2c35922deaa74c90cd1313614fef6328c2fe3c47aae17af0", "content": "To create a `PriorityChannel`, use the `<priority-queue/>` sub-element, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic PollableChannel priorityChannel() {\n return new PriorityChannel(20);\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"priorityChannel\">\n <int:priority-queue capacity=\"20\"/>\n</int:channel>\n----\n======\n\nBy default, the channel consults the `priority` header of the message.\nHowever, you can instead provide a custom `Comparator` reference.\nAlso, note that the `PriorityChannel` (like the other types) does support the `datatype` attribute.\nAs with the `QueueChannel`, it also supports a `capacity` attribute.\nThe following example demonstrates all of these:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic PollableChannel priorityChannel() {\n PriorityChannel channel = new PriorityChannel(20, widgetComparator());\n channel.setDatatypes(example.Widget.class);\n return channel;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"priorityChannel\" datatype=\"example.Widget\">\n <int:priority-queue comparator=\"widgetComparator\"\n capacity=\"10\"/>\n</int:channel>\n----\n======\n\nSince version 4.0, the `priority-channel` child element supports the `message-store` option (`comparator` and `capacity` are not allowed in that case).\nThe message store must be a `PriorityCapableChannelMessageStore`.\nImplementations of the `PriorityCapableChannelMessageStore` are currently provided for `Redis`, `JDBC`, and `MongoDB`.\nSee xref:channel/configuration.adoc#channel-configuration-queuechannel[`QueueChannel` Configuration] and xref:message-store.adoc[Message Store] for more information.\nYou can find sample configuration in xref:jdbc/message-store.adoc#jdbc-message-store-channels[Backing Message Channels].\n\n[[channel-configuration-rendezvouschannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "`PriorityChannel` Configuration", "heading_level": 2, "file_order": 19, "section_index": 7, "content_hash": "f9649caad04d03da2c35922deaa74c90cd1313614fef6328c2fe3c47aae17af0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:b88ac5655207816eb5e3920d7f0166a3cb1e82371eff03fe7f1d02c27b18aa1a", "content": "A `RendezvousChannel` is created when the queue subelement is a `<rendezvous-queue>`.\nIt does not provide any additional configuration options to those described earlier, and its queue does not accept any capacity value, since it is a zero-capacity direct handoff queue.\nThe following example shows how to declare a `RendezvousChannel`:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic PollableChannel rendezvousChannel() {\n return new RendezvousChannel();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"rendezvousChannel\"/>\n <int:rendezvous-queue/>\n</int:channel>\n----\n======\n\n[[channel-configuration-threadlocalchannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "`RendezvousChannel` Configuration", "heading_level": 2, "file_order": 19, "section_index": 8, "content_hash": "b88ac5655207816eb5e3920d7f0166a3cb1e82371eff03fe7f1d02c27b18aa1a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:591f3a85d1325714d599ad18422ab4f1b769edb9dcfdfc5ad40125f32b8e7498", "content": "Any channel can be configured with a `scope` attribute, as the following example shows:\n\n[source,xml]\n----\n<int:channel id=\"threadLocalChannel\" scope=\"thread\"/>\n----\n\n[[channel-configuration-interceptors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "Scoped Channel Configuration", "heading_level": 2, "file_order": 19, "section_index": 9, "content_hash": "591f3a85d1325714d599ad18422ab4f1b769edb9dcfdfc5ad40125f32b8e7498", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:5106c5b034384997f63529cc321ae996f3db11f573d73f011ffe44543109d578", "content": "Message channels may also have interceptors, as described in xref:channel/interceptors.adoc[Channel Interceptors].\nThe `<interceptors/>` sub-element can be added to a `<channel/>` (or the more specific element types).\nYou can provide the `ref` attribute to reference any Spring-managed object that implements the `ChannelInterceptor` interface, as the following example shows:\n\n[source,xml]\n----\n<int:channel id=\"exampleChannel\">\n <int:interceptors>\n <ref bean=\"trafficMonitoringInterceptor\"/>\n </int:interceptors>\n</int:channel>\n----\n\nIn general, we recommend defining the interceptor implementations in a separate location, since they usually provide common behavior that can be reused across multiple channels.\n\n[[global-channel-configuration-interceptors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "Channel Interceptor Configuration", "heading_level": 2, "file_order": 19, "section_index": 10, "content_hash": "5106c5b034384997f63529cc321ae996f3db11f573d73f011ffe44543109d578", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:a7e642265071ccdab696bd05f7a9a93893e89079bf26fa409c45e89d2a4628f3", "content": "Channel interceptors provide a clean and concise way of applying cross-cutting behavior per individual channel.\nIf the same behavior should be applied on multiple channels, configuring the same set of interceptors for each channel would not be the most efficient way.\nTo avoid repeated configuration while also enabling interceptors to apply to multiple channels, Spring Integration provides global interceptors.\nConsider the following pair of examples:\n\n[source,xml]\n----\n<int:channel-interceptor pattern=\"input*, thing2*, thing1, !cat*\" order=\"3\">\n <bean class=\"thing1.thing2SampleInterceptor\"/>\n</int:channel-interceptor>\n----\n\n[source,xml]\n----\n<int:channel-interceptor ref=\"myInterceptor\" pattern=\"input*, thing2*, thing1, !cat*\" order=\"3\"/>\n\n<bean id=\"myInterceptor\" class=\"thing1.thing2SampleInterceptor\"/>\n----\n\nEach `<channel-interceptor/>` element lets you define a global interceptor, which is applied on all channels that match any patterns defined by the `pattern` attribute.\nIn the preceding case, the global interceptor is applied on the 'thing1' channel and all other channels that begin with 'thing2' or 'input' but not to channels starting with 'thing3' (since version 5.0).\n\nWARNING: The addition of this syntax to the pattern causes one possible (though perhaps unlikely) problem.\nIf you have a bean named `!thing1` and you included a pattern of `!thing1` in your channel interceptor's `pattern` patterns, it no longer matches.\nThe pattern now matches all beans not named `thing1`.\nIn this case, you can escape the `!` in the pattern with `\\`.\nThe pattern `\\!thing1` matches a bean named `!thing1`.\n\nThe order attribute lets you manage where this interceptor is injected when there are multiple interceptors on a given channel.\nFor example, channel 'inputChannel' could have individual interceptors configured locally, as the following example shows:\n\n[source,xml]\n----\n<int:channel id=\"inputChannel\">\n <int:interceptors>\n <int:wire-tap channel=\"logger\"/>\n </int:interceptors>\n</int:channel>\n----\n\nA reasonable question is \"`how a global interceptor is injected in relation to other interceptors configured locally or through other global interceptor definitions?`\"\nThe current implementation provides a simple mechanism for defining the order of interceptor execution.\nA positive number in the `order` attribute ensures interceptor injection after any existing interceptors, while a negative number ensures that the interceptor is injected before existing interceptors.\nThis means that, in the preceding example, the global interceptor is injected after (since its `order` is greater than `0`) the 'wire-tap' interceptor configured locally.\nIf there were another global interceptor with a matching `pattern`, its order would be determined by comparing the values of both interceptors' `order` attributes.\nTo inject a global interceptor before the existing interceptors, use a negative value for the `order` attribute.\n\nNOTE: Note that both the `order` and `pattern` attributes are optional.\nThe default value for `order` will be 0 and for `pattern`, the default is '*' (to match all channels).\n\n[[channel-wiretap]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "Global Channel Interceptor Configuration", "heading_level": 2, "file_order": 19, "section_index": 11, "content_hash": "a7e642265071ccdab696bd05f7a9a93893e89079bf26fa409c45e89d2a4628f3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:fe9ce9ffcaf5e7eb224abbb9f650c156c7587c70b0f4af5bde14a17c512c738d", "content": "As mentioned earlier, Spring Integration provides a simple wire tap interceptor.\nYou can configure a wire tap on any channel within an `<interceptors/>` element.\nDoing so is especially useful for debugging and can be used in conjunction with Spring Integration's logging channel adapter as follows:\n\n[source,xml]\n----\n<int:channel id=\"in\">\n <int:interceptors>\n <int:wire-tap channel=\"logger\"/>\n </int:interceptors>\n</int:channel>\n\n<int:logging-channel-adapter id=\"logger\" level=\"DEBUG\"/>\n----\n\nTIP: The 'logging-channel-adapter' also accepts an 'expression' attribute so that you can evaluate a SpEL expression against the 'payload' and 'headers' variables.\nAlternatively, to log the full message `toString()` result, provide a value of `true` for the 'log-full-message' attribute.\nBy default, it is `false` so that only the payload is logged.\nSetting it to `true` enables logging of all headers in addition to the payload.\nThe 'expression' option provides the most flexibility, (for example, `expression=\"payload.user.name\"`).\n\nOne of the common misconceptions about the wire tap and other similar components (xref:message-publishing.adoc#message-publishing-config[Message Publishing Configuration]) is that they are automatically asynchronous in nature.\nBy default, wire tap as a component is not invoked asynchronously.\nInstead, Spring Integration focuses on a single unified approach to configuring asynchronous behavior: the message channel.\nWhat makes certain parts of the message flow synchronous or asynchronous is the type of Message Channel that has been configured within that flow.\nThat is one of the primary benefits of the message channel abstraction.\nFrom the inception of the framework, we have always emphasized the need and the value of the message channel as a first-class citizen of the framework.\nIt is not just an internal, implicit realization of the EIP pattern.\nIt is fully exposed as a configurable component to the end user.\nSo, the wire tap component is only responsible for performing the following tasks:\n\n* Intercept a message flow by tapping into a channel, (for example, `channelA`)\n* Grab each message\n* Send the message to another channel, (for example, `channelB`)\n\nIt is essentially a variation of the bridge pattern, but it is encapsulated within a channel definition (and hence easier to enable and disable without disrupting a flow).\nAlso, unlike the bridge, it basically forks another message flow.\nIs that flow synchronous or asynchronous? The answer depends on the type of message channel that 'channelB' is.\nWe have the following options: direct channel, pollable channel, and executor channel.\nThe last two break the thread boundary, making communication over such channels asynchronous, because the dispatching of the message from that channel to its subscribed handlers happens on a different thread than the one used to send the message to that channel.\nThat is what is going to make your wire-tap flow synchronous or asynchronous.\nIt is consistent with other components within the framework (such as message publisher) and adds a level of consistency and simplicity by sparing you from worrying in advance (other than writing thread-safe code) about whether a particular piece of code should be implemented as synchronous or asynchronous.\nThe actual wiring of two pieces of code, (say, component A and component B) over a message channel is what makes their collaboration synchronous or asynchronous.\nYou may even want to change from synchronous to asynchronous in the future, and a message channel lets you do it swiftly without ever touching the code.\n\nOne final point regarding the wire tap is that, despite the rationale provided above for not being asynchronous by default, you should keep in mind that it is usually desirable to hand off the message as soon as possible.\nTherefore, it would be quite common to use an asynchronous channel option as the wire tap's outbound channel.\nHowever, the asynchronous behavior is not enforced by default.\nThere are a number of use cases that would break if we did, including that you might not want to break a transactional boundary.\nPerhaps you use the wire tap pattern for auditing purposes, and you do want the audit messages to be sent within the original transaction.\nAs an example, you might connect the wire tap to a JMS outbound channel adapter.\nThat way, you get the best of both worlds: 1) the sending of a JMS Message can occur within the transaction while 2) it is still a \"`fire-and-forget`\" action, thereby preventing any noticeable delay in the main message flow.\n\nIMPORTANT: Starting with version 4.0, it is important to avoid circular references when an interceptor (such as the https://docs.spring.io/autorepo/docs/spring-integration/current/api/org/springframework/integration/channel/interceptor/WireTap.html[`WireTap` class]) references a channel.\nYou need to exclude such channels from those being intercepted by the current interceptor.\nThis can be done with appropriate patterns or programmatically.\nIf you have a custom `ChannelInterceptor` that references a `channel`, consider implementing `VetoCapableInterceptor`.\nThat way, the framework asks the interceptor if it is OK to intercept each channel that is a candidate, based on the supplied pattern.\nYou can also add runtime protection in the interceptor methods to ensure that the channel is not one that is referenced by the interceptor.\nThe `WireTap` uses both of these techniques.\n\nStarting with version 4.3, the `WireTap` has additional constructors that take a `channelName` instead of a\n`MessageChannel` instance.\nThis can be convenient for Java configuration and when channel auto-creation logic is being used.\nThe target `MessageChannel` bean is resolved from the provided `channelName` later, on the first interaction with the\ninterceptor.\n\nIMPORTANT: Channel resolution requires a `BeanFactory`, so the wire tap instance must be a Spring-managed bean.\n\nThis late-binding approach also allows simplification of typical wire-tapping patterns with Java DSL configuration, as the following example shows:\n\n[source,java]\n----\n@Bean\npublic PollableChannel myChannel() {\n return MessageChannels.queue()\n .wireTap(\"loggingFlow.input\")\n .get();\n}\n\n@Bean\npublic IntegrationFlow loggingFlow() {\n return f -> f.log();\n}\n----\n\n[[conditional-wiretap]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "Wire Tap", "heading_level": 2, "file_order": 19, "section_index": 12, "content_hash": "fe9ce9ffcaf5e7eb224abbb9f650c156c7587c70b0f4af5bde14a17c512c738d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:5f385615cc85a6b61bbdfb205ba3c07c50a6a9c52847c5b71a6d1495a3d37dd5", "content": "Wire taps can be made conditional by using the `selector` or `selector-expression` attributes.\nThe `selector` references a `MessageSelector` bean, which can determine at runtime whether the message should go to the tap channel.\nSimilarly, the `selector-expression` is a boolean SpEL expression that performs the same purpose: If the expression evaluates to `true`, the message is sent to the tap channel.\n\n[[channel-global-wiretap]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "Conditional Wire Taps", "heading_level": 2, "file_order": 19, "section_index": 13, "content_hash": "5f385615cc85a6b61bbdfb205ba3c07c50a6a9c52847c5b71a6d1495a3d37dd5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:37693968f7d9a8eb181de4347424b14865d7fce119bb4042119790a46694e726", "content": "It is possible to configure a global wire tap as a special case of the xref:channel/configuration.adoc#global-channel-configuration-interceptors[Global Channel Interceptor Configuration].\nTo do so, configure a top level `wire-tap` element.\nNow, in addition to the normal `wire-tap` namespace support, the `pattern` and `order` attributes are supported and work in exactly the same way as they do for the `channel-interceptor`.\nThe following example shows how to configure a global wire tap:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\n@GlobalChannelInterceptor(patterns = \"input*,thing2*,thing1\", order = 3)\npublic WireTap wireTap(MessageChannel wiretapChannel) {\n return new WireTap(wiretapChannel);\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:wire-tap pattern=\"input*, thing2*, thing1\" order=\"3\" channel=\"wiretapChannel\"/>\n----\n======\n\nTIP: A global wire tap provides a convenient way to configure a single-channel wire tap externally without modifying the existing channel configuration.\nTo do so, set the `pattern` attribute to the target channel name.\nFor example, you can use this technique to configure a test case to verify messages on a channel.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/configuration.adoc", "title": "configuration", "heading": "Global Wire Tap Configuration", "heading_level": 2, "file_order": 19, "section_index": 14, "content_hash": "37693968f7d9a8eb181de4347424b14865d7fce119bb4042119790a46694e726", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/configuration.adoc"}}
{"id": "sha256:6dd1d81d63838f8ee743d5f42eb5a9fa1d0102e292a8c127c56ae47bf1a05ae3", "content": "[[channel-implementations]]\n\nSpring Integration provides different message channel implementations.\nThe following sections briefly describe each one.\n\n[[channel-implementations-publishsubscribechannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/implementations.adoc", "title": "implementations", "heading": "implementations", "heading_level": 1, "file_order": 20, "section_index": 0, "content_hash": "6dd1d81d63838f8ee743d5f42eb5a9fa1d0102e292a8c127c56ae47bf1a05ae3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/implementations.adoc"}}
{"id": "sha256:7df635c35e25cbcfb6530c3658dc803e3150641f5b0d2e2a0a40861c7f88fbf3", "content": "The `PublishSubscribeChannel` implementation broadcasts any `Message` sent to it to all of its subscribed handlers.\nThis is most often used for sending event messages, whose primary role is notification (as opposed to document messages, which are generally intended to be processed by a single handler).\nNote that the `PublishSubscribeChannel` is intended for sending only.\nSince it broadcasts to its subscribers directly when its `send(Message)` method is invoked, consumers cannot poll for messages (it does not implement `PollableChannel` and therefore has no `receive()` method).\nInstead, any subscriber must itself be a `MessageHandler`, and the subscriber's `handleMessage(Message)` method is invoked in turn.\n\nPrior to version 3.0, invoking the `send` method on a `PublishSubscribeChannel` that had no subscribers returned `false`.\nWhen used in conjunction with a `MessagingTemplate`, a `MessageDeliveryException` was thrown.\nStarting with version 3.0, the behavior has changed such that a `send` is always considered successful if at least the minimum subscribers are present (and successfully handle the message).\nThis behavior can be modified by setting the `minSubscribers` property, which defaults to `0`.\n\nNOTE: If you use a `TaskExecutor`, only the presence of the correct number of subscribers is used for this determination, because the actual handling of the message is performed asynchronously.\n\n[[channel-implementations-queuechannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/implementations.adoc", "title": "implementations", "heading": "`PublishSubscribeChannel`", "heading_level": 2, "file_order": 20, "section_index": 1, "content_hash": "7df635c35e25cbcfb6530c3658dc803e3150641f5b0d2e2a0a40861c7f88fbf3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/implementations.adoc"}}
{"id": "sha256:8bd6929aeb7b47af6595e90288d786fa51e249907b1dab1790a0cf8fba8261e9", "content": "The `QueueChannel` implementation wraps a queue.\nUnlike the `PublishSubscribeChannel`, the `QueueChannel` has point-to-point semantics.\nIn other words, even if the channel has multiple consumers, only one of them should receive any `Message` sent to that channel.\nIt provides a default no-argument constructor (providing an essentially unbounded capacity of `Integer.MAX_VALUE`) as well as a constructor that accepts the queue capacity, as the following listing shows:\n\n[source,java]\n----\npublic QueueChannel(int capacity)\n----\n\nA channel that has not reached its capacity limit stores messages in its internal queue, and the `send(Message<?>)` method returns immediately, even if no receiver is ready to handle the message.\nIf the queue has reached capacity, the sender blocks until room is available in the queue.\nAlternatively, if you use the send method that has an additional timeout parameter, the queue blocks until either room is available or the timeout period elapses, whichever occurs first.\nSimilarly, a `receive()` call returns immediately if a message is available on the queue, but, if the queue is empty, then a `receive` call may block until either a message is available or the timeout, if provided, elapses.\nIn either case, it is possible to force an immediate return regardless of the queue's state by passing a timeout value of 0.\nNote, however, that calls the versions of `send()` and `receive()` with no `timeout` parameter block indefinitely.\n\n[[channel-implementations-prioritychannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/implementations.adoc", "title": "implementations", "heading": "`QueueChannel`", "heading_level": 2, "file_order": 20, "section_index": 2, "content_hash": "8bd6929aeb7b47af6595e90288d786fa51e249907b1dab1790a0cf8fba8261e9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/implementations.adoc"}}
{"id": "sha256:24de7cac83360f496a52ff4d77048d36306c98a3dc755685fd2153dd62ca731d", "content": "Whereas the `QueueChannel` enforces first-in-first-out (FIFO) ordering, the `PriorityChannel` is an alternative implementation that allows for messages to be ordered within the channel based upon a priority.\nBy default, the priority is determined by the `priority` header within each message.\nHowever, for custom priority determination logic, a comparator of type `Comparator<Message<?>>` can be provided to the `PriorityChannel` constructor.\n\n[[channel-implementations-rendezvouschannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/implementations.adoc", "title": "implementations", "heading": "`PriorityChannel`", "heading_level": 2, "file_order": 20, "section_index": 3, "content_hash": "24de7cac83360f496a52ff4d77048d36306c98a3dc755685fd2153dd62ca731d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/implementations.adoc"}}
{"id": "sha256:ec61d98bd58209ee7c6dca1be86605de1f843c19b925111141173e0e3b1c9297", "content": "The `RendezvousChannel` enables a \"`direct-handoff`\" scenario, wherein a sender blocks until another party invokes the channel's `receive()` method.\nThe other party blocks until the sender sends the message.\nInternally, this implementation is quite similar to the `QueueChannel`, except that it uses a `SynchronousQueue` (a zero-capacity implementation of `BlockingQueue`).\nThis works well in situations where the sender and receiver operate in different threads, but asynchronously dropping the message in a queue is not appropriate.\nIn other words, with a `RendezvousChannel`, the sender knows that some receiver has accepted the message, whereas with a `QueueChannel`, the message would have been stored to the internal queue and potentially never received.\n\nTIP: Keep in mind that all of these queue-based channels are storing messages in-memory only by default.\nWhen persistence is required, you can either provide a 'message-store' attribute within the 'queue' element to reference a persistent `MessageStore` implementation or you can replace the local channel with one that is backed by a persistent broker, such as a JMS-backed channel or channel adapter.\nThe latter option lets you take advantage of any JMS provider's implementation for message persistence, as discussed in xref:jms.adoc[JMS Support].\nHowever, when buffering in a queue is not necessary, the simplest approach is to rely upon the `DirectChannel`, discussed in the next section.\n\nThe `RendezvousChannel` is also useful for implementing request-reply operations.\nThe sender can create a temporary, anonymous instance of `RendezvousChannel`, which it then sets as the 'replyChannel' header when building a `Message`.\nAfter sending that `Message`, the sender can immediately call `receive` (optionally providing a timeout value) in order to block while waiting for a reply `Message`.\nThis is very similar to the implementation used internally by many of Spring Integration's request-reply components.\n\n[[channel-implementations-directchannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/implementations.adoc", "title": "implementations", "heading": "`RendezvousChannel`", "heading_level": 2, "file_order": 20, "section_index": 4, "content_hash": "ec61d98bd58209ee7c6dca1be86605de1f843c19b925111141173e0e3b1c9297", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/implementations.adoc"}}
{"id": "sha256:27c929f660a7a868a45bab119b28121b9c1a8d2a449b6be19f263fdba3cd4359", "content": "The `DirectChannel` has point-to-point semantics but otherwise is more similar to the `PublishSubscribeChannel` than any of the queue-based channel implementations described earlier.\nIt implements the `SubscribableChannel` interface instead of the `PollableChannel` interface, so it dispatches messages directly to a subscriber.\nAs a point-to-point channel, however, it differs from the `PublishSubscribeChannel` in that it sends each `Message` to a single subscribed `MessageHandler`.\n\nIn addition to being the simplest point-to-point channel option, one of its most important features is that it enables a single thread to perform the operations on \"`both sides`\" of the channel.\nFor example, if a handler subscribes to a `DirectChannel`, then sending a `Message` to that channel triggers invocation of that handler's `handleMessage(Message)` method directly in the sender's thread, before the `send()` method invocation can return.\n\nThe key motivation for providing a channel implementation with this behavior is to support transactions that must span across the channel while still benefiting from the abstraction and loose coupling that the channel provides.\nIf the `send()` call is invoked within the scope of a transaction, the outcome of the handler's invocation, (for example, updating a database record) plays a role in determining the ultimate result of that transaction (commit or rollback).\n\nNOTE: Since the `DirectChannel` is the simplest option and does not add any additional overhead that would be required for scheduling and managing the threads of a poller, it is the default channel type within Spring Integration.\nThe general idea is to define the channels for an application, consider which of those need to provide buffering or to throttle input, and modify those to be queue-based `PollableChannels`.\nLikewise, if a channel needs to broadcast messages, it should not be a `DirectChannel` but rather a `PublishSubscribeChannel`.\nLater we show how each of these channels can be configured.\n\nThe `DirectChannel` internally delegates to a message dispatcher to invoke its subscribed message handlers, and that dispatcher can have a load-balancing strategy exposed by `load-balancer` or `load-balancer-ref` attributes (mutually exclusive).\nThe load balancing strategy is used by the message dispatcher to help determine how messages are distributed amongst message handlers when multiple message handlers subscribe to the same channel.\nAs a convenience, the `load-balancer` attribute exposes an enumeration of values pointing to pre-existing implementations of `LoadBalancingStrategy`.\nA `round-robin` (load-balances across the handlers in rotation) and `none` (for the cases where one wants to explicitly disable load balancing) are the only available values.\nOther strategy implementations may be added in future versions.\nHowever, since version 3.0, you can provide your own implementation of the `LoadBalancingStrategy` and inject it by using the `load-balancer-ref` attribute, which should point to a bean that implements `LoadBalancingStrategy`, as the following example shows:\n\nA `FixedSubscriberChannel` is a `SubscribableChannel` that only supports a single `MessageHandler` subscriber that cannot be unsubscribed.\nThis is useful for high-throughput performance use-cases when no other subscribers are involved and no channel interceptors are needed.\n\n[source,xml]\n----\n<int:channel id=\"lbRefChannel\">\n <int:dispatcher load-balancer-ref=\"lb\"/>\n</int:channel>\n\n<bean id=\"lb\" class=\"foo.bar.SampleLoadBalancingStrategy\"/>\n----\n\nNote that the `load-balancer` and `load-balancer-ref` attributes are mutually exclusive.\n\nThe load-balancing also works in conjunction with a boolean `failover` property.\nIf the `failover` value is true (the default), the dispatcher falls back to any subsequent handlers (as necessary) when preceding handlers throw exceptions.\nThe order is determined by an optional order value defined on the handlers themselves or, if no such value exists, the order in which the handlers subscribed.\n\nIf a certain situation requires that the dispatcher always try to invoke the first handler and then fall back in the same fixed order sequence every time an error occurs, no load-balancing strategy should be provided.\nIn other words, the dispatcher still supports the `failover` boolean property even when no load-balancing is enabled.\nWithout load-balancing, however, the invocation of handlers always begins with the first, according to their order.\nFor example, this approach works well when there is a clear definition of primary, secondary, tertiary, and so on.\nWhen using the namespace support, the `order` attribute on any endpoint determines the order.\n\nNOTE: Keep in mind that load-balancing and `failover` apply only when a channel has more than one subscribed message handler.\nWhen using the namespace support, this means that more than one endpoint shares the same channel reference defined in the `input-channel` attribute.\n\nStarting with version 5.2, when `failover` is true, a failure of the current handler together with the failed message is logged under `debug` or `info` if configured respectively.\n\n[[executor-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/implementations.adoc", "title": "implementations", "heading": "`DirectChannel`", "heading_level": 2, "file_order": 20, "section_index": 5, "content_hash": "27c929f660a7a868a45bab119b28121b9c1a8d2a449b6be19f263fdba3cd4359", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/implementations.adoc"}}
{"id": "sha256:ae3db2210368d1c1da272a8f20ee603fbf79192a0b3baa9204e03eb3c4239436", "content": "The `ExecutorChannel` is a point-to-point channel that supports the same dispatcher configuration as `DirectChannel` (load-balancing strategy and the `failover` boolean property).\nThe key difference between these two dispatching channel types is that the `ExecutorChannel` delegates to an instance of `TaskExecutor` to perform the dispatch.\nThis means that the send method typically does not block, but it also means that the handler invocation may not occur in the sender's thread.\nIt therefore does not support transactions that span the sender and receiving handler.\n\nCAUTION: The sender can sometimes block.\nFor example, when using a `TaskExecutor` with a rejection policy that throttles the client (such as the `ThreadPoolExecutor.CallerRunsPolicy`), the sender's thread can execute the method any time the thread pool is at its maximum capacity and the executor's work queue is full.\nSince that situation would only occur in a non-predictable way, you should not rely upon it for transactions.\n\n[[partitioned-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/implementations.adoc", "title": "implementations", "heading": "`ExecutorChannel`", "heading_level": 2, "file_order": 20, "section_index": 6, "content_hash": "ae3db2210368d1c1da272a8f20ee603fbf79192a0b3baa9204e03eb3c4239436", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/implementations.adoc"}}
{"id": "sha256:9f276d13797fe962b05cfa525994ba8b17d23a5742b4865c5b0c3b63bbc5fdd9", "content": "Starting with version 6.1, a `PartitionedChannel` implementation is provided.\nThis is an extension of `AbstractExecutorChannel` and represents point-to-point dispatching logic where the actual consumption is processed on a specific thread, determined by the partition key evaluated from a message sent to this channel.\nThis channel is similar to the `ExecutorChannel` mentioned above, but with the difference that messages with the same partition key are always handled in the same thread, preserving ordering.\nIt does not require an external `TaskExecutor`, but can be configured with a custom `ThreadFactory` (e.g. `Thread.ofVirtual().name(\"partition-\", 0).factory()`).\nThis factory is used to populate single-thread executors into a `MessageDispatcher` delegate, per partition.\nBy default, the `IntegrationMessageHeaderAccessor.CORRELATION_ID` message header is used as the partition key.\nThis channel can be configured as a simple bean:\n\n[source,java]\n----\n@Bean\nPartitionedChannel somePartitionedChannel() {\n return new PartitionedChannel(3, (message) -> message.getHeaders().get(\"partitionKey\"));\n}\n----\n\nThe channel will have `3` partitions - dedicated threads; will use the `partitionKey` header to determine in which partition the message will be handled.\nSee `PartitionedChannel` class Javadocs for more information.\n\n[[flux-message-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/implementations.adoc", "title": "implementations", "heading": "`PartitionedChannel`", "heading_level": 2, "file_order": 20, "section_index": 7, "content_hash": "9f276d13797fe962b05cfa525994ba8b17d23a5742b4865c5b0c3b63bbc5fdd9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/implementations.adoc"}}
{"id": "sha256:dc0e131202a71f686af1a07b61546a4b67dea137c64c332c25c4fa59ac0220ec", "content": "The `FluxMessageChannel` is an `org.reactivestreams.Publisher` implementation for `\"sinking\"` sent messages into an internal `reactor.core.publisher.Flux` for on demand consumption by reactive subscribers downstream.\nThis channel implementation is neither a `SubscribableChannel`, nor a `PollableChannel`, so only `org.reactivestreams.Subscriber` instances can be used to consume from this channel honoring back-pressure nature of reactive streams.\nOn the other hand, the `FluxMessageChannel` implements a `ReactiveStreamsSubscribableChannel` with its `subscribeTo(Publisher<Message<?>>)` contract allowing receiving events from reactive source publishers, bridging a reactive stream into the integration flow.\nTo achieve fully reactive behavior for the whole integration flow, such a channel must be placed between all the endpoints in the flow.\n\nSee xref:reactive-streams.adoc[Reactive Streams Support] for more information about interaction with Reactive Streams.\n\n[[channel-implementations-threadlocalchannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/implementations.adoc", "title": "implementations", "heading": "`FluxMessageChannel`", "heading_level": 2, "file_order": 20, "section_index": 8, "content_hash": "dc0e131202a71f686af1a07b61546a4b67dea137c64c332c25c4fa59ac0220ec", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/implementations.adoc"}}
{"id": "sha256:325163e0b05323a97e987129a95103b8cdd5c6c00943a35731c4a9223e2f7222", "content": "Spring Integration 1.0 provided a `ThreadLocalChannel` implementation, but that has been removed as of 2.0.\nNow the more general way to handle the same requirement is to add a `scope` attribute to a channel.\nThe value of the attribute can be the name of a scope that is available within the context.\nFor example, in a web environment, certain scopes are available, and any custom scope implementations can be registered with the context.\nThe following example shows a thread-local scope being applied to a channel, including the registration of the scope itself:\n\n[source,xml]\n----\n<int:channel id=\"threadScopedChannel\" scope=\"thread\">\n <int:queue />\n</int:channel>\n\n<bean class=\"org.springframework.beans.factory.config.CustomScopeConfigurer\">\n <property name=\"scopes\">\n <map>\n <entry key=\"thread\" value=\"org.springframework.context.support.SimpleThreadScope\" />\n </map>\n </property>\n</bean>\n----\n\nThe channel defined in the previous example also delegates to a queue internally, but the channel is bound to the current thread, so the contents of the queue are similarly bound.\nThat way, the thread that sends to the channel can later receive those same messages, but no other thread would be able to access them.\nWhile thread-scoped channels are rarely needed, they can be useful in situations where `DirectChannel` instances are being used to enforce a single thread of operation but any reply messages should be sent to a \"`terminal`\" channel.\nIf that terminal channel is thread-scoped, the original sending thread can collect its replies from the terminal channel.\n\nNow, since any channel can be scoped, you can define your own scopes in addition to thread-Local.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/implementations.adoc", "title": "implementations", "heading": "Scoped Channel", "heading_level": 2, "file_order": 20, "section_index": 9, "content_hash": "325163e0b05323a97e987129a95103b8cdd5c6c00943a35731c4a9223e2f7222", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/implementations.adoc"}}
{"id": "sha256:637ab47d0c7fc1022f915a2f24dfde35ab10639912967e0d1f0516aab16e816a", "content": "[[channel-interceptors]]\n\nOne of the advantages of a messaging architecture is the ability to provide common behavior and capture meaningful information about the messages passing through the system in a non-invasive way.\nSince the `Message` instances are sent to and received from `MessageChannel` instances, those channels provide an opportunity for intercepting the send and receive operations.\nThe `ChannelInterceptor` strategy interface, shown in the following listing, provides methods for each of those operations:\n\n[source,java]\n----\npublic interface ChannelInterceptor {\n\n Message<?> preSend(Message<?> message, MessageChannel channel);\n\n void postSend(Message<?> message, MessageChannel channel, boolean sent);\n\n void afterSendCompletion(Message<?> message, MessageChannel channel, boolean sent, Exception ex);\n\n boolean preReceive(MessageChannel channel);\n\n Message<?> postReceive(Message<?> message, MessageChannel channel);\n\n void afterReceiveCompletion(Message<?> message, MessageChannel channel, Exception ex);\n}\n----\n\nAfter implementing the interface, registering the interceptor with a channel is just a matter of making the following call:\n\n[source,java]\n----\nchannel.addInterceptor(someChannelInterceptor);\n----\n\nThe methods that return a `Message` instance can be used for transforming the `Message` or can return 'null' to prevent further processing (of course, any of the methods can throw a `RuntimeException`).\nAlso, the `preReceive` method can return `false` to prevent the `receive` operation from proceeding.\n\nNOTE: Keep in mind that `receive()` calls are only relevant for `PollableChannels`.\nIn fact, the `SubscribableChannel` interface does not even define a `receive()` method.\nThe reason for this is that when a `Message` is sent to a `SubscribableChannel`, it is sent directly to zero or more subscribers, depending on the type of channel, (for example, a `PublishSubscribeChannel` sends to all of its subscribers).\nTherefore, the `preReceive(...)`, `postReceive(...)`, and `afterReceiveCompletion(...)` interceptor methods are invoked only when the interceptor is applied to a `PollableChannel`.\n\nSpring Integration also provides an implementation of the https://www.enterpriseintegrationpatterns.com/WireTap.html[Wire Tap] pattern.\nIt is a simple interceptor that sends the `Message` to another channel without otherwise altering the existing flow.\nIt can be very useful for debugging and monitoring.\nAn example is shown in xref:channel/configuration.adoc#channel-wiretap[Wire Tap].\n\nBecause it is rarely necessary to implement all of the interceptor methods, the interface provides no-op methods (those returning `void` method have no code, the `Message`-returning methods return the `Message` as-is, and the `boolean` method returns `true`).\n\nTIP: The order of invocation for the interceptor methods depends on the type of channel.\nAs described earlier, the queue-based channels are the only ones where the `receive()` method is intercepted in the first place.\nAdditionally, the relationship between send and receive interception depends on the timing of the separate sender and receiver threads.\nFor example, if a receiver is already blocked while waiting for a message, the order could be as follows: `preSend`, `preReceive`, `postReceive`, `postSend`.\nHowever, if a receiver polls after the sender has placed a message on the channel and has already returned, the order would be as follows: `preSend`, `postSend` (some-time-elapses), `preReceive`, `postReceive`.\nThe time that elapses in such a case depends on a number of factors and is therefore generally unpredictable (in fact, the `receive` may never happen).\nThe type of queue also plays a role, (for example, rendezvous versus priority).\nIn short, you cannot rely on the order beyond the fact that `preSend` precedes `postSend` and `preReceive` precedes `postReceive`.\n\nStarting with Spring Framework 4.1 and Spring Integration 4.1, the `ChannelInterceptor` provides new methods: `afterSendCompletion()` and `afterReceiveCompletion()`.\nThey are invoked after `send()' and 'receive()` calls, regardless of any exception that is raised, which allow for resource cleanup.\nNote that the channel invokes these methods on the `ChannelInterceptor` list in the reverse order of the initial `preSend()` and `preReceive()` calls.\n\nStarting with version 5.1, global channel interceptors now apply to dynamically registered channels - such as through beans that are initialized by using `beanFactory.initializeBean()` or `IntegrationFlowContext` when using the Java DSL.\nPreviously, interceptors were not applied when beans were created after the application context was refreshed.\n\nAlso, starting with version 5.1, `ChannelInterceptor.postReceive()` is no longer called when no message is received; it is no longer necessary to check for a `null` `Message<?>`.\nPreviously, the method was called.\nIf you have an interceptor that relies on the previous behavior, implement `afterReceiveCompleted()` instead, since that method is invoked, regardless of whether a message is received or not.\n\nNOTE: Starting with version 5.2, the `ChannelInterceptorAware` is deprecated in favor of `InterceptableChannel` from the Spring Messaging module, which it extends now for backward compatibility.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/interceptors.adoc", "title": "interceptors", "heading": "interceptors", "heading_level": 1, "file_order": 21, "section_index": 0, "content_hash": "637ab47d0c7fc1022f915a2f24dfde35ab10639912967e0d1f0516aab16e816a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/interceptors.adoc"}}
{"id": "sha256:d5bca30ce25a4f5200f1b26350e242e4008b8272a1eac6d6eac0bf7831336013", "content": "[[channel-interfaces]]\n\nSpring Integration's top-level `MessageChannel` interface is defined as follows:\n\n[source,java]\n----\npublic interface MessageChannel {\n\n boolean send(Message message);\n\n boolean send(Message message, long timeout);\n}\n----\n\nWhen sending a message, the return value is `true` if the message is sent successfully.\nIf the send call times out or is interrupted, it returns `false`.\n\n[[channel-interfaces-pollablechannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/interfaces.adoc", "title": "interfaces", "heading": "interfaces", "heading_level": 1, "file_order": 22, "section_index": 0, "content_hash": "d5bca30ce25a4f5200f1b26350e242e4008b8272a1eac6d6eac0bf7831336013", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/interfaces.adoc"}}
{"id": "sha256:e5b53eee570529ac446ec054c047d17c91851c7652ef2c1c541a79b02df6faca", "content": "Since message channels may or may not buffer messages (as discussed in the xref:overview.adoc[Spring Integration Overview]), two sub-interfaces define the buffering (pollable) and non-buffering (subscribable) channel behavior.\nThe following listing shows the definition of the `PollableChannel` interface:\n\n[source,java]\n----\npublic interface PollableChannel extends MessageChannel {\n\n Message<?> receive();\n\n Message<?> receive(long timeout);\n\n}\n----\n\nAs with the send methods, when receiving a message, the return value is null in the case of a timeout or interrupt.\n\n[[channel-interfaces-subscribablechannel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/interfaces.adoc", "title": "interfaces", "heading": "`PollableChannel`", "heading_level": 2, "file_order": 22, "section_index": 1, "content_hash": "e5b53eee570529ac446ec054c047d17c91851c7652ef2c1c541a79b02df6faca", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/interfaces.adoc"}}
{"id": "sha256:d50a33bce80fcd98410b2f207ae00b8a9fa994ee6f1ea2452f2b37b3857ac8d2", "content": "The `SubscribableChannel` base interface is implemented by channels that send messages directly to their subscribed `MessageHandler` instances.\nTherefore, they do not provide receive methods for polling.\nInstead, they define methods for managing those subscribers.\nThe following listing shows the definition of the `SubscribableChannel` interface:\n\n[source,java]\n----\npublic interface SubscribableChannel extends MessageChannel {\n\n boolean subscribe(MessageHandler handler);\n\n boolean unsubscribe(MessageHandler handler);\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/interfaces.adoc", "title": "interfaces", "heading": "`SubscribableChannel`", "heading_level": 2, "file_order": 22, "section_index": 2, "content_hash": "d50a33bce80fcd98410b2f207ae00b8a9fa994ee6f1ea2452f2b37b3857ac8d2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/interfaces.adoc"}}
{"id": "sha256:97327d40f4b5e18d490cc351a459130ebe6d8d9efff3d80f6a61e43c54a1c026", "content": "[[channel-special-channels]]\n\nTwo special channels are defined within the application context by default: `errorChannel` and `nullChannel`.\nThe 'nullChannel' (an instance of `NullChannel`) acts like `/dev/null`, logging any message sent to it at the `DEBUG` level and returning immediately.\nThe special treatment is applied for an `org.reactivestreams.Publisher` payload of a transmitted message: it is subscribed to in this channel immediately, to initiate reactive stream processing, although the data is discarded.\nAn error thrown from a reactive stream processing (see `Subscriber.onError(Throwable)`) is logged under the `warn` level for possible investigation.\nIf there is a need to do anything with such an error, the `xref:handler-advice/reactive.adoc[ReactiveRequestHandlerAdvice]` with a `Mono.doOnError()` customization can be applied to the message handler producing `Mono` reply into this `nullChannel`.\nAny time you face channel resolution errors for a reply that you do not care about, you can set the affected component's `output-channel` attribute to 'nullChannel' (the name, 'nullChannel', is reserved within the application context).\n\nThe 'errorChannel' is used internally for sending error messages and may be overridden with a custom configuration.\nThis is discussed in greater detail in xref:error-handling.adoc[Error Handling].\n\nSee also xref:dsl/java-channels.adoc[Message Channels] in the Java DSL chapter for more information about a message channel and interceptors.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/special-channels.adoc", "title": "special-channels", "heading": "special-channels", "heading_level": 1, "file_order": 23, "section_index": 0, "content_hash": "97327d40f4b5e18d490cc351a459130ebe6d8d9efff3d80f6a61e43c54a1c026", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/special-channels.adoc"}}
{"id": "sha256:5d78a5a3f0728bde65d443da36f0c5b93201e2890a8e49255f5c569dbdc139c8", "content": "[[channel-template]]\n\nWhen the endpoints and their various configuration options are introduced, Spring Integration provides a foundation for messaging components that enables non-invasive invocation of your application code from the messaging system.\nHowever, it is sometimes necessary to invoke the messaging system from your application code.\nFor convenience when implementing such use cases, Spring Integration provides a `MessagingTemplate` that supports a variety of operations across the message channels, including request and reply scenarios.\nFor example, it is possible to send a request and wait for a reply, as follows:\n\n[source,java]\n----\nMessagingTemplate template = new MessagingTemplate();\n\nMessage reply = template.sendAndReceive(someChannel, new GenericMessage(\"test\"));\n----\n\nIn the preceding example, a temporary anonymous channel would be created internally by the template.\nThe 'sendTimeout' and 'receiveTimeout' properties may also be set on the template, and other exchange types are also supported.\nThe following listing shows the signatures for such methods:\n\n[source,java]\n----\npublic boolean send(final MessageChannel channel, final Message<?> message) { ...\n}\n\npublic Message<?> sendAndReceive(final MessageChannel channel, final Message<?> request) { ...\n}\n\npublic Message<?> receive(final PollableChannel<?> channel) { ...\n}\n----\n\nNOTE: A less invasive approach that lets you invoke simple interfaces with payload or header values instead of `Message` instances is described in xref:gateway.adoc#gateway-proxy[Enter the `GatewayProxyFactoryBean`].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel/template.adoc", "title": "template", "heading": "template", "heading_level": 1, "file_order": 24, "section_index": 0, "content_hash": "5d78a5a3f0728bde65d443da36f0c5b93201e2890a8e49255f5c569dbdc139c8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel/template.adoc"}}
{"id": "sha256:e642ad1fc66c5848abee08457bdbf7fdb1c2e0d6dc5bc67af50e00417be59b46", "content": "[[annotations]]\n\nIn addition to the XML namespace support for configuring message endpoints, you can also use annotations.\nFirst, Spring Integration provides the class-level `@MessageEndpoint` as a stereotype annotation, meaning that it is itself annotated with Spring's `@Component` annotation and is therefore automatically recognized as a bean definition by Spring's component scanning.\n\nEven more important are the various method-level annotations.\nThey indicate that the annotated method is capable of handling a message.\nThe following example demonstrates both class-level and method-level annotations:\n\n[source,java]\n----\n@MessageEndpoint\npublic class FooService {\n\n @ServiceActivator\n public void processMessage(Message message) {\n ...\n }\n}\n----\n\nExactly what it means for the method to \"`handle`\" the Message depends on the particular annotation.\nAnnotations available in Spring Integration include:\n\n* `@Aggregator` (see xref:overview.adoc#overview-endpoints-aggregator[Aggregator])\n* `@Filter` (see xref:filter.adoc[Filter])\n* `@Router` (see xref:router.adoc[Routers])\n* `@ServiceActivator` (see xref:service-activator.adoc[Service Activator])\n* `@Splitter` (see xref:splitter.adoc[Splitter])\n* `@Transformer` (see xref:transformer.adoc[Transformer])\n* `@InboundChannelAdapter` (see xref:overview.adoc#overview-endpoints-channeladapter[Channel Adapter])\n* `@BridgeFrom` (see xref:bridge.adoc#bridge-annot[Configuring a Bridge with Java Configuration])\n* `@BridgeTo` (see xref:bridge.adoc#bridge-annot[Configuring a Bridge with Java Configuration])\n* `@MessagingGateway` (see xref:gateway.adoc[Messaging Gateways])\n* `@IntegrationComponentScan` (see xref:overview.adoc#configuration-enable-integration[Configuration and `@EnableIntegration`])\n\nNOTE: If you use XML configuration in combination with annotations, the `@MessageEndpoint` annotation is not required.\nIf you want to configure a POJO reference from the `ref` attribute of a `<service-activator/>` element, you can provide only the method-level annotations.\nIn that case, the annotation prevents ambiguity even when no method-level attribute exists on the `<service-activator/>` element.\n\nIn most cases, the annotated handler method should not require the `Message` type as its parameter.\nInstead, the method parameter type can match the message's payload type, as the following example shows:\n\n[source,java]\n----\npublic class ThingService {\n\n @ServiceActivator\n public void bar(Thing thing) {\n ...\n }\n\n}\n----\n\nWhen the method parameter should be mapped from a value in the `MessageHeaders`, another option is to use the parameter-level `@Header` annotation.\nIn general, methods annotated with the Spring Integration annotations can accept the `Message` itself, the message payload, or a header value (with `@Header`) as the parameter.\nIn fact, the method can accept a combination, as the following example shows:\n\n[source,java]\n----\npublic class ThingService {\n\n @ServiceActivator\n public void otherThing(String payload, @Header(\"x\") int valueX, @Header(\"y\") int valueY) {\n ...\n }\n\n}\n----\n\nYou can also use the `@Headers` annotation to provide all the message headers as a `Map`, as the following example shows:\n\n[source,java]\n----\npublic class ThingService {\n\n @ServiceActivator\n public void otherThing(String payload, @Headers Map<String, Object> headerMap) {\n ...\n }\n\n}\n----\n\nNOTE: The value of the annotation can also be a SpEL expression, (for example, `someHeader.toUpperCase()`), which is useful when you wish to manipulate the header value before injecting it.\nIt also provides an optional `required` property, which specifies whether the attribute value must be available within the headers.\nThe default value for the `required` property is `true`.\n\nFor several of these annotations, when a message-handling method returns a non-null value, the endpoint tries to send a reply.\nThis is consistent across both configuration options (namespace and annotations) in that such an endpoint's output channel is used (if available), and the `REPLY_CHANNEL` message header value is used as a fallback.\n\nTIP: The combination of output channels on endpoints and the reply channel message header enables a pipeline approach, where multiple components have an output channel and the final component allows the reply message to be forwarded to the reply channel (as specified in the original request message).\nIn other words, the final component depends on the information provided by the original sender and can dynamically support any number of clients as a result.\nThis is an example of the https://www.enterpriseintegrationpatterns.com/ReturnAddress.html[return address] pattern.\n\nIn addition to the examples shown here, these annotations also support the `inputChannel` and `outputChannel` properties, as the following example shows:\n\n[source,java]\n----\n@Service\npublic class ThingService {\n\n @ServiceActivator(inputChannel=\"input\", outputChannel=\"output\")\n public void otherThing(String payload, @Headers Map<String, Object> headerMap) {\n ...\n }\n\n}\n----\n\nThe processing of these annotations creates the same beans as the corresponding XML components -- `AbstractEndpoint` instances and `MessageHandler` instances (or `MessageSource` instances for the inbound channel adapter).\nSee xref:configuration/meta-annotations.adoc#annotations_on_beans[Annotations on `@Bean` Methods].\nThe bean names are generated from the following pattern: `[componentName].[methodName].[decapitalizedAnnotationClassShortName]`.\nIn the preceding example the bean name is `thingService.otherThing.serviceActivator` for the `AbstractEndpoint` and the same name with an additional `.handler` (`.source`) suffix for the `MessageHandler` (`MessageSource`) bean.\nSuch a name can be customized using an `@EndpointId` annotation alongside these messaging annotations.\nThe `MessageHandler` instances (`MessageSource` instances) are also eligible to be tracked by xref:message-history.adoc[the message history].\n\nStarting with version 4.0, all messaging annotations provide `SmartLifecycle` options (`autoStartup` and `phase`) to allow endpoint lifecycle control on application context initialization.\nThey default to `true` and `0`, respectively.\nTo change the state of an endpoint (such as `start()` or `stop()`), you can obtain a reference to the endpoint bean by using the `BeanFactory` (or autowiring) and invoke the methods.\nAlternatively, you can send a command message to the xref:control-bus.adoc[Control Bus].\nFor these purposes, you should use the `beanName` mentioned earlier in the preceding paragraph.\n\n[IMPORTANT]\n=====\nChannels are automatically created after parsing the mentioned annotations (when no specific channel bean is configured), and the corresponding consumer endpoints are declared as beans near the end of the context initialization.\nThese beans **can** be autowired in other services, but they have to be marked with the `@Lazy` annotation because the definitions, typically, won't yet be available during normal autowiring processing.\n\n[source, java]\n----\n@Autowired\n@Lazy\n@Qualifier(\"someChannel\")\nMessageChannel someChannel;\n...\n\n@Bean\nThing1 dependsOnSPCA(@Qualifier(\"someInboundAdapter\") @Lazy SourcePollingChannelAdapter someInboundAdapter) {\n ...\n}\n----\n=====\n\nStarting with version 6.0, all the messaging annotations are `@Repeatable` now, so several of the same type can be declared on the same service method with the meaning to create as many endpoints as those annotations are repeated:\n[source, java]\n----\n@Transformer(inputChannel = \"inputChannel1\", outputChannel = \"outputChannel1\")\n@Transformer(inputChannel = \"inputChannel2\", outputChannel = \"outputChannel2\")\npublic String transform(String input) {\n return input.toUpperCase();\n}\n----\n\n[[configuration-using-poller-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/annotations.adoc", "title": "annotations", "heading": "annotations", "heading_level": 1, "file_order": 25, "section_index": 0, "content_hash": "e642ad1fc66c5848abee08457bdbf7fdb1c2e0d6dc5bc67af50e00417be59b46", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/annotations.adoc"}}
{"id": "sha256:2a301c46d3c5137de0a3d2a6371528ec927f27e2bd8cda2f501231bf469a1d38", "content": "Before Spring Integration 4.0, messaging annotations required that the `inputChannel` be a reference to a `SubscribableChannel`.\nFor `PollableChannel` instances, an `<int:bridge/>` element was needed to configure an `<int:poller/>` and make the composite endpoint be a `PollingConsumer`.\nVersion 4.0 introduced the `@Poller` annotation to allow the configuration of `poller` attributes directly on the messaging annotations, as the following example shows:\n\n[source,java]\n----\npublic class AnnotationService {\n\n @Transformer(inputChannel = \"input\", outputChannel = \"output\",\n poller = @Poller(maxMessagesPerPoll = \"${poller.maxMessagesPerPoll}\", fixedDelay = \"${poller.fixedDelay}\"))\n public String handle(String payload) {\n ...\n }\n}\n----\n\nThe `@Poller` annotation provides only simple `PollerMetadata` options.\nYou can configure the `@Poller` annotation's attributes (`maxMessagesPerPoll`, `fixedDelay`, `fixedRate`, and `cron`) with property placeholders.\nAlso, starting with version 5.1, the `receiveTimeout` option for ``PollingConsumer``s is also provided.\nIf it is necessary to provide more polling options (for example, `transaction`, `advice-chain`, `error-handler`, and others), you should configure the `PollerMetadata` as a generic bean and use its bean name as the `@Poller` 's `value` attribute.\nIn this case, no other attributes are allowed (they must be specified on the `PollerMetadata` bean).\nNote, if `inputChannel` is a `PollableChannel` and no `@Poller` is configured, the default `PollerMetadata` is used (if it is present in the application context).\nTo declare the default poller by using a `@Configuration` annotation, use code similar to the following example:\n\n[source,java]\n----\n@Bean(name = PollerMetadata.DEFAULT_POLLER)\npublic PollerMetadata defaultPoller() {\n PollerMetadata pollerMetadata = new PollerMetadata();\n pollerMetadata.setTrigger(new PeriodicTrigger(10));\n return pollerMetadata;\n}\n----\n\nThe following example shows how to use the default poller:\n\n[source,java]\n----\npublic class AnnotationService {\n\n @Transformer(inputChannel = \"aPollableChannel\", outputChannel = \"output\")\n public String handle(String payload) {\n ...\n }\n}\n----\n\nThe following example shows how to use a named poller:\n\n[source,java]\n----\n@Bean\npublic PollerMetadata myPoller() {\n PollerMetadata pollerMetadata = new PollerMetadata();\n pollerMetadata.setTrigger(new PeriodicTrigger(1000));\n return pollerMetadata;\n}\n----\n\nThe following example shows an endpoint that uses the default poller:\n\n[source,java]\n----\npublic class AnnotationService {\n\n @Transformer(inputChannel = \"aPollableChannel\", outputChannel = \"output\"\n poller = @Poller(\"myPoller\"))\n public String handle(String payload) {\n ...\n }\n}\n----\n\nStarting with version 4.3.3, the `@Poller` annotation has the `errorChannel` attribute for easier configuration of the underlying `MessagePublishingErrorHandler`.\nThis attribute plays the same role as `error-channel` in the `<poller>` XML component.\nSee xref:endpoint.adoc#endpoint-namespace[Endpoint Namespace Support] for more information.\n\nThe `poller()` attribute on the messaging annotations is mutually exclusive with the `reactive()` attribute.\nSee the next section for more information.\n\n[[configuration-using-reactive-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/annotations.adoc", "title": "annotations", "heading": "Using the `@Poller` Annotation", "heading_level": 2, "file_order": 25, "section_index": 1, "content_hash": "2a301c46d3c5137de0a3d2a6371528ec927f27e2bd8cda2f501231bf469a1d38", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/annotations.adoc"}}
{"id": "sha256:5cfc3ba1e3708cc3e1465be3c4c301729ed77ef24eee37ac913e0635599e88a7", "content": "The `ReactiveStreamsConsumer` has been around since version 5.0, but it was applied only when an input channel for the endpoint is a `FluxMessageChannel` (or any `org.reactivestreams.Publisher` implementation).\nStarting with version 5.3, its instance is also created by the framework when the target message handler is a `ReactiveMessageHandler` independently of the input channel type.\nThe `@Reactive` sub-annotation (similar to mentioned above `@Poller`) has been introduced for all the messaging annotations starting with version 5.5.\nIt accepts an optional `Function<? super Flux<Message<?>>, ? extends Publisher<Message<?>>>` bean reference and, independently of the input channel type and message handler, turns the target endpoint into the `ReactiveStreamsConsumer` instance.\nThe function is used from the `Flux.transform()` operator to apply some customization (`publishOn()`, `doOnNext()`, `log()`, `retry()` etc.) on a reactive stream source from the input channel.\n\nThe following example demonstrates how to change the publishing thread from the input channel independently of the final subscriber and producer to that `DirectChannel`:\n\n[source,java]\n----\n@Bean\npublic Function<Flux<?>, Flux<?>> publishOnCustomizer() {\n return flux -> flux.publishOn(Schedulers.parallel());\n}\n\n@ServiceActivator(inputChannel = \"directChannel\", reactive = @Reactive(\"publishOnCustomizer\"))\npublic void handleReactive(String payload) {\n ...\n}\n----\n\nThe `reactive()` attribute on the messaging annotations is mutually exclusive with the `poller()` attribute.\nSee xref:configuration/annotations.adoc#configuration-using-poller-annotation[Using the `@Poller` Annotation] and xref:reactive-streams.adoc[Reactive Streams Support] for more information.\n\n[[using-the-inboundchanneladapter-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/annotations.adoc", "title": "annotations", "heading": "Using `@Reactive` Annotation", "heading_level": 2, "file_order": 25, "section_index": 2, "content_hash": "5cfc3ba1e3708cc3e1465be3c4c301729ed77ef24eee37ac913e0635599e88a7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/annotations.adoc"}}
{"id": "sha256:03b306c7d86b554405c1ce37dc300dee756ac3f3f77cad205d38d69cfd778e45", "content": "Version 4.0 introduced the `@InboundChannelAdapter` method-level annotation.\nIt produces a `SourcePollingChannelAdapter` integration component based on a `MethodInvokingMessageSource` for the annotated method.\nThis annotation is an analogue of the `<int:inbound-channel-adapter>` XML component and has the same restrictions: The method cannot have parameters, and the return type must not be `void`.\nIt has two attributes: `value` (the required `MessageChannel` bean name) and `poller` (an optional `@Poller` annotation, as xref:configuration/annotations.adoc#configuration-using-poller-annotation[described earlier]).\nIf you need to provide some `MessageHeaders`, use a `Message<?>` return type and use a `MessageBuilder` to build the `Message<?>`.\nUsing a `MessageBuilder` lets you configure the `MessageHeaders`.\nThe following example shows how to use an `@InboundChannelAdapter` annotation:\n\n[source,java]\n----\n@InboundChannelAdapter(\"counterChannel\")\npublic Integer count() {\n return this.counter.incrementAndGet();\n}\n\n@InboundChannelAdapter(value = \"fooChannel\", poller = @Poller(fixed-rate = \"5000\"))\npublic String foo() {\n return \"foo\";\n}\n----\n\nVersion 4.3 introduced the `channel` alias for the `value` annotation attribute, to provide better source code readability.\nAlso, the target `MessageChannel` bean is resolved in the `SourcePollingChannelAdapter` by the provided name (set by the `outputChannelName` option) on the first `receive()` call, not during the initialization phase.\nIt allows \"`late binding`\" logic: The target `MessageChannel` bean from the consumer perspective is created and registered a bit later than the `@InboundChannelAdapter` parsing phase.\n\nThe first example requires that the default poller has been declared elsewhere in the application context.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/annotations.adoc", "title": "annotations", "heading": "Using the `@InboundChannelAdapter` Annotation", "heading_level": 2, "file_order": 25, "section_index": 3, "content_hash": "03b306c7d86b554405c1ce37dc300dee756ac3f3f77cad205d38d69cfd778e45", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/annotations.adoc"}}
{"id": "sha256:24f4151062930529470b928572dba29f5ed2baea2ac326c618dabba194dae2db", "content": "See xref:gateway.adoc#messaging-gateway-annotation[`@MessagingGateway` Annotation].\n\n[[using-the-integrationcomponentscan-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/annotations.adoc", "title": "annotations", "heading": "Using the `@MessagingGateway` Annotation", "heading_level": 2, "file_order": 25, "section_index": 4, "content_hash": "24f4151062930529470b928572dba29f5ed2baea2ac326c618dabba194dae2db", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/annotations.adoc"}}
{"id": "sha256:ac3153a5833bc54df25ded634954d76c055d8edf03969a3bcc0cd6cc04c010e0", "content": "The standard Spring Framework `@ComponentScan` annotation does not scan interfaces for stereotype `@Component` annotations.\nTo overcome this limitation and allow the configuration of `@MessagingGateway` (see xref:gateway.adoc#messaging-gateway-annotation[`@MessagingGateway` Annotation]), we introduced the `@IntegrationComponentScan` mechanism.\nThis annotation must be placed with a `@Configuration` annotation and be customized to define its scanning options,\nsuch as `basePackages` and `basePackageClasses`.\nIn this case, all discovered interfaces annotated with `@MessagingGateway` are parsed and registered as `GatewayProxyFactoryBean` instances.\nAll other class-based components are parsed by the standard `@ComponentScan`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/annotations.adoc", "title": "annotations", "heading": "Using the `@IntegrationComponentScan` Annotation", "heading_level": 2, "file_order": 25, "section_index": 5, "content_hash": "ac3153a5833bc54df25ded634954d76c055d8edf03969a3bcc0cd6cc04c010e0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/annotations.adoc"}}
{"id": "sha256:014e2ea2d00af0e6edeacb6794838b588f53ae4819ea72b5c5dc3b9e5dbc53af", "content": "[[global-properties]]\n\nCertain global framework properties can be overridden by providing a properties file on the classpath.\n\nThe default properties can be found in `org.springframework.integration.context.IntegrationProperties` class.\nThe following listing shows the default values:\n\n====\n[source]\n----\nspring.integration.channels.autoCreate=true <1>\nspring.integration.channels.maxUnicastSubscribers=0x7fffffff <2>\nspring.integration.channels.maxBroadcastSubscribers=0x7fffffff <3>\nspring.integration.taskScheduler.poolSize=10 <4>\nspring.integration.messagingTemplate.throwExceptionOnLateReply=false <5>\nspring.integration.readOnly.headers= <6>\nspring.integration.endpoints.noAutoStartup= <7>\nspring.integration.channels.error.requireSubscribers=true <8>\nspring.integration.channels.error.ignoreFailures=true <9>\nspring.integration.endpoints.defaultTimeout=30000 <10>\n----\n\n<1> When true, `input-channel` instances are automatically declared as `DirectChannel` instances when not explicitly found in the application context.\n\n<2> Sets the default number of subscribers allowed on, for example, a `DirectChannel`.\nIt can be used to avoid inadvertently subscribing multiple endpoints to the same channel.\nYou can override it on individual channels by setting the `max-subscribers` attribute.\n\n<3> This property provides the default number of subscribers allowed on, for example, a `PublishSubscribeChannel`.\nIt can be used to avoid inadvertently subscribing more than the expected number of endpoints to the same channel.\nYou can override it on individual channels by setting the `max-subscribers` attribute.\n\n<4> The number of threads available in the default `taskScheduler` bean.\nSee xref:configuration/namespace-taskscheduler.adoc[Configuring the Task Scheduler].\n\n<5> When `true`, messages that arrive at a gateway reply channel throw an exception when the gateway is not expecting a reply (because the sending thread has timed out or already received a reply).\n\n<6> A comma-separated list of message header names that should not be populated into `Message` instances during a header copying operation.\nThe list is used by the `DefaultMessageBuilderFactory` bean and propagated to the `IntegrationMessageHeaderAccessor` instances (see xref:message.adoc#message-header-accessor[`MessageHeaderAccessor` API]) used to build messages via `MessageBuilder` (see xref:message.adoc#message-builder[The `MessageBuilder` Helper Class]).\nBy default, only `MessageHeaders.ID` and `MessageHeaders.TIMESTAMP` are not copied during message building.\nSince version 4.3.2.\n\n<7> A comma-separated list of `AbstractEndpoint` bean names patterns (`xxx*`, `*xxx`, `*xxx*` or `xxx*yyy`) that should not be started automatically during application startup.\nYou can manually start these endpoints later by their bean name through a xref:control-bus.adoc[Control Bus], by their role with the `SmartLifecycleRoleController` (see xref:endpoint-roles.adoc[Endpoint Roles]), or by `Lifecycle` bean injection.\nYou can explicitly override the effect of this global property by specifying `auto-startup` XML annotation or the `autoStartup` annotation attribute or by calling `AbstractEndpoint.setAutoStartup()` in the bean definition.\nSince version 4.3.12.\n\n<8> A boolean flag to indicate that default global `errorChannel` must be configured with the `requireSubscribers` option.\nSince version 5.4.3.\nSee xref:scatter-gather.adoc#scatter-gather-error-handling[Error Handling] for more information.\n\n<9> A boolean flag to indicate that default global `errorChannel` must ignore dispatching errors and pass the message to the next handler.\nSince version 5.5.\n\n<10> The default number of milliseconds for request and reply timeouts in endpoints.\nThe default value is 30 seconds to avoid indefinite blocking.\nCan be configured to a negative value to restore infinite blocking behavior in endpoints.\nSince version 6.2.\n====\n\nThese properties can be overridden by adding a `/META-INF/spring.integration.properties` file to the classpath or an `IntegrationContextUtils.INTEGRATION_GLOBAL_PROPERTIES_BEAN_NAME` bean for the `org.springframework.integration.context.IntegrationProperties` instance.\nYou need not provide all the properties -- only those that you want to override.\n\nStarting with version 5.1, all the merged global properties are printed in the logs after application context startup when a `DEBUG` logic level is turned on for the `org.springframework.integration` category.\nThe output looks like this:\n\n[source]\n----\nSpring Integration global properties:\n\nspring.integration.endpoints.noAutoStartup=fooService*\nspring.integration.taskScheduler.poolSize=20\nspring.integration.channels.maxUnicastSubscribers=0x7fffffff\nspring.integration.channels.autoCreate=true\nspring.integration.channels.maxBroadcastSubscribers=0x7fffffff\nspring.integration.readOnly.headers=\nspring.integration.messagingTemplate.throwExceptionOnLateReply=true\nspring.integration.endpoints.defaultTimeout=30000\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/global-properties.adoc", "title": "global-properties", "heading": "global-properties", "heading_level": 1, "file_order": 26, "section_index": 0, "content_hash": "014e2ea2d00af0e6edeacb6794838b588f53ae4819ea72b5c5dc3b9e5dbc53af", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/global-properties.adoc"}}
{"id": "sha256:21fb5bf530e7d823ba24ab04f47d792895fc1baa50f22f32e34e3f99c8bf298e", "content": "[[message-mapping-rules]]\n\nSpring Integration implements a flexible facility to map messages to methods and their arguments without providing extra configuration, by relying on some default rules and defining certain conventions.\nThe examples in the following sections articulate the rules.\n\n[[sample-scenarios]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/message-mapping-rules.adoc", "title": "message-mapping-rules", "heading": "message-mapping-rules", "heading_level": 1, "file_order": 27, "section_index": 0, "content_hash": "21fb5bf530e7d823ba24ab04f47d792895fc1baa50f22f32e34e3f99c8bf298e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/message-mapping-rules.adoc"}}
{"id": "sha256:d4a06430319cfb4d4ea1bacbb1d74d7019e0fad3318b0c22a5f7d2e4ac7bf680", "content": "The following example shows a single un-annotated parameter (object or primitive) that is not a `Map` or a `Properties` object with a non-void return type:\n\n[source,java]\n----\npublic String doSomething(Object o);\n----\n\nThe input parameter is a message payload.\nIf the parameter type is not compatible with a message payload, an attempt is made to convert it by using a conversion service provided by Spring 3.0.\nThe return value is incorporated as a payload of the returned message.\n\nThe following example shows a single unannotated parameter (object or primitive)that is not a `Map` or a `Properties` with a `Message` return type:\n\n[source,java]\n----\npublic Message doSomething(Object o);\n----\n\nThe input parameter is a message payload.\nIf the parameter type is not compatible with a message payload, an attempt is made to convert it by using a conversion service provided by Spring 3.0.\nThe return value is a newly constructed message that is sent to the next destination.\n\nThe following example shows a single parameter that is a message (or one of its subclasses) with an arbitrary object or primitive return type:\n\n[source,java]\n----\npublic int doSomething(Message msg);\n----\n\nThe input parameter is itself a `Message`.\nThe return value becomes a payload of the `Message` that is sent to the next destination.\n\nThe following example shows a single parameter that is a `Message` (or one of its subclasses) with a `Message` (or one of its subclasses) as the return type:\n\n[source,java]\n----\npublic Message doSomething(Message msg);\n----\n\nThe input parameter is itself a `Message`.\nThe return value is a newly constructed `Message` that is sent to the next destination.\n\nThe following example shows a single parameter of type `Map` or `Properties` with a `Message` as the return type:\n\n[source,java]\n----\npublic Message doSomething(Map m);\n----\n\nThis one is a bit interesting.\nAlthough, at first, it might seem like an easy mapping straight to message headers, preference is always given to a `Message` payload.\nThis means that if a `Message` payload is of type `Map`, this input argument represents a `Message` payload.\nHowever, if the `Message` payload is not of type `Map`, the conversion service does not try to convert the payload, and the input argument is mapped to message headers.\n\nThe following example shows two parameters, where one of them is an arbitrary type (an object or a primitive) that is not a `Map` or a `Properties` object and the other is of type `Map` or `Properties` type (regardless of the return):\n\n[source,java]\n----\npublic Message doSomething(Map h, <T> t);\n----\n\nThis combination contains two input parameters where one of them is of type `Map`.\nThe non-`Map` parameters (regardless of the order) are mapped to a `Message` payload and the `Map` or `Properties` (regardless of the order) is mapped to message headers, giving you a nice POJO way of interacting with `Message` structure.\n\nThe following example shows no parameters (regardless of the return):\n\n[source,java]\n----\npublic String doSomething();\n----\n\nThis message handler method is invoked based on the Message sent to the input channel to which this handler is connected.\nHowever, no `Message` data is mapped, thus making the `Message` act as event or trigger to invoke the handler.\nThe output is mapped according to the rules xref:configuration/message-mapping-rules.adoc[described earlier].\n\nThe following example shows no parameters and a void return:\n\n[source,java]\n----\npublic void soSomething();\n----\n\nThis example is the same as the previous example, but it produces no output.\n\n[[annotation-based-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/message-mapping-rules.adoc", "title": "message-mapping-rules", "heading": "Sample Scenarios", "heading_level": 2, "file_order": 27, "section_index": 1, "content_hash": "d4a06430319cfb4d4ea1bacbb1d74d7019e0fad3318b0c22a5f7d2e4ac7bf680", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/message-mapping-rules.adoc"}}
{"id": "sha256:e026b7fe34de1e9c5ec9792b2ebe2255d4220622ebf99a62601621cc6225e0b4", "content": "Annotation-based mapping is the safest and least ambiguous approach to map messages to methods.\nThe following example shows how to explicitly map a method to a header:\n\n[source,java]\n----\npublic String doSomething(@Payload String s, @Header(\"someheader\") String b)\n----\n\nAs you can see later on, without an annotation, this signature would result in an ambiguous condition.\nHowever, by explicitly mapping the first argument to a `Message` payload and the second argument to a value of the `someheader` message header, we avoid any ambiguity.\n\nThe following example is nearly identical to the preceding example:\n\n[source,java]\n----\npublic String doSomething(@Payload String s, @RequestParam(\"something\") String b)\n----\n\n`@RequestMapping` or any other non-Spring Integration mapping annotation is irrelevant and is therefore ignored, leaving the second parameter unmapped.\nAlthough the second parameter could easily be mapped to a payload, there can only be one payload.\nTherefore, the annotations keep this method from being ambiguous.\n\nThe following example shows another similar method that would be ambiguous were it not for annotations to clarify the intent:\n\n[source,java]\n----\npublic String foo(String s, @Header(\"foo\") String b)\n----\n\nThe only difference is that the first argument is implicitly mapped to the message payload.\n\nThe following example shows yet another signature that would definitely be treated as ambiguous without annotations because it has more than two arguments:\n\n[source,java]\n----\npublic String soSomething(@Headers Map m, @Header(\"something\") Map f, @Header(\"someotherthing\") String bar)\n----\n\nThis example would be especially problematic, because two of its arguments are `Map` instances.\nHowever, with annotation-based mapping, the ambiguity is easily avoided.\nIn this example the first argument is mapped to all the message headers, while the second and third argument maps to the values of the message headers named 'something' and 'someotherthing'.\nThe payload is not being mapped to any argument.\n\n[[complex-scenarios]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/message-mapping-rules.adoc", "title": "message-mapping-rules", "heading": "Annotation-based Mapping", "heading_level": 2, "file_order": 27, "section_index": 2, "content_hash": "e026b7fe34de1e9c5ec9792b2ebe2255d4220622ebf99a62601621cc6225e0b4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/message-mapping-rules.adoc"}}
{"id": "sha256:2e65ccf600e520c6417ef0185a386a026ccaf8488e628103e5461a22b7a59d8c", "content": "The following example uses multiple parameters:\n\nMultiple parameters can create a lot of ambiguity in regard to determining the appropriate mappings.\nThe general advice is to annotate your method parameters with `@Payload`, `@Header`, and `@Headers`.\nThe examples in this section show ambiguous conditions that result in an exception being raised.\n\n[source,java]\n----\npublic String doSomething(String s, int i)\n----\n\nThe two parameters are equal in weight.\nTherefore, there is no way to determine which one is a payload.\n\nThe following example shows a similar problem, only with three parameters:\n\n[source,java]\n----\npublic String foo(String s, Map m, String b)\n----\n\nAlthough the Map could be easily mapped to message headers, there is no way to determine what to do with the two String parameters.\n\nThe following example shows another ambiguous method:\n\n[source,java]\n----\npublic String foo(Map m, Map f)\n----\n\nAlthough one might argue that one `Map` could be mapped to the message payload and the other one to the message headers, we cannot rely on the order.\n\nTIP: Any method signature with more than one method argument that is not (`Map`, `<T>`) and with unannotated parameters results in an ambiguous condition and triggers an exception.\n\nThe next set of examples each shows multiple methods that result in ambiguity.\n\nMessage handlers with multiple methods are mapped based on the same rules that are described earlier (in the examples).\nHowever, some scenarios might still look confusing.\n\nThe following example shows multiple methods with legal (mappable and unambiguous) signatures:\n\n[source,java]\n----\npublic class Something {\n public String doSomething(String str, Map m);\n\n public String doSomething(Map m);\n}\n----\n\n(Whether the methods have the same name or different names makes no difference).\nThe `Message` could be mapped to either method.\nThe first method would be invoked when the message payload could be mapped to `str` and the message headers could be mapped to `m`.\nThe second method could also be a candidate by mapping only the message headers to `m`.\nTo make matters worse, both methods have the same name.\nAt first, that might look ambiguous because of the following configuration:\n\n[source,xml]\n----\n<int:service-activator input-channel=\"input\" output-channel=\"output\" method=\"doSomething\">\n <bean class=\"org.things.Something\"/>\n</int:service-activator>\n----\n\nIt works because mappings are based on the payload first and everything else next.\nIn other words, the method whose first argument can be mapped to a payload takes precedence over all other methods.\n\nNow consider an alternate example, which produces a truly ambiguous condition:\n\n[source,java]\n----\npublic class Something {\n public String doSomething(String str, Map m);\n\n public String doSomething(String str);\n}\n----\n\nBoth methods have signatures that could be mapped to a message payload.\nThey also have the same name.\nSuch handler methods will trigger an exception.\nHowever, if the method names were different, you could influence the mapping with a `method` attribute (shown in the next example).\nThe following example shows the same example with two different method names:\n\n[source,java]\n----\npublic class Something {\n public String doSomething(String str, Map m);\n\n public String doSomethingElse(String str);\n}\n----\n\nThe following example shows how to use the `method` attribute to dictate the mapping:\n\n[source,xml]\n----\n<int:service-activator input-channel=\"input\" output-channel=\"output\" method=\"doSomethingElse\">\n <bean class=\"org.bar.Foo\"/>\n</int:service-activator>\n----\nBecause the configuration explicitly maps the `doSomethingElse` method, we have eliminated the ambiguity.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/message-mapping-rules.adoc", "title": "message-mapping-rules", "heading": "Complex Scenarios", "heading_level": 2, "file_order": 27, "section_index": 3, "content_hash": "2e65ccf600e520c6417ef0185a386a026ccaf8488e628103e5461a22b7a59d8c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/message-mapping-rules.adoc"}}
{"id": "sha256:42734d5f9706b0723243ac46022b75e32a30f690229780782a87db7cb95a645d", "content": "[[meta-annotations]]\n\nStarting with version 4.0, all messaging annotations can be configured as meta-annotations, and all user-defined messaging annotations can define the same attributes to override their default values.\nIn addition, meta-annotations can be configured hierarchically, as the following example shows:\n\n[source,java]\n----\n@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@ServiceActivator(inputChannel = \"annInput\", outputChannel = \"annOutput\")\npublic @interface MyServiceActivator {\n\n String[] adviceChain = { \"annAdvice\" };\n}\n\n@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@MyServiceActivator\npublic @interface MyServiceActivator1 {\n\n String inputChannel();\n\n String outputChannel();\n}\n...\n\n@MyServiceActivator1(inputChannel = \"inputChannel\", outputChannel = \"outputChannel\")\npublic Object service(Object payload) {\n ...\n}\n----\n\nConfiguring meta-annotations hierarchically lets users set defaults for various attributes and enables isolation of framework Java dependencies to user annotations, avoiding their use in user classes.\nIf the framework finds a method with a user annotation that has a framework meta-annotation, it is treated as if the method were annotated directly with the framework annotation.\n\n[[annotations_on_beans]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/meta-annotations.adoc", "title": "meta-annotations", "heading": "meta-annotations", "heading_level": 1, "file_order": 28, "section_index": 0, "content_hash": "42734d5f9706b0723243ac46022b75e32a30f690229780782a87db7cb95a645d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/meta-annotations.adoc"}}
{"id": "sha256:e3ff3bbec096695d4e51458eafa17769b3e18b5cba63eb742eca6c92ff86f6ce", "content": "Starting with version 4.0, you can configure messaging annotations on `@Bean` method definitions in `@Configuration` classes, to produce message endpoints based on the beans, not the methods.\nIt is useful when `@Bean` definitions are \"`out-of-the-box`\" `MessageHandler` instances (`AggregatingMessageHandler`, `DefaultMessageSplitter`, and others), `Transformer` instances (`JsonToObjectTransformer`, `ClaimCheckOutTransformer`, and others), and `MessageSource` instances (`FileReadingMessageSource`, `RedisStoreMessageSource`, and others).\nThe following example shows how to use messaging annotations with `@Bean` annotations:\n\n[source,java]\n----\n@Configuration\n@EnableIntegration\npublic class MyFlowConfiguration {\n\n @Bean\n @InboundChannelAdapter(value = \"inputChannel\", poller = @Poller(fixedDelay = \"1000\"))\n public MessageSource<String> consoleSource() {\n return CharacterStreamReadingMessageSource.stdin();\n }\n\n @Bean\n @Transformer(inputChannel = \"inputChannel\", outputChannel = \"httpChannel\")\n public ObjectToMapTransformer toMapTransformer() {\n return new ObjectToMapTransformer();\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"httpChannel\")\n public HttpRequestExecutingMessageHandler httpHandler() {\n HttpRequestExecutingMessageHandler handler = new HttpRequestExecutingMessageHandler(\"https://foo/service\");\n handler.setExpectedResponseType(String.class);\n handler.setOutputChannelName(\"outputChannel\");\n return handler;\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"outputChannel\")\n public LoggingHandler loggingHandler() {\n return new LoggingHandler(\"info\");\n }\n\n}\n----\n\nVersion 5.0 introduced support for a `@Bean` annotated with `@InboundChannelAdapter` that returns `java.util.function.Supplier`, which can produce either a POJO or a `Message`.\nThe following example shows how to use that combination:\n\n[source,java]\n----\n@Configuration\n@EnableIntegration\npublic class MyFlowConfiguration {\n\n @Bean\n @InboundChannelAdapter(value = \"inputChannel\", poller = @Poller(fixedDelay = \"1000\"))\n public Supplier<String> pojoSupplier() {\n return () -> \"foo\";\n }\n\n @Bean\n @InboundChannelAdapter(value = \"inputChannel\", poller = @Poller(fixedDelay = \"1000\"))\n public Supplier<Message<String>> messageSupplier() {\n return () -> new GenericMessage<>(\"foo\");\n }\n}\n----\n\nThe meta-annotation rules work on `@Bean` methods as well (the `@MyServiceActivator` annotation xref:configuration/meta-annotations.adoc[described earlier] can be applied to a `@Bean` definition).\n\nNOTE: When you use these annotations on consumer `@Bean` definitions, if the bean definition returns an appropriate `MessageHandler` (depending on the annotation type), you must set attributes (such as `outputChannel`, `requiresReply`, `order`, and others), on the `MessageHandler` `@Bean` definition itself.\nOnly the following annotation attributes are used: `adviceChain`, `autoStartup`, `inputChannel`, `phase`, and `poller`.\nAll other attributes are for the handler.\n\nNOTE: The bean names are generated with the following algorithm:\n\n* The `MessageHandler` (`MessageSource`) `@Bean` gets its own standard name from the method name or `name` attribute on the `@Bean`.\nThis works as though there were no messaging annotation on the `@Bean` method.\n* The `AbstractEndpoint` bean name is generated with the following pattern: `[@Bean name].[decapitalizedAnnotationClassShortName]`.\nFor example, the `SourcePollingChannelAdapter` endpoint for the `consoleSource()` definition xref:configuration/meta-annotations.adoc#annotations_on_beans[shown earlier] gets a bean name of `consoleSource.inboundChannelAdapter`.\nUnlike with POJO methods, the bean method name is not included in the endpoint bean name.\nSee also xref:overview.adoc#endpoint-bean-names[Endpoint Bean Names].\n* If `@Bean` cannot be used directly in the target endpoint (not an instance of a `MessageSource`, `AbstractReplyProducingMessageHandler` or `AbstractMessageRouter`), a respective `AbstractStandardMessageHandlerFactoryBean` is registered to delegate to this `@Bean`.\nThe bean name for this wrapper is generated with the following pattern: `[@Bean name].[decapitalizedAnnotationClassShortName].[handler (or source)]`.\n\nIMPORTANT: When using these annotations on `@Bean` definitions, the `inputChannel` must reference a declared bean.\nChannels are automatically declared if not present in the application context yet.\n\n[NOTE]\n=====\nWith Java configuration, you can use any `@Conditional` (for example, `@Profile`) definition on the `@Bean` method level to skip the bean registration for some conditional reason.\nThe following example shows how to do so:\n\n[source,java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"skippedChannel\")\n@Profile(\"thing\")\npublic MessageHandler skipped() {\n return System.out::println;\n}\n----\nTogether with the existing Spring container logic, the messaging endpoint bean (based on the `@ServiceActivator` annotation), is also not registered.\n=====\n\n[[creating-a-bridge-with-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/meta-annotations.adoc", "title": "meta-annotations", "heading": "Annotations on `@Bean` Methods", "heading_level": 2, "file_order": 28, "section_index": 1, "content_hash": "e3ff3bbec096695d4e51458eafa17769b3e18b5cba63eb742eca6c92ff86f6ce", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/meta-annotations.adoc"}}
{"id": "sha256:3c7bd56fb52a841adcc38fa094428852fa20e10465dcf0c05eead293b3e66a3e", "content": "Starting with version 4.0, Java configuration provides the `@BridgeFrom` and `@BridgeTo` `@Bean` method annotations to mark `MessageChannel` beans in `@Configuration` classes.\nThese really exists for completeness, providing a convenient mechanism to declare a `BridgeHandler` and its message endpoint configuration:\n\n[source,java]\n----\n@Bean\npublic PollableChannel bridgeFromInput() {\n return new QueueChannel();\n}\n\n@Bean\n@BridgeFrom(value = \"bridgeFromInput\", poller = @Poller(fixedDelay = \"1000\"))\npublic MessageChannel bridgeFromOutput() {\n return new DirectChannel();\n}\n@Bean\npublic QueueChannel bridgeToOutput() {\n return new QueueChannel();\n}\n\n@Bean\n@BridgeTo(\"bridgeToOutput\")\npublic MessageChannel bridgeToInput() {\n return new DirectChannel();\n}\n----\n\nYou can use these annotations as meta-annotations as well.\n\n[[advising-annotated-endpoints]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/meta-annotations.adoc", "title": "meta-annotations", "heading": "Creating a Bridge with Annotations", "heading_level": 2, "file_order": 28, "section_index": 2, "content_hash": "3c7bd56fb52a841adcc38fa094428852fa20e10465dcf0c05eead293b3e66a3e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/meta-annotations.adoc"}}
{"id": "sha256:5c0303aefe5cd7e60ed8251fb95b0884a29273b507bcddea7ebd7b3a775b1fc3", "content": "See xref:handler-advice/advising-with-annotations.adoc[Advising Endpoints Using Annotations].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/meta-annotations.adoc", "title": "meta-annotations", "heading": "Advising Annotated Endpoints", "heading_level": 2, "file_order": 28, "section_index": 3, "content_hash": "5c0303aefe5cd7e60ed8251fb95b0884a29273b507bcddea7ebd7b3a775b1fc3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/meta-annotations.adoc"}}
{"id": "sha256:be346caedfaec7739a98c859fa0f5a68cb945690e3db37d7bd2d564e86783ebc", "content": "[[namespace-taskscheduler]]\n\nIn Spring Integration, the `ApplicationContext` plays the central role of a message bus, and you need to consider only a couple of configuration options.\nFirst, you may want to control the central `TaskScheduler` instance.\nYou can do so by providing a single bean named `taskScheduler`.\nThis is also defined as a constant, as follows:\n\n[source,java]\n----\nIntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME\n----\n\nBy default, Spring Integration relies on an instance of `ThreadPoolTaskScheduler`, as described in the https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling[Task Execution and Scheduling] section of the Spring Framework reference manual.\nThat default `TaskScheduler` starts up automatically with a pool of ten threads, but see xref:configuration/global-properties.adoc[Global Properties].\nIf you provide your own `TaskScheduler` instance instead, you can set the 'autoStartup' property to `false` or provide your own pool size value.\n\nWhen polling consumers provide an explicit task executor reference in their configuration, the invocation of the handler methods happens within that executor's thread pool and not the main scheduler pool.\nHowever, when no task executor is provided for an endpoint's poller, it is invoked by one of the main scheduler's threads.\n\nCAUTION: Do not run long-running tasks on poller threads.\nUse a task executor instead.\nIf you have a lot of polling endpoints, you can cause thread starvation unless you increase the pool size.\nAlso, polling consumers have a default `receiveTimeout` of one second.\nSince the poller thread blocks for this time, we recommend that you use a task executor when many such endpoints exist, again to avoid starvation.\nAlternatively, you can reduce the `receiveTimeout`.\n\nNOTE: An endpoint is a Polling Consumer if its input channel is one of the queue-based (that is, pollable) channels.\nEvent-driven consumers are those having input channels that have dispatchers instead of queues (in other words, they are subscribable).\nSuch endpoints have no poller configuration, since their handlers are invoked directly.\n\n[IMPORTANT]\n=====\nWhen running in a JEE container, you may need to use Spring's `TimerManagerTaskScheduler`, as described https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling-task-scheduler-implementations[here], instead of the default `taskScheduler`.\nTo do so, define a bean with the appropriate JNDI name for your environment, as the following example shows:\n\n[source,xml]\n----\n<bean id=\"taskScheduler\" class=\"org.springframework.scheduling.concurrent.DefaultManagedTaskScheduler\">\n <property name=\"jndiName\" value=\"tm/MyTimerManager\" />\n <property name=\"resourceRef\" value=\"true\" />\n</bean>\n----\n=====\n\nIMPORTANT: When a custom `TaskScheduler` is configured in the application context (like the above-mentioned `DefaultManagedTaskScheduler`), it is recommended to supply it with a `MessagePublishingErrorHandler` (`integrationMessagePublishingErrorHandler` bean) to be able to handle exceptions as `ErrorMessage`s sent to the error channel, as is done with the default `TaskScheduler` bean provided by the framework.\n\nSee also xref:scatter-gather.adoc#scatter-gather-error-handling[Error Handling] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/namespace-taskscheduler.adoc", "title": "namespace-taskscheduler", "heading": "namespace-taskscheduler", "heading_level": 1, "file_order": 29, "section_index": 0, "content_hash": "be346caedfaec7739a98c859fa0f5a68cb945690e3db37d7bd2d564e86783ebc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/namespace-taskscheduler.adoc"}}
{"id": "sha256:77b3fb03738694a56f9c935436a61ffe16b6f406ded33cf4ebf49f9e7cd5664c", "content": "[[configuration-namespace]]\n\nYou can configure Spring Integration components with XML elements that map directly to the terminology and concepts of enterprise integration.\nIn many cases, the element names match those of the https://www.enterpriseintegrationpatterns.com/[_Enterprise Integration Patterns_] book.\n\nTo enable Spring Integration's core namespace support within your Spring configuration files, add the following namespace reference and schema mapping in your top-level 'beans' element:\n\n[subs=\"+quotes\"]\n----\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n *xmlns:int=\"http://www.springframework.org/schema/integration\"*\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n *http://www.springframework.org/schema/integration*\n *https://www.springframework.org/schema/integration/spring-integration.xsd*\">\n----\n\n(We have emphasized the lines that are particular to Spring Integration.)\n\nYou can choose any name after `xmlns:`.\nWe use `int` (short for Integration) for clarity, but you might prefer another abbreviation.\nOn the other hand, if you use an XML editor or IDE support, the availability of auto-completion may convince you to keep the longer name for clarity.\nAlternatively, you can create configuration files that use the Spring Integration schema as the primary namespace, as the following example shows:\n\n[subs=+quotes]\n----\n*<beans:beans xmlns=\"http://www.springframework.org/schema/integration\"*\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:beans=\"http://www.springframework.org/schema/beans\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n *http://www.springframework.org/schema/integration*\n *https://www.springframework.org/schema/integration/spring-integration.xsd*\">\n----\n\n(We have emphasized the lines that are particular to Spring Integration.)\n\nWhen using this alternative, no prefix is necessary for the Spring Integration elements.\nOn the other hand, if you define a generic Spring bean within the same configuration file, the bean element requires a prefix (`<beans:bean .../>`).\nSince it is generally a good idea to modularize the configuration files themselves (based on responsibility or architectural layer), you may find it appropriate to use the latter approach in the integration-focused configuration files, since generic beans are seldom necessary within those files.\nFor the purposes of this documentation, we assume the integration namespace is the primary.\n\nSpring Integration provides many other namespaces.\nIn fact, each adapter type (JMS, file, and so on) that provides namespace support defines its elements within a separate schema.\nIn order to use these elements, add the necessary namespaces with an `xmlns` entry and the corresponding `schemaLocation` mapping.\nFor example, the following root element shows several of these namespace declarations:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int=\"http://www.springframework.org/schema/integration\"\n xmlns:int-file=\"http://www.springframework.org/schema/integration/file\"\n xmlns:int-jms=\"http://www.springframework.org/schema/integration/jms\"\n xmlns:int-mail=\"http://www.springframework.org/schema/integration/mail\"\n xmlns:int-ws=\"http://www.springframework.org/schema/integration/ws\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration.xsd\n http://www.springframework.org/schema/integration/file\n https://www.springframework.org/schema/integration/file/spring-integration-file.xsd\n http://www.springframework.org/schema/integration/jms\n https://www.springframework.org/schema/integration/jms/spring-integration-jms.xsd\n http://www.springframework.org/schema/integration/mail\n https://www.springframework.org/schema/integration/mail/spring-integration-mail.xsd\n http://www.springframework.org/schema/integration/ws\n https://www.springframework.org/schema/integration/ws/spring-integration-ws.xsd\">\n ...\n</beans>\n----\n\nThis reference manual provides specific examples of the various elements in their corresponding chapters.\nHere, the main thing to recognize is the consistency of the naming for each namespace URI and schema location.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration/namespace.adoc", "title": "namespace", "heading": "namespace", "heading_level": 1, "file_order": 30, "section_index": 0, "content_hash": "77b3fb03738694a56f9c935436a61ffe16b6f406ded33cf4ebf49f9e7cd5664c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration/namespace.adoc"}}
{"id": "sha256:ca33e915ccbdbc9c984e6d223354e56b0ae827efe5defff7f2b0aef99a2d4ca8", "content": "[[integration-flow-as-gateway]]\n\nThe `IntegrationFlow` can start from the service interface that provides a `GatewayProxyFactoryBean` component, as the following example shows:\n\n[source,java]\n----\npublic interface ControlBusGateway {\n\n void send(String command);\n}\n\n...\n\n@Bean\npublic IntegrationFlow controlBusFlow() {\n return IntegrationFlow.from(ControlBusGateway.class)\n .controlBus()\n .get();\n}\n----\n\nAll the proxies for interface methods are supplied with the channel to send messages to the next integration component in the `IntegrationFlow`.\nYou can mark the service interface with the `@MessagingGateway` annotation and mark the methods with the `@Gateway` annotations.\nNevertheless, the `requestChannel` is ignored and overridden with that internal channel for the next component in the `IntegrationFlow`.\nOtherwise, creating such a configuration by using `IntegrationFlow` does not make sense.\n\nBy default, a `GatewayProxyFactoryBean` gets a conventional bean name, such as `[FLOW_BEAN_NAME.gateway]`.\nYou can change that ID by using the `@MessagingGateway.name()` attribute or the overloaded `IntegrationFlow.from(Class<?> serviceInterface, Consumer<GatewayProxySpec> endpointConfigurer)` factory method.\nAlso, all the attributes from the `@MessagingGateway` annotation on the interface are applied to the target `GatewayProxyFactoryBean`.\nWhen annotation configuration is not applicable, the `Consumer<GatewayProxySpec>` variant can be used for providing the appropriate option for the target proxy.\nThis DSL method is available starting with version 5.2.\n\nWith Java 8, you can even create an integration gateway with the `java.util.function` interfaces, as the following example shows:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow errorRecovererFlow() {\n return IntegrationFlow.from(Function.class, (gateway) -> gateway.beanName(\"errorRecovererFunction\"))\n .<Object>handle((p, h) -> {\n throw new RuntimeException(\"intentional\");\n }, e -> e.advice(retryAdvice()))\n .get();\n}\n----\n\nThat `errorRecovererFlow` can be used as follows:\n\n[source,java]\n----\n@Autowired\n@Qualifier(\"errorRecovererFunction\")\nprivate Function<String, String> errorRecovererFlowGateway;\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/integration-flow-as-gateway.adoc", "title": "integration-flow-as-gateway", "heading": "integration-flow-as-gateway", "heading_level": 1, "file_order": 31, "section_index": 0, "content_hash": "ca33e915ccbdbc9c984e6d223354e56b0ae827efe5defff7f2b0aef99a2d4ca8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/integration-flow-as-gateway.adoc"}}
{"id": "sha256:a5d5818795b23795cc0afd583cc062589a196f8d2a92154de3ec8d4a565c7e25", "content": "[[integration-flows-composition]]\n\nWith the `MessageChannel` abstraction as a first-class citizen in Spring Integration, the composition of integration flows was always assumed.\nThe input channel of any endpoint in the flow can be used to send messages from any other endpoint and not only from the one that has this channel as an output.\nFurthermore, with a `@MessagingGateway` contract, Content Enricher components, composite endpoints like a `<chain>`, and now with `IntegrationFlow` beans (e.g. `IntegrationFlowAdapter`), it is straightforward enough to distribute the business logic between shorter, reusable parts.\nAll that is needed for the final composition is knowledge about a `MessageChannel` to send to or receive from.\n\nStarting with version `5.5.4`, to abstract more from `MessageChannel` and hide implementation details from the end-user, the `IntegrationFlow` introduces the `from(IntegrationFlow)` factory method to allow starting the current `IntegrationFlow` from the output of an existing flow:\n\n[source,java]\n----\n@Bean\nIntegrationFlow templateSourceFlow() {\n return IntegrationFlow.fromSupplier(() -> \"test data\")\n .channel(\"sourceChannel\")\n .get();\n}\n\n@Bean\nIntegrationFlow compositionMainFlow(IntegrationFlow templateSourceFlow) {\n return IntegrationFlow.from(templateSourceFlow)\n .<String, String>transform(String::toUpperCase)\n .channel(c -> c.queue(\"compositionMainFlowResult\"))\n .get();\n}\n----\n\nOn the other hand, the `IntegrationFlowDefinition` has added a `to(IntegrationFlow)` terminal operator to continue the current flow at the input channel of some other flow:\n\n[source,java]\n----\n@Bean\nIntegrationFlow mainFlow(IntegrationFlow otherFlow) {\n return f -> f\n .<String, String>transform(String::toUpperCase)\n .to(otherFlow);\n}\n\n@Bean\nIntegrationFlow otherFlow() {\n return f -> f\n .<String, String>transform(p -> p + \" from other flow\")\n .channel(c -> c.queue(\"otherFlowResultChannel\"));\n}\n----\n\nThe composition in the middle of the flow is simply achievable with an existing `gateway(IntegrationFlow)` EIP-method.\nThis way we can build flows with any complexity by composing them from simpler, reusable logical blocks.\nFor example, you may add a library of `IntegrationFlow` beans as a dependency, and it is just enough to have their configuration classes imported to the final project and autowired for your `IntegrationFlow` definitions.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/integration-flows-composition.adoc", "title": "integration-flows-composition", "heading": "integration-flows-composition", "heading_level": 1, "file_order": 32, "section_index": 0, "content_hash": "a5d5818795b23795cc0afd583cc062589a196f8d2a92154de3ec8d4a565c7e25", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/integration-flows-composition.adoc"}}
{"id": "sha256:b614edf9318ffccc62a59770101110e6fa0829e7bd250e6bc572cc26e57a4718", "content": "[[java-dsl-aggregators]]\n\nAn `Aggregator` is conceptually the opposite of a `Splitter`.\nIt aggregates a sequence of individual messages into a single message and is necessarily more complex.\nBy default, an aggregator returns a message that contains a collection of payloads from incoming messages.\nThe same rules are applied for the `Resequencer`.\nThe following example shows a canonical example of the splitter-aggregator pattern:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow splitAggregateFlow() {\n return IntegrationFlow.from(\"splitAggregateInput\")\n .split()\n .channel(MessageChannels.executor(this.taskExecutor()))\n .resequence()\n .aggregate()\n .get();\n}\n----\n\nThe `split()` method splits the list into individual messages and sends them to the `ExecutorChannel`.\nThe `resequence()` method reorders messages by sequence details found in the message headers.\nThe `aggregate()` method collects those messages.\n\nHowever, you can change the default behavior by specifying a release strategy and correlation strategy, among other things.\nConsider the following example:\n\n[source,java]\n----\n.aggregate(a ->\n a.correlationStrategy(m -> m.getHeaders().get(\"myCorrelationKey\"))\n .releaseStrategy(g -> g.size() > 10)\n .messageStore(messageStore()))\n----\n\nThe preceding example correlates messages that have `myCorrelationKey` headers and releases the messages once at least ten have been accumulated.\n\nSimilar lambda configurations are provided for the `resequence()` EIP method.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-aggregators.adoc", "title": "java-aggregators", "heading": "java-aggregators", "heading_level": 1, "file_order": 33, "section_index": 0, "content_hash": "b614edf9318ffccc62a59770101110e6fa0829e7bd250e6bc572cc26e57a4718", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-aggregators.adoc"}}
{"id": "sha256:fb747051acfeab181ea8d9333faa91b38662e36a7fe13567dff55ba952d1310c", "content": "[[java-dsl-basics]]\n\nThe `org.springframework.integration.dsl` package contains the `IntegrationFlowBuilder` API mentioned earlier and a number of `IntegrationComponentSpec` implementations, which are also builders and provide the fluent API to configure concrete endpoints.\nThe `IntegrationFlowBuilder` infrastructure provides common https://www.enterpriseintegrationpatterns.com/[enterprise integration patterns] (EIP) for message-based applications, such as channels, endpoints, pollers, and channel interceptors.\n\nIMPORTANT:: The `IntegrationComponentSpec` is a `FactoryBean` implementation, therefore its `getObject()` method must not be called from bean definitions.\nThe `IntegrationComponentSpec` implementation must be left as is for bean definitions and the framework will manage its lifecycle.\nBean method parameter injection for the target `IntegrationComponentSpec` type (a `FactoryBean` value) must be used for `IntegrationFlow` bean definitions instead of bean method references.\n\nEndpoints are expressed as verbs in the DSL to improve readability.\nThe following list includes the common DSL method names and the associated EIP endpoint:\n\n* transform -> `Transformer`\n* filter -> `Filter`\n* handle -> `ServiceActivator`\n* split -> `Splitter`\n* aggregate -> `Aggregator`\n* route -> `Router`\n* bridge -> `Bridge`\n\nConceptually, integration processes are constructed by composing these endpoints into one or more message flows.\nNote that EIP does not formally define the term 'message flow', but it is useful to think of it as a unit of work that uses well known messaging patterns.\nThe DSL provides an `IntegrationFlow` component to define a composition of channels and endpoints between them, but now `IntegrationFlow` plays only the configuration role to populate real beans in the application context and is not used at runtime.\nHowever, the bean for `IntegrationFlow` can be autowired as a `Lifecycle` to control `start()` and `stop()` for the whole flow which is delegated to all the Spring Integration components associated with this `IntegrationFlow`.\nThe following example uses the `IntegrationFlow` fluent API to define an `IntegrationFlow` bean by using EIP-methods from `IntegrationFlowBuilder`:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow integerFlow() {\n return IntegrationFlow.from(\"input\")\n .<String, Integer>transform(Integer::parseInt)\n .get();\n}\n----\n\nThe `transform` method accepts a lambda as an endpoint argument to operate on the message payload.\nThe real argument of this method is a `GenericTransformer<S, T>` instance.\nConsequently, any of the provided transformers (`ObjectToJsonTransformer`, `FileToStringTransformer`, and other) can be used here.\n\nUnder the covers, `IntegrationFlowBuilder` recognizes the `MessageHandler` and the endpoint for it, with `MessageTransformingHandler` and `ConsumerEndpointFactoryBean`, respectively.\nConsider another example:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow myFlow() {\n return IntegrationFlow.from(\"input\")\n .filter(\"World\"::equals)\n .transform(\"Hello \"::concat)\n .handle(System.out::println)\n .get();\n}\n----\n\nThe preceding example composes a sequence of `Filter -> Transformer -> Service Activator`.\nThe flow is \"'one way'\".\nThat is, it does not provide a reply message but only prints the payload to STDOUT.\nThe endpoints are automatically wired together by using direct channels.\n\n[[java-dsl-class-cast]]\n.Lambdas And `Message<?>` Arguments\n[IMPORTANT]\n====\nWhen using lambdas in EIP methods, the \"input\" argument is generally the message payload.\nIf you wish to access the entire message, use one of the overloaded methods that take a `Class<?>` as the first parameter.\nFor example, this won't work:\n\n[source, java]\n----\n.<Message<?>, Foo>transform(m -> newFooFromMessage(m))\n----\n\nThis will fail at runtime with a `ClassCastException` because the lambda doesn't retain the argument type and the framework will attempt to cast the payload to a `Message<?>`.\n\nInstead, use:\n\n[source, java]\n----\n.(Message.class, m -> newFooFromMessage(m))\n----\n====\n\n[[bean-definitions-override]]\n.Bean Definitions override\n[IMPORTANT]\n====\nThe Java DSL can register beans for the object defined in-line in the flow definition, as well as can reuse existing, injected beans.\nIn case of the same bean name defined for in-line object and existing bean definition, a `BeanDefinitionOverrideException` is thrown indicating that such a configuration is wrong.\nHowever, when you deal with `prototype` beans, there is no way to detect from the integration flow processor an existing bean definition because every time we call a `prototype` bean from the `BeanFactory` we get a new instance.\nThis way a provided instance is used in the `IntegrationFlow` as is without any bean registration and any possible check against existing `prototype` bean definition.\nHowever `BeanFactory.initializeBean()` is called for this object if it has an explicit `id` and bean definition for this name is in `prototype` scope.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-basics.adoc", "title": "java-basics", "heading": "java-basics", "heading_level": 1, "file_order": 34, "section_index": 0, "content_hash": "fb747051acfeab181ea8d9333faa91b38662e36a7fe13567dff55ba952d1310c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-basics.adoc"}}
{"id": "sha256:792bb82a4ffb36f2016d454de3871e8d8dd790c12d7d4bae2d63ce33b8f09a7d", "content": "[[java-dsl-channels]]\n\nIn addition to the `IntegrationFlowBuilder` with EIP methods, the Java DSL provides a fluent API to configure `MessageChannel` instances.\nFor this purpose the `MessageChannels` builder factory is provided.\nThe following example shows how to use it:\n\n[source,java]\n----\n@Bean\npublic PriorityChannelSpec priorityChannel() {\n return MessageChannels.priority(this.mongoDbChannelMessageStore, \"priorityGroup\")\n .interceptor(wireTap());\n}\n----\n\nThe same `MessageChannels` builder factory can be used in the `channel()` EIP method from `IntegrationFlowBuilder` to wire endpoints, similar to wiring an `input-channel`/`output-channel` pair in the XML configuration.\nBy default, endpoints are wired with `DirectChannel` instances where the bean name is based on the following pattern: `[IntegrationFlow.beanName].channel#[channelNameIndex]`.\nThis rule is also applied for unnamed channels produced by inline `MessageChannels` builder factory usage.\nHowever, all `MessageChannels` methods have a variant that is aware of the `channelId` that you can use to set the bean names for `MessageChannel` instances.\nThe `MessageChannel` references and `beanName` can be used as bean-method invocations.\nThe following example shows the possible ways to use the `channel()` EIP method:\n\n[source,java]\n----\n@Bean\npublic QueueChannelSpec queueChannel() {\n return MessageChannels.queue();\n}\n\n@Bean\npublic PublishSubscribeChannelSpec<?> publishSubscribe() {\n return MessageChannels.publishSubscribe();\n}\n\n@Bean\npublic IntegrationFlow channelFlow() {\n return IntegrationFlow.from(\"input\")\n .fixedSubscriberChannel()\n .channel(\"queueChannel\")\n .channel(publishSubscribe())\n .channel(MessageChannels.executor(\"executorChannel\", this.taskExecutor))\n .channel(\"output\")\n .get();\n}\n----\n\n* `from(\"input\")` means \"'find and use the `MessageChannel` with the \"input\" id, or create one'\".\n* `fixedSubscriberChannel()` produces an instance of `FixedSubscriberChannel` and registers it with a name of `channelFlow.channel#0`.\n* `channel(\"queueChannel\")` works the same way but uses an existing `queueChannel` bean.\n* `channel(publishSubscribe())` is the bean-method reference.\n* `channel(MessageChannels.executor(\"executorChannel\", this.taskExecutor))` is the `IntegrationFlowBuilder` that exposes `IntegrationComponentSpec` to the `ExecutorChannel` and registers it as `executorChannel`.\n* `channel(\"output\")` registers the `DirectChannel` bean with `output` as its name, as long as no beans with this name already exist.\n\nNote: The preceding `IntegrationFlow` definition is valid, and all of its channels are applied to endpoints with `BridgeHandler` instances.\n\nIMPORTANT: Be careful to use the same inline channel definition through `MessageChannels` factory from different `IntegrationFlow` instances.\nEven if the DSL parser registers non-existent objects as beans, it cannot determine the same object (`MessageChannel`) from different `IntegrationFlow` containers.\nThe following example is wrong:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow startFlow() {\n return IntegrationFlow.from(\"input\")\n .transform(...)\n .channel(MessageChannels.queue(\"queueChannel\"))\n .get();\n}\n\n@Bean\npublic IntegrationFlow endFlow() {\n return IntegrationFlow.from(MessageChannels.queue(\"queueChannel\"))\n .handle(...)\n .get();\n}\n----\n\nThe result of that bad example is the following exception:\n\n```\nCaused by: java.lang.IllegalStateException:\nCould not register object [queueChannel] under bean name 'queueChannel':\n there is already object [queueChannel] bound\n at o.s.b.f.s.DefaultSingletonBeanRegistry.registerSingleton(DefaultSingletonBeanRegistry.java:129)\n```\n\nTo make it work, you need to declare `@Bean` for that channel and use its bean method from different `IntegrationFlow` instances.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-channels.adoc", "title": "java-channels", "heading": "java-channels", "heading_level": 1, "file_order": 35, "section_index": 0, "content_hash": "792bb82a4ffb36f2016d454de3871e8d8dd790c12d7d4bae2d63ce33b8f09a7d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-channels.adoc"}}
{"id": "sha256:0f933031f0531a87a159cdda1d38150981ff336cba7a4fe3ad7086208b1739f3", "content": "[[java-dsl-endpoints]]\n\nAll `IntegrationFlowBuilder` EIP methods have a variant that applies the lambda parameter to provide options for `AbstractEndpoint` instances: `SmartLifecycle`, `PollerMetadata`, `request-handler-advice-chain`, and others.\nEach of them has generic arguments, so it lets you configure an endpoint and even its `MessageHandler` in the context, as the following example shows:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow flow2() {\n return IntegrationFlow.from(this.inputChannel)\n .transformWith(t -> t\n .transformer(new PayloadSerializingTransformer())\n .autoStartup(false)\n .id(\"payloadSerializingTransformer\"))\n .transformWith(t -> t\n .transformer((Integer p) -> p * 2)\n .advice(expressionAdvice()))\n .get();\n}\n----\n\nIn addition, the `EndpointSpec` provides an `id()` method to let you register an endpoint bean with a given bean name, rather than a generated one.\n\nIf the `MessageHandler` is referenced as a bean, then any existing `adviceChain` configuration will be overridden if the `.advice()` method is present in the DSL definition:\n\n[source,java]\n----\n@Bean\npublic TcpOutboundGateway tcpOut() {\n TcpOutboundGateway gateway = new TcpOutboundGateway();\n gateway.setConnectionFactory(cf());\n gateway.setAdviceChain(Collections.singletonList(fooAdvice()));\n return gateway;\n}\n\n@Bean\npublic IntegrationFlow clientTcpFlow() {\n return f -> f\n .handle(tcpOut(), e -> e.advice(testAdvice()))\n .transform(Transformers.objectToString());\n}\n----\n\nThey are not merged, only the `testAdvice()` bean is used in this case.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-endpoints.adoc", "title": "java-endpoints", "heading": "java-endpoints", "heading_level": 1, "file_order": 36, "section_index": 0, "content_hash": "0f933031f0531a87a159cdda1d38150981ff336cba7a4fe3ad7086208b1739f3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-endpoints.adoc"}}
{"id": "sha256:f606b24bffa33b1775f4d0eb678df36d81e3616d46513fe57ac43e51ade5ab12", "content": "[[java-dsl-extensions]]\n\nStarting with version 5.3, an `IntegrationFlowExtension` has been introduced to allow extension of the existing Java DSL with custom or composed EIP-operators.\nAll that is needed is an extension of this class that provides methods which can be used in the `IntegrationFlow` bean definitions.\nThe extension class can also be used for custom `IntegrationComponentSpec` configuration; for example, missed or default options can be implemented in the existing `IntegrationComponentSpec` extension.\nThe sample below demonstrates a composite custom operator and usage of an `AggregatorSpec` extension for a default custom `outputProcessor`:\n\n[source,java]\n----\npublic class CustomIntegrationFlowDefinition\n extends IntegrationFlowExtension<CustomIntegrationFlowDefinition> {\n\n public CustomIntegrationFlowDefinition upperCaseAfterSplit() {\n return split()\n .transform(\"payload.toUpperCase()\");\n }\n\n public CustomIntegrationFlowDefinition customAggregate(Consumer<CustomAggregatorSpec> aggregator) {\n return register(new CustomAggregatorSpec(), aggregator);\n }\n\n}\n\npublic class CustomAggregatorSpec extends AggregatorSpec {\n\n CustomAggregatorSpec() {\n outputProcessor(group ->\n group.getMessages()\n .stream()\n .map(Message::getPayload)\n .map(String.class::cast)\n .collect(Collectors.joining(\", \")));\n }\n\n}\n----\n\nFor a method chain flow the new DSL operator in these extensions must return the extension class.\nThis way a target `IntegrationFlow` definition will work with new and existing DSL operators:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow customFlowDefinition() {\n return\n new CustomIntegrationFlowDefinition()\n .log()\n .upperCaseAfterSplit()\n .channel(\"innerChannel\")\n .customAggregate(customAggregatorSpec ->\n customAggregatorSpec.expireGroupsUponCompletion(true))\n .logAndReply();\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-extensions.adoc", "title": "java-extensions", "heading": "java-extensions", "heading_level": 1, "file_order": 37, "section_index": 0, "content_hash": "f606b24bffa33b1775f4d0eb678df36d81e3616d46513fe57ac43e51ade5ab12", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-extensions.adoc"}}
{"id": "sha256:e845e647a2bfc6a59695c61664c6dcfffe410a65f90532327cc96af5091d1eb7", "content": "[[java-dsl-flow-adapter]]\n\nThe `IntegrationFlow` interface can be implemented directly and specified as a component for scanning, as the following example shows:\n\n[source,java]\n----\n@Component\npublic class MyFlow implements IntegrationFlow {\n\n @Override\n public void configure(IntegrationFlowDefinition<?> f) {\n f.<String, String>transform(String::toUpperCase);\n }\n\n}\n----\n\nIt is picked up by the `IntegrationFlowBeanPostProcessor` and correctly parsed and registered in the application context.\n\nFor convenience and to gain the benefits of loosely coupled architecture, we provide the `IntegrationFlowAdapter` base class implementation.\nIt requires a `buildFlow()` method implementation to produce an `IntegrationFlowDefinition` by using one of `from()` methods, as the following example shows:\n\n[source,java]\n----\n@Component\npublic class MyFlowAdapter extends IntegrationFlowAdapter {\n\n private final AtomicBoolean invoked = new AtomicBoolean();\n\n public Instant nextExecutionTime(TriggerContext triggerContext) {\n return this.invoked.getAndSet(true) ? null : Instant.now();\n }\n\n @Override\n protected IntegrationFlowDefinition<?> buildFlow() {\n return fromSupplier(this::messageSource,\n e -> e.poller(p -> p.trigger(this::nextExecutionTime)))\n .split(this)\n .transform(this)\n .aggregate(this)\n .enrichHeaders(Collections.singletonMap(\"thing1\", \"THING1\"))\n .filter(this)\n .handle(this)\n .channel(c -> c.queue(\"myFlowAdapterOutput\"));\n }\n\n public String messageSource() {\n return \"T,H,I,N,G,2\";\n }\n\n @Splitter\n public String[] split(String payload) {\n return StringUtils.commaDelimitedListToStringArray(payload);\n }\n\n @Transformer\n public String transform(String payload) {\n return payload.toLowerCase();\n }\n\n @Aggregator\n public String aggregate(List<String> payloads) {\n return payloads.stream().collect(Collectors.joining());\n }\n\n @Filter\n public boolean filter(@Header Optional<String> thing1) {\n return thing1.isPresent();\n }\n\n @ServiceActivator\n public String handle(String payload, @Header String thing1) {\n return payload + \":\" + thing1;\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-flow-adapter.adoc", "title": "java-flow-adapter", "heading": "java-flow-adapter", "heading_level": 1, "file_order": 38, "section_index": 0, "content_hash": "e845e647a2bfc6a59695c61664c6dcfffe410a65f90532327cc96af5091d1eb7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-flow-adapter.adoc"}}
{"id": "sha256:c489a3e4bf5a596b215ac3ef7d9e7d4dd15ae91b997f25847b996189b8b1a0fc", "content": "[[java-dsl-flows]]\n\n`IntegrationFlowBuilder` provides a top-level API to produce integration components wired to message flows.\nWhen your integration may be accomplished with a single flow, (which is often the case), this is convenient.\nAlternately `IntegrationFlow` instances can be joined via `MessageChannel` instances.\n\nBy default, `MessageFlow` behaves as a \"`chain`\" in Spring Integration parlance.\nThat is, the endpoints are automatically and implicitly wired by `DirectChannel` instances.\nThe message flow is not actually constructed as a chain, which offers much more flexibility.\nFor example, you may send a message to any component within the flow, if you know its `inputChannel` name (that is, if you explicitly define it).\nYou may also reference externally defined channels within a flow to allow the use of channel adapters (to enable remote transport protocols, file I/O, and so on), instead of direct channels.\nAs such, the DSL does not support the Spring Integration `chain` element, because it does not add much value in this case.\n\nSince the Spring Integration Java DSL produces the same bean definition model as any other configuration options and is based on the existing Spring Framework `@Configuration` infrastructure, it can be used together with XML definitions and wired with Spring Integration messaging annotation configuration.\n\nYou can also define direct `IntegrationFlow` instances by using a lambda.\nThe following example shows how to do so:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow lambdaFlow() {\n return f -> f.filter(\"World\"::equals)\n .transform(\"Hello \"::concat)\n .handle(System.out::println);\n}\n----\n\nThe result of this definition is the same set of integration components that are wired with an implicit direct channel.\nThe only limitation here is that this flow is started with a named direct channel - `lambdaFlow.input`.\nAlso, a Lambda flow cannot start from `MessageSource` or `MessageProducer`.\n\nStarting with version 5.1, this kind of `IntegrationFlow` is wrapped to the proxy to expose lifecycle control and provide access to the `inputChannel` of the internally associated `StandardIntegrationFlow`.\n\nStarting with version 5.0.6, the generated bean names for the components in an `IntegrationFlow` include the flow bean followed by a dot (`.`) as a prefix.\nFor example, the `ConsumerEndpointFactoryBean` for the `.transform(\"Hello \"::concat)` in the preceding sample results in a bean name of `lambdaFlow.o.s.i.config.ConsumerEndpointFactoryBean#0`.\n(The `o.s.i` is a shortened from `org.springframework.integration` to fit on the page.)\nThe `Transformer` implementation bean for that endpoint has a bean name of `lambdaFlow.transformer#0` (starting with version 5.1), where instead of a fully qualified name of the `MethodInvokingTransformer` class, its component type is used.\nThe same pattern is applied for all the ``NamedComponent``s when the bean name has to be generated within the flow.\nThese generated bean names are prepended with the flow ID for purposes such as parsing logs or grouping components together in some analysis tool, as well as to avoid a race condition when we concurrently register integration flows at runtime.\nSee xref:dsl/java-runtime-flows.adoc[Dynamic and Runtime Integration Flows] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-flows.adoc", "title": "java-flows", "heading": "java-flows", "heading_level": 1, "file_order": 39, "section_index": 0, "content_hash": "c489a3e4bf5a596b215ac3ef7d9e7d4dd15ae91b997f25847b996189b8b1a0fc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-flows.adoc"}}
{"id": "sha256:80ec38a053f75d6a6d5b62d6eb50b697d1ddf44d7b42c524f008a5431e740be9", "content": "[[java-dsl-function-expression]]\n\nWe introduced the `FunctionExpression` class (an implementation of SpEL's `Expression` interface) to let us use lambdas and `generics`.\nThe `Function<T, R>` option is provided for the DSL components, along with an `expression` option, when there is the implicit `Strategy` variant from Core Spring Integration.\nThe following example shows how to use a function expression:\n\n[source,java]\n----\n.enrich(e -> e.requestChannel(\"enrichChannel\")\n .requestPayload(Message::getPayload)\n .propertyFunction(\"date\", m -> new Date()))\n----\n\nThe `FunctionExpression` also supports runtime type conversion, as is done in `SpelExpression`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-function-expression.adoc", "title": "java-function-expression", "heading": "java-function-expression", "heading_level": 1, "file_order": 40, "section_index": 0, "content_hash": "80ec38a053f75d6a6d5b62d6eb50b697d1ddf44d7b42c524f008a5431e740be9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-function-expression.adoc"}}
{"id": "sha256:eed6391ec5b1d4cf1f8faffad7b3850130dca926be86238c1b1c9836a0fa5425", "content": "[[java-dsl-gateway]]\n\nThe `gateway()` operator in an `IntegrationFlow` definition is a special service activator implementation, to call some other endpoint or integration flow via its input channel and wait for reply.\nTechnically it plays the same role as a nested `<gateway>` component in a `<chain>` definition (see xref:chain.adoc#chain-gateway[Calling a Chain from within a Chain]) and allows a flow to be cleaner and more straightforward.\nLogically, and from business perspective, it is a messaging gateway to allow the distribution and reuse of functionality between different parts of the target integration solution (see xref:gateway.adoc[Messaging Gateways]).\nThis operator has several overloads for different goals:\n\n- `gateway(String requestChannel)` to send a message to some endpoint's input channel by its name;\n- `gateway(MessageChannel requestChannel)` to send a message to some endpoint's input channel by its direct injection;\n- `gateway(IntegrationFlow flow)` to send a message to the input channel of the provided `IntegrationFlow`.\n\nAll of these have a variant with the second `Consumer<GatewayEndpointSpec>` argument to configure the target `GatewayMessageHandler` and respective `AbstractEndpoint`.\nAlso, the `IntegrationFlow`-based methods allows calling existing `IntegrationFlow` bean or declare the flow as a sub-flow via an in-place lambda for an `IntegrationFlow` functional interface or have it extracted in a `private` method cleaner code style:\n\n[source,java]\n----\n@Bean\nIntegrationFlow someFlow() {\n return IntegrationFlow\n .from(...)\n .gateway(subFlow())\n .handle(...)\n .get();\n}\n\nprivate static IntegrationFlow subFlow() {\n return f -> f\n .scatterGather(s -> s.recipientFlow(...),\n g -> g.outputProcessor(MessageGroup::getOne))\n}\n----\n\nIMPORTANT: If the downstream flow does not always return a reply, you should set the `requestTimeout` to 0 to prevent hanging the calling thread indefinitely.\nIn that case, the flow will end at that point and the thread released for further work.\n\nStarting with version 6.5, this `gateway()` operator fully supports an `async(true)` behaviour.\nInternally, an `AsyncRequestReplyExchanger` service interface is provided for the `GatewayProxyFactoryBean`.\nAnd since `AsyncRequestReplyExchanger` contract is a `CompletableFuture<Message<?>>`, the whole request-reply is executed in asynchronous manner.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-gateway.adoc", "title": "java-gateway", "heading": "java-gateway", "heading_level": 1, "file_order": 41, "section_index": 0, "content_hash": "eed6391ec5b1d4cf1f8faffad7b3850130dca926be86238c1b1c9836a0fa5425", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-gateway.adoc"}}
{"id": "sha256:69ce4f451294d29535688a97c5404c151631250572e789f35f4840722540d3f0", "content": "[[java-dsl-handle]]\n\nThe `.handle()` EIP method's goal is to invoke any `MessageHandler` implementation or any method on some POJO.\nAnother option is to define an \"`activity`\" by using lambda expressions.\nConsequently, we introduced a generic `GenericHandler<P>` functional interface.\nIts `handle` method requires two arguments: `P payload` and `MessageHeaders headers` (starting with version 5.1).\nHaving that, we can define a flow as follows:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow myFlow() {\n return IntegrationFlow.from(\"flow3Input\")\n .<Integer>handle((p, h) -> p * 2)\n .get();\n}\n----\n\nThe preceding example doubles any integer it receives.\n\nHowever, one main goal of Spring Integration is `loose coupling`, through runtime type conversion from message payload to the target arguments of the message handler.\nSince Java does not support generic type resolution for lambda classes, we introduced a workaround with an additional `payloadType` argument for the most EIP methods and `LambdaMessageProcessor`.\nDoing so delegates the hard conversion work to Spring's `ConversionService`, which uses the provided `type` and the requested message to target method arguments.\nThe following example shows what the resulting `IntegrationFlow` might look like:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow integerFlow() {\n return IntegrationFlow.from(\"input\")\n .<byte[], String>transform(p - > new String(p, \"UTF-8\"))\n .handle(Integer.class, (p, h) -> p * 2)\n .get();\n}\n----\n\nWe also can register some `BytesToIntegerConverter` within `ConversionService` to get rid of that additional `.transform()`:\n\n[source,java]\n----\n@Bean\n@IntegrationConverter\npublic BytesToIntegerConverter bytesToIntegerConverter() {\n return new BytesToIntegerConverter();\n}\n\n@Bean\npublic IntegrationFlow integerFlow() {\n return IntegrationFlow.from(\"input\")\n .handle(Integer.class, (p, h) -> p * 2)\n .get();\n}\n----\n\nAlso see xref:dsl/java-basics.adoc#java-dsl-class-cast[Lambdas And `Message<?>` Arguments].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-handle.adoc", "title": "java-handle", "heading": "java-handle", "heading_level": 1, "file_order": 42, "section_index": 0, "content_hash": "69ce4f451294d29535688a97c5404c151631250572e789f35f4840722540d3f0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-handle.adoc"}}
{"id": "sha256:e9ec61b8b32229672e6c33f8d281233628af7c01d64f4f3a9b6ee4eb2d45a94c", "content": "[[java-dsl-inbound-adapters]]\n\nTypically, message flows start from an inbound channel adapter (such as `<int-jdbc:inbound-channel-adapter>`).\nThe adapter is configured with `<poller>`, and it asks a `MessageSource<?>` to periodically produce messages.\nJava DSL allows for starting `IntegrationFlow` from a `MessageSource<?>`, too.\nFor this purpose, the `IntegrationFlow` fluent API provides an overloaded `IntegrationFlow.from(MessageSource<?> messageSource)` method.\nYou can configure the `MessageSource<?>` as a bean and provide it as an argument for that method.\nThe second parameter of `IntegrationFlow.from()` is a `Consumer<SourcePollingChannelAdapterSpec>` lambda that lets you provide options (such as `PollerMetadata` or `SmartLifecycle`) for the `SourcePollingChannelAdapter`.\nThe following example shows how to use the fluent API and a lambda to create an `IntegrationFlow`:\n\n[source,java]\n----\n@Bean\npublic MessageSource<Object> jdbcMessageSource() {\n return new JdbcPollingChannelAdapter(this.dataSource, \"SELECT * FROM something\");\n}\n\n@Bean\npublic IntegrationFlow pollingFlow() {\n return IntegrationFlow.from(jdbcMessageSource(),\n c -> c.poller(Pollers.fixedRate(100).maxMessagesPerPoll(1)))\n .transform(Transformers.toJson())\n .channel(\"furtherProcessChannel\")\n .get();\n}\n----\n\nFor those cases that have no requirements to build `Message` objects directly, you can use a `IntegrationFlow.fromSupplier()` variant that is based on the `java.util.function.Supplier` .\nThe result of the `Supplier.get()` is automatically wrapped in a `Message` (if it is not already a `Message`).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-inbound-adapters.adoc", "title": "java-inbound-adapters", "heading": "java-inbound-adapters", "heading_level": 1, "file_order": 43, "section_index": 0, "content_hash": "e9ec61b8b32229672e6c33f8d281233628af7c01d64f4f3a9b6ee4eb2d45a94c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-inbound-adapters.adoc"}}
{"id": "sha256:0a5cb13904d2b1538e20a1f5825ca140a2428244ee93f2456e457be1ab208d14", "content": "[[java-dsl-intercept]]\n\nStarting with version 5.3, the `intercept()` operator allows registering one or more `ChannelInterceptor` instances at the current `MessageChannel` in the flow.\nThis is an alternative to creating an explicit `MessageChannel` via the `MessageChannels` API.\nThe following example uses a `MessageSelectingInterceptor` to reject certain messages with an exception:\n\n[source,java]\n----\n.transform(...)\n.intercept(new MessageSelectingInterceptor(m -> m.getPayload().isValid()))\n.handle(...)\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-intercept.adoc", "title": "java-intercept", "heading": "java-intercept", "heading_level": 1, "file_order": 44, "section_index": 0, "content_hash": "0a5cb13904d2b1538e20a1f5825ca140a2428244ee93f2456e457be1ab208d14", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-intercept.adoc"}}
{"id": "sha256:055dbae7bd6e0c2ea187c7f71137a1867ff777054cb85d60212ce152a8bd4e46", "content": "[[java-dsl-log]]\n\nFor convenience, to log the message journey through the Spring Integration flow (`<logging-channel-adapter>`), a `log()` operator is presented.\nInternally, it is represented by the `WireTap` `ChannelInterceptor` with a `LoggingHandler` as its subscriber.\nIt is responsible for logging the incoming message into the next endpoint or the current channel.\nThe following example shows how to use `LoggingHandler`:\n\n[source,java]\n----\n.filter(...)\n.log(LoggingHandler.Level.ERROR, \"test.category\", m -> m.getHeaders().getId())\n.route(...)\n----\n\nIn the preceding example, an `id` header is logged at the `ERROR` level onto `test.category` only for messages that passed the filter and before routing.\n\nStarting with version 6.0, the behavior of this operator at the end of the flow is aligned with its usage in the middle.\nIn other words the behavior of the flow remains the same even if the `log()` operator is removed.\nSo, if a reply is not expected to be produced in the end of the flow, the `nullChannel()` is recommended to be used after the last `log()`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-log.adoc", "title": "java-log", "heading": "java-log", "heading_level": 1, "file_order": 45, "section_index": 0, "content_hash": "055dbae7bd6e0c2ea187c7f71137a1867ff777054cb85d60212ce152a8bd4e46", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-log.adoc"}}
{"id": "sha256:2c08beb08b962f4743a2899fd9a52b1deecc21ee5c8cc1355961efe0d8c48c78", "content": "[[java-dsl-pollers]]\n\nSpring Integration also provides a fluent API that lets you configure `PollerMetadata` for `AbstractPollingEndpoint` implementations.\nYou can use the `Pollers` builder factory to configure common bean definitions or those created from `IntegrationFlowBuilder` EIP methods, as the following example shows:\n\n[source,java]\n----\n@Bean(name = PollerMetadata.DEFAULT_POLLER)\npublic PollerSpec poller() {\n return Pollers.fixedRate(500)\n .errorChannel(\"myErrors\");\n}\n----\n\nSee https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/Pollers.html[`Pollers`] and https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/PollerSpec.html[`PollerSpec`] in the Javadoc for more information.\n\nIMPORTANT: If you use the DSL to construct a `PollerSpec` as a `@Bean`, do not call the `getObject()` method in the bean definition.\nThe `PollerSpec` is a `FactoryBean` that generates the `PollerMetadata` object from the specification and initializes all of its properties.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-pollers.adoc", "title": "java-pollers", "heading": "java-pollers", "heading_level": 1, "file_order": 46, "section_index": 0, "content_hash": "2c08beb08b962f4743a2899fd9a52b1deecc21ee5c8cc1355961efe0d8c48c78", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-pollers.adoc"}}
{"id": "sha256:6e6181637d0cfd3d2d4a2bd0ad214c637191c864877031ce3778e951a171c043", "content": "[[java-dsl-protocol-adapters]]\n\nAll the examples shown so far illustrate how the DSL supports a messaging architecture by using the Spring Integration programming model.\nHowever, we have yet to do any real integration.\nDoing so requires access to remote resources over HTTP, JMS, AMQP, TCP, JDBC, FTP, SMTP, and so on or access to the local file system.\nSpring Integration supports all of these and more.\nIdeally, the DSL should offer first-class support for all of them, but it is a daunting task to implement all of these and keep up as new adapters are added to Spring Integration.\nSo the expectation is that the DSL is continually catching up with Spring Integration.\n\nConsequently, we provide the high-level API to seamlessly define protocol-specific messaging.\nWe do so with the factory and builder patterns and with lambdas.\nYou can think of the factory classes as \"`Namespace Factories`\" because they play the same role as the XML namespace for components from the concrete protocol-specific Spring Integration modules.\nCurrently, Spring Integration Java DSL supports the `Amqp`, `Feed`, `Jms`, `Files`, `(S)Ftp`, `Http`, `JPA`, `MongoDb`, `TCP/UDP`, `Mail`, `WebFlux`, and `Scripts` namespace factories.\nThe following example shows how to use three of them (`Amqp`, `Jms`, and `Mail`):\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow amqpFlow() {\n return IntegrationFlow.from(Amqp.inboundGateway(this.rabbitConnectionFactory, queue()))\n .transform(\"hello \"::concat)\n .transform(String.class, String::toUpperCase)\n .get();\n}\n\n@Bean\npublic IntegrationFlow jmsOutboundGatewayFlow() {\n return IntegrationFlow.from(\"jmsOutboundGatewayChannel\")\n .handle(Jms.outboundGateway(this.jmsConnectionFactory)\n .replyContainer(c ->\n c.concurrentConsumers(3)\n .sessionTransacted(true))\n .requestDestination(\"jmsPipelineTest\"))\n .get();\n}\n\n@Bean\npublic IntegrationFlow sendMailFlow() {\n return IntegrationFlow.from(\"sendMailChannel\")\n .handle(Mail.outboundAdapter(\"localhost\")\n .port(smtpPort)\n .credentials(\"user\", \"pw\")\n .protocol(\"smtp\")\n .javaMailProperties(p -> p.put(\"mail.debug\", \"true\")),\n e -> e.id(\"sendMailEndpoint\"))\n .get();\n}\n----\n\nThe preceding example shows how to use the \"`namespace factories`\" as inline adapters declarations.\nHowever, you can use them from `@Bean` definitions to make the `IntegrationFlow` method chain more readable.\n\nNOTE: We are soliciting community feedback on these namespace factories before we spend effort on others.\nWe also appreciate any input into prioritization for which adapters and gateways we should support next.\n\nYou can find more Java DSL samples in the protocol-specific chapters throughout this reference manual.\n\nAll other protocol channel adapters may be configured as generic beans and wired to the `IntegrationFlow`, as the following examples show:\n\n[source,java]\n----\n@Bean\npublic QueueChannelSpec wrongMessagesChannel() {\n return MessageChannels\n .queue()\n .wireTap(\"wrongMessagesWireTapChannel\");\n}\n\n@Bean\npublic IntegrationFlow xpathFlow(MessageChannel wrongMessagesChannel) {\n return IntegrationFlow.from(\"inputChannel\")\n .filter(new StringValueTestXPathMessageSelector(\"namespace-uri(/*)\", \"my:namespace\"),\n e -> e.discardChannel(wrongMessagesChannel))\n .log(LoggingHandler.Level.ERROR, \"test.category\", m -> m.getHeaders().getId())\n .route(xpathRouter(wrongMessagesChannel))\n .get();\n}\n\n@Bean\npublic AbstractMappingMessageRouter xpathRouter(MessageChannel wrongMessagesChannel) {\n XPathRouter router = new XPathRouter(\"local-name(/*)\");\n router.setEvaluateAsString(true);\n router.setResolutionRequired(false);\n router.setDefaultOutputChannel(wrongMessagesChannel);\n router.setChannelMapping(\"Tags\", \"splittingChannel\");\n router.setChannelMapping(\"Tag\", \"receivedChannel\");\n return router;\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-protocol-adapters.adoc", "title": "java-protocol-adapters", "heading": "java-protocol-adapters", "heading_level": 1, "file_order": 47, "section_index": 0, "content_hash": "6e6181637d0cfd3d2d4a2bd0ad214c637191c864877031ce3778e951a171c043", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-protocol-adapters.adoc"}}
{"id": "sha256:a44e67b9c1b0d6dd70e99e707de397b8ecc2ac15d77390acb7e0dec0c96ebed8", "content": "[[java-dsl-reactive]]\n\nStarting with version 5.5, the `ConsumerEndpointSpec` provides a `reactive()` configuration property with an optional customizer `Function<? super Flux<Message<?>>, ? extends Publisher<Message<?>>>`.\nThis option configures the target endpoint as a `ReactiveStreamsConsumer` instance, independently of the input channel type, which is converted to a `Flux` via `IntegrationReactiveUtils.messageChannelToFlux()`.\nThe provided function is used from the `Flux.transform()` operator to customize (`publishOn()`, `log()`, `doOnNext()` etc.) a reactive stream source from the input channel.\n\nThe following example demonstrates how to change the publishing thread from the input channel independently of the final subscriber and producer to that `DirectChannel`:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow reactiveEndpointFlow() {\n return IntegrationFlow\n .from(\"inputChannel\")\n .transformWith(t -> t\n .<String, Integer>transformer(Integer::parseInt)\n .reactive(flux -> flux.publishOn(Schedulers.parallel()))\n )\n .get();\n}\n----\n\nSee xref:reactive-streams.adoc[Reactive Streams Support] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-reactive.adoc", "title": "java-reactive", "heading": "java-reactive", "heading_level": 1, "file_order": 48, "section_index": 0, "content_hash": "a44e67b9c1b0d6dd70e99e707de397b8ecc2ac15d77390acb7e0dec0c96ebed8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-reactive.adoc"}}
{"id": "sha256:1ef395111fcf575401bdd382dd26b71d5d0225901f8c4f6be2d170f1d4203f35", "content": "[[java-dsl-routers]]\n\nSpring Integration natively provides specialized router types, including:\n\n* `HeaderValueRouter`\n* `PayloadTypeRouter`\n* `ExceptionTypeRouter`\n* `RecipientListRouter`\n* `XPathRouter`\n\nAs with many other DSL `IntegrationFlowBuilder` EIP methods, the `route()` method can apply any `AbstractMessageRouter` implementation or, for convenience, a `String` as a SpEL expression or a `ref`-`method` pair.\nIn addition, you can configure `route()` with a lambda and use a lambda for a `Consumer<RouterSpec<MethodInvokingRouter>>`.\nThe fluent API also provides `AbstractMappingMessageRouter` options such as `channelMapping(String key, String channelName)` pairs, as the following example shows:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow routeFlowByLambda() {\n return IntegrationFlow.from(\"routerInput\")\n .<Integer, Boolean>route(p -> p % 2 == 0,\n m -> m.suffix(\"Channel\")\n .channelMapping(true, \"even\")\n .channelMapping(false, \"odd\")\n )\n .get();\n}\n----\n\nThe following example shows a simple expression-based router:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow routeFlowByExpression() {\n return IntegrationFlow.from(\"routerInput\")\n .route(\"headers['destChannel']\")\n .get();\n}\n----\n\nThe `routeToRecipients()` method takes a `Consumer<RecipientListRouterSpec>`, as the following example shows:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow recipientListFlow() {\n return IntegrationFlow.from(\"recipientListInput\")\n .<String, String>transform(p -> p.replaceFirst(\"Payload\", \"\"))\n .routeToRecipients(r -> r\n .recipient(\"thing1-channel\", \"'thing1' == payload\")\n .recipientMessageSelector(\"thing2-channel\", m ->\n m.getHeaders().containsKey(\"recipient\")\n && (boolean) m.getHeaders().get(\"recipient\"))\n .recipientFlow(\"'thing1' == payload or 'thing2' == payload or 'thing3' == payload\",\n f -> f.<String, String>transform(String::toUpperCase)\n .channel(c -> c.queue(\"recipientListSubFlow1Result\")))\n .recipientFlow((String p) -> p.startsWith(\"thing3\"),\n f -> f.transform(\"Hello \"::concat)\n .channel(c -> c.queue(\"recipientListSubFlow2Result\")))\n .recipientFlow(new FunctionExpression<Message<?>>(m ->\n \"thing3\".equals(m.getPayload())),\n f -> f.channel(c -> c.queue(\"recipientListSubFlow3Result\")))\n .defaultOutputToParentFlow())\n .get();\n}\n----\n\nThe `.defaultOutputToParentFlow()` of the `.routeToRecipients()` definition lets you set the router's `defaultOutput` as a gateway to continue a process for the unmatched messages in the main flow.\n\nAlso see xref:dsl/java-basics.adoc#java-dsl-class-cast[Lambdas And `Message<?>` Arguments].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-routers.adoc", "title": "java-routers", "heading": "java-routers", "heading_level": 1, "file_order": 49, "section_index": 0, "content_hash": "1ef395111fcf575401bdd382dd26b71d5d0225901f8c4f6be2d170f1d4203f35", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-routers.adoc"}}
{"id": "sha256:f66dc080528083bf2b745a63ef2ef68869bdffebd2af7c3ee12d59ead75a5b72", "content": "[[java-dsl-runtime-flows]]\n\n`IntegrationFlow` and all its dependent components can be registered at runtime.\nBefore version 5.0, we used the `BeanFactory.registerSingleton()` hook.\nStarting in the Spring Framework `5.0`, we use the `instanceSupplier` hook for programmatic `BeanDefinition` registration.\nThe following example shows how to programmatically register a bean:\n\n[source,java]\n----\nBeanDefinition beanDefinition =\n BeanDefinitionBuilder.genericBeanDefinition((Class<Object>) bean.getClass(), () -> bean)\n .getRawBeanDefinition();\n\n((BeanDefinitionRegistry) this.beanFactory).registerBeanDefinition(beanName, beanDefinition);\n----\n\nNote that, in the preceding example, the `instanceSupplier` hook is the last parameter to the `genericBeanDefinition` method, provided by a lambda in this case.\n\nAll the necessary bean initialization and lifecycle is done automatically, as it is with the standard context configuration bean definitions.\n\nTo simplify the development experience, Spring Integration introduced `IntegrationFlowContext` to register and manage `IntegrationFlow` instances at runtime, as the following example shows:\n\n[source,java]\n----\n@Autowired\nprivate AbstractServerConnectionFactory server1;\n\n@Autowired\nprivate IntegrationFlowContext flowContext;\n\n...\n\n@Test\npublic void testTcpGateways() {\n TestingUtilities.waitListening(this.server1, null);\n\n IntegrationFlow flow = f -> f\n .handle(Tcp.outboundGateway(Tcp.netClient(\"localhost\", this.server1.getPort())\n .serializer(TcpCodecs.crlf())\n .deserializer(TcpCodecs.lengthHeader1())\n .id(\"client1\"))\n .remoteTimeout(m -> 5000))\n .transform(Transformers.objectToString());\n\n IntegrationFlowRegistration theFlow = this.flowContext.registration(flow).register();\n assertThat(theFlow.getMessagingTemplate().convertSendAndReceive(\"foo\", String.class), equalTo(\"FOO\"));\n}\n----\n\nThis is useful when we have multiple configuration options and have to create several instances of similar flows.\nTo do so, we can iterate our options and create and register `IntegrationFlow` instances within a loop.\nAnother variant is when our source of data is not Spring-based, so we must create it on the fly.\nSuch a sample is the Reactive Streams event source, as the following example shows:\n\n[source,java]\n----\nFlux<Message<?>> messageFlux =\n Flux.just(\"1,2,3,4\")\n .map(v -> v.split(\",\"))\n .flatMapIterable(Arrays::asList)\n .map(Integer::parseInt)\n .map(GenericMessage<Integer>::new);\n\nQueueChannel resultChannel = new QueueChannel();\n\nIntegrationFlow integrationFlow =\n IntegrationFlow.from(messageFlux)\n .<Integer, Integer>transform(p -> p * 2)\n .channel(resultChannel)\n .get();\n\nthis.integrationFlowContext.registration(integrationFlow)\n .register();\n----\n\nThe `IntegrationFlowRegistrationBuilder` (as a result of the `IntegrationFlowContext.registration()`) can be used to specify a bean name for the `IntegrationFlow` to register, to control its `autoStartup`, and to register, non-Spring Integration beans.\nUsually, those additional beans are connection factories (AMQP, JMS, (S)FTP, TCP/UDP, and others.), serializers and deserializers, or any other required support components.\n\nYou can use the `IntegrationFlowRegistration.destroy()` callback to remove a dynamically registered `IntegrationFlow` and all its dependent beans when you no longer need them.\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/context/IntegrationFlowContext.html[`IntegrationFlowContext` Javadoc] for more information.\n\nNOTE: Starting with version 5.0.6, all generated bean names in an `IntegrationFlow` definition are prepended with the flow ID as a prefix.\nWe recommend always specifying an explicit flow ID.\nOtherwise, a synchronization barrier is initiated in the `IntegrationFlowContext`, to generate the bean name for the `IntegrationFlow` and register its beans.\nWe synchronize on these two operations to avoid a race condition when the same generated bean name may be used for different `IntegrationFlow` instances.\n\nAlso, starting with version 5.0.6, the registration builder API has a new method: `useFlowIdAsPrefix()`.\nThis is useful if you wish to declare multiple instances of the same flow and avoid bean name collisions when components in the flows have the same ID, as the following example shows:\n\n[source, java]\n----\nprivate void registerFlows() {\n IntegrationFlowRegistration flow1 =\n this.flowContext.registration(buildFlow(1234))\n .id(\"tcp1\")\n .useFlowIdAsPrefix()\n .register();\n\n IntegrationFlowRegistration flow2 =\n this.flowContext.registration(buildFlow(1235))\n .id(\"tcp2\")\n .useFlowIdAsPrefix()\n .register();\n}\n\nprivate IntegrationFlow buildFlow(int port) {\n return f -> f\n .handle(Tcp.outboundGateway(Tcp.netClient(\"localhost\", port)\n .serializer(TcpCodecs.crlf())\n .deserializer(TcpCodecs.lengthHeader1())\n .id(\"client\"))\n .remoteTimeout(m -> 5000))\n .transform(Transformers.objectToString());\n}\n----\n\nIn this case, the message handler for the first flow can be referenced with bean a name of `tcp1.client.handler`.\n\nNOTE: An `id` attribute is required when you usE `useFlowIdAsPrefix()`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-runtime-flows.adoc", "title": "java-runtime-flows", "heading": "java-runtime-flows", "heading_level": 1, "file_order": 50, "section_index": 0, "content_hash": "f66dc080528083bf2b745a63ef2ef68869bdffebd2af7c3ee12d59ead75a5b72", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-runtime-flows.adoc"}}
{"id": "sha256:0220ec75f28628481b3e5f2acf2f9fd432fbc529fc664147635093a6800db88e", "content": "[[java-dsl-splitters]]\n\nTo create a splitter, use the `split()` EIP method.\nBy default, if the payload is an `Iterable`, an `Iterator`, an `Array`, a `Stream`, or a reactive `Publisher`, the `split()` method outputs each item as an individual message.\nIt accepts a lambda, a SpEL expression, or any `AbstractMessageSplitter` implementation.\nAlternatively, you can use it without parameters to provide the `DefaultMessageSplitter`.\nThe following example shows how to use the `splitWith()` method by providing a lambda:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow splitFlow() {\n return IntegrationFlow.from(\"splitInput\")\n .splitWith(s -> s.applySequence(false).delimiters(\",\"))\n .channel(MessageChannels.executor(taskExecutor()))\n .get();\n}\n----\n\nThe preceding example creates a splitter that splits a message containing a comma-delimited `String`.\n\nAlso see xref:dsl/java-basics.adoc#java-dsl-class-cast[Lambdas And `Message<?>` Arguments].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-splitters.adoc", "title": "java-splitters", "heading": "java-splitters", "heading_level": 1, "file_order": 51, "section_index": 0, "content_hash": "0220ec75f28628481b3e5f2acf2f9fd432fbc529fc664147635093a6800db88e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-splitters.adoc"}}
{"id": "sha256:1d07ff211772d69737986613d1899ca8e0b2b3106a7b3f244519191644b9f45b", "content": "[[java-dsl-subflows]]\n\nSome of `if...else` and `publish-subscribe` components provide the ability to specify their logic or mapping by using sub-flows.\nThe simplest sample is `.publishSubscribeChannel()`, as the following example shows:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow subscribersFlow() {\n return flow -> flow\n .publishSubscribeChannel(Executors.newCachedThreadPool(), s -> s\n .subscribe(f -> f\n .<Integer>handle((p, h) -> p / 2)\n .channel(c -> c.queue(\"subscriber1Results\")))\n .subscribe(f -> f\n .<Integer>handle((p, h) -> p * 2)\n .channel(c -> c.queue(\"subscriber2Results\"))))\n .<Integer>handle((p, h) -> p * 3)\n .channel(c -> c.queue(\"subscriber3Results\"));\n}\n----\n\nYou can achieve the same result with separate `IntegrationFlow` `@Bean` definitions, but we hope you find the sub-flow style of logic composition useful.\nWe find that it results in shorter (and so more readable) code.\n\nStarting with version 5.3, a `BroadcastCapableChannel`-based `publishSubscribeChannel()` implementation is provided to configure sub-flow subscribers on broker-backed message channels.\nFor example, we now can configure several subscribers as sub-flows on the `Jms.publishSubscribeChannel()`:\n\n[source,java]\n----\n@Bean\npublic JmsPublishSubscribeMessageChannelSpec jmsPublishSubscribeChannel() {\n return Jms.publishSubscribeChannel(jmsConnectionFactory())\n .destination(\"pubsub\");\n}\n\n@Bean\npublic IntegrationFlow pubSubFlow(BroadcastCapableChannel jmsPublishSubscribeChannel) {\n return f -> f\n .publishSubscribeChannel(jmsPublishSubscribeChannel,\n pubsub -> pubsub\n .subscribe(subFlow -> subFlow\n .channel(c -> c.queue(\"jmsPubSubBridgeChannel1\")))\n .subscribe(subFlow -> subFlow\n .channel(c -> c.queue(\"jmsPubSubBridgeChannel2\"))));\n}\n----\n\nA similar `publish-subscribe` sub-flow composition provides the `.routeToRecipients()` method.\n\nAnother example is using `.discardFlow()` instead of `.discardChannel()` on the `.filter()` method.\n\nThe `.route()` deserves special attention.\nConsider the following example:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow routeFlow() {\n return f -> f\n .<Integer, Boolean>route(p -> p % 2 == 0,\n m -> m.channelMapping(\"true\", \"evenChannel\")\n .subFlowMapping(\"false\", sf ->\n sf.<Integer>handle((p, h) -> p * 3)))\n .transform(Object::toString)\n .channel(c -> c.queue(\"oddChannel\"));\n}\n----\n\nThe `.channelMapping()` continues to work as it does in regular `Router` mapping, but the `.subFlowMapping()` tied that sub-flow to the main flow.\nIn other words, any router's sub-flow returns to the main flow after `.route()`.\n\n[IMPORTANT]\n====\nSometimes, you need to refer to an existing `IntegrationFlow` `@Bean` from the `.subFlowMapping()`.\nThe following example shows how to do so:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow splitRouteAggregate() {\n return f -> f\n .split()\n .<Integer, Boolean>route(o -> o % 2 == 0,\n m -> m\n .subFlowMapping(true, oddFlow())\n .subFlowMapping(false, sf -> sf.gateway(evenFlow())))\n .aggregate();\n}\n\n@Bean\npublic IntegrationFlow oddFlow() {\n return f -> f.handle(m -> System.out.println(\"odd\"));\n}\n\n@Bean\npublic IntegrationFlow evenFlow() {\n return f -> f.handle((p, h) -> \"even\");\n}\n----\n\n{empty} +\nIn this case, when you need to receive a reply from such a sub-flow and continue the main flow, this `IntegrationFlow` bean reference (or its input channel) has to be wrapped with a `.gateway()` as shown in the preceding example.\nThe `oddFlow()` reference in the preceding example is not wrapped to the `.gateway()`.\nTherefore, we do not expect a reply from this routing branch.\nOtherwise, you end up with an exception similar to the following:\n\n....\nCaused by: org.springframework.beans.factory.BeanCreationException:\n The 'currentComponent' (org.springframework.integration.router.MethodInvokingRouter@7965a51c)\n is a one-way 'MessageHandler' and it isn't appropriate to configure 'outputChannel'.\n This is the end of the integration flow.\n....\n\nWhen you configure a sub-flow as a lambda, the framework handles the request-reply interaction with the sub-flow and a gateway is not needed.\n====\n\nSub-flows can be nested to any depth, but we do not recommend doing so.\nIn fact, even in the router case, adding complex sub-flows within a flow would quickly begin to look like a plate of spaghetti and be difficult for a human to parse.\n\n[NOTE]\n====\nIn cases where the DSL supports a subflow configuration, when a channel is normally needed for the component being configured, and that subflow starts with a `channel()` element, the framework implicitly places a `bridge()` between the component output channel and the flow's input channel.\nFor example, in this `filter` definition:\n\n[source,java]\n----\n.filter(p -> p instanceof String, e -> e\n\t.discardFlow(df -> df\n .channel(MessageChannels.queue())\n ...)\n----\nthe Framework internally creates a `DirectChannel` bean for injecting into the `MessageFilter.discardChannel`.\nThen it wraps the subflow into an `IntegrationFlow` starting with this implicit channel for the subscription and places a `bridge` before the `channel()` specified in the flow.\nWhen an existing `IntegrationFlow` bean is used as a subflow reference (instead of an inline subflow, e.g. a lambda), there is no such bridge required because the framework can resolve the first channel from the flow bean.\nWith an inline subflow, the input channel is not yet available.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-subflows.adoc", "title": "java-subflows", "heading": "java-subflows", "heading_level": 1, "file_order": 52, "section_index": 0, "content_hash": "1d07ff211772d69737986613d1899ca8e0b2b3106a7b3f244519191644b9f45b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-subflows.adoc"}}
{"id": "sha256:8a172c607efd87d3ba48f1f6069b2acb1c27e4a0e4544e5ec62e14a77cb4c745", "content": "[[java-dsl-transformers]]\n\nThe DSL API provides a convenient, fluent `Transformers` factory to be used as inline target object definition within the `.transform()` EIP method.\nThe following example shows how to use it:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow transformFlow() {\n return IntegrationFlow.from(\"input\")\n .transform(Transformers.fromJson(MyPojo.class))\n .transform(Transformers.serializer())\n .get();\n}\n----\n\nIt avoids inconvenient coding using setters and makes the flow definition more straightforward.\nNote that you can use `Transformers` to declare target `Transformer` instances as `@Bean` instances and, again, use them from `IntegrationFlow` definition as bean methods.\nNevertheless, the DSL parser takes care of bean declarations for inline objects if they are not yet defined as beans.\n\nSee https://docs.spring.io/spring-integration/api/org/springframework/integration/dsl/Transformers.html[Transformers] in the Javadoc for more information and supported factory methods.\n\nStarting with version 6.2, a `transformWith(Consumer<TransformerEndpointSpec>)` variant has been introduced to have all the transformer and its endpoint options to be configured via single builder argument.\nThis style gives DSL more readability and increases developer experience while modifying code.\nThis also makes Groovy and Kotlin DSLs more straightforward.\n\nAlso see xref:dsl/java-basics.adoc#java-dsl-class-cast[Lambdas And `Message<?>` Arguments].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-transformers.adoc", "title": "java-transformers", "heading": "java-transformers", "heading_level": 1, "file_order": 53, "section_index": 0, "content_hash": "8a172c607efd87d3ba48f1f6069b2acb1c27e4a0e4544e5ec62e14a77cb4c745", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-transformers.adoc"}}
{"id": "sha256:5f6d90a086651dfc313bb2ccb5f8a4fffe02b9d06b47704eb49a535c1851c93d", "content": "[[java-dsl-wiretap]]\n\nSpring Integration includes a `.wireTap()` fluent API `MessageChannelSpec` builders.\nThe following example shows how to use the `wireTap` method to log input:\n\n[source,java]\n----\n@Bean\npublic QueueChannelSpec myChannel() {\n return MessageChannels.queue()\n .wireTap(\"loggingFlow.input\");\n}\n\n@Bean\npublic IntegrationFlow loggingFlow() {\n return f -> f.log();\n}\n----\n\n[IMPORTANT]\n====\nIf the `MessageChannel` is an instance of `InterceptableChannel`, the `log()`, `wireTap()` or `intercept()` operators are applied to the current `MessageChannel`.\nOtherwise, an intermediate `DirectChannel` is injected into the flow for the currently configured endpoint.\nIn the following example, the `WireTap` interceptor is added to `myChannel` directly, because `DirectChannel` implements `InterceptableChannel`:\n\n[source,java]\n----\n@Bean\nMessageChannel myChannel() {\n return new DirectChannel();\n}\n\n...\n .channel(myChannel())\n .log()\n}\n----\n====\n\nWhen the current `MessageChannel` does not implement `InterceptableChannel`, an implicit `DirectChannel` and `BridgeHandler` are injected into the `IntegrationFlow`, and the `WireTap` is added to this new `DirectChannel`.\nThe following example does not have any channel declaration:\n\n[source,java]\n----\n.handle(...)\n.log()\n}\n----\n\nIn the preceding example (and any time no channel has been declared), an implicit `DirectChannel` is injected in the current position of the `IntegrationFlow` and used as an output channel for the currently configured `ServiceActivatingHandler` (from the `.handle()`, xref:dsl/java-handle.adoc[described earlier]).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl/java-wiretap.adoc", "title": "java-wiretap", "heading": "java-wiretap", "heading_level": 1, "file_order": 54, "section_index": 0, "content_hash": "5f6d90a086651dfc313bb2ccb5f8a4fffe02b9d06b47704eb49a535c1851c93d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl/java-wiretap.adoc"}}
{"id": "sha256:f76bd370bdbed766b188724b5aaa7522d7bc0c6bfa5118c9dff4fc37b527c35a", "content": "[[file-aggregator]]\n\nStarting with version 5.5, a `FileAggregator` is introduced to cover other side of `FileSplitter` use-case when START/END markers are enabled.\nFor convenience the `FileAggregator` implements all three sequence details strategies:\n\n- The `HeaderAttributeCorrelationStrategy` with the `FileHeaders.FILENAME` attribute is used for correlation key calculation.\nWhen markers are enabled on the `FileSplitter`, it does not populate sequence details headers, since START/END marker messages are also included into the sequence size.\nThe `FileHeaders.FILENAME` is still populated for each line emitted, including START/END marker messages.\n\n- The `FileMarkerReleaseStrategy` - checks for `FileSplitter.FileMarker.Mark.END` message in the group and then compare a `FileHeaders.LINE_COUNT` header value with the group size minus `2` - `FileSplitter.FileMarker` instances.\nIt also implements a convenient `GroupConditionProvider` contact for `conditionSupplier` function to be used in the `AbstractCorrelatingMessageHandler`.\nSee xref:message-store.adoc#message-group-condition[Message Group Condition] for more information.\n\n- The `FileAggregatingMessageGroupProcessor` just removes `FileSplitter.FileMarker` messages from the group and collect the rest of messages into a list payload to produce.\n\nThe following listing shows possible ways to configure a `FileAggregator`:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow fileSplitterAggregatorFlow(TaskExecutor taskExecutor) {\n return f -> f\n .split(Files.splitter()\n .markers()\n .firstLineAsHeader(\"firstLine\"))\n .channel(c -> c.executor(taskExecutor))\n .filter(payload -> !(payload instanceof FileSplitter.FileMarker),\n e -> e.discardChannel(\"aggregatorChannel\"))\n .<String, String>transform(String::toUpperCase)\n .channel(\"aggregatorChannel\")\n .aggregate(new FileAggregator())\n .channel(c -> c.queue(\"resultChannel\"));\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun fileSplitterAggregatorFlow(taskExecutor: TaskExecutor?) =\n integrationFlow {\n split(Files.splitter().markers().firstLineAsHeader(\"firstLine\"))\n channel { executor(taskExecutor) }\n filter<Any>({ it !is FileMarker }) { discardChannel(\"aggregatorChannel\") }\n transform(String::toUpperCase)\n channel(\"aggregatorChannel\")\n aggregate(FileAggregator())\n channel { queue(\"resultChannel\") }\n }\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@serviceActivator(inputChannel=\"toAggregateFile\")\n@Bean\npublic AggregatorFactoryBean fileAggregator() {\n AggregatorFactoryBean aggregator = new AggregatorFactoryBean();\n aggregator.setProcessorBean(new FileAggregator());\n aggregator.setOutputChannel(outputChannel);\n return aggregator;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:chain input-channel=\"input\" output-channel=\"output\">\n <int-file:splitter markers=\"true\"/>\n <int:aggregator>\n <bean class=\"org.springframework.integration.file.aggregator.FileAggregator\"/>\n </int:aggregator>\n</int:chain>\n----\n======\n\nIf default behavior of the `FileAggregator` does not satisfy the target logic, it is recommended to configure an aggregator endpoint with individual strategies.\nSee `FileAggregator` JavaDocs for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/aggregator.adoc", "title": "aggregator", "heading": "aggregator", "heading_level": 1, "file_order": 55, "section_index": 0, "content_hash": "f76bd370bdbed766b188724b5aaa7522d7bc0c6bfa5118c9dff4fc37b527c35a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/aggregator.adoc"}}
{"id": "sha256:05eb952cf075eb9385f5e9e25c3c63fd34c338113638f3c24030ea8aff075fb3", "content": "[[file-reading]]\n\nA `FileReadingMessageSource` can be used to consume files from the filesystem.\nThis is an implementation of `MessageSource` that creates messages from a file system directory.\nThe following example shows how to configure a `FileReadingMessageSource`:\n\n[source,xml]\n----\n<bean id=\"pollableFileSource\"\n class=\"org.springframework.integration.file.inbound.FileReadingMessageSource\"\n p:directory=\"${input.directory}\"/>\n----\n\nTo prevent creating messages for certain files, you can supply a `FileListFilter`.\nBy default, we use the following filters:\n\n* `IgnoreHiddenFileListFilter`\n* `AcceptOnceFileListFilter`\n\nThe `IgnoreHiddenFileListFilter` ensures that hidden files are not processed.\nNote that the exact definition of hidden is system-dependent.\nFor example, on UNIX-based systems, a file beginning with a period character is considered to be hidden.\nMicrosoft Windows, on the other hand, has a dedicated file attribute to indicate hidden files.\n\n[IMPORTANT]\n====\nVersion 4.2 introduced the `IgnoreHiddenFileListFilter`.\nIn prior versions, hidden files were included.\nWith the default configuration, the `IgnoreHiddenFileListFilter` is triggered first, followed by the `AcceptOnceFileListFilter`.\n====\n\nThe `AcceptOnceFileListFilter` ensures files are picked up only once from the directory.\n\n[NOTE]\n====\nThe `AcceptOnceFileListFilter` stores its state in memory.\nIf you wish the state to survive a system restart, you can use the `FileSystemPersistentAcceptOnceFileListFilter`.\nThis filter stores the accepted file names in a `MetadataStore` implementation (see xref:meta-data-store.adoc[Metadata Store]).\nThis filter matches on the filename and modified time.\n\nSince version 4.0, this filter requires a `ConcurrentMetadataStore`.\nWhen used with a shared data store (such as `Redis` with the `RedisMetadataStore`), it lets filter keys be shared across multiple application instances or across a network file share being used by multiple servers.\n\nSince version 4.1.5, this filter has a new property (`flushOnUpdate`), which causes it to flush the metadata store on every update (if the store implements `Flushable`).\n====\n\nThe persistent file list filters now have a boolean property `forRecursion`.\nSetting this property to `true`, also sets `alwaysAcceptDirectories`, which means that the recursive operation on the outbound gateways (`ls` and `mget`) will now always traverse the full directory tree each time.\nThis is to solve a problem where changes deep in the directory tree were not detected.\nIn addition, `forRecursion=true` causes the full path to files to be used as the metadata store keys; this solves a problem where the filter did not work properly if a file with the same name appears multiple times in different directories.\nIMPORTANT: This means that existing keys in a persistent metadata store will not be found for files beneath the top level directory.\nFor this reason, the property is `false` by default; this may change in a future release.\n\nThe following example configures a `FileReadingMessageSource` with a filter:\n\n[source,xml]\n----\n<bean id=\"pollableFileSource\"\n class=\"org.springframework.integration.file.inbound.FileReadingMessageSource\"\n p:inputDirectory=\"${input.directory}\"\n p:filter-ref=\"customFilterBean\"/>\n----\n\nA common problem with reading files is that a file may be detected before it is ready (that is, some other process may still be writing the file).\nThe default `AcceptOnceFileListFilter` does not prevent this.\nIn most cases, this can be prevented if the file-writing process renames each file as soon as it is ready for reading.\nA `filename-pattern` or `filename-regex` filter that accepts only files that are ready (perhaps based on a known suffix), composed with the default `AcceptOnceFileListFilter`, allows for this situation.\nThe `CompositeFileListFilter` enables the composition, as the following example shows:\n\n[source,xml]\n----\n<bean id=\"pollableFileSource\"\n class=\"org.springframework.integration.file.inbound.FileReadingMessageSource\"\n p:inputDirectory=\"${input.directory}\"\n p:filter-ref=\"compositeFilter\"/>\n\n<bean id=\"compositeFilter\"\n class=\"org.springframework.integration.file.filters.CompositeFileListFilter\">\n <constructor-arg>\n <list>\n <bean class=\"o.s.i.file.filters.AcceptOnceFileListFilter\"/>\n <bean class=\"o.s.i.file.filters.RegexPatternFileListFilter\">\n <constructor-arg value=\"^test.*$\"/>\n </bean>\n </list>\n </constructor-arg>\n</bean>\n----\n\nIf it is not possible to create the file with a temporary name and rename to the final name, Spring Integration provides another alternative.\nVersion 4.2 added the `LastModifiedFileListFilter`.\nThis filter can be configured with an `age` property so that only files older than this value are passed by the filter.\nThe age defaults to 60 seconds, but you should choose an age that is large enough to avoid picking up a file early (due to, say, network glitches).\nThe following example shows how to configure a `LastModifiedFileListFilter`:\n\n[source, xml]\n----\n<bean id=\"filter\" class=\"org.springframework.integration.file.filters.LastModifiedFileListFilter\">\n <property name=\"age\" value=\"120\" />\n</bean>\n----\n\nStarting with version 4.3.7, a `ChainFileListFilter` (an extension of `CompositeFileListFilter`) has been introduced to allow scenarios when subsequent filters should only see the result of the previous filter.\n(With the `CompositeFileListFilter`, all filters see all the files, but it passes only files that have passed all filters).\nAn example of where the new behavior is required is a combination of `LastModifiedFileListFilter` and `AcceptOnceFileListFilter`, when we do not wish to accept the file until some amount of time has elapsed.\nWith the `CompositeFileListFilter`, since the `AcceptOnceFileListFilter` sees all the files on the first pass, it does not pass it later when the other filter does.\nThe `CompositeFileListFilter` approach is useful when a pattern filter is combined with a custom filter that looks for a secondary file to indicate that file transfer is complete.\nThe pattern filter might only pass the primary file (such as `something.txt`) but the \"`done`\" filter needs to see whether (for example) `something.done` is present.\n\nSay we have files `a.txt`, `a.done`, and `b.txt`.\n\nThe pattern filter passes only `a.txt` and `b.txt`, while the \"`done`\" filter sees all three files and passes only `a.txt`.\nThe final result of the composite filter is that only `a.txt` is released.\n\nNOTE: With the `ChainFileListFilter`, if any filter in the chain returns an empty list, the remaining filters are not invoked.\n\nVersion 5.0 introduced an `ExpressionFileListFilter` to execute SpEL expression against a file as a context evaluation root object.\nFor this purpose, all the XML components for file handling (local and remote), along with an existing `filter` attribute, have been supplied with the `filter-expression` option, as the following example shows:\n\n[source, xml]\n----\n<int-file:inbound-channel-adapter\n directory=\"${inputdir}\"\n filter-expression=\"name matches '.text'\"\n auto-startup=\"false\"/>\n----\n\nVersion 5.0.5 introduced the `DiscardAwareFileListFilter` implementations that have an interest in rejected files.\nFor this purpose, such a filter implementation should be supplied with a callback through `addDiscardCallback(Consumer<File>)`.\nIn the framework, this functionality is used from the `FileReadingMessageSource.WatchServiceDirectoryScanner`, in combination with `LastModifiedFileListFilter`.\nUnlike the regular `DirectoryScanner`, the `WatchService` provides files for processing, according to the events on the target file system.\nAt the moment of polling an internal queue with those files, the `LastModifiedFileListFilter` may discard them because they are too young relative to its configured `age`.\nTherefore, we lose the file for future possible considerations.\nThe discard callback hook lets us retain the file in the internal queue so that it is available to be checked against the `age` in subsequent polls.\nThe `CompositeFileListFilter` also implements a `DiscardAwareFileListFilter` and populates a discard callback to all its `DiscardAwareFileListFilter` delegates.\n\nNOTE: Since `CompositeFileListFilter` matches the files against all delegates, the `discardCallback` may be called several times for the same file.\n\nStarting with version 5.1, the `FileReadingMessageSource` doesn't check a directory for existence and doesn't create it until its `start()` is called (typically via wrapping `SourcePollingChannelAdapter`).\nPreviously, there was no simple way to prevent the operating system permissions error when referencing the directory, for example from tests, or when permissions are applied later.\n\nIn opposition to the `LastModifiedFileListFilter`, a `RecentFileListFilter` strategy has been introduced starting version 6.5.\nIt is an extension for a local file system of the `AbstractRecentFileListFilter`.\nBy default, it accepts files which are not older than 1 day.\nSee its other implementations for respective remote file protocol.\n\n[[message-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/reading.adoc", "title": "reading", "heading": "reading", "heading_level": 1, "file_order": 56, "section_index": 0, "content_hash": "05eb952cf075eb9385f5e9e25c3c63fd34c338113638f3c24030ea8aff075fb3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/reading.adoc"}}
{"id": "sha256:dc8ed8f9f66a26b7b21e265012e8585adf9254532237b932fbb9db7431a9ce9f", "content": "Starting with version 5.0, the `FileReadingMessageSource` (in addition to the `payload` as a polled `File`) populates the following headers to the outbound `Message`:\n\n* `FileHeaders.FILENAME`: The `File.getName()` of the file to send.\nCan be used for subsequent rename or copy logic.\n* `FileHeaders.ORIGINAL_FILE`: The `File` object itself.\nTypically, this header is populated automatically by framework components (such as xref:file/splitter.adoc[splitters] or xref:file/transforming.adoc[transformers]) when we lose the original `File` object.\nHowever, for consistency and convenience with any other custom use cases, this header can be useful to get access to the original file.\n* `FileHeaders.RELATIVE_PATH`: A new header introduced to represent the part of file path relative to the root directory for the scan.\nThis header can be useful when the requirement is to restore a source directory hierarchy in the other places.\nFor this purpose, the `DefaultFileNameGenerator` (see \"`xref:file/writing.adoc#file-writing-file-names[Generating File Names]) can be configured to use this header.\n\n[[directory-scanning-and-polling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/reading.adoc", "title": "reading", "heading": "Message Headers", "heading_level": 2, "file_order": 56, "section_index": 1, "content_hash": "dc8ed8f9f66a26b7b21e265012e8585adf9254532237b932fbb9db7431a9ce9f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/reading.adoc"}}
{"id": "sha256:9030bd4161f1cf36c0dfce8eae25daf67386da5da06a7a7f7da9bf4151e7395a", "content": "The `FileReadingMessageSource` does not produce messages for files from the directory immediately.\nIt uses an internal queue for 'eligible files' returned by the `scanner`.\nThe `scanEachPoll` option is used to ensure that the internal queue is refreshed with the latest input directory content on each poll.\nBy default (`scanEachPoll = false`), the `FileReadingMessageSource` empties its queue before scanning the directory again.\nThis default behavior is particularly useful to reduce scans of large numbers of files in a directory.\nHowever, in cases where custom ordering is required, it is important to consider the effects of setting this flag to `true`.\nThe order in which files are processed may not be as expected.\nBy default, files in the queue are processed in their natural (`path`) order.\nNew files added by a scan, even when the queue already has files, are inserted in the appropriate position to maintain that natural order.\nTo customize the order, the `FileReadingMessageSource` can accept a `Comparator<File>` as a constructor argument.\nIt is used by the internal (`PriorityBlockingQueue`) to reorder its content according to the business requirements.\nTherefore, to process files in a specific order, you should provide a comparator to the `FileReadingMessageSource` rather than ordering the list produced by a custom `DirectoryScanner`.\n\nVersion 5.0 introduced `RecursiveDirectoryScanner` to perform file tree visiting.\nThe implementation is based on the `Files.walk(Path start, int maxDepth, FileVisitOption... options)` functionality.\nThe root directory (`DirectoryScanner.listFiles(File)`) argument is excluded from the result.\nAll other subdirectories inclusions and exclusions are based on the target `FileListFilter` implementation.\nFor example, the `SimplePatternFileListFilter` filters out directories by default.\nSee https://docs.spring.io/spring-integration/api/org/springframework/integration/file/filters/AbstractDirectoryAwareFileListFilter.html[`AbstractDirectoryAwareFileListFilter`] and its implementations for more information.\n\nNOTE: Starting with version 5.5, the `FileInboundChannelAdapterSpec` of the Java DSL has a convenient `recursive(boolean)` option to use a `RecursiveDirectoryScanner` in the target `FileReadingMessageSource` instead of the default one.\n\nStarting with version 7.0, the `FileReadingMessageSource` can be configured with a SpEL expression for its `directory` property.\nThis expression evaluated each time when a new scan is requested.\nSuch a logic might be useful in scenarios when input directory should be changed after scanning is exhausted, or when it is based on the timestamp rotation.\n\n[[file-namespace-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/reading.adoc", "title": "reading", "heading": "Directory Scanning and Polling", "heading_level": 2, "file_order": 56, "section_index": 2, "content_hash": "9030bd4161f1cf36c0dfce8eae25daf67386da5da06a7a7f7da9bf4151e7395a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/reading.adoc"}}
{"id": "sha256:c51f3540e45d9edc2a5415da69ca2fdd574aab678c9ba5cba29fbb9acadf38b6", "content": "The configuration for file reading can be simplified by using the file-specific namespace.\nTo do so, use the following template:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int=\"http://www.springframework.org/schema/integration\"\n xmlns:int-file=\"http://www.springframework.org/schema/integration/file\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration.xsd\n http://www.springframework.org/schema/integration/file\n https://www.springframework.org/schema/integration/file/spring-integration-file.xsd\">\n</beans>\n----\n\nWithin this namespace, you can reduce the `FileReadingMessageSource` and wrap it in an inbound Channel Adapter, as follows:\n\n[source,xml]\n----\n<int-file:inbound-channel-adapter id=\"filesIn1\"\n directory=\"file:${input.directory}\" prevent-duplicates=\"true\" ignore-hidden=\"true\"/>\n\n<int-file:inbound-channel-adapter id=\"filesIn2\"\n directory=\"file:${input.directory}\"\n filter=\"customFilterBean\" />\n\n<int-file:inbound-channel-adapter id=\"filesIn3\"\n directory=\"file:${input.directory}\"\n filename-pattern=\"test*\" />\n\n<int-file:inbound-channel-adapter id=\"filesIn4\"\n directory=\"file:${input.directory}\"\n filename-regex=\"test[0-9]+\\.txt\" />\n----\n\nThe first channel adapter example relies on the default `FileListFilter` implementations:\n\n* `IgnoreHiddenFileListFilter` (do not process hidden files)\n* `AcceptOnceFileListFilter` (prevent duplication)\n\nTherefore, you can also leave off the `prevent-duplicates` and `ignore-hidden` attributes, as they are `true` by default.\n\n[IMPORTANT]\n=====\nSpring Integration 4.2 introduced the `ignore-hidden` attribute.\nIn prior versions, hidden files were included.\n=====\n\nThe second channel adapter example uses a custom filter, the third uses the `filename-pattern` attribute to add an `AntPathMatcher` based filter, and the fourth uses the `filename-regex` attribute to add a regular expression pattern-based filter to the `FileReadingMessageSource`.\nThe `filename-pattern` and `filename-regex` attributes are each mutually exclusive with the regular `filter` reference attribute.\nHowever, you can use the `filter` attribute to reference an instance of `CompositeFileListFilter` that combines any number of filters, including one or more pattern-based filters to fit your particular needs.\n\nWhen multiple processes are read from the same directory, you may want to lock files to prevent them from being picked up concurrently.\nTo do so, you can use a `FileLocker`.\nThere is a `java.nio`-based implementation available, but it is also possible to implement your own locking scheme.\nThe `nio` locker can be injected as follows:\n\n[source,xml]\n----\n<int-file:inbound-channel-adapter id=\"filesIn\"\n directory=\"file:${input.directory}\" prevent-duplicates=\"true\">\n <int-file:nio-locker/>\n</int-file:inbound-channel-adapter>\n----\n\nYou can configure a custom locker as follows:\n\n[source,xml]\n----\n<int-file:inbound-channel-adapter id=\"filesIn\"\n directory=\"file:${input.directory}\" prevent-duplicates=\"true\">\n <int-file:locker ref=\"customLocker\"/>\n</int-file:inbound-channel-adapter>\n----\n\nNOTE: When a file inbound adapter is configured with a locker, it takes responsibility for acquiring a lock before the file is allowed to be received.\nIt does not assume the responsibility to unlock the file.\nIf you have processed the file and keep the locks hanging around, you have a memory leak.\nIf this is a problem, you should call `FileLocker.unlock(File file)` yourself at the appropriate time.\n\nWhen filtering and locking files is not enough, you might need to control the way files are listed entirely.\nTo implement this type of requirement, you can use an implementation of `DirectoryScanner`.\nThis scanner lets you determine exactly what files are listed in each poll.\nThis is also the interface that Spring Integration uses internally to wire `FileListFilter` instances and `FileLocker` to the `FileReadingMessageSource`.\nYou can inject a custom `DirectoryScanner` into the `<int-file:inbound-channel-adapter/>` on the `scanner` attribute, as the following example shows:\n\n[source,xml]\n----\n<int-file:inbound-channel-adapter id=\"filesIn\" directory=\"file:${input.directory}\"\n scanner=\"customDirectoryScanner\"/>\n----\n\nDoing so gives you full freedom to choose the ordering, listing, and locking strategies.\n\nIt is also important to understand that filters (including `patterns`, `regex`, `prevent-duplicates`, and others) and `locker` instances are actually used by the `scanner`.\nAny of these attributes set on the adapter are subsequently injected into the internal `scanner`.\nFor the case of an external `scanner`, all filter and locker attributes are prohibited on the `FileReadingMessageSource`.\nThey must be specified (if required) on that custom `DirectoryScanner`.\nIn other words, if you inject a `scanner` into the `FileReadingMessageSource`, you should supply `filter` and `locker` on that `scanner`, not on the `FileReadingMessageSource`.\n\nNOTE: By default, the `DefaultDirectoryScanner` uses an `IgnoreHiddenFileListFilter` and an `AcceptOnceFileListFilter`.\nTo prevent their use, you can configure your own filter (such as `AcceptAllFileListFilter`) or even set it to `null`.\n\n[[watch-service-directory-scanner]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/reading.adoc", "title": "reading", "heading": "Namespace Support", "heading_level": 2, "file_order": 56, "section_index": 3, "content_hash": "c51f3540e45d9edc2a5415da69ca2fdd574aab678c9ba5cba29fbb9acadf38b6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/reading.adoc"}}
{"id": "sha256:81914334a1fd97c1cf5ffe7c6e028bccf1382f6bef9b85e00e0134c498ff6c50", "content": "The `FileReadingMessageSource.WatchServiceDirectoryScanner` relies on file-system events when new files are added to the directory.\nDuring initialization, the directory is registered to generate events.\nThe initial file list is also built during initialization.\nWhile walking the directory tree, any subdirectories encountered are also registered to generate events.\nIn the first poll, the initial file list from walking the directory is returned.\nIn subsequent polls, files from new creation events are returned.\nIf a new subdirectory is added, its creation event is used to walk the new subtree to find existing files and register any new subdirectories found.\n\nNOTE: There is an issue with `WatchKey` when its internal events `queue` is not drained by the program as quickly as the directory modification events occur.\nIf the queue size is exceeded, a `StandardWatchEventKinds.OVERFLOW` is emitted to indicate that some file system events may be lost.\nIn this case, the root directory is re-scanned completely.\nTo avoid duplicates, consider using an appropriate `FileListFilter` (such as the `AcceptOnceFileListFilter`) or removing files when processing is complete.\n\nThe `WatchServiceDirectoryScanner` can be enabled through the `FileReadingMessageSource.use-watch-service` option, which is mutually exclusive with the `scanner` option.\nAn internal `FileReadingMessageSource.WatchServiceDirectoryScanner` instance is populated for the provided `directory`.\n\nIn addition, now the `WatchService` polling logic can track the `StandardWatchEventKinds.ENTRY_MODIFY` and `StandardWatchEventKinds.ENTRY_DELETE`.\n\nIf you need to track the modification of existing files as well as new files, you should implement the `ENTRY_MODIFY` events logic in the `FileListFilter`.\nOtherwise, the files from those events are treated the same way.\n\nThe `ResettableFileListFilter` implementations pick up the `ENTRY_DELETE` events.\nConsequently, their files are provided for the `remove()` operation.\nWhen this event is enabled, filters such as the `AcceptOnceFileListFilter` have the file removed.\nAs a result, if a file with the same name appears, it passes the filter and is sent as a message.\n\nFor this purpose, the `watch-events` property (`FileReadingMessageSource.setWatchEvents(WatchEventType... watchEvents)`) has been introduced.\n(`WatchEventType` is a public inner enumeration in `FileReadingMessageSource`.)\nWith such an option, we can use one downstream flow logic for new files and use some other logic for modified files.\nThe following example shows how to configure different logic to create and modify events in the same directory:\n\nIt is worth mentioning that the `ENTRY_DELETE` event is involved in the rename operation of subdirectory of the watched directory.\nMore specifically, `ENTRY_DELETE` event, which is related to the previous directory name, precedes `ENTRY_CREATE` event which notifies about the new (renamed) directory.\nOn some operating systems (like Windows), the `ENTRY_DELETE` event has to be registered to deal with that situation.\nOtherwise, renaming watched subdirectory in the File Explorer could result in the new files not being detected in that sub-directory.\n\n[source,xml]\n----\n<int-file:inbound-channel-adapter id=\"newFiles\"\n directory=\"${input.directory}\"\n use-watch-service=\"true\"/>\n\n<int-file:inbound-channel-adapter id=\"modifiedFiles\"\n directory=\"${input.directory}\"\n use-watch-service=\"true\"\n filter=\"acceptAllFilter\"\n watch-events=\"MODIFY\"/> <!-- The default is CREATE. -->\n----\n\nStarting with version 6.1, the `FileReadingMessageSource` exposes two new `WatchService`-related options:\n\n* `watchMaxDepth` - an argument for the `Files.walkFileTree(Path root, Set attributes, int maxDepth, FileVisitor visitor)` API;\n* `watchDirPredicate` - a `Predicate<Path>` to test if a directory in the scanned tree should be walked and registered with the `WatchService` and the configured watch event kinds.\n\n[[limiting-memory-consumption]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/reading.adoc", "title": "reading", "heading": "`WatchServiceDirectoryScanner`", "heading_level": 2, "file_order": 56, "section_index": 4, "content_hash": "81914334a1fd97c1cf5ffe7c6e028bccf1382f6bef9b85e00e0134c498ff6c50", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/reading.adoc"}}
{"id": "sha256:0cd6c14fcebd3b917ac9ab74e5b394d7b95cd2d0fbc7b69a6ea8e6408cd443db", "content": "You can use a `HeadDirectoryScanner` to limit the number of files retained in memory.\nThis can be useful when scanning large directories.\nWith XML configuration, this is enabled by setting the `queue-size` property on the inbound channel adapter.\n\nPrior to version 4.2, this setting was incompatible with the use of any other filters.\nAny other filters (including `prevent-duplicates=\"true\"`) overwrote the filter used to limit the size.\n\n[NOTE]\n=====\nThe use of a `HeadDirectoryScanner` is incompatible with an `AcceptOnceFileListFilter`.\nSince all filters are consulted during the poll decision, the `AcceptOnceFileListFilter` does not know that other filters might be temporarily filtering files.\nEven if files that were previously filtered by the `HeadDirectoryScanner.HeadFilter` are now available, the `AcceptOnceFileListFilter` filters them.\n\nGenerally, instead of using an `AcceptOnceFileListFilter` in this case, you should remove the processed files so that the previously filtered files are available on a future poll.\n=====\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/reading.adoc", "title": "reading", "heading": "Limiting Memory Consumption", "heading_level": 2, "file_order": 56, "section_index": 5, "content_hash": "0cd6c14fcebd3b917ac9ab74e5b394d7b95cd2d0fbc7b69a6ea8e6408cd443db", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/reading.adoc"}}
{"id": "sha256:d4e690390e6a1ad1d16a72b1f1e1481fde4a04ec424cfa4ec74b22772e44243b", "content": "The following Spring Boot application shows an example of how to configure the outbound adapter with Java configuration:\n\n[source, java]\n----\n@SpringBootApplication\npublic class FileReadingJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(FileReadingJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public MessageChannel fileInputChannel() {\n return new DirectChannel();\n }\n\n @Bean\n @InboundChannelAdapter(value = \"fileInputChannel\", poller = @Poller(fixedDelay = \"1000\"))\n public MessageSource<File> fileReadingMessageSource() {\n FileReadingMessageSource source = new FileReadingMessageSource();\n source.setDirectory(new File(INBOUND_PATH));\n source.setFilter(new SimplePatternFileListFilter(\"*.txt\"));\n return source;\n }\n\n @Bean\n @Transformer(inputChannel = \"fileInputChannel\", outputChannel = \"processFileChannel\")\n public FileToStringTransformer fileToStringTransformer() {\n return new FileToStringTransformer();\n }\n\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/reading.adoc", "title": "reading", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 56, "section_index": 6, "content_hash": "d4e690390e6a1ad1d16a72b1f1e1481fde4a04ec424cfa4ec74b22772e44243b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/reading.adoc"}}
{"id": "sha256:153edfd0b333cc035865ffeb7daa293ce61f68189c14df9b4b0bb700fc43ad60", "content": "The following Spring Boot application shows an example of how to configure the outbound adapter with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class FileReadingJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(FileReadingJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public IntegrationFlow fileReadingFlow() {\n return IntegrationFlow\n .from(Files.inboundAdapter(new File(INBOUND_PATH))\n .patternFilter(\"*.txt\"),\n e -> e.poller(Pollers.fixedDelay(1000)))\n .transform(Files.toStringTransformer())\n .channel(\"processFileChannel\")\n .get();\n }\n\n}\n----\n\n[[file-tailing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/reading.adoc", "title": "reading", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 56, "section_index": 7, "content_hash": "153edfd0b333cc035865ffeb7daa293ce61f68189c14df9b4b0bb700fc43ad60", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/reading.adoc"}}
{"id": "sha256:dab7a3e730c1120eb29af8f297dee90bd955a6991a9b7b170e3d94a2e55c6700", "content": "Another popular use case is to get 'lines' from the end (or tail) of a file, capturing new lines when they are added.\nTwo implementations are provided.\nThe first, `OSDelegatingFileTailingMessageProducer`, uses the native `tail` command (on operating systems that have one).\nThis is generally the most efficient implementation on those platforms.\nFor operating systems that do not have a `tail` command, the second implementation, `ApacheCommonsFileTailingMessageProducer`, uses the Apache `commons-io` `Tailer` class.\n\nIn both cases, file system events, such as files being unavailable and other events, are published as `ApplicationEvent` instances by using the normal Spring event publishing mechanism.\nExamples of such events include the following:\n\n[source,bash]\n----\n[message=tail: cannot open '/tmp/somefile' for reading:\n No such file or directory, file=/tmp/somefile]\n\n[message=tail: '/tmp/somefile' has become accessible, file=/tmp/somefile]\n\n[message=tail: '/tmp/somefile' has become inaccessible:\n No such file or directory, file=/tmp/somefile]\n\n[message=tail: '/tmp/somefile' has appeared;\n following end of new file, file=/tmp/somefile]\n----\n\nThe sequence of events shown in the preceding example might occur, for example, when a file is rotated.\n\nStarting with version 5.0, a `FileTailingIdleEvent` is emitted when there is no data in the file during `idleEventInterval`.\nThe following example shows what such an event looks like:\n\n[source,bash]\n----\n[message=Idle timeout, file=/tmp/somefile] [idle time=5438]\n----\n\nNOTE: Not all platforms that support a `tail` command provide these status messages.\n\nMessages emitted from these endpoints have the following headers:\n\n* `FileHeaders.ORIGINAL_FILE`: The `File` object\n* `FileHeaders.FILENAME`: The file name (`File.getName()`)\n\nNOTE: In versions prior to version 5.0, the `FileHeaders.FILENAME` header contained a string representation of the file's absolute path.\nYou can now obtain that string representation by calling `getAbsolutePath()` on the original file header.\n\nThe following example creates a native adapter with the default options ('-F -n 0', meaning to follow the file name from the current end).\n\n[source,xml]\n----\n<int-file:tail-inbound-channel-adapter id=\"native\"\n\tchannel=\"input\"\n\ttask-executor=\"exec\"\n\tfile=\"/tmp/foo\"/>\n----\n\nThe following example creates a native adapter with '-F -n +0' options (meaning follow the file name, emitting all existing lines).\n\n[source,xml]\n----\n<int-file:tail-inbound-channel-adapter id=\"native\"\n\tchannel=\"input\"\n\tnative-options=\"-F -n +0\"\n\ttask-executor=\"exec\"\n\tfile-delay=10000\n\tfile=\"/tmp/foo\"/>\n----\n\nIf the `tail` command fails (on some platforms, a missing file causes the `tail` to fail, even with `-F` specified), the command is retried every 10 seconds.\n\nBy default, native adapters capture from standard output and send the content as messages.\nThey also capture from standard error to raise events.\nStarting with version 4.3.6, you can discard the standard error events by setting the `enable-status-reader` to `false`, as the following example shows:\n\n[source,xml]\n----\n<int-file:tail-inbound-channel-adapter id=\"native\"\n\tchannel=\"input\"\n\tenable-status-reader=\"false\"\n\ttask-executor=\"exec\"\n\tfile=\"/tmp/foo\"/>\n----\n\nIn the following example, `IdleEventInterval` is set to `5000`, meaning that, if no lines are written for five seconds, `FileTailingIdleEvent` is triggered every five seconds:\n\n[source,xml]\n----\n<int-file:tail-inbound-channel-adapter id=\"native\"\n\tchannel=\"input\"\n\tidle-event-interval=\"5000\"\n\ttask-executor=\"exec\"\n\tfile=\"/tmp/somefile\"/>\n----\n\nThis can be useful when you need to stop the adapter.\n\nThe following example creates an Apache `commons-io` `Tailer` adapter that examines the file for new lines every two seconds and checks for existence of a missing file every ten seconds:\n\n[source,xml]\n----\n<int-file:tail-inbound-channel-adapter id=\"apache\"\n\tchannel=\"input\"\n\ttask-executor=\"exec\"\n\tfile=\"/tmp/bar\"\n\tdelay=\"2000\"\n\tend=\"false\" <1>\n\treopen=\"true\" <2>\n\tfile-delay=\"10000\"/>\n----\n\n<1> The file is tailed from the beginning (`end=\"false\"`) instead of the end (which is the default).\n<2> The file is reopened for each chunk (the default is to keep the file open).\n\nIMPORTANT: Specifying the `delay`, `end` or `reopen` attributes forces the use of the Apache `commons-io` adapter and makes the `native-options` attribute unavailable.\n\n[[file-incomplete]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/reading.adoc", "title": "reading", "heading": "'tail'ing Files", "heading_level": 2, "file_order": 56, "section_index": 8, "content_hash": "dab7a3e730c1120eb29af8f297dee90bd955a6991a9b7b170e3d94a2e55c6700", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/reading.adoc"}}
{"id": "sha256:bdc43cacc3c21465db81b6ac633cf2ebdeaaee9369d58b2506bde8e24d510c66", "content": "A common problem in file-transfer scenarios is how to determine that the transfer is complete so that you do not start reading an incomplete file.\nA common technique to solve this problem is to write the file with a temporary name and then atomically rename it to the final name.\nThis technique, together with a filter that masks the temporary file from being picked up by the consumer, provides a robust solution.\nThis technique is used by Spring Integration components that write files (locally or remotely).\nBy default, they append `.writing` to the file name and remove it when the transfer is complete.\n\nAnother common technique is to write a second \"`marker`\" file to indicate that the file transfer is complete.\nIn this scenario, you should not consider `somefile.txt` (for example) to be available for use until `somefile.txt.complete` is also present.\nSpring Integration version 5.0 introduced new filters to support this mechanism.\nImplementations are provided for the file system (`FileSystemMarkerFilePresentFileListFilter`), xref:ftp/inbound.adoc#ftp-incomplete[FTP], and xref:sftp/inbound.adoc#sftp-incomplete[SFTP].\nThey are configurable such that the marker file can have any name, although it is usually related to the file being transferred.\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/file/filters/FileSystemMarkerFilePresentFileListFilter.html[Javadoc] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/reading.adoc", "title": "reading", "heading": "Dealing With Incomplete Data", "heading_level": 2, "file_order": 56, "section_index": 9, "content_hash": "bdc43cacc3c21465db81b6ac633cf2ebdeaaee9369d58b2506bde8e24d510c66", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/reading.adoc"}}
{"id": "sha256:e1da09e9c36f060f1af8eee5c1da125c16c5e7b4e0662c3587fdf12793983814", "content": "[[remote-persistent-flf]]\n\nInbound and streaming inbound remote file channel adapters (`FTP`, `SFTP`, and other technologies) are configured with corresponding implementations of `AbstractPersistentAcceptOnceFileListFilter` by default, configured with an in-memory `MetadataStore`.\nTo run in a cluster, these can be replaced with filters using a shared `MetadataStore` (see xref:meta-data-store.adoc[Metadata Store] for more information).\nThese filters are used to prevent fetching the same file multiple times (unless its modified time changes).\nStarting with version 5.2, a file is added to the filter immediately before the file is fetched (and reversed if the fetch fails).\n\nStarting with version 7.0, all the `AbstractPersistentAcceptOnceFileListFilter` implementations uses a \"long file name\" (fetching directory plus simple file name) for the metadata entry key.\nPreviously, just a file name may cause the metadata overriding problem when the same filter is used for different directories with same file names.\nFor example, the `RotatingServerAdvice` may switch to directories based on the timestamp, but files are placed there with the same name according to business logic.\nIf `directory1` and `directory2` contain a `someFile`, the metadata for them is stored with a `directory1/someFile` and `directory2/someFile`, respectively.\nThat is if filter's `prefix` option is provided as an empty string, otherwise such a prefix is added to the final key.\n\nIMPORTANT: In the event of a catastrophic failure (such as power loss), it is possible that the file currently being fetched will remain in the filter and won't be re-fetched when restarting the application.\nIn this case you would need to manually remove this file from the `MetadataStore`.\n\nIn previous versions, the files were filtered before any were fetched, meaning that several files could be in this state after a catastrophic failure.\n\nIn order to facilitate this new behavior, two new methods have been added to `FileListFilter`.\n\n[source, java]\n----\nboolean accept(F file);\n\nboolean supportsSingleFileFiltering();\n----\n\nIf a filter returns `true` in `supportsSingleFileFiltering`, it **must** implement `accept()`.\n\nIf a remote filter does not support single file filtering (such as the `AbstractMarkerFilePresentFileListFilter`), the adapters revert to the previous behavior.\n\nIf multiple filters are in used(a `CompositeFileListFilter` or `ChainFileListFilter`), then **all** of the delegate filters must support single file filtering in order for the composite filter to support it.\n\nThe persistent file list filters now have a boolean property `forRecursion`.\nSetting this property to `true`, also sets `alwaysAcceptDirectories`, which means that the recursive operation on the outbound gateways (`ls` and `mget`) will now always traverse the full directory tree each time.\nThis is to solve a problem where changes deep in the directory tree were not detected.\nIn addition, `forRecursion=true` causes the full path to files to be used as the metadata store keys; this solves a problem where the filter did not work properly if a file with the same name appears multiple times in different directories.\nIMPORTANT: This means that existing keys in a persistent metadata store will not be found for files beneath the top level directory.\nFor this reason, the property is `false` by default; this may change in a future release.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/remote-persistent-flf.adoc", "title": "remote-persistent-flf", "heading": "remote-persistent-flf", "heading_level": 1, "file_order": 57, "section_index": 0, "content_hash": "e1da09e9c36f060f1af8eee5c1da125c16c5e7b4e0662c3587fdf12793983814", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/remote-persistent-flf.adoc"}}
{"id": "sha256:f12bfa621d89f832a5ac59d347653bd5658a882af5591e625ac4a0e99b55966f", "content": "[[file-splitter]]\n\nThe `FileSplitter` was added in version 4.1.2, and its namespace support was added in version 4.2.\nThe `FileSplitter` splits text files into individual lines, based on `BufferedReader.readLine()`.\nBy default, the splitter uses an `Iterator` to emit file lines one at a time as they are read from the file.\nSetting the `iterator` property to `false` causes it to read all the lines into memory before emitting them as messages.\nOne use case for this might be if you want to detect I/O errors on the file before sending any messages containing lines.\nHowever, it is only practical for relatively short files.\n\nInbound payloads can be `File`, `String` (a `File` path), `InputStream`, or `Reader`.\nOther payload types are emitted unchanged.\n\nThe following listing shows possible ways to configure a `FileSplitter`:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@SpringBootApplication\npublic class FileSplitterApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(FileSplitterApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public IntegrationFlow fileSplitterFlow() {\n return IntegrationFlow\n .from(Files.inboundAdapter(tmpDir.getRoot())\n .filter(new ChainFileListFilter<File>()\n .addFilter(new AcceptOnceFileListFilter<>())\n .addFilter(new ExpressionFileListFilter<>(\n new FunctionExpression<File>(f -> \"foo.tmp\".equals(f.getName()))))))\n .split(Files.splitter()\n .markers()\n .charset(StandardCharsets.US_ASCII)\n .firstLineAsHeader(\"fileHeader\")\n .applySequence(true))\n .channel(c -> c.queue(\"fileSplittingResultChannel\"))\n .get();\n }\n\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun fileSplitterFlow() =\n integrationFlow(\n Files.inboundAdapter(tmpDir.getRoot())\n .filter(\n ChainFileListFilter<File?>()\n .addFilter(AcceptOnceFileListFilter())\n .addFilter(ExpressionFileListFilter(FunctionExpression { f: File? -> \"foo.tmp\" == f!!.name }))\n )\n ) {\n split(\n Files.splitter()\n .markers()\n .charset(StandardCharsets.US_ASCII)\n .firstLineAsHeader(\"fileHeader\")\n .applySequence(true)\n )\n channel { queue(\"fileSplittingResultChannel\") }\n }\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Splitter(inputChannel=\"toSplitter\")\n@Bean\npublic MessageHandler fileSplitter() {\n FileSplitter splitter = new FileSplitter(true, true);\n splitter.setApplySequence(true);\n splitter.setOutputChannel(outputChannel);\n return splitter;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-file:splitter id=\"splitter\" <1>\n iterator=\"\" <2>\n markers=\"\" <3>\n markers-json=\"\" <4>\n apply-sequence=\"\" <5>\n requires-reply=\"\" <6>\n charset=\"\" <7>\n first-line-as-header=\"\" <8>\n input-channel=\"\" <9>\n output-channel=\"\" <10>\n send-timeout=\"\" <11>\n auto-startup=\"\" <12>\n order=\"\" <13>\n phase=\"\" /> <14>\n----\n======\n\n<1> The bean name of the splitter.\n<2> Set to `true` (the default) to use an iterator or `false` to load the file into memory before sending lines.\n<3> Set to `true` to emit start-of-file and end-of-file marker messages before and after the file data.\nMarkers are messages with `FileSplitter.FileMarker` payloads (with `START` and `END` values in the `mark` property).\nYou might use markers when sequentially processing files in a downstream flow where some lines are filtered.\nThey enable the downstream processing to know when a file has been completely processed.\nIn addition, a `file_marker` header that contains `START` or `END` is added to these messages.\nThe `END` marker includes a line count.\nIf the file is empty, only `START` and `END` markers are emitted with `0` as the `lineCount`.\nThe default is `false`.\nWhen `true`, `apply-sequence` is `false` by default.\nSee also `markers-json` (the next attribute).\n<4> When `markers` is true, set this to `true` to have the `FileMarker` objects be converted to a JSON string.\n(Uses a `SimpleJsonSerializer` underneath).\n<5> Set to `false` to disable the inclusion of `sequenceSize` and `sequenceNumber` headers in messages.\nThe default is `true`, unless `markers` is `true`.\nWhen `true` and `markers` is `true`, the markers are included in the sequencing.\nWhen `true` and `iterator` is `true`, the `sequenceSize` header is set to `0`, because the size is unknown.\n<6> Set to `true` to cause a `RequiresReplyException` to be thrown if there are no lines in the file.\nThe default is `false`.\n<7> Set the charset name to be used when reading text data into `String` payloads.\nThe default is the platform charset.\n<8> The header name for the first line to be carried as a header in the messages emitted for the remaining lines.\nSince version 5.0.\n<9> Set the input channel used to send messages to the splitter.\n<10> Set the output channel to which messages are sent.\n<11> Set the send timeout.\nOnly applies if the `output-channel` can block -- such as a full `QueueChannel`.\n<12> Set to `false` to disable automatically starting the splitter when the context is refreshed.\nThe default is `true`.\n<13> Set the order of this endpoint if the `input-channel` is a `<publish-subscribe-channel/>`.\n<14> Set the startup phase for the splitter (used when `auto-startup` is `true`).\n\nThe `FileSplitter` also splits any text-based `InputStream` into lines.\nStarting with version 4.3, when used in conjunction with an FTP or SFTP streaming inbound channel adapter or an FTP or SFTP outbound gateway that uses the `stream` option to retrieve a file, the splitter automatically closes the session that supports the stream when the file is completely consumed\nSee xref:ftp/streaming.adoc[FTP Streaming Inbound Channel Adapter] and xref:sftp/streaming.adoc[SFTP Streaming Inbound Channel Adapter] as well as xref:ftp/outbound-gateway.adoc[FTP Outbound Gateway] and xref:sftp/outbound-gateway.adoc[SFTP Outbound Gateway] for more information about these facilities.\n\nWhen using Java configuration, an additional constructor is available, as the following example shows:\n\n[source, java]\n----\npublic FileSplitter(boolean iterator, boolean markers, boolean markersJson)\n----\n\nWhen `markersJson` is true, the markers are represented as a JSON string (using a `SimpleJsonSerializer`).\n\nVersion 5.0 introduced the `firstLineAsHeader` option to specify that the first line of content is a header (such as column names in a CSV file).\nThe argument passed to this property is the header name under which the first line is carried as a header in the messages emitted for the remaining lines.\nThis line is not included in the sequence header (if `applySequence` is true) nor in the `lineCount` associated with `FileMarker.END`.\nNOTE: Starting with version 5.5, the lineCount` is also included as a `FileHeaders.LINE_COUNT` into headers of the `FileMarker.END` message, since the `FileMarker` could be serialized into JSON.\nIf a file contains only the header line, the file is treated as empty and, therefore, only `FileMarker` instances are emitted during splitting (if markers are enabled -- otherwise, no messages are emitted).\nBy default, (if no header name is set), the first line is considered to be data and becomes the payload of the first emitted message.\n\nIf you need more complex logic about header extraction from the file content (not first line, not the whole content of the line, not one particular header, and so on), consider using xref:content-enrichment.adoc#header-enricher[header enricher] ahead of the `FileSplitter`.\nNote that the lines that have been moved to the headers might be filtered downstream from the normal content process.\n\n[[idempotent-file-splitter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/splitter.adoc", "title": "splitter", "heading": "splitter", "heading_level": 1, "file_order": 58, "section_index": 0, "content_hash": "f12bfa621d89f832a5ac59d347653bd5658a882af5591e625ac4a0e99b55966f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/splitter.adoc"}}
{"id": "sha256:a1d384f4016ae5cb75033e3317d788e241b211b0fd3ecdc2417d05cabee0478f", "content": "When `apply-sequence` is true, the splitter adds the line number in the `SEQUENCE_NUMBER` header (when `markers` is true, the markers are counted as lines).\nThe line number can be used with an xref:handler-advice/idempotent-receiver.adoc[Idempotent Receiver] to avoid reprocessing lines after a restart.\n\nFor example:\n\n[source, java]\n----\n@Bean\npublic ConcurrentMetadataStore store() {\n return new ZookeeperMetadataStore();\n}\n\n@Bean\npublic MetadataStoreSelector selector() {\n return new MetadataStoreSelector(\n message -> message.getHeaders().get(FileHeaders.ORIGINAL_FILE, File.class)\n .getAbsolutePath(),\n message -> message.getHeaders().get(IntegrationMessageHeaderAccessor.SEQUENCE_NUMBER)\n .toString(),\n store())\n .compareValues(\n (oldVal, newVal) -> Integer.parseInt(oldVal) < Integer.parseInt(newVal));\n}\n\n@Bean\npublic IdempotentReceiverInterceptor idempotentReceiverInterceptor() {\n return new IdempotentReceiverInterceptor(selector());\n}\n\n@Bean\npublic IntegrationFlow flow() {\n ...\n .split(new FileSplitter())\n ...\n .handle(\"lineHandler\", e -> e.advice(idempotentReceiverInterceptor()))\n ...\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/splitter.adoc", "title": "splitter", "heading": "Idempotent Downstream Processing a Split File", "heading_level": 2, "file_order": 58, "section_index": 1, "content_hash": "a1d384f4016ae5cb75033e3317d788e241b211b0fd3ecdc2417d05cabee0478f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/splitter.adoc"}}
{"id": "sha256:cab46d145386eaabef729de14165621f1ebba8213ef07ad3f6bad62cd44a5644", "content": "[[file-transforming]]\n\nTo transform data read from the file system to objects and the other way around, you need to do some work.\nUnlike `FileReadingMessageSource` and to a lesser extent `FileWritingMessageHandler`, you probably need your own mechanism to get the job done.\nFor this, you can implement the `Transformer` interface.\nAlternatively, you can extend the `AbstractFilePayloadTransformer` for inbound messages.\nSpring Integration provides some obvious implementations.\n\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/Transformer.html[Javadoc for the `Transformer` interface] to see which Spring Integration classes implement it.\nSimilarly, you can check the https://docs.spring.io/spring-integration/api/org/springframework/integration/file/transformer/AbstractFilePayloadTransformer.html[Javadoc for the `AbstractFilePayloadTransformer` class] to see which Spring Integration classes extend it.\n\n`FileToByteArrayTransformer` extends `AbstractFilePayloadTransformer` and transforms a `File` object into a `byte[]` by using Spring's `FileCopyUtils`.\nIt is often better to use a sequence of transformers than to put all transformations in a single class.\nIn that case the `File` to `byte[]` conversion might be a logical first step.\n\n`FileToStringTransformer` extends `AbstractFilePayloadTransformer` convert a `File` object to a `String`.\nIf nothing else, this can be useful for debugging (to consider using it with a xref:channel/configuration.adoc#channel-wiretap[wire tap]).\n\nTo configure file-specific transformers, you can use the appropriate elements from the file namespace, as the following example shows:\n\n[source,xml]\n----\n<int-file:file-to-bytes-transformer input-channel=\"input\" output-channel=\"output\"\n delete-files=\"true\"/>\n\n<int-file:file-to-string-transformer input-channel=\"input\" output-channel=\"output\"\n delete-files=\"true\" charset=\"UTF-8\"/>\n----\n\nThe `delete-files` option signals to the transformer that it should delete the inbound file after the transformation is complete.\nThis is in no way a replacement for using an `AcceptOnceFileListFilter` when the `FileReadingMessageSource` is being used in a multithreaded environment (such as when you use Spring Integration in general).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/transforming.adoc", "title": "transforming", "heading": "transforming", "heading_level": 1, "file_order": 59, "section_index": 0, "content_hash": "cab46d145386eaabef729de14165621f1ebba8213ef07ad3f6bad62cd44a5644", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/transforming.adoc"}}
{"id": "sha256:4e21ce0741297faf0d620dd0e33fa67cf26cd140fd294948a03a49317c4a767c", "content": "[[file-writing]]\n\nTo write messages to the file system, you can use a https://docs.spring.io/spring-integration/api/org/springframework/integration/file/FileWritingMessageHandler.html[`FileWritingMessageHandler`].\nThis class can deal with the following payload types:\n\n* `File`\n* `String`\n* byte array\n* `InputStream` (since _version 4.2_)\n\nFor a String payload, you can configure the encoding and the charset.\n\nTo make things easier, you can configure the `FileWritingMessageHandler` as part of an outbound channel adapter or outbound gateway by using the XML namespace.\n\nStarting with version 4.3, you can specify the buffer size to use when writing files.\n\nStarting with version 5.1, you can provide a `BiConsumer<File, Message<?>>` `newFileCallback` which is triggered if you use `FileExistsMode.APPEND` or `FileExistsMode.APPEND_NO_FLUSH` and a new file has to be created.\nThis callback receives a newly created file and the message which triggered it.\nThis callback could be used to write a CSV header defined in the message header, for an example.\n\n[[file-writing-file-names]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "writing", "heading_level": 1, "file_order": 60, "section_index": 0, "content_hash": "4e21ce0741297faf0d620dd0e33fa67cf26cd140fd294948a03a49317c4a767c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:80d16a1159ec6b7d7690dd2bf37f12f32a5da1b660c072dd8e9466b0e8200ef8", "content": "In its simplest form, the `FileWritingMessageHandler` requires only a destination directory for writing the files.\nThe name of the file to be written is determined by the handler's https://docs.spring.io/spring-integration/api/org/springframework/integration/file/FileNameGenerator.html[`FileNameGenerator`].\nThe https://docs.spring.io/spring-integration/api/org/springframework/integration/file/DefaultFileNameGenerator.html[default implementation] looks for a message header whose key matches the constant defined as https://docs.spring.io/spring-integration/api/constant-values.html#org.springframework.integration.file.FileHeaders.FILENAME[`FileHeaders.FILENAME`].\n\nAlternatively, you can specify an expression to be evaluated against the message to generate a file name -- for example, `headers['myCustomHeader'] + '.something'`.\nThe expression must evaluate to a `String`.\nFor convenience, the `DefaultFileNameGenerator` also provides the `setHeaderName` method, letting you explicitly specify the message header whose value is to be used as the filename.\n\nOnce set up, the `DefaultFileNameGenerator` employs the following resolution steps to determine the filename for a given message payload:\n\n. Evaluate the expression against the message and, if the result is a non-empty `String`, use it as the filename.\n. Otherwise, if the payload is a `java.io.File`, use the `File` object's filename.\n. Otherwise, use the message ID appended with .`msg` as the filename.\n\nWhen you use the XML namespace support, both the file outbound channel adapter and the file outbound gateway support the following mutually exclusive configuration attributes:\n\n* `filename-generator` (a reference to a `FileNameGenerator` implementation)\n* `filename-generator-expression` (an expression that evaluates to a `String`)\n\nWhile writing files, a temporary file suffix is used (its default is `.writing`).\nIt is appended to the filename while the file is being written.\nTo customize the suffix, you can set the `temporary-file-suffix` attribute on both the file outbound channel adapter and the file outbound gateway.\n\nNOTE: When using the `APPEND` file `mode`, the `temporary-file-suffix` attribute is ignored, since the data is appended to the file directly.\n\nStarting with version 4.2.5, the generated file name (as a result of `filename-generator` or `filename-generator-expression` evaluation) can represent a child path together with the target file name.\nIt is used as a second constructor argument for `File(File parent, String child)` as before.\nHowever, in the past we did not create (`mkdirs()`) directories for the child path, assuming only the file name.\nThis approach is useful for cases when we need to restore the file system tree to match the source directory -- for example, when unzipping the archive and saving all the files in the target directory in the original order.\n\n[[file-writing-output-directory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "Generating File Names", "heading_level": 2, "file_order": 60, "section_index": 1, "content_hash": "80d16a1159ec6b7d7690dd2bf37f12f32a5da1b660c072dd8e9466b0e8200ef8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:015f5c4c1ceff84ab816574169fa3efa8fc7fd2d6af1ffd6d755b7f22fff6661", "content": "Both the file outbound channel adapter and the file outbound gateway provide two mutually exclusive configuration attributes for specifying the output directory:\n\n* `directory`\n* `directory-expression`\n\nNOTE: Spring Integration 2.2 introduced the `directory-expression` attribute.\n\n[[using-the-directory-attribute]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "Specifying the Output Directory", "heading_level": 2, "file_order": 60, "section_index": 2, "content_hash": "015f5c4c1ceff84ab816574169fa3efa8fc7fd2d6af1ffd6d755b7f22fff6661", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:6c54af991ed108852704021fe532112c0cc277b972f8504eae59fb44dcb7ec58", "content": "When you use the `directory` attribute, the output directory is set to a fixed value, which is set when the `FileWritingMessageHandler` is initialized.\nIf you do not specify this attribute, you must use the `directory-expression` attribute.\n\n[[using-the-directory-expression-attribute]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "Using the `directory` Attribute", "heading_level": 3, "file_order": 60, "section_index": 3, "content_hash": "6c54af991ed108852704021fe532112c0cc277b972f8504eae59fb44dcb7ec58", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:70cf24bf51538789d24f3adcf8035c59045b76be7f77f687b6d79928e59080e4", "content": "If you want to have full SpEL support, you can use the `directory-expression` attribute.\nThis attribute accepts a SpEL expression that is evaluated for each message being processed.\nThus, you have full access to a message's payload and its headers when you dynamically specify the output file directory.\n\nThe SpEL expression must resolve to either a `String`, `java.io.File` or `org.springframework.core.io.Resource`.\n(The latter is evaluated into a `File` anyway.)\nFurthermore, the resulting `String` or `File` must point to a directory.\nIf you do not specify the `directory-expression` attribute, then you must set the `directory` attribute.\n\n[[using-the-auto-create-directory-attribute]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "Using the `directory-expression` Attribute", "heading_level": 3, "file_order": 60, "section_index": 4, "content_hash": "70cf24bf51538789d24f3adcf8035c59045b76be7f77f687b6d79928e59080e4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:0ada65aa95c3c647a231b06fa508f8f470c96eae62783f04effeeee67289cb8e", "content": "By default, if the destination directory does not exist, the respective destination directory and any non-existing parent directories are automatically created.\nTo prevent that behavior, you can set the `auto-create-directory` attribute to `false`.\nThis attribute applies to both the `directory` and the `directory-expression` attributes.\n\n[NOTE]\n====\nWhen using the `directory` attribute and `auto-create-directory` is `false`, the following change was made starting with Spring Integration 2.2:\n\nInstead of checking for the existence of the destination directory when the adapter is initialized, this check is now performed for each message being processed.\n\nFurthermore, if `auto-create-directory` is `true` and the directory was deleted between the processing of messages, the directory is re-created for each message being processed.\n====\n\n[[file-writing-destination-exists]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "Using the `auto-create-directory` Attribute", "heading_level": 3, "file_order": 60, "section_index": 5, "content_hash": "0ada65aa95c3c647a231b06fa508f8f470c96eae62783f04effeeee67289cb8e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:b605a551d07a44464ad08945ee95058d74341866589297e26889877234000db8", "content": "When you write files and the destination file already exists, the default behavior is to overwrite that target file.\nYou can change this behavior by setting the `mode` attribute on the relevant file outbound components.\nThe following options exist:\n\n* `REPLACE` (Default)\n* `REPLACE_IF_MODIFIED`\n* `APPEND`\n* `APPEND_NO_FLUSH`\n* `FAIL`\n* `IGNORE`\n\nNOTE: Spring Integration 2.2 introduced the `mode` attribute and the `APPEND`, `FAIL`, and `IGNORE` options.\n\n`REPLACE`::\nIf the target file already exists, it is overwritten.\nIf the `mode` attribute is not specified, this is the default behavior when writing files.\n`REPLACE_IF_MODIFIED`::\nIf the target file already exists, it is overwritten only if the last modified timestamp differs from that of the source file.\nFor `File` payloads, the payload `lastModified` time is compared to the existing file.\nFor other payloads, the `FileHeaders.SET_MODIFIED` (`file_setModified`) header is compared to the existing file.\nIf the header is missing or has a value that is not a `Number`, the file is always replaced.\n`APPEND`::\nThis mode lets you append message content to the existing file instead of creating a new file each time.\nNote that this attribute is mutually exclusive with the `temporary-file-suffix` attribute because, when it appends content to the existing file, the adapter no longer uses a temporary file.\nThe file is closed after each message.\n`APPEND_NO_FLUSH`::\nThis option has the same semantics as `APPEND`, but the data is not flushed and the file is not closed after each message.\nThis can provide a significant performance at the risk of data loss in the event of a failure.\nSee xref:file/writing.adoc#file-flushing[Flushing Files When Using `APPEND_NO_FLUSH`] for more information.\n`FAIL`::\nIf the target file exists, a https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/MessageHandlingException.html[`MessageHandlingException`] is thrown.\n`IGNORE`::\nIf the target file exists, the message payload is silently ignored.\n\nNOTE: When using a temporary file suffix (the default is `.writing`), the `IGNORE` option applies if either the final file name or the temporary file name exists.\n\n[[file-flushing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "Dealing with Existing Destination Files", "heading_level": 2, "file_order": 60, "section_index": 6, "content_hash": "b605a551d07a44464ad08945ee95058d74341866589297e26889877234000db8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:6612e0c1cb41447131fd6a360db4ef5cca880eb56af65f5ab3e24791727e6cbc", "content": "The `APPEND_NO_FLUSH` mode was added in version 4.3.\nUsing it can improve performance because the file is not closed after each message.\nHowever, this can cause data loss in the event of a failure.\n\nSpring Integration provides several flushing strategies to mitigate this data loss:\n\n* Use `flushInterval`.\nIf a file is not written to for this period of time, it is automatically flushed.\nThis is approximate and may be up to `1.33x` this time (with an average of `1.167x`).\n* Send a message containing a regular expression to the message handler's `trigger` method.\nFiles with absolute path names matching the pattern are flushed.\n* Provide the handler with a custom `MessageFlushPredicate` implementation to modify the action taken when a message is sent to the `trigger` method.\n* Invoke one of the handler's `flushIfNeeded` methods by passing in a custom `FileWritingMessageHandler.FlushPredicate` or `FileWritingMessageHandler.MessageFlushPredicate` implementation.\n\nThe predicates are called for each open file.\nSee the https://docs.spring.io/spring-integration/api/index.html[Javadoc] for these interfaces for more information.\nNote that, since version 5.0, the predicate methods provide another parameter: the time that the current file was first written to if new or previously closed.\n\nWhen using `flushInterval`, the interval starts at the last write.\nThe file is flushed only if it is idle for the interval.\nStarting with version 4.3.7, an additional property (`flushWhenIdle`) can be set to `false`, meaning that the interval starts with the first write to a previously flushed (or new) file.\n\n[[file-timestamps]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "Flushing Files When Using `APPEND_NO_FLUSH`", "heading_level": 2, "file_order": 60, "section_index": 7, "content_hash": "6612e0c1cb41447131fd6a360db4ef5cca880eb56af65f5ab3e24791727e6cbc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:b707e99487589eda2687e8a70c23fa31920cb51a6f29ed9192e4271650734e6d", "content": "By default, the destination file's `lastModified` timestamp is the time when the file was created (except that an in-place rename retains the current timestamp).\nStarting with version 4.3, you can now configure `preserve-timestamp` (or `setPreserveTimestamp(true)` when using Java configuration).\nFor `File` payloads, this transfers the timestamp from the inbound file to the outbound (regardless of whether a copy was required).\nFor other payloads, if the `FileHeaders.SET_MODIFIED` header (`file_setModified`) is present, it is used to set the destination file's `lastModified` timestamp, as long as the header is a `Number`.\n\n[[file-permissions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "File Timestamps", "heading_level": 2, "file_order": 60, "section_index": 8, "content_hash": "b707e99487589eda2687e8a70c23fa31920cb51a6f29ed9192e4271650734e6d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:7407faf826f72138c3fb320b16f1a49b0334264f0f8e5c36afabf8aac65b2453", "content": "Starting with version 5.0, when writing files to a file system that supports Posix permissions, you can specify those permissions on the outbound channel adapter or gateway.\nThe property is an integer and is usually supplied in the familiar octal format -- for example, `0640`, meaning that the owner has read/write permissions, the group has read-only permission, and others have no access.\n\n[[file-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "File Permissions", "heading_level": 2, "file_order": 60, "section_index": 9, "content_hash": "7407faf826f72138c3fb320b16f1a49b0334264f0f8e5c36afabf8aac65b2453", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:03d4efaa0b863224cc3e5881500ec0f88085d1b5b01c3df72919dd1b61ef8d00", "content": "The following example configures a file outbound channel adapter:\n\n[source,xml]\n----\n<int-file:outbound-channel-adapter id=\"filesOut\" directory=\"${input.directory.property}\"/>\n----\n\nThe namespace-based configuration also supports a `delete-source-files` attribute.\nIf set to `true`, it triggers the deletion of the original source files after writing to a destination.\nThe default value for that flag is `false`.\nThe following example shows how to set it to `true`:\n\n[source,xml]\n----\n<int-file:outbound-channel-adapter id=\"filesOut\"\n directory=\"${output.directory}\"\n delete-source-files=\"true\"/>\n----\n\nNOTE: The `delete-source-files` attribute has an effect only if the inbound message has a `File` payload or if the `FileHeaders.ORIGINAL_FILE` header value contains either the source `File` instance or a `String` representing the original file path.\n\nStarting with version 4.2, the `FileWritingMessageHandler` supports an `append-new-line` option.\nIf set to `true`, a new line is appended to the file after a message is written.\nThe default attribute value is `false`.\nThe following example shows how to use the `append-new-line` option:\n\n[source,xml]\n----\n<int-file:outbound-channel-adapter id=\"newlineAdapter\"\n\tappend-new-line=\"true\"\n directory=\"${output.directory}\"/>\n----\n\n[[file-writing-output-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "File Outbound Channel Adapter", "heading_level": 2, "file_order": 60, "section_index": 10, "content_hash": "03d4efaa0b863224cc3e5881500ec0f88085d1b5b01c3df72919dd1b61ef8d00", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:58236816c113bec932d4ae9c237d4a17621a64df14930782d3ad8f73735f0c83", "content": "In cases where you want to continue processing messages based on the written file, you can use the `outbound-gateway` instead.\nIt plays a role similar to that of the `outbound-channel-adapter`.\nHowever, after writing the file, it also sends it to the reply channel as the payload of a message.\n\nThe following example configures an outbound gateway:\n\n[source,xml]\n----\n<int-file:outbound-gateway id=\"mover\" request-channel=\"moveInput\"\n reply-channel=\"output\"\n directory=\"${output.directory}\"\n mode=\"REPLACE\" delete-source-files=\"true\"/>\n----\n\nAs mentioned earlier, you can also specify the `mode` attribute, which defines the behavior of how to deal with situations where the destination file already exists.\nSee xref:file/writing.adoc#file-writing-destination-exists[Dealing with Existing Destination Files] for further details.\nGenerally, when using the file outbound gateway, the result file is returned as the message payload on the reply channel.\n\nThis also applies when specifying the `IGNORE` mode.\nIn that case the pre-existing destination file is returned.\nIf the payload of the request message was a file, you still have access to that original file through the message header.\nSee https://docs.spring.io/spring-integration/api/org/springframework/integration/file/FileHeaders.html[FileHeaders.ORIGINAL_FILE].\n\nNOTE: The 'outbound-gateway' works well in cases where you want to first move a file and then send it through a processing pipeline.\nIn such cases, you may connect the file namespace's `inbound-channel-adapter` element to the `outbound-gateway` and then connect that gateway's `reply-channel` to the beginning of the pipeline.\n\nIf you have more elaborate requirements or need to support additional payload types as input to be converted to file content, you can extend the `FileWritingMessageHandler`, but a much better option is to rely on a xref:file/transforming.adoc[`Transformer`].\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "Outbound Gateway", "heading_level": 2, "file_order": 60, "section_index": 11, "content_hash": "58236816c113bec932d4ae9c237d4a17621a64df14930782d3ad8f73735f0c83", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:30d01fc69d5beecddc3474626c8ac4b0d3de469a51d6b1344c5bde9d1bb121ea", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with Java configuration:\n\n[source, java]\n----\n@SpringBootApplication\n@IntegrationComponentScan\npublic class FileWritingJavaApplication {\n\n public static void main(String[] args) {\n ConfigurableApplicationContext context =\n new SpringApplicationBuilder(FileWritingJavaApplication.class)\n .web(false)\n .run(args);\n MyGateway gateway = context.getBean(MyGateway.class);\n gateway.writeToFile(\"foo.txt\", new File(tmpDir.getRoot(), \"fileWritingFlow\"), \"foo\");\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"writeToFileChannel\")\n public MessageHandler fileWritingMessageHandler() {\n Expression directoryExpression = new SpelExpressionParser().parseExpression(\"headers.directory\");\n FileWritingMessageHandler handler = new FileWritingMessageHandler(directoryExpression);\n handler.setFileExistsMode(FileExistsMode.APPEND);\n return handler;\n }\n\n @MessagingGateway(defaultRequestChannel = \"writeToFileChannel\")\n public interface MyGateway {\n\n void writeToFile(@Header(FileHeaders.FILENAME) String fileName,\n @Header(FileHeaders.FILENAME) File directory, String data);\n\n }\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 60, "section_index": 12, "content_hash": "30d01fc69d5beecddc3474626c8ac4b0d3de469a51d6b1344c5bde9d1bb121ea", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:7fe0f3e52469d23e8d8217000294a5ba24128b1fd298ad4139fd8238db96663c", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class FileWritingJavaApplication {\n\n public static void main(String[] args) {\n ConfigurableApplicationContext context =\n new SpringApplicationBuilder(FileWritingJavaApplication.class)\n .web(false)\n .run(args);\n MessageChannel fileWritingInput = context.getBean(\"fileWritingInput\", MessageChannel.class);\n fileWritingInput.send(new GenericMessage<>(\"foo\"));\n }\n\n @Bean\n public IntegrationFlow fileWritingFlow() {\n return IntegrationFlow.from(\"fileWritingInput\")\n .enrichHeaders(h -> h.header(FileHeaders.FILENAME, \"foo.txt\")\n .header(\"directory\", new File(tmpDir.getRoot(), \"fileWritingFlow\")))\n .handle(Files.outboundGateway(m -> m.getHeaders().get(\"directory\")))\n .channel(MessageChannels.queue(\"fileWritingResultChannel\"))\n .get();\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file/writing.adoc", "title": "writing", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 60, "section_index": 13, "content_hash": "7fe0f3e52469d23e8d8217000294a5ba24128b1fd298ad4139fd8238db96663c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file/writing.adoc"}}
{"id": "sha256:042a1c51365f119e75765a53b3ed599ac024fd17abdc072ad3888029f4767771", "content": "[[advanced-configuration]]\n\n`DefaultFtpSessionFactory` provides an abstraction over the underlying client API, which (since Spring Integration 2.0) is https://commons.apache.org/net/[Apache Commons Net].\nThis spares you from the low-level configuration details of the `org.apache.commons.net.ftp.FTPClient`.\nSeveral common properties are exposed on the session factory (since version 4.0, this now includes `connectTimeout`, `defaultTimeout`, and `dataTimeout`).\nHowever, you sometimes need access to lower level `FTPClient` configuration to achieve more advanced configuration (such as setting the port range for active mode).\nFor that purpose, `AbstractFtpSessionFactory` (the base class for all FTP Session Factories) exposes hooks, in the form of the two post-processing methods shown in the following listing:\n\n[source,java]\n----\n/**\n * Will handle additional initialization after client.connect() method was invoked,\n * but before any action on the client has been taken\n */\nprotected void postProcessClientAfterConnect(T t) throws IOException {\n // NOOP\n}\n/**\n * Will handle additional initialization before client.connect() method was invoked.\n */\nprotected void postProcessClientBeforeConnect(T client) throws IOException {\n // NOOP\n}\n----\n\nAs you can see, there is no default implementation for these two methods.\nHowever, by extending `DefaultFtpSessionFactory`, you can override these methods to provide more advanced configuration of the `FTPClient`, as the following example shows:\n\n[source,java]\n----\npublic class AdvancedFtpSessionFactory extends DefaultFtpSessionFactory {\n\n protected void postProcessClientBeforeConnect(FTPClient ftpClient) throws IOException {\n ftpClient.setActivePortRange(4000, 5000);\n }\n}\n----\n\n[[ftps-and-shared-sslsession]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/advanced-configuration.adoc", "title": "advanced-configuration", "heading": "advanced-configuration", "heading_level": 1, "file_order": 61, "section_index": 0, "content_hash": "042a1c51365f119e75765a53b3ed599ac024fd17abdc072ad3888029f4767771", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/advanced-configuration.adoc"}}
{"id": "sha256:f6b069d7ca1669c736459a476604844f2b5fbd204659f33edf561e0ba4c99b03", "content": "When using FTP over SSL or TLS, some servers require the same `SSLSession` to be used on the control and data connections.\nThis is to prevent \"`stealing`\" data connections.\nSee https://scarybeastsecurity.blogspot.cz/2009/02/vsftpd-210-released.html for more information.\n\nCurrently, the Apache FTPSClient does not support this feature.\nSee https://issues.apache.org/jira/browse/NET-408[NET-408].\n\nThe following solution (courtesy of https://stackoverflow.com/questions/32398754/how-to-connect-to-ftps-server-with-data-connection-using-same-tls-session[Stack Overflow]), uses reflection on the `sun.security.ssl.SSLSessionContextImpl`, so it may not work on other JVMs.\nThe stack overflow answer was submitted in 2015, and the solution has been tested by the Spring Integration team on JDK 1.8.0_112.\n\nThe following example shows how to create an FTPS session:\n\n[source, java]\n----\n@Bean\npublic DefaultFtpsSessionFactory sf() {\n DefaultFtpsSessionFactory sf = new DefaultFtpsSessionFactory() {\n\n @Override\n protected FTPSClient createClientInstance() {\n return new SharedSSLFTPSClient();\n }\n\n };\n sf.setHost(\"...\");\n sf.setPort(21);\n sf.setUsername(\"...\");\n sf.setPassword(\"...\");\n sf.setNeedClientAuth(true);\n return sf;\n}\n\nprivate static final class SharedSSLFTPSClient extends FTPSClient {\n\n @Override\n protected void _prepareDataSocket_(final Socket socket) throws IOException {\n if (socket instanceof SSLSocket) {\n // Control socket is SSL\n final SSLSession session = ((SSLSocket) _socket_).getSession();\n final SSLSessionContext context = session.getSessionContext();\n context.setSessionCacheSize(0); // you might want to limit the cache\n try {\n final Field sessionHostPortCache = context.getClass()\n .getDeclaredField(\"sessionHostPortCache\");\n sessionHostPortCache.setAccessible(true);\n final Object cache = sessionHostPortCache.get(context);\n final Method method = cache.getClass().getDeclaredMethod(\"put\", Object.class,\n Object.class);\n method.setAccessible(true);\n String key = String.format(\"%s:%s\", socket.getInetAddress().getHostName(),\n String.valueOf(socket.getPort())).toLowerCase(Locale.ROOT);\n method.invoke(cache, key, session);\n key = String.format(\"%s:%s\", socket.getInetAddress().getHostAddress(),\n String.valueOf(socket.getPort())).toLowerCase(Locale.ROOT);\n method.invoke(cache, key, session);\n }\n catch (NoSuchFieldException e) {\n // Not running in expected JRE\n logger.warn(\"No field sessionHostPortCache in SSLSessionContext\", e);\n }\n catch (Exception e) {\n // Not running in expected JRE\n logger.warn(e.getMessage());\n }\n }\n\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/advanced-configuration.adoc", "title": "advanced-configuration", "heading": "FTPS and Shared SSLSession", "heading_level": 2, "file_order": 61, "section_index": 1, "content_hash": "f6b069d7ca1669c736459a476604844f2b5fbd204659f33edf561e0ba4c99b03", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/advanced-configuration.adoc"}}
{"id": "sha256:6faedd1d15db0fb6c5981b56e774fdd7d4558f7d84466cdb66f6a870981cac26", "content": "[[ftp-dsf]]\n\nVersion 4.2 introduced the `DelegatingSessionFactory`, which allows the selection of the actual session factory at runtime.\nPrior to invoking the FTP endpoint, call `setThreadKey()` on the factory to associate a key with the current thread.\nThat key is then used to look up the actual session factory to be used.\nYou can clear the key by calling `clearThreadKey()` after use.\n\nSee xref:handler-advice/context-holder.adoc[Context Holder Advice] for more information how this factory can be used together with a `ContextHolderRequestHandlerAdvice`.\n\nIMPORTANT: When you use session caching (see xref:ftp/session-caching.adoc[FTP Session Caching]), each of the delegates should be cached.\nYou cannot cache the `DelegatingSessionFactory` itself.\n\nStarting with version 5.0.7, the `DelegatingSessionFactory` can be used in conjunction with a `RotatingServerAdvice` to poll multiple servers; see xref:ftp/rotating-server-advice.adoc[Inbound Channel Adapters: Polling Multiple Servers and Directories].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/dsf.adoc", "title": "dsf", "heading": "dsf", "heading_level": 1, "file_order": 62, "section_index": 0, "content_hash": "6faedd1d15db0fb6c5981b56e774fdd7d4558f7d84466cdb66f6a870981cac26", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/dsf.adoc"}}
{"id": "sha256:9a60334b8c5f3f4729ce65925ac3911e2f4a7e5c8e13fc9beddd8bf98b375541", "content": "[[ftp-inbound]]\n\nThe FTP inbound channel adapter is a special listener that connects to the FTP server and listens for the remote directory events, (for example, a new file created) at which point it initiates a file transfer.\nThe following example shows how to configure an `inbound-channel-adapter`:\n\n[source,xml]\n----\n<int-ftp:inbound-channel-adapter id=\"ftpInbound\"\n channel=\"ftpChannel\"\n session-factory=\"ftpSessionFactory\"\n auto-create-local-directory=\"true\"\n delete-remote-files=\"true\"\n filename-pattern=\"*.txt\"\n remote-directory=\"some/remote/path\"\n remote-file-separator=\"/\"\n preserve-timestamp=\"true\"\n local-filename-generator-expression=\"#this.toUpperCase() + '.a'\"\n scanner=\"myDirScanner\"\n local-filter=\"myFilter\"\n temporary-file-suffix=\".writing\"\n max-fetch-size=\"-1\"\n local-directory=\".\">\n <int:poller fixed-rate=\"1000\"/>\n</int-ftp:inbound-channel-adapter>\n----\n\nAs the preceding configuration shows, you can configure an FTP inbound channel adapter by using the `inbound-channel-adapter` element while also providing values for various attributes, such as `local-directory`, `filename-pattern` (which is based on simple pattern matching, not regular expressions), and the reference to a `session-factory`.\n\nBy default, the transferred file carries the same name as the original file.\nIf you want to override this behavior, you can set the `local-filename-generator-expression` attribute, which lets you provide a SpEL expression to generate the name of the local file.\nUnlike outbound gateways and adapters, where the root object of the SpEL evaluation context is a `Message`, this inbound adapter does not yet have the message at the time of evaluation, since that's what it ultimately generates with the transferred file as its payload.\nConsequently, the root object of the SpEL evaluation context is the original name of the remote file (a `String`).\n\nThe inbound channel adapter first retrieves the `File` object for a local directory and then emits each file according to the poller configuration.\nStarting with version 5.0, you can now limit the number of files fetched from the FTP server when new file retrievals are needed.\nThis can be beneficial when the target files are very large or when you run in a clustered system with a persistent file list filter, discussed later.\nUse `max-fetch-size` for this purpose.\nA negative value (the default) means no limit and all matching files are retrieved.\nSee xref:ftp/max-fetch.adoc[Inbound Channel Adapters: Controlling Remote File Fetching] for more information.\nSince version 5.0, you can also provide a custom `DirectoryScanner` implementation to the `inbound-channel-adapter` by setting the `scanner` attribute.\n\nStarting with Spring Integration 3.0, you can specify the `preserve-timestamp` attribute (its default is `false`).\nWhen `true`, the local file's modified timestamp is set to the value retrieved from the server.\nOtherwise, it is set to the current time.\n\nStarting with version 4.2, you can specify `remote-directory-expression` instead of `remote-directory`, letting you dynamically determine the directory on each poll -- for example, `remote-directory-expression=\"@myBean.determineRemoteDir()\"`.\n\nStarting with version 4.3, you can omit the `remote-directory` and `remote-directory-expression` attributes.\nThey default to `null`.\nIn this case, according to the FTP protocol, the client working directory is used as the default remote directory.\n\nSometimes, file filtering based on the simple pattern specified with the `filename-pattern` attribute might not suffice.\nIf this is the case, you can use the `filename-regex` attribute to specify a regular expression (such as `filename-regex=\".*\\.test$\"`).\nAlso, if you need complete control, you can use the `filter` attribute and provide a reference to any custom implementation of the `o.s.i.file.filters.FileListFilter`, a strategy interface for filtering a list of files.\nThis filter determines which remote files are retrieved.\nYou can also combine a pattern-based filter with other filters (such as an `AcceptOnceFileListFilter` to avoid synchronizing files that have previously been fetched) by using a `CompositeFileListFilter`.\n\nThe `AcceptOnceFileListFilter` stores its state in memory.\nIf you wish the state to survive a system restart, consider using the `FtpPersistentAcceptOnceFileListFilter` instead.\nThis filter stores the accepted file names in an instance of the `MetadataStore` strategy (see xref:meta-data-store.adoc[Metadata Store]).\nThis filter matches on the filename and the remote modified time.\n\nSince version 4.0, this filter requires a `ConcurrentMetadataStore`.\nWhen used with a shared data store (such as `Redis` with the `RedisMetadataStore`), it lets filter keys be shared across multiple application or server instances.\n\nStarting with version 5.0, the `FtpPersistentAcceptOnceFileListFilter` with in-memory `SimpleMetadataStore` is applied by default for the `FtpInboundFileSynchronizer`.\nThis filter is also applied with the `regex` or `pattern` option in the XML configuration as well as with `FtpInboundChannelAdapterSpec` in the Java DSL.\nAny other use cases can be managed with `CompositeFileListFilter` (or `ChainFileListFilter`).\n\nThe preceding discussion refers to filtering the files before retrieving them.\nOnce the files have been retrieved, an additional filter is applied to the files on the file system.\nBy default, this is an `AcceptOnceFileListFilter` which, as discussed earlier, retains state in memory and does not consider the file's modified time.\nUnless your application removes files after processing, the adapter will re-process the files on disk by default after an application restart.\n\nAlso, if you configure the `filter` to use a `FtpPersistentAcceptOnceFileListFilter` and the remote file timestamp changes (causing it to be re-fetched), the default local filter does not let this new file be processed.\n\nFor more information about this filter and how it is used, see xref:file/remote-persistent-flf.adoc[Remote Persistent File List Filters].\n\nYou can use the `local-filter` attribute to configure the behavior of the local file system filter.\nStarting with version 4.3.8, a `FileSystemPersistentAcceptOnceFileListFilter` is configured by default.\nThis filter stores the accepted file names and modified timestamp in an instance of the `MetadataStore` strategy (see xref:meta-data-store.adoc[Metadata Store]) and detects changes to the local file modified time.\nThe default `MetadataStore` is a `SimpleMetadataStore`, which stores state in memory.\n\nSince version 4.1.5, these filters have a new property (`flushOnUpdate`) that causes them to flush the\nmetadata store on every update (if the store implements `Flushable`).\n\nIMPORTANT: Further, if you use a distributed `MetadataStore` (such as xref:redis.adoc#redis-metadata-store[Redis]), you can have multiple instances of the same adapter or application and be sure that each file is processed only once.\n\nThe actual local filter is a `ChainFileListFilter` that contains a pattern filter that prevents processing files that are in the process of being downloaded (based on the `temporary-file-suffix`) and the supplied filter.\nFiles are downloaded with this suffix (the default is `.writing`), and the file is renamed to its final name when the transfer is complete, making it 'visible' to the filter.\n\nThe `remote-file-separator` attribute lets you configure a file separator character to use if the default '/' is not applicable for your particular environment.\n\nSee the https://github.com/spring-projects/spring-integration/tree/main/spring-integration-core/src/main/resources/org/springframework/integration/config[schema] for more details on these attributes.\n\nYou should also understand that the FTP inbound channel adapter is a polling consumer.\nTherefore, you must configure a poller (by using either a global default or a local subelement).\nOnce a file has been transferred, a message with a `java.io.File` as its payload is generated and sent to the channel identified by the `channel` attribute.\n\nStarting with version 6.2, you can filter FTP files based on last-modified strategy using `FtpLastModifiedFileListFilter`.\nThis filter can be configured with an `age` property so that only files older than this value are passed by the filter.\nThe age defaults to 60 seconds, but you should choose an age that is large enough to avoid picking up a file early (due to, say, network glitches).\nLook into its Javadoc for more information.\n\nIn contrast, starting with version 6.5, an `FtpRecentFileListFilter` has been introduced to accept only those files which are not older than provided `age`.\n\n[[more-on-file-filtering-and-incomplete-files]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/inbound.adoc", "title": "inbound", "heading": "inbound", "heading_level": 1, "file_order": 63, "section_index": 0, "content_hash": "9a60334b8c5f3f4729ce65925ac3911e2f4a7e5c8e13fc9beddd8bf98b375541", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/inbound.adoc"}}
{"id": "sha256:4ff4edde0d2927bb9cd5a2bfa1bc9e441badd9f438d64ee33140df9319f64719", "content": "Sometimes the file that just appeared in the monitored (remote) directory is not complete.\nTypically, such a file is written with a temporary extension (such as `somefile.txt.writing`) and is then renamed once the writing process finishes.\nIn most cases, you are only interested in files that are complete and would like to filter for only files that are complete.\nTo handle these scenarios, you can use the filtering support provided by the `filename-pattern`, `filename-regex`, and `filter` attributes.\nThe following example uses a custom filter implementation:\n\n[source,xml]\n----\n<int-ftp:inbound-channel-adapter\n channel=\"ftpChannel\"\n session-factory=\"ftpSessionFactory\"\n filter=\"customFilter\"\n local-directory=\"file:/my_transfers\">\n remote-directory=\"some/remote/path\"\n <int:poller fixed-rate=\"1000\"/>\n</int-ftp:inbound-channel-adapter>\n\n<bean id=\"customFilter\" class=\"org.example.CustomFilter\"/>\n----\n\n[[poller-configuration-notes-for-the-inbound-ftp-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/inbound.adoc", "title": "inbound", "heading": "More on File Filtering and Incomplete Files", "heading_level": 2, "file_order": 63, "section_index": 1, "content_hash": "4ff4edde0d2927bb9cd5a2bfa1bc9e441badd9f438d64ee33140df9319f64719", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/inbound.adoc"}}
{"id": "sha256:798fa1def78f171fe0ee97bd4bfd989ea05544bf14261c90043b2293b39a44bc", "content": "The job of the inbound FTP adapter consists of two tasks:\n\n. Communicate with a remote server in order to transfer files from a remote directory to a local directory.\n. For each transferred file, generate a message with that file as a payload and send it to the channel identified by the 'channel' attribute.\nThat is why they are called \"'channel adapters'\" rather than just \"'adapters'\".\nThe main job of such an adapter is to generate a message to send to a message channel.\nEssentially, the second task takes precedence in such a way that, if your local directory already has one or more files, it first generates messages from those.\nOnly when all local files have been processed does it initiate the remote communication to retrieve more files.\n\nAlso, when configuring a trigger on the poller, you should pay close attention to the `max-messages-per-poll` attribute.\nIts default value is `1` for all `SourcePollingChannelAdapter` instances (including FTP).\nThis means that, as soon as one file is processed, it waits for the next execution time as determined by your trigger configuration.\nIf you happened to have one or more files sitting in the `local-directory`, it would process those files before it would initiate communication with the remote FTP server.\nAlso, if the `max-messages-per-poll` is set to `1` (the default), it processes only one file at a time with intervals as defined by your trigger, essentially working as \"`one-poll === one-file`\".\n\nFor typical file-transfer use cases, you most likely want the opposite behavior: to process all the files you can for each poll and only then wait for the next poll.\nIf that is the case, set `max-messages-per-poll` to -1.\nThen, on each poll, the adapter tries to generate as many messages as it possibly can.\nIn other words, it processes everything in the local directory, and then it connects to the remote directory to transfer everything that is available there to be processed locally.\nOnly then is the poll operation considered complete, and the poller waits for the next execution time.\n\nYou can alternatively set the 'max-messages-per-poll' value to a positive value that indicates the upward limit of messages to be created from files with each poll.\nFor example, a value of `10` means that, on each poll, it tries to process no more than ten files.\n\n[[recovering-from-failures]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/inbound.adoc", "title": "inbound", "heading": "Poller Configuration Notes for the Inbound FTP Adapter", "heading_level": 2, "file_order": 63, "section_index": 2, "content_hash": "798fa1def78f171fe0ee97bd4bfd989ea05544bf14261c90043b2293b39a44bc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/inbound.adoc"}}
{"id": "sha256:f2bcd4a0c00009b89dd77e940035d81f645cc25440ee8380e866f57d023206de", "content": "It is important to understand the architecture of the adapter.\nThere is a file synchronizer that fetches the files and a `FileReadingMessageSource` that emits a message for each synchronized file.\nAs discussed earlier, two filters are involved.\nThe `filter` attribute (and patterns) refers to the remote (FTP) file list, to avoid fetching files that have already been fetched.\nThe `local-filter` is used by the `FileReadingMessageSource` to determine which files are to be sent as messages.\n\nThe synchronizer lists the remote files and consults its filter.\nThe files are then transferred.\nIf an IO error occurs during file transfer, any files that have already been added to the filter are removed so that they are eligible to be re-fetched on the next poll.\nThis only applies if the filter implements `ReversibleFileListFilter` (such as the `AcceptOnceFileListFilter`).\n\nIf, after synchronizing the files, an error occurs on the downstream flow processing a file, no automatic rollback of the filter occurs, so the failed file is not reprocessed by default.\n\nIf you wish to reprocess such files after a failure, you can use configuration similar to the following to facilitate the removal of the failed file from the filter:\n\n[source, xml]\n----\n<int-ftp:inbound-channel-adapter id=\"ftpAdapter\"\n session-factory=\"ftpSessionFactory\"\n channel=\"requestChannel\"\n remote-directory-expression=\"'/ftpSource'\"\n local-directory=\"file:myLocalDir\"\n auto-create-local-directory=\"true\"\n filename-pattern=\"*.txt\">\n <int:poller fixed-rate=\"1000\">\n <int:transactional synchronization-factory=\"syncFactory\" />\n </int:poller>\n</int-ftp:inbound-channel-adapter>\n\n<bean id=\"acceptOnceFilter\"\n class=\"org.springframework.integration.file.filters.AcceptOnceFileListFilter\" />\n\n<int:transaction-synchronization-factory id=\"syncFactory\">\n <int:after-rollback expression=\"payload.delete()\" />\n</int:transaction-synchronization-factory>\n\n<bean id=\"transactionManager\"\n class=\"org.springframework.integration.transaction.PseudoTransactionManager\" />\n----\n\nThe preceding configuration works for any `ResettableFileListFilter`.\n\nStarting with version 5.0, the inbound channel adapter can build subdirectories locally that correspond to the generated local file name.\nThat can be a remote sub-path as well.\nTo be able to read a local directory recursively for modification according to the hierarchy support, you can now supply an internal `FileReadingMessageSource` with a new `RecursiveDirectoryScanner` based on the `Files.walk()` algorithm.\nSee https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/synchronizer/AbstractInboundFileSynchronizingMessageSource.html#setScanner[`AbstractInboundFileSynchronizingMessageSource.setScanner()`] for more information.\nAlso, you can now switch the `AbstractInboundFileSynchronizingMessageSource` to the `WatchService`-based `DirectoryScanner` by using `setUseWatchService()` option.\nIt is also configured for all the `WatchEventType` instances to react to any modifications in local directory.\nThe reprocessing sample shown earlier is based on the built-in functionality of the `FileReadingMessageSource.WatchServiceDirectoryScanner` to perform `ResettableFileListFilter.remove()` when the file is deleted (`StandardWatchEventKinds.ENTRY_DELETE`) from the local directory.\nSee xref:file/reading.adoc#watch-service-directory-scanner[`WatchServiceDirectoryScanner`] for more information.\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/inbound.adoc", "title": "inbound", "heading": "Recovering from Failures", "heading_level": 2, "file_order": 63, "section_index": 3, "content_hash": "f2bcd4a0c00009b89dd77e940035d81f645cc25440ee8380e866f57d023206de", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/inbound.adoc"}}
{"id": "sha256:49b7405836785a3a07c84e457d3a43c8bdc0b26b1114989e6a21ae01278883e3", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with Java configuration:\n\n[source, java]\n----\n@SpringBootApplication\npublic class FtpJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(FtpJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public SessionFactory<FTPFile> ftpSessionFactory() {\n DefaultFtpSessionFactory sf = new DefaultFtpSessionFactory();\n sf.setHost(\"localhost\");\n sf.setPort(port);\n sf.setUsername(\"foo\");\n sf.setPassword(\"foo\");\n sf.setTestSession(true);\n return new CachingSessionFactory<FTPFile>(sf);\n }\n\n @Bean\n public FtpInboundFileSynchronizer ftpInboundFileSynchronizer() {\n FtpInboundFileSynchronizer fileSynchronizer = new FtpInboundFileSynchronizer(ftpSessionFactory());\n fileSynchronizer.setDeleteRemoteFiles(false);\n fileSynchronizer.setRemoteDirectory(\"foo\");\n fileSynchronizer.setFilter(new FtpSimplePatternFileListFilter(\"*.xml\"));\n return fileSynchronizer;\n }\n\n @Bean\n @InboundChannelAdapter(channel = \"ftpChannel\", poller = @Poller(fixedDelay = \"5000\"))\n public MessageSource<File> ftpMessageSource() {\n FtpInboundFileSynchronizingMessageSource source =\n new FtpInboundFileSynchronizingMessageSource(ftpInboundFileSynchronizer());\n source.setLocalDirectory(new File(\"ftp-inbound\"));\n source.setAutoCreateLocalDirectory(true);\n source.setLocalFilter(new AcceptOnceFileListFilter<File>());\n source.setMaxFetchSize(1);\n return source;\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"ftpChannel\")\n public MessageHandler handler() {\n return new MessageHandler() {\n\n @Override\n public void handleMessage(Message<?> message) throws MessagingException {\n System.out.println(message.getPayload());\n }\n\n };\n }\n\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/inbound.adoc", "title": "inbound", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 63, "section_index": 4, "content_hash": "49b7405836785a3a07c84e457d3a43c8bdc0b26b1114989e6a21ae01278883e3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/inbound.adoc"}}
{"id": "sha256:3fd7065cada67822067f46b295c1690c45b33eafd8931741c86d0df753b13fc9", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class FtpJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(FtpJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public IntegrationFlow ftpInboundFlow() {\n return IntegrationFlow\n .from(Ftp.inboundAdapter(this.ftpSessionFactory)\n .preserveTimestamp(true)\n .remoteDirectory(\"foo\")\n .regexFilter(\".*\\\\.txt$\")\n .localFilename(f -> f.toUpperCase() + \".a\")\n .localDirectory(new File(\"d:\\\\ftp_files\")),\n e -> e.id(\"ftpInboundAdapter\")\n .autoStartup(true)\n .poller(Pollers.fixedDelay(5000)))\n .handle(m -> System.out.println(m.getPayload()))\n .get();\n }\n}\n----\n\n[[ftp-incomplete]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/inbound.adoc", "title": "inbound", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 63, "section_index": 5, "content_hash": "3fd7065cada67822067f46b295c1690c45b33eafd8931741c86d0df753b13fc9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/inbound.adoc"}}
{"id": "sha256:2098b89d0ce9253e3c2a0267f8ff4dda521e41f9c75f3a077e1a44a3b6443a9f", "content": "See xref:file/reading.adoc#file-incomplete[Dealing With Incomplete Data].\n\nThe `FtpSystemMarkerFilePresentFileListFilter` is provided to filter remote files that do not have a corresponding marker file on the remote system.\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/ftp/filters/FtpSystemMarkerFilePresentFileListFilter.html[Javadoc] (and browse to the parent classes) for configuration information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/inbound.adoc", "title": "inbound", "heading": "Dealing With Incomplete Data", "heading_level": 2, "file_order": 63, "section_index": 6, "content_hash": "2098b89d0ce9253e3c2a0267f8ff4dda521e41f9c75f3a077e1a44a3b6443a9f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/inbound.adoc"}}
{"id": "sha256:fbee1fed3ad91b8190f9f0f3559d3ff56f450bb7d8f1c1d14e33d6be506b236d", "content": "[[ftp-max-fetch]]\n\nSee xref:sftp/max-fetch.adoc[SFTP: Controlling Remote File Fetching] for exactly the same generic functionality.\n\nAlso see general xref:ftp/inbound.adoc[FTP Inbound Channel Adapter] chapter for information about `FileListFilter` configuration.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/max-fetch.adoc", "title": "max-fetch", "heading": "max-fetch", "heading_level": 1, "file_order": 64, "section_index": 0, "content_hash": "fbee1fed3ad91b8190f9f0f3559d3ff56f450bb7d8f1c1d14e33d6be506b236d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/max-fetch.adoc"}}
{"id": "sha256:3c03d0fe93a4502672d323c32bd764a3bbe11e2d7edaddee2e504998b36cd4b4", "content": "[[ftp-outbound-gateway]]\n\nThe FTP outbound gateway provides a limited set of commands to interact with a remote FTP or FTPS server.\nThe supported commands are:\n\n* `ls` (list files)\n* `nlst` (list file names)\n* `get` (retrieve file)\n* `mget` (retrieve file(s))\n* `rm` (remove file(s))\n* `mv` (move/rename file)\n* `put` (send file)\n* `mput` (send multiple files)\n\n[[ftp-using-ls]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "outbound-gateway", "heading_level": 1, "file_order": 65, "section_index": 0, "content_hash": "3c03d0fe93a4502672d323c32bd764a3bbe11e2d7edaddee2e504998b36cd4b4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:19e420fb530fd2756dbe2a830ac0cf107ed53b44bdb19b06d9539b353a53c78b", "content": "`ls` lists remote files and supports the following options:\n\n* `-1`: Retrieve a list of file names.\nThe default is to retrieve a list of `FileInfo` objects.\n* `-a`: Include all files (including those starting with '.')\n* `-f`: Do not sort the list\n* `-dirs`: Include directories (they are excluded by default)\n* `-links`: Include symbolic links (they are excluded by default)\n* `-R`: List the remote directory recursively\n\nIn addition, filename filtering is provided, in the same manner as the `inbound-channel-adapter`.\nSee xref:ftp/inbound.adoc[FTP Inbound Channel Adapter].\n\nThe message payload resulting from an `ls` operation is a list of file names or a list of `FileInfo` objects.\nThese objects provide information such as modified time, permissions, and other details.\n\nThe remote directory that the `ls` command acted on is provided in the `file_remoteDirectory` header.\n\nWhen using the recursive option (`-R`), the `fileName` includes any subdirectory elements, representing a relative path to the file (relative to the remote directory).\nIf the `-dirs` option is included, each recursive directory is also returned as an element in the list.\nIn this case, it is recommended that you not use the `-1` option, because you would not be able to distinguish files from directories, which you can do with the `FileInfo` objects.\n\nStarting with version 4.3, the `FtpSession` supports `null` for the `list()` and `listNames()` methods.\nTherefore, you can omit the `expression` attribute.\nFor convenience, Java configuration has two constructors that do not have an `expression` argument.\nor `LS`, `NLST`, `PUT` and `MPUT` commands, `null` is treated as the client working directory, according to the FTP protocol.\nAll other commands must be supplied with the `expression` to evaluate the remote path against the request message.\nYou can set the working directory with the `FTPClient.changeWorkingDirectory()` function when you extend the `DefaultFtpSessionFactory` and implement the `postProcessClientAfterConnect()` callback.\n\n[[using-the-nlst-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `ls` Command", "heading_level": 2, "file_order": 65, "section_index": 1, "content_hash": "19e420fb530fd2756dbe2a830ac0cf107ed53b44bdb19b06d9539b353a53c78b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:417b096f8abeb2c8e7cce39150d8c7a499ec9d2a9662cc98a206c58f5f51283f", "content": "Version 5 introduced support for the `nlst` command.\n\n`nlst` lists remote file names and supports only one option:\n\n* `-f`: Do not sort the list\n\nThe message payload resulting from an `nlst` operation is a list of file names.\n\nThe remote directory that the `nlst` command acted on is provided in the `file_remoteDirectory` header.\n\nUnlike the `-1` option for the xref:ftp/outbound-gateway.adoc#ftp-using-ls[`ls` command], which uses the `LIST` command, the `nlst` command sends an `NLST` command to the target FTP server.\nThis command is useful when the server does not support `LIST` (due to security restrictions, for example).\nThe result of the `nlst` operation is the names without another detail.\nTherefore, the framework cannot determine if an entity is a directory, to perform filtering or recursive listing, for example.\n\n[[using-the-get-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `nlst` Command", "heading_level": 2, "file_order": 65, "section_index": 2, "content_hash": "417b096f8abeb2c8e7cce39150d8c7a499ec9d2a9662cc98a206c58f5f51283f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:b524ba528a32a33b5348e00e487bb54bbeb89cce4a09153df8819967b20b4e1c", "content": "`get` retrieves a remote file.\nIt supports the following option:\n\n* `-P`: Preserve the timestamp of the remote file.\n* `-stream`: Retrieve the remote file as a stream.\n\n* `-D`: Delete the remote file after successful transfer.\nThe remote file is not deleted if the transfer is ignored, because the `FileExistsMode` is `IGNORE` and the local file already exists.\n\nThe `file_remoteDirectory` header provides the remote directory name, and the `file_remoteFile` header provides the file name.\n\nThe message payload resulting from a `get` operation is a `File` object that represents the retrieved file or an `InputStream` when you use the `-stream` option.\nThe `-stream` option allows retrieving the file as a stream.\nFor text files, a common use case is to combine this operation with a xref:file/splitter.adoc[file splitter] or a xref:transformer.adoc#stream-transformer[stream transformer].\nWhen consuming remote files as streams, you are responsible for closing the `Session` after the stream is consumed.\nFor convenience, the `Session` is provided in the `closeableResource` header, which you can access with a convenience method on `IntegrationMessageHeaderAccessor`\nThe following example shows how to use the convenience method:\n\n[source, java]\n----\nCloseable closeable = new IntegrationMessageHeaderAccessor(message).getCloseableResource();\nif (closeable != null) {\n closeable.close();\n}\n----\n\nFramework components such as the xref:file/splitter.adoc[file splitter] and the xref:transformer.adoc#stream-transformer[stream transformer] automatically close the session after the data is transferred.\n\nThe following example shows how to consume a file as a stream:\n\n[source, xml]\n----\n<int-ftp:outbound-gateway session-factory=\"ftpSessionFactory\"\n request-channel=\"inboundGetStream\"\n command=\"get\"\n command-options=\"-stream\"\n expression=\"payload\"\n remote-directory=\"ftpTarget\"\n reply-channel=\"stream\" />\n\n<int-file:splitter input-channel=\"stream\" output-channel=\"lines\" />\n----\n\nNOTE: If you consume the input stream in a custom component, you must close the `Session`.\nYou can do so either in your custom code or by routing a copy of the message to a `service-activator` and using SpEL, as the following example shows:\n\n[source, xml]\n----\n<int:service-activator input-channel=\"closeSession\"\n expression=\"headers['closeableResource'].close()\" />\n----\n\n[[using-the-mget-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `get` Command", "heading_level": 2, "file_order": 65, "section_index": 3, "content_hash": "b524ba528a32a33b5348e00e487bb54bbeb89cce4a09153df8819967b20b4e1c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:fe85f2f6e273f099964c4cc3ff5c527efa1db6609464637bb0b296a550ba21dd", "content": "`mget` retrieves multiple remote files based on a pattern and supports the following options:\n\n* `-P`: Preserve the timestamps of the remote files.\n\n* `-R`: Retrieve the entire directory tree recursively.\n\n* `-x`: Throw an exception if no files match the pattern (otherwise an empty list is returned).\n\n* `-D`: Delete each remote file after successful transfer.\nThe remote file is not deleted if the transfer is ignored, because the `FileExistsMode` is `IGNORE` and the local file already exists.\n\nThe message payload resulting from an `mget` operation is a `List<File>` object (that is, a `List` of `File` objects, each representing a retrieved file).\n\nIMPORTANT: Starting with version 5.0, if the `FileExistsMode` is `IGNORE`, the payload of the output message no longer contains files that were not fetched due to the file already existing.\nPreviously, the list contained all files, including those that already existed.\n\nThe expression used to determine the remote path should produce a result that ends with `*` - e.g. `somedir/*` will fetch the complete tree under `somedir`.\n\nStarting with version 5.0, a recursive `mget`, combined with the new `FileExistsMode.REPLACE_IF_MODIFIED` mode, can be used to periodically synchronize an entire remote directory tree locally.\nThis mode replaces the local file's last modified timestamp with the remote timestamp, regardless of the `-P` (preserve timestamp) option.\n\n.Using recursion (`-R`)\n[IMPORTANT]\n=====\nThe pattern is ignored, and `*` is assumed.\nBy default, the entire remote tree is retrieved.\nHowever, files in the tree can be filtered, by providing a `FileListFilter`.\nDirectories in the tree can also be filtered this way.\nA `FileListFilter` can be provided by reference, by `filename-pattern`, or by `filename-regex` attributes.\nFor example, `filename-regex=\"(subDir|.*1.txt)\"` retrieves all files ending with `1.txt` in the remote directory and the `subDir` child directory.\nHowever, the next example shows an alternative, which version 5.0 made available.\n\nIf a subdirectory is filtered, no additional traversal of that subdirectory is performed.\n\nThe `-dirs` option is not allowed (the recursive `mget` uses the recursive `ls` to obtain the directory tree, so the directories themselves cannot be included in the list).\n\nTypically, you would use the `#remoteDirectory` variable in the `local-directory-expression` so that the remote directory structure is retained locally.\n=====\n\nThe persistent file list filters now have a boolean property `forRecursion`.\nSetting this property to `true`, also sets `alwaysAcceptDirectories`, which means that the recursive operation on the outbound gateways (`ls` and `mget`) will now always traverse the full directory tree each time.\nThis is to solve a problem where changes deep in the directory tree were not detected.\nIn addition, `forRecursion=true` causes the full path to files to be used as the metadata store keys; this solves a problem where the filter did not work properly if a file with the same name appears multiple times in different directories.\nIMPORTANT: This means that existing keys in a persistent metadata store will not be found for files beneath the top level directory.\nFor this reason, the property is `false` by default; this may change in a future release.\n\nStarting with version 5.0, the `FtpSimplePatternFileListFilter` and `FtpRegexPatternFileListFilter` can be configured to always pass directories by setting the `alwaysAcceptDirectories` property to `true`.\nDoing so allows recursion for a simple pattern, as the following examples show:\n\n[source, xml]\n----\n<bean id=\"starDotTxtFilter\"\n class=\"org.springframework.integration.ftp.filters.FtpSimplePatternFileListFilter\">\n <constructor-arg value=\"*.txt\" />\n <property name=\"alwaysAcceptDirectories\" value=\"true\" />\n</bean>\n\n<bean id=\"dotStarDotTxtFilter\"\n class=\"org.springframework.integration.ftp.filters.FtpRegexPatternFileListFilter\">\n <constructor-arg value=\"^.*\\.txt$\" />\n <property name=\"alwaysAcceptDirectories\" value=\"true\" />\n</bean>\n----\n\nOnce you have defined filters such as those in the preceding example, you can use one by setting the `filter` property on the gateway.\n\nSee also xref:ftp/outbound-gateway.adoc#ftp-partial[Outbound Gateway Partial Success (`mget` and `mput`)].\n\n[[ftp-put-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `mget` Command", "heading_level": 2, "file_order": 65, "section_index": 4, "content_hash": "fe85f2f6e273f099964c4cc3ff5c527efa1db6609464637bb0b296a550ba21dd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:8f3db72a24f08cdba565c0d4b7ac004a5d1473fa461cbece23bc691b11482bfa", "content": "The `put` command sends a file to the remote server.\nThe payload of the message can be a `java.io.File`, a `byte[]`, or a `String`.\nA `remote-filename-generator` (or expression) is used to name the remote file.\nOther available attributes include `remote-directory`, `temporary-remote-directory`, and their `*-expression` equivalents: `use-temporary-file-name` and `auto-create-directory`.\nSee the https://github.com/spring-projects/spring-integration/tree/main/spring-integration-core/src/main/resources/org/springframework/integration/config[schema] documentation for more information.\n\nThe message payload resulting from a `put` operation is a `String` that represents the full path of the file on the server after transfer.\n\nVersion 5.2 introduced the `chmod` attribute, which changes the remote file permissions after upload.\nYou can use the conventional Unix octal format, for example, `600` allows read-write for the file owner only.\nWhen configuring the adapter using java, you can use `setChmod(0600)`.\nOnly applies if your FTP server supports the `SITE CHMOD` subcommand.\n\n[[using-the-mput-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `put` Command", "heading_level": 2, "file_order": 65, "section_index": 5, "content_hash": "8f3db72a24f08cdba565c0d4b7ac004a5d1473fa461cbece23bc691b11482bfa", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:3413198d5987eb9095b60de3e923cdbde2617646bc8e25c1fecd20335b9b6086", "content": "The `mput` sends multiple files to the server and supports only one option:\n\n* `-R`: Recursive.\nSend all files (possibly filtered) in the directory and its subdirectories.\n\nThe message payload must be a `java.io.File` (or `String`) that represents a local directory.\nSince version 5.1, a collection of `File` or `String` is also supported.\n\nThis command supports the same attributes as the xref:ftp/outbound-gateway.adoc#ftp-put-command[`put` command].\nIn addition, files in the local directory can be filtered with one of `mput-pattern`, `mput-regex`, `mput-filter`, or `mput-filter-expression`.\nThe filter works with recursion, as long as the subdirectories themselves pass the filter.\nSubdirectories that do not pass the filter are not recursed.\n\nThe message payload resulting from an `mput` operation is a `List<String>` object (that is, a `List` of remote file paths that result from the transfer).\n\nSee also xref:ftp/outbound-gateway.adoc#ftp-partial[Outbound Gateway Partial Success (`mget` and `mput`)].\n\nVersion 5.2 introduced the `chmod` attribute, which lets you change the remote file permissions after upload.\nYou can use the conventional Unix octal format, for example, `600` allows read-write for the file owner only.\nWhen configuring the adapter with Java, you can use `setChmodOctal(\"600\")` or `setChmod(0600)`.\nOnly applies if your FTP server supports the `SITE CHMOD` subcommand.\n\n[[using-the-rm-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `mput` Command", "heading_level": 2, "file_order": 65, "section_index": 6, "content_hash": "3413198d5987eb9095b60de3e923cdbde2617646bc8e25c1fecd20335b9b6086", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:6916aa71cff5c7d5e5efa8eeecdd600333631a0822332f7e16d26c3d01930041", "content": "The `rm` command removes files.\n\nThe `rm` command has no options.\n\nThe message payload resulting from an `rm` operation is `Boolean.TRUE` if the remove was successful or `Boolean.FALSE` otherwise.\nThe `file_remoteDirectory` header provides the remote directory, and the `file_remoteFile` header provides the file name.\n\n[[using-the-mv-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `rm` Command", "heading_level": 2, "file_order": 65, "section_index": 7, "content_hash": "6916aa71cff5c7d5e5efa8eeecdd600333631a0822332f7e16d26c3d01930041", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:2ec5b9dfeb3dfbf28038c6945f7441ed14214aec7d65ec33a49b89db54b43824", "content": "The `mv` command moves files.\n\nThe `mv` command has no options.\n\nThe `expression` attribute defines the \"`from`\" path and the `rename-expression` attribute defines the \"`to`\" path.\nBy default, the `rename-expression` is `headers['file_renameTo']`.\nThis expression must not evaluate to null or an empty `String`.\nIf necessary, any necessary remote directories are created.\nThe payload of the result message is `Boolean.TRUE`.\nThe `file_remoteDirectory` header provides the original remote directory, and `file_remoteFile` header provides the file name.\nThe new path is in the `file_renameTo` header.\n\nStarting with version 5.5.6, the `remoteDirectoryExpression` can be used in the `mv` command for convenience.\nIf the \"`from`\" file is not a full file path, the result of `remoteDirectoryExpression` is used as the remote directory.\nThe same applies for the \"`to`\" file, for example, if the task is just to rename a remote file in some directory.\n\n[[additional-information-about-ftp-outbound-gateway-commands]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `mv` Command", "heading_level": 2, "file_order": 65, "section_index": 8, "content_hash": "2ec5b9dfeb3dfbf28038c6945f7441ed14214aec7d65ec33a49b89db54b43824", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:31f675ff06190df56e3412d5243f5778b4388cc6e1b0a07518118c82236a2531", "content": "The `get` and `mget` commands support the `local-filename-generator-expression` attribute.\nIt defines a SpEL expression to generate the name of local files during the transfer.\nThe root object of the evaluation context is the request message.\n The `remoteFileName` variable, which is particularly useful for `mget`, is also available -- for example, `local-filename-generator-expression=\"#remoteFileName.toUpperCase() + headers.something\"`.\n\nThe `get` and `mget` commands support the `local-directory-expression` attribute.\nIt defines a SpEL expression to generate the name of local directories during the transfer.\nThe root object of the evaluation context is the request message but.\nThe `remoteDirectory` variable, which is particularly useful for `mget`, is also available -- for example: `local-directory-expression=\"'/tmp/local/' + #remoteDirectory.toUpperCase() + headers.something\"`.\nThis attribute is mutually exclusive with the `local-directory` attribute.\n\nFor all commands, the 'expression' property of the gateway provides the path on which the command acts.\nFor the `mget` command, the expression might evaluate to '*', meaning to retrieve all files, or 'somedirectory/*', and so on.\n\nThe following example shows a gateway configured for an `ls` command:\n\n[source,xml]\n----\n<int-ftp:outbound-gateway id=\"gateway1\"\n session-factory=\"ftpSessionFactory\"\n request-channel=\"inbound1\"\n command=\"ls\"\n command-options=\"-1\"\n expression=\"payload\"\n reply-channel=\"toSplitter\"/>\n----\n\nThe payload of the message sent to the `toSplitter` channel is a list of `String` objects that each contain the name of a file.\nIf the `command-options` attribute was omitted, it holds `FileInfo` objects.\nIt uses space-delimited options -- for example, `command-options=\"-1 -dirs -links\"`.\n\nStarting with version 4.2, the `GET`, `MGET`, `PUT` and `MPUT` commands support a `FileExistsMode` property (`mode` when using the namespace support).\nThis affects the behavior when the local file exists (`GET` and `MGET`) or the remote file exists (`PUT` and `MPUT`).\nSupported modes are `REPLACE`, `APPEND`, `FAIL`, and `IGNORE`.\nFor backwards compatibility, the default mode for `PUT` and `MPUT` operations is `REPLACE`.\nFor `GET` and `MGET` operations, the default is `FAIL`.\n\nStarting with version 5.0, the `setWorkingDirExpression()` (`working-dir-expression` in XML) option is provided on the `FtpOutboundGateway` (`<int-ftp:outbound-gateway>` in XML).\nIt lets you change the client working directory at runtime.\nThe expression is evaluated against the request message.\nThe previous working directory is restored after each gateway operation.\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Additional Information about FTP Outbound Gateway Commands", "heading_level": 2, "file_order": 65, "section_index": 9, "content_hash": "31f675ff06190df56e3412d5243f5778b4388cc6e1b0a07518118c82236a2531", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:13bb22f2ace597d622205499f2ecbd556ff080a416e79cddfef300dc18be9497", "content": "The following Spring Boot application shows an example of how to configure the outbound gateway with Java configuration:\n\n[source, java]\n----\n@SpringBootApplication\npublic class FtpJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(FtpJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public SessionFactory<FTPFile> ftpSessionFactory() {\n DefaultFtpSessionFactory sf = new DefaultFtpSessionFactory();\n sf.setHost(\"localhost\");\n sf.setPort(port);\n sf.setUsername(\"foo\");\n sf.setPassword(\"foo\");\n sf.setTestSession(true);\n return new CachingSessionFactory<FTPFile>(sf);\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"ftpChannel\")\n public MessageHandler handler() {\n FtpOutboundGateway ftpOutboundGateway =\n new FtpOutboundGateway(ftpSessionFactory(), \"ls\", \"'my_remote_dir/'\");\n ftpOutboundGateway.setOutputChannelName(\"lsReplyChannel\");\n return ftpOutboundGateway;\n }\n\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 65, "section_index": 10, "content_hash": "13bb22f2ace597d622205499f2ecbd556ff080a416e79cddfef300dc18be9497", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:5e33b5d9178d2f1b89317e35d181d734f941ae411eff38c8e7b949a4cc672464", "content": "The following Spring Boot application shows an example of how to configure the outbound gateway with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class FtpJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(FtpJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public SessionFactory<FTPFile> ftpSessionFactory() {\n DefaultFtpSessionFactory sf = new DefaultFtpSessionFactory();\n sf.setHost(\"localhost\");\n sf.setPort(port);\n sf.setUsername(\"foo\");\n sf.setPassword(\"foo\");\n sf.setTestSession(true);\n return new CachingSessionFactory<FTPFile>(sf);\n }\n\n @Bean\n public FtpOutboundGatewaySpec ftpOutboundGateway() {\n return Ftp.outboundGateway(ftpSessionFactory(),\n AbstractRemoteFileOutboundGateway.Command.MGET, \"payload\")\n .options(AbstractRemoteFileOutboundGateway.Option.RECURSIVE)\n .regexFileNameFilter(\"(subFtpSource|.*1.txt)\")\n .localDirectoryExpression(\"'localDirectory/' + #remoteDirectory\")\n .localFilenameExpression(\"#remoteFileName.replaceFirst('ftpSource', 'localTarget')\");\n }\n\n @Bean\n public IntegrationFlow ftpMGetFlow(AbstractRemoteFileOutboundGateway<FTPFile> ftpOutboundGateway) {\n return f -> f\n .handle(ftpOutboundGateway)\n .channel(c -> c.queue(\"remoteFileOutputChannel\"));\n }\n\n}\n----\n\n[[ftp-partial]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 65, "section_index": 11, "content_hash": "5e33b5d9178d2f1b89317e35d181d734f941ae411eff38c8e7b949a4cc672464", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:5365efd5d8a3176e8e3de7775ff3d4749814ff32e78ce22184dc74730e6daa39", "content": "When you perform operations on multiple files (by using `mget` and `mput`), an exception can occur some time after one or more files have been transferred.\nIn this case (starting with version 4.2), a `PartialSuccessException` is thrown.\nAs well as the usual `MessagingException` properties (`failedMessage` and `cause`), this exception has two additional properties:\n\n* `partialResults`: The successful transfer results.\n* `derivedInput`: The list of files generated from the request message, for example, local files to transfer for an `mput`.\n\nThese attributes let you determine which files were successfully transferred and which were not.\n\nIn the case of a recursive `mput`, the `PartialSuccessException` may have nested `PartialSuccessException` occurrences.\n\nConsider the following directory structure:\n\n[source]\n----\nroot/\n|- file1.txt\n|- subdir/\n | - file2.txt\n | - file3.txt\n|- zoo.txt\n----\n\nIf the exception occurs on `file3.txt`, the `PartialSuccessException` thrown by the gateway has `derivedInput` of `file1.txt`, `subdir`, and `zoo.txt` and `partialResults` of `file1.txt`.\nIts `cause` is another `PartialSuccessException` with `derivedInput` of `file2.txt` and `file3.txt` and `partialResults` of `file2.txt`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Outbound Gateway Partial Success (`mget` and `mput`)", "heading_level": 2, "file_order": 65, "section_index": 12, "content_hash": "5365efd5d8a3176e8e3de7775ff3d4749814ff32e78ce22184dc74730e6daa39", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound-gateway.adoc"}}
{"id": "sha256:b786c3442ed8e0e509fcbde0b69edec701f6897af5245e07474a30bc65ceac10", "content": "[[ftp-outbound]]\n\nThe FTP outbound channel adapter relies on a `MessageHandler` implementation that connects to the FTP server and initiates an FTP transfer for every file it receives in the payload of incoming messages.\nIt also supports several representations of a file, so you are not limited only to `java.io.File`-typed payloads.\nThe FTP outbound channel adapter supports the following payloads:\n\n* `java.io.File`: The actual file object\n* `byte[]`: A byte array that represents the file contents\n* `java.lang.String`: Text that represents the file contents\n* `java.io.InputStream`: a stream of data to transfer to remote file\n* `org.springframework.core.io.Resource`: a resource for data to transfer to remote file\n\nThe following example shows how to configure an `outbound-channel-adapter`:\n\n[source,xml]\n----\n<int-ftp:outbound-channel-adapter id=\"ftpOutbound\"\n channel=\"ftpChannel\"\n session-factory=\"ftpSessionFactory\"\n charset=\"UTF-8\"\n remote-file-separator=\"/\"\n auto-create-directory=\"true\"\n remote-directory-expression=\"headers['remote_dir']\"\n temporary-remote-directory-expression=\"headers['temp_remote_dir']\"\n filename-generator=\"fileNameGenerator\"\n use-temporary-filename=\"true\"\n chmod=\"600\"\n mode=\"REPLACE\"/>\n----\n\nThe preceding configuration shows how you can configure an FTP outbound channel adapter by using the `outbound-channel-adapter` element while also providing values for various attributes, such as `filename-generator` (an implementation of the `o.s.i.file.FileNameGenerator` strategy interface), a reference to a `session-factory`, and other attributes.\nYou can also see some examples of `*expression` attributes that let you use SpEL to configure settings such as `remote-directory-expression`, `temporary-remote-directory-expression`, and `remote-filename-generator-expression` (a SpEL alternative to `filename-generator`, shown in the preceding example).\nAs with any component that allows the usage of SpEL, access to the payload and the message Headers is available through the 'payload' and 'headers' variables.\nSee the https://github.com/spring-projects/spring-integration/tree/main/spring-integration-core/src/main/resources/org/springframework/integration/config[schema] for more details on the available attributes.\n\nNOTE: By default, if no file name generator is specified, Spring Integration uses `o.s.i.file.DefaultFileNameGenerator`.\n`DefaultFileNameGenerator` determines the file name based on the value of the `file_name` header (if it exists) in the `MessageHeaders`, or, if the payload of the Message is already a `java.io.File`, it uses the original name of that file.\n\nIMPORTANT: Defining certain values (such as `remote-directory`) might be platform- or FTP server-dependent.\nFor example, as was reported on https://forum.spring.io/showthread.php?p=333478&posted=1#post333478, on some platforms, you must add a slash to the end of the directory definition (for example, `remote-directory=\"/thing1/thing2/\"` instead of `remote-directory=\"/thing1/thing2\"`).\n\nStarting with version 4.1, you can specify the `mode` when transferring the file.\nBy default, an existing file is overwritten.\nThe modes are defined by the `FileExistsMode` enumeration, which includes the following values:\n\n* `REPLACE` (default)\n* `REPLACE_IF_MODIFIED`\n* `APPEND`\n* `APPEND_NO_FLUSH`\n* `IGNORE`\n* `FAIL`\n\n`IGNORE` and `FAIL` do not transfer the file.\n`FAIL` causes an exception to be thrown, while `IGNORE` silently ignores the transfer (although a `DEBUG` log entry is produced).\n\nVersion 5.2 introduced the `chmod` attribute, which you can use to change the remote file permissions after upload.\nYou can use the conventional Unix octal format, (for example, `600` allows read-write for the file owner only).\nWhen configuring the adapter using java, you can use `setChmodOctal(\"600\")` or `setChmod(0600)`.\nOnly applies if your FTP server supports the `SITE CHMOD` subcommand.\n\n[[avoiding-partially-written-files]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound.adoc", "title": "outbound", "heading": "outbound", "heading_level": 1, "file_order": 66, "section_index": 0, "content_hash": "b786c3442ed8e0e509fcbde0b69edec701f6897af5245e07474a30bc65ceac10", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound.adoc"}}
{"id": "sha256:cb1b0b990cba295a878cccdcec1fe0b1e9fb41359b6cc1f52c762027e43e57d7", "content": "One of the common problems that arises when dealing with file transfers is the possibility of processing a partial file.\nThat is, a file might appear in the file system before its transfer is actually complete.\n\nTo deal with this issue, Spring Integration FTP adapters use a common algorithm: Files are transferred under a temporary name and then renamed once they are fully transferred.\n\nBy default, every file that is in the process of being transferred appears in the file system with an additional suffix, which, by default, is `.writing`.\nYou can change this suffix by setting the `temporary-file-suffix` attribute.\n\nHowever, there may be situations where you do not want to use this technique, for example, if the server does not permit renaming files.\nFor situations like this, you can disable this feature by setting `use-temporary-file-name` to `false` (the default is `true`).\nWhen this attribute is `false`, the file is written with its final name and the consuming application needs some other mechanism to detect that the file is completely uploaded before accessing it.\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound.adoc", "title": "outbound", "heading": "Avoiding Partially Written Files", "heading_level": 2, "file_order": 66, "section_index": 1, "content_hash": "cb1b0b990cba295a878cccdcec1fe0b1e9fb41359b6cc1f52c762027e43e57d7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound.adoc"}}
{"id": "sha256:de2eb8f3af5f0c4d4487b42b550fdaf12bd4461b8fdcd03b30cfe48382a703ff", "content": "The following Spring Boot application shows an example of how to configure the outbound adapter with Java configuration:\n\n[source, java]\n----\n@SpringBootApplication\n@IntegrationComponentScan\npublic class FtpJavaApplication {\n\n public static void main(String[] args) {\n ConfigurableApplicationContext context =\n new SpringApplicationBuilder(FtpJavaApplication.class)\n .web(false)\n .run(args);\n MyGateway gateway = context.getBean(MyGateway.class);\n gateway.sendToFtp(new File(\"/foo/bar.txt\"));\n }\n\n @Bean\n public SessionFactory<FTPFile> ftpSessionFactory() {\n DefaultFtpSessionFactory sf = new DefaultFtpSessionFactory();\n sf.setHost(\"localhost\");\n sf.setPort(port);\n sf.setUsername(\"foo\");\n sf.setPassword(\"foo\");\n sf.setTestSession(true);\n return new CachingSessionFactory<FTPFile>(sf);\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"ftpChannel\")\n public MessageHandler handler() {\n FtpMessageHandler handler = new FtpMessageHandler(ftpSessionFactory());\n handler.setRemoteDirectoryExpressionString(\"headers['remote-target-dir']\");\n handler.setFileNameGenerator(new FileNameGenerator() {\n\n @Override\n public String generateFileName(Message<?> message) {\n return \"handlerContent.test\";\n }\n\n });\n return handler;\n }\n\n @MessagingGateway\n public interface MyGateway {\n\n @Gateway(requestChannel = \"toFtpChannel\")\n void sendToFtp(File file);\n\n }\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound.adoc", "title": "outbound", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 66, "section_index": 2, "content_hash": "de2eb8f3af5f0c4d4487b42b550fdaf12bd4461b8fdcd03b30cfe48382a703ff", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound.adoc"}}
{"id": "sha256:3ccc03627bd2105375005166e97ee3ebdb92f745c1b75a9adc28e9c0aa1e3939", "content": "The following Spring Boot application shows an example of how to configure the outbound adapter using the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\n@IntegrationComponentScan\npublic class FtpJavaApplication {\n\n public static void main(String[] args) {\n ConfigurableApplicationContext context =\n new SpringApplicationBuilder(FtpJavaApplication.class)\n .web(false)\n .run(args);\n MyGateway gateway = context.getBean(MyGateway.class);\n gateway.sendToFtp(new File(\"/foo/bar.txt\"));\n }\n\n @Bean\n public SessionFactory<FTPFile> ftpSessionFactory() {\n DefaultFtpSessionFactory sf = new DefaultFtpSessionFactory();\n sf.setHost(\"localhost\");\n sf.setPort(port);\n sf.setUsername(\"foo\");\n sf.setPassword(\"foo\");\n sf.setTestSession(true);\n return new CachingSessionFactory<FTPFile>(sf);\n }\n\n @Bean\n public IntegrationFlow ftpOutboundFlow() {\n return IntegrationFlow.from(\"toFtpChannel\")\n .handle(Ftp.outboundAdapter(ftpSessionFactory(), FileExistsMode.FAIL)\n .useTemporaryFileName(false)\n .fileNameExpression(\"headers['\" + FileHeaders.FILENAME + \"']\")\n .remoteDirectory(this.ftpServer.getTargetFtpDirectory().getName())\n ).get();\n }\n\n @MessagingGateway\n public interface MyGateway {\n\n @Gateway(requestChannel = \"toFtpChannel\")\n void sendToFtp(File file);\n\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/outbound.adoc", "title": "outbound", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 66, "section_index": 3, "content_hash": "3ccc03627bd2105375005166e97ee3ebdb92f745c1b75a9adc28e9c0aa1e3939", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/outbound.adoc"}}
{"id": "sha256:ac8431326b52a837572741e78c6b8805e6812163357c822e75d1b03532b86928", "content": "[[ftp-remote-file-info]]\n\nStarting with version 5.2, the `FtpStreamingMessageSource` (xref:ftp/streaming.adoc[FTP Streaming Inbound Channel Adapter]), `FtpInboundFileSynchronizingMessageSource` (xref:ftp/inbound.adoc[FTP Inbound Channel Adapter]) and \"read\"-commands of the `FtpOutboundGateway` (xref:ftp/outbound-gateway.adoc[FTP Outbound Gateway]) provide additional headers in the message to produce with an information about the remote file:\n\n* `FileHeaders.REMOTE_HOST_PORT` - the host:port pair the remote session has been connected to during file transfer operation;\n* `FileHeaders.REMOTE_DIRECTORY` - the remote directory the operation has been performed;\n* `FileHeaders.REMOTE_FILE` - the remote file name; applicable only for single file operations.\n\nSince the `FtpInboundFileSynchronizingMessageSource` doesn't produce messages against remote files, but using a local copy, the `AbstractInboundFileSynchronizer` stores an information about remote file in the `MetadataStore` (which can be configured externally) in the URI style (`protocol://host:port/remoteDirectory#remoteFileName`) during synchronization operation.\nThis metadata is retrieved by the `FtpInboundFileSynchronizingMessageSource` when a local file is polled.\nWhen a local file is deleted, it is recommended to remove its metadata entry.\nThe `AbstractInboundFileSynchronizer` provides a `removeRemoteFileMetadata()` callback for this purpose.\nIn addition, there is a `setMetadataStorePrefix()` to be used in the metadata keys.\nIt is recommended to have this prefix be different from the one used in the `MetadataStore`-based `FileListFilter` implementations, when the same `MetadataStore` instance is shared between these components, to avoid entry overriding because both filter and `AbstractInboundFileSynchronizer` use the same local file name for the metadata entry key.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/remote-file-info.adoc", "title": "remote-file-info", "heading": "remote-file-info", "heading_level": 1, "file_order": 67, "section_index": 0, "content_hash": "ac8431326b52a837572741e78c6b8805e6812163357c822e75d1b03532b86928", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/remote-file-info.adoc"}}
{"id": "sha256:fe533ecfa6eaa1d0a66ab7c66e3b5549f0957ac9f7d1a966e93ef39800804190", "content": "[[ftp-rft]]\n\nStarting with Spring Integration 3.0, a new abstraction is provided over the `FtpSession` object.\nThe template provides methods to send, retrieve (as an `InputStream`), remove, and rename files.\nIn addition, an `execute` method is provided allowing the caller to execute multiple operations on the session.\nIn all cases, the template takes care of reliably closing the session.\nFor more information, see the\nhttps://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/RemoteFileTemplate.html[Javadoc for `RemoteFileTemplate`].\nThere is a subclass for FTP: `FtpRemoteFileTemplate`.\n\nVersion 4.1 added additional methods, including `getClientInstance()`, which provides access to the underlying `FTPClient` and thus gives you access to low-level APIs.\n\nNot all FTP servers properly implement the `STAT <path>` command.\nSome return a positive result for a non-existent path.\nThe `NLST` command reliably returns the name when the path is a file, and it exists.\nHowever, this does not support checking that an empty directory exists since `NLST` always returns an empty list when the path is a directory.\nSince the template does not know whether the path represents a directory, it has to perform additional checks when the path does not appear to exist (when using `NLST`).\nThis adds overhead, requiring several requests to the server.\nStarting with version 4.1.9, the `FtpRemoteFileTemplate` provides the `FtpRemoteFileTemplate.ExistsMode` property, which has the following options:\n\n* `STAT`: Perform the `STAT` FTP command (`FTPClient.getStatus(path)`) to check the path existence.\nThis is the default and requires that your FTP server properly support the `STAT` command (with a path).\n* `NLST`: Perform the `NLST` FTP command -- `FTPClient.listName(path)`.\nUse this if you are testing for a path that is a full path to a file.\nIt does not work for empty directories.\n* `NLST_AND_DIRS`: Perform the `NLST` command first and, if it returns no files, fall back to a technique that temporarily switches the working directory by using `FTPClient.changeWorkingDirectory(path)`.\nSee https://docs.spring.io/spring-integration/api/org/springframework/integration/ftp/session/FtpSession.html#exists[`FtpSession.exists()`] for more information.\n\nSince we know that the `FileExistsMode.FAIL` case is always only looking for a file (and not a directory), we safely use `NLST` mode for the `FtpMessageHandler` and `FtpOutboundGateway` components.\n\nFor any other cases, the `FtpRemoteFileTemplate` can be extended to implement custom logic in the overridden `exist()` method.\n\nStarting with version 5.0, the new `RemoteFileOperations.invoke(OperationsCallback<F, T> action)` method is available.\nThis method lets several `RemoteFileOperations` calls be called in the scope of the same, thread-bounded, `Session`.\nThis is useful when you need to perform several high-level operations of the `RemoteFileTemplate` as one unit of work.\nFor example, `AbstractRemoteFileOutboundGateway` uses it with the `mput` command implementation, where we perform a `put` operation for each file in the provided directory and recursively for its sub-directories.\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/RemoteFileOperations.html#invoke[Javadoc] for more information.\n\nStarting with version 6.5, the `AbstractRemoteFileOutboundGateway` supports dynamic resolution of `FileExistsMode` at runtime via SpEL expressions.\nThis allows you to determine the action to take when files already exist based on message content or other conditions.\n\nTo use this feature, configure the `fileExistsModeExpression` property on the gateway.\nThe expression can evaluate to:\n\n* A `FileExistsMode` enum value (e.g., `FileExistsMode.REPLACE`)\n* A string representation of a `FileExistsMode` (case-insensitive, e.g., \"REPLACE\", \"append\")\n\nIf the expression returns `null`, the default `fileExistsMode` configured on the gateway will be used.\n\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/gateway/AbstractRemoteFileOutboundGateway.html#setFileExistsModeExpression(org.springframework.expression.Expression)[Javadoc] for more information.\n\n[IMPORTANT]\n====\nWhen using `FileExistsMode.APPEND`, temporary filename functionality is automatically disabled regardless of the `useTemporaryFileName` setting.\nThis is because appending to a temporary file and then renaming it would not achieve the intended `append` behavior.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/rft.adoc", "title": "rft", "heading": "rft", "heading_level": 1, "file_order": 68, "section_index": 0, "content_hash": "fe533ecfa6eaa1d0a66ab7c66e3b5549f0957ac9f7d1a966e93ef39800804190", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/rft.adoc"}}
{"id": "sha256:5faad5ccf764cef0db34f250af0b9b8ddec48c485e1b5bc3e6d4a76a0339de21", "content": "[[ftp-rotating-server-advice]]\n\nStarting with version 5.0.7, the `RotatingServerAdvice` is available; when configured as a poller advice, the inbound adapters can poll multiple servers and directories.\nConfigure the advice and add it to the poller's advice chain as normal.\nA `DelegatingSessionFactory` is used to select the server see xref:ftp/dsf.adoc[Delegating Session Factory] for more information.\nThe advice configuration consists of a list of `RotationPolicy.KeyDirectory` objects.\n\n.Example\n[source, java]\n----\n@Bean\npublic RotatingServerAdvice advice() {\n List<RotationPolicy.KeyDirectory> keyDirectories = new ArrayList<>();\n keyDirectories.add(new RotationPolicy.KeyDirectory(\"one\", \"foo\"));\n keyDirectories.add(new RotationPolicy.KeyDirectory(\"one\", \"bar\"));\n keyDirectories.add(new RotationPolicy.KeyDirectory(\"two\", \"baz\"));\n keyDirectories.add(new RotationPolicy.KeyDirectory(\"two\", \"qux\"));\n keyDirectories.add(new RotationPolicy.KeyDirectory(\"three\", \"fiz\"));\n keyDirectories.add(new RotationPolicy.KeyDirectory(\"three\", \"buz\"));\n return new RotatingServerAdvice(delegatingSf(), keyDirectories);\n}\n----\n\nThis advice will poll directory `foo` on server `one` until no new files exist then move to directory `bar` and then directory `baz` on server `two`, etc.\n\nThis default behavior can be modified with the `fair` constructor arg:\n\n.fair\n[source, java]\n----\n@Bean\npublic RotatingServerAdvice advice() {\n ...\n return new RotatingServerAdvice(delegatingSf(), keyDirectories, true);\n}\n----\n\nIn this case, the advice will move to the next server/directory regardless of whether the previous poll returned a file.\n\nAlternatively, you can provide your own `RotationPolicy` to reconfigure the message source as needed:\n\n.policy\n[source, java]\n----\npublic interface RotationPolicy {\n\n void beforeReceive(MessageSource<?> source);\n\n void afterReceive(boolean messageReceived, MessageSource<?> source);\n\n}\n----\n\nand\n\n.custom\n[source, java]\n----\n@Bean\npublic RotatingServerAdvice advice() {\n return new RotatingServerAdvice(myRotationPolicy());\n}\n----\n\nThe `local-filename-generator-expression` attribute (`localFilenameGeneratorExpression` on the synchronizer) can now contain the `#remoteDirectory` variable.\nThis allows files retrieved from different directories to be downloaded to similar directories locally:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow flow() {\n return IntegrationFlow.from(Ftp.inboundAdapter(sf())\n .filter(new FtpPersistentAcceptOnceFileListFilter(new SimpleMetadataStore(), \"rotate\"))\n .localDirectory(new File(tmpDir))\n .localFilenameExpression(\"#remoteDirectory + T(java.io.File).separator + #root\")\n .remoteDirectory(\".\"),\n e -> e.poller(Pollers.fixedDelay(1).advice(advice())))\n .channel(MessageChannels.queue(\"files\"))\n .get();\n}\n----\n\nIMPORTANT: Do not configure a `TaskExecutor` on the poller when using this advice; see xref:changes-4.1-4.2.adoc#x4.2-conditional-pollers[Conditional Pollers for Message Sources] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/rotating-server-advice.adoc", "title": "rotating-server-advice", "heading": "rotating-server-advice", "heading_level": 1, "file_order": 69, "section_index": 0, "content_hash": "5faad5ccf764cef0db34f250af0b9b8ddec48c485e1b5bc3e6d4a76a0339de21", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/rotating-server-advice.adoc"}}
{"id": "sha256:b9a8d2fc74596f4cc3ccb31615a014cfeb0e129daf5951c79a72509de431e0c0", "content": "[[ftp-server-events]]\n\nThe `ApacheMinaFtplet`, added in version 5.2, listens for certain Apache Mina FTP server events and publishes them as ``ApplicationEvent``s which can be received by any `ApplicationListener` bean, `@EventListener` bean method, or xref:event.adoc#appevent-inbound[Event Inbound Channel Adapter].\n\nCurrently, supported events are:\n\n* `SessionOpenedEvent` - a client session was opened\n* `DirectoryCreatedEvent` - a directory was created\n* `FileWrittenEvent` - a file was written to\n* `PathMovedEvent` - a file or directory was renamed\n* `PathRemovedEvent` - a file or directory was removed\n* `SessionClosedEvent` - the client has disconnected\n\nEach of these is a subclass of `ApacheMinaFtpEvent`; you can configure a single listener to receive all the event types.\nThe `source` property of each event is a `FtpSession`, from which you can obtain information such as the client address; a convenient `getSession()` method is provided on the abstract event.\n\nEvents other than session open/close have another property `FtpRequest` which has properties such as the command and arguments.\n\nTo configure the server with the listener, (which must be a Spring bean), add it to the server factory:\n\n[source, java]\n----\nFtpServerFactory serverFactory = new FtpServerFactory();\n...\nListenerFactory factory = new ListenerFactory();\n...\nserverFactory.addListener(\"default\", factory.createListener());\nserverFactory.setFtplets(new HashMap<>(Collections.singletonMap(\"springFtplet\", apacheMinaFtpletBean)));\nserver = serverFactory.createServer();\nserver.start();\n----\n\nTo consume these events using a Spring Integration event adapter:\n\n[source, java]\n----\n@Bean\npublic ApplicationEventListeningMessageProducer eventsAdapter() {\n ApplicationEventListeningMessageProducer producer =\n new ApplicationEventListeningMessageProducer();\n producer.setEventTypes(ApacheMinaFtpEvent.class);\n producer.setOutputChannel(eventChannel());\n return producer;\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/server-events.adoc", "title": "server-events", "heading": "server-events", "heading_level": 1, "file_order": 70, "section_index": 0, "content_hash": "b9a8d2fc74596f4cc3ccb31615a014cfeb0e129daf5951c79a72509de431e0c0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/server-events.adoc"}}
{"id": "sha256:2c970c09d80a5e47183fc2193edad96bbc65b4447ab5463c3d34402b12181d32", "content": "[[ftp-session-caching]]\n\nIMPORTANT: Starting with Spring Integration 3.0, sessions are no longer cached by default.\nThe `cache-sessions` attribute is no longer supported on endpoints.\nYou must use a `CachingSessionFactory` (shown in the next example) if you wish to cache sessions.\n\nIn versions prior to 3.0, the sessions were automatically cached by default.\nA `cache-sessions` attribute was available for disabling the auto caching, but that solution did not provide a way to configure other session caching attributes.\nFor example, you could not limit the number of sessions created.\nTo support that requirement and other configuration options, a `CachingSessionFactory` was added.\nIt provides `sessionCacheSize` and `sessionWaitTimeout` properties.\nThe `sessionCacheSize` property controls how many active sessions the factory maintains in its cache (the default is unbounded).\nIf the `sessionCacheSize` threshold has been reached, any attempt to acquire another session blocks until either one of the cached sessions becomes available or until the wait time for a session expires (the default wait time is `Integer.MAX_VALUE`).\nThe `sessionWaitTimeout` property configures that value.\n\nIf you want your sessions to be cached, configure your default session factory as described earlier and then wrap it in an instance of `CachingSessionFactory`, where you can provide those additional properties.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<bean id=\"ftpSessionFactory\" class=\"o.s.i.ftp.session.DefaultFtpSessionFactory\">\n <property name=\"host\" value=\"localhost\"/>\n</bean>\n\n<bean id=\"cachingSessionFactory\" class=\"o.s.i.file.remote.session.CachingSessionFactory\">\n <constructor-arg ref=\"ftpSessionFactory\"/>\n <constructor-arg value=\"10\"/>\n <property name=\"sessionWaitTimeout\" value=\"1000\"/>\n</bean>\n----\n\nThe preceding example shows a `CachingSessionFactory` created with the `sessionCacheSize` set to `10` and the `sessionWaitTimeout` set to one second (its value is in milliseconds).\n\nStarting with Spring Integration 3.0, the `CachingConnectionFactory` provides a `resetCache()` method.\nWhen invoked, all idle sessions are immediately closed and in-use sessions are closed when they are returned to the cache.\nNew requests for sessions establish new sessions as necessary.\n\nStarting with version 5.1, the `CachingSessionFactory` has a new property `testSession`.\nWhen true, the session will be tested by sending a NOOP command to ensure it is still active; if not, it will be removed from the cache; a new session is created if no active sessions are in the cache.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/session-caching.adoc", "title": "session-caching", "heading": "session-caching", "heading_level": 1, "file_order": 71, "section_index": 0, "content_hash": "2c970c09d80a5e47183fc2193edad96bbc65b4447ab5463c3d34402b12181d32", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/session-caching.adoc"}}
{"id": "sha256:ec305b40bd97363686ee806efdcc71c378360766966b6d185d0eac3d80cd4f04", "content": "[[ftp-session-callback]]\n\nStarting with Spring Integration 4.2, you can use a `MessageSessionCallback<F, T>` implementation with the `<int-ftp:outbound-gateway/>` (`FtpOutboundGateway` in Java) to perform any operations on the `Session<FTPFile>` with the `requestMessage` context.\nIt can be used for any non-standard or low-level FTP operations and allows access to an integration flow definition and functional interface (Lambda) implementation injection, as the following example shows:\n\n[source,java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"ftpChannel\")\npublic MessageHandler ftpOutboundGateway(SessionFactory<FTPFile> sessionFactory) {\n return new FtpOutboundGateway(sessionFactory,\n (session, requestMessage) -> session.list(requestMessage.getPayload()));\n}\n----\n\nAnother example might be to pre- or post-process the file data being sent or retrieved.\n\nWhen using XML configuration, the `<int-ftp:outbound-gateway/>` provides a `session-callback` attribute to let you specify the `MessageSessionCallback` bean name.\n\nNOTE: The `session-callback` is mutually exclusive with the `command` and `expression` attributes.\nWhen configuring with Java, different constructors are available in the https://docs.spring.io/spring-integration/api/org/springframework/integration/ftp/outbound/FtpOutboundGateway.html[`FtpOutboundGateway`] class.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/session-callback.adoc", "title": "session-callback", "heading": "session-callback", "heading_level": 1, "file_order": 72, "section_index": 0, "content_hash": "ec305b40bd97363686ee806efdcc71c378360766966b6d185d0eac3d80cd4f04", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/session-callback.adoc"}}
{"id": "sha256:67235003bdd414b0c2064868de5e728ca4eebbe7d5118f7db11310332473a7f6", "content": "[[ftp-session-factory]]\n\nSpring Integration provides factories you can use to create FTP (or FTPS) sessions.\n\n[[default-factories]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/session-factory.adoc", "title": "session-factory", "heading": "session-factory", "heading_level": 1, "file_order": 73, "section_index": 0, "content_hash": "67235003bdd414b0c2064868de5e728ca4eebbe7d5118f7db11310332473a7f6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/session-factory.adoc"}}
{"id": "sha256:b56837ee56d7a53e653cbbeb92ab18b42d9646ade05fba9d1868099b28a28407", "content": "IMPORTANT: Starting with version 3.0, sessions are no longer cached by default.\nSee xref:ftp/session-caching.adoc[FTP Session Caching].\n\nBefore configuring FTP adapters, you must configure an FTP session factory.\nYou can configure the FTP Session Factory with a regular bean definition where the implementation class is `o.s.i.ftp.session.DefaultFtpSessionFactory`.\nThe following example shows a basic configuration:\n\n[source,xml]\n----\n<bean id=\"ftpClientFactory\"\n class=\"org.springframework.integration.ftp.session.DefaultFtpSessionFactory\">\n <property name=\"host\" value=\"localhost\"/>\n <property name=\"port\" value=\"22\"/>\n <property name=\"username\" value=\"kermit\"/>\n <property name=\"password\" value=\"frog\"/>\n <property name=\"clientMode\" value=\"0\"/>\n <property name=\"fileType\" value=\"2\"/>\n <property name=\"bufferSize\" value=\"100000\"/>\n</bean>\n----\n\nFor FTPS connections, you can use `o.s.i.ftp.session.DefaultFtpsSessionFactory` instead.\n\nThe following example shows a complete configuration:\n\n[source,xml]\n----\n<bean id=\"ftpClientFactory\"\n class=\"org.springframework.integration.ftp.session.DefaultFtpsSessionFactory\">\n <property name=\"host\" value=\"localhost\"/>\n <property name=\"port\" value=\"22\"/>\n <property name=\"username\" value=\"oleg\"/>\n <property name=\"password\" value=\"password\"/>\n <property name=\"clientMode\" value=\"1\"/>\n <property name=\"fileType\" value=\"2\"/>\n <property name=\"useClientMode\" value=\"true\"/>\n <property name=\"cipherSuites\" value=\"a,b.c\"/>\n <property name=\"keyManager\" ref=\"keyManager\"/>\n <property name=\"protocol\" value=\"SSL\"/>\n <property name=\"trustManager\" ref=\"trustManager\"/>\n <property name=\"prot\" value=\"P\"/>\n <property name=\"needClientAuth\" value=\"true\"/>\n <property name=\"authValue\" value=\"oleg\"/>\n <property name=\"sessionCreation\" value=\"true\"/>\n <property name=\"protocols\" value=\"SSL, TLS\"/>\n <property name=\"implicit\" value=\"true\"/>\n</bean>\n----\n\nNOTE: If you experience connectivity problems and would like to trace session creation as well as see which sessions are polled, you can enable session tracing by setting the logger to the `TRACE` level (for example, `log4j.category.org.springframework.integration.file=TRACE`).\n\nNow you need only inject these session factories into your adapters.\nThe protocol (FTP or FTPS) that an adapter uses depends on the type of session factory that has been injected into the adapter.\n\nNOTE: A more practical way to provide values for FTP or FTPS session factories is to use Spring's property placeholder support (See https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-placeholderconfigurer).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/session-factory.adoc", "title": "session-factory", "heading": "Default Factories", "heading_level": 2, "file_order": 73, "section_index": 1, "content_hash": "b56837ee56d7a53e653cbbeb92ab18b42d9646ade05fba9d1868099b28a28407", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/session-factory.adoc"}}
{"id": "sha256:9539fa0e6d51ddd1b339cf9cdcb367d41bdc42e472d18ceefcfb8c02ac2d5f7a", "content": "[[ftp-streaming]]\n\nVersion 4.3 introduced the streaming inbound channel adapter.\nThis adapter produces a message with payloads of type `InputStream`, letting files be fetched without writing to the local file system.\nSince the session remains open, the consuming application is responsible for closing the session when the file has been consumed.\nThe session is provided in the `closeableResource` header (`IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE`).\nStandard framework components, such as the `FileSplitter` and `StreamTransformer`, automatically close the session.\nSee xref:file/splitter.adoc[File Splitter] and xref:transformer.adoc#stream-transformer[Stream Transformer] for more information about these components.\nThe following example shows how to configure an `inbound-streaming-channel-adapter`:\n\n[source, xml]\n----\n<int-ftp:inbound-streaming-channel-adapter id=\"ftpInbound\"\n channel=\"ftpChannel\"\n session-factory=\"sessionFactory\"\n filename-pattern=\"*.txt\"\n filename-regex=\".*\\.txt\"\n filter=\"filter\"\n filter-expression=\"@myFilterBean.check(#root)\"\n remote-file-separator=\"/\"\n comparator=\"comparator\"\n max-fetch-size=\"1\"\n remote-directory-expression=\"'foo/bar'\">\n <int:poller fixed-rate=\"1000\" />\n</int-ftp:inbound-streaming-channel-adapter>\n----\n\nOnly one of `filename-pattern`, `filename-regex`, `filter`, or `filter-expression` is allowed.\n\nIMPORTANT: Starting with version 5.0, by default, the `FtpStreamingMessageSource` adapter prevents duplicates for remote files with `FtpPersistentAcceptOnceFileListFilter` based on the in-memory `SimpleMetadataStore`.\nBy default, this filter is also applied with the filename pattern (or regex).\nIf you need to allow duplicates, you can use `AcceptAllFileListFilter`.\nAny other use cases can be handled by `CompositeFileListFilter` (or `ChainFileListFilter`).\nThe Java configuration (xref:ftp/streaming.adoc#ftp-streaming-java[later in the document]) shows one technique to remove the remote file after processing to avoid duplicates.\n\nFor more information about the `FtpPersistentAcceptOnceFileListFilter`, and how it is used, see xref:file/remote-persistent-flf.adoc[Remote Persistent File List Filters].\n\nUse the `max-fetch-size` attribute to limit the number of files fetched on each poll when a fetch is necessary.\nSet it to `1` and use a persistent filter when running in a clustered environment.\nSee xref:ftp/max-fetch.adoc[Inbound Channel Adapters: Controlling Remote File Fetching] for more information.\n\nThe adapter puts the remote directory and file name in the `FileHeaders.REMOTE_DIRECTORY` and `FileHeaders.REMOTE_FILE` headers, respectively.\nStarting with version 5.0, the `FileHeaders.REMOTE_FILE_INFO` header provides additional remote file information (represented in JSON by default).\nIf you set the `fileInfoJson` property on the `FtpStreamingMessageSource` to `false`, the header contains an `FtpFileInfo` object.\nThe `FTPFile` object provided by the underlying Apache Net library can be accessed by using the `FtpFileInfo.getFileInfo()` method.\nThe `fileInfoJson` property is not available when you use XML configuration, but you can set it by injecting the `FtpStreamingMessageSource` into one of your configuration classes.\nSee also xref:ftp/remote-file-info.adoc[Remote File Information].\n\nStarting with version 5.1, the generic type of the `comparator` is `FTPFile`.\nPreviously, it was `AbstractFileInfo<FTPFile>`.\nThis is because the sort is now performed earlier in the processing, before filtering and applying `maxFetch`.\n\n[[ftp-streaming-java]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/streaming.adoc", "title": "streaming", "heading": "streaming", "heading_level": 1, "file_order": 74, "section_index": 0, "content_hash": "9539fa0e6d51ddd1b339cf9cdcb367d41bdc42e472d18ceefcfb8c02ac2d5f7a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/streaming.adoc"}}
{"id": "sha256:ad74905c5d88282aa30f6e49d9718d3857544114e5fca4c53fe732e7ea7bbed2", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with Java configuration:\n\n[source, java]\n----\n@SpringBootApplication\npublic class FtpJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(FtpJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n @InboundChannelAdapter(channel = \"stream\")\n public MessageSource<InputStream> ftpMessageSource() {\n FtpStreamingMessageSource messageSource = new FtpStreamingMessageSource(template());\n messageSource.setRemoteDirectory(\"ftpSource/\");\n messageSource.setFilter(new AcceptAllFileListFilter<>());\n messageSource.setMaxFetchSize(1);\n return messageSource;\n }\n\n @Bean\n @Transformer(inputChannel = \"stream\", outputChannel = \"data\")\n public org.springframework.integration.transformer.Transformer transformer() {\n return new StreamTransformer(\"UTF-8\");\n }\n\n @Bean\n public FtpRemoteFileTemplate template() {\n return new FtpRemoteFileTemplate(ftpSessionFactory());\n }\n\n @ServiceActivator(inputChannel = \"data\", adviceChain = \"after\")\n @Bean\n public MessageHandler handle() {\n return System.out::println;\n }\n\n @Bean\n public ExpressionEvaluatingRequestHandlerAdvice after() {\n ExpressionEvaluatingRequestHandlerAdvice advice = new ExpressionEvaluatingRequestHandlerAdvice();\n advice.setOnSuccessExpression(\n \"@template.remove(headers['file_remoteDirectory'] + headers['file_remoteFile'])\");\n advice.setPropagateEvaluationFailures(true);\n return advice;\n }\n\n}\n----\n\nNotice that, in this example, the message handler downstream of the transformer has an `advice` that removes the remote file after processing.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp/streaming.adoc", "title": "streaming", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 74, "section_index": 1, "content_hash": "ad74905c5d88282aa30f6e49d9718d3857544114e5fca4c53fe732e7ea7bbed2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp/streaming.adoc"}}
{"id": "sha256:b5ac155461419799530d57fb85e505c13f4165a89e339829019668aa3e795e45", "content": "[[advised-handler-properties]]\n\nSometimes, it is useful to access handler properties from within the advice.\nFor example, most handlers implement `NamedComponent` to let you access the component name.\n\nThe target object can be accessed through the `target` argument (when subclassing `AbstractRequestHandlerAdvice`) or `invocation.getThis()` (when implementing `org.aopalliance.intercept.MethodInterceptor`).\n\nWhen the entire handler is advised (such as when the handler does not produce replies or the advice implements `HandleMessageAdvice`), you can cast the target object to an interface, such as `NamedComponent`, as shown in the following example:\n\n[source, java]\n----\nString componentName = ((NamedComponent) target).getComponentName();\n----\n\nWhen you implement `MethodInterceptor` directly, you could cast the target object as follows:\n\n[source, java]\n----\nString componentName = ((NamedComponent) invocation.getThis()).getComponentName();\n----\n\nWhen only the `handleRequestMessage()` method is advised (in a reply-producing handler), you need to access the full handler, which is an `AbstractReplyProducingMessageHandler`.\nThe following example shows how to do so:\n\n[source, java]\n----\nAbstractReplyProducingMessageHandler handler =\n ((AbstractReplyProducingMessageHandler.RequestHandler) target).getAdvisedHandler();\n\nString componentName = handler.getComponentName();\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/advised-properties.adoc", "title": "advised-properties", "heading": "advised-properties", "heading_level": 1, "file_order": 75, "section_index": 0, "content_hash": "b5ac155461419799530d57fb85e505c13f4165a89e339829019668aa3e795e45", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/advised-properties.adoc"}}
{"id": "sha256:3e16995ca983cb9d11c3e44593ce299ffe0319424911c6cb8f7341c57d310c1f", "content": "[[advising-filters]]\n\nThere is an additional consideration when advising `Filter` advices.\nBy default, any discard actions (when the filter returns `false`) are performed within the scope of the advice chain.\nThis could include all the flow downstream of the discard channel.\nSo, for example, if an element downstream of the discard channel throws an exception and there is a retry advice, the process is retried.\nAlso, if `throwExceptionOnRejection` is set to `true` (the exception is thrown within the scope of the advice).\n\nSetting `discard-within-advice` to `false` modifies this behavior and the discard (or exception) occurs after the advice chain is called.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/advising-filters.adoc", "title": "advising-filters", "heading": "advising-filters", "heading_level": 1, "file_order": 76, "section_index": 0, "content_hash": "3e16995ca983cb9d11c3e44593ce299ffe0319424911c6cb8f7341c57d310c1f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/advising-filters.adoc"}}
{"id": "sha256:5111e40f7397012ee7221d1d642f393483a8adf82909d1d045ad4c36ed77a66a", "content": "[[advising-with-annotations]]\n\nWhen configuring certain endpoints by using annotations (`@Filter`, `@ServiceActivator`, `@Splitter`, and `@Transformer`), you can supply a bean name for the advice chain in the `adviceChain` attribute.\nIn addition, the `@Filter` annotation also has the `discardWithinAdvice` attribute, which can be used to configure the discard behavior, as discussed in xref:handler-advice/advising-filters.adoc[Advising Filters].\nThe following example causes the discard to be performed after the advice:\n\n[source,java]\n----\n@MessageEndpoint\npublic class MyAdvisedFilter {\n\n @Filter(inputChannel=\"input\", outputChannel=\"output\",\n adviceChain=\"adviceChain\", discardWithinAdvice=\"false\")\n public boolean filter(String s) {\n return s.contains(\"good\");\n }\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/advising-with-annotations.adoc", "title": "advising-with-annotations", "heading": "advising-with-annotations", "heading_level": 1, "file_order": 77, "section_index": 0, "content_hash": "5111e40f7397012ee7221d1d642f393483a8adf82909d1d045ad4c36ed77a66a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/advising-with-annotations.adoc"}}
{"id": "sha256:455de5e2b515301da2d6a8f7da0b948a8f5a6067f3ce2d058da9092123975811", "content": "[[advice-classes]]\n\nIn addition to providing the general mechanism to apply AOP advice classes, Spring Integration provides these out-of-the-box advice implementations:\n\n* `RequestHandlerRetryAdvice` (described in xref:handler-advice/classes.adoc#retry-advice[Retry Advice])\n* `RequestHandlerCircuitBreakerAdvice` (described in xref:handler-advice/classes.adoc#circuit-breaker-advice[Circuit Breaker Advice])\n* `ExpressionEvaluatingRequestHandlerAdvice` (described in xref:handler-advice/classes.adoc#expression-advice[Expression Advice])\n* `RateLimiterRequestHandlerAdvice` (described in xref:handler-advice/classes.adoc#rate-limiter-advice[Rate Limiter Advice])\n* `CacheRequestHandlerAdvice` (described in xref:handler-advice/classes.adoc#cache-advice[Caching Advice])\n* `ReactiveRequestHandlerAdvice` (described in xref:handler-advice/reactive.adoc[Reactive Advice])\n* `ContextHolderRequestHandlerAdvice` (described in xref:handler-advice/context-holder.adoc[Context Holder Advice])\n* `LockRequestHandlerAdvice` (described in xref:handler-advice/lock.adoc[Lock Advice])\n\n[[expression-advice]]\n[[retry-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/classes.adoc", "title": "classes", "heading": "classes", "heading_level": 1, "file_order": 78, "section_index": 0, "content_hash": "455de5e2b515301da2d6a8f7da0b948a8f5a6067f3ce2d058da9092123975811", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/classes.adoc"}}
{"id": "sha256:42b8432d914bb56938283625de7386aeec48d2bf5530416306de76f1278c293f", "content": "The retry advice (`o.s.i.handler.advice.RequestHandlerRetryAdvice`) leverages the rich retry mechanisms provided by the https://docs.spring.io/spring-framework/reference/core/resilience.html#resilience-programmatic-retry[Retry Support] in Spring Framework.\nThe core component of this advice is the `RetryTemplate`, which allows configuration of sophisticated retry scenarios, including `RetryPolicy` as well as a `RecoveryCallback` strategy to determine the action to take when retries are exhausted.\n\nStateless Retry::\nStateless retry is the case where the retry activity is handled entirely within the advice.\nThe thread pauses (if configured to do so) and retries the action.\n\nStateful Retry::\nStateful retry is the case where the retry state is managed within the advice but where an exception is thrown and the caller resubmits the request.\nAn example for stateful retry is when we want the message originator, (for example, JMS) to be responsible for resubmitting, rather than performing it on the current thread.\nStateful retry needs some mechanism to detect a retried submission.\nFor this purpose, the `RequestHandlerRetryAdvice` expose the `stateKeyFunction`, `newMessagePredicate` and `stateCacheSize` properties.\nWhere later two of them make sense only if the first is provided.\nEssentially, the `stateKeyFunction` is an indicator to switch `RequestHandlerRetryAdvice` logic from stateless to stateful.\nThe meaning of the `newMessagePredicate` is two refresh an existing retry state for the key based on the message to handle.\nThe `stateCacheSize` is `100` by default, where elder entries are removed from the cache when more new retry states are coming.\nPerhaps those old messages are not redelivered anymore from the upstream flow, e.g., the message broker dead-lettered those messages according to its redelivery policy.\n\nWARNING: The default back off behavior is to not back off.\nRetries are attempted immediately.\nUsing a back off policy that causes threads to pause between attempts may cause performance issues, including excessive memory use and thread starvation.\nIn high-volume environments, back off policies should be used with caution.\n\n[[retry-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/classes.adoc", "title": "classes", "heading": "Retry Advice", "heading_level": 2, "file_order": 78, "section_index": 1, "content_hash": "42b8432d914bb56938283625de7386aeec48d2bf5530416306de76f1278c293f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/classes.adoc"}}
{"id": "sha256:433cb323a4b36d69dfae552621126b737114a702e3cb50c158d29e92139f906c", "content": "The examples in this section use the following `@ServiceActivator` that always throws an exception:\n\n[source,java]\n----\npublic class FailingService {\n\n\t@ServiceActivator(inputChannel = \"input\", adviceChain = \"retryAdvice\")\n public void service(String message) {\n throw new RuntimeException(\"error\");\n }\n}\n----\n\nSimple Stateless Retry::\nThe default `RetryPolicy` is to try three times, plus original call for the target `MessageHandler`.\nThere is no backoff by default, so the three attempts are made back-to-back-to-back with no delay between attempts.\nThere is no `RecoveryCallback`, so the result is to throw the exception to the caller after the final failed retry occurs.\nIn a Spring Integration environment, this final exception might be handled by using an `error-channel` on the inbound endpoint.\nThe following example uses default configuration for the `RequestHandlerRetryAdvice`:\n+\n[source,java]\n----\n@Bean\nRequestHandlerRetryAdvice retryAdvice() {\n return new RequestHandlerRetryAdvice();\n}\n----\n\nSimple Stateless Retry with Recovery::\nThe following example adds a `RecoveryCallback` to the preceding example and uses an `ErrorMessageSendingRecoverer` to send an `ErrorMessage` to a channel:\n+\n[source,java]\n----\n@Bean\nRequestHandlerRetryAdvice retryAdvice(MessageChannel recoveryChannel) {\n RequestHandlerRetryAdvice requestHandlerRetryAdvice = new RequestHandlerRetryAdvice();\n requestHandlerRetryAdvice.setRecoveryCallback(new ErrorMessageSendingRecoverer(recoveryChannel));\n return requestHandlerRetryAdvice;\n}\n----\n\nStateless Retry with Customized Policies, and Recovery::\nFor more sophistication, a customized `RetryPolicy` can be provided for the `RequestHandlerRetryAdvice`.\nThis example continues to use the simple `RetryPolicy` but increases the attempts to four.\nIt also adds an `ExponentialBackoff` where the first retry waits one second, the second waits five seconds, and the third waits 25 (for four attempts in all).\nThe following listing shows the example of such a configuration:\n+\n[source,java]\n----\n@Bean\nRequestHandlerRetryAdvice retryAdvice() {\n RequestHandlerRetryAdvice requestHandlerRetryAdvice = new RequestHandlerRetryAdvice();\n requestHandlerRetryAdvice.setRecoveryCallback(new ErrorMessageSendingRecoverer(recoveryChannel()));\n RetryPolicy retryPolicy = RetryPolicy.builder()\n .maxRetries(4)\n .delay(Duration.ofSeconds(1))\n .multiplier(5.0)\n .maxDelay(Duration.ofMinutes(1))\n .build();\n requestHandlerRetryAdvice.setRetryPolicy(retryPolicy);\n return requestHandlerRetryAdvice;\n}\n----\n\nNamespace Support for Stateless Retry::\nThe following examples demonstrate how the `RequestHandlerRetryAdvice` can be configured using Spring Integration XML namespace with its custom tags:\n+\n[source,xml]\n----\n<int:service-activator input-channel=\"input\" ref=\"failer\" method=\"service\">\n <int:request-handler-advice-chain>\n <ref bean=\"retrier\" />\n </int:request-handler-advice-chain>\n</int:service-activator>\n\n<int:handler-retry-advice id=\"retrier\" max-retries=\"4\" recovery-channel=\"myErrorChannel\">\n <int:exponential-back-off initial=\"1000\" multiplier=\"5.0\" maximum=\"60000\" />\n</int:handler-retry-advice>\n----\n+\nIn the preceding example, the advice is defined as a top-level bean so that it can be used in multiple `request-handler-advice-chain` instances.\nYou can also define the advice directly within the chain, as the following example shows:\n+\n[source,xml]\n----\n<int:service-activator input-channel=\"input\" ref=\"failer\" method=\"service\">\n <int:request-handler-advice-chain>\n <int:retry-advice id=\"retrier\" max-retries=\"4\" recovery-channel=\"myErrorChannel\">\n <int:exponential-back-off initial=\"1000\" multiplier=\"5.0\" maximum=\"60000\" />\n </int:retry-advice>\n </int:request-handler-advice-chain>\n</int:service-activator>\n----\n+\nA `<handler-retry-advice>` can have a `<fixed-back-off>` or `<exponential-back-off>` child element or have no child element.\nA `<handler-retry-advice>` with no child element uses no back off.\nIf there is no `recovery-channel`, the exception is thrown when retries are exhausted.\nThe namespace can only be used with stateless retry.\n+\nFor more complex environments (custom policies etc.), use normal `<bean>` definitions.\n\nSimple Stateful Retry with Recovery::\nTo make retry stateful, a `Function<Message<?>, Object> stateKeyFunction` must be provided for the `RequestHandlerRetryAdvice` instance.\nThis function is used to identify a message as being a resubmission so that the `RequestHandlerRetryAdvice` can determine the current state of retry for this message.\nThe idea behind stateful retry is to not block the current thread, but rather cache the retry state for this message and re-throw `MessageHandler` failure back to the caller.\nUsually this works well with message originators which are able to resubmit (or redeliver) events, for example, message brokers like RabbitMQ with `nack`, or Apache Kafka with seek functionality; or JMS after rollback on the consumption.\nIf there is no cached state yet (or the `Predicate<Message<?>> newMessagePredicate` returns `true` for the message), the `MessageHandler` call is treated as the first one, and on its failure an internal `RetryState` based on a `BackOffExecution`, is cached under the mentioned key.\nOn the next message arrival, the cached state provides a backoff interval for `Thread.sleep()` before an attempt to call the `MessageHandler`.\nIf this backoff interval is equal to `BackOffExecution.STOP` (e.g., `maxAttempts` have been reached), that mean no more retries for this message: the whole retry cycle is treated as exhausted, and respective `RetryException` is thrown back to the caller or used for `RecoveryCallback` invocation if provided.\nIn general, the exception handling logic and backoff execution are similar to the stateless behavior, with only difference that thread is not blocked for all the `maxAttempts`.\nIt is up to the message originator to redeliver a message for the next retry call.\n\n[[circuit-breaker-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/classes.adoc", "title": "classes", "heading": "Configuring the Retry Advice", "heading_level": 3, "file_order": 78, "section_index": 2, "content_hash": "433cb323a4b36d69dfae552621126b737114a702e3cb50c158d29e92139f906c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/classes.adoc"}}
{"id": "sha256:60e992145579e2372bb1f9f6432a57a909bf49c44fb92adeb8be83673165cdeb", "content": "The general idea of the circuit breaker pattern is that, if a service is not currently available, do not waste time (and resources) trying to use it.\nThe `o.s.i.handler.advice.RequestHandlerCircuitBreakerAdvice` implements this pattern.\nWhen the circuit breaker is in the closed state, the endpoint attempts to invoke the service.\nThe circuit breaker goes to the open state if a certain number of consecutive attempts fail.\nWhen it is in the open state, new requests \"`fail fast`\" and no attempt is made to invoke the service until some time has expired.\n\nWhen that time has expired, the circuit breaker is set to the half-open state.\nWhen in this state, if even a single attempt fails, the breaker immediately goes to the open state.\nIf the attempt succeeds, the breaker goes to the closed state, in which case it does not go to the open state again until the configured number of consecutive failures again occurs.\nAny successful attempt resets the state to zero failures for the purpose of determining when the breaker might go to the open state again.\n\nTypically, this advice might be used for external services, where it might take some time to fail, such as a timeout attempting to make a network connection.\n\nThe `RequestHandlerCircuitBreakerAdvice` has two properties: `threshold` and `halfOpenAfter`.\nThe `threshold` property represents the number of consecutive failures that need to occur before the breaker goes open.\nIt defaults to `5`.\nThe `halfOpenAfter` property represents the time after the last failure that the breaker waits before attempting another request.\nThe default is 1000 milliseconds.\n\nThe following example configures a circuit breaker and shows its `DEBUG` and `ERROR` output:\n\n[source,xml]\n----\n<int:service-activator input-channel=\"input\" ref=\"failer\" method=\"service\">\n <int:request-handler-advice-chain>\n <bean class=\"o.s.i.handler.advice.RequestHandlerCircuitBreakerAdvice\">\n <property name=\"threshold\" value=\"2\" />\n <property name=\"halfOpenAfter\" value=\"12000\" />\n </bean>\n </int:request-handler-advice-chain>\n</int:service-activator>\n\n05.617 DEBUG [task-scheduler-1]preSend on channel 'input', message: [Payload=...]\n05.638 ERROR [task-scheduler-1]org.springframework.messaging.MessageHandlingException: java.lang.RuntimeException: foo\n...\n10.598 DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]\n10.600 ERROR [task-scheduler-2]org.springframework.messaging.MessageHandlingException: java.lang.RuntimeException: foo\n...\n15.598 DEBUG [task-scheduler-3]preSend on channel 'input', message: [Payload=...]\n15.599 ERROR [task-scheduler-3]org.springframework.messaging.MessagingException: Circuit Breaker is Open for ServiceActivator\n...\n20.598 DEBUG [task-scheduler-2]preSend on channel 'input', message: [Payload=...]\n20.598 ERROR [task-scheduler-2]org.springframework.messaging.MessagingException: Circuit Breaker is Open for ServiceActivator\n...\n25.598 DEBUG [task-scheduler-5]preSend on channel 'input', message: [Payload=...]\n25.601 ERROR [task-scheduler-5]org.springframework.messaging.MessageHandlingException: java.lang.RuntimeException: foo\n...\n30.598 DEBUG [task-scheduler-1]preSend on channel 'input', message: [Payload=foo...]\n30.599 ERROR [task-scheduler-1]org.springframework.messaging.MessagingException: Circuit Breaker is Open for ServiceActivator\n----\n\nIn the preceding example, the threshold is set to `2` and `halfOpenAfter` is set to `12` seconds.\nA new request arrives every 5 seconds.\nThe first two attempts invoked the service.\nThe third and fourth failed with an exception indicating that the circuit breaker is open.\nThe fifth request was attempted because the request was 15 seconds after the last failure.\nThe sixth attempt fails immediately because the breaker immediately went to open.\n\n[[expression-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/classes.adoc", "title": "classes", "heading": "Circuit Breaker Advice", "heading_level": 2, "file_order": 78, "section_index": 3, "content_hash": "60e992145579e2372bb1f9f6432a57a909bf49c44fb92adeb8be83673165cdeb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/classes.adoc"}}
{"id": "sha256:6e8c02f841143e5106c2feb05b370145a428b4c4b45edf6962005b3fb4379ff7", "content": "The final supplied advice class is the `o.s.i.handler.advice.ExpressionEvaluatingRequestHandlerAdvice`.\nThis advice is more general than the other two advices.\nIt provides a mechanism to evaluate an expression on the original inbound message sent to the endpoint.\nSeparate expressions are available to be evaluated, after either success or failure.\nOptionally, a message containing the evaluation result, together with the input message, can be sent to a message channel.\n\nA typical use case for this advice might be with an `<ftp:outbound-channel-adapter/>`, perhaps to move the file to one directory if the transfer was successful or to another directory if it fails:\n\nThe advice has properties to set an expression when successful, an expression for failures, and corresponding channels for each.\nFor the successful case, the message sent to the `successChannel` is an `AdviceMessage`, with the payload being the result of the expression evaluation.\nAn additional property, called `inputMessage`, contains the original message sent to the handler.\nA message sent to the `failureChannel` (when the handler throws an exception) is an `ErrorMessage` with a payload of `MessageHandlingExpressionEvaluatingAdviceException`.\nLike all `MessagingException` instances, this payload has `failedMessage` and `cause` properties, as well as an additional property called `evaluationResult`, which contains the result of the expression evaluation.\n\nNOTE: Starting with version 5.1.3, if channels are configured, but expressions are not provided, the default expression is used to evaluate to the `payload` of the message.\n\nWhen an exception is thrown in the scope of the advice, by default, that exception is thrown to the caller after any `failureExpression` is evaluated.\nIf you wish to suppress throwing the exception, set the `trapException` property to `true`.\nThe following advice shows how to configure an `advice` with Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class EerhaApplication {\n\n public static void main(String[] args) {\n ConfigurableApplicationContext context = SpringApplication.run(EerhaApplication.class, args);\n MessageChannel in = context.getBean(\"advised.input\", MessageChannel.class);\n in.send(new GenericMessage<>(\"good\"));\n in.send(new GenericMessage<>(\"bad\"));\n context.close();\n }\n\n @Bean\n public IntegrationFlow advised() {\n return f -> f.<String>handle((payload, headers) -> {\n if (payload.equals(\"good\")) {\n return null;\n }\n else {\n throw new RuntimeException(\"some failure\");\n }\n }, c -> c.advice(expressionAdvice()));\n }\n\n @Bean\n public Advice expressionAdvice() {\n ExpressionEvaluatingRequestHandlerAdvice advice = new ExpressionEvaluatingRequestHandlerAdvice();\n advice.setSuccessChannelName(\"success.input\");\n advice.setOnSuccessExpressionString(\"payload + ' was successful'\");\n advice.setFailureChannelName(\"failure.input\");\n advice.setOnFailureExpressionString(\n \"payload + ' was bad, with reason: ' + #exception.cause.message\");\n advice.setTrapException(true);\n return advice;\n }\n\n @Bean\n public IntegrationFlow success() {\n return f -> f.handle(System.out::println);\n }\n\n @Bean\n public IntegrationFlow failure() {\n return f -> f.handle(System.out::println);\n }\n\n}\n----\n\n[[rate-limiter-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/classes.adoc", "title": "classes", "heading": "Expression Evaluating Advice", "heading_level": 2, "file_order": 78, "section_index": 4, "content_hash": "6e8c02f841143e5106c2feb05b370145a428b4c4b45edf6962005b3fb4379ff7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/classes.adoc"}}
{"id": "sha256:44aef7a1bc1e86ad139dc6da523597511ae023abc488ead0000193255140d533", "content": "The Rate Limiter advice (`RateLimiterRequestHandlerAdvice`) allows to ensure that an endpoint does not get overloaded with requests.\nWhen the rate limit is breached, the request will go in a blocked state.\n\nA typical use case for this advice might be an external service provider not allowing more than `n` number of request per minute.\n\nThe `RateLimiterRequestHandlerAdvice` implementation is fully based on the https://github.com/resilience4j/resilience4j#ratelimiter[Resilience4j] project and requires either `RateLimiter` or `RateLimiterConfig` injections.\nCan also be configured with defaults and/or custom name.\n\nThe following example configures a rate limiter advice with one request per 1 second:\n[source, java]\n----\n@Bean\npublic RateLimiterRequestHandlerAdvice rateLimiterRequestHandlerAdvice() {\n return new RateLimiterRequestHandlerAdvice(RateLimiterConfig.custom()\n .limitRefreshPeriod(Duration.ofSeconds(1))\n .limitForPeriod(1)\n .build());\n}\n\n@ServiceActivator(inputChannel = \"requestChannel\", outputChannel = \"resultChannel\",\n adviceChain = \"rateLimiterRequestHandlerAdvice\")\npublic String handleRequest(String payload) {\n ...\n}\n----\n\n[[cache-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/classes.adoc", "title": "classes", "heading": "Rate Limiter Advice", "heading_level": 2, "file_order": 78, "section_index": 5, "content_hash": "44aef7a1bc1e86ad139dc6da523597511ae023abc488ead0000193255140d533", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/classes.adoc"}}
{"id": "sha256:6703b7508af67216ca3950d25febc34b2d54743026bb420ed2ca786ea11ed602", "content": "Starting with version 5.2, the `CacheRequestHandlerAdvice` has been introduced.\nIt is based on the caching abstraction in https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache[Spring Framework] and aligned with the concepts and functionality provided by the `@Caching` annotation family.\nThe logic internally is based on the `CacheAspectSupport` extension, where proxying for caching operations is done around the `AbstractReplyProducingMessageHandler.RequestHandler.handleRequestMessage` method with the request `Message<?>` as the argument.\nThis advice can be configured with a SpEL expression or a `Function` to evaluate a cache key.\nThe request `Message<?>` is available as the root object for the SpEL evaluation context, or as the `Function` input argument.\nBy default, the `payload` of the request message is used for the cache key.\nThe `CacheRequestHandlerAdvice` must be configured with `cacheNames`, when a default cache operation is a `CacheableOperation`, or with a set of any arbitrary ``CacheOperation``s.\nEvery `CacheOperation` can be configured separately or have shared options, like a `CacheManager`, `CacheResolver` and `CacheErrorHandler`, can be reused from the `CacheRequestHandlerAdvice` configuration.\nThis configuration functionality is similar to Spring Framework's `@CacheConfig` and `@Caching` annotation combination.\nIf a `CacheManager` is not provided, a single bean is resolved by default from the `BeanFactory` in the `CacheAspectSupport`.\n\nThe following example configures two advice with different sets of caching operations:\n\n[source, java]\n----\n@Bean\npublic CacheRequestHandlerAdvice cacheAdvice() {\n CacheRequestHandlerAdvice cacheRequestHandlerAdvice = new CacheRequestHandlerAdvice(TEST_CACHE);\n cacheRequestHandlerAdvice.setKeyExpressionString(\"payload\");\n return cacheRequestHandlerAdvice;\n}\n\n@Transformer(inputChannel = \"transformerChannel\", outputChannel = \"nullChannel\", adviceChain = \"cacheAdvice\")\npublic Object transform(Message<?> message) {\n ...\n}\n\n@Bean\npublic CacheRequestHandlerAdvice cachePutAndEvictAdvice() {\n CacheRequestHandlerAdvice cacheRequestHandlerAdvice = new CacheRequestHandlerAdvice();\n cacheRequestHandlerAdvice.setKeyExpressionString(\"payload\");\n CachePutOperation.Builder cachePutBuilder = new CachePutOperation.Builder();\n cachePutBuilder.setCacheName(TEST_PUT_CACHE);\n CacheEvictOperation.Builder cacheEvictBuilder = new CacheEvictOperation.Builder();\n cacheEvictBuilder.setCacheName(TEST_CACHE);\n cacheRequestHandlerAdvice.setCacheOperations(cachePutBuilder.build(), cacheEvictBuilder.build());\n return cacheRequestHandlerAdvice;\n}\n\n@ServiceActivator(inputChannel = \"serviceChannel\", outputChannel = \"nullChannel\",\n adviceChain = \"cachePutAndEvictAdvice\")\npublic Message<?> service(Message<?> message) {\n ...\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/classes.adoc", "title": "classes", "heading": "Caching Advice", "heading_level": 2, "file_order": 78, "section_index": 6, "content_hash": "6703b7508af67216ca3950d25febc34b2d54743026bb420ed2ca786ea11ed602", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/classes.adoc"}}
{"id": "sha256:b9bc79cb9b7256e586a7e6e4600e04200f9ea122ae3b62c84f286edfed6d71c5", "content": "[[context-holder-advice]]\n\nStarting with version 6.1, the `ContextHolderRequestHandlerAdvice` has been introduced.\nThis advice takes some value from the request message as and stores it in the context holder.\nThe value is clear from the context when an execution is finished on the target `MessageHandler`.\nThe best way to think about this advice is similar to the programming flow where we store some value into a `ThreadLocal`, get access to it from the target call and then clean up the `ThreadLocal` after execution.\nThe `ContextHolderRequestHandlerAdvice` requires these constructor arguments: a `Function<Message<?>, Object>` as a value provider, `Consumer<Object>` as a context-setting callback and `Runnable` as a context cleaning-up hook.\n\nFollowing is a sample how a `ContextHolderRequestHandlerAdvice` can be used in combination with a `o.s.i.file.remote.session.DelegatingSessionFactory`:\n\n[source, java]\n----\n@Bean\nDelegatingSessionFactory<?> dsf(SessionFactory<?> one, SessionFactory<?> two) {\n return new DelegatingSessionFactory<>(Map.of(\"one\", one, \"two\", two), null);\n}\n\n@Bean\nContextHolderRequestHandlerAdvice contextHolderRequestHandlerAdvice(DelegatingSessionFactory<String> dsf) {\n return new ContextHolderRequestHandlerAdvice(message -> message.getHeaders().get(\"FACTORY_KEY\"),\n dsf::setThreadKey, dsf::clearThreadKey);\n}\n\n@ServiceActivator(inputChannel = \"in\", adviceChain = \"contextHolderRequestHandlerAdvice\")\nFtpOutboundGateway ftpOutboundGateway(DelegatingSessionFactory<?> sessionFactory) {\n\treturn new FtpOutboundGateway(sessionFactory, \"ls\", \"payload\");\n}\n----\n\nAnd it is just enough to send a message to the `in` channel with a `FACTORY_KEY` header set to either `one` or `two`.\nThe `ContextHolderRequestHandlerAdvice` sets the value from that header into a `DelegatingSessionFactory` via its `setThreadKey`.\nThen when `FtpOutboundGateway` executes an `ls` command a proper delegating `SessionFactory` is chosen from the `DelegatingSessionFactory` according to the value in its `ThreadLocal`.\nWhen the result is produced from the `FtpOutboundGateway`, a `ThreadLocal` value in the `DelegatingSessionFactory` is cleared according to the `clearThreadKey()` call from the `ContextHolderRequestHandlerAdvice`.\nSee xref:ftp/dsf.adoc[Delegating Session Factory] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/context-holder.adoc", "title": "context-holder", "heading": "context-holder", "heading_level": 1, "file_order": 79, "section_index": 0, "content_hash": "b9bc79cb9b7256e586a7e6e4600e04200f9ea122ae3b62c84f286edfed6d71c5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/context-holder.adoc"}}
{"id": "sha256:7c35b5e7d546571a7a70c110c141536e66032ab92bfeb5886a1eaaf1a4fbc375", "content": "[[custom-advice]]\n\nIn addition to the provided advice classes xref:handler-advice/classes.adoc[described earlier], you can implement your own advice classes.\nWhile you can provide any implementation of `org.aopalliance.aop.Advice` (usually `org.aopalliance.intercept.MethodInterceptor`), we generally recommend that you subclass `o.s.i.handler.advice.AbstractRequestHandlerAdvice`.\nThis has the benefit of avoiding the writing of low-level aspect-oriented programming code as well as providing a starting point that is specifically tailored for use in this environment.\n\nSubclasses need to implement the `doInvoke()` method, the definition of which follows:\n\n[source,java]\n----\n/**\n * Subclasses implement this method to apply behavior to the {@link MessageHandler} callback.execute()\n * invokes the handler method and returns its result, or null).\n * @param callback Subclasses invoke the execute() method on this interface to invoke the handler method.\n * @param target The target handler.\n * @param message The message that will be sent to the handler.\n * @return the result after invoking the {@link MessageHandler}.\n * @throws Exception\n */\nprotected abstract Object doInvoke(ExecutionCallback callback, Object target, Message<?> message) throws Exception;\n----\n\nThe callback parameter is a convenience to avoid subclasses that deal with AOP directly.\nInvoking the `callback.execute()` method invokes the message handler.\n\nThe `target` parameter is provided for those subclasses that need to maintain state for a specific handler, perhaps by maintaining that state in a `Map` keyed by the target.\nThis feature allows the same advice to be applied to multiple handlers.\nThe `RequestHandlerCircuitBreakerAdvice` uses advice this to keep circuit breaker state for each handler.\n\nThe `message` parameter is the message sent to the handler.\nWhile the advice cannot modify the message before invoking the handler, it can modify the payload (if it has mutable properties).\nTypically, an advice would use the message for logging or to send a copy of the message somewhere before or after invoking the handler.\n\nThe return value would normally be the value returned by `callback.execute()`.\nHowever, the advice does have the ability to modify the return value.\nNote that only `AbstractReplyProducingMessageHandler` instances return values.\nThe following example shows a custom advice class that extends `AbstractRequestHandlerAdvice`:\n\n[source,java]\n----\npublic class MyAdvice extends AbstractRequestHandlerAdvice {\n\n @Override\n protected Object doInvoke(ExecutionCallback callback, Object target, Message<?> message) throws Exception {\n // add code before the invocation\n Object result = callback.execute();\n // add code after the invocation\n return result;\n }\n}\n----\n\n[NOTE]\n=====\nIn addition to the `execute()` method, `ExecutionCallback` provides an additional method: `cloneAndExecute()`.\nThis method must be used in cases where the invocation might be called multiple times within a single execution of `doInvoke()`, such as in the `RequestHandlerRetryAdvice`.\nThis is required because the Spring AOP `org.springframework.aop.framework.ReflectiveMethodInvocation` object maintains state by keeping track of which advice in a chain was last invoked.\nThis state must be reset for each call.\n\nFor more information, see the https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/aop/framework/ReflectiveMethodInvocation.html[ReflectiveMethodInvocation] Javadoc.\n=====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/custom.adoc", "title": "custom", "heading": "custom", "heading_level": 1, "file_order": 80, "section_index": 0, "content_hash": "7c35b5e7d546571a7a70c110c141536e66032ab92bfeb5886a1eaaf1a4fbc375", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/custom.adoc"}}
{"id": "sha256:850ac66229b0235bb84d19f0c016bd2cfdecb9d79fc06974c6ac2a3b8cdcbb14", "content": "[[handle-message-advice]]\n\nAs discussed in xref:handler-advice.adoc[the introduction to this section], advice objects in a request handler advice chain are applied to just the current endpoint, not the downstream flow (if any).\nFor `MessageHandler` objects that produce a reply (such as those that extend `AbstractReplyProducingMessageHandler`), the advice is applied to an internal method: `handleRequestMessage()` (called from `MessageHandler.handleMessage()`).\nFor other message handlers, the advice is applied to `MessageHandler.handleMessage()`.\n\nThere are some circumstances where, even if a message handler is an `AbstractReplyProducingMessageHandler`, the advice must be applied to the `handleMessage` method.\nFor example, the xref:handler-advice/idempotent-receiver.adoc[idempotent receiver] might return `null`, which would cause an exception if the handler's `replyRequired` property is set to `true`.\nAnother example is the `BoundRabbitChannelAdvice` -- see xref:amqp/strict-ordering.adoc[Strict Message Ordering].\n\nStarting with version 4.3.1, a new `HandleMessageAdvice` interface and its base implementation (`AbstractHandleMessageAdvice`) have been introduced.\n`Advice` objects that implement `HandleMessageAdvice` are always applied to the `handleMessage()` method, regardless of the handler type.\n\nIt is important to understand that `HandleMessageAdvice` implementations (such as xref:handler-advice/idempotent-receiver.adoc[idempotent receiver]), when applied to a handlers that return responses, are dissociated from the `adviceChain` and properly applied to the `MessageHandler.handleMessage()` method.\n\nNOTE: Because of this disassociation, the advice chain order is not honored.\n\nConsider the following configuration:\n\n[source,xml]\n----\n<some-reply-producing-endpoint ... >\n <int:request-handler-advice-chain>\n <tx:advice ... />\n <ref bean=\"myHandleMessageAdvice\" />\n </int:request-handler-advice-chain>\n</some-reply-producing-endpoint>\n----\n\nIn the preceding example, the `<tx:advice>` is applied to the `AbstractReplyProducingMessageHandler.handleRequestMessage()`.\nHowever, `myHandleMessageAdvice` is applied for to `MessageHandler.handleMessage()`.\nTherefore, it is invoked *before* the `<tx:advice>`.\nTo retain the order, you should follow the standard https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-api[Spring AOP] configuration approach and use an endpoint `id` together with the `.handler` suffix to obtain the target `MessageHandler` bean.\nNote that, in that case, the entire downstream flow is within the transaction scope.\n\nIn the case of a `MessageHandler` that does not return a response, the advice chain order is retained.\n\nStarting with version 5.3, the `HandleMessageAdviceAdapter` is provided to apply any `MethodInterceptor` for the `MessageHandler.handleMessage()` method and, therefore, the whole sub-flow.\nFor example, a `RetryOperationsInterceptor` could be applied to the whole sub-flow starting from some endpoint; this is not possible, by default, because the consumer endpoint applies advices only to the `AbstractReplyProducingMessageHandler.RequestHandler.handleRequestMessage()`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/handle-message.adoc", "title": "handle-message", "heading": "handle-message", "heading_level": 1, "file_order": 81, "section_index": 0, "content_hash": "850ac66229b0235bb84d19f0c016bd2cfdecb9d79fc06974c6ac2a3b8cdcbb14", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/handle-message.adoc"}}
{"id": "sha256:4bfd06eb900fdc444bd8cb668a28b74edb70a5f418a18a69d070ef462f173953", "content": "[[idempotent-receiver]]\n\nStarting with version 4.1, Spring Integration provides an implementation of the https://www.enterpriseintegrationpatterns.com/IdempotentReceiver.html[Idempotent Receiver] Enterprise Integration Pattern.\nIt is a functional pattern and the whole idempotency logic should be implemented in the application.\nHowever, to simplify the decision-making, the `IdempotentReceiverInterceptor` component is provided.\nThis is an AOP `Advice` that is applied to the `MessageHandler.handleMessage()` method and that can `filter` a request message or mark it as a `duplicate`, according to its configuration.\n\nPreviously, you could have implemented this pattern by using a custom `MessageSelector` in a `<filter/>` (see xref:filter.adoc[Filter]), for example.\nHowever, since this pattern really defines the behavior of an endpoint rather than being an endpoint itself, the idempotent receiver implementation does not provide an endpoint component.\nRather, it is applied to endpoints declared in the application.\n\nThe logic of the `IdempotentReceiverInterceptor` is based on the provided `MessageSelector` and, if the message is not accepted by that selector, it is enriched with the `duplicateMessage` header set to `true`.\nThe target `MessageHandler` (or downstream flow) can consult this header to implement the correct idempotency logic.\nIf the `IdempotentReceiverInterceptor` is configured with a `discardChannel` or `throwExceptionOnRejection = true`, the duplicate message is not sent to the target `MessageHandler.handleMessage()`.\nRather, it is discarded.\nIf you want to discard (do nothing with) the duplicate message, the `discardChannel` should be configured with a `NullChannel`, such as the default `nullChannel` bean.\n\nTo maintain state between messages and provide the ability to compare messages for the idempotency, we provide the `MetadataStoreSelector`.\nIt accepts a `MessageProcessor` implementation (which creates a lookup key based on the `Message`) and an optional `ConcurrentMetadataStore` (xref:meta-data-store.adoc[Metadata Store]).\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/selector/MetadataStoreSelector.html[`MetadataStoreSelector` Javadoc] for more information.\nYou can also customize the `value` for `ConcurrentMetadataStore` by using an additional `MessageProcessor`.\nBy default, `MetadataStoreSelector` uses the `timestamp` message header.\n\nNormally, the selector selects a message for acceptance if there is no existing value for the key.\nIn some cases, it is useful to compare the current and new values for a key to determine whether the message should be accepted.\nStarting with version 5.3, the `compareValues` property is provided which references a `BiPredicate<String, String>`; the first parameter is the old value; return `true` to accept the message and replace the old value with the new value in the `MetadataStore`.\nThis can be useful to reduce the number of keys; for example, when processing lines in a file, you can store the file name in the key and the current line number in the value.\nThen, after a restart, you can skip lines that have already been processed.\nSee xref:file/splitter.adoc#idempotent-file-splitter[Idempotent Downstream Processing a Split File] for an example.\n\nFor convenience, the `MetadataStoreSelector` options are configurable directly on the `<idempotent-receiver>` component.\nThe following listing shows all the possible attributes:\n\n[source,xml]\n----\n<idempotent-receiver\n id=\"\" <1>\n endpoint=\"\" <2>\n selector=\"\" <3>\n discard-channel=\"\" <4>\n metadata-store=\"\" <5>\n key-strategy=\"\" <6>\n key-expression=\"\" <7>\n value-strategy=\"\" <8>\n value-expression=\"\" <9>\n compare-values=\"\" <10>\n throw-exception-on-rejection=\"\" /> <11>\n----\n\n<1> The ID of the `IdempotentReceiverInterceptor` bean.\nOptional.\n<2> Consumer endpoint name(s) or pattern(s) to which this interceptor is applied.\nSeparate names (patterns) with commas (`,`), such as `endpoint=\"aaa, bbb*, *ccc, *ddd*, eee*fff\"`.\nEndpoint bean names matching these patterns are then used to retrieve the target endpoint's `MessageHandler` bean (using its `.handler` suffix), and the `IdempotentReceiverInterceptor` is applied to those beans.\nRequired.\n<3> A `MessageSelector` bean reference.\nMutually exclusive with `metadata-store` and `key-strategy (key-expression)`.\nWhen `selector` is not provided, one of `key-strategy` or `key-strategy-expression` is required.\n<4> Identifies the channel to which to send a message when the `IdempotentReceiverInterceptor` does not accept it.\nWhen omitted, duplicate messages are forwarded to the handler with a `duplicateMessage` header.\nOptional.\n<5> A `ConcurrentMetadataStore` reference.\nUsed by the underlying `MetadataStoreSelector`.\nMutually exclusive with `selector`.\nOptional.\nThe default `MetadataStoreSelector` uses an internal `SimpleMetadataStore` that does not maintain state across application executions.\n<6> A `MessageProcessor` reference.\nUsed by the underlying `MetadataStoreSelector`.\nEvaluates an `idempotentKey` from the request message.\nMutually exclusive with `selector` and `key-expression`.\nWhen a `selector` is not provided, one of `key-strategy` or `key-strategy-expression` is required.\n<7> A SpEL expression to populate an `ExpressionEvaluatingMessageProcessor`.\nUsed by the underlying `MetadataStoreSelector`.\nEvaluates an `idempotentKey` by using the request message as the evaluation context root object.\nMutually exclusive with `selector` and `key-strategy`.\nWhen a `selector` is not provided, one of `key-strategy` or `key-strategy-expression` is required.\n<8> A `MessageProcessor` reference.\nUsed by the underlying `MetadataStoreSelector`.\nEvaluates a `value` for the `idempotentKey` from the request message.\nMutually exclusive with `selector` and `value-expression`.\nBy default, the 'MetadataStoreSelector' uses the 'timestamp' message header as the Metadata 'value'.\n<9> A SpEL expression to populate an `ExpressionEvaluatingMessageProcessor`.\nUsed by the underlying `MetadataStoreSelector`.\nEvaluates a `value` for the `idempotentKey` by using the request message as the evaluation context root object.\nMutually exclusive with `selector` and `value-strategy`.\nBy default, the 'MetadataStoreSelector' uses the 'timestamp' message header as the metadata 'value'.\n<10> A reference to a `BiPredicate<String, String>` bean which allows you to optionally select a message by comparing the old and new values for the key; `null` by default.\n<11> Whether to throw an exception if the `IdempotentReceiverInterceptor` rejects the message.\nDefaults to `false`.\nIt is applied regardless of whether or not a `discard-channel` is provided.\n\nFor Java configuration, Spring Integration provides the method-level `@IdempotentReceiver` annotation.\nIt is used to mark a `method` that has a messaging annotation (`@ServiceActivator`, `@Router, and others) to specify which `IdempotentReceiverInterceptor` objects are applied to this endpoint.\nThe following example shows how to use the `@IdempotentReceiver` annotation:\n\n[source,java]\n----\n@Bean\npublic IdempotentReceiverInterceptor idempotentReceiverInterceptor() {\n return new IdempotentReceiverInterceptor(new MetadataStoreSelector(m ->\n m.getHeaders().get(INVOICE_NBR_HEADER)));\n}\n\n@Bean\n@ServiceActivator(inputChannel = \"input\", outputChannel = \"output\")\n@IdempotentReceiver(\"idempotentReceiverInterceptor\")\npublic MessageHandler myService() {\n ....\n}\n----\n\nWhen you use the Java DSL, you can add the interceptor to the endpoint's advice chain, as the following example shows:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow flow() {\n ...\n .handle(\"someBean\", \"someMethod\",\n e -> e.advice(idempotentReceiverInterceptor()))\n ...\n}\n----\n\nNOTE: The `IdempotentReceiverInterceptor` is designed only for the `MessageHandler.handleMessage(Message<?>)` method.\nStarting with version 4.3.1, it implements `HandleMessageAdvice`, with the `AbstractHandleMessageAdvice` as a base class, for better dissociation.\nSee xref:handler-advice/handle-message.adoc[Handling Message Advice] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/idempotent-receiver.adoc", "title": "idempotent-receiver", "heading": "idempotent-receiver", "heading_level": 1, "file_order": 82, "section_index": 0, "content_hash": "4bfd06eb900fdc444bd8cb668a28b74edb70a5f418a18a69d070ef462f173953", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/idempotent-receiver.adoc"}}
{"id": "sha256:a41964a77ba57e8bab109665ec979a23f3181bb61b38a25585478b33a23978dd", "content": "[[lock-advice]]\n\nStarting with version 6.5, the `LockRequestHandlerAdvice` has been introduced.\nThis advice evaluates a lock key against a request message and performs `LockRegistry.executeLocked()` API.\nThe goal of the advice is to achieve exclusive access to the service invocation according to the `lockKey` context, meaning that different keys may still get concurrent access to the service.\n\nThe `LockRequestHandlerAdvice` requires a xref:distributed-locks.adoc[LockRegistry], and a static, SpEL or function-based lock key callback.\nIf `lockKey` is evaluated to `null`, no locking is held around service call.\nHowever, a `discardChannel` can be provided - and such a message with a null key will be sent to this channel instead.\nAlso, a `waitLockDuration` option can be provided to use `Lock.tryLock(long, TimeUnit)` API instead of `Lock.lockInterruptibly()`.\n\nFollowing is a sample how a `LockRequestHandlerAdvice` can be used:\n\n[source, java]\n----\n@Bean\nLockRegistry lockRegistry() {\n return new DefaultLockRegistry();\n}\n\n@Bean\nQueueChannel discardChannel() {\n return new QueueChannel();\n}\n\n@Bean\nLockRequestHandlerAdvice lockRequestHandlerAdvice(LockRegistry lockRegistry, QueueChannel discardChannel) {\n LockRequestHandlerAdvice lockRequestHandlerAdvice =\n new LockRequestHandlerAdvice(lockRegistry, (message) -> message.getHeaders().get(LOCK_KEY_HEADER));\n lockRequestHandlerAdvice.setDiscardChannel(discardChannel);\n lockRequestHandlerAdvice.setWaitLockDurationExpressionString(\"'PT1s'\");\n return lockRequestHandlerAdvice;\n}\n\nAtomicInteger counter = new AtomicInteger();\n\n@ServiceActivator(inputChannel = \"inputChannel\", adviceChain = \"lockRequestHandlerAdvice\")\nString handleWithDelay(String payload) throws InterruptedException {\n int currentCount = this.counter.incrementAndGet();\n Thread.sleep(\"longer_process\".equals(payload) ? 2000 : 500);\n try {\n return payload + \"-\" + currentCount;\n }\n finally {\n this.counter.decrementAndGet();\n }\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/lock.adoc", "title": "lock", "heading": "lock", "heading_level": 1, "file_order": 83, "section_index": 0, "content_hash": "a41964a77ba57e8bab109665ec979a23f3181bb61b38a25585478b33a23978dd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/lock.adoc"}}
{"id": "sha256:2d1d8f64a2fc64aab7d258d315f69c12759f29ceaaea70dac4739b1554665ef1", "content": "[[advice-order]]\n\nAdvice classes are \"`around`\" advices and are applied in a nested fashion.\nThe first advice is the outermost, while the last advice is the innermost (that is, closest to the handler being advised).\nIt is important to put the advice classes in the correct order to achieve the functionality you desire.\n\nFor example, suppose you want to add a retry advice and a transaction advice.\nYou may want to place the retry advice first, followed by the transaction advice.\nConsequently, each retry is performed in a new transaction.\nOn the other hand, if you want all the attempts and any recovery operations (in the retry `RecoveryCallback`) to be scoped within the transaction, you could put the transaction advice first.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/order.adoc", "title": "order", "heading": "order", "heading_level": 1, "file_order": 84, "section_index": 0, "content_hash": "2d1d8f64a2fc64aab7d258d315f69c12759f29ceaaea70dac4739b1554665ef1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/order.adoc"}}
{"id": "sha256:775e8f4b1742fa83df56b9eb0d42b47dcb97bdaabadc617e136cfbf1f3e8847e", "content": "[[other-advice]]\n\nWhile the abstract class mentioned above is a convenience, you can add any `Advice`, including a transaction advice, to the chain.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/other.adoc", "title": "other", "heading": "other", "heading_level": 1, "file_order": 85, "section_index": 0, "content_hash": "775e8f4b1742fa83df56b9eb0d42b47dcb97bdaabadc617e136cfbf1f3e8847e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/other.adoc"}}
{"id": "sha256:09450f10c689a7b90928b180d8dc86c528a4562a4c2c5d651d7c845cb265bdd6", "content": "[[reactive-advice]]\n\nStarting with version 5.3, a `ReactiveRequestHandlerAdvice` can be used for request message handlers producing a `Mono` replies.\nA `BiFunction<Message<?>, Mono<?>, Publisher<?>>` has to be provided for this advice, and it is called from the `Mono.transform()` operator on a reply produced by the intercepted `handleRequestMessage()` method implementation.\nTypically, such a `Mono` customization is necessary when we would like to control network fluctuations via `timeout()`, `retry()` and similar support operators.\nFor example, when we can an HTTP request over the WebFlux client, we could use the below configuration to not wait for a response more than 5 seconds:\n\n[source, java]\n----\n.handle(WebFlux.outboundGateway(\"https://somehost/\"),\n e -> e.customizeMonoReply((message, mono) -> mono.timeout(Duration.ofSeconds(5))));\n----\n\nThe `message` argument is the request message for the message handler and can be used to determine request-scope attributes.\nThe `mono` argument is the result of this message handler's `handleRequestMessage()` method implementation.\nA nested `Mono.transform()` can also be called from this function to apply, for example, a https://spring.io/projects/spring-cloud-circuitbreaker[Reactive Circuit Breaker].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/reactive.adoc", "title": "reactive", "heading": "reactive", "heading_level": 1, "file_order": 86, "section_index": 0, "content_hash": "09450f10c689a7b90928b180d8dc86c528a4562a4c2c5d651d7c845cb265bdd6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/reactive.adoc"}}
{"id": "sha256:beae00ce2549f111e6e8f0cca9905398a193b279d808b528f5765b7066b4fb3c", "content": "[[tx-handle-message-advice]]\n\nStarting with version 5.0, a new `TransactionHandleMessageAdvice` has been introduced to make the whole downstream flow transactional, thanks to the `HandleMessageAdvice` implementation.\nWhen a regular `TransactionInterceptor` is used in the `<request-handler-advice-chain>` element (for example, through configuring `<tx:advice>`), a started transaction is applied only for an internal `AbstractReplyProducingMessageHandler.handleRequestMessage()` and is not propagated to the downstream flow.\n\nTo simplify XML configuration, along with the `<request-handler-advice-chain>`, a `<transactional>` element has been added to all `<outbound-gateway>` and `<service-activator>` and related components.\nThe following example shows `<transactional>` in use:\n\n[source,xml]\n----\n<int-jdbc:outbound-gateway query=\"select * from things where id=:headers[id]\">\n <int-jdbc:transactional/>\n</int-jdbc:outbound-gateway>\n\n<bean id=\"transactionManager\" class=\"org.mockito.Mockito\" factory-method=\"mock\">\n <constructor-arg value=\"org.springframework.transaction.TransactionManager\"/>\n</bean>\n----\n\nIf you are familiar with the xref:jpa.adoc[JPA integration components], such a configuration is not new, but now we can start a transaction from any point in our flow -- not only from the `<poller>` or a message-driven channel adapter such as xref:changes-2.2-3.0.adoc#x3.0-jms-mdca-te[JMS].\n\nJava configuration can be simplified by using the `TransactionInterceptorBuilder`, and the result bean name can be used in the xref:configuration/annotations.adoc[messaging annotations] `adviceChain` attribute, as the following example shows:\n\n[source,java]\n----\n@Bean\npublic ConcurrentMetadataStore store() {\n return new SimpleMetadataStore(hazelcastInstance()\n .getMap(\"idempotentReceiverMetadataStore\"));\n}\n\n@Bean\npublic IdempotentReceiverInterceptor idempotentReceiverInterceptor() {\n return new IdempotentReceiverInterceptor(\n new MetadataStoreSelector(\n message -> message.getPayload().toString(),\n message -> message.getPayload().toString().toUpperCase(), store()));\n}\n\n@Bean\npublic TransactionInterceptor transactionInterceptor() {\n return new TransactionInterceptorBuilder(true)\n .transactionManager(this.transactionManager)\n .isolation(Isolation.READ_COMMITTED)\n .propagation(Propagation.REQUIRES_NEW)\n .build();\n}\n\n@Bean\n@org.springframework.integration.annotation.Transformer(inputChannel = \"input\",\n outputChannel = \"output\",\n adviceChain = { \"idempotentReceiverInterceptor\",\n \"transactionInterceptor\" })\npublic Transformer transformer() {\n return message -> message;\n}\n----\n\nNote the `true` parameter on the `TransactionInterceptorBuilder` constructor.\nIt causes the creation of a `TransactionHandleMessageAdvice`, not a regular `TransactionInterceptor`.\n\nJava DSL supports an `Advice` through the `.transactional()` options on the endpoint configuration, as the following example shows:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow updatingGatewayFlow() {\n return f -> f\n .handle(Jpa.updatingGateway(this.entityManagerFactory),\n e -> e.transactional(true))\n .channel(c -> c.queue(\"persistResults\"));\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice/tx-handle-message.adoc", "title": "tx-handle-message", "heading": "tx-handle-message", "heading_level": 1, "file_order": 87, "section_index": 0, "content_hash": "beae00ce2549f111e6e8f0cca9905398a193b279d808b528f5765b7066b4fb3c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice/tx-handle-message.adoc"}}
{"id": "sha256:21694cca0b22d20f55d459e6c3793789c486c6d119424403179f0dd1d5336ad1", "content": "[[control-bus-controller]]\n\nStarting with version 6.4, the HTTP module provides an `@EnableControlBusController` configuration class annotation to expose the `ControlBusController` as a REST service at the `/control-bus` path.\nThe `ControlBusControllerConfiguration` underneath enables eager initialization for the `ControlBusCommandRegistry` to expose all the available control bus commands for the mentioned REST service.\nThe `/control-bus` GET request returns all the control bus commands for the application in a format like this:\n\n[source,json]\n----\n[\n {\n \"beanName\": \"errorChannel\",\n \"commands\": [\n {\n \"command\": \"errorChannel.setShouldTrack\",\n \"description\": \"setShouldTrack\",\n \"parameterTypes\": [\n \"boolean\"\n ]\n },\n {\n \"command\": \"errorChannel.setLoggingEnabled\",\n \"description\": \"Use to disable debug logging during normal message flow\",\n \"parameterTypes\": [\n \"boolean\"\n ]\n },\n {\n \"command\": \"errorChannel.isLoggingEnabled\",\n \"description\": \"isLoggingEnabled\",\n \"parameterTypes\": []\n }\n ]\n },\n {\n \"beanName\": \"testManagementComponent\",\n \"commands\": [\n {\n \"command\": \"testManagementComponent.operation2\",\n \"description\": \"operation2\",\n \"parameterTypes\": []\n },\n {\n \"command\": \"testManagementComponent.operation\",\n \"description\": \"operation\",\n \"parameterTypes\": []\n },\n {\n \"command\": \"testManagementComponent.operation\",\n \"description\": \"operation\",\n \"parameterTypes\": [\n \"int\",\n \"java.lang.String\"\n ]\n },\n {\n \"command\": \"testManagementComponent.operation\",\n \"description\": \"operation\",\n \"parameterTypes\": [\n \"int\"\n ]\n }\n ]\n }\n]\n----\n\nEssentially, a JSON-serialized list of `ControlBusController.ControlBusBean` instances.\nEach entry is a bean with a list of control bus eligible methods (see `ControlBusMethodFilter` for more information) with their parameter types and description from the `@ManagedOperation` or `@ManagedAttribute` (falls back to method name otherwise).\n\nThe POST method to `/control-bus/{beanName.methodName}` invokes the command.\nThe body of the request may contain a list of values and their types for command to execute.\nFor example, the `operation` command with `int` argument for the class:\n\n[source,java]\n----\n@ManagedResource\nclass TestManagementComponent {\n\n @ManagedOperation\n public void operation() {\n\n }\n\n @ManagedOperation(description = \"The overloaded operation with int argument\")\n public void operation(int input) {\n\n }\n\n @ManagedOperation(description = \"The overloaded operation with two arguments\")\n public void operation(int input1, String input2) {\n\n }\n\n @ManagedOperation\n public int operation2() {\n return 123;\n }\n\n}\n----\n\ncould be called like `/testManagementComponent.operation` using mention POST method with body:\n\n[source,json]\n----\n[\n {\n \"value\": \"1\",\n \"parameterType\": \"int\"\n }\n]\n----\n\nSee xref:control-bus.adoc[Control Bus] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/control-bus-controller.adoc", "title": "control-bus-controller", "heading": "control-bus-controller", "heading_level": 1, "file_order": 88, "section_index": 0, "content_hash": "21694cca0b22d20f55d459e6c3793789c486c6d119424403179f0dd1d5336ad1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/control-bus-controller.adoc"}}
{"id": "sha256:167a517e5856ec1295c2cb3042793a34ff9577c84966f850876080964bec096f", "content": "[[http-header-mapping]]\n\nSpring Integration provides support for HTTP header mapping for both HTTP Request and HTTP Responses.\n\nBy default, all standard https://en.wikipedia.org/wiki/List_of_HTTP_header_fields[HTTP headers] are mapped from the message to HTTP request or response headers without further configuration.\nHowever, if you do need further customization, you can provide additional configuration by taking advantage of the namespace support.\nYou can provide a comma-separated list of header names, and you can include simple patterns with the '*' character acting as a wildcard.\nProvide such values overrides the default behavior.\nBasically, it assumes you are in complete control at that point.\nHowever, if you do want to include all the standard HTTP headers, you can use the shortcut patterns: `HTTP_REQUEST_HEADERS` and `HTTP_RESPONSE_HEADERS`.\nThe following listing shows two examples (the first of which uses a wildcard):\n\n[source,xml]\n----\n<int-http:outbound-gateway id=\"httpGateway\"\n url=\"http://localhost/test2\"\n mapped-request-headers=\"thing1, thing2\"\n mapped-response-headers=\"X-*, HTTP_RESPONSE_HEADERS\"\n channel=\"someChannel\"/>\n\n<int-http:outbound-channel-adapter id=\"httpAdapter\"\n url=\"http://localhost/test2\"\n mapped-request-headers=\"thing1, thing2, HTTP_REQUEST_HEADERS\"\n channel=\"someChannel\"/>\n----\n\nThe adapters and gateways use the `DefaultHttpHeaderMapper`, which now provides two static factory methods for inbound and outbound adapters so that the proper direction can be applied (mapping HTTP requests and responses either in or out, as appropriate).\n\nIf you need further customization, you can also configure a `DefaultHttpHeaderMapper` independently and inject it into the adapter through the `header-mapper` attribute.\n\nBefore version 5.0, the `DefaultHttpHeaderMapper` the default prefix for user-defined, non-standard HTTP headers was `X-`.\nVersion 5.0 changed the default prefix to an empty string.\nAccording to https://tools.ietf.org/html/rfc6648[RFC-6648], the use of such prefixes is now discouraged.\nYou can still customize this option by setting the `DefaultHttpHeaderMapper.setUserDefinedHeaderPrefix()` property.\nThe following example configures a header mapper for an HTTP gateway:\n\n[source,xml]\n----\n<int-http:outbound-gateway id=\"httpGateway\"\n url=\"http://localhost/test2\"\n header-mapper=\"headerMapper\"\n channel=\"someChannel\"/>\n\n<bean id=\"headerMapper\" class=\"o.s.i.http.support.DefaultHttpHeaderMapper\">\n <property name=\"inboundHeaderNames\" value=\"thing1*, *thing2, thing3\"/>\n <property name=\"outboundHeaderNames\" value=\"a*b, d\"/>\n</bean>\n----\n\nIf you need to do something other than what the `DefaultHttpHeaderMapper` supports, you can implement the `HeaderMapper` strategy interface directly and provide a reference to your implementation.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/header-mapping.adoc", "title": "header-mapping", "heading": "header-mapping", "heading_level": 1, "file_order": 89, "section_index": 0, "content_hash": "167a517e5856ec1295c2cb3042793a34ff9577c84966f850876080964bec096f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/header-mapping.adoc"}}
{"id": "sha256:1f0b988912e18f7f7a8d8ea488eecd1bf640f17f668886db48e7aba375a1021a", "content": "[[http-inbound]]\n\nTo receive messages over HTTP, you need to use an HTTP inbound channel adapter or an HTTP inbound gateway.\nTo support the HTTP inbound adapters, they need to be deployed within a servlet container such as https://tomcat.apache.org/[Apache Tomcat] or https://www.eclipse.org/jetty/[Jetty].\nThe easiest way to do this is to use Spring's https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/context/support/HttpRequestHandlerServlet.html[`HttpRequestHandlerServlet`], by providing the following servlet definition in the `web.xml` file:\n\n[source,xml]\n----\n<servlet>\n <servlet-name>inboundGateway</servlet-name>\n <servlet-class>o.s.web.context.support.HttpRequestHandlerServlet</servlet-class>\n</servlet>\n----\n\nNotice that the servlet name matches the bean name.\nFor more information see the `HttpRequestHandlerServlet` Javadocs.\n\nIf you are running within a Spring MVC application, then the aforementioned explicit servlet definition is not necessary.\nIn that case, the bean name for your gateway can be matched against the URL path as you would for a Spring MVC Controller bean.\nFor more information, see\nhttps://docs.spring.io/spring-framework/reference/web/webmvc.html[Web MVC framework], which is part of the Spring Framework Reference documentation.\n\nTIP: For a sample application and the corresponding configuration, see the https://github.com/spring-projects/spring-integration-samples[Spring Integration Samples] repository.\nIt contains the https://github.com/spring-projects/spring-integration-samples/tree/main/basic/http[HTTP sample] application, which demonstrates Spring Integration's HTTP support.\n\nThe following example bean defines an HTTP inbound endpoint:\n\n[source,xml]\n----\n<bean id=\"httpInbound\"\n class=\"org.springframework.integration.http.inbound.HttpRequestHandlingMessagingGateway\">\n <property name=\"requestChannel\" ref=\"httpRequestChannel\" />\n <property name=\"replyChannel\" ref=\"httpReplyChannel\" />\n</bean>\n----\n\nThe `HttpRequestHandlingMessagingGateway` accepts a list of `HttpMessageConverter` instances or else relies on a default list.\nThe converters allow customization of the mapping from `HttpServletRequest` to `Message`.\nThe default converters encapsulate simple strategies, which, for example, create a `String` message for a `POST` request where the content type starts with `text`.\nSee the https://docs.spring.io/spring-integration/api/index.html[Javadoc] for full details.\nAn additional flag (`mergeWithDefaultConverters`) can be set along with the list of custom `HttpMessageConverter` to add the default converters after the custom converters.\nBy default, this flag is set to `false`, meaning that the custom converters replace the default list.\n\nThe message conversion process uses the (optional) `requestPayloadType` property and the incoming `Content-Type` header.\nStarting with version 4.3, if a request has no content type header, `application/octet-stream` is assumed, as recommended by `RFC 2616`.\nPreviously, the body of such messages was ignored.\n\nSpring Integration 2.0 implemented multipart file support.\nIf the request has been wrapped as a `MultipartHttpServletRequest`, when you use the default converters, that request is converted to a `Message` payload that is a `MultiValueMap` containing values that may be byte arrays, strings, or instances of Spring's `MultipartFile`, depending on the content type of the individual parts.\n\nNOTE: The HTTP inbound endpoint locates a `MultipartResolver` in the context if one has a bean name of `multipartResolver` (the same name expected by Spring's `DispatcherServlet`).\nIf it does locate that bean, the support for multipart files is enabled on the inbound request mapper.\nOtherwise, it fails when it tries to map a multipart file request to a Spring Integration `Message`.\nFor more on Spring's support for `MultipartResolver`, see the https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet/multipart.html[Spring Reference Manual].\n\n[NOTE]\n====\nIf you wish to proxy a `multipart/form-data` to another server, it may be better to keep it in raw form.\nTo handle this situation, do not add the `multipartResolver` bean to the context.\nConfigure the endpoint to expect a `byte[]` request, customize the message converters to include a `ByteArrayHttpMessageConverter`, and disable the default multipart converter.\nYou may need some other converters for the replies.\nThe following example shows such an arrangement:\n\n[source, xml]\n----\n<int-http:inbound-gateway\n channel=\"receiveChannel\"\n path=\"/inboundAdapter.htm\"\n request-payload-type=\"byte[]\"\n message-converters=\"converters\"\n merge-with-default-converters=\"false\"\n supported-methods=\"POST\" />\n\n<util:list id=\"converters\">\n <beans:bean class=\"org.springframework.http.converter.ByteArrayHttpMessageConverter\" />\n <beans:bean class=\"org.springframework.http.converter.StringHttpMessageConverter\" />\n <beans:bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\" />\n</util:list>\n----\n====\n\nWhen you send a response to the client, you have a number of ways to customize the behavior of the gateway.\nBy default, the gateway acknowledges that the request was received by sending a `200` status code back.\nIt is possible to customize this response by providing a 'viewName' to be resolved by the Spring MVC `ViewResolver`.\nIf the gateway should expect a reply to the `Message`, you can set the `expectReply` flag (constructor argument) to cause the gateway to wait for a reply `Message` before creating an HTTP response.\nThe following example configures a gateway to serve as a Spring MVC Controller with a view name:\n\n[source,xml]\n----\n<bean id=\"httpInbound\"\n class=\"org.springframework.integration.http.inbound.HttpRequestHandlingController\">\n <constructor-arg value=\"true\" /> <!-- indicates that a reply is expected -->\n <property name=\"requestChannel\" ref=\"httpRequestChannel\" />\n <property name=\"replyChannel\" ref=\"httpReplyChannel\" />\n <property name=\"viewName\" value=\"jsonView\" />\n <property name=\"supportedMethodNames\" >\n <list>\n <value>GET</value>\n <value>DELETE</value>\n </list>\n </property>\n</bean>\n----\n\nBecause of the `constructor-arg` value of `true`, it waits for a reply.\nThe preceding example also shows how to customize the HTTP methods accepted by the gateway, which are `POST` and `GET` by default.\n\nThe reply message is available in the model map.\nBy default, the key for that map entry is 'reply', but you can override this default by setting the 'replyKey' property on the endpoint's configuration.\n\n[[http-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/inbound.adoc", "title": "inbound", "heading": "inbound", "heading_level": 1, "file_order": 90, "section_index": 0, "content_hash": "1f0b988912e18f7f7a8d8ea488eecd1bf640f17f668886db48e7aba375a1021a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/inbound.adoc"}}
{"id": "sha256:ee6dc542159a38478db2e65cb7f9f93cb21dd7f943335425553aa8413af4389d", "content": "Starting with version 5.2, the HTTP inbound endpoints can be supplied with a `Validator` to check a payload before sending into the channel.\nThis payload is already a result of conversion and extraction after `payloadExpression` to narrow a validation scope in regard to the valuable data.\nThe validation failure handling is fully the same as what we have in Spring MVC https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet/exceptionhandlers.html[Error Handling].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/inbound.adoc", "title": "inbound", "heading": "Payload Validation", "heading_level": 2, "file_order": 90, "section_index": 1, "content_hash": "ee6dc542159a38478db2e65cb7f9f93cb21dd7f943335425553aa8413af4389d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/inbound.adoc"}}
{"id": "sha256:9f4d31e2b1f4a6074e1ea2d2b18143a0fa7817499ba12307d19757a2d11700ec", "content": "[[int-graph-controller]]\n\nStarting with version 4.3, the HTTP module provides an `@EnableIntegrationGraphController` configuration class annotation and an `<int-http:graph-controller/>` XML element to expose the `IntegrationGraphServer` as a REST service.\nSee the xref:graph.adoc[Integration Graph] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/int-graph-controller.adoc", "title": "int-graph-controller", "heading": "int-graph-controller", "heading_level": 1, "file_order": 91, "section_index": 0, "content_hash": "9f4d31e2b1f4a6074e1ea2d2b18143a0fa7817499ba12307d19757a2d11700ec", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/int-graph-controller.adoc"}}
{"id": "sha256:9884aa8df802a28f183447d51d354e8783cd6233de1bcc427b192071f0dfa896", "content": "[[http-java-config]]\n\nThe following example shows how to configure an inbound gateway with Java:\n\n.Inbound Gateway Using Java Configuration\n[source, java]\n----\n@Bean\npublic HttpRequestHandlingMessagingGateway inbound() {\n HttpRequestHandlingMessagingGateway gateway =\n new HttpRequestHandlingMessagingGateway(true);\n gateway.setRequestMapping(mapping());\n gateway.setRequestPayloadType(String.class);\n gateway.setRequestChannelName(\"httpRequest\");\n return gateway;\n}\n\n@Bean\npublic RequestMapping mapping() {\n RequestMapping requestMapping = new RequestMapping();\n requestMapping.setPathPatterns(\"/foo\");\n requestMapping.setMethods(HttpMethod.POST);\n return requestMapping;\n}\n----\n\nThe following example shows how to configure an inbound gateway with the Java DSL:\n\n.Inbound Gateway Using the Java DSL\n[source, java]\n----\n@Bean\npublic IntegrationFlow inbound() {\n return IntegrationFlow.from(Http.inboundGateway(\"/foo\")\n .requestMapping(m -> m.methods(HttpMethod.POST))\n .requestPayloadType(String.class))\n .channel(\"httpRequest\")\n .get();\n}\n----\n\nThe following example shows how to configure an outbound gateway with Java:\n\n.Outbound Gateway Using Java Configuration\n[source, java]\n----\n@ServiceActivator(inputChannel = \"httpOutRequest\")\n@Bean\npublic HttpRequestExecutingMessageHandler outbound() {\n HttpRequestExecutingMessageHandler handler =\n new HttpRequestExecutingMessageHandler(\"http://localhost:8080/foo\");\n handler.setHttpMethod(HttpMethod.POST);\n handler.setExpectedResponseType(String.class);\n return handler;\n}\n----\n\nThe following example shows how to configure an outbound gateway with the Java DSL:\n\n.Outbound Gateway Using the Java DSL\n[source, java]\n----\n@Bean\npublic IntegrationFlow outbound() {\n return IntegrationFlow.from(\"httpOutRequest\")\n .handle(Http.outboundGateway(\"http://localhost:8080/foo\")\n .httpMethod(HttpMethod.POST)\n .expectedResponseType(String.class))\n .get();\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/java-config.adoc", "title": "java-config", "heading": "java-config", "heading_level": 1, "file_order": 92, "section_index": 0, "content_hash": "9884aa8df802a28f183447d51d354e8783cd6233de1bcc427b192071f0dfa896", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/java-config.adoc"}}
{"id": "sha256:7a6395ef8045ba2cd10e67c01f7ac9578db3a68b7df659cdfb328a75587ea53f", "content": "[[http-namespace]]\n\nSpring Integration provides an `http` namespace and the corresponding schema definition.\nTo include it in your configuration, provide the following namespace declaration in your application context configuration file:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int=\"http://www.springframework.org/schema/integration\"\n xmlns:int-http=\"http://www.springframework.org/schema/integration/http\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration.xsd\n http://www.springframework.org/schema/integration/http\n https://www.springframework.org/schema/integration/http/spring-integration-http.xsd\">\n ...\n</beans>\n----\n\n[[inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/namespace.adoc", "title": "namespace", "heading": "namespace", "heading_level": 1, "file_order": 93, "section_index": 0, "content_hash": "7a6395ef8045ba2cd10e67c01f7ac9578db3a68b7df659cdfb328a75587ea53f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/namespace.adoc"}}
{"id": "sha256:4431e03733b962b2554bd05dad4e4c18dc01176c1f7f45df81005d36d813c149", "content": "The XML namespace provides two components for handling HTTP inbound requests: `inbound-channel-adapter` and `inbound-gateway`.\nIn order to process requests without returning a dedicated response, use the `inbound-channel-adapter`.\nThe following example shows how to configure one:\n\n[source,xml]\n----\n<int-http:inbound-channel-adapter id=\"httpChannelAdapter\" channel=\"requests\"\n supported-methods=\"PUT, DELETE\"/>\n----\n\nTo process requests that do expect a response, use an `inbound-gateway`.\nThe following example shows how to configure one:\n\n[source,xml]\n----\n<int-http:inbound-gateway id=\"inboundGateway\"\n request-channel=\"requests\"\n reply-channel=\"responses\"/>\n----\n\n[[http-request-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/namespace.adoc", "title": "namespace", "heading": "Inbound", "heading_level": 2, "file_order": 93, "section_index": 1, "content_hash": "4431e03733b962b2554bd05dad4e4c18dc01176c1f7f45df81005d36d813c149", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/namespace.adoc"}}
{"id": "sha256:587aa358d114a851cbd53f32f8955d9e9d897ea0aa71a08b9aaf33f27974a28f", "content": "NOTE: Spring Integration 3.0 improved the REST support by introducing the https://docs.spring.io/spring-integration/api/org/springframework/integration/http/inbound/IntegrationRequestMappingHandlerMapping.html[`IntegrationRequestMappingHandlerMapping`].\nThe implementation relies on the enhanced REST support provided by Spring Framework 3.1 or higher.\n\nThe parsing of the HTTP inbound gateway or the HTTP inbound channel adapter registers an `integrationRequestMappingHandlerMapping` bean of type https://docs.spring.io/spring-integration/api/org/springframework/integration/http/inbound/IntegrationRequestMappingHandlerMapping.html[`IntegrationRequestMappingHandlerMapping`], in case one is not yet registered.\nThis particular implementation of the https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/HandlerMapping.html[`HandlerMapping`] delegates its logic to https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/RequestMappingInfoHandlerMapping.html[`RequestMappingInfoHandlerMapping`].\nThe implementation provides functionality similar to the https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestMapping.html[`org.springframework.web.bind.annotation.RequestMapping`] annotation in Spring MVC.\n\nNOTE: For more information, see https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping[Mapping Requests With `@RequestMapping`].\n\nFor this purpose, Spring Integration 3.0 introduces the `<request-mapping>` element.\nYou can add this optional element to `<http:inbound-channel-adapter>` and `<http:inbound-gateway>`.\nIt works in conjunction with the `path` and `supported-methods` attributes.\nThe following example shows how to configure it on an inbound gateway:\n\n[source,xml]\n----\n<inbound-gateway id=\"inboundController\"\n request-channel=\"requests\"\n reply-channel=\"responses\"\n path=\"/foo/{fooId}\"\n supported-methods=\"GET\"\n view-name=\"foo\"\n error-code=\"oops\">\n <request-mapping headers=\"User-Agent\"\n params=\"myParam=myValue\"\n consumes=\"application/json\"\n produces=\"!text/plain\"/>\n</inbound-gateway>\n----\n\nBased on the preceding configuration, the namespace parser creates an instance of the `IntegrationRequestMappingHandlerMapping` (if none exists) and an `HttpRequestHandlingController` bean and associates with it an instance of https://docs.spring.io/spring-integration/api/org/springframework/integration/http/inbound/RequestMapping.html[`RequestMapping`].\nThis `RequestMapping` instance is, in turn, converted to the Spring MVC https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/mvc/method/RequestMappingInfo.html[`RequestMappingInfo`].\n\nThe `<request-mapping>` element provides the following attributes:\n\n* `headers`\n* `params`\n* `consumes`\n* `produces`\n\nWith the `path` and `supported-methods` attributes of the `<http:inbound-channel-adapter>` or the `<http:inbound-gateway>`, `<request-mapping>` attributes translate directly into the respective options provided by the `org.springframework.web.bind.annotation.RequestMapping` annotation in Spring MVC.\n\nThe `<request-mapping>` element lets you configure several Spring Integration HTTP inbound endpoints to the same `path` (or even the same `supported-methods`) and lets you provide different downstream message flows based on incoming HTTP requests.\n\nAlternatively, you can also declare only one HTTP inbound endpoint and apply routing and filtering logic within the Spring Integration flow to achieve the same result.\nThis lets you get the `Message` into the flow as early as possibly.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<int-http:inbound-gateway request-channel=\"httpMethodRouter\"\n supported-methods=\"GET,DELETE\"\n path=\"/process/{entId}\"\n payload-expression=\"#pathVariables.entId\"/>\n\n<int:router input-channel=\"httpMethodRouter\" expression=\"headers.http_requestMethod\">\n <int:mapping value=\"GET\" channel=\"in1\"/>\n <int:mapping value=\"DELETE\" channel=\"in2\"/>\n</int:router>\n\n<int:service-activator input-channel=\"in1\" ref=\"service\" method=\"getEntity\"/>\n\n<int:service-activator input-channel=\"in2\" ref=\"service\" method=\"delete\"/>\n----\n\nFor more information regarding handler mappings, see https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html[the Spring Framework Web Servlet documentation] or https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html[the Spring Framework Web Reactive documentation].\n\nIMPORTANT: The `IntegrationRequestMappingHandlerMapping` extends the Spring MVC `RequestMappingHandlerMapping` class, inheriting most of its logic, especially `handleNoMatch(Set, String, HttpServletRequest)`, which throws a specific `4xx` error for the HTTP response, when mapping doesn't match for some reason, preventing calls to any remaining mapping handlers in the application context.\nFor this reason, configuring the same path for both Spring Integration and Spring MVC request mappings (e.g. `POST` in one and `GET` in the other) is not supported; the MVC mapping will not be found..\n\n[[http-cors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/namespace.adoc", "title": "namespace", "heading": "Request Mapping Support", "heading_level": 2, "file_order": 93, "section_index": 2, "content_hash": "587aa358d114a851cbd53f32f8955d9e9d897ea0aa71a08b9aaf33f27974a28f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/namespace.adoc"}}
{"id": "sha256:865807f14229e030463c71008fa11c7613812bdb7ff9f3b7a700192aa8a88985", "content": "Starting with version 4.2, you can configure the `<http:inbound-channel-adapter>` and `<http:inbound-gateway>` with a `<cross-origin>` element.\nIt represents the same options as Spring MVC's `@CrossOrigin` for `@Controller` annotations and allows the configuration of cross-origin resource sharing (CORS) for Spring Integration HTTP endpoints:\n\n* `origin`: List of allowed origins.\nThe `pass:[*]` means that all origins are allowed.\nThese values are placed in the `Access-Control-Allow-Origin` header of both the pre-flight and actual responses.\nThe default value is `pass:[*]`.\n* `allowed-headers`: Indicates which request headers can be used during the actual request.\nThe `pass:[*]` means that all headers requested by the client are allowed.\nThis property controls the value of the pre-flight response's `Access-Control-Allow-Headers` header.\nThe default value is `pass:[*]`.\n* `exposed-headers`: List of response headers that the user-agent lets the client access.\nThis property controls the value of the actual response's `Access-Control-Expose-Headers` header.\n* `method`: The HTTP request methods to allow: `GET`, `POST`, `HEAD`, `OPTIONS`, `PUT`, `PATCH`, `DELETE`, `TRACE`.\nMethods specified here overrides those in `supported-methods`.\n* `allow-credentials`: Set to `true` if the browser should include any cookies associated to the domain of the request or `false` if it should not.\nAn empty string (\"\") means undefined.\nIf `true`, the pre-flight response includes the `Access-Control-Allow-Credentials=true` header.\nThe default value is `true`.\n* `max-age`: Controls the cache duration for pre-flight responses.\nSetting this to a reasonable value can reduce the number of pre-flight request-response interactions required by the browser.\nThis property controls the value of the `Access-Control-Max-Age` header in the pre-flight response.\nA value of `-1` means undefined.\nThe default value is 1800 seconds (30 minutes).\n\nThe CORS Java Configuration is represented by the `org.springframework.integration.http.inbound.CrossOrigin` class, instances of which can be injected into the `HttpRequestHandlingEndpointSupport` beans.\n\n[[http-response-statuscode]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/namespace.adoc", "title": "namespace", "heading": "Cross-origin Resource Sharing (CORS) Support", "heading_level": 2, "file_order": 93, "section_index": 3, "content_hash": "865807f14229e030463c71008fa11c7613812bdb7ff9f3b7a700192aa8a88985", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/namespace.adoc"}}
{"id": "sha256:1af34b22cde91842c48e2e4c5e58063fa0038bdbec370659545c3eff11f86d98", "content": "Starting with version 4.1, you can configure the `<http:inbound-channel-adapter>` with a `status-code-expression` to override the default `200 OK` status.\nThe expression must return an object that can be converted to an `org.springframework.http.HttpStatus` enum value.\nThe `evaluationContext` has a `BeanResolver` and, starting with version 5.1, is supplied with the `RequestEntity<?>` as root object.\nAn example might be to resolve, at runtime, some scoped bean that returns a status code value.\nHowever, most likely, it is set to a fixed value such as `status-code=expression=\"204\"` (No Content), or `status-code-expression=\"T(org.springframework.http.HttpStatus).NO_CONTENT\"`.\nBy default, `status-code-expression` is null, meaning that the normal '200 OK' response status is returned.\nUsing the `RequestEntity<?>` as root object, the status code can be conditional e.g. on the request method, some header, URI content or even request body.\nThe following example shows how to set the status code to `ACCEPTED`:\n\n[source,xml]\n----\n<http:inbound-channel-adapter id=\"inboundController\"\n channel=\"requests\" view-name=\"foo\" error-code=\"oops\"\n status-code-expression=\"T(org.springframework.http.HttpStatus).ACCEPTED\">\n <request-mapping headers=\"BAR\"/>\n</http:inbound-channel-adapter>\n----\n\nThe `<http:inbound-gateway>` resolves the 'status code' from the `http_statusCode` header of the reply `Message`.\nStarting with version 4.2, the default response status code when no reply is received within the `reply-timeout` is `500 Internal Server Error`.\nThere are two ways to modify this behavior:\n\n* Add a `reply-timeout-status-code-expression`.\nThis has the same semantics as the `status-code-expression` on the inbound adapter.\n* Add an `error-channel` and return an appropriate message with an HTTP status code header, as the following example shows:\n+\n[source, xml]\n----\n<int:chain input-channel=\"errors\">\n <int:header-enricher>\n <int:header name=\"http_statusCode\" value=\"504\" />\n </int:header-enricher>\n <int:transformer expression=\"payload.failedMessage\" />\n</int:chain>\n----\n\nThe payload of the `ErrorMessage` is a `MessageTimeoutException`.\nIt must be transformed to something that can be converted by the gateway, such as a `String`.\nA good candidate is the exception's message property, which is the value used when you use the `expression` technique.\n\nIf the error flow times out after a main flow timeout, `500 Internal Server Error` is returned, or, if the `reply-timeout-status-code-expression` is present, it is evaluated.\n\nNOTE: Previously, the default status code for a timeout was `200 OK`.\nTo restore that behavior, set `reply-timeout-status-code-expression=\"200\"`.\n\nAlso, starting with version 5.4, an error that is encountered while preparing the request message is sent to the error channel (if provided).\nA decision about throwing an appropriate exception should be done in the error flow by examining the exception.\nPreviously, any exceptions were simply thrown, causing an HTTP 500 server error response status, but in some cases the problem can be caused by incorrect request params, so a `ResponseStatusException` with a 4xx client error status should be thrown instead.\nSee `ResponseStatusException` for more information.\nThe `ErrorMessage` sent to this error channel contains the original exception as the payload for analysis.\n[[uri-template-variables-and-expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/namespace.adoc", "title": "namespace", "heading": "Response Status Code", "heading_level": 2, "file_order": 93, "section_index": 4, "content_hash": "1af34b22cde91842c48e2e4c5e58063fa0038bdbec370659545c3eff11f86d98", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/namespace.adoc"}}
{"id": "sha256:54e5a2d4ee1f982ac35dba37d68535e77068ddc02817f72b151d9d62dc51b13e", "content": "By using the `path` attribute in conjunction with the `payload-expression` attribute and the `header` element, you have a high degree of flexibility for mapping inbound request data.\n\nIn the following example configuration, an inbound channel adapter is configured to accept requests using the following URI:\n\n[source]\n----\n/first-name/{firstName}/last-name/{lastName}\n----\n\nWhen you use the `payload-expression` attribute, the `+{firstName}+` URI template variable maps to be the `Message` payload, while the `+{lastName}+` URI template variable maps to the `lname` message header, as defined in the following example:\n\n[source,xml]\n----\n<int-http:inbound-channel-adapter id=\"inboundAdapterWithExpressions\"\n path=\"/first-name/{firstName}/last-name/{lastName}\"\n channel=\"requests\"\n payload-expression=\"#pathVariables.firstName\">\n <int-http:header name=\"lname\" expression=\"#pathVariables.lastName\"/>\n</int-http:inbound-channel-adapter>\n----\n\nFor more information about URI template variables, see https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-uri-templates[uri template patterns] in the Spring Reference Manual.\n\nSince Spring Integration 3.0, in addition to the existing `#pathVariables` and `#requestParams` variables being available in payload and header expressions, we added other useful expression variables:\n\n* `#requestParams`: The `MultiValueMap` from the `ServletRequest` `parameterMap`.\n* `#pathVariables`: The `Map` from URI Template placeholders and their values.\n* `#matrixVariables`: The `Map` of `MultiValueMap` according to the https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-matrix-variables[Spring MVC Specification].\nNote that `#matrixVariables` requires Spring MVC 3.2 or higher.\n* `#requestAttributes`: The `org.springframework.web.context.request.RequestAttributes` associated with the current request.\n* `#requestHeaders`: The `org.springframework.http.HttpHeaders` object from the current request.\n* `#cookies`: The `MultiValueMap<String, Cookie>` of `jakarta.servlet.http.Cookie` instances from the current request.\n\nNote that all these values (and others) can be accessed within expressions in the downstream message flow through the `ThreadLocal` `org.springframework.web.context.request.RequestAttributes` variable, if that message flow is single-threaded and lives within the request thread.\nThe following example configures a transformer that uses an `expression` attribute:\n\n[source,xml]\n----\n<int-:transformer\n expression=\"T(org.springframework.web.context.request.RequestContextHolder).\n requestAttributes.request.queryString\"/>\n\n----\n\n[[outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/namespace.adoc", "title": "namespace", "heading": "URI Template Variables and Expressions", "heading_level": 2, "file_order": 93, "section_index": 5, "content_hash": "54e5a2d4ee1f982ac35dba37d68535e77068ddc02817f72b151d9d62dc51b13e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/namespace.adoc"}}
{"id": "sha256:698e4dd6aab9914b5eeb7c91eda82ca50e66e2f1e3caa72b122f9ec8f5ee5fde", "content": "To configure the outbound gateway, you can use the namespace support.\nThe following code snippet shows the available configuration options for an outbound HTTP gateway:\n\n[source,xml]\n----\n<int-http:outbound-gateway id=\"example\"\n request-channel=\"requests\"\n url=\"http://localhost/test\"\n http-method=\"POST\"\n extract-request-payload=\"false\"\n expected-response-type=\"java.lang.String\"\n charset=\"UTF-8\"\n request-factory=\"requestFactory\"\n reply-timeout=\"1234\"\n reply-channel=\"replies\"/>\n----\n\nMost importantly, notice that the 'http-method' and 'expected-response-type' attributes are provided.\nThose are two of the most commonly configured values.\nThe default `http-method` is `POST`, and the default response type is null.\nWith a null response type, the payload of the reply `Message` contains the `ResponseEntity`, as long as its HTTP status is a success (non-successful status codes throw exceptions).\nIf you expect a different type, such as a `String`, provide that as a fully-qualified class name (`java.lang.String` in the preceding example).\nSee also the note about empty response bodies in xref:http/outbound.adoc[HTTP Outbound Components].\n\nIMPORTANT: Beginning with Spring Integration 2.1, the `request-timeout` attribute of the HTTP outbound gateway was renamed to `reply-timeout` to better reflect its intent.\n\n[IMPORTANT]\n=====\nSince Spring Integration 2.2, Java serialization over HTTP has been no longer enabled by default.\nPreviously, when setting the `expected-response-type` attribute to a `Serializable` object, the `Accept` header was not properly set up.\nSince Spring Integration 2.2, the `SerializingHttpMessageConverter` has now been updated to set the `Accept` header to `application/x-java-serialized-object`.\n\nHowever, because this could cause incompatibility with existing applications, it was decided to no longer automatically add this converter to the HTTP endpoints.\nIf you wish to use Java serialization, you can add the `SerializingHttpMessageConverter` to the appropriate endpoints, by using the `message-converters` attribute (when you use XML configuration) or by using the `setMessageConverters()` method (in Java configuration).\nAlternatively, you may wish to consider using JSON instead, which is enabled by having https://github.com/FasterXML/jackson[the Jackson library] on the classpath.\n=====\n\nBeginning with Spring Integration 2.2, you can also determine the HTTP method dynamically by using SpEL and the `http-method-expression` attribute.\nNote that this attribute is mutually exclusive with `http-method`.\nYou can also use the `expected-response-type-expression` attribute instead of `expected-response-type` and provide any valid SpEL expression that determines the type of the response.\nThe following configuration example uses `expected-response-type-expression`:\n\n[source,xml]\n----\n<int-http:outbound-gateway id=\"example\"\n request-channel=\"requests\"\n url=\"http://localhost/test\"\n http-method-expression=\"headers.httpMethod\"\n extract-request-payload=\"false\"\n expected-response-type-expression=\"payload\"\n charset=\"UTF-8\"\n request-factory=\"requestFactory\"\n reply-timeout=\"1234\"\n reply-channel=\"replies\"/>\n----\n\nIf your outbound adapter is to be used in a unidirectional way, you can use an `outbound-channel-adapter` instead.\nThis means that a successful response executes without sending any messages to a reply channel.\nIn the case of any non-successful response status code, it throws an exception.\nThe configuration looks very similar to the gateway, as the following example shows:\n\n[source,xml]\n----\n<int-http:outbound-channel-adapter id=\"example\"\n url=\"http://localhost/example\"\n http-method=\"GET\"\n channel=\"requests\"\n charset=\"UTF-8\"\n extract-payload=\"false\"\n expected-response-type=\"java.lang.String\"\n request-factory=\"someRequestFactory\"\n order=\"3\"\n auto-startup=\"false\"/>\n----\n\n[NOTE]\n=====\nTo specify the URL, you can use either the 'url' attribute or the 'url-expression' attribute.\nThe 'url' attribute takes a simple string (with placeholders for URI variables, as described below).\nThe 'url-expression' is a SpEL expression, with the `Message` as the root object, which enables dynamic urls.\nThe URL that results from the expression evaluation can still have placeholders for URI variables.\n\nIn previous releases, some users used the placeholders to replace the entire URL with a URI variable.\nChanges in Spring 3.1 can cause some issues with escaped characters, such as '?'.\nFor this reason, we recommend that, if you wish to generate the URL entirely at runtime, you use the 'url-expression' attribute.\n=====\n\n[[mapping-uri-variables]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/namespace.adoc", "title": "namespace", "heading": "Outbound", "heading_level": 2, "file_order": 93, "section_index": 6, "content_hash": "698e4dd6aab9914b5eeb7c91eda82ca50e66e2f1e3caa72b122f9ec8f5ee5fde", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/namespace.adoc"}}
{"id": "sha256:7e50b718a11f032d8add4dc527f476c0a36ff7cb108424aa352fd49cc6518c47", "content": "If your URL contains URI variables, you can map them by using the `uri-variable` element.\nThis element is available for the HTTP outbound gateway and the HTTP outbound channel adapter.\nThe following example maps the `zipCode` URI variable to an expression:\n\n[source,xml]\n----\n<int-http:outbound-gateway id=\"trafficGateway\"\n url=\"https://local.yahooapis.com/trafficData?appid=YdnDemo&amp;zip={zipCode}\"\n request-channel=\"trafficChannel\"\n http-method=\"GET\"\n expected-response-type=\"java.lang.String\">\n <int-http:uri-variable name=\"zipCode\" expression=\"payload.getZip()\"/>\n</int-http:outbound-gateway>\n----\n\nThe `uri-variable` element defines two attributes: `name` and `expression`.\nThe `name` attribute identifies the name of the URI variable, while the `expression` attribute is used to set the actual value.\nBy using the `expression` attribute, you can leverage the full power of the Spring Expression Language (SpEL), which gives you full dynamic access to the message payload and the message headers.\nFor example, in the preceding configuration, the `getZip()` method is invoked on the payload object of the `Message` and the result of that method is used as the value of the URI variable named 'zipCode'.\n\nSince Spring Integration 3.0, HTTP outbound endpoints support the `uri-variables-expression` attribute to specify an `expression` that should be evaluated, resulting in a `Map` of all URI variable placeholders within the URL template.\nIt provides a mechanism whereby you can use different variable expressions, based on the outbound message.\nThis attribute is mutually exclusive with the `<uri-variable/>` element.\nThe following example shows how to use the `uri-variables-expression` attribute:\n\n[source,xml]\n----\n<int-http:outbound-gateway\n url=\"https://foo.host/{foo}/bars/{bar}\"\n request-channel=\"trafficChannel\"\n http-method=\"GET\"\n uri-variables-expression=\"@uriVariablesBean.populate(payload)\"\n expected-response-type=\"java.lang.String\"/>\n----\n\n`uriVariablesBean` might be defined as follows:\n\n[source,java]\n----\npublic class UriVariablesBean {\n private static final ExpressionParser EXPRESSION_PARSER = new SpelExpressionParser();\n\n public Map<String, ?> populate(Object payload) {\n Map<String, Object> variables = new HashMap<String, Object>();\n if (payload instanceOf String.class)) {\n variables.put(\"foo\", \"foo\"));\n }\n else {\n variables.put(\"foo\", EXPRESSION_PARSER.parseExpression(\"headers.bar\"));\n }\n return variables;\n }\n\n}\n----\n\nNOTE: The `uri-variables-expression` must evaluate to a `Map`.\nThe values of the `Map` must be instances of `String` or `Expression`.\nThis `Map` is provided to an `ExpressionEvalMap` for further resolution of URI variable placeholders by using those expressions in the context of the outbound `Message`.\n\nIMPORTANT\nThe `uriVariablesExpression` property provides a very powerful mechanism for evaluating URI variables.\nWe anticipate that people mostly use simple expressions, such as the preceding example.\nHowever, you can also configure something such as `\"@uriVariablesBean.populate(#root)\"` with an expression in the returned map being `variables.put(\"thing1\", EXPRESSION_PARSER.parseExpression(message.getHeaders().get(\"thing2\", String.class)));`, where the expression is dynamically provided in the message header named `thing2`.\nSince the header may come from an untrusted source, the HTTP outbound endpoints use `SimpleEvaluationContext` when evaluating these expressions.\nThe `SimpleEvaluationContext` uses only a subset of SpEL features.\nIf you trust your message sources and wish to use the restricted SpEL constructs, set the `trustedSpel` property of the outbound endpoint to `true`.\n\nYou can achieve scenarios that need to supply a dynamic set of URI variables on a per-message basis by using a custom `url-expression` and some utilities for building and encoding URL parameters.\nThe following example shows how to do so:\n\n[source,xml]\n----\nurl-expression=\"T(org.springframework.web.util.UriComponentsBuilder)\n .fromHttpUrl('https://HOST:PORT/PATH')\n .queryParams(payload)\n .build()\n .toUri()\"\n----\n\nThe `queryParams()` method expects a `MultiValueMap<String, String>` as an argument, so you can build a real set of URL query parameters in advance, before performing the request.\n\nThe whole `queryString` can also be presented as a `uri-variable`, as the following example shows:\n\n[source,xml]\n----\n<int-http:outbound-gateway id=\"proxyGateway\" request-channel=\"testChannel\"\n url=\"http://testServer/test?{queryString}\">\n <int-http:uri-variable name=\"queryString\" expression=\"'a=A&amp;b=B'\"/>\n</int-http:outbound-gateway>\n----\n\nIn this case, you must manually provide the URL encoding.\nFor example, you can use the `org.apache.http.client.utils.URLEncodedUtils#format()` for this purpose.\nAs mentioned earlier, a manually built `MultiValueMap<String, String>` can be converted to the `List<NameValuePair>` `format()` method argument by using the following Java Streams snippet:\n\n[source,java]\n----\nList<NameValuePair> nameValuePairs =\n params.entrySet()\n .stream()\n .flatMap(e -> e\n .getValue()\n .stream()\n .map(v -> new BasicNameValuePair(e.getKey(), v)))\n .collect(Collectors.toList());\n----\n\n[[http-uri-encoding]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/namespace.adoc", "title": "namespace", "heading": "Mapping URI Variables", "heading_level": 2, "file_order": 93, "section_index": 7, "content_hash": "7e50b718a11f032d8add4dc527f476c0a36ff7cb108424aa352fd49cc6518c47", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/namespace.adoc"}}
{"id": "sha256:efede3e06836f3d885f63e4b51b251a34b3f03f69470fe3a07113796c1087596", "content": "By default, the URL string is encoded (see https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html[`UriComponentsBuilder`]) to the URI object before sending the request.\nIn some scenarios with a non-standard URI, (such as the RabbitMQ REST API), it is undesirable to perform the encoding.\nThe `<http:outbound-gateway/>` and `<http:outbound-channel-adapter/>` provide an `encoding-mode` attribute.\nTo disable encoding the URL, set this attribute to `NONE` (by default, it is `TEMPLATE_AND_VALUES`).\nIf you wish to partially encode some part of the URL, use an `expression` within a `<uri-variable/>`, as the following example shows:\n\n[source,xml]\n----\n<http:outbound-gateway url=\"https://somehost/%2f/fooApps?bar={param}\" encoding-mode=\"NONE\">\n <http:uri-variable name=\"param\"\n expression=\"T(org.apache.commons.httpclient.util.URIUtil)\n .encodeWithinQuery('Hello World!')\"/>\n</http:outbound-gateway>\n----\n\nWith Java DSL this option can be controlled by the `BaseHttpMessageHandlerSpec.encodingMode()` option.\nThe same configuration applies for similar outbound components in the xref:webflux.adoc[WebFlux module] and xref:ws.adoc[Web Services module].\nFor much sophisticated scenarios it is recommended to configure an `UriTemplateHandler` on the externally provided `RestTemplate`; or in case of WebFlux - `WebClient` with it `UriBuilderFactory`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/namespace.adoc", "title": "namespace", "heading": "Controlling URI Encoding", "heading_level": 2, "file_order": 93, "section_index": 8, "content_hash": "efede3e06836f3d885f63e4b51b251a34b3f03f69470fe3a07113796c1087596", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/namespace.adoc"}}
{"id": "sha256:35f324f3d9fd8a62924b704e1c0421c3475dceaf35857e3e8737445da558af6a", "content": "[[http-outbound]]\n\nThis section describes Spring Integration's HTTP outbound components.\n\n[[using-httprequestexecutingmessagehandler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/outbound.adoc", "title": "outbound", "heading": "outbound", "heading_level": 1, "file_order": 94, "section_index": 0, "content_hash": "35f324f3d9fd8a62924b704e1c0421c3475dceaf35857e3e8737445da558af6a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/outbound.adoc"}}
{"id": "sha256:fbf5ef2e26ab828752822643d0ec1393e4abea6e2e9e51a431d6884fa481ca78", "content": "To configure the `HttpRequestExecutingMessageHandler`, write a bean definition similar to the following:\n\n[source,xml]\n----\n<bean id=\"httpOutbound\"\n class=\"org.springframework.integration.http.outbound.HttpRequestExecutingMessageHandler\">\n <constructor-arg value=\"http://localhost:8080/example\" />\n <property name=\"outputChannel\" ref=\"responseChannel\" />\n</bean>\n----\n\nThis bean definition runs HTTP requests by delegating to a `RestTemplate`.\nThat template, in turn, delegates to a list of `HttpMessageConverter` instances to generate the HTTP request body from the `Message` payload.\nYou can configure those converters as well as the `ClientHttpRequestFactory` instance to use, as the following example shows:\n\n[source,xml]\n----\n<bean id=\"httpOutbound\"\n class=\"org.springframework.integration.http.outbound.HttpRequestExecutingMessageHandler\">\n <constructor-arg value=\"http://localhost:8080/example\" />\n <property name=\"outputChannel\" ref=\"responseChannel\" />\n <property name=\"messageConverters\" ref=\"messageConverterList\" />\n <property name=\"requestFactory\" ref=\"customRequestFactory\" />\n</bean>\n----\n\nBy default, the HTTP request is generated by using an instance of `SimpleClientHttpRequestFactory`, which uses the JDK `HttpURLConnection`.\nUse of the Apache Commons HTTP Client is also supported through `CommonsClientHttpRequestFactory`, which you can inject (as shown earlier).\n\nNOTE: For the outbound gateway, the reply message produced by the gateway contains all the message headers that are present in the request message.\n\n[[using-cookies]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/outbound.adoc", "title": "outbound", "heading": "Using `HttpRequestExecutingMessageHandler`", "heading_level": 2, "file_order": 94, "section_index": 1, "content_hash": "fbf5ef2e26ab828752822643d0ec1393e4abea6e2e9e51a431d6884fa481ca78", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/outbound.adoc"}}
{"id": "sha256:4e3099f0bf08ca0d4a19250cb3acca55a60c6a0945cf50407783eb687afb96b1", "content": "Basic cookie support is provided by the `transfer-cookies` attribute on the outbound gateway.\nWhen set to `true` (the default is `false`), a `Set-Cookie` header received from the server in a response is converted to `Cookie` in the reply message.\nThis header is then used on subsequent sending.\nThis enables simple stateful interactions, such as the following:\n\n`...->logonGateway->...->doWorkGateway->...->logoffGateway->...`\n\nIf `transfer-cookies` is `false`, any `Set-Cookie` header received remains as `Set-Cookie` in the reply message and is dropped on subsequent sends.\n\n[NOTE]\n.Empty Response Bodies\n=====\nHTTP is a request-response protocol.\nHowever, the response may not have a body, only headers.\nIn this case, the `HttpRequestExecutingMessageHandler` produces a reply `Message` with the payload being an `org.springframework.http.ResponseEntity`, regardless of any provided `expected-response-type`.\nAccording to the https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html[HTTP RFC Status Code Definitions], there are many statuses that mandate that a response must not contain a message-body (for example, `204 No Content`).\nThere are also cases where calls to the same URL might or might not return a response body.\nFor example, the first request to an HTTP resource returns content, but the second does not (return a `304 Not Modified`).\nIn all cases, however, the `http_statusCode` message header is populated.\nThis can be used in some routing logic after the HTTP outbound gateway.\nYou could also use a`<payload-type-router/>` to route messages with a `ResponseEntity` to a different flow than that used for responses with a body.\n=====\n[NOTE]\n.expected-response-type\n=====\nFurther to the preceding note about empty response bodies, if a response does contain a body, you must provide an appropriate `expected-response-type` attribute or, again, you receive a `ResponseEntity` with no body.\nThe `expected-response-type` must be compatible with the (configured or default) `HttpMessageConverter` instances and the `Content-Type` header in the response.\nThis can be an abstract class or even an interface (such as `java.io.Serializable` when you use Java serialization and `Content-Type: application/x-java-serialized-object`).\n=====\n\nStarting with version 5.5, the `HttpRequestExecutingMessageHandler` exposes an `extractResponseBody` flag (which is `true` by default) to return just the response body, or to return the whole `ResponseEntity` as the reply message payload, independently of the provided `expectedResponseType`.\nIf a body is not present in the `ResponseEntity`, this flag is ignored and the whole `ResponseEntity` is returned.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/outbound.adoc", "title": "outbound", "heading": "Using Cookies", "heading_level": 2, "file_order": 94, "section_index": 2, "content_hash": "4e3099f0bf08ca0d4a19250cb3acca55a60c6a0945cf50407783eb687afb96b1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/outbound.adoc"}}
{"id": "sha256:122c319aca6450d6d42bde066d37aeae704f08df85a8ed0003d1c277b10de489", "content": "[[http-proxy]]\n\nIf you are behind a proxy and need to configure proxy settings for HTTP outbound adapters or gateways, you can apply one of two approaches.\nIn most cases, you can rely on the standard Java system properties that control the proxy settings.\nOtherwise, you can explicitly configure a Spring bean for the HTTP client request factory instance.\n\n[[standard-java-proxy-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/proxy.adoc", "title": "proxy", "heading": "proxy", "heading_level": 1, "file_order": 95, "section_index": 0, "content_hash": "122c319aca6450d6d42bde066d37aeae704f08df85a8ed0003d1c277b10de489", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/proxy.adoc"}}
{"id": "sha256:c8e6fa1c6d77369803b184a30b308f7a90c574af20de0731fe1048e2fff9369f", "content": "You can set three system properties to configure the proxy settings that are used by the HTTP protocol handler:\n\n* `http.proxyHost`: The host name of the proxy server.\n* `http.proxyPort`: The port number (the default is `80`).\n* `http.nonProxyHosts`: A list of hosts that should be reached directly, bypassing the proxy.\nThis is a list of patterns separated by `|`.\nThe patterns may start or end with a `*` for wildcards.\nAny host that matches one of these patterns is reached through a direct connection instead of through a proxy.\n\nFor HTTPS, the following properties are available:\n\n* `https.proxyHost`: The host name of the proxy server.\n* `https.proxyPort`: The port number, the default value being 80.\n\nFor more information, see https://docs.oracle.com/javase/8/docs/technotes/guides/net/proxies.html\n\n[[spring-s-simpleclienthttprequestfactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/proxy.adoc", "title": "proxy", "heading": "Standard Java Proxy configuration", "heading_level": 2, "file_order": 95, "section_index": 1, "content_hash": "c8e6fa1c6d77369803b184a30b308f7a90c574af20de0731fe1048e2fff9369f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/proxy.adoc"}}
{"id": "sha256:e033532f1fc4ea767ac25bbb2669904bcd76b636d764761c72a3ca98da1fe7ce", "content": "If you need more explicit control over the proxy configuration, you can use Spring's `SimpleClientHttpRequestFactory` and configure its 'proxy' property, as the following example shows:\n\n[source,xml]\n----\n<bean id=\"requestFactory\"\n class=\"org.springframework.http.client.SimpleClientHttpRequestFactory\">\n <property name=\"proxy\">\n <bean id=\"proxy\" class=\"java.net.Proxy\">\n <constructor-arg>\n <util:constant static-field=\"java.net.Proxy.Type.HTTP\"/>\n </constructor-arg>\n <constructor-arg>\n <bean class=\"java.net.InetSocketAddress\">\n <constructor-arg value=\"123.0.0.1\"/>\n <constructor-arg value=\"8080\"/>\n </bean>\n </constructor-arg>\n </bean>\n </property>\n</bean>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/proxy.adoc", "title": "proxy", "heading": "Spring's `SimpleClientHttpRequestFactory`", "heading_level": 2, "file_order": 95, "section_index": 2, "content_hash": "e033532f1fc4ea767ac25bbb2669904bcd76b636d764761c72a3ca98da1fe7ce", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/proxy.adoc"}}
{"id": "sha256:535c9bf2743b5a40f91592103614bb48bf8f64c7c74708f5ee1075aa1eca5557", "content": "[[http-samples]]\n\nThis section wraps up our coverage of Spring Integration's HTTP support with a few examples.\n\n[[multipart-rest-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/samples.adoc", "title": "samples", "heading": "samples", "heading_level": 1, "file_order": 96, "section_index": 0, "content_hash": "535c9bf2743b5a40f91592103614bb48bf8f64c7c74708f5ee1075aa1eca5557", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/samples.adoc"}}
{"id": "sha256:2ef28272f29691629a8bc04fd0379ae648ff24a0821c099103005ea2af0c371b", "content": "This example shows how simple it is to send a multipart HTTP request with Spring's `RestTemplate` and receive it with a Spring Integration HTTP inbound adapter.\nWe create a `MultiValueMap` and populate it with multipart data.\nThe `RestTemplate` takes care of the rest (no pun intended) by converting it to a `MultipartHttpServletRequest`.\nThis particular client sends a multipart HTTP Request that contains the name of the company and an image file (the company logo).\nThe following listing shows the example:\n\n[source,java]\n----\nRestTemplate template = new RestTemplate();\nString uri = \"http://localhost:8080/multipart-http/inboundAdapter.htm\";\nResource s2logo =\n new ClassPathResource(\"org/springframework/samples/multipart/spring09_logo.png\");\nMultiValueMap map = new LinkedMultiValueMap();\nmap.add(\"company\", \"SpringSource\");\nmap.add(\"company-logo\", s2logo);\nHttpHeaders headers = new HttpHeaders();\nheaders.setContentType(new MediaType(\"multipart\", \"form-data\"));\nHttpEntity request = new HttpEntity(map, headers);\nResponseEntity<?> httpResponse = template.exchange(uri, HttpMethod.POST, request, null);\n----\n\nThat is all we need for the client.\n\nOn the server side, we have the following configuration:\n\n[source,xml]\n----\n<int-http:inbound-channel-adapter id=\"httpInboundAdapter\"\n channel=\"receiveChannel\"\n path=\"/inboundAdapter.htm\"\n supported-methods=\"GET, POST\"/>\n\n<int:channel id=\"receiveChannel\"/>\n\n<int:service-activator input-channel=\"receiveChannel\">\n <bean class=\"org.springframework.integration.samples.multipart.MultipartReceiver\"/>\n</int:service-activator>\n\n<bean id=\"multipartResolver\"\n class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"/>\n----\n\nThe 'httpInboundAdapter' receives the request and converts it to a `Message` with a payload that is a `LinkedMultiValueMap`.\nWe then parse that in the 'multipartReceiver' service-activator, as the following example shows:\n\n[source,java]\n----\npublic void receive(LinkedMultiValueMap<String, Object> multipartRequest){\n System.out.println(\"### Successfully received multipart request ###\");\n for (String elementName : multipartRequest.keySet()) {\n if (elementName.equals(\"company\")){\n System.out.println(\"\\t\" + elementName + \" - \" +\n ((String[]) multipartRequest.getFirst(\"company\"))[0]);\n }\n else if (elementName.equals(\"company-logo\")){\n System.out.println(\"\\t\" + elementName + \" - as UploadedMultipartFile: \" +\n ((UploadedMultipartFile) multipartRequest\n .getFirst(\"company-logo\")).getOriginalFilename());\n }\n }\n}\n----\n\nYou should see the following output:\n\n[source,xml]\n----\n### Successfully received multipart request ###\n company - SpringSource\n company-logo - as UploadedMultipartFile: spring09_logo.png\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/samples.adoc", "title": "samples", "heading": "Multipart HTTP Request -- RestTemplate (Client) and Http Inbound Gateway (Server)", "heading_level": 2, "file_order": 96, "section_index": 1, "content_hash": "2ef28272f29691629a8bc04fd0379ae648ff24a0821c099103005ea2af0c371b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/samples.adoc"}}
{"id": "sha256:02a56dbfcd10765e2c93e7dc5c34ca174e066130e3b47d206fb1b12d0d0e13ab", "content": "[[http-timeout]]\n\nIn the context of HTTP components, there are two timing areas that have to be considered:\n\n* Timeouts when interacting with Spring Integration Channels\n* Timeouts when interacting with a remote HTTP server\n\nThe components interact with message channels, for which timeouts can be specified.\nFor example, an HTTP Inbound Gateway forwards messages received from connected HTTP Clients to a message channel (which uses a request timeout) and consequently the HTTP Inbound Gateway receives a reply message from the reply channel (which uses a reply timeout) that is used to generate the HTTP Response.\nThe following illustration offers a visual explanation:\n\n.How timeout settings apply to an HTTP Inbound Gateway\nimage::http-inbound-gateway.png[align=\"center\"]\n\nFor outbound endpoints, we need to consider how timing works while interacting with the remote server.\nThe following image shows this scenario:\n\n.How timeout settings apply to an HTTP Outbound Gateway\nimage::http-outbound-gateway.png[align=\"center\"]\n\nYou may want to configure the HTTP-related timeout behavior when making active HTTP requests by using the HTTP outbound gateway or the HTTP outbound channel adapter.\nIn those instances, these two components use Spring's https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html[`RestTemplate`] support to execute HTTP requests.\n\nTo configure timeouts for the HTTP outbound gateway and the HTTP outbound channel adapter, you can either reference a `RestTemplate` bean directly (by using the `rest-template` attribute) or you can provide a reference to a https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/client/ClientHttpRequestFactory.html[`ClientHttpRequestFactory`] bean (by using the `request-factory` attribute).\nSpring provides the following implementations of the `ClientHttpRequestFactory` interface:\n\n* https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/client/SimpleClientHttpRequestFactory.html[`SimpleClientHttpRequestFactory`]: Uses standard J2SE facilities for making HTTP Requests\n* https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/client/HttpComponentsClientHttpRequestFactory.html[`HttpComponentsClientHttpRequestFactory`]: Uses https://hc.apache.org/httpcomponents-client-ga/[Apache HttpComponents HttpClient] (since Spring 3.1)\n\nIf you do not explicitly configure the `request-factory` or `rest-template` attribute, a default `RestTemplate` (which uses a `SimpleClientHttpRequestFactory`) is instantiated.\n\n[NOTE]\n=====\nWith some JVM implementations, the handling of timeouts by the `URLConnection` class may not be consistent.\n\nFor example, from the Java Platform, Standard Edition 6 API Specification on `setConnectTimeout`:\n\n[quote]\nSome non-standard implementation of this method may ignore the specified timeout.\nTo see the `connect timeout` set, please call getConnectTimeout().\n\nIf you have specific needs, you should test your timeouts.\nConsider using the `HttpComponentsClientHttpRequestFactory`, which, in turn, uses https://hc.apache.org/httpcomponents-client-ga/[Apache HttpComponents HttpClient] rather than relying on implementations provided by a JVM.\n=====\n\nIMPORTANT: When you use the Apache HttpComponents HttpClient with a pooling connection manager, you should be aware that, by default, the connection manager creates no more than two concurrent connections per given route and no more than 20 connections in total.\nFor many real-world applications, these limits may prove to be too constraining.\nSee the https://hc.apache.org/httpcomponents-client-ga/[Apache documentation] for information about configuring this important component.\n\nThe following example configures an HTTP outbound gateway by using a `SimpleClientHttpRequestFactory` that is configured with connect and read timeouts of 5 seconds, respectively:\n\n[source,xml]\n----\n<int-http:outbound-gateway url=\"https://samples.openweathermap.org/data/2.5/weather?q={city}\"\n http-method=\"GET\"\n expected-response-type=\"java.lang.String\"\n request-factory=\"requestFactory\"\n request-channel=\"requestChannel\"\n reply-channel=\"replyChannel\">\n <int-http:uri-variable name=\"city\" expression=\"payload\"/>\n</int-http:outbound-gateway>\n\n<bean id=\"requestFactory\"\n class=\"org.springframework.http.client.SimpleClientHttpRequestFactory\">\n <property name=\"connectTimeout\" value=\"5000\"/>\n <property name=\"readTimeout\" value=\"5000\"/>\n</bean>\n----\n\n_HTTP Outbound Gateway_\n\nFor the _HTTP Outbound Gateway_, the XML Schema defines only the _reply-timeout_.\nThe _reply-timeout_ maps to the _sendTimeout_ property of the _org.springframework.integration.http.outbound.HttpRequestExecutingMessageHandler_ class.\nMore precisely, the property is set on the extended `AbstractReplyProducingMessageHandler` class, which ultimately sets the property on the `MessagingTemplate`.\n\nThe value of the _sendTimeout_ property defaults to `30` seconds and will be applied to the connected `MessageChannel`.\nThis means, that depending on the implementation, the Message Channel's _send_ method may block indefinitely.\nFurthermore, the _sendTimeout_ property is only used when the actual MessageChannel implementation has a blocking sending (such as 'full' bounded QueueChannel).\n\n[[http-inbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/timeout.adoc", "title": "timeout", "heading": "timeout", "heading_level": 1, "file_order": 97, "section_index": 0, "content_hash": "02a56dbfcd10765e2c93e7dc5c34ca174e066130e3b47d206fb1b12d0d0e13ab", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/timeout.adoc"}}
{"id": "sha256:ccc589fdc537b35830a264806596b964ec1c3243a85698de1b77459c28e0467e", "content": "For the HTTP inbound gateway, the XML Schema defines the `request-timeout` attribute, which is used to set the `requestTimeout` property on the `HttpRequestHandlingMessagingGateway` class (on the extended `MessagingGatewaySupport` class).\nYou can also use the `reply-timeout` attribute to map to the `replyTimeout` property on the same class.\n\nThe default for both timeout properties is `1000ms` (one thousand milliseconds or one second).\nUltimately, the `request-timeout` property is used to set the `sendTimeout` on the `MessagingTemplate` instance.\nThe `replyTimeout` property, on the other hand, is used to set the `receiveTimeout` property on the `MessagingTemplate` instance.\n\nTIP: To simulate connection timeouts, you can connect to a non-routable IP address, such as 10.255.255.10.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http/timeout.adoc", "title": "timeout", "heading": "HTTP Inbound Gateway", "heading_level": 2, "file_order": 97, "section_index": 1, "content_hash": "ccc589fdc537b35830a264806596b964ec1c3243a85698de1b77459c28e0467e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http/timeout.adoc"}}
{"id": "sha256:f21aa301ff3c0cb964ca34429bee480c45f5061118040b014f614ee6250fb354", "content": "[[ip-annotation]]\n\nThe following example from the samples repository shows some of the configuration options available when you use annotations instead of XML:\n\n[source, java]\n----\n@EnableIntegration <1>\n@IntegrationComponentScan <2>\n@Configuration\npublic static class Config {\n\n @Value(${some.port})\n private int port;\n\n @MessagingGateway(defaultRequestChannel=\"toTcp\") <3>\n public interface Gateway {\n\n String viaTcp(String in);\n\n }\n\n @Bean\n @ServiceActivator(inputChannel=\"toTcp\") <4>\n public MessageHandler tcpOutGate(AbstractClientConnectionFactory connectionFactory) {\n TcpOutboundGateway gate = new TcpOutboundGateway();\n gate.setConnectionFactory(connectionFactory);\n gate.setOutputChannelName(\"resultToString\");\n return gate;\n }\n\n @Bean <5>\n public TcpInboundGateway tcpInGate(AbstractServerConnectionFactory connectionFactory) {\n TcpInboundGateway inGate = new TcpInboundGateway();\n inGate.setConnectionFactory(connectionFactory);\n inGate.setRequestChannel(fromTcp());\n return inGate;\n }\n\n @Bean\n public MessageChannel fromTcp() {\n return new DirectChannel();\n }\n\n @MessageEndpoint\n public static class Echo { <6>\n\n @Transformer(inputChannel=\"fromTcp\", outputChannel=\"toEcho\")\n public String convert(byte[] bytes) {\n return new String(bytes);\n }\n\n @ServiceActivator(inputChannel=\"toEcho\")\n public String upCase(String in) {\n return in.toUpperCase();\n }\n\n @Transformer(inputChannel=\"resultToString\")\n public String convertResult(byte[] bytes) {\n return new String(bytes);\n }\n\n }\n\n @Bean\n public AbstractClientConnectionFactory clientCF() { <7>\n return new TcpNetClientConnectionFactory(\"localhost\", this.port);\n }\n\n @Bean\n public AbstractServerConnectionFactory serverCF() { <8>\n return new TcpNetServerConnectionFactory(this.port);\n }\n\n}\n----\n\n<1> Standard Spring Integration annotation enabling the infrastructure for an integration application.\n\n<2> Searches for `@MessagingGateway` interfaces.\n\n<3> The entry points to the client-side of the flow.\nThe calling application can use `@Autowired` for this `Gateway` bean and invoke its method.\n\n<4> Outbound endpoints consist of a `MessageHandler` and a consumer that wraps it.\nIn this scenario, the `@ServiceActivator` configures the endpoint, according to the channel type.\n\n<5> Inbound endpoints (in the TCP/UDP module) are all message-driven and so only need to be declared as simple `@Bean` instances.\n\n<6> This class provides a number of POJO methods for use in this sample flow (a `@Transformer` and `@ServiceActivator` on the server side and a `@Transformer` on the client side).\n\n<7> The client-side connection factory.\n\n<8> The server-side connection factory.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/annotation.adoc", "title": "annotation", "heading": "annotation", "heading_level": 1, "file_order": 98, "section_index": 0, "content_hash": "f21aa301ff3c0cb964ca34429bee480c45f5061118040b014f614ee6250fb354", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/annotation.adoc"}}
{"id": "sha256:31224fabac908d48e7d9678a340302902f1325fd9426efd20e26e08e74297084", "content": "[[ip-correlation]]\n\nOne goal of the IP endpoints is to provide communication with systems other than Spring Integration applications.\nFor this reason, only message payloads are sent and received by default.\nSince 3.0, you can transfer headers by using JSON, Java serialization, or custom serializers and deserializers.\nSee xref:ip/correlation.adoc#ip-headers[Transferring Headers] for more information.\nNo message correlation is provided by the framework (except when using the gateways) or collaborating channel adapters on the server side.\nxref:ip/correlation.adoc#ip-collaborating-adapters[Later in this document], we discuss the various correlation techniques available to applications.\nIn most cases, this requires specific application-level correlation of messages, even when message payloads contain some natural correlation data (such as an order number).\n\n[[ip-gateways]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/correlation.adoc", "title": "correlation", "heading": "correlation", "heading_level": 1, "file_order": 99, "section_index": 0, "content_hash": "31224fabac908d48e7d9678a340302902f1325fd9426efd20e26e08e74297084", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/correlation.adoc"}}
{"id": "sha256:bb6ddaace56ac4c83e5fc169f6f3a29e3483c927f732bba3964969c8eb435976", "content": "Gateways automatically correlate messages.\nHowever, you should use an outbound gateway for relatively low-volume applications.\nWhen you configure the connection factory to use a single shared connection for all message pairs ('single-use=\"false\"'), only one message can be processed at a time.\nA new message has to wait until the reply to the previous message has been received.\nWhen a connection factory is configured for each new message to use a new connection ('single-use=\"true\"'), this restriction does not apply.\nWhile this setting can give higher throughput than a shared connection environment, it comes with the overhead of opening and closing a new connection for each message pair.\n\nTherefore, for high-volume messages, consider using a collaborating pair of channel adapters.\nHowever, to do so, you need to provide collaboration logic.\n\nAnother solution, introduced in Spring Integration 2.2, is to use a `CachingClientConnectionFactory`, which allows the use of a pool of shared connections.\n\n[[ip-collaborating-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/correlation.adoc", "title": "correlation", "heading": "Gateways", "heading_level": 2, "file_order": 99, "section_index": 1, "content_hash": "bb6ddaace56ac4c83e5fc169f6f3a29e3483c927f732bba3964969c8eb435976", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/correlation.adoc"}}
{"id": "sha256:f322885d813232159d822c068540d992499a5a682fe39463e3a4ce316448c4d5", "content": "To achieve high-volume throughput (avoiding the pitfalls of using gateways, as xref:ip/correlation.adoc#ip-gateways[mentioned earlier]) you can configure a pair of collaborating outbound and inbound channel adapters.\nYou can also use collaborating adapters (server-side or client-side) for totally asynchronous communication (rather than with request-reply semantics).\nOn the server side, message correlation is automatically handled by the adapters, because the inbound adapter adds a header that allows the outbound adapter to determine which connection to use when sending the reply message.\n\nNOTE: On the server side, you must populate the `ip_connectionId` header, because it is used to correlate the message to a connection.\nMessages that originate at the inbound adapter automatically have the header set.\nIf you wish to construct other messages to send, you need to set the header.\nYou can get the header value from an incoming message.\n\nOn the client side, the application must provide its own correlation logic, if needed.\nYou can do so in a number of ways.\n\nIf the message payload has some natural correlation data (such as a transaction ID or an order number) and you have no need to retain any information (such as a reply channel header) from the original outbound message, the correlation is simple and would be done at the application level in any case.\n\nIf the message payload has some natural correlation data (such as a transaction ID or an order number), but you need to retain some information (such as a reply channel header) from the original outbound message, you can retain a copy of the original outbound message (perhaps by using a publish-subscribe channel) and use an aggregator to recombine the necessary data.\n\nFor either of the previous two scenarios, if the payload has no natural correlation data, you can provide a transformer upstream of the outbound channel adapter to enhance the payload with such data.\nSuch a transformer may transform the original payload to a new object that contains both the original payload and some subset of the message headers.\nOf course, live objects (such as reply channels) from the headers cannot be included in the transformed payload.\n\nIf you choose such a strategy, you need to ensure the connection factory has an appropriate serializer-deserializer pair to handle such a payload (such as `DefaultSerializer` and `DefaultDeserializer`, which use java serialization, or a custom serializer and deserializer).\nThe `ByteArray*Serializer` options mentioned in xref:ip/tcp-connection-factories.adoc[TCP Connection Factories], including the default `ByteArrayCrLfSerializer`, do not support such payloads unless the transformed payload is a `String` or `byte[]`.\n\n[NOTE]\n=====\nBefore the 2.2 release, when collaborating channel adapters used a client connection factory, the `so-timeout` attribute defaulted to the default reply timeout (10 seconds).\nThis meant that, if no data were received by the inbound adapter for this period of time, the socket was closed.\n\nThis default behavior was not appropriate in a truly asynchronous environment, so it now defaults to an infinite timeout.\nYou can reinstate the previous default behavior by setting the `so-timeout` attribute on the client connection factory to 10000 milliseconds.\n=====\n\nStarting with version 5.4, multiple outbound channel adapters and one `TcpInboundChannelAdapter` can share the same connection factory.\nThis allows an application to support both request/reply and arbitrary server -> client messaging.\nSee xref:ip/tcp-gateways.adoc[TCP Gateways] for more information.\n\n[[ip-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/correlation.adoc", "title": "correlation", "heading": "Collaborating Outbound and Inbound Channel Adapters", "heading_level": 2, "file_order": 99, "section_index": 2, "content_hash": "f322885d813232159d822c068540d992499a5a682fe39463e3a4ce316448c4d5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/correlation.adoc"}}
{"id": "sha256:cc6abf37a732b9deecccb6f20100fa3f4049d2f3fa4ffb46292f483455c9a662", "content": "TCP is a streaming protocol.\n`Serializers` and `Deserializers` demarcate messages within the stream.\nPrior to 3.0, only message payloads (`String` or `byte[]`) could be transferred over TCP.\nBeginning with 3.0, you can transfer selected headers as well as the payload.\nHowever, \"`live`\" objects, such as the `replyChannel` header, cannot be serialized.\n\nSending header information over TCP requires some additional configuration.\n\nThe first step is to provide the `ConnectionFactory` with a `MessageConvertingTcpMessageMapper` that uses the `mapper` attribute.\nThis mapper delegates to any `MessageConverter` implementation to convert the message to and from some object that can be serialized and deserialized by the configured `serializer` and `deserializer`.\n\nSpring Integration provides a `MapMessageConverter`, which allows the specification of a list of headers that are added to a `Map` object, along with the payload.\nThe generated Map has two entries: `payload` and `headers`.\nThe `headers` entry is itself a `Map` and contains the selected headers.\n\nThe second step is to provide a serializer and a deserializer that can convert between a `Map` and some wire format.\nThis can be a custom `Serializer` or `Deserializer`, which you typically need if the peer system is not a Spring Integration application.\n\nSpring Integration provides a `MapJsonSerializer` to convert a `Map` to and from JSON.\nIt uses a Spring Integration `JsonObjectMapper`.\nYou can provide a custom `JsonObjectMapper` if needed.\nBy default, the serializer inserts a linefeed (`0x0a`) character between objects.\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/ip/tcp/serializer/MapJsonSerializer.html[Javadoc] for more information.\n\nNOTE: The `JsonObjectMapper` uses whichever version of `Jackson` is on the classpath.\n\nYou can also use standard Java serialization of the `Map`, by using the `DefaultSerializer` and `DefaultDeserializer`.\n\nThe following example shows the configuration of a connection factory that transfers the `correlationId`, `sequenceNumber`, and `sequenceSize` headers by using JSON:\n\n[source,xml]\n----\n<int-ip:tcp-connection-factory id=\"client\"\n type=\"client\"\n host=\"localhost\"\n port=\"12345\"\n mapper=\"mapper\"\n serializer=\"jsonSerializer\"\n deserializer=\"jsonSerializer\"/>\n\n<bean id=\"mapper\"\n class=\"o.sf.integration.ip.tcp.connection.MessageConvertingTcpMessageMapper\">\n <constructor-arg name=\"messageConverter\">\n <bean class=\"o.sf.integration.support.converter.MapMessageConverter\">\n <property name=\"headerNames\">\n <list>\n <value>correlationId</value>\n <value>sequenceNumber</value>\n <value>sequenceSize</value>\n </list>\n </property>\n </bean>\n </constructor-arg>\n</bean>\n\n<bean id=\"jsonSerializer\" class=\"o.sf.integration.ip.tcp.serializer.MapJsonSerializer\" />\n----\n\nA message sent with the preceding configuration, with a payload of 'something' would appear on the wire as follows:\n\n[source,xml]\n----\n\n{\"headers\":{\"correlationId\":\"things\",\"sequenceSize\":5,\"sequenceNumber\":1},\"payload\":\"something\"}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/correlation.adoc", "title": "correlation", "heading": "Transferring Headers", "heading_level": 2, "file_order": 99, "section_index": 3, "content_hash": "cc6abf37a732b9deecccb6f20100fa3f4049d2f3fa4ffb46292f483455c9a662", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/correlation.adoc"}}
{"id": "sha256:7dd3b3b8893f357e6ef2c15b83314be3e94a5691f3e9f7b9ac6c41e974398e4f", "content": "[[ip-dsl]]\n\nDSL support for TCP components includes specs for adapters and gateways, the `Tcp` class with factory methods to create connection factory beans, and the `TcpCodecs` class with factory methods to create serializers and deserializers.\nRefer to their Javadocs for more information.\n\nHere are some examples of using the DSL to configure flows using the DSL.\n\n.Server Adapter Flow\n[source, java]\n----\n@Bean\npublic IntegrationFlow server() {\n return IntegrationFlow.from(Tcp.inboundAdapter(Tcp.netServer(1234)\n .deserializer(TcpCodecs.lengthHeader1())\n .backlog(30))\n .errorChannel(\"tcpIn.errorChannel\")\n .id(\"tcpIn\"))\n .transform(Transformers.objectToString())\n .channel(\"tcpInbound\")\n .get();\n}\n----\n\n.Client Adapter Flow\n[source, java]\n----\n@Bean\npublic IntegrationFlow client() {\n return f -> f.handle(Tcp.outboundAdapter(Tcp.nioClient(\"localhost\", 1234)\n .serializer(TcpCodecs.lengthHeader1())));\n}\n----\n\n.Server Gateway Flow\n[source, java]\n----\n@Bean\npublic IntegrationFlow server() {\n return IntegrationFlow.from(Tcp.inboundGateway(Tcp.netServer(1234)\n .deserializer(TcpCodecs.lengthHeader1())\n .serializer(TcpCodecs.lengthHeader1())\n .backlog(30))\n .errorChannel(\"tcpIn.errorChannel\")\n .id(\"tcpIn\"))\n .transform(Transformers.objectToString())\n .channel(\"tcpInbound\")\n .get();\n}\n----\n\n.Client Gateway Flow\n[source, java]\n----\n@Bean\npublic IntegrationFlow client() {\n return f -> f.handle(Tcp.outboundGateway(Tcp.nioClient(\"localhost\", 1234)\n .deserializer(TcpCodecs.lengthHeader1())\n .serializer(TcpCodecs.lengthHeader1())));\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/dsl.adoc", "title": "dsl", "heading": "dsl", "heading_level": 1, "file_order": 100, "section_index": 0, "content_hash": "7dd3b3b8893f357e6ef2c15b83314be3e94a5691f3e9f7b9ac6c41e974398e4f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/dsl.adoc"}}
{"id": "sha256:1534aa0aba50413cc558c58e5f3292d7d7cde85b63edd3ba906a541df87afdcb", "content": "[[ip-endpoint-reference]]\n\nThe following table describes attributes that you can set to configure IP connections:\n\n.Connection Factory Attributes\n[cols=\"2,^1,^1,1,4\", options=\"header\"]\n|===\n\n| Attribute Name\n| Client?\n| Server?\n| Allowed Values\n| Attribute Description\n\n| `type`\n| Y\n| Y\n| client, server\n| Determines whether the connection factory is a client or a server.\n\n| `host`\n| Y\n| N\n|\n| The host name or IP address of the destination.\n\n| `port`\n| Y\n| Y\n|\n| The port.\n\n| `serializer`\n| Y\n| Y\n|\n| An implementation of `Serializer` used to serialize the payload.\nDefaults to `ByteArrayCrLfSerializer`\n\n| `deserializer`\n| Y\n| Y\n|\n| An implementation of `Deserializer` used to deserialize the payload.\nDefaults to `ByteArrayCrLfSerializer`\n\n| `using-nio`\n| Y\n| Y\n| `true`, `false`\n| Whether the connection uses NIO.\nRefer to the `java.nio` package for more information.\nSee xref:ip/note-nio.adoc[About Non-blocking I/O (NIO)].\nDefault: `false`.\n\n| `using-direct-buffers`\n| Y\n| N\n| `true`, `false`\n| When using NIO, whether the connection uses direct buffers.\nRefer to the `java.nio.ByteBuffer` documentation for more information.\nMust be `false` if `using-nio` is `false`.\n\n| `apply-sequence`\n| Y\n| Y\n| `true`, `false`\n| When you use NIO, it may be necessary to resequence messages.\nWhen this attribute is set to `true`, `correlationId` and `sequenceNumber` headers are added to received messages.\nSee xref:ip/note-nio.adoc[About Non-blocking I/O (NIO)].\nDefault: `false`.\n\n| `so-timeout`\n| Y\n| Y\n|\n| Defaults to `0` (infinity), except for server connection factories with `single-use=\"true\"`.\nIn that case, it defaults to the default reply timeout (10 seconds).\n\n| `so-send-buffer-size`\n| Y\n| Y\n|\n| See `java.net.Socket.`\n`setSendBufferSize()`.\n\n| `so-receive-buffer-size`\n| Y\n| Y\n|\n| See `java.net.Socket.`\n`setReceiveBufferSize()`.\n\n| `so-keep-alive`\n| Y\n| Y\n| `true`, `false`\n| See `java.net.Socket.setKeepAlive()`.\n\n| `so-linger`\n| Y\n| Y\n|\n| Sets `linger` to `true` with the supplied value.\nSee `java.net.Socket.setSoLinger()`.\n\n| `so-tcp-no-delay`\n| Y\n| Y\n| `true`, `false`\n| See `java.net.Socket.setTcpNoDelay()`.\n\n| `so-traffic-class`\n| Y\n| Y\n|\n| See `java.net.Socket.`\n`setTrafficClass()`.\n\n| `local-address`\n| N\n| Y\n|\n| On a multi-homed system, specifies an IP address for the interface to which the socket is bound.\n\n| `task-executor`\n| Y\n| Y\n|\n| Specifies a specific executor to be used for socket handling.\nIf not supplied, an internal cached thread executor is used.\nNeeded on some platforms that require the use of specific task executors, such as a `WorkManagerTaskExecutor`.\n\n| `single-use`\n| Y\n| Y\n| `true`, `false`\n| Specifies whether a connection can be used for multiple messages.\nIf `true`, a new connection is used for each message.\n\n| `pool-size`\n| N\n| N\n|\n| This attribute is no longer used.\nFor backward compatibility, it sets the backlog, but you should use `backlog` to specify the connection backlog in server factories.\n\n| `backlog`\n| N\n| Y\n|\n| Sets the connection backlog for server factories.\n\n| `lookup-host`\n| Y\n| Y\n| `true`, `false`\n| Specifies whether reverse lookups are done on IP addresses to convert to host names for use in message headers.\nIf false, the IP address is used instead.\nDefault: `false`.\n\n| `interceptor-factory-chain`\n| Y\n| Y\n|\n| See xref:ip/interceptors.adoc[TCP Connection Interceptors].\n\n| `ssl-context-support`\n| Y\n| Y\n|\n| See `xref:ip/ssl-tls.adoc[SSL/TLS Support]`.\n\n| `socket-factory-support`\n| Y\n| Y\n|\n| See `xref:ip/ssl-tls.adoc[SSL/TLS Support]`.\n\n| `socket-support`\n| Y\n| Y\n|\n| See xref:ip/ssl-tls.adoc[SSL/TLS Support].\n\n| `nio-connection-support`\n| Y\n| Y\n|\n| See xref:ip/tcp-advanced-techniques.adoc[Advanced Techniques].\n\n| `read-delay`\n| Y\n| Y\n| long > 0\n| The delay (in milliseconds) before retrying a read after the previous attempt failed due to insufficient threads.\nDefault: 100.\nOnly applies if `using-nio` is `true`.\n|===\n\nThe following table describes attributes that you can set to configure UDP inbound channel adapters:\n\n[[ip-udp-ib-atts]]\n.UDP Inbound Channel Adapter Attributes\n[cols=\"1,^1,4\", options=\"header\"]\n|===\n| Attribute Name\n| Allowed Values\n| Attribute Description\n\n| `port`\n|\n| The port on which the adapter listens.\n\n| `multicast`\n| `true`, `false`\n| Whether or not the UDP adapter uses multicast.\n\n| `multicast-address`\n|\n| When multicast is true, the multicast address to which the adapter joins.\n\n| `pool-size`\n|\n| Specifies how many packets can be handled concurrently.\nIt only applies if the `task-executor` is not configured.\nDefault: 5.\n\n| task-executor\n|\n| Specifies a specific executor to be used for socket handling.\nIf not supplied, an internal pooled executor is used.\nNeeded on some platforms that require the use of specific task executors such as a `WorkManagerTaskExecutor`.\nSee pool-size for thread requirements.\n\n| `receive-buffer-size`\n|\n| The size of the buffer used to receive `DatagramPackets`.\nUsually set to the maximum transmission unit (MTU) size.\nIf a smaller buffer is used than the size of the sent packet, truncation can occur.\nYou can detect this by using the `check-length` attribute..\n\n| `check-length`\n| `true`, `false`\n| Whether a UDP adapter expects a data length field in the packet received.\nUsed to detect packet truncation.\n\n| `so-timeout`\n|\n| See the `setSoTimeout()` methods in `java.net.DatagramSocket` for more information.\n\n| `so-send-buffer-size`\n|\n| Used for UDP acknowledgment packets.\nSee the setSendBufferSize() methods in `java.net.DatagramSocket` for more information.\n\n| `so-receive-buffer-size`\n|\n| See `java.net.DatagramSocket.setReceiveBufferSize()` for more information.\n\n| `local-address`\n|\n| On a multi-homed system, specifies an IP address for the interface to which the socket is bound.\n\n| `error-channel`\n|\n| If a downstream component throws an exception, the `MessagingException` message that contains the exception and failed message is sent to this channel.\n\n| `lookup-host`\n| `true`, `false`\n| Specifies whether reverse lookups are done on IP addresses to convert to host names for use in message headers.\nIf `false`, the IP address is used instead.\nDefault: `false`.\n\n|===\n\nThe following table describes attributes that you can set to configure UDP outbound channel adapters:\n\n.UDP Outbound Channel Adapter Attributes\n[cols=\"2,^1,4\", options=\"header\"]\n|===\n| Attribute Name\n| Allowed Values\n| Attribute Description\n\n| `host`\n|\n| The host name or ip address of the destination.\nFor multicast udp adapters, the multicast address.\n\n| `port`\n|\n| The port on the destination.\n\n| `multicast`\n| `true`, `false`\n| Whether or not the udp adapter uses multicast.\n\n| `acknowledge`\n| `true`, `false`\n| Whether a UDP adapter requires an acknowledgment from the destination.\nWhen enabled, it requires setting the following four attributes: `ack-host`, `ack-port`, `ack-timeout`, and `min-acks-for- success`.\n\n| `ack-host`\n|\n| When `acknowledge` is `true`, indicates the host or IP address to which the acknowledgment should be sent.\nUsually the current host, but may be different -- for example, when Network Address Translation (NAT) is being used.\n\n| `ack-port`\n|\n| When `acknowledge` is `true`, indicates the port to which the acknowledgment should be sent.\nThe adapter listens on this port for acknowledgments.\n\n| `ack-timeout`\n|\n| When `acknowledge` is `true`, indicates the time in milliseconds that the adapter waits for an acknowledgment.\nIf an acknowledgment is not received in time, the adapter throws an exception.\n\n| `min-acks-for- success`\n|\n| Defaults to 1.\nFor multicast adapters, you can set this to a larger value, which requires acknowledgments from multiple destinations.\n\n| `check-length`\n| `true`, `false`\n| Whether or not a UDP adapter includes a data length field in the packet sent to the destination.\n\n| `time-to-live`\n|\n| For multicast adapters, specifies the time-to-live attribute for the `MulticastSocket`.\nControls the scope of the multicasts.\nRefer to the Java API documentation for more information.\n\n| `so-timeout`\n|\n| See `java.net.DatagramSocket` setSoTimeout() methods for more information.\n\n| `so-send-buffer-size`\n|\n| See the `setSendBufferSize()` methods in `java.net.DatagramSocket` for more information.\n\n| `so-receive-buffer-size`\n|\n| Used for UDP acknowledgment packets.\nSee the `setReceiveBufferSize()` methods in `java.net.DatagramSocket` for more information.\n| local-address\n|\n| On a multi-homed system, for the UDP adapter, specifies an IP address for the interface to which the socket is bound for reply messages.\nFor a multicast adapter, it also determines which interface the multicast packets are sent over.\n\n| `task-executor`\n|\n| Specifies a specific executor to be used for acknowledgment handling.\nIf not supplied, an internal single-threaded executor is used.\nNeeded on some platforms that require the use of specific task executors, such as a `WorkManagerTaskExecutor`.\nOne thread is dedicated to handling acknowledgments (if the `acknowledge` option is true).\n\n| `destination-expression`\n| SpEL expression\n| A SpEL expression to be evaluated to determine which `SocketAddress` to use as a destination address for the outgoing UDP packets.\n\n| `socket-expression`\n| SpEL expression\n| A SpEL expression to be evaluated to determine which datagram socket use for sending outgoing UDP packets.\n|===\n\nThe following table describes attributes that you can set to configure TCP inbound channel adapters:\n\n.TCP Inbound Channel Adapter Attributes\n[cols=\"2,^1,4\", options=\"header\"]\n|===\n| Attribute Name\n| Allowed Values\n| Attribute Description\n\n| `channel`\n|\n| The channel to which inbound messages are sent.\n\n| `connection-factory`\n|\n| If the connection factory has a type of `server`, the factory is \"`owned`\" by this adapter.\nIf it has a type of `client`, it is \"`owned`\" by an outbound channel adapter, and this adapter receives any incoming messages on the connection created by the outbound adapter.\n\n| `error-channel`\n|\n| If an exception is thrown by a downstream component, the `MessagingException` message containing the exception and the failed message is sent to this channel.\n\n| `client-mode`\n| `true`, `false`\n| When `true`, the inbound adapter acts as a client with respect to establishing the connection and then receiving incoming messages on that connection.\nDefault: `false`.\nSee also `retry-interval` and `scheduler`.\nThe connection factory must be of type `client` and have `single-use` set to `false`.\n\n| `retry-interval`\n|\n| When in `client-mode`, specifies the number of milliseconds to wait between connection attempts or after a connection failure.\nDefault: 60000 (60 seconds).\n\n| `scheduler`\n| `true`, `false`\n| Specifies a `TaskScheduler` to use for managing the `client-mode` connection.\nIf not specified, it defaults to the global Spring Integration `taskScheduler` bean, which has a default pool size of 10.\nSee xref:configuration/namespace-taskscheduler.adoc[Configuring the Task Scheduler].\n|===\n\nThe following table describes attributes that you can set to configure TCP outbound channel adapters:\n\n.TCP Outbound Channel Adapter Attributes\n[cols=\"2,^1,4\", options=\"header\"]\n|===\n| Attribute Name\n| Allowed Values\n| Attribute Description\n\n| `channel`\n|\n| The channel on which outbound messages arrive.\n\n| `connection-factory`\n|\n| If the connection factory has a type of `client`, the factory is \"`owned`\" by this adapter.\nIf it has a type of `server`, it is \"`owned`\" by an inbound channel adapter, and this adapter tries to correlate messages to the connection on which an original inbound message was received.\n\n| `client-mode`\n| `true`, `false`\n| When `true`, the outbound adapter tries to establish the connection as soon as it is started.\nWhen `false`, the connection is established when the first message is sent.\nDefault: `false`.\nSee also `retry-interval` and `scheduler`.\nThe connection factory must be of type `client` and have `single-use` set to `false`.\n\n| `retry-interval`\n|\n| When in `client-mode`, specifies the number of milliseconds to wait between connection attempts or after a connection failure.\nDefault: 60000 (60 seconds).\n\n| `scheduler`\n| `true`, `false`\n| Specifies a `TaskScheduler` to use for managing the `client-mode` connection.\nIf not specified, it defaults to the global Spring Integration `taskScheduler` bean, which has a default pool size of 10.\nSee xref:configuration/namespace-taskscheduler.adoc[Configuring the Task Scheduler].\n|===\n\nThe following table describes attributes that you can set to configure TCP inbound gateways:\n\n.TCP Inbound Gateway Attributes\n[cols=\"2,^1,4\", options=\"header\"]\n|===\n| Attribute Name\n| Allowed Values\n| Attribute Description\n\n| `connection-factory`\n|\n| The connection factory must be of type server.\n\n| `request-channel`\n|\n| The channel to which incoming messages are sent.\n\n| `reply-channel`\n|\n| The channel on which reply messages may arrive.\nUsually, replies arrive on a temporary reply channel added to the inbound message header.\n\n| `reply-timeout`\n|\n| The time in milliseconds for which the gateway waits for a reply.\nDefault: 1000 (1 second).\n\n| `error-channel`\n|\n| If an exception is thrown by a downstream component, the `MessagingException` message containing the exception and the failed message is sent to this channel.\nAny reply from that flow is then returned as a response by the gateway.\n\n| `client-mode`\n| `true`, `false`\n| When `true`, the inbound gateway acts as a client with respect to establishing the connection and then receiving (and replying to) incoming messages on that connection.\nDefault: false.\nSee also `retry-interval` and `scheduler`.\nThe connection factory must be of type `client` and have `single-use` set to `false`.\n\n| `retry-interval`\n|\n| When in `client-mode`, specifies the number of milliseconds to wait between connection attempts or after a connection failure.\nDefault: 60000 (60 seconds).\n\n| `scheduler`\n| `true`, `false`\n| Specifies a `TaskScheduler` to use for managing the `client-mode` connection.\nIf not specified, it defaults to the global Spring Integration `taskScheduler` bean, which has a default pool size of 10.\nSee xref:configuration/namespace-taskscheduler.adoc[Configuring the Task Scheduler].\n|===\n\nThe following table describes attributes that you can set to configure TCP outbound gateways:\n\n[[tcp-ob-gateway-attributes]]\n.TCP Outbound Gateway Attributes\n[cols=\"2,^1,4\", options=\"header\"]\n|===\n| Attribute Name\n| Allowed Values\n| Attribute Description\n\n| `connection-factory`\n|\n| The connection factory must be of type `client`.\n\n| `request-channel`\n|\n| The channel on which outgoing messages arrive.\n\n| `reply-channel`\n|\n| Optional.\nThe channel to which reply messages are sent.\n\n| `remote-timeout`\n|\n| The time in milliseconds for which the gateway waits for a reply from the remote system.\nMutually exclusive with `remote-timeout-expression`.\nDefault: 10000 (10 seconds).\nNote: In versions prior to 4.2 this value defaulted to `reply-timeout` (if set).\n\n| `remote-timeout-expression`\n|\n| A SpEL expression that is evaluated against the message to determine the time in milliseconds for which the gateway waits for a reply from the remote system.\nMutually exclusive with `remote-timeout`.\n\n| `request-timeout`\n|\n| If a single-use connection factory is not being used, the time in milliseconds for which the gateway waits to get access to the shared connection.\n\n| `reply-timeout`\n|\n| The time in milliseconds for which the gateway waits when sending the reply to the reply-channel.\nOnly applies if the reply-channel might block (such as a bounded QueueChannel that is currently full).\n\n| `async`\n|\n| Release the sending thread after the sending; the reply (or error) will be sent on the receiving thread.\n\n| `unsolicited`\n`MessageChannel`\n|\n| A channel to which to send unsolicited messages and late replies.\n|===\n\n.IP Message Headers", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/endpoint-reference.adoc", "title": "endpoint-reference", "heading": "endpoint-reference", "heading_level": 1, "file_order": 101, "section_index": 0, "content_hash": "1534aa0aba50413cc558c58e5f3292d7d7cde85b63edd3ba906a541df87afdcb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/endpoint-reference.adoc"}}
{"id": "sha256:258d155707a084b963e800e223c8f79ea88aaaf5fe949324e105ae314756b9e6", "content": "[[ip-interceptors]]\n\nYou can configure connection factories with a reference to a `TcpConnectionInterceptorFactoryChain`.\nYou can use interceptors to add behavior to connections, such as negotiation, security, and other options.\nNo interceptors are currently provided by the framework, but see https://github.com/spring-projects/spring-integration/blob/main/spring-integration-ip/src/test/java/org/springframework/integration/ip/tcp/InterceptedSharedConnectionTests.java[`InterceptedSharedConnectionTests` in the source repository] for an example.\n\nThe `HelloWorldInterceptor` used in the test case works as follows:\n\nThe interceptor is first configured with a client connection factory.\nWhen the first message is sent over an intercepted connection, the interceptor sends 'Hello' over the connection and expects to receive 'world!'.\nWhen that occurs, the negotiation is complete and the original message is sent.\nFurther, messages that use the same connection are sent without any additional negotiation.\n\nWhen configured with a server connection factory, the interceptor requires the first message to be 'Hello' and, if it is, returns 'world!'.\nOtherwise, it throws an exception that causes the connection to be closed.\n\nAll `TcpConnection` methods are intercepted.\nInterceptor instances are created for each connection by an interceptor factory.\nIf an interceptor is stateful, the factory should create a new instance for each connection.\nIf there is no state, the same interceptor can wrap each connection.\nInterceptor factories are added to the configuration of an interceptor factory chain, which you can provide to a connection factory by setting the `interceptor-factory` attribute.\nInterceptors must extend `TcpConnectionInterceptorSupport`.\nFactories must implement the `TcpConnectionInterceptorFactory` interface.\n`TcpConnectionInterceptorSupport` has passthrough methods.\nBy extending this class, you only need to implement those methods you wish to intercept.\n\nThe following example shows how to configure a connection interceptor factory chain:\n\n[source,xml]\n----\n<bean id=\"helloWorldInterceptorFactory\"\n class=\"o.s.i.ip.tcp.connection.TcpConnectionInterceptorFactoryChain\">\n <property name=\"interceptors\">\n <array>\n <bean class=\"o.s.i.ip.tcp.connection.HelloWorldInterceptorFactory\"/>\n </array>\n </property>\n</bean>\n\n<int-ip:tcp-connection-factory id=\"server\"\n type=\"server\"\n port=\"12345\"\n using-nio=\"true\"\n single-use=\"true\"\n interceptor-factory-chain=\"helloWorldInterceptorFactory\"/>\n\n<int-ip:tcp-connection-factory id=\"client\"\n type=\"client\"\n host=\"localhost\"\n port=\"12345\"\n single-use=\"true\"\n so-timeout=\"100000\"\n using-nio=\"true\"\n interceptor-factory-chain=\"helloWorldInterceptorFactory\"/>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/interceptors.adoc", "title": "interceptors", "heading": "interceptors", "heading_level": 1, "file_order": 102, "section_index": 0, "content_hash": "258d155707a084b963e800e223c8f79ea88aaaf5fe949324e105ae314756b9e6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/interceptors.adoc"}}
{"id": "sha256:739acaaa8bcb84ce63d661abe4293905346f475e95a751c373f65664af8a6d2b", "content": "[[ip-intro]]\n\nTwo flavors each of UDP inbound and outbound channel adapters are provided:\n\n* `UnicastSendingMessageHandler` sends a datagram packet to a single destination.\n* `UnicastReceivingChannelAdapter` receives incoming datagram packets.\n* `MulticastSendingMessageHandler` sends (broadcasts) datagram packets to a multicast address.\n* `MulticastReceivingChannelAdapter` receives incoming datagram packets by joining to a multicast address.\n\nTCP inbound and outbound channel adapters are provided:\n\n* `TcpSendingMessageHandler` sends messages over TCP.\n* `TcpReceivingChannelAdapter` receives messages over TCP.\n\nAn inbound TCP gateway is provided.\nIt allows for simple request-response processing.\nWhile the gateway can support any number of connections, each connection can only be processed serially.\nThe thread that reads from the socket waits for, and sends, the response before reading again.\nIf the connection factory is configured for single use connections, the connection is closed after the socket times out.\n\nAn outbound TCP gateway is provided.\nIt allows for simple request-response processing.\nIf the associated connection factory is configured for single-use connections, a new connection is immediately created for each new request.\nOtherwise, if the connection is in use, the calling thread blocks on the connection until either a response is received or a timeout or I/O error occurs.\n\nThe TCP and UDP inbound channel adapters and the TCP inbound gateway support the `error-channel` attribute.\nThis provides the same basic functionality as described in xref:gateway.adoc#gateway-proxy[Enter the `GatewayProxyFactoryBean`].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/intro.adoc", "title": "intro", "heading": "intro", "heading_level": 1, "file_order": 103, "section_index": 0, "content_hash": "739acaaa8bcb84ce63d661abe4293905346f475e95a751c373f65664af8a6d2b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/intro.adoc"}}
{"id": "sha256:19fe7b9b403a7613d0305d5829c26462216cc26ee74356763ecf9a6e631c1210", "content": "[[ip-msg-headers]]\n\nThis module uses the following `MessageHeader` instances:\n\n[cols=\"3,3,4\", options=\"header\"]\n|===\n| Header Name\n| IpHeaders Constant\n| Description\n\n| `ip_hostname`\n| `HOSTNAME`\n| The host name from which a TCP message or UDP packet was received.\nIf `lookupHost` is `false`, this contains the IP address.\n\n| `ip_address`\n| `IP_ADDRESS`\n| The IP address from which a TCP message or UDP packet was received.\n\n| `ip_port`\n| `PORT`\n| The remote port for a UDP packet.\n\n| ip_localInetAddress\n| `IP_LOCAL_ADDRESS`\n| The local `InetAddress` to which the socket is connected (since version 4.2.5).\n\n| `ip_ackTo`\n| `ACKADDRESS`\n| The remote IP address to which UDP application-level acknowledgments are sent.\nThe framework includes acknowledgment information in the data packet.\n\n| `ip_ackId`\n| `ACK_ID`\n| A correlation ID for UDP application-level acknowledgments.\nThe framework includes acknowledgment information in the data packet.\n\n| `ip_tcp_remotePort`\n| `REMOTE_PORT`\n| The remote port for a TCP connection.\n\n| `ip_connectionId`\n| `CONNECTION_ID`\n| A unique identifier for a TCP connection.\nSet by the framework for inbound messages.\nWhen sending to a server-side inbound channel adapter or replying to an inbound gateway, this header is required so that the endpoint can determine the connection to which to send the message.\n\n| `ip_actualConnectionId`\n| `ACTUAL_CONNECTION_ID`\n| For information only.\nWhen using a cached or failover client connection factory, it contains the actual underlying connection ID.\n\n| `contentType`\n| `MessageHeaders.`\n`CONTENT_TYPE`\n| An optional content type for inbound messages\nDescribed after this table.\nNote that, unlike the other header constants, this constant is in the `MessageHeaders` class, not the `IpHeaders` class.\n|===\n\nFor inbound messages, `ip_hostname`, `ip_address`, `ip_tcp_remotePort`, and `ip_connectionId` are mapped by the default `TcpHeaderMapper`.\nIf you set the mapper's `addContentTypeHeader` property to `true`, the mapper sets the `contentType` header (`application/octet-stream;charset=\"UTF-8\"`, by default).\nYou can change the default by setting the `contentType` property.\nYou can add additional headers by subclassing `TcpHeaderMapper` and overriding the `supplyCustomHeaders` method.\nFor example, when you use SSL, you can add properties of the `SSLSession` by obtaining the session object from the `TcpConnection` object, which is provided as an argument to the `supplyCustomHeaders` method.\n\nFor outbound messages, `String` payloads are converted to `byte[]` with the default (`UTF-8`) charset.\nSet the `charset` property to change the default.\n\nWhen customizing the mapper properties or subclassing, declare the mapper as a bean and provide an instance to the connection factory by using the `mapper` property.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/msg-headers.adoc", "title": "msg-headers", "heading": "msg-headers", "heading_level": 1, "file_order": 104, "section_index": 0, "content_hash": "19fe7b9b403a7613d0305d5829c26462216cc26ee74356763ecf9a6e631c1210", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/msg-headers.adoc"}}
{"id": "sha256:9c6fc325f7d3fb3c828e7864e088392194b71bf55636833e32fe1a75940f0ff9", "content": "[[note-nio]]\n\nUsing NIO (see `using-nio` in xref:ip/endpoint-reference.adoc[IP Configuration Attributes]) avoids dedicating a thread to read from each socket.\nFor a small number of sockets, you are likely to find that not using NIO, together with an asynchronous hand-off (such as to a `QueueChannel`), performs as well as or better than using NIO.\n\nYou should consider using NIO when handling a large number of connections.\nHowever, the use of NIO has some other ramifications.\nA pool of threads (in the task executor) is shared across all the sockets.\nEach incoming message is assembled and sent to the configured channel as a separate unit of work on a thread selected from that pool.\nTwo sequential messages arriving at the same socket might be processed by different threads.\nThis means that the order in which the messages are sent to the channel is indeterminate.\nStrict ordering of the messages arriving at the socket is not maintained.\n\nFor some applications, this is not an issue.\nFor others, it is a problem.\nIf you require strict ordering, consider setting `using-nio` to `false` and using an asynchronous hand-off.\n\nAlternatively, you can insert a resequencer downstream of the inbound endpoint to return the messages to their proper sequence.\nIf you set `apply-sequence` to `true` on the connection factory, messages arriving at a TCP connection have `sequenceNumber` and `correlationId` headers set.\nThe resequencer uses these headers to return the messages to their proper sequence.\n\nIMPORTANT: Starting with version 5.1.4, priority is given to accepting new connections over reading from existing connections.\nThis should, generally, have little impact unless you have a very high rate of new incoming connections.\nIf you wish to revert to the previous behavior of giving reads priority, set the `multiAccept` property on the `TcpNioServerConnectionFactory` to `false`.\n\n[[pool-size]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/note-nio.adoc", "title": "note-nio", "heading": "note-nio", "heading_level": 1, "file_order": 105, "section_index": 0, "content_hash": "9c6fc325f7d3fb3c828e7864e088392194b71bf55636833e32fe1a75940f0ff9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/note-nio.adoc"}}
{"id": "sha256:7581c71044c999013d4d59bc6f99e01321e6d037297864b9a3a4f29c23ebb702", "content": "The pool size attribute is no longer used.\nPreviously, it specified the size of the default thread pool when a task-executor was not specified.\nIt was also used to set the connection backlog on server sockets.\nThe first function is no longer needed; see the next paragraph.\nThe second function is replaced by the `backlog` attribute.\n\nPreviously, when using a fixed thread pool task executor, (which was the default) with NIO, it was possible to get a deadlock and processing would stop.\nThe problem occurred when a buffer was full, a thread reading from the socket was trying to add more data to the buffer, and no threads were available to make space in the buffer.\nThis only occurred with a very small pool size, but it could be possible under extreme conditions.\nSince 2.2, two changes have eliminated this problem.\nFirst, the default task executor is a cached thread pool executor.\nSecond, deadlock detection logic has been added such that, if thread starvation occurs, instead of deadlocking, an exception is thrown, thus releasing the deadlocked resources.\n\nIMPORTANT: Now that the default task executor is unbounded, it is possible that an out-of-memory condition might occur with high rates of incoming messages if message processing takes extended time.\nIf your application exhibits this type of behavior, you should use a pooled task executor with an appropriate pool size, but see xref:ip/note-nio.adoc#io-thread-pool-task-executor-caller-runs[the next section].\n\n[[io-thread-pool-task-executor-caller-runs]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/note-nio.adoc", "title": "note-nio", "heading": "Pool Size", "heading_level": 2, "file_order": 105, "section_index": 1, "content_hash": "7581c71044c999013d4d59bc6f99e01321e6d037297864b9a3a4f29c23ebb702", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/note-nio.adoc"}}
{"id": "sha256:f5156393f16e4a4afa0ff3eecc7181997c2ec41ef6c11f38c65b8d3457f41310", "content": "You should keep in mind some important considerations when you use a fixed thread pool with the `CallerRunsPolicy` (`CALLER_RUNS` when using the `<task/>` namespace) and the queue capacity is small.\n\nThe following does not apply if you do not use a fixed thread pool.\n\nWith NIO connections, there are three distinct task types.\nThe I/O selector processing is performed on one dedicated thread (detecting events, accepting new connections, and dispatching the I/O read operations to other threads by using the task executor).\nWhen an I/O reader thread (to which the read operation is dispatched) reads data, it hands off to another thread to assemble the incoming message.\nLarge messages can take several reads to complete.\nThese \"`assembler`\" threads can block while waiting for data.\nWhen a new read event occurs, the reader determines if this socket already has an assembler and, if not, runs a new one.\nWhen the assembly process is complete, the assembler thread is returned to the pool.\n\nThis can cause a deadlock when the pool is exhausted, the `CALLER_RUNS` rejection policy is in use, and the task queue is full.\nWhen the pool is empty and there is no room in the queue, the IO selector thread receives an `OP_READ` event and dispatches the read by using the executor.\nThe queue is full, so the selector thread itself starts the read process.\nNow it detects that there is no assembler for this socket and, before it does the read, fires off an assembler.\nAgain, the queue is full, and the selector thread becomes the assembler.\nThe assembler is now blocked, waiting for the data to be read, which never happens.\nThe connection factory is now deadlocked because the selector thread cannot handle new events.\n\nTo avoid this deadlock, we must avoid the selector (or reader) threads performing the assembly task.\nWe want to use separate pools for the IO and assembly operations.\n\nThe framework provides a `CompositeExecutor`, which allows the configuration of two distinct executors: one for performing IO operations and one for message assembly.\nIn this environment, an IO thread can never become an assembler thread, and the deadlock cannot occur.\n\nIn addition, the task executors should be configured to use an `AbortPolicy` (`ABORT` when using `<task>`).\nWhen an I/O task cannot be completed, it is deferred for a short time and continually retried until it can be completed and have an assembler allocated.\nBy default, the delay is 100ms, but you can change it by setting the `readDelay` property on the connection factory (`read-delay` when configuring with the XML namespace).\n\nThe following three examples show how to configure the composite executor:\n\n[source,java]\n----\n@Bean\nprivate CompositeExecutor compositeExecutor() {\n ThreadPoolTaskExecutor ioExec = new ThreadPoolTaskExecutor();\n ioExec.setCorePoolSize(4);\n ioExec.setMaxPoolSize(10);\n ioExec.setQueueCapacity(0);\n ioExec.setThreadNamePrefix(\"io-\");\n ioExec.setRejectedExecutionHandler(new AbortPolicy());\n ioExec.initialize();\n ThreadPoolTaskExecutor assemblerExec = new ThreadPoolTaskExecutor();\n assemblerExec.setCorePoolSize(4);\n assemblerExec.setMaxPoolSize(10);\n assemblerExec.setQueueCapacity(0);\n assemblerExec.setThreadNamePrefix(\"assembler-\");\n assemblerExec.setRejectedExecutionHandler(new AbortPolicy());\n assemblerExec.initialize();\n return new CompositeExecutor(ioExec, assemblerExec);\n}\n----\n\n[source,xml]\n----\n<bean id=\"myTaskExecutor\" class=\"org.springframework.integration.util.CompositeExecutor\">\n <constructor-arg ref=\"io\"/>\n <constructor-arg ref=\"assembler\"/>\n</bean>\n\n<task:executor id=\"io\" pool-size=\"4-10\" queue-capacity=\"0\" rejection-policy=\"ABORT\" />\n<task:executor id=\"assembler\" pool-size=\"4-10\" queue-capacity=\"0\" rejection-policy=\"ABORT\" />\n----\n\n[source,xml]\n----\n<bean id=\"myTaskExecutor\" class=\"org.springframework.integration.util.CompositeExecutor\">\n <constructor-arg>\n <bean class=\"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\">\n <property name=\"threadNamePrefix\" value=\"io-\" />\n <property name=\"corePoolSize\" value=\"4\" />\n <property name=\"maxPoolSize\" value=\"8\" />\n <property name=\"queueCapacity\" value=\"0\" />\n <property name=\"rejectedExecutionHandler\">\n <bean class=\"java.util.concurrent.ThreadPoolExecutor.AbortPolicy\" />\n </property>\n </bean>\n </constructor-arg>\n <constructor-arg>\n <bean class=\"org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor\">\n <property name=\"threadNamePrefix\" value=\"assembler-\" />\n <property name=\"corePoolSize\" value=\"4\" />\n <property name=\"maxPoolSize\" value=\"10\" />\n <property name=\"queueCapacity\" value=\"0\" />\n <property name=\"rejectedExecutionHandler\">\n <bean class=\"java.util.concurrent.ThreadPoolExecutor.AbortPolicy\" />\n </property>\n </bean>\n </constructor-arg>\n</bean>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/note-nio.adoc", "title": "note-nio", "heading": "Thread Pool Task Executor with `CALLER_RUNS` Policy", "heading_level": 2, "file_order": 105, "section_index": 2, "content_hash": "f5156393f16e4a4afa0ff3eecc7181997c2ec41ef6c11f38c65b8d3457f41310", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/note-nio.adoc"}}
{"id": "sha256:679e68a86f0a792334214c83ddddacbc9fef948adc506a7d77a3ee63ef4fb230", "content": "[[ssl-tls]]\n\nSecure Sockets Layer/Transport Layer Security is supported.\nWhen using NIO, the JDK 5+ `SSLEngine` feature is used to handle handshaking after the connection is established.\nWhen not using NIO, standard `SSLSocketFactory` and `SSLServerSocketFactory` objects are used to create connections.\nA number of strategy interfaces are provided to allow significant customization.\nThe default implementations of these interfaces provide for the simplest way to get started with secure communications.\n\n[[ip-ssl-tls-getting-started]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/ssl-tls.adoc", "title": "ssl-tls", "heading": "ssl-tls", "heading_level": 1, "file_order": 106, "section_index": 0, "content_hash": "679e68a86f0a792334214c83ddddacbc9fef948adc506a7d77a3ee63ef4fb230", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/ssl-tls.adoc"}}
{"id": "sha256:b0fb8a2f6ae10c73c8f77609adc55736e959f4c7524a1f01784a9a156a4a37a1", "content": "Regardless of whether you use NIO, you need to configure the `ssl-context-support` attribute on the connection factory.\nThis attribute references a <bean/> definition that describes the location and passwords for the required key stores.\n\nSSL/TLS peers require two key stores each:\n\n* A keystore that contains private and public key pairs to identify the peer\n* A truststore that contains the public keys for peers that are trusted.\nSee the documentation for the `keytool` utility provided with the JDK.\nThe essential steps are\n\n. Create a new key pair and store it in a keystore.\n. Export the public key.\n. Import the public key into the peer's truststore.\n. Repeat for the other peer.\n\nNOTE: It is common in test cases to use the same key stores on both peers, but this should be avoided for production.\n\nAfter establishing the key stores, the next step is to indicate their locations to the `TcpSSLContextSupport` bean and provide a reference to that bean to the connection factory.\n\nThe following example configures an SSL connection:\n\n[source,xml]\n----\n<bean id=\"sslContextSupport\"\n class=\"o.sf.integration.ip.tcp.connection.support.DefaultTcpSSLContextSupport\">\n <constructor-arg value=\"client.ks\"/>\n <constructor-arg value=\"client.truststore.ks\"/>\n <constructor-arg value=\"secret\"/>\n <constructor-arg value=\"secret\"/>\n</bean>\n\n<ip:tcp-connection-factory id=\"clientFactory\"\n type=\"client\"\n host=\"localhost\"\n port=\"1234\"\n ssl-context-support=\"sslContextSupport\" />\n----\n\nThe `DefaultTcpSSLContextSupport` class also has an optional `protocol` property, which can be `SSL` or `TLS` (the default).\n\nThe keystore file names (the first two constructor arguments) use the Spring `Resource` abstraction.\nBy default, the files are located on the classpath, but you can override this by using the `file:` prefix (to find the files on the filesystem instead).\n\nStarting with version 4.3.6, when you use NIO, you can specify an `ssl-handshake-timeout` (in seconds) on the connection factory.\nThis timeout (the default is 30 seconds) is used during SSL handshake when waiting for data.\nIf the timeout is exceeded, the process is stopped and the socket is closed.\n\n[[tcp-ssl-host-verification]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/ssl-tls.adoc", "title": "ssl-tls", "heading": "Getting Started", "heading_level": 2, "file_order": 106, "section_index": 1, "content_hash": "b0fb8a2f6ae10c73c8f77609adc55736e959f4c7524a1f01784a9a156a4a37a1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/ssl-tls.adoc"}}
{"id": "sha256:c4e8a007f1d92da90494a79412e861a1517b03176349adfe33b9897d678ec2fb", "content": "Starting with version 5.0.8, you can configure whether to enable host verification.\nStarting with version 5.1, it is enabled by default; the mechanism to disable it depends on whether you are using NIO.\n\nHost verification is used to ensure the server you are connected to matches information in the certificate, even if the certificate is trusted.\n\nWhen using NIO, configure the `DefaultTcpNioSSLConnectionSupport`, for example.\n\n[source, java]\n----\n@Bean\npublic DefaultTcpNioSSLConnectionSupport connectionSupport() {\n DefaultTcpSSLContextSupport sslContextSupport = new DefaultTcpSSLContextSupport(\"test.ks\",\n \"test.truststore.ks\", \"secret\", \"secret\");\n sslContextSupport.setProtocol(\"SSL\");\n DefaultTcpNioSSLConnectionSupport tcpNioConnectionSupport =\n new DefaultTcpNioSSLConnectionSupport(sslContextSupport, false);\n return tcpNioConnectionSupport;\n}\n----\n\nThe second constructor argument disables host verification.\nThe `connectionSupport` bean is then injected into the NIO connection factory.\n\nWhen not using NIO, the configuration is in the `TcpSocketSupport`:\n\n[source, java]\n----\nconnectionFactory.setTcpSocketSupport(new DefaultTcpSocketSupport(false));\n----\n\nAgain, the constructor argument disables host verification.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/ssl-tls.adoc", "title": "ssl-tls", "heading": "Host Verification", "heading_level": 2, "file_order": 106, "section_index": 2, "content_hash": "c4e8a007f1d92da90494a79412e861a1517b03176349adfe33b9897d678ec2fb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/ssl-tls.adoc"}}
{"id": "sha256:a500093e0241bc92f347becc333e6f9926f89397bb36a7a174393baa15d28ea4", "content": "[[tcp-adapters]]\n\nTCP inbound and outbound channel adapters that use connection factories xref:changes-4.1-4.2.adoc#x4.2-tcp-events[mentioned earlier] are provided.\nThese adapters have two relevant attributes: `connection-factory` and `channel`.\nThe `connection-factory` attribute indicates which connection factory is to be used to manage connections for the adapter.\nThe `channel` attribute specifies the channel on which messages arrive at an outbound adapter and on which messages are placed by an inbound adapter.\nWhile both inbound and outbound adapters can share a connection factory, server connection factories are always \"`owned`\" by an inbound adapter.\nClient connection factories are always \"`owned`\" by an outbound adapter.\nOnly one adapter of each type may get a reference to a connection factory.\nThe following example shows how to define client and server TCP connection factories:\n\n[source,xml]\n----\n<bean id=\"javaSerializer\"\n class=\"org.springframework.core.serializer.DefaultSerializer\"/>\n<bean id=\"javaDeserializer\"\n class=\"org.springframework.core.serializer.DefaultDeserializer\"/>\n\n<int-ip:tcp-connection-factory id=\"server\"\n type=\"server\"\n port=\"1234\"\n deserializer=\"javaDeserializer\"\n serializer=\"javaSerializer\"\n using-nio=\"true\"\n single-use=\"true\"/>\n\n<int-ip:tcp-connection-factory id=\"client\"\n type=\"client\"\n host=\"localhost\"\n port=\"#{server.port}\"\n single-use=\"true\"\n so-timeout=\"10000\"\n deserializer=\"javaDeserializer\"\n serializer=\"javaSerializer\"/>\n\n<int:channel id=\"input\" />\n\n<int:channel id=\"replies\">\n <int:queue/>\n</int:channel>\n\n<int-ip:tcp-outbound-channel-adapter id=\"outboundClient\"\n channel=\"input\"\n connection-factory=\"client\"/>\n\n<int-ip:tcp-inbound-channel-adapter id=\"inboundClient\"\n channel=\"replies\"\n connection-factory=\"client\"/>\n\n<int-ip:tcp-inbound-channel-adapter id=\"inboundServer\"\n channel=\"loop\"\n connection-factory=\"server\"/>\n\n<int-ip:tcp-outbound-channel-adapter id=\"outboundServer\"\n channel=\"loop\"\n connection-factory=\"server\"/>\n\n<int:channel id=\"loop\"/>\n----\n\nAlso see xref:ip/annotation.adoc[Annotation-Based Configuration] and xref:ip/dsl.adoc[Using the Java DSL for TCP Components].\n\nIn the preceding configuration, messages arriving in the `input` channel are serialized over connections created by `client` connection factory, received at the server, and placed on the `loop` channel.\nSince `loop` is the input channel for `outboundServer`, the message is looped back over the same connection, received by `inboundClient`, and deposited in the `replies` channel.\nJava serialization is used on the wire.\n\nNormally, inbound adapters use a `type=\"server\"` connection factory, which listens for incoming connection requests.\nIn some cases, you may want to establish the connection in reverse, such that the inbound adapter connects to an external server and then waits for inbound messages on that connection.\n\nThis topology is supported by setting `client-mode=\"true\"` on the inbound adapter.\nIn this case, the connection factory must be of type `client` and must have `single-use` set to `false`.\n\nTwo additional attributes support this mechanism.\nThe `retry-interval` specifies (in milliseconds) how often the framework attempts to reconnect after a connection failure.\nThe `scheduler` supplies a `TaskScheduler` to schedule the connection attempts and to test that the connection is still active.\n\nIf you don't provide a scheduler, the framework's default xref:configuration/namespace-taskscheduler.adoc[taskScheduler] bean is used.\n\nFor an outbound adapter, the connection is normally established when the first message is sent.\nThe `client-mode=\"true\"` on an outbound adapter causes the connection to be established when the adapter is started.\nBy default, adapters are automatically started.\nAgain, the connection factory must be of type `client` and have `single-use=\"false\"`.\nA `retry-interval` and `scheduler` are also supported.\nIf a connection fails, it is re-established either by the scheduler or when the next message is sent.\n\nFor both inbound and outbound, if the adapter is started, you can force the adapter to establish a connection by sending a `<control-bus />` command: `@adapter_id.retryConnection()`.\nThen you can examine the current state with `@adapter_id.isClientModeConnected()`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-adapters.adoc", "title": "tcp-adapters", "heading": "tcp-adapters", "heading_level": 1, "file_order": 107, "section_index": 0, "content_hash": "a500093e0241bc92f347becc333e6f9926f89397bb36a7a174393baa15d28ea4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-adapters.adoc"}}
{"id": "sha256:b9c6ff261a3ce0f264ddb0874ab9d10daafc8243150339c5ed5d1b90d5023fb3", "content": "[[tcp-advanced-techniques]]\n\nThis section covers advanced techniques that you may find to be helpful in certain situations.\n\n[[strategy-interfaces]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc", "title": "tcp-advanced-techniques", "heading": "tcp-advanced-techniques", "heading_level": 1, "file_order": 108, "section_index": 0, "content_hash": "b9c6ff261a3ce0f264ddb0874ab9d10daafc8243150339c5ed5d1b90d5023fb3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc"}}
{"id": "sha256:7894626e4929da88bdd5652797a60c717c8981219d03080a6910884dd33e1b0d", "content": "In many cases, the configuration described earlier is all that is needed to enable secure communication over TCP/IP.\nHowever, Spring Integration provides a number of strategy interfaces to allow customization and modification of socket factories and sockets:\n\n* `TcpSSLContextSupport`\n* `TcpSocketFactorySupport`\n* `TcpSocketSupport`\n* `TcpNetConnectionSupport`\n* `TcpNioConnectionSupport`\n\n[[the-tcpsslcontextsupport-strategy-interface]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc", "title": "tcp-advanced-techniques", "heading": "Strategy Interfaces", "heading_level": 2, "file_order": 108, "section_index": 1, "content_hash": "7894626e4929da88bdd5652797a60c717c8981219d03080a6910884dd33e1b0d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc"}}
{"id": "sha256:b255b842e7ec62976c59732a4add85886ca0d2ffd813d9995d1050749938d215", "content": "The following listing shows the `TcpSSLContextSupport` strategy interface:\n\n[source,java]\n----\npublic interface TcpSSLContextSupport {\n\n SSLContext getSSLContext() throws Exception;\n\n}\n----\n\nImplementations of the `TcpSSLContextSupport` interface are responsible for creating an `SSLContext` object.\nThe implementation provided by the framework is the `DefaultTcpSSLContextSupport`, xref:ip/ssl-tls.adoc#ip-ssl-tls-getting-started[described earlier].\nIf you require different behavior, implement this interface and provide the connection factory with a reference to a bean of your class' implementation.\n\n[[the-tcpsocketfactorysupport-strategy-interface]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc", "title": "tcp-advanced-techniques", "heading": "The `TcpSSLContextSupport` Strategy Interface", "heading_level": 3, "file_order": 108, "section_index": 2, "content_hash": "b255b842e7ec62976c59732a4add85886ca0d2ffd813d9995d1050749938d215", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc"}}
{"id": "sha256:482c1abf3fc143ab57247bac217a0a396530eea79658c1473fc9f6be62ee21a5", "content": "The following listing shows the definition of the `TcpSocketFactorySupport` strategy interface:\n\n[source,java]\n----\npublic interface TcpSocketFactorySupport {\n\n ServerSocketFactory getServerSocketFactory();\n\n SocketFactory getSocketFactory();\n\n}\n----\n\nImplementations of this interface are responsible for obtaining references to `ServerSocketFactory` and `SocketFactory`.\nTwo implementations are provided.\nThe first is `DefaultTcpNetSocketFactorySupport` for non-SSL sockets (when no `ssl-context-support` attribute is defined).\nThis uses the JDK's default factories.\nThe second implementation is `DefaultTcpNetSSLSocketFactorySupport`.\nBy default, this is used when an `ssl-context-support` attribute is defined.\nIt uses the `SSLContext` created by that bean to create the socket factories.\n\nNOTE: This interface applies only if `using-nio` is `false`.\nNIO does not use socket factories.\n\n[[the-tcpsocketsupport-strategy-interface]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc", "title": "tcp-advanced-techniques", "heading": "The `TcpSocketFactorySupport` Strategy Interface", "heading_level": 3, "file_order": 108, "section_index": 3, "content_hash": "482c1abf3fc143ab57247bac217a0a396530eea79658c1473fc9f6be62ee21a5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc"}}
{"id": "sha256:8376a6c374c80e7b82c99314dab03c74d7a0b6706c7aa162259a0de9cd43ca8b", "content": "The following listing shows the definition of the `TcpSocketSupport` strategy interface:\n\n[source,java]\n----\npublic interface TcpSocketSupport {\n\n void postProcessServerSocket(ServerSocket serverSocket);\n\n void postProcessSocket(Socket socket);\n\n}\n----\n\nImplementations of this interface can modify sockets after they are created and after all configured attributes have been applied but before the sockets are used.\nThis applies whether you use NIO or not.\nFor example, you could use an implementation of this interface to modify the supported cipher suites on an SSL socket, or you could add a listener that gets notified after SSL handshaking is complete.\nThe sole implementation provided by the framework is the `DefaultTcpSocketSupport`, which does not modify the sockets in any way.\n\nTo supply your own implementation of `TcpSocketFactorySupport` or `TcpSocketSupport`, provide the connection factory with references to beans of your custom type by setting the `socket-factory-support` and `socket-support` attributes, respectively.\n\n[[the-tcpnetconnectionsupport-strategy-interface]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc", "title": "tcp-advanced-techniques", "heading": "The `TcpSocketSupport` Strategy Interface", "heading_level": 3, "file_order": 108, "section_index": 4, "content_hash": "8376a6c374c80e7b82c99314dab03c74d7a0b6706c7aa162259a0de9cd43ca8b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc"}}
{"id": "sha256:4f386ab7cf24f49f8142671c29bacef4c9c8cb95b158c12ad87b69b32c947aff", "content": "The following listing shows the definition of the `TcpNetConnectionSupport` strategy interface:\n\n[source, java]\n----\npublic interface TcpNetConnectionSupport {\n\n TcpNetConnection createNewConnection(Socket socket,\n boolean server, boolean lookupHost,\n ApplicationEventPublisher applicationEventPublisher,\n String connectionFactoryName) throws Exception;\n\n}\n----\n\nThis interface is invoked to create objects of type `TcpNetConnection` (or its subclasses).\nThe framework provides a single implementation (`DefaultTcpNetConnectionSupport`), which, by default, creates simple `TcpNetConnection` objects.\nIt has two properties: `pushbackCapable` and `pushbackBufferSize`.\nWhen push back is enabled, the implementation returns a subclass that wraps the connection's `InputStream` in a `PushbackInputStream`.\nAligned with the `PushbackInputStream` default, the buffer size defaults to 1.\nThis lets deserializers \"`unread`\" (push back) bytes into the stream.\nThe following trivial example shows how it might be used in a delegating deserializer that \"`peeks`\" at the first byte to determine which deserializer to invoke:\n\n[source, java]\n----\npublic class CompositeDeserializer implements Deserializer<byte[]> {\n\n private final ByteArrayStxEtxSerializer stxEtx = new ByteArrayStxEtxSerializer();\n\n private final ByteArrayCrLfSerializer crlf = new ByteArrayCrLfSerializer();\n\n @Override\n public byte[] deserialize(InputStream inputStream) throws IOException {\n PushbackInputStream pbis = (PushbackInputStream) inputStream;\n int first = pbis.read();\n if (first < 0) {\n throw new SoftEndOfStreamException();\n }\n pbis.unread(first);\n if (first == ByteArrayStxEtxSerializer.STX) {\n this.receivedStxEtx = true;\n return this.stxEtx.deserialize(pbis);\n }\n else {\n this.receivedCrLf = true;\n return this.crlf.deserialize(pbis);\n }\n }\n\n}\n----\n\n[[the-tcpnioconnectionsupport-strategy-interface]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc", "title": "tcp-advanced-techniques", "heading": "The `TcpNetConnectionSupport` Strategy Interface", "heading_level": 3, "file_order": 108, "section_index": 5, "content_hash": "4f386ab7cf24f49f8142671c29bacef4c9c8cb95b158c12ad87b69b32c947aff", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc"}}
{"id": "sha256:a7f7555dd530de459ff17c016e1f1dda391b70cbfb08a810762a04f38ffcbba6", "content": "The following listing shows the definition of the `TcpNioConnectionSupport` strategy interface:\n\n[source, java]\n----\npublic interface TcpNioConnectionSupport {\n\n TcpNioConnection createNewConnection(SocketChannel socketChannel,\n boolean server, boolean lookupHost,\n ApplicationEventPublisher applicationEventPublisher,\n String connectionFactoryName) throws Exception;\n\n}\n----\n\nThis interface is invoked to create `TcpNioConnection` objects (or objects from subclasses).\nSpring Integration provides two implementations: `DefaultTcpNioSSLConnectionSupport` and `DefaultTcpNioConnectionSupport`.\nWhich one is used depends on whether SSL is in use.\nA common use case is to subclass `DefaultTcpNioSSLConnectionSupport` and override `postProcessSSLEngine`.\nSee the xref:ip/tcp-advanced-techniques.adoc#ssl-client-authentication-example[SSL client authentication example].\nAs with the `DefaultTcpNetConnectionSupport`, these implementations also support push back.\n\n[[ssl-client-authentication-example]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc", "title": "tcp-advanced-techniques", "heading": "The `TcpNioConnectionSupport` Strategy Interface", "heading_level": 3, "file_order": 108, "section_index": 6, "content_hash": "a7f7555dd530de459ff17c016e1f1dda391b70cbfb08a810762a04f38ffcbba6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc"}}
{"id": "sha256:e1752b65edba40369ae29c05f740ab3bbd3fb254001f0b55560b249aa3b0c3b4", "content": "To enable client certificate authentication when you use SSL, the technique depends on whether you use NIO.\nWhen you do not NIO, provide a custom `TcpSocketSupport` implementation to post-process the server socket:\n\n[source, java]\n----\nserverFactory.setTcpSocketSupport(new DefaultTcpSocketSupport() {\n\n @Override\n public void postProcessServerSocket(ServerSocket serverSocket) {\n ((SSLServerSocket) serverSocket).setNeedClientAuth(true);\n }\n\n});\n----\n\n(When you use XML configuration, provide a reference to your bean by setting the `socket-support` attribute).\n\nWhen you use NIO, provide a custom `TcpNioSslConnectionSupport` implementation to post-process the `SSLEngine`, as the following example shows:\n\n[source, java]\n----\n@Bean\npublic DefaultTcpNioSSLConnectionSupport tcpNioConnectionSupport() {\n return new DefaultTcpNioSSLConnectionSupport(serverSslContextSupport) {\n\n @Override\n protected void postProcessSSLEngine(SSLEngine sslEngine) {\n sslEngine.setNeedClientAuth(true);\n }\n\n }\n}\n\n@Bean\npublic TcpNioServerConnectionFactory server() {\n ...\n serverFactory.setTcpNioConnectionSupport(tcpNioConnectionSupport());\n ...\n}\n----\n\n(When you use XML configuration, since version 4.3.7, provide a reference to your bean by setting the `nio-connection-support` attribute).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc", "title": "tcp-advanced-techniques", "heading": "Example: Enabling SSL Client Authentication", "heading_level": 2, "file_order": 108, "section_index": 7, "content_hash": "e1752b65edba40369ae29c05f740ab3bbd3fb254001f0b55560b249aa3b0c3b4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-advanced-techniques.adoc"}}
{"id": "sha256:4c7ff3a3d1be3eace29a9e562ed937161d1abdc23ba3f102ca03c00b586fd667", "content": "[[tcp-connection-factories]]\n\n[[overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc", "title": "tcp-connection-factories", "heading": "tcp-connection-factories", "heading_level": 1, "file_order": 109, "section_index": 0, "content_hash": "4c7ff3a3d1be3eace29a9e562ed937161d1abdc23ba3f102ca03c00b586fd667", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc"}}
{"id": "sha256:19f295bc394f8c369fe6cc0bf4e53d57d18b43270cddd5bfcf852df3e0c06771", "content": "For TCP, the configuration of the underlying connection is provided by using a connection factory.\nTwo types of connection factory are provided: a client connection factory and a server connection factory.\nClient connection factories establish outgoing connections.\nServer connection factories listen for incoming connections.\n\nAn outbound channel adapter uses a client connection factory, but you can also provide a reference to a client connection factory to an inbound channel adapter.\nThat adapter receives any incoming messages that are received on connections created by the outbound adapter.\n\nAn inbound channel adapter or gateway uses a server connection factory.\n(In fact, the connection factory cannot function without one).\nYou can also provide a reference to a server connection factory to an outbound adapter.\nYou can then use that adapter to send replies to incoming messages on the same connection.\n\nTIP: Reply messages are routed to the connection only if the reply contains the `ip_connectionId` header that was inserted into the original message by the connection factory.\n\nTIP: This is the extent of message correlation performed when sharing connection factories between inbound and outbound adapters.\nSuch sharing allows for asynchronous two-way communication over TCP.\nBy default, only payload information is transferred using TCP.\nTherefore, any message correlation must be performed by downstream components such as aggregators or other endpoints.\nSupport for transferring selected headers was introduced in version 3.0.\nFor more information, see xref:ip/correlation.adoc[TCP Message Correlation].\n\nYou may give a reference to a connection factory to a maximum of one adapter of each type.\n\nSpring Integration provides connection factories that use `java.net.Socket` and `java.nio.channel.SocketChannel`.\n\nThe following example shows a simple server connection factory that uses `java.net.Socket` connections:\n\n[source,xml]\n----\n<int-ip:tcp-connection-factory id=\"server\"\n type=\"server\"\n port=\"1234\"/>\n----\n\nThe following example shows a simple server connection factory that uses `java.nio.channel.SocketChannel` connections:\n\n[source,xml]\n----\n<int-ip:tcp-connection-factory id=\"server\"\n type=\"server\"\n port=\"1234\"\n using-nio=\"true\"/>\n----\n\nNOTE: Starting with Spring Integration version 4.2, if the server is configured to listen on a random port (by setting the port to `0`), you can get the actual port chosen by the OS by using `getPort()`.\nAlso, `getServerSocketAddress()` lets you get the complete `SocketAddress`.\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/ip/tcp/connection/TcpServerConnectionFactory.html[Javadoc for the `TcpServerConnectionFactory` interface] for more information.\n\n[source,xml]\n----\n<int-ip:tcp-connection-factory id=\"client\"\n type=\"client\"\n host=\"localhost\"\n port=\"1234\"\n single-use=\"true\"\n so-timeout=\"10000\"/>\n----\n\nThe following example shows a client connection factory that uses `java.net.Socket` connections and creates a new connection for each message:\n\n[source,xml]\n----\n<int-ip:tcp-connection-factory id=\"client\"\n type=\"client\"\n host=\"localhost\"\n port=\"1234\"\n single-use=\"true\"\n so-timeout=\"10000\"\n using-nio=true/>\n----\n\nStarting with version 5.2, the client connection factories support the property `connectTimeout`, specified in seconds, which defaults to 60.\n\nAlso see xref:ip/annotation.adoc[Annotation-Based Configuration] and xref:ip/dsl.adoc[Using the Java DSL for TCP Components].\n\n[[tcp-codecs]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc", "title": "tcp-connection-factories", "heading": "Overview", "heading_level": 2, "file_order": 109, "section_index": 1, "content_hash": "19f295bc394f8c369fe6cc0bf4e53d57d18b43270cddd5bfcf852df3e0c06771", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc"}}
{"id": "sha256:52d045e986ae723bbf7dafa5fb0dcd402d79a5855bbbe5c630a67ae45945d837", "content": "TCP is a streaming protocol.\nThis means that some structure has to be provided to data transported over TCP so that the receiver can demarcate the data into discrete messages.\nConnection factories are configured to use serializers and deserializers to convert between the message payload and the bits that are sent over TCP.\nThis is accomplished by providing a deserializer and a serializer for inbound and outbound messages, respectively.\nSpring Integration provides a number of standard serializers and deserializers.\n\n`ByteArrayCrlfSerializer`^*^ converts a byte array to a stream of bytes followed by carriage return and linefeed characters (`\\r\\n`).\nThis is the default serializer (and deserializer) and can be used (for example) with telnet as a client.\n\nThe `ByteArraySingleTerminatorSerializer`^*^ converts a byte array to a stream of bytes followed by a single termination character (the default is `0x00`).\n\nThe `ByteArrayLfSerializer`^*^ converts a byte array to a stream of bytes followed by a single linefeed character (`0x0a`).\n\nThe `ByteArrayStxEtxSerializer`^*^ converts a byte array to a stream of bytes preceded by an STX (`0x02`) and followed by an ETX (`0x03`).\n\nThe `ByteArrayLengthHeaderSerializer` converts a byte array to a stream of bytes preceded by a binary length in network byte order (big endian).\nThis is an efficient deserializer because it does not have to parse every byte to look for a termination character sequence.\nIt can also be used for payloads that contain binary data.\nThe preceding serializers support only text in the payload.\nThe default size of the length header is four bytes (an Integer), allowing for messages up to (2^31 - 1) bytes.\nHowever, the `length` header can be a single byte (unsigned) for messages up to 255 bytes, or an unsigned short (2 bytes) for messages up to (2^16 - 1) bytes.\nIf you need any other format for the header, you can subclass `ByteArrayLengthHeaderSerializer` and provide implementations for the `readHeader` and `writeHeader` methods.\nThe absolute maximum data size is (2^31 - 1) bytes.\nStarting with version 5.2, the header value can include the length of the header in addition to the payload.\nSet the `inclusive` property to enable that mechanism (it must be set to the same for producers and consumers).\n\nThe `ByteArrayRawSerializer`^*^, converts a byte array to a stream of bytes and adds no additional message demarcation data.\nWith this serializer (and deserializer), the end of a message is indicated by the client closing the socket in an orderly fashion.\nWhen using this serializer, message reception hangs until the client closes the socket or a timeout occurs.\nA timeout does not result in a message.\nWhen this serializer is being used and the client is a Spring Integration application, the client must use a connection factory that is configured with `single-use=\"true\"`.\nDoing so causes the adapter to close the socket after sending the message.\nThe serializer does not, by itself, close the connection.\nYou should use this serializer only with the connection factories used by channel adapters (not gateways), and the connection factories should be used by either an inbound or outbound adapter but not both.\nSee also `ByteArrayElasticRawDeserializer`, later in this section.\nHowever, since version 5.2, the outbound gateway has a new property `closeStreamAfterSend`; this allows the use of raw serializers/deserializers because the EOF is signaled to the server, while leaving the connection open to receive the reply.\n\nNOTE: Before version 4.2.2, when using non-blocking I/O (NIO), this serializer treated a timeout (during read) as an end of file, and the data read so far was emitted as a message.\nThis is unreliable and should not be used to delimit messages.\nIt now treats such conditions as an exception.\nIn the unlikely event that you use it this way, you can restore the previous behavior by setting the `treatTimeoutAsEndOfMessage` constructor argument to `true`.\n\nEach of these is a subclass of `AbstractByteArraySerializer`, which implements both `org.springframework.core.serializer.Serializer` and `org.springframework.core.serializer.Deserializer`.\nFor backwards compatibility, connections that use any subclass of `AbstractByteArraySerializer` for serialization also accept a `String` that is first converted to a byte array.\nEach of these serializers and deserializers converts an input stream that contains the corresponding format to a byte array payload.\n\nTo avoid memory exhaustion due to a badly behaved client (one that does not adhere to the protocol of the configured serializer), these serializers impose a maximum message size.\nIf an incoming message exceeds this size, an exception is thrown.\nThe default maximum message size is 2048 bytes.\nYou can increase it by setting the `maxMessageSize` property.\nIf you use the default serializer or deserializer and wish to increase the maximum message size, you must declare the maximum message size as an explicit bean with the `maxMessageSize` property set and configure the connection factory to use that bean.\n\nThe classes marked with ^*^ earlier in this section use an intermediate buffer and copy the decoded data to a final buffer of the correct size.\nStarting with version 4.3, you can configure these buffers by setting a `poolSize` property to let these raw buffers be reused instead of being allocated and discarded for each message, which is the default behavior.\nSetting the property to a negative value creates a pool that has no bounds.\nIf the pool is bounded, you can also set the `poolWaitTimeout` property (in milliseconds), after which an exception is thrown if no buffer becomes available.\nIt defaults to infinity.\nSuch an exception causes the socket to be closed.\n\nIf you wish to use the same mechanism in custom deserializers, you can extend `AbstractPooledBufferByteArraySerializer` (instead of its super class, `AbstractByteArraySerializer`) and implement `doDeserialize()` instead of `deserialize()`.\nThe buffer is automatically returned to the pool.\n`AbstractPooledBufferByteArraySerializer` also provides a convenient utility method: `copyToSizedArray()`.\n\nVersion 5.0 added the `ByteArrayElasticRawDeserializer`.\nThis is similar to the deserializer side of `ByteArrayRawSerializer` above, except that it is not necessary to set a `maxMessageSize`.\nInternally, it uses a `ByteArrayOutputStream` that lets the buffer grow as needed.\nThe client must close the socket in an orderly manner to signal the end of a message.\n\nWARNING: This deserializer should only be used when the peer is trusted; it is susceptible to an DoS attachment due to out-of-memory conditions.\n\nThe `MapJsonSerializer` uses a Jackson `ObjectMapper` to convert between a `Map` and JSON.\nYou can use this serializer in conjunction with a `MessageConvertingTcpMessageMapper` and a `MapMessageConverter` to transfer selected headers and the payload in JSON.\n\nNOTE: The Jackson `ObjectMapper` cannot demarcate messages in the stream.\nTherefore, the `MapJsonSerializer` needs to delegate to another serializer or deserializer to handle message demarcation.\nBy default, a `ByteArrayLfSerializer` is used, resulting in messages with a format of `<json><LF>` on the wire, but you can configure it to use others instead.\n(The next example shows how to do so.)\n\nThe final standard serializer is `org.springframework.core.serializer.DefaultSerializer`, which you can use to convert serializable objects with Java serialization.\nThe `org.springframework.core.serializer.DefaultDeserializer` is provided for inbound deserialization of streams that contain serializable objects.\n\nIf you do not wish to use the default serializer and deserializer (`ByteArrayCrLfSerializer`), you must set the `serializer` and `deserializer` attributes on the connection factory.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<bean id=\"javaSerializer\"\n class=\"org.springframework.core.serializer.DefaultSerializer\" />\n<bean id=\"javaDeserializer\"\n class=\"org.springframework.core.serializer.DefaultDeserializer\" />\n\n<int-ip:tcp-connection-factory id=\"server\"\n type=\"server\"\n port=\"1234\"\n deserializer=\"javaDeserializer\"\n serializer=\"javaSerializer\"/>\n----\n\nA server connection factory that uses `java.net.Socket` connections and uses Java serialization on the wire.\n\nFor full details of the attributes available on connection factories, see xref:ip/annotation.adoc[the reference] at the end of this section.\n\nBy default, reverse DNS lookups are not performed on inbound packets: in environments where DNS is not configured (e.g. Docker containers), this can cause connection delays.\nTo convert IP addresses to host names for use in message headers, the default behavior can be overridden by setting the `lookup-host` attribute to `true`.\n\nNOTE: You can also modify the attributes of sockets and socket factories.\nSee xref:ip/ssl-tls.adoc[SSL/TLS Support] for more information.\nAs noted there, such modifications are possible if SSL is being used, or not.\n\nAlso see xref:ip/annotation.adoc[Annotation-Based Configuration] and xref:ip/dsl.adoc[Using the Java DSL for TCP Components].\n\n[[host-verification]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc", "title": "tcp-connection-factories", "heading": "Message Demarcation (Serializers and Deserializers)", "heading_level": 2, "file_order": 109, "section_index": 2, "content_hash": "52d045e986ae723bbf7dafa5fb0dcd402d79a5855bbbe5c630a67ae45945d837", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc"}}
{"id": "sha256:dfa5acfe78e8f4e7acc5fe7321e256609dde84585dfa5ed5b4390763172a559d", "content": "Starting from version 5.1.0, host verification is enabled by default for enhanced security.\nThis feature ensures that the server's identity is verified during TCP connections.\n\nIf you encounter a scenario where host verification needs to be disabled (not recommended), you can configure the socket-support attribute in the tcp-connection-factory.\n\n[source,xml]\n----\n<int-ip:tcp-connection-factory id=\"client\"\n type=\"client\"\n host=\"localhost\"\n port=\"0\"\n socket-support=\"customSocketSupport\"\n single-use=\"true\"\n so-timeout=\"10000\"/>\n\n<bean id=\"customSocketSupport\" class=\"org.springframework.integration.ip.tcp.connection.DefaultTcpSocketSupport\">\n\t<constructor-arg value=\"false\" />\n</bean>\n----\n\n[[custom-serializers-and-deserializers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc", "title": "tcp-connection-factories", "heading": "Host verification", "heading_level": 2, "file_order": 109, "section_index": 3, "content_hash": "dfa5acfe78e8f4e7acc5fe7321e256609dde84585dfa5ed5b4390763172a559d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc"}}
{"id": "sha256:99f4cd5f507d9bf86af588ee1272590c7528238cea67407b8e197937122fa721", "content": "If your data is not in a format supported by one of the standard deserializers, you can implement your own; you can also implement a custom serializer.\n\nTo implement a custom serializer and deserializer pair, implement the `org.springframework.core.serializer.Deserializer` and `org.springframework.core.serializer.Serializer` interfaces.\n\nWhen the deserializer detects a closed input stream between messages, it must throw a `SoftEndOfStreamException`; this is a signal to the framework to indicate that the close was \"normal\".\nIf the stream is closed while decoding a message, some other exception should be thrown instead.\n\nStarting with version 5.2, `SoftEndOfStreamException` is now a `RuntimeException` instead of extending `IOException`.\n\n[[caching-cf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc", "title": "tcp-connection-factories", "heading": "Custom Serializers and Deserializers", "heading_level": 2, "file_order": 109, "section_index": 4, "content_hash": "99f4cd5f507d9bf86af588ee1272590c7528238cea67407b8e197937122fa721", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc"}}
{"id": "sha256:d002da495bab4af16e02fb5d997924ad38495be114c75aaf8cf0065e55127353", "content": "As xref:ip/intro.adoc[noted earlier], TCP sockets can be 'single-use' (one request or response) or shared.\nShared sockets do not perform well with outbound gateways in high-volume environments, because the socket can only process one request or response at a time.\n\nTo improve performance, you can use collaborating channel adapters instead of gateways, but that requires application-level message correlation.\nSee xref:ip/correlation.adoc[TCP Message Correlation] for more information.\n\nSpring Integration 2.2 introduced a caching client connection factory, which uses a pool of shared sockets, letting a gateway process multiple concurrent requests with a pool of shared connections.\n\n[[failover-cf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc", "title": "tcp-connection-factories", "heading": "TCP Caching Client Connection Factory", "heading_level": 2, "file_order": 109, "section_index": 5, "content_hash": "d002da495bab4af16e02fb5d997924ad38495be114c75aaf8cf0065e55127353", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc"}}
{"id": "sha256:9d96fe4e49f7ca2eccc90ed3c9745571edb4524a136a2e8717dbb6f746307731", "content": "You can configure a TCP connection factory that supports failover to one or more other servers.\nWhen sending a message, the factory iterates over all its configured factories until either the message can be sent or no connection can be found.\nInitially, the first factory in the configured list is used.\nIf a connection subsequently fails, the next factory becomes the current factory.\nThe following example shows how to configure a failover client connection factory:\n\n[source,xml]\n----\n<bean id=\"failCF\" class=\"o.s.i.ip.tcp.connection.FailoverClientConnectionFactory\">\n <constructor-arg>\n <list>\n <ref bean=\"clientFactory1\"/>\n <ref bean=\"clientFactory2\"/>\n </list>\n </constructor-arg>\n</bean>\n----\n\nNOTE: When using the failover connection factory, the `singleUse` property must be consistent between the factory itself and the list of factories it is configured to use.\n\nThe connection factory has two properties related to failing back, when used with a shared connection (`singleUse=false`):\n\n* `refreshSharedInterval`\n* `closeOnRefresh`\n\nConsider the following scenario based on the above configuration:\nLet's say `clientFactory1` cannot establish a connection but `clientFactory2` can.\nWhen the `failCF` `getConnection()` method is called after the `refreshSharedInterval` has passed, we will again attempt to connect using `clientFactory1`; if successful, the connection to `clientFactory2` will be closed.\nIf `closeOnRefresh` is `false`, the \"old\" connection will remain open and may be reused in future if the first factory fails once more.\n\nSet `refreshSharedInterval` to only attempt to reconnect with the first factory after that time has expired; setting it to `Long.MAX_VALUE` (default) if you only want to fail back to the first factory when the current connection fails.\n\nSet `closeOnRefresh` to close the \"old\" connection after a refresh actually creates a new connection.\n\nIMPORTANT: These properties do not apply if any of the delegate factories is a `CachingClientConnectionFactory` because the connection caching is handled there; in that case the list of connection factories will always be consulted to get a connection.\n\nStarting with version 5.3, these default to `Long.MAX_VALUE` and `true` so the factory only attempts to fail back when the current connection fails.\nTo revert to the default behavior of previous versions, set them to `0` and `false`.\n\nAlso see xref:ip/testing-connections.adoc[Testing Connections].\n\n[[tcp-affinity-cf]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc", "title": "tcp-connection-factories", "heading": "TCP Failover Client Connection Factory", "heading_level": 2, "file_order": 109, "section_index": 6, "content_hash": "9d96fe4e49f7ca2eccc90ed3c9745571edb4524a136a2e8717dbb6f746307731", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc"}}
{"id": "sha256:6a509f2bdfd52fc0fe1ac4ca97bac9655f8517af6568460807c5abe85edfadbf", "content": "Spring Integration version 5.0 introduced this connection factory.\nIt binds a connection to the calling thread, and the same connection is reused each time that thread sends a message.\nThis continues until the connection is closed (by the server or the network) or until the thread calls the `releaseConnection()` method.\nThe connections themselves are provided by another client factory implementation, which must be configured to provide non-shared (single-use) connections so that each thread gets a connection.\n\nThe following example shows how to configure a TCP thread affinity connection factory:\n\n[source, java]\n----\n@Bean\npublic TcpNetClientConnectionFactory cf() {\n TcpNetClientConnectionFactory cf = new TcpNetClientConnectionFactory(\"localhost\",\n Integer.parseInt(System.getProperty(PORT)));\n cf.setSingleUse(true);\n return cf;\n}\n\n@Bean\npublic ThreadAffinityClientConnectionFactory tacf() {\n return new ThreadAffinityClientConnectionFactory(cf());\n}\n\n@Bean\n@ServiceActivator(inputChannel = \"out\")\npublic TcpOutboundGateway outGate() {\n TcpOutboundGateway outGate = new TcpOutboundGateway();\n outGate.setConnectionFactory(tacf());\n outGate.setReplyChannelName(\"toString\");\n return outGate;\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc", "title": "tcp-connection-factories", "heading": "TCP Thread Affinity Connection Factory", "heading_level": 2, "file_order": 109, "section_index": 7, "content_hash": "6a509f2bdfd52fc0fe1ac4ca97bac9655f8517af6568460807c5abe85edfadbf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-connection-factories.adoc"}}
{"id": "sha256:91ce3d9fb60b7c53764df7a81c9650fb44799990f51f5ef96a09ba34fa26567c", "content": "[[tcp-events]]\n\nBeginning with version 3.0, changes to `TcpConnection` instances are reported by `TcpConnectionEvent` instances.\n`TcpConnectionEvent` is a subclass of `ApplicationEvent` and can thus be received by any `ApplicationListener` defined in the `ApplicationContext`, or an `@EventListener` method.\nAlso see xref:event.adoc#appevent-inbound[an event inbound channel adapter].\n\n`TcpConnectionEvents` have the following properties:\n\n* `connectionId`: The connection identifier, which you can use in a message header to send data to the connection.\n* `connectionFactoryName`: The bean name of the connection factory to which the connection belongs.\n* `throwable`: The `Throwable` (for `TcpConnectionExceptionEvent` events only).\n* `source`: The `TcpConnection`.\nYou can use this, for example, to determine the remote IP Address with `getHostAddress()` (cast required).\n\nAvailable ``TcpConnectionEvent``s, related to a specific connection include:\n\n* `TcpConnectionOpenEvent`\n* `TcpConnectionCloseEvent`\n* `TcpConnectionExceptionEvent`\n\nIn addition, since version 4.0, the standard deserializers discussed in xref:ip/tcp-connection-factories.adoc[TCP Connection Factories] now emit `TcpDeserializationExceptionEvent` instances when they encounter problems while decoding the data stream.\nThese events contain the exception, the buffer that was in the process of being built, and an offset into the buffer (if available) at the point where the exception occurred.\nApplications can use a normal `ApplicationListener`, an `@EventListener` method, or an `ApplicationEventListeningMessageProducer` (see xref:event.adoc#appevent-inbound[Receiving Spring Application Events]) to capture these events, allowing analysis of the problem.\n\nStarting with versions 4.0.7 and 4.1.3, `TcpConnectionServerExceptionEvent` instances are published whenever an unexpected exception occurs on a server socket (such as a `BindException` when the server socket is in use).\nThese events have a reference to the connection factory and the cause.\n\nStarting with version 4.2, `TcpConnectionFailedCorrelationEvent` instances are published whenever an endpoint (inbound gateway or collaborating outbound channel adapter) receives a message that cannot be routed to a connection because the `ip_connectionId` header is invalid.\nOutbound gateways also publish this event when a late reply is received (the sender thread has timed out).\nThe event contains the connection ID as well as an exception in the `cause` property, which contains the failed message.\n\nStarting with version 4.3, a `TcpConnectionServerListeningEvent` is emitted when a server connection factory is started.\nThis is useful when the factory is configured to listen on port `0`, meaning that the operating system chooses the port.\nIt can also be used instead of polling `isListening()`, if you need to wait before starting some other process that connects to the socket.\n\nIMPORTANT: To avoid delaying the listening thread from accepting connections, the event is published on a separate thread.\n\nStarting with version 4.3.2, a `TcpConnectionFailedEvent` is emitted whenever a client connection cannot be created.\nThe source of the event is the connection factory, which you can use to determine the host and port to which the connection could not be established.\n\nTo use a single `ApplicationListener` (or `@EventListener` method) to receive all of these events (including ``TcpConnectionEvent``s), configure the listener to receive ``IpIntegrationEvent``s.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-events.adoc", "title": "tcp-events", "heading": "tcp-events", "heading_level": 1, "file_order": 110, "section_index": 0, "content_hash": "91ce3d9fb60b7c53764df7a81c9650fb44799990f51f5ef96a09ba34fa26567c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-events.adoc"}}
{"id": "sha256:635f6998ba011c192b7d540e62f594906cfdd7ac87aeef44262c146e87e56987", "content": "[[tcp-gateways]]\n\nThe inbound TCP gateway `TcpInboundGateway` and outbound TCP gateway `TcpOutboundGateway` use a server and client connection factory, respectively.\nEach connection can process a single request or response at a time.\n\nThe inbound gateway, after constructing a message with the incoming payload and sending it to the `requestChannel`, waits for a response and sends the payload from the response message by writing it to the connection.\n\nNOTE: For the inbound gateway, you must retain or populate, the `ip_connectionId` header, because it is used to correlate the message to a connection.\nMessages that originate at the gateway automatically have the header set.\nIf the reply is constructed as a new message, you need to set the header.\nThe header value can be captured from the incoming message.\n\nAs with inbound adapters, inbound gateways normally use a `type=\"server\"` connection factory, which listens for incoming connection requests.\nIn some cases, you may want to establish the connection in reverse, such that the inbound gateway connects to an external server and then waits for and replies to inbound messages on that connection.\n\nThis topology is supported by using `client-mode=\"true\"` on the inbound gateway.\nIn this case, the connection factory must be of type `client` and must have `single-use` set to `false`.\n\nTwo additional attributes support this mechanism.\nThe `retry-interval` specifies (in milliseconds) how often the framework tries to reconnect after a connection failure.\nThe `scheduler` supplies a `TaskScheduler` to schedule the connection attempts and to test that the connection is still active.\n\nIf the gateway is started, you may force the gateway to establish a connection by sending a `<control-bus/>` command: `@adapter_id.retryConnection()` and examine the current state with `@adapter_id.isClientModeConnected()`.\n\nThe outbound gateway, after sending a message over the connection, waits for a response, constructs a response message, and puts it on the reply channel.\nCommunications over the connections are single-threaded.\nOnly one message can be handled at a time.\nIf another thread attempts to send a message before the current response has been received, it blocks until any previous requests are complete (or time out).\nIf, however, the client connection factory is configured for single-use connections, each new request gets its own connection and is processed immediately.\nThe following example configures an inbound TCP gateway:\n\n[source,xml]\n----\n\n<int-ip:tcp-inbound-gateway id=\"inGateway\"\n request-channel=\"tcpChannel\"\n reply-channel=\"replyChannel\"\n connection-factory=\"cfServer\"\n reply-timeout=\"10000\"/>\n----\n\nIf a connection factory configured with the default serializer or deserializer is used, messages is `\\r\\n` delimited data and the gateway can be used by a simple client such as telnet.\n\nThe following example shows an outbound TCP gateway:\n\n[source,xml]\n----\n\n<int-ip:tcp-outbound-gateway id=\"outGateway\"\n request-channel=\"tcpChannel\"\n reply-channel=\"replyChannel\"\n connection-factory=\"cfClient\"\n request-timeout=\"10000\"\n remote-timeout=\"10000\"/> <!-- or e.g. remote-timeout-expression=\"headers['timeout']\" -->\n----\n\nThe `client-mode` is not currently available with the outbound gateway.\n\nStarting with version 5.2, the outbound gateway can be configured with the property `closeStreamAfterSend`.\nIf the connection factory is configured for `single-use` (a new connection for each request/reply) the gateway will close the output stream; this signals EOF to the server.\nThis is useful if the server uses the EOF to determine the end of a message, rather than some delimiter in the stream, but leaves the connection open in order to receive the reply.\n\nNormally, the calling thread will block in the gateway, waiting for the reply (or a timeout).\nStarting with version 5.3, you can set the `async` property on the gateway and the sending thread is released to do other work.\nThe reply (or error) will be sent on the receiving thread.\nThis only applies when using the `TcpNetClientConnectionFactory`, it is ignored when using NIO because there is a race condition whereby a socket error that occurs after the reply is received can be passed to the gateway before the reply.\n\nIMPORTANT: When using a shared connection (`singleUse=false`), a new request, while another is in process, will be blocked until the current reply is received.\nConsider using the `CachingClientConnectionFactory` if you wish to support concurrent requests on a pool of long-lived connections.\n\nStarting with version 5.4, the inbound can be configured with an `unsolicitedMessageChannel`.\nUnsolicited inbound messages will be sent to this channel, as well as late replies (where the client timed out).\nTo support this on the server side, you can now register multiple ``TcpSender``s with the connection factory.\nGateways and Channel Adapters automatically register themselves.\nWhen sending unsolicited messages from the server, you must add the appropriate `IpHeaders.CONNECTION_ID` to the messages sent.\n\nAlso see xref:ip/annotation.adoc[Annotation-Based Configuration] and xref:ip/dsl.adoc[Using the Java DSL for TCP Components].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/tcp-gateways.adoc", "title": "tcp-gateways", "heading": "tcp-gateways", "heading_level": 1, "file_order": 111, "section_index": 0, "content_hash": "635f6998ba011c192b7d540e62f594906cfdd7ac87aeef44262c146e87e56987", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/tcp-gateways.adoc"}}
{"id": "sha256:e9f4096ed66c605f6e4df161cdcb58ea3235a6310bde4f2ce0cfa936079dda3c", "content": "[[testing-connections]]\n\nIn some scenarios, it can be useful to send some kind of health check request when a connection is first opened.\nOne such scenario might be when using a xref:ip/tcp-connection-factories.adoc#failover-cf[TCP Failover Client Connection Factory] so that we can fail over if the selected server allowed a connection to be opened but reports that it is not healthy.\n\nIn order to support this feature, add a `connectionTest` to the client connection factory.\n\n[source, java]\n----\n/**\n * Set a {@link Predicate} that will be invoked to test a new connection; return true\n * to accept the connection, false the reject.\n * @param connectionTest the predicate.\n * @since 5.3\n */\npublic void setConnectionTest(@Nullable Predicate<TcpConnectionSupport> connectionTest) {\n this.connectionTest = connectionTest;\n}\n----\n\nTo test the connection, attach a temporary listener to the connection within the test.\nIf the test fails, the connection is closed and an exception thrown.\nWhen used with the xref:ip/tcp-connection-factories.adoc#failover-cf[TCP Failover Client Connection Factory], this triggers trying the next server.\n\nIMPORTANT: Only the first reply from the server will go to the test listener.\n\nIn the following example, the server is considered healthy if the server replies `PONG` when we send `PING`.\n\n[source, java]\n----\nMessage<String> ping = new GenericMessage<>(\"PING\");\nbyte[] pong = \"PONG\".getBytes();\nclientFactory.setConnectionTest(conn -> {\n CountDownLatch latch = new CountDownLatch(1);\n AtomicBoolean result = new AtomicBoolean();\n conn.registerTestListener(msg -> {\n if (Arrays.equals(pong, (byte[]) msg.getPayload())) {\n result.set(true);\n }\n latch.countDown();\n return false;\n });\n conn.send(ping);\n try {\n latch.await(10, TimeUnit.SECONDS);\n }\n catch (InterruptedException e) {\n Thread.currentThread().interrupt();\n }\n return result.get();\n});\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/testing-connections.adoc", "title": "testing-connections", "heading": "testing-connections", "heading_level": 1, "file_order": 112, "section_index": 0, "content_hash": "e9f4096ed66c605f6e4df161cdcb58ea3235a6310bde4f2ce0cfa936079dda3c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/testing-connections.adoc"}}
{"id": "sha256:e0830592874dc271ea593dffda5a0238a167531f7ad8165eb56cda85c6e1a510", "content": "[[udp-adapters]]\n\nThis section describes how to configure and use the UDP adapters.\n\n[[outbound-udp-adapters-xml-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/udp-adapters.adoc", "title": "udp-adapters", "heading": "udp-adapters", "heading_level": 1, "file_order": 113, "section_index": 0, "content_hash": "e0830592874dc271ea593dffda5a0238a167531f7ad8165eb56cda85c6e1a510", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/udp-adapters.adoc"}}
{"id": "sha256:fa1e5c21f90c552270e2ef95b9de9ee2287517edb36a3282e4e3f258722b3848", "content": "The following example configures a UDP outbound channel adapter:\n\n[source,xml]\n----\n<int-ip:udp-outbound-channel-adapter id=\"udpOut\"\n host=\"somehost\"\n port=\"11111\"\n multicast=\"false\"\n socket-customizer=\"udpCustomizer\"\n channel=\"exampleChannel\"/>\n----\n\nTIP: When setting `multicast` to `true`, you should also provide the multicast address in the host attribute.\n\nUDP is an efficient but unreliable protocol.\nSpring Integration adds two attributes to improve reliability: `check-length` and `acknowledge`.\nWhen `check-length` is set to `true`, the adapter precedes the message data with a length field (four bytes in network byte order).\nThis enables the receiving side to verify the length of the packet received.\nIf a receiving system uses a buffer that is too short to contain the packet, the packet can be truncated.\nThe `length` header provides a mechanism to detect this.\n\nStarting with version 4.3, you can set the `port` to `0`, in which case the operating system chooses the port.\nThe chosen port can be discovered by invoking `getPort()` after the adapter is started and `isListening()` returns `true`.\n\nStarting with version 5.3.3, you can add a `SocketCustomizer` bean to modify the `DatagramSocket` after it is created (for example, call `setTrafficClass(0x10)`).\n\nThe following example shows an outbound channel adapter that adds length checking to the datagram packets:\n\n[source,xml]\n----\n<int-ip:udp-outbound-channel-adapter id=\"udpOut\"\n host=\"somehost\"\n port=\"11111\"\n multicast=\"false\"\n check-length=\"true\"\n channel=\"exampleChannel\"/>\n----\n\nTIP: The recipient of the packet must also be configured to expect a length to precede the actual data.\nFor a Spring Integration UDP inbound channel adapter, set its `check-length` attribute.\n\nThe second reliability improvement allows an application-level acknowledgment protocol to be used.\nThe receiver must send an acknowledgment to the sender within a specified time.\n\nThe following example shows an outbound channel adapter that adds length checking to the datagram packets and waits for an acknowledgment:\n\n[source,xml]\n----\n<int-ip:udp-outbound-channel-adapter id=\"udpOut\"\n host=\"somehost\"\n port=\"11111\"\n multicast=\"false\"\n check-length=\"true\"\n acknowledge=\"true\"\n ack-host=\"thishost\"\n ack-port=\"22222\"\n ack-timeout=\"10000\"\n channel=\"exampleChannel\"/>\n----\n\nTIP: Setting `acknowledge` to `true` implies that the recipient of the packet can interpret the header added to the packet containing acknowledgment data (host and port).\nMost likely, the recipient is a Spring Integration inbound channel adapter.\n\nTIP: When multicast is true, an additional attribute (`min-acks-for-success`) specifies how many acknowledgments must be received within the `ack-timeout`.\n\nStarting with version 4.3, you can set the `ackPort` to `0`, in which case the operating system chooses the port.\n\n[[outbound-udp-adapters-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/udp-adapters.adoc", "title": "udp-adapters", "heading": "Outbound UDP Adapters (XML Configuration)", "heading_level": 2, "file_order": 113, "section_index": 1, "content_hash": "fa1e5c21f90c552270e2ef95b9de9ee2287517edb36a3282e4e3f258722b3848", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/udp-adapters.adoc"}}
{"id": "sha256:9eac2691f56dd73535684233f6947c904472204c59a7205611f1d5bb03f7b4e3", "content": "The following example shows how to configure an outbound UDP adapter with Java:\n\n[source, java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"udpOut\")\npublic UnicastSendingMessageHandler handler() {\n return new UnicastSendingMessageHandler(\"localhost\", 11111);\n}\n----\n\n(or `MulticastSendingChannelAdapter` for multicast).\n\n[[outbound-udp-adapters-java-dsl-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/udp-adapters.adoc", "title": "udp-adapters", "heading": "Outbound UDP Adapters (Java Configuration)", "heading_level": 2, "file_order": 113, "section_index": 2, "content_hash": "9eac2691f56dd73535684233f6947c904472204c59a7205611f1d5bb03f7b4e3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/udp-adapters.adoc"}}
{"id": "sha256:386b9b9a015f59f9c7abe7a7e8e41c940c6dc65fa9d8ddfec171e3c0057cb74f", "content": "The following example shows how to configure an outbound UDP adapter with the Java DSL:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow udpOutFlow() {\n return f -> f.handle(Udp.outboundAdapter(\"localhost\", 1234)\n .configureSocket(socket -> socket.setTrafficClass(0x10)))\n .get();\n}\n----\n\n[[inbound-udp-adapters-xml-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/udp-adapters.adoc", "title": "udp-adapters", "heading": "Outbound UDP Adapters (Java DSL Configuration)", "heading_level": 2, "file_order": 113, "section_index": 3, "content_hash": "386b9b9a015f59f9c7abe7a7e8e41c940c6dc65fa9d8ddfec171e3c0057cb74f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/udp-adapters.adoc"}}
{"id": "sha256:9faa6c6be7d352b8488d9833ca1ddcde5794df211005c35891e1638b342063d5", "content": "The following example shows how to configure a basic unicast inbound udp channel adapter.\n\n[source,xml]\n----\n<int-ip:udp-inbound-channel-adapter id=\"udpReceiver\"\n channel=\"udpOutChannel\"\n port=\"11111\"\n receive-buffer-size=\"500\"\n multicast=\"false\"\n socket-customizer=\"udpCustomizer\"\n check-length=\"true\"/>\n----\n\nThe following example shows how to configure a basic multicast inbound udp channel adapter:\n\n[source,xml]\n----\n<int-ip:udp-inbound-channel-adapter id=\"udpReceiver\"\n channel=\"udpOutChannel\"\n port=\"11111\"\n receive-buffer-size=\"500\"\n multicast=\"true\"\n multicast-address=\"225.6.7.8\"\n check-length=\"true\"/>\n----\n\nBy default, reverse DNS lookups are not performed on inbound packets: in environments where DNS is not configured (e.g. Docker containers), this can cause connection delays.\nTo convert IP addresses to host names for use in message headers, the default behavior can be overridden by setting the `lookup-host` attribute to `true`.\n\nStarting with version 5.3.3, you can add a `SocketCustomizer` bean to modify the `DatagramSocket` after it is created.\nIt is called for the receiving socket and any sockets created for sending acks.\n\n[[inbound-udp-adapters-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/udp-adapters.adoc", "title": "udp-adapters", "heading": "Inbound UDP Adapters (XML Configuration)", "heading_level": 2, "file_order": 113, "section_index": 4, "content_hash": "9faa6c6be7d352b8488d9833ca1ddcde5794df211005c35891e1638b342063d5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/udp-adapters.adoc"}}
{"id": "sha256:2f6dfafed4e14e3f972f15afee48940c94a37b96cdcd6d65ba78ee0fd6d1088c", "content": "The following example shows how to configure an inbound UDP adapter with Java:\n\n[source, java]\n----\n@Bean\npublic UnicastReceivingChannelAdapter udpIn() {\n UnicastReceivingChannelAdapter adapter = new UnicastReceivingChannelAdapter(11111);\n adapter.setOutputChannelName(\"udpChannel\");\n return adapter;\n}\n----\n\nThe following example shows how to configure an inbound UDP adapter with the Java DSL:\n\n[[inbound-udp-adapters-java-dsl-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/udp-adapters.adoc", "title": "udp-adapters", "heading": "Inbound UDP Adapters (Java Configuration)", "heading_level": 2, "file_order": 113, "section_index": 5, "content_hash": "2f6dfafed4e14e3f972f15afee48940c94a37b96cdcd6d65ba78ee0fd6d1088c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/udp-adapters.adoc"}}
{"id": "sha256:0e538f8b0856459e7f081bcc9266ada67e47ad32057b763e66b4f37ac471b891", "content": "[source, java]\n----\n@Bean\npublic IntegrationFlow udpIn() {\n return IntegrationFlow.from(Udp.inboundAdapter(11111))\n .channel(\"udpChannel\")\n .get();\n}\n----\n\n[[server-listening-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/udp-adapters.adoc", "title": "udp-adapters", "heading": "Inbound UDP Adapters (Java DSL Configuration)", "heading_level": 2, "file_order": 113, "section_index": 6, "content_hash": "0e538f8b0856459e7f081bcc9266ada67e47ad32057b763e66b4f37ac471b891", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/udp-adapters.adoc"}}
{"id": "sha256:5fcde3dfcea27f93ffed79dffcc6bff1f43f756911fcffa4b057dad01ea16bb4", "content": "Starting with version 5.0.2, a `UdpServerListeningEvent` is emitted when an inbound adapter is started and has begun listening.\nThis is useful when the adapter is configured to listen on port `0`, meaning that the operating system chooses the port.\nIt can also be used instead of polling `isListening()`, if you need to wait before starting some other process that will connect to the socket.\n\n[[advanced-outbound-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/udp-adapters.adoc", "title": "udp-adapters", "heading": "Server Listening Events", "heading_level": 2, "file_order": 113, "section_index": 7, "content_hash": "5fcde3dfcea27f93ffed79dffcc6bff1f43f756911fcffa4b057dad01ea16bb4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/udp-adapters.adoc"}}
{"id": "sha256:6412caab4e0cf5b29b693b3efb77656f83ec59457670ed67b199a8f717b8b46f", "content": "The `<int-ip:udp-outbound-channel-adapter>` (`UnicastSendingMessageHandler`) has `destination-expression` and `socket-expression` options.\n\nYou can use the `destination-expression` as a runtime alternative to the hardcoded `host`-`port` pair to determine the destination address for the outgoing datagram packet against a `requestMessage` (with the root object for the evaluation context).\nThe expression must evaluate to an `URI`, a `String` in the URI style (see https://www.ietf.org/rfc/rfc2396.txt[RFC-2396]), or a `SocketAddress`.\nYou can also use the inbound `IpHeaders.PACKET_ADDRESS` header for this expression.\nIn the framework, the `DatagramPacketMessageMapper` populates this header when we receive datagrams in the `UnicastReceivingChannelAdapter` and convert them to messages.\nThe header value is exactly the result of `DatagramPacket.getSocketAddress()` of the incoming datagram.\n\nWith the `socket-expression`, the outbound channel adapter can use (for example) an inbound channel adapter socket to send datagrams through the same port which they were received.\nIt is useful in a scenario where our application works as a UDP server and clients operate behind network address translation (NAT).\nThis expression must evaluate to a `DatagramSocket`.\nThe `requestMessage` is used as the root object for the evaluation context.\nYou cannot use the `socket-expression` parameter with the `multicast` and `acknowledge` parameters.\nThe following example shows how to configure a UDP inbound channel adapter with a transformer that converts to upper case and uses a socket:\n\n[source,xml]\n----\n<int-ip:udp-inbound-channel-adapter id=\"inbound\" port=\"0\" channel=\"in\" />\n\n<int:channel id=\"in\" />\n\n<int:transformer expression=\"new String(payload).toUpperCase()\"\n input-channel=\"in\" output-channel=\"out\"/>\n\n<int:channel id=\"out\" />\n\n<int-ip:udp-outbound-channel-adapter id=\"outbound\"\n socket-expression=\"@inbound.socket\"\n destination-expression=\"headers['ip_packetAddress']\"\n channel=\"out\" />\n----\n\nThe following example shows the equivalent configuration with the Java DSL:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow udpEchoUpcaseServer() {\n return IntegrationFlow.from(Udp.inboundAdapter(11111).id(\"udpIn\"))\n .<byte[], String>transform(p -> new String(p).toUpperCase())\n .handle(Udp.outboundAdapter(\"headers['ip_packetAddress']\")\n .socketExpression(\"@udpIn.socket\"))\n .get();\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip/udp-adapters.adoc", "title": "udp-adapters", "heading": "Advanced Outbound Configuration", "heading_level": 2, "file_order": 113, "section_index": 8, "content_hash": "6412caab4e0cf5b29b693b3efb77656f83ec59457670ed67b199a8f717b8b46f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip/udp-adapters.adoc"}}
{"id": "sha256:2e45874d623a59375211f554c608ee811811f55f899bb3d2768b395ef832e1eb", "content": "[[jdbc-dsl]]\n\nVersion 7.0 introduced the Java DSL API for channel adapters in the JDBC module.\nThe central Java DSL class (and usually starting point) is a `org.springframework.integration.jdbc.dsl.Jdbc` factory.\nIt provides a self-explanatory method to initiate configuration for the target channel adapter or gateway.\nThe standard `IntegrationComponentSpec` implementations for out-of-the-box channel adapters are:\n\n* `JdbcInboundChannelAdapterSpec extends MessageSourceSpec<JdbcInboundChannelAdapterSpec, JdbcPollingChannelAdapter>`\n* `JdbcOutboundChannelAdapterSpec extends MessageHandlerSpec<JdbcOutboundChannelAdapterSpec, JdbcMessageHandler>`\n* `JdbcOutboundGatewaySpec extends MessageHandlerSpec<JdbcOutboundGatewaySpec, JdbcOutboundGateway>`\n* `JdbcStoredProcInboundChannelAdapterSpec extends MessageSourceSpec<JdbcStoredProcInboundChannelAdapterSpec, StoredProcPollingChannelAdapter>`\n* `JdbcStoredProcOutboundChannelAdapterSpec extends MessageHandlerSpec<JdbcStoredProcOutboundChannelAdapterSpec, StoredProcMessageHandler>`\n* `JdbcStoredProcOutboundGatewaySpec extends MessageHandlerSpec<JdbcStoredProcOutboundGatewaySpec, StoredProcOutboundGateway>`\n\nIn addition, the `StoredProcExecutorSpec`, a convenient, builder-like component is provided for a `StoredProcExecutor` creation and configuration.\n\nHere are some examples how `Jdbc` factory can be used for configuration an `IntegrationFlow`:\n\n[source, java]\n----\n@Bean\npublic DataSource h2DataSource() {\n return new EmbeddedDatabaseBuilder()\n .setType(EmbeddedDatabaseType.H2)\n .addScripts(\"classpath:dsl-h2.sql\", \"classpath:h2-stored-procedures.sql\")\n .build();\n}\n\n@Bean\npublic IntegrationFlow outboundFlow(DataSource h2DataSource) {\n return flow -> flow\n .handle(Jdbc.outboundAdapter(h2DataSource,\n \"insert into outbound (id, status, name) values (1, 0, ?)\")\n .preparedStatementSetter((ps, requestMessage) ->\n ps.setObject(1, requestMessage.getPayload()))\n .usePayloadAsParameterSource(false)\n .keysGenerated(false));\n}\n\n@Bean\npublic IntegrationFlow storedProcInboundFlow(DataSource h2DataSource) {\n return IntegrationFlow.from(Jdbc.storedProcInboundAdapter(h2DataSource)\n .expectSingleResult(true)\n .configurerStoredProcExecutor(configurer -> configurer\n .ignoreColumnMetaData(true)\n .isFunction(false)\n .storedProcedureName(\"GET_PRIME_NUMBERS\")\n .procedureParameter(new ProcedureParameter(\"beginRange\", 1, null))\n .procedureParameter(new ProcedureParameter(\"endRange\", 10, null))\n .sqlParameter(new SqlParameter(\"beginRange\", Types.INTEGER))\n .sqlParameter(new SqlParameter(\"endRange\", Types.INTEGER))\n .returningResultSetRowMapper(\"out\", new PrimeMapper())\n ),\n e -> e.poller(p -> p.trigger(new OnlyOnceTrigger())))\n .channel(c -> c.queue(\"storedProcInboundPollerChannel\"))\n .get();\n}\n----\n\nThis Java DSL API can be used as is with the xref:kotlin-dsl.adoc[Kotlin] and xref:groovy-dsl.adoc[Groovy] DSLs.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/dsl.adoc", "title": "dsl", "heading": "dsl", "heading_level": 1, "file_order": 114, "section_index": 0, "content_hash": "2e45874d623a59375211f554c608ee811811f55f899bb3d2768b395ef832e1eb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/dsl.adoc"}}
{"id": "sha256:adf3f6259f12e0b419f1138aee28997601502f02913de76e8aca25c7aa8e9b7e", "content": "[[jdbc-inbound-channel-adapter]]\n\nThe main function of an inbound channel adapter is to execute a SQL `SELECT` query and turn the result set into a message.\nThe message payload is the whole result set (expressed as a `List`), and the types of the items in the list depend on the row-mapping strategy.\nThe default strategy is a generic mapper that returns a `Map` for each row in the query result.\nOptionally, you can change this by adding a reference to a `RowMapper` instance (see the https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jdbc.html[Spring JDBC] documentation for more detailed information about row mapping).\n\nNOTE: If you want to convert rows in the `SELECT` query result to individual messages, you can use a downstream splitter.\n\nThe inbound adapter also requires a reference to either a `JdbcTemplate` instance or a `DataSource`.\n\nAs well as the `SELECT` statement to generate the messages, the adapter also has an `UPDATE` statement that marks the records as processed so that they do not show up in the next poll.\nThe update can be parameterized by the list of IDs from the original select.\nBy default, this is done through a naming convention (a column in the input result set called `id` is translated into a list in the parameter map for the update called `id`).\nThe following example defines an inbound channel adapter with an update query and a `DataSource` reference.\n\n[source,xml]\n----\n<int-jdbc:inbound-channel-adapter query=\"select * from item where status=2\"\n channel=\"target\" data-source=\"dataSource\"\n update=\"update item set status=10 where id in (:id)\" />\n----\n\nNOTE: The parameters in the update query are specified with a colon (`:`) prefix to the name of a parameter (which, in the preceding example, is an expression to be applied to each of the rows in the polled result set).\nThis is a standard feature of the named parameter JDBC support in Spring JDBC, combined with a convention (projection onto the polled result list) adopted in Spring Integration.\nThe underlying Spring JDBC features limit the available expressions, (for example, most special characters other than a period are disallowed), but since the target is usually a list of objects, (possibly a list of one) that are addressable by bean paths this is not unduly restrictive.\n\nTo change the parameter generation strategy, you can inject a `SqlParameterSourceFactory` into the adapter to override the default behavior (the adapter has a `sql-parameter-source-factory` attribute).\nSpring Integration provides `ExpressionEvaluatingSqlParameterSourceFactory`, which creates a SpEL-based parameter source, with the results of the query as the `#root` object.\n(If `update-per-row` is true, the root object is the row).\nIf the same parameter name appears multiple times in the update query, it is evaluated only once, and its result is cached.\n\nYou can also use a parameter source for the select query.\nIn this case, since there is no \"`result`\" object to evaluate against, a single parameter source is used each time (rather than using a parameter source factory).\nStarting with version 4.0, you can use Spring to create a SpEL-based parameter source, as the following example shows:\n\n[source,xml]\n----\n<int-jdbc:inbound-channel-adapter query=\"select * from item where status=:status\"\n\tchannel=\"target\" data-source=\"dataSource\"\n\tselect-sql-parameter-source=\"parameterSource\" />\n\n<bean id=\"parameterSource\" factory-bean=\"parameterSourceFactory\"\n factory-method=\"createParameterSourceNoCache\">\n\t<constructor-arg value=\"\" />\n</bean>\n\n<bean id=\"parameterSourceFactory\"\n class=\"o.s.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory\">\n\t<property name=\"parameterExpressions\">\n <map>\n <entry key=\"status\" value=\"@statusBean.which()\" />\n </map>\n\t</property>\n</bean>\n\n<bean id=\"statusBean\" class=\"foo.StatusDetermination\" />\n----\n\nThe `value` in each parameter expression can be any valid SpEL expression.\nThe `#root` object for the expression evaluation is the constructor argument defined on the `parameterSource` bean.\nIt is static for all evaluations (in the preceding example, an empty `String`).\n\nStarting with version 5.0, you can supply `ExpressionEvaluatingSqlParameterSourceFactory` with `sqlParameterTypes` to specify the target SQL type for the particular parameter.\n\nThe following example provides SQL types for the parameters being used in the query:\n\n[source,xml]\n----\n<int-jdbc:inbound-channel-adapter query=\"select * from item where status=:status\"\n channel=\"target\" data-source=\"dataSource\"\n select-sql-parameter-source=\"parameterSource\" />\n\n<bean id=\"parameterSource\" factory-bean=\"parameterSourceFactory\"\n factory-method=\"createParameterSourceNoCache\">\n <constructor-arg value=\"\" />\n</bean>\n\n<bean id=\"parameterSourceFactory\"\n class=\"o.s.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory\">\n <property name=\"sqlParameterTypes\">\n <map>\n <entry key=\"status\" value=\"#{ T(java.sql.Types).BINARY}\" />\n </map>\n </property>\n</bean>\n----\n\nIMPORTANT: Use the `createParameterSourceNoCache` factory method.\nOtherwise, the parameter source caches the result of the evaluation.\nAlso note that, because caching is disabled, if the same parameter name appears in the select query multiple times, it is re-evaluated for each occurrence.\n\n[[jdbc-polling-transactions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/inbound-channel-adapter.adoc", "title": "inbound-channel-adapter", "heading": "inbound-channel-adapter", "heading_level": 1, "file_order": 115, "section_index": 0, "content_hash": "adf3f6259f12e0b419f1138aee28997601502f02913de76e8aca25c7aa8e9b7e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/inbound-channel-adapter.adoc"}}
{"id": "sha256:8117dea858c28997380325db5db873aaf73a357711756e5f84f97bf52fce084f", "content": "The inbound adapter accepts a regular Spring Integration poller as a child element.\nConsequently, the frequency of the polling can be controlled (among other uses).\nAn important feature of the poller for JDBC usage is the option to wrap the poll operation in a transaction, as the following example shows:\n\n[source,xml]\n----\n<int-jdbc:inbound-channel-adapter query=\"...\"\n channel=\"target\" data-source=\"dataSource\" update=\"...\">\n <int:poller fixed-rate=\"1000\">\n <int:transactional/>\n </int:poller>\n</int-jdbc:inbound-channel-adapter>\n----\n\nNOTE: If you do not explicitly specify a poller, a default value is used.\nAs is normal with Spring Integration, it can be defined as a top-level bean).\n\nIn the preceding example, the database is polled every 1000 milliseconds (or once a second), and the update and select queries are both executed in the same transaction.\nThe transaction manager configuration is not shown.\nHowever, as long as it is aware of the data source, the poll is transactional.\nA common use case is for the downstream channels to be direct channels (the default), so that the endpoints are invoked in the same thread and, hence, the same transaction.\nThat way, if any of them fail, the transaction rolls back and the input data is reverted to its original state.\n\n[[jdbc-max-rows-versus-max-messages-per-poll]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/inbound-channel-adapter.adoc", "title": "inbound-channel-adapter", "heading": "Polling and Transactions", "heading_level": 2, "file_order": 115, "section_index": 1, "content_hash": "8117dea858c28997380325db5db873aaf73a357711756e5f84f97bf52fce084f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/inbound-channel-adapter.adoc"}}
{"id": "sha256:df6c3371083d96da9601bb8a625eaa68e28a758b31d65fe6d90a867a4da63243", "content": "The JDBC inbound channel adapter defines an attribute called `max-rows`.\nWhen you specify the adapter's poller, you can also define a property called `max-messages-per-poll`.\nWhile these two attributes look similar, their meaning is quite different.\n\n`max-messages-per-poll` specifies the number of times the query is executed per polling interval, whereas `max-rows` specifies the number of rows returned for each execution.\n\nUnder normal circumstances, you would likely not want to set the poller's `max-messages-per-poll` property when you use the JDBC inbound channel adapter.\nIts default value is `1`, which means that the JDBC inbound channel adapter's https://docs.spring.io/spring-integration/api/org/springframework/integration/jdbc/JdbcPollingChannelAdapter.html#receive()[`receive()`] method is executed exactly once for each poll interval.\n\nSetting the `max-messages-per-poll` attribute to a larger value means that the query is executed that many times back to back.\nFor more information regarding the `max-messages-per-poll` attribute, see xref:channel-adapter.adoc#channel-adapter-namespace-inbound[Configuring An Inbound Channel Adapter].\n\nIn contrast, the `max-rows` attribute, if greater than `0`, specifies the maximum number of rows to be used from the query result set created by the `receive()` method.\nIf the attribute is set to `0`, all rows are included in the resulting message.\nThe attribute defaults to `0`.\n\nNOTE: It is recommended to use result set limiting via vendor-specific query options, for example, MySQL `LIMIT` or SQL Server `TOP` or Oracle's `ROWNUM`.\nSee the particular vendor documentation for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/inbound-channel-adapter.adoc", "title": "inbound-channel-adapter", "heading": "`max-rows` Versus `max-messages-per-poll`", "heading_level": 2, "file_order": 115, "section_index": 2, "content_hash": "df6c3371083d96da9601bb8a625eaa68e28a758b31d65fe6d90a867a4da63243", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/inbound-channel-adapter.adoc"}}
{"id": "sha256:8b0bc8585cffdff045fd43c854ccdf723ded126550a5f25a629700911e77841c", "content": "[[jdbc-lock-registry]]\n\nVersion 4.3 introduced the `JdbcLockRegistry`.\nCertain components (for example, aggregator and resequencer) use a lock obtained from a `LockRegistry` instance to ensure that only one thread manipulates a group at a time.\nThe `DefaultLockRegistry` performs this function within a single component.\nYou can now configure an external lock registry on these components.\nWhen used with a shared `MessageGroupStore`, you can use the `JdbcLockRegistry` to provide this functionality across multiple application instances, such that only one instance can manipulate the group at a time.\n\nWhen a lock is released by a local thread, another local thread can generally acquire the lock immediately.\nIf a lock is released by a thread that uses a different registry instance, it can take up to 100ms to acquire the lock.\n\nThe `JdbcLockRegistry` is based on the `LockRepository` abstraction, which has a `DefaultLockRepository` implementation.\nThe database schema scripts are located in the `org.springframework.integration.jdbc` package, which is divided for the particular RDBMS vendors.\nFor example, the following listing shows the H2 DDL for the lock table:\n\n[source,sql]\n----\nCREATE TABLE INT_LOCK (\n\tLOCK_KEY CHAR(36) NOT NULL,\n\tREGION VARCHAR(100) NOT NULL,\n\tCLIENT_ID CHAR(36),\n\tCREATED_DATE TIMESTAMP NOT NULL,\n\tEXPIRED_AFTER TIMESTAMP NOT NULL,\n\tconstraint INT_LOCK_PK primary key (LOCK_KEY, REGION)\n);\n----\n\nThe `INT_` can be changed according to the target database design requirements.\nTherefore, you must use `prefix` property on the `DefaultLockRepository` bean definition.\n\nSometimes, one application has moved to such a state that it cannot release the distributed lock and remove the particular record in the database.\nFor this purpose, such deadlocks can be expired by the other application on the next locking invocation.\nThe `timeToLive` (TTL) option on the `DefaultLockRepository` is provided for this purpose.\nYou may also want to specify `CLIENT_ID` for the locks stored for a given `DefaultLockRepository` instance.\nIf so, you can specify the `id` to be associated with the `DefaultLockRepository` as a constructor parameter.\n\nStarting with version 5.1.8, the `JdbcLockRegistry` can be configured with the `idleBetweenTries` - a `Duration` to sleep between lock record insert/update executions.\nBy default, it is `100` milliseconds and in some environments non-leaders pollute connections with data source too often.\n\nStarting with version 5.4, the `RenewableLockRegistry` interface has been introduced and added to `JdbcLockRegistry`.\nThe `renewLock()` method must be called during a locked process in case of the locked process would be longer than time to live of the lock.\nSo the time to live can be highly reduced, and deployments can retake a lost lock quickly.\n\nNOTE: The lock renewal can be done only if the lock is held by the current thread.\n\nStarting with version 5.5.6, the `JdbcLockRegistry` is support automatically clean-up cache for JdbcLock in `JdbcLockRegistry.locks` via `JdbcLockRegistry.setCacheCapacity()`.\nSee its Javadocs for more information.\n\nStarting with version 6.0, the `DefaultLockRepository` can be supplied with a `PlatformTransactionManager` instead of relying on the primary bean from the application context.\n\nStarting with version 6.1, the `DefaultLockRepository` can be configured for custom `insert`, `update` and `renew` queries.\nFor this purpose the respective setters and getters are exposed.\nFor example, an insert query for a PostgreSQL hint can be configured like this:\n\n[source,java]\n----\nlockRepository.setInsertQuery(lockRepository.getInsertQuery() + \" ON CONFLICT DO NOTHING\");\n----\n\nStarting with version 6.4, the `LockRepository.delete()` method return the result of removing ownership of a distributed lock.\nAnd the `JdbcLockRegistry.JdbcLock.unlock()` method throws `ConcurrentModificationException` if the ownership of the lock is expired.\n\nStarting with version 7.0, the `JdbcLock` implements `DistributedLock` interface to support the feature of customized time-to-live (TTL) for the lock status data.\nA `JdbcLock` can now be acquired using the `lock(Duration ttl)` or `tryLock(long time, TimeUnit unit, Duration ttl)` method, with a specified time-to-live (TTL) value.\nThe `JdbcLockRegistry` now provides new `renewLock(Object lockKey, Duration ttl)` method, allowing you to renew the lock with a custom time-to-live value.\nThe default time-to-live for all `JdbcLock` instances stored in the same `JdbcLockRegistry` can now be set by the new constructor `JdbcLockRegistry(LockRepository client, Duration expireAfter)`.\nThe APIs of `LockRepository` and `DefaultLockRepository` are also modified to support the feature.\n[IMPORTANT]\n====\nIf you're already using an earlier version of `JdbcLockRegistry` or `DefaultLockRepository`, please execute the necessary DDL to modify the `INT_LOCK` table before upgrading to this version.\n\nHere is an example of the Postgres DDL for adding the new column to the lock table:\n[source,sql]\n----\nALTER TABLE INT_LOCK ADD EXPIRED_AFTER TIMESTAMP NOT NULL;\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/lock-registry.adoc", "title": "lock-registry", "heading": "lock-registry", "heading_level": 1, "file_order": 116, "section_index": 0, "content_hash": "8b0bc8585cffdff045fd43c854ccdf723ded126550a5f25a629700911e77841c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/lock-registry.adoc"}}
{"id": "sha256:df1b791b283e0f530861bc3ce89ddcc968fded79c885f423c074c7e5eb67f6f9", "content": "[[jdbc-channel-message-store-json]]\n\nVersion 7.0 introduced JSON serialization support for `JdbcChannelMessageStore`.\nBy default, Spring Integration uses Java serialization to store messages in the database.\nThe new JSON serialization option provides an alternative serialization mechanism.\n\n[IMPORTANT]\n====\n**Security Consideration:** JSON serialization stores message content as text in the database, which may expose sensitive data.\nEnsure proper database access controls, encryption at rest, and consider your organization's data protection requirements before using JSON serialization in production environments.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store-json.adoc", "title": "message-store-json", "heading": "message-store-json", "heading_level": 1, "file_order": 117, "section_index": 0, "content_hash": "df1b791b283e0f530861bc3ce89ddcc968fded79c885f423c074c7e5eb67f6f9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store-json.adoc"}}
{"id": "sha256:c566c772623703e646f25127edcd5e958e7e891e177bf6e394821a8a9216129a", "content": "Two components are available for JSON (de)serialization:\n\n* `JsonChannelMessageStorePreparedStatementSetter` - Serializes messages to JSON\n* `JsonMessageRowMapper` - Deserializes messages from JSON\n\n[source,java]\n----\n@Bean\npublic JdbcChannelMessageStore messageStore(DataSource dataSource) {\n JdbcChannelMessageStore store = new JdbcChannelMessageStore(dataSource);\n store.setChannelMessageStoreQueryProvider(\n new PostgresChannelMessageStoreQueryProvider());\n\n // Enable JSON serialization\n store.setPreparedStatementSetter(\n new JsonChannelMessageStorePreparedStatementSetter());\n store.setMessageRowMapper(\n new JsonMessageRowMapper(\"com.example\"));\n\n return store;\n}\n----\n\nThe string parameter (`\"com.example\"`) specifies additional trusted packages for deserialization.\nThese packages are appended to the default trusted packages (see <<trusted-packages>> section).\nOnly classes from trusted packages can be deserialized for security.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store-json.adoc", "title": "message-store-json", "heading": "Configuration", "heading_level": 2, "file_order": 117, "section_index": 1, "content_hash": "c566c772623703e646f25127edcd5e958e7e891e177bf6e394821a8a9216129a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store-json.adoc"}}
{"id": "sha256:9c9e7ac5fd5f719e07c310ad8339a115033a21c185a80fa6b3e79fe327b52710", "content": "[IMPORTANT]\n====\nJSON serialization **requires modifying the database schema**.\nThe default schema with `BLOB/BYTEA` column types cannot be used for JSON serialization.\n====\n\nThe `MESSAGE_CONTENT` column must be changed to a text-based type that can store JSON.\n\n[tabs]\n======\nPostgreSQL::\n+\nFor PostgreSQL, the `JSONB` type can be used.\n+\n[source,sql]\n----\n-- JSONB (enables JSON queries)\nALTER TABLE INT_CHANNEL_MESSAGE\nALTER COLUMN MESSAGE_CONTENT TYPE JSONB\nUSING MESSAGE_CONTENT::text::jsonb;\n----\n\nMySQL::\n+\nFor MySQL, the `JSON` type can be used.\n+\n[source,sql]\n----\n-- JSON type (enables JSON functions)\nALTER TABLE INT_CHANNEL_MESSAGE\nMODIFY COLUMN MESSAGE_CONTENT JSON;\n----\n\nH2::\n+\nFor H2 database, the `CLOB` type can be used.\n+\n[source,sql]\n----\nALTER TABLE INT_CHANNEL_MESSAGE\nALTER COLUMN MESSAGE_CONTENT CLOB;\n----\n\nOther Databases::\n+\nFor any database that supports large text columns (CLOB, TEXT, etc.), the `MESSAGE_CONTENT` column can be modified to an appropriate text type.\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store-json.adoc", "title": "message-store-json", "heading": "Database Schema Modification", "heading_level": 2, "file_order": 117, "section_index": 2, "content_hash": "9c9e7ac5fd5f719e07c310ad8339a115033a21c185a80fa6b3e79fe327b52710", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store-json.adoc"}}
{"id": "sha256:3dde3f6cd1502744d651472f93bb497f32760cce5d74bcb748dc0fb860c1faca", "content": "The following examples demonstrate how to create a dedicated table for JSON-based message storage.\n\n[tabs]\n======\nPostgreSQL::\n+\n[source,sql]\n----\nCREATE TABLE JSON_CHANNEL_MESSAGE (\n MESSAGE_ID CHAR(36) NOT NULL,\n GROUP_KEY CHAR(36) NOT NULL,\n CREATED_DATE BIGINT NOT NULL,\n MESSAGE_PRIORITY BIGINT,\n MESSAGE_SEQUENCE BIGINT NOT NULL DEFAULT nextval('JSON_MESSAGE_SEQ'),\n MESSAGE_CONTENT JSONB, -- JSON message content\n REGION VARCHAR(100) NOT NULL,\n CONSTRAINT JSON_CHANNEL_MESSAGE_PK\n PRIMARY KEY (REGION, GROUP_KEY, CREATED_DATE, MESSAGE_SEQUENCE)\n);\n----\n\nMySQL::\n+\n[source,sql]\n----\nCREATE TABLE JSON_CHANNEL_MESSAGE (\n MESSAGE_ID CHAR(36) NOT NULL,\n GROUP_KEY CHAR(36) NOT NULL,\n CREATED_DATE BIGINT NOT NULL,\n MESSAGE_PRIORITY BIGINT,\n MESSAGE_SEQUENCE BIGINT NOT NULL AUTO_INCREMENT UNIQUE,\n MESSAGE_CONTENT JSON, -- JSON message content\n REGION VARCHAR(100) NOT NULL,\n CONSTRAINT JSON_CHANNEL_MESSAGE_PK\n PRIMARY KEY (REGION, GROUP_KEY, CREATED_DATE, MESSAGE_SEQUENCE)\n);\n----\n\nH2::\n+\n[source,sql]\n----\nCREATE TABLE JSON_CHANNEL_MESSAGE (\n MESSAGE_ID CHAR(36) NOT NULL,\n GROUP_KEY CHAR(36) NOT NULL,\n CREATED_DATE BIGINT NOT NULL,\n MESSAGE_PRIORITY BIGINT,\n MESSAGE_SEQUENCE BIGINT NOT NULL DEFAULT NEXT VALUE FOR JSON_MESSAGE_SEQ,\n MESSAGE_CONTENT CLOB, -- JSON message content\n REGION VARCHAR(100) NOT NULL,\n CONSTRAINT JSON_CHANNEL_MESSAGE_PK\n PRIMARY KEY (REGION, GROUP_KEY, CREATED_DATE, MESSAGE_SEQUENCE)\n);\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store-json.adoc", "title": "message-store-json", "heading": "Example Schema for JSON Serialization", "heading_level": 2, "file_order": 117, "section_index": 3, "content_hash": "3dde3f6cd1502744d651472f93bb497f32760cce5d74bcb748dc0fb860c1faca", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store-json.adoc"}}
{"id": "sha256:e9252755b48b9275f21fe5ac1c10d5c3998c82ed5731242b953906aca8b4e5fc", "content": "When using Jackson-based serialization, messages are stored with the following JSON structure using Jackson's polymorphic type handling:\n\n[source,json]\n----\n{\n \"@class\": \"org.springframework.messaging.support.GenericMessage\",\n \"payload\": {\n \"@class\": \"com.example.OrderMessage\",\n \"orderId\": \"ORDER-12345\",\n \"amount\": 1299.99\n },\n \"headers\": {\n \"@class\": \"java.util.HashMap\",\n \"priority\": [\"java.lang.String\", \"HIGH\"],\n \"id\": [\"java.util.UUID\", \"a1b2c3d4-...\"],\n \"timestamp\": [\"java.lang.Long\", 1234567890]\n }\n}\n----\n\nThe `@class` properties provide type information necessary for proper deserialization of polymorphic types.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store-json.adoc", "title": "message-store-json", "heading": "JSON Structure", "heading_level": 2, "file_order": 117, "section_index": 4, "content_hash": "e9252755b48b9275f21fe5ac1c10d5c3998c82ed5731242b953906aca8b4e5fc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store-json.adoc"}}
{"id": "sha256:5d5f36a86507caf2adb1b055e556ae125fdf010a70e69cce0b1d6fcc0c5dd64a", "content": "If native JSON column types (PostgreSQL JSONB or MySQL JSON) are used, message content can be queried directly.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store-json.adoc", "title": "message-store-json", "heading": "Querying JSON Content (Optional)", "heading_level": 2, "file_order": 117, "section_index": 5, "content_hash": "5d5f36a86507caf2adb1b055e556ae125fdf010a70e69cce0b1d6fcc0c5dd64a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store-json.adoc"}}
{"id": "sha256:61ed5ad4860991d35b7c3f2fdc66d54fcfe0f54953ef8140d6a678c00519b372", "content": "[source,sql]\n----\n-- Find messages by payload field\nSELECT * FROM JSON_CHANNEL_MESSAGE\nWHERE MESSAGE_CONTENT @> '{\"payload\": {\"orderId\": \"ORDER-12345\"}}';\n\n-- Find high-priority messages\nSELECT * FROM JSON_CHANNEL_MESSAGE\nWHERE MESSAGE_CONTENT -> 'headers' @> '{\"priority\": [\"java.lang.String\", \"HIGH\"]}';\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store-json.adoc", "title": "message-store-json", "heading": "PostgreSQL JSONB Queries", "heading_level": 3, "file_order": 117, "section_index": 6, "content_hash": "61ed5ad4860991d35b7c3f2fdc66d54fcfe0f54953ef8140d6a678c00519b372", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store-json.adoc"}}
{"id": "sha256:0f156a04d1a8cafabb52b61a8873013d429ce95d048445edb9c80a8574e84d1a", "content": "[source,sql]\n----\n-- Find messages by payload field\nSELECT * FROM JSON_CHANNEL_MESSAGE\nWHERE JSON_EXTRACT(MESSAGE_CONTENT, '$.payload.orderId') = 'ORDER-12345';\n\n-- Find high-priority messages\nSELECT * FROM JSON_CHANNEL_MESSAGE\nWHERE JSON_EXTRACT(MESSAGE_CONTENT, '$.headers.priority[1]') = 'HIGH';\n----\n\n[NOTE]\n====\nIf `TEXT` or `CLOB` column types are used, these JSON-specific queries are not available.\nHowever, JSON serialization still works for storage and retrieval through Spring Integration.\n====\n\n[[trusted-packages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store-json.adoc", "title": "message-store-json", "heading": "MySQL JSON Functions", "heading_level": 3, "file_order": 117, "section_index": 7, "content_hash": "0f156a04d1a8cafabb52b61a8873013d429ce95d048445edb9c80a8574e84d1a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store-json.adoc"}}
{"id": "sha256:54d52c0c3019e5d049bbd71d57e372a0a5225e7a24de1fbc55cc20a826ee5c75", "content": "The `JacksonMessagingUtils.messagingAwareMapper()` validates all deserialized classes against a trusted package list to prevent security vulnerabilities.\n\nDefault trusted packages include:\n- `java.util`\n- `java.lang`\n- `org.springframework.messaging.support`\n- `org.springframework.integration.support`\n- `org.springframework.integration.message`\n- `org.springframework.integration.store`\n- `org.springframework.integration.history`\n- `org.springframework.integration.handler`\n\nAdditional packages can be specified in the constructor and are appended to this list:\n\n[source,java]\n----\nnew JsonMessageRowMapper(\"com.example.orders\", \"com.example.payments\")\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store-json.adoc", "title": "message-store-json", "heading": "Trusted Packages", "heading_level": 2, "file_order": 117, "section_index": 8, "content_hash": "54d52c0c3019e5d049bbd71d57e372a0a5225e7a24de1fbc55cc20a826ee5c75", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store-json.adoc"}}
{"id": "sha256:6123e73f7f9569859d979a88cf99605b43690d63aa8e3f82be12c97aa9fd787e", "content": "For advanced scenarios, a custom `JsonObjectMapper` can be provided:\n\n[source,java]\n----\nimport org.springframework.integration.support.json.JacksonJsonObjectMapper;\nimport org.springframework.integration.support.json.JacksonMessagingUtils;\nimport tools.jackson.databind.ObjectMapper;\nimport tools.jackson.databind.SerializationFeature;\n\n@Bean\npublic JdbcChannelMessageStore messageStore(DataSource dataSource) {\n ObjectMapper customMapper = JacksonMessagingUtils.messagingAwareMapper(\"com.example\");\n customMapper.enable(SerializationFeature.INDENT_OUTPUT);\n customMapper.registerModule(new CustomModule());\n\n JacksonJsonObjectMapper jsonObjectMapper = new JacksonJsonObjectMapper(customMapper);\n\n JdbcChannelMessageStore store = new JdbcChannelMessageStore(dataSource);\n store.setPreparedStatementSetter(\n new JsonChannelMessageStorePreparedStatementSetter(jsonObjectMapper));\n store.setMessageRowMapper(\n new JsonMessageRowMapper(jsonObjectMapper));\n\n return store;\n}\n----\n\n[IMPORTANT]\n====\nThe custom `JsonObjectMapper` should be configured appropriately for Spring Integration message serialization.\nIt is recommended to start with `JacksonMessagingUtils.messagingAwareMapper()` and customize from there.\nThe same configuration must be used in both `JsonChannelMessageStorePreparedStatementSetter` and `JsonMessageRowMapper` for consistent serialization and deserialization.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store-json.adoc", "title": "message-store-json", "heading": "Custom JsonObjectMapper", "heading_level": 2, "file_order": 117, "section_index": 9, "content_hash": "6123e73f7f9569859d979a88cf99605b43690d63aa8e3f82be12c97aa9fd787e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store-json.adoc"}}
{"id": "sha256:7437fa84d1bebd8d1ffb3ed9aae259c2b328edca26a89342fdf63cedc2c879a3", "content": "[[jdbc-message-store]]\n\nSpring Integration provides two JDBC-specific message store implementations.\nThe `JdbcMessageStore` is suitable for use with aggregators and the claim check pattern.\nThe `JdbcChannelMessageStore` implementation provides a more targeted and scalable implementation specifically for message channel.\n\nNote that you can use a `JdbcMessageStore` to back a message channel, `JdbcChannelMessageStore` is optimized for that purpose.\n\nIMPORTANT: Starting with versions 5.0.11, 5.1.2, the indexes for the `JdbcChannelMessageStore` have been optimized.\nIf you have large message groups in such a store, you may wish to alter the indexes.\nFurthermore, the index for `PriorityChannel` is commented out because it is not needed unless you are using such channels backed by JDBC.\n\nNOTE: When using the `OracleChannelMessageStoreQueryProvider`, the priority channel index **must** be added because it is included in a hint in the query.\n\n[[jdbc-db-init]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store.adoc", "title": "message-store", "heading": "message-store", "heading_level": 1, "file_order": 118, "section_index": 0, "content_hash": "7437fa84d1bebd8d1ffb3ed9aae259c2b328edca26a89342fdf63cedc2c879a3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store.adoc"}}
{"id": "sha256:43364fc90ea114dd073e883c6aa7560e3f1b9fa8b114774157d94ed2f72f0d3f", "content": "Before starting to use JDBC message store components, you should provision a target database with the appropriate objects.\n\nSpring Integration ships with some sample scripts that can be used to initialize a database.\nIn the `spring-integration-jdbc` JAR file, you can find scripts in the `org.springframework.integration.jdbc` package.\nIt provides an example creation and an example drop script for a range of common database platforms.\nA common way to use these scripts is to reference them in a https://docs.spring.io/spring-framework/reference/data-access/jdbc/initializing-datasource.html[Spring JDBC data source initializer].\nNote that the scripts are provided as samples and as specifications of the required table and column names.\nYou may find that you need to enhance them for production use, for example, by adding index declarations.\n\nStarting with version 6.2, the `JdbcMessageStore`, `JdbcChannelMessageStore`, `JdbcMetadataStore`, and `DefaultLockRepository` implement `SmartLifecycle` and perform a`SELECT COUNT` query, on their respective tables, in the `start()` method to ensure that the required table (according to the provided prefix) is present in the target database.\nIf the required table does not exist, the application context fails to start.\nThe check can be disabled via `setCheckDatabaseOnStart(false)`.\n\n[[jdbc-message-store-generic]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store.adoc", "title": "message-store", "heading": "Initializing the Database", "heading_level": 2, "file_order": 118, "section_index": 1, "content_hash": "43364fc90ea114dd073e883c6aa7560e3f1b9fa8b114774157d94ed2f72f0d3f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store.adoc"}}
{"id": "sha256:abcda8323b4987eda8b94b0f1c4325b016cee8eff6a7d48d743f19a133764c21", "content": "The JDBC module provides an implementation of the Spring Integration `MessageStore` (important in the claim check pattern) and `MessageGroupStore` (important in stateful patterns such as an aggregator) backed by a database.\nBoth interfaces are implemented by the `JdbcMessageStore`, and there is support for configuring store instances in XML, as the following example shows:\n\n[source,xml]\n----\n<int-jdbc:message-store id=\"messageStore\" data-source=\"dataSource\"/>\n----\n\nYou can specify a `JdbcTemplate` instead of a `DataSource`.\n\nThe following example shows some other optional attributes:\n\n[source,xml]\n----\n<int-jdbc:message-store id=\"messageStore\" data-source=\"dataSource\" table-prefix=\"MY_INT_\"/>\n----\n\nIn the preceding example, we have specified a prefix for the table names in the queries generated by the store.\nThe table name prefix defaults to `INT_`.\n\n[[jdbc-message-store-channels]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store.adoc", "title": "message-store", "heading": "The Generic JDBC Message Store", "heading_level": 2, "file_order": 118, "section_index": 2, "content_hash": "abcda8323b4987eda8b94b0f1c4325b016cee8eff6a7d48d743f19a133764c21", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store.adoc"}}
{"id": "sha256:2e732307210154b7f19dc29dab99ccaa124731c9e0c5f9dbaf059072f37bbe04", "content": "If you intend to back message channels with JDBC, we recommend using the `JdbcChannelMessageStore` implementation.\nIt works only in conjunction with Message Channels.\n\n[[supported-databases]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store.adoc", "title": "message-store", "heading": "Backing Message Channels", "heading_level": 2, "file_order": 118, "section_index": 3, "content_hash": "2e732307210154b7f19dc29dab99ccaa124731c9e0c5f9dbaf059072f37bbe04", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store.adoc"}}
{"id": "sha256:30d4c7c16f18a582479c24e5ffec3110b31b26e546662d2b618af5e8f6c61e0f", "content": "The `JdbcChannelMessageStore` uses database-specific SQL queries to retrieve messages from the database.\nTherefore, you must set the `ChannelMessageStoreQueryProvider` property on the `JdbcChannelMessageStore`.\nThis `channelMessageStoreQueryProvider` provides the SQL queries for the particular database you specify.\nSpring Integration provides support for the following relational databases:\n\n* PostgreSQL\n* HSQLDB\n* MySQL\n* Oracle\n* Derby\n* H2\n* SqlServer\n* Sybase\n* DB2\n\nIf your database is not listed, you can implement the `ChannelMessageStoreQueryProvider` interface and provide your own custom queries.\n\nVersion 4.0 added the `MESSAGE_SEQUENCE` column to the table to ensure first-in-first-out (FIFO) queueing even when messages are stored in the same millisecond.\n\nStarting with version 6.2, `ChannelMessageStoreQueryProvider` exposes a `isSingleStatementForPoll` flag, where the `PostgresChannelMessageStoreQueryProvider` returns `true` and its queries for polls are now based on a single `DELETE...RETURNING` statement.\nThe `JdbcChannelMessageStore` consults with the `isSingleStatementForPoll` option and skips a separate `DELETE` statement if only a single poll statement is supported.\n\n[[custom-message-insertion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store.adoc", "title": "message-store", "heading": "Supported Databases", "heading_level": 3, "file_order": 118, "section_index": 4, "content_hash": "30d4c7c16f18a582479c24e5ffec3110b31b26e546662d2b618af5e8f6c61e0f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store.adoc"}}
{"id": "sha256:f955074259dd9df05ac40cc0e7ea796a775fc11294ace657821785ef5fb79dbd", "content": "Since version 5.0, by overloading the `ChannelMessageStorePreparedStatementSetter` class, you can provide a custom implementation for message insertion in the `JdbcChannelMessageStore`.\nYou can use it to set different columns or change the table structure or serialization strategy.\nFor example, instead of default serialization to `byte[]`, you can store its structure as a JSON string.\n\nThe following example uses the default implementation of `setValues` to store common columns and overrides the behavior to store the message payload as a `varchar`:\n\n[source,java]\n----\npublic class JsonPreparedStatementSetter extends ChannelMessageStorePreparedStatementSetter {\n\n @Override\n public void setValues(PreparedStatement preparedStatement, Message<?> requestMessage,\n Object groupId, String region, boolean priorityEnabled) throws SQLException {\n // Populate common columns\n super.setValues(preparedStatement, requestMessage, groupId, region, priorityEnabled);\n // Store message payload as varchar\n preparedStatement.setString(6, requestMessage.getPayload().toString());\n }\n}\n----\n\n[IMPORTANT]\n====\nGenerally, we do not recommend using a relational database for queuing.\nInstead, if possible, consider using either JMS- or AMQP-backed channels instead.\nFor further reference, see the following resource:\n\n* https://mikehadlow.blogspot.com/2012/04/database-as-queue-anti-pattern.html[The Database As Queue Anti-Pattern].\n\nIf you are still planning to use your database as a queue, consider using PostgreSQL and its notification mechanism, which is described xref:jdbc/message-store.adoc#postgresql-push[in a subsequent section].\n====\n\n[[concurrent-polling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store.adoc", "title": "message-store", "heading": "Custom Message Insertion", "heading_level": 3, "file_order": 118, "section_index": 5, "content_hash": "f955074259dd9df05ac40cc0e7ea796a775fc11294ace657821785ef5fb79dbd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store.adoc"}}
{"id": "sha256:54b7d47afde288fd1fe14d14d82c2d3194ff135eb106c38d543ebb1af1de5034", "content": "When polling a message channel, you have the option to configure the associated `Poller` with a `TaskExecutor` reference.\n\n[IMPORTANT]\n====\nKeep in mind, though, that if you use a JDBC backed message channel, and you plan to poll the channel and consequently the message store transactional with multiple threads, you should ensure that you use a relational database that supports https://en.wikipedia.org/wiki/Multiversion_concurrency_control[Multiversion Concurrency Control] (MVCC).\nOtherwise, locking may be an issue and the performance, when using multiple threads, may not materialize as expected.\nFor example, Apache Derby is problematic in that regard.\n\nTo achieve better JDBC queue throughput and avoid issues when different threads may poll the same `Message` from the queue, it is *important* to set the `usingIdCache` property of `JdbcChannelMessageStore` to `true` when using databases that do not support MVCC.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<bean id=\"queryProvider\"\n class=\"o.s.i.jdbc.store.channel.PostgresChannelMessageStoreQueryProvider\"/>\n\n<int:transaction-synchronization-factory id=\"syncFactory\">\n <int:after-commit expression=\"@store.removeFromIdCache(headers.id.toString())\" />\n <int:after-rollback expression=\"@store.removeFromIdCache(headers.id.toString())\"/>\n</int:transaction-synchronization-factory>\n\n<task:executor id=\"pool\" pool-size=\"10\"\n queue-capacity=\"10\" rejection-policy=\"CALLER_RUNS\" />\n\n<bean id=\"store\" class=\"o.s.i.jdbc.store.JdbcChannelMessageStore\">\n <property name=\"dataSource\" ref=\"dataSource\"/>\n <property name=\"channelMessageStoreQueryProvider\" ref=\"queryProvider\"/>\n <property name=\"region\" value=\"TX_TIMEOUT\"/>\n <property name=\"usingIdCache\" value=\"true\"/>\n</bean>\n\n<int:channel id=\"inputChannel\">\n <int:queue message-store=\"store\"/>\n</int:channel>\n\n<int:bridge input-channel=\"inputChannel\" output-channel=\"outputChannel\">\n <int:poller fixed-delay=\"500\" receive-timeout=\"500\"\n max-messages-per-poll=\"1\" task-executor=\"pool\">\n <int:transactional propagation=\"REQUIRED\" synchronization-factory=\"syncFactory\"\n isolation=\"READ_COMMITTED\" transaction-manager=\"transactionManager\" />\n </int:poller>\n</int:bridge>\n\n<int:channel id=\"outputChannel\" />\n----\n====\n\n[[priority-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store.adoc", "title": "message-store", "heading": "Concurrent Polling", "heading_level": 3, "file_order": 118, "section_index": 6, "content_hash": "54b7d47afde288fd1fe14d14d82c2d3194ff135eb106c38d543ebb1af1de5034", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store.adoc"}}
{"id": "sha256:0acc1ea62a19cfea084a0b6dff3feb2eb4986ef02fd05d3ae641b2ca9c6cc1e0", "content": "Starting with version 4.0, `JdbcChannelMessageStore` implements `PriorityCapableChannelMessageStore` and provides the `priorityEnabled` option, letting it be used as a `message-store` reference for `priority-queue` instances.\nFor this purpose, the `INT_CHANNEL_MESSAGE` table has a `MESSAGE_PRIORITY` column to store the value of `PRIORITY` message headers.\nIn addition, a new `MESSAGE_SEQUENCE` column lets us achieve a robust first-in-first-out (FIFO) polling mechanism, even when multiple messages are stored with the same priority in the same millisecond.\nMessages are polled (selected) from the database with `order by MESSAGE_PRIORITY DESC NULLS LAST, CREATED_DATE, MESSAGE_SEQUENCE`.\n\nNOTE: We do not recommend using the same `JdbcChannelMessageStore` bean for priority and non-priority queue channels, because the `priorityEnabled` option applies to the entire store and proper FIFO queue semantics are not retained for the queue channel.\nHowever, the same `INT_CHANNEL_MESSAGE` table (and even `region`) can be used for both `JdbcChannelMessageStore` types.\nTo configure that scenario, you can extend one message store bean from the other, as the following example shows:\n\n[source,xml]\n----\n<bean id=\"channelStore\" class=\"o.s.i.jdbc.store.JdbcChannelMessageStore\">\n <property name=\"dataSource\" ref=\"dataSource\"/>\n <property name=\"channelMessageStoreQueryProvider\" ref=\"queryProvider\"/>\n</bean>\n\n<int:channel id=\"queueChannel\">\n <int:queue message-store=\"channelStore\"/>\n</int:channel>\n\n<bean id=\"priorityStore\" parent=\"channelStore\">\n <property name=\"priorityEnabled\" value=\"true\"/>\n</bean>\n\n<int:channel id=\"priorityChannel\">\n <int:priority-queue message-store=\"priorityStore\"/>\n</int:channel>\n----\n\n[[partitioning-a-message-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store.adoc", "title": "message-store", "heading": "Priority Channel", "heading_level": 3, "file_order": 118, "section_index": 7, "content_hash": "0acc1ea62a19cfea084a0b6dff3feb2eb4986ef02fd05d3ae641b2ca9c6cc1e0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store.adoc"}}
{"id": "sha256:3466ca01c7601e7cbf93e9007f24c1b933b2a7f1f122d78b7a149fe062b6997a", "content": "It is common to use a `JdbcMessageStore` as a global store for a group of applications or nodes in the same application.\nTo provide some protection against name clashes and to give control over the database meta-data configuration, the message store lets the tables be partitioned in two ways.\nOne way is to use separate table names by changing the prefix (as xref:jdbc/message-store.adoc#jdbc-message-store-generic[described earlier]).\nThe other way is to specify a `region` name for partitioning data within a single table.\nAn important use case for the second approach is when the `MessageStore` is managing persistent queues that back a Spring Integration Message Channel.\nThe message data for a persistent channel is keyed in the store on the channel name.\nConsequently, if the channel names are not globally unique, the channels can pick up data that is not intended for them.\nTo avoid this danger, you can use the message store `region` to keep data separate for different physical channels that have the same logical name.\n\n[[postgresql-push]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store.adoc", "title": "message-store", "heading": "Partitioning a Message Store", "heading_level": 2, "file_order": 118, "section_index": 8, "content_hash": "3466ca01c7601e7cbf93e9007f24c1b933b2a7f1f122d78b7a149fe062b6997a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store.adoc"}}
{"id": "sha256:da6253d67ccdfd70581e53ee413aad5d46777dbe139c612f3730c6c13085793d", "content": "PostgreSQL offers a listen and notification framework for receiving push notifications upon database table manipulations.\nSpring Integration leverages this mechanism (starting with version 6.0) to allow for receiving push notifications when new messages are added to a `JdbcChannelMessageStore`.\nWhen using this feature, a database trigger must be defined, which can be found as part of the comments of the `schema-postgresql.sql` file which is included in the JDBC module of Spring Integration.\n\nPush notifications are received via the `PostgresChannelMessageTableSubscriber` class which allows its subscribers to receive a callback upon the arrival of new messages for any given `region` and `groupId`.\nThese notifications are received even if a message was appended on a different JVM, but to the same database.\nThe `PostgresSubscribableChannel` implementation uses a `PostgresChannelMessageTableSubscriber.Subscription` contract to pull messages from the store as a reaction for notification from the mentioned `PostgresChannelMessageTableSubscriber` notifications.\n\nFor example, push notifications for `some group` can be received as follows:\n\n[source,java]\n----\n@Bean\npublic JdbcChannelMessageStore messageStore(DataSource dataSource) {\n JdbcChannelMessageStore messageStore = new JdbcChannelMessageStore(dataSource);\n messageStore.setChannelMessageStoreQueryProvider(new PostgresChannelMessageStoreQueryProvider());\n return messageStore;\n}\n\n@Bean\npublic PostgresChannelMessageTableSubscriber subscriber(\n @Value(\"${spring.datasource.url}\") String url,\n @Value(\"${spring.datasource.username}\") String username,\n @Value(\"${spring.datasource.password}\") String password) {\n return new PostgresChannelMessageTableSubscriber(() ->\n DriverManager.getConnection(url, username, password).unwrap(PgConnection.class));\n}\n\n@Bean\npublic PostgresSubscribableChannel channel(\n PostgresChannelMessageTableSubscriber subscriber,\n JdbcChannelMessageStore messageStore) {\n return new PostgresSubscribableChannel(messageStore, \"some group\", subscriber);\n}\n----\n\n*Transaction support*\n\nStarting with version 6.0.5, specifying a `PlatformTransactionManager` on a `PostgresSubscribableChannel` will notify subscribers in a transaction.\nAn exception in a subscriber will cause the transaction to be rolled back and the message to be put back in the message store.\nTransactional support is not activated by default.\n\n*Retries*\n\nStarting with version 6.0.5, a retry policy can be specified by providing a `RetryTemplate` to the `PostgresSubscribableChannel`.\nBy default, no retries are performed.\n\n[IMPORTANT]\n====\nAny active `PostgresChannelMessageTableSubscriber` occupies an exclusive JDBC `Connection` for the duration of its active life cycle.\nIt is therefore important that this connection does not originate from a pooling `DataSource`.\nSuch connection pools do normally expect that issued connections are closed within a predefined timeout window.\n\nFor this need of an exclusive connection, it is also recommended that a JVM only runs a single `PostgresChannelMessageTableSubscriber` which can be used to register any number of subscriptions.\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/message-store.adoc", "title": "message-store", "heading": "PostgreSQL: Receiving Push Notifications", "heading_level": 2, "file_order": 118, "section_index": 9, "content_hash": "da6253d67ccdfd70581e53ee413aad5d46777dbe139c612f3730c6c13085793d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/message-store.adoc"}}
{"id": "sha256:47234990e38e4eb41eb601b0cdfe511a4556954d75ed6e96eb9a279faa9345be", "content": "[[jdbc-metadata-store]]\n\nVersion 5.0 introduced the JDBC `MetadataStore` (see xref:meta-data-store.adoc[Metadata Store]) implementation.\nYou can use the `JdbcMetadataStore` to maintain the metadata state across application restarts.\nThis `MetadataStore` implementation can be used with adapters such as the following:\n\n* xref:feed.adoc#feed-inbound-channel-adapter[Feed inbound channel adapters]\n* xref:file/reading.adoc[File inbound channel adapters]\n* xref:ftp/inbound.adoc[FTP inbound channel adapters]\n* xref:sftp/inbound.adoc[SFTP inbound channel adapters]\n\nTo configure these adapters to use the `JdbcMetadataStore`, declare a Spring bean by using a bean name of `metadataStore`.\nThe Feed inbound channel adapter and the feed inbound channel adapter both automatically pick up and use the declared `JdbcMetadataStore`, as the following example shows:\n\n[source,java]\n----\n@Bean\npublic MetadataStore metadataStore(DataSource dataSource) {\n return new JdbcMetadataStore(dataSource);\n}\n----\n\nThe `org.springframework.integration.jdbc` package has Database schema scripts for several RDMBS vendors.\nFor example, the following listing shows the H2 DDL for the metadata table:\n\n[source,sql]\n----\nCREATE TABLE INT_METADATA_STORE (\n\tMETADATA_KEY VARCHAR(255) NOT NULL,\n\tMETADATA_VALUE VARCHAR(4000),\n\tREGION VARCHAR(100) NOT NULL,\n\tconstraint INT_METADATA_STORE_PK primary key (METADATA_KEY, REGION)\n);\n----\n\nYou can change the `INT_` prefix to match the target database design requirements.\nYou can also configure `JdbcMetadataStore` to use the custom prefix.\n\nThe `JdbcMetadataStore` implements `ConcurrentMetadataStore`, letting it be reliably shared across multiple application instances, where only one instance can store or modify a key's value.\nAll of these operations are atomic, thanks to transaction guarantees.\n\nTransaction management must use `JdbcMetadataStore`.\nInbound channel adapters can be supplied with a reference to the `TransactionManager` in the poller configuration.\nUnlike non-transactional `MetadataStore` implementations, with `JdbcMetadataStore`, the entry appears in the target table only after the transaction commits.\nWhen a rollback occurs, no entries are added to the `INT_METADATA_STORE` table.\n\nSince version 5.0.7, you can configure the `JdbcMetadataStore` with the RDBMS vendor-specific `lockHint` option for lock-based queries on metadata store entries.\nBy default, it is `FOR UPDATE` and can be configured with an empty string if the target database does not support row locking functionality.\nConsult with your vendor for particular and possible hints in the `SELECT` expression for locking rows before updates.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/metadata-store.adoc", "title": "metadata-store", "heading": "metadata-store", "heading_level": 1, "file_order": 119, "section_index": 0, "content_hash": "47234990e38e4eb41eb601b0cdfe511a4556954d75ed6e96eb9a279faa9345be", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/metadata-store.adoc"}}
{"id": "sha256:28880f150965ed06a19609bfbbcbbd1647c7a0568407873b3d46ba8b52e3fb45", "content": "[[jdbc-outbound-channel-adapter]]\n\nThe outbound channel adapter is the inverse of the inbound: its role is to handle a message and use it to execute a SQL query.\nBy default, the message payload and headers are available as input parameters to the query, as the following example shows:\n\n[source,xml]\n----\n<int-jdbc:outbound-channel-adapter\n query=\"insert into items (id, status, name) values (:headers[id], 0, :payload[something])\"\n data-source=\"dataSource\"\n channel=\"input\"/>\n----\n\nIn the preceding example, messages arriving at the channel labelled `input` have a payload of a map with a key of `something`, so the `[]` operator dereferences that value from the map.\nThe headers are also accessed as a map.\n\nNOTE: The parameters in the preceding query are bean property expressions on the incoming message (not SpEL expressions).\nThis behavior is part of the `SqlParameterSource`, which is the default source created by the outbound adapter.\nYou can inject a different `SqlParameterSourceFactory` to get different behavior.\n\nThe outbound adapter requires a reference to either a `DataSource` or a `JdbcTemplate`.\nYou can also inject a `SqlParameterSourceFactory` to control the binding of each incoming message to a query.\nTo make use of `SqlParameterSourceFactory` (especially default `BeanPropertySqlParameterSourceFactory` with its `MapSqlParameterSource`) more smooth, starting with version 6.5, the `JdbcMessageHandler` exposes a `usePayloadAsParameterSource` flag to indicate whether the whole message should be passed as parameter source input.\n\nIf the input channel is a direct channel, the outbound adapter runs its query in the same thread and, therefore, the same transaction (if there is one) as the sender of the message.\n\n[[passing-parameters-by-using-spel-expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "outbound-channel-adapter", "heading_level": 1, "file_order": 120, "section_index": 0, "content_hash": "28880f150965ed06a19609bfbbcbbd1647c7a0568407873b3d46ba8b52e3fb45", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/outbound-channel-adapter.adoc"}}
{"id": "sha256:140dac597ca89ebb622e667ebac5cd29586e46e7fac62032f2e9bb53be8c01b9", "content": "A common requirement for most JDBC channel adapters is to pass parameters as part of SQL queries or stored procedures or functions.\nAs mentioned earlier, these parameters are by default bean property expressions, not SpEL expressions.\nHowever, if you need to pass SpEL expression as parameters, you must explicitly inject a `SqlParameterSourceFactory`.\n\nThe following example uses a `ExpressionEvaluatingSqlParameterSourceFactory` to achieve that requirement:\n\n[source,xml]\n----\n<jdbc:outbound-channel-adapter data-source=\"dataSource\" channel=\"input\"\n query=\"insert into MESSAGES (MESSAGE_ID,PAYLOAD,CREATED_DATE) values (:id, :payload, :createdDate)\"\n sql-parameter-source-factory=\"spelSource\"/>\n\n<bean id=\"spelSource\"\n class=\"o.s.integration.jdbc.ExpressionEvaluatingSqlParameterSourceFactory\">\n <property name=\"parameterExpressions\">\n <map>\n <entry key=\"id\" value=\"headers['id'].toString()\"/>\n <entry key=\"createdDate\" value=\"new java.util.Date()\"/>\n <entry key=\"payload\" value=\"payload\"/>\n </map>\n </property>\n</bean>\n----\n\nFor further information, see xref:jdbc/stored-procedures.adoc#sp-defining-parameter-sources[Defining Parameter Sources].\n\n[[using-the-preparedstatement-callback]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "Passing Parameters by Using SpEL Expressions", "heading_level": 2, "file_order": 120, "section_index": 1, "content_hash": "140dac597ca89ebb622e667ebac5cd29586e46e7fac62032f2e9bb53be8c01b9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/outbound-channel-adapter.adoc"}}
{"id": "sha256:d41e205d7647cc1335e8e58af2d8ea6ceb72d838a528a5ed356869ed422ce944", "content": "Sometimes, the flexibility and loose-coupling of `SqlParameterSourceFactory` does not do what we need for the target `PreparedStatement` or we need to do some low-level JDBC work.\nThe Spring JDBC module provides APIs to configure the execution environment (such as `ConnectionCallback` or `PreparedStatementCreator`) and manipulate parameter values (such as `SqlParameterSource`).\nIt can even access APIs for low-level operations, such as `StatementCallback`.\n\nStarting with Spring Integration 4.2, `MessagePreparedStatementSetter` allows the specification of parameters on the `PreparedStatement` manually, in the `requestMessage` context.\nThis class plays exactly the same role as `PreparedStatementSetter` in the standard Spring JDBC API.\nActually, it is invoked directly from an inline `PreparedStatementSetter` implementation when the `JdbcMessageHandler` invokes `execute` on the `JdbcTemplate`.\n\nThis functional interface option is mutually exclusive with `sqlParameterSourceFactory` and can be used as a more powerful alternative to populate parameters of the `PreparedStatement` from the `requestMessage`.\nFor example, it is useful when we need to store `File` data to the DataBase `BLOB` column in a streaming manner.\nThe following example shows how to do so:\n\n[source,java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"storeFileChannel\")\npublic MessageHandler jdbcMessageHandler(DataSource dataSource) {\n JdbcMessageHandler jdbcMessageHandler = new JdbcMessageHandler(dataSource,\n \"INSERT INTO imagedb (image_name, content, description) VALUES (?, ?, ?)\");\n jdbcMessageHandler.setPreparedStatementSetter((ps, m) -> {\n ps.setString(1, m.getHeaders().get(FileHeaders.FILENAME));\n try (FileInputStream inputStream = new FileInputStream((File) m.getPayload())) {\n ps.setBlob(2, inputStream);\n }\n catch (Exception e) {\n throw new MessageHandlingException(m, e);\n }\n ps.setClob(3, new StringReader(m.getHeaders().get(\"description\", String.class)));\n });\n return jdbcMessageHandler;\n}\n----\n\nFrom the XML configuration perspective, the `prepared-statement-setter` attribute is available on the `<int-jdbc:outbound-channel-adapter>` component.\nIt lets you specify a `MessagePreparedStatementSetter` bean reference.\n\n[[batch-update]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "Using the `PreparedStatement` Callback", "heading_level": 2, "file_order": 120, "section_index": 2, "content_hash": "d41e205d7647cc1335e8e58af2d8ea6ceb72d838a528a5ed356869ed422ce944", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/outbound-channel-adapter.adoc"}}
{"id": "sha256:0d62ac3ad0a995d5ec2b5a0ccbc184b618175add09f6e850efdbd5640e653568", "content": "Starting with version 5.1, the `JdbcMessageHandler` performs a `JdbcOperations.batchUpdate()` if the payload of the request message is an `Iterable` instance.\nEach element of the `Iterable` is wrapped to a `Message` with the headers from the request message if such an element is not a `Message` already.\nIn the case of regular `SqlParameterSourceFactory`-based configuration these messages are used to build an `SqlParameterSource[]` for an argument used in the mentioned `JdbcOperations.batchUpdate()` function.\nWhen a `MessagePreparedStatementSetter` configuration is applied, a `BatchPreparedStatementSetter` variant is used to iterate over those messages for each item and the provided `MessagePreparedStatementSetter` is called against them.\nThe batch update is not supported when `keysGenerated` mode is selected.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "Batch Update", "heading_level": 2, "file_order": 120, "section_index": 3, "content_hash": "0d62ac3ad0a995d5ec2b5a0ccbc184b618175add09f6e850efdbd5640e653568", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/outbound-channel-adapter.adoc"}}
{"id": "sha256:3e6201f3c4ea3b4912715ed04edd7688ed71476a1954ed73a8292d921c305c97", "content": "[[jdbc-outbound-gateway]]\n\nThe outbound gateway is like a combination of the outbound and inbound adapters: Its role is to handle a message and use it to execute a SQL query and then respond with the result by sending it to a reply channel.\nBy default, the message payload and headers are available as input parameters to the query, as the following example shows:\n\n[source,xml]\n----\n<int-jdbc:outbound-gateway\n update=\"insert into mythings (id, status, name) values (:headers[id], 0, :payload[thing])\"\n request-channel=\"input\" reply-channel=\"output\" data-source=\"dataSource\" />\n----\n\nThe result of the preceding example is to insert a record into the `mythings` table and return a message that indicates the number of rows affected (the payload is a map: `{UPDATED=1}`) to the output channel.\n\nIf the update query is an insert with auto-generated keys, you can populate the reply message with the generated keys by adding `keys-generated=\"true\"` to the preceding example (this is not the default because it is not supported by some database platforms).\nThe following example shows the changed configuration:\n\n[source,xml]\n----\n<int-jdbc:outbound-gateway\n update=\"insert into mythings (status, name) values (0, :payload[thing])\"\n request-channel=\"input\" reply-channel=\"output\" data-source=\"dataSource\"\n keys-generated=\"true\"/>\n----\n\nInstead of the update count or the generated keys, you can also provide a select query to execute and generate a reply message from the result (such as the inbound adapter), as the following example shows:\n\n[source,xml]\n----\n<int-jdbc:outbound-gateway\n update=\"insert into foos (id, status, name) values (:headers[id], 0, :payload[foo])\"\n query=\"select * from foos where id=:headers[$id]\"\n request-channel=\"input\" reply-channel=\"output\" data-source=\"dataSource\"/>\n----\n\nSince Spring Integration 2.2, the update SQL query has been no longer mandatory.\nYou can now provide only a select query, by using either the `query` attribute or the `query` element.\nThis is extremely useful if you need to actively retrieve data by using, for example, a generic gateway or a payload enricher.\nThe reply message is then generated from the result (similar to how the inbound adapter works) and passed to the reply channel.\nThe following example show to use the `query` attribute:\n\n[source,xml]\n----\n<int-jdbc:outbound-gateway\n query=\"select * from foos where id=:headers[id]\"\n request-channel=\"input\"\n reply-channel=\"output\"\n data-source=\"dataSource\"/>\n----\n\n[IMPORTANT]\n====\nBy default, the component for the `SELECT` query returns only one (the first) row from the cursor.\nYou can adjust this behavior with the `max-rows` option.\nIf you need to return all the rows from the SELECT, consider specifying `max-rows=\"0\"`.\n====\n\nAs with the channel adapters, you can also provide `SqlParameterSourceFactory` instances for request and reply.\nThe default is the same as for the outbound adapter, so the request message is available as the root of an expression.\nIf `keys-generated=\"true\"`, the root of the expression is the generated keys (a map if there is only one or a list of maps if multivalued).\n\nThe outbound gateway requires a reference to either a `DataSource` or a `JdbcTemplate`.\nIt can also have a `SqlParameterSourceFactory` injected to control the binding of the incoming message to the query.\n\nStarting with the version 4.2, the `request-prepared-statement-setter` attribute is available on the `<int-jdbc:outbound-gateway>` as an alternative to `request-sql-parameter-source-factory`.\nIt lets you specify a `MessagePreparedStatementSetter` bean reference, which implements more sophisticated `PreparedStatement` preparation before its execution.\n\nStarting with the version 6.0, the `JdbcOutboundGateway` returns an empty list result as is instead of converting it to `null` as it was before with the meaning \"no reply\".\nThis caused an extra configuration in applications where handling of empty lists is a part of downstream logic.\nSee xref:splitter.adoc#split-stream-and-flux[Splitter Discard Channel] for a possible empty list handling option.\n\nSee xref:jdbc/outbound-channel-adapter.adoc[Outbound Channel Adapter] for more information about `MessagePreparedStatementSetter`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "outbound-gateway", "heading_level": 1, "file_order": 121, "section_index": 0, "content_hash": "3e6201f3c4ea3b4912715ed04edd7688ed71476a1954ed73a8292d921c305c97", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/outbound-gateway.adoc"}}
{"id": "sha256:ca3d77d8f719df4744cb768f8c08fbe47a20a04f2a356c78b40ad3b7dd47162c", "content": "[[stored-procedures]]\n\nIn certain situations, plain JDBC support is not sufficient.\nMaybe you deal with legacy relational database schemas, or you have complex data processing needs, but, ultimately, you have to use https://en.wikipedia.org/wiki/Stored_procedure[stored procedures] or stored functions.\nSince Spring Integration 2.1, we've provided three components to execute stored procedures or stored functions:\n\n* Stored Procedures Inbound Channel Adapter\n* Stored Procedures Outbound Channel Adapter\n* Stored Procedures Outbound Gateway\n\n[[sp-supported-databases]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/stored-procedures.adoc", "title": "stored-procedures", "heading": "stored-procedures", "heading_level": 1, "file_order": 122, "section_index": 0, "content_hash": "ca3d77d8f719df4744cb768f8c08fbe47a20a04f2a356c78b40ad3b7dd47162c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/stored-procedures.adoc"}}
{"id": "sha256:07611b286b9cf2febd7315ce6e0c25e0b670a683d9f6558ea4cf93062428c257", "content": "In order to enable calls to stored procedures and stored functions, the stored procedure components use the https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCall.html[`org.springframework.jdbc.core.simple.SimpleJdbcCall`] class.\nConsequently, the following databases are fully supported for executing stored procedures:\n\n* Apache Derby\n* DB2\n* MySQL\n* Microsoft SQL Server\n* Oracle\n* PostgreSQL\n* Sybase\n\nIf you want to execute stored functions instead, the following databases are fully supported:\n\n* MySQL\n* Microsoft SQL Server\n* Oracle\n* PostgreSQL\n\n[NOTE]\n=====\nEven though your particular database may not be fully supported, chances are that you can use the stored procedure Spring Integration components quite successfully anyway, provided your RDBMS supports stored procedures or stored functions.\n\nAs a matter of fact, some provided integration tests use the https://www.h2database.com[H2 database].\nNevertheless, it is very important to thoroughly test those usage scenarios.\n=====\n\n[[sp-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/stored-procedures.adoc", "title": "stored-procedures", "heading": "Supported Databases", "heading_level": 2, "file_order": 122, "section_index": 1, "content_hash": "07611b286b9cf2febd7315ce6e0c25e0b670a683d9f6558ea4cf93062428c257", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/stored-procedures.adoc"}}
{"id": "sha256:bb3a02882a989a657121ec35a7189b654d25bda18d45ce008d06c1ca94654f66", "content": "The stored procedure components provide full XML Namespace support, and configuring the components is the same as for the general purpose JDBC components discussed earlier.\n\n[[sp-common-config-params]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/stored-procedures.adoc", "title": "stored-procedures", "heading": "Configuration", "heading_level": 2, "file_order": 122, "section_index": 2, "content_hash": "bb3a02882a989a657121ec35a7189b654d25bda18d45ce008d06c1ca94654f66", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/stored-procedures.adoc"}}
{"id": "sha256:de7da34967134e41a3ad22215df37df84b04e2b34c1ea30f05ead614b3a4dc51", "content": "All stored procedure components share certain configuration parameters:\n\n* `auto-startup`: Lifecycle attribute signaling whether this component should be started during application context startup.\nIt defaults to `true`.\nOptional.\n* `data-source`: Reference to a `javax.sql.DataSource`, which is used to access the database.\nRequired.\n* `id`: Identifies the underlying Spring bean definition, which is an instance of either `EventDrivenConsumer` or `PollingConsumer`, depending on whether the outbound channel adapter's `channel` attribute references a `SubscribableChannel` or a `PollableChannel`.\nOptional.\n* `ignore-column-meta-data`: For fully supported databases, the underlying https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCall.html[`SimpleJdbcCall`] class can automatically retrieve the parameter information for the stored procedure or stored function from the JDBC metadata.\n+\nHowever, if the database does not support metadata lookups or if you need to provide customized parameter definitions, this flag can be set to `true`.\nIt defaults to `false`.\nOptional.\n* `is-function`: If `true`, a SQL Function is called.\nIn that case, the `stored-procedure-name` or `stored-procedure-name-expression` attributes define the name of the called function.\nIt defaults to `false`.\nOptional.\n* `stored-procedure-name`: This attribute specifies the name of the stored procedure.\nIf the `is-function` attribute is set to `true`, this attribute specifies the function name instead.\nEither this property or `stored-procedure-name-expression` must be specified.\n* `stored-procedure-name-expression`: This attribute specifies the name of the stored procedure by using a SpEL expression.\nBy using SpEL, you have access to the full message (if available), including its headers and payload.\nYou can use this attribute to invoke different stored procedures at runtime.\nFor example, you can provide stored procedure names that you would like to execute as a message header.\nThe expression must resolve to a `String`.\n+\nIf the `is-function` attribute is set to `true`, this attribute specifies a stored function.\nEither this property or `stored-procedure-name` must be specified.\n* `jdbc-call-operations-cache-size`: Defines the maximum number of cached `SimpleJdbcCallOperations` instances.\nBasically, for each stored procedure name, a new https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCallOperations.html[`SimpleJdbcCallOperations`] instance is created that, in return, is cached.\n+\nNOTE: Spring Integration 2.2 added the `stored-procedure-name-expression` attribute and the `jdbc-call-operations-cache-size` attribute.\n+\nThe default cache size is `10`.\nA value of `0` disables caching.\nNegative values are not permitted.\n+\nIf you enable JMX, statistical information about the `jdbc-call-operations-cache` is exposed as an MBean.\nSee xref:jmx.adoc#jmx-mbean-exporter[MBean Exporter] for more information.\n* `sql-parameter-source-factory`: (Not available for the stored procedure inbound channel adapter.)\nReference to a `SqlParameterSourceFactory`.\nBy default, bean properties of the passed in `Message` payload are used as a source for the stored procedure's input parameters by using a `BeanPropertySqlParameterSourceFactory`.\n+\nThis may suffice for basic use cases.\nFor more sophisticated options, consider passing in one or more `ProcedureParameter` values.\nSee xref:jdbc/stored-procedures.adoc#sp-defining-parameter-sources[Defining Parameter Sources].\nOptional.\n* `use-payload-as-parameter-source`: (Not available for the stored procedure inbound channel adapter.)\nIf set to `true`, the payload of the `Message` is used as a source for providing parameters.\nIf set to `false`, however, the entire `Message` is available as a source for parameters.\n+\nIf no procedure parameters are passed in, this property defaults to `true`.\nThis means that, by using a default `BeanPropertySqlParameterSourceFactory`, the bean properties of the payload are used as a source for parameter values for the stored procedure or stored function.\nOr, starting with version `6.5`, as keys if the mention payload is a `Map`.\n+\nHowever, if procedure parameters are passed in, this property (by default) evaluates to `false`.\n`ProcedureParameter` lets SpEL Expressions be provided.\nTherefore, it is highly beneficial to have access to the entire `Message`.\nThe property set on the underlying `StoredProcExecutor`.\nOptional.\n\n[[sp-common-config-subelements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/stored-procedures.adoc", "title": "stored-procedures", "heading": "Common Configuration Attributes", "heading_level": 2, "file_order": 122, "section_index": 3, "content_hash": "de7da34967134e41a3ad22215df37df84b04e2b34c1ea30f05ead614b3a4dc51", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/stored-procedures.adoc"}}
{"id": "sha256:c1eb0a99d501818aadd429cd06fdf5055bd6ef7042a6aff2b64d49da79228436", "content": "The stored procedure components share a common set of child elements that you can use to define and pass parameters to stored procedures or stored functions.\nThe following elements are available:\n\n* `parameter`\n* `returning-resultset`\n* `sql-parameter-definition`\n* `poller`\n\n* `parameter`: Provides a mechanism to provide stored procedure parameters.\nParameters can be either static or provided by using a SpEL Expressions.\n+\n[source,xml]\n----\n<int-jdbc:parameter name=\"\" <1>\n type=\"\" <2>\n value=\"\"/> <3>\n\n<int-jdbc:parameter name=\"\"\n expression=\"\"/> <4>\n----\n+\n<1> The name of the parameter to be passed into the Stored Procedure or Stored Function.\nRequired.\n<2> This attribute specifies the type of the value.\nIf nothing is provided, this attribute defaults to `java.lang.String`.\nThis attribute is used only when the `value` attribute is used.\nOptional.\n<3> The value of the parameter.\nYou must provide either this attribute or the `expression` attribute.\nOptional.\n<4> Instead of the `value` attribute, you can specify a SpEL expression for passing the value of the parameter.\nIf you specify the `expression`, the `value` attribute is not allowed.\nOptional.\nOptional.\n+\n* `returning-resultset`: Stored procedures may return multiple result sets.\nBy setting one or more `returning-resultset` elements, you can specify `RowMappers` to convert each returned `ResultSet` to meaningful objects.\nOptional.\n+\n[source,xml]\n----\n<int-jdbc:returning-resultset name=\"\" row-mapper=\"\" />\n----\n\n* `sql-parameter-definition`: If you use a database that is fully supported, you typically do not have to specify the stored procedure parameter definitions.\nInstead, those parameters can be automatically derived from the JDBC metadata.\nHowever, if you use databases that are not fully supported, you must set those parameters explicitly by using the `sql-parameter-definition` element.\n+\nYou can also choose to turn off any processing of parameter metadata information obtained through JDBC by using the `ignore-column-meta-data` attribute.\n+\n[source,xml]\n----\n<int-jdbc:sql-parameter-definition\n name=\"\" <1>\n direction=\"IN\" <2>\n type=\"STRING\" <3>\n scale=\"5\" <4>\n type-name=\"FOO_STRUCT\" <5>\n return-type=\"fooSqlReturnType\"/> <6>\n----\n\n<1> Specifies the name of the SQL parameter.\nRequired.\n<2> Specifies the direction of the SQL parameter definition.\nDefaults to `IN`.\nValid values are: `IN`, `OUT`, and `INOUT`.\nIf your procedure is returning result sets, use the `returning-resultset` element.\nOptional.\n<3> The SQL type used for this SQL parameter definition.\nTranslates into an integer value, as defined by `java.sql.Types`.\nAlternatively, you can provide the integer value as well.\nIf this attribute is not explicitly set, it defaults to 'VARCHAR'.\nOptional.\n<4> The scale of the SQL parameter.\nOnly used for numeric and decimal parameters.\nOptional.\n<5> The `typeName` for types that are user-named such as: `STRUCT`, `DISTINCT`, `JAVA_OBJECT`, and named array types.\nThis attribute is mutually exclusive with the `scale` attribute.\nOptional.\n<6> The reference to a custom value handler for complex types.\nAn implementation of https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/SqlReturnType.html[`SqlReturnType`].\nThis attribute is mutually exclusive with the `scale` attribute and is only applicable for OUT and INOUT parameters.\nOptional.\n* `poller`: Lets you configure a message poller if this endpoint is a `PollingConsumer`.\nOptional.\n\n[[sp-defining-parameter-sources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/stored-procedures.adoc", "title": "stored-procedures", "heading": "Common Configuration Sub-Elements", "heading_level": 2, "file_order": 122, "section_index": 4, "content_hash": "c1eb0a99d501818aadd429cd06fdf5055bd6ef7042a6aff2b64d49da79228436", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/stored-procedures.adoc"}}
{"id": "sha256:cd13c8a757dc7d7d74e01b45fdb9f8c3b5474cc401cc54e84bf6f8920dd3795b", "content": "Parameter sources govern the techniques of retrieving and mapping the Spring Integration message properties to the relevant stored procedure input parameters.\n\nThe stored procedure components follow certain rules.\nBy default, the bean properties of the `Message` payload are used as a source for the stored procedure's input parameters.\nIn that case, a `BeanPropertySqlParameterSourceFactory` is used.\nThis may suffice for basic use cases.\nThe next example illustrates that default behavior.\n\nIMPORTANT: For the \"`automatic`\" lookup of bean properties by using the `BeanPropertySqlParameterSourceFactory` to work, your bean properties must be defined in lower case.\nThis is due to the fact that in `org.springframework.jdbc.core.metadata.CallMetaDataContext` (the Java method is `matchInParameterValuesWithCallParameters()`), the retrieved stored procedure parameter declarations are converted to lower case.\nAs a result, if you have camel-case bean properties (such as `lastName`), the lookup fails.\nIn that case, provide an explicit `ProcedureParameter`.\n\nSuppose we have a payload that consists of a simple bean with the following three properties: `id`, `name`, and `description`.\nFurthermore, we have a simplistic Stored Procedure called `INSERT_COFFEE` that accepts three input parameters: `id`, `name`, and `description`.\nWe also use a fully supported database.\nIn that case, the following configuration for a stored procedure outbound adapter suffices:\n\n[source,xml]\n----\n<int-jdbc:stored-proc-outbound-channel-adapter data-source=\"dataSource\"\n channel=\"insertCoffeeProcedureRequestChannel\"\n stored-procedure-name=\"INSERT_COFFEE\"/>\n----\n\nFor more sophisticated options, consider passing in one or more `ProcedureParameter` values.\n\nIf you do provide `ProcedureParameter` values explicitly, by default, an `ExpressionEvaluatingSqlParameterSourceFactory` is used for parameter processing, to enable the full power of SpEL expressions.\n\nIf you need even more control over how parameters are retrieved, consider passing in a custom implementation of `SqlParameterSourceFactory` by using the `sql-parameter-source-factory` attribute.\n\n[[stored-procedure-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/stored-procedures.adoc", "title": "stored-procedures", "heading": "Defining Parameter Sources", "heading_level": 2, "file_order": 122, "section_index": 5, "content_hash": "cd13c8a757dc7d7d74e01b45fdb9f8c3b5474cc401cc54e84bf6f8920dd3795b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/stored-procedures.adoc"}}
{"id": "sha256:e6a1494245229d5f983b6881bb77750d89e7cc713c315c20fa3ca6acdb6ef416", "content": "The following listing calls out the attributes that matter for a stored procedure inbound channel adapter:\n\n[source,xml]\n----\n<int-jdbc:stored-proc-inbound-channel-adapter\n channel=\"\" <1>\n stored-procedure-name=\"\"\n data-source=\"\"\n auto-startup=\"true\"\n id=\"\"\n ignore-column-meta-data=\"false\"\n is-function=\"false\"\n skip-undeclared-results=\"\" <2>\n return-value-required=\"false\" <3>\n <int:poller/>\n <int-jdbc:sql-parameter-definition name=\"\" direction=\"IN\"\n type=\"STRING\"\n scale=\"\"/>\n <int-jdbc:parameter name=\"\" type=\"\" value=\"\"/>\n <int-jdbc:parameter name=\"\" expression=\"\"/>\n <int-jdbc:returning-resultset name=\"\" row-mapper=\"\" />\n</int-jdbc:stored-proc-inbound-channel-adapter>\n----\n\n<1> Channel to which polled messages are sent.\nIf the stored procedure or function does not return any data, the payload of the `Message` is null.\nRequired.\n<2> If this attribute is set to `true`, all results from a stored procedure call that do not have a corresponding `SqlOutParameter` declaration are bypassed.\nFor example, stored procedures can return an update count value, even though your stored procedure declared only a single result parameter.\nThe exact behavior depends on the database implementation.\nThe value is set on the underlying `JdbcTemplate`.\nThe value defaults to `true`.\nOptional.\n<3> Indicates whether this procedure's return value should be included.\nSince Spring Integration 3.0.\nOptional.\n\n[[stored-procedure-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/stored-procedures.adoc", "title": "stored-procedures", "heading": "Stored Procedure Inbound Channel Adapter", "heading_level": 2, "file_order": 122, "section_index": 6, "content_hash": "e6a1494245229d5f983b6881bb77750d89e7cc713c315c20fa3ca6acdb6ef416", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/stored-procedures.adoc"}}
{"id": "sha256:de31c13c1c2dadf396ef09628ab802fb6b73a59632c8083b303258a52a185505", "content": "The following listing calls out the attributes that matter for a stored procedure outbound channel adapter:\n\n[source,xml]\n----\n<int-jdbc:stored-proc-outbound-channel-adapter channel=\"\" <1>\n stored-procedure-name=\"\"\n data-source=\"\"\n auto-startup=\"true\"\n id=\"\"\n ignore-column-meta-data=\"false\"\n order=\"\" <2>\n sql-parameter-source-factory=\"\"\n use-payload-as-parameter-source=\"\">\n <int:poller fixed-rate=\"\"/>\n <int-jdbc:sql-parameter-definition name=\"\"/>\n <int-jdbc:parameter name=\"\"/>\n\n</int-jdbc:stored-proc-outbound-channel-adapter>\n----\n\n<1> The receiving message channel of this endpoint.\nRequired.\n<2> Specifies the order for invocation when this endpoint is connected as a subscriber to a channel.\nThis is particularly relevant when that channel is using a `failover` dispatching strategy.\nIt has no effect when this endpoint is itself a polling consumer for a channel with a queue.\nOptional.\n\n[[stored-procedure-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/stored-procedures.adoc", "title": "stored-procedures", "heading": "Stored Procedure Outbound Channel Adapter", "heading_level": 2, "file_order": 122, "section_index": 7, "content_hash": "de31c13c1c2dadf396ef09628ab802fb6b73a59632c8083b303258a52a185505", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/stored-procedures.adoc"}}
{"id": "sha256:51c8ca8455e64c01226fb22f7336d58dbc537f270868c43684677233db3bb40f", "content": "The following listing calls out the attributes that matter for a stored procedure outbound channel adapter:\n\n[source,xml]\n----\n<int-jdbc:stored-proc-outbound-gateway request-channel=\"\" <1>\n stored-procedure-name=\"\"\n data-source=\"\"\n auto-startup=\"true\"\n id=\"\"\n ignore-column-meta-data=\"false\"\n is-function=\"false\"\n order=\"\"\n reply-channel=\"\" <2>\n reply-timeout=\"\" <3>\n return-value-required=\"false\" <4>\n skip-undeclared-results=\"\" <5>\n sql-parameter-source-factory=\"\"\n use-payload-as-parameter-source=\"\">\n<int-jdbc:sql-parameter-definition name=\"\" direction=\"IN\"\n type=\"\"\n scale=\"10\"/>\n<int-jdbc:sql-parameter-definition name=\"\"/>\n<int-jdbc:parameter name=\"\" type=\"\" value=\"\"/>\n<int-jdbc:parameter name=\"\" expression=\"\"/>\n<int-jdbc:returning-resultset name=\"\" row-mapper=\"\" />\n----\n\n<1> The receiving message channel of this endpoint.\nRequired.\n<2> Message channel to which replies should be sent after receiving the database response.\nOptional.\n<3> Lets you specify how long this gateway waits for the reply message to be sent successfully before throwing an exception.\nKeep in mind that, when sending to a `DirectChannel`, the invocation occurs in the sender's thread.\nConsequently, the failing of the send operation may be caused by other components further downstream.\nThe value is specified in milliseconds.\nOptional.\n<4> Indicates whether this procedure's return value should be included.\nOptional.\n<5> If the `skip-undeclared-results` attribute is set to `true`, all results from a stored procedure call that do not have a corresponding `SqlOutParameter` declaration are bypassed.\nFor example, stored procedures may return an update count value, even though your stored procedure only declared a single result parameter.\nThe exact behavior depends on the database.\nThe value is set on the underlying `JdbcTemplate`.\nThe value defaults to `true`.\nOptional.\n\n[[sp-examples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/stored-procedures.adoc", "title": "stored-procedures", "heading": "Stored Procedure Outbound Gateway", "heading_level": 2, "file_order": 122, "section_index": 8, "content_hash": "51c8ca8455e64c01226fb22f7336d58dbc537f270868c43684677233db3bb40f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/stored-procedures.adoc"}}
{"id": "sha256:26345f07ee9446072a5da93a1e3fd64a962092f3d21c4fbf62a295aab019876f", "content": "This section contains two examples that call https://db.apache.org/derby/[Apache Derby] stored procedures.\nThe first procedure calls a stored procedure that returns a `ResultSet`.\nBy using a `RowMapper`, the data is converted into a domain object, which then becomes the Spring Integration message payload.\n\nIn the second sample, we call a stored procedure that uses output parameters to return data instead.\n\n[NOTE]\n=====\nHave a look at the https://github.com/spring-projects/spring-integration-samples[Spring Integration Samples project].\n\nThe project contains the Apache Derby example referenced here, as well as instructions on how to run it.\nThe Spring Integration Samples project also provides an https://github.com/spring-projects/spring-integration-samples/tree/main/intermediate/stored-procedures-oracle[example] of using Oracle stored procedures.\n=====\n\nIn the first example, we call a stored procedure named `FIND_ALL_COFFEE_BEVERAGES` that does not define any input parameters but that returns a `ResultSet`.\n\nIn Apache Derby, stored procedures are implemented in Java.\nThe following listing shows the method signature:\n\n[source,java]\n----\npublic static void findAllCoffeeBeverages(ResultSet[] coffeeBeverages)\n throws SQLException {\n ...\n}\n----\n\nThe following listing shows the corresponding SQL:\n\n[source,sql]\n----\nCREATE PROCEDURE FIND_ALL_COFFEE_BEVERAGES() \\\nPARAMETER STYLE JAVA LANGUAGE JAVA MODIFIES SQL DATA DYNAMIC RESULT SETS 1 \\\nEXTERNAL NAME 'o.s.i.jdbc.storedproc.derby.DerbyStoredProcedures.findAllCoffeeBeverages';\n----\n\nIn Spring Integration, you can now call this stored procedure by using, for example, a `stored-proc-outbound-gateway`, as the following example shows:\n\n[source,xml]\n----\n<int-jdbc:stored-proc-outbound-gateway id=\"outbound-gateway-storedproc-find-all\"\n data-source=\"dataSource\"\n request-channel=\"findAllProcedureRequestChannel\"\n expect-single-result=\"true\"\n stored-procedure-name=\"FIND_ALL_COFFEE_BEVERAGES\">\n<int-jdbc:returning-resultset name=\"coffeeBeverages\"\n row-mapper=\"org.springframework.integration.support.CoffeBeverageMapper\"/>\n</int-jdbc:stored-proc-outbound-gateway>\n----\n\nIn the second example, we call a stored procedure named `FIND_COFFEE` that has one input parameter.\nInstead of returning a `ResultSet`, it uses an output parameter.\nThe following example shows the method signature:\n\n[source,java]\n----\npublic static void findCoffee(int coffeeId, String[] coffeeDescription)\n throws SQLException {\n ...\n}\n----\n\nThe following listing shows the corresponding SQL:\n\n[source,sql]\n----\nCREATE PROCEDURE FIND_COFFEE(IN ID INTEGER, OUT COFFEE_DESCRIPTION VARCHAR(200)) \\\nPARAMETER STYLE JAVA LANGUAGE JAVA EXTERNAL NAME \\\n'org.springframework.integration.jdbc.storedproc.derby.DerbyStoredProcedures.findCoffee';\n----\n\nIn Spring Integration, you can now call this Stored Procedure by using, for example, a `stored-proc-outbound-gateway`, as the following example shows:\n\n[source,xml]\n----\n<int-jdbc:stored-proc-outbound-gateway id=\"outbound-gateway-storedproc-find-coffee\"\n data-source=\"dataSource\"\n request-channel=\"findCoffeeProcedureRequestChannel\"\n skip-undeclared-results=\"true\"\n stored-procedure-name=\"FIND_COFFEE\"\n expect-single-result=\"true\">\n <int-jdbc:parameter name=\"ID\" expression=\"payload\" />\n</int-jdbc:stored-proc-outbound-gateway>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc/stored-procedures.adoc", "title": "stored-procedures", "heading": "Examples", "heading_level": 2, "file_order": 122, "section_index": 9, "content_hash": "26345f07ee9446072a5da93a1e3fd64a962092f3d21c4fbf62a295aab019876f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc/stored-procedures.adoc"}}
{"id": "sha256:7b6f623ec902b4dcae19973ed1f474fef71e7fe87d340492000092ae920200ba", "content": "[[functionality]]\n\nAll JPA components perform their respective JPA operations by using one of the following:\n\n* Entity classes\n* Java Persistence Query Language (JPQL) for update, select and delete (JPQL does not support inserts)\n* Native Query\n* Named Query\n\nThe following sections describe each of these components in more detail.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/functionality.adoc", "title": "functionality", "heading": "functionality", "heading_level": 1, "file_order": 123, "section_index": 0, "content_hash": "7b6f623ec902b4dcae19973ed1f474fef71e7fe87d340492000092ae920200ba", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/functionality.adoc"}}
{"id": "sha256:ab93427e2513bc8a627bb76e597debcb22cefe1cc410bdb31102bc743f218cf9", "content": "[[jpa-inbound-channel-adapter]]\n\nAn inbound channel adapter is used to execute a select query over the database using JPA QL and return the result.\nThe message payload is either a single entity or a `List` of entities.\nThe following XML configures an `inbound-channel-adapter`:\n\n[source,xml]\n----\n<int-jpa:inbound-channel-adapter channel=\"inboundChannelAdapterOne\" <1>\n entity-manager=\"em\" <2>\n auto-startup=\"true\" <3>\n query=\"select s from Student s\" <4>\n expect-single-result=\"true\" <5>\n max-results=\"\" <6>\n max-results-expression=\"\" <7>\n delete-after-poll=\"true\" <8>\n flush-after-delete=\"true\"> <9>\n <int:poller fixed-rate=\"2000\" >\n <int:transactional propagation=\"REQUIRED\" transaction-manager=\"transactionManager\"/>\n </int:poller>\n</int-jpa:inbound-channel-adapter>\n----\n\n<1> The channel over which the `inbound-channel-adapter` puts the messages (with the payload) after executing the JPA QL in the `query` attribute.\n<2> The `EntityManager` instance used to perform the required JPA operations.\n<3> Attribute signaling whether the component should automatically start when the application context starts.\nThe value defaults to `true`.\n<4> The JPA QL whose result are sent out as the payload of the message\n<5> This attribute tells whether the JPQL query gives a single entity in the result or a `List` of entities.\nIf the value is set to `true`, the single entity is sent as the payload of the message.\nIf, however, multiple results are returned after setting this to `true`, a `MessagingException` is thrown.\nThe value defaults to `false`.\n<6> This non-zero, non-negative integer value tells the adapter not to select more than the given number of rows on execution of the select operation.\nBy default, if this attribute is not set, all possible records are selected by the query.\nThis attribute is mutually exclusive with `max-results-expression`.\nOptional.\n<7> An expression that is evaluated to find the maximum number of results in a result set.\nMutually exclusive with `max-results`.\nOptional.\n<8> Set this value to `true` if you want to delete the rows received after execution of the query.\nYou must ensure that the component operates as part of a transaction.\nOtherwise, you may encounter an exception such as: `java.lang.IllegalArgumentException: Removing a detached instance ...`\n<9> Set this value to `true` if you want to flush the persistence context immediately after deleting received entities and if you do not want to rely on the `flushMode` of the `EntityManager`.\nThe value defaults to `false`.\n\n[[jpaInboundChannelAdapterParameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/inbound-channel-adapter.adoc", "title": "inbound-channel-adapter", "heading": "inbound-channel-adapter", "heading_level": 1, "file_order": 124, "section_index": 0, "content_hash": "ab93427e2513bc8a627bb76e597debcb22cefe1cc410bdb31102bc743f218cf9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/inbound-channel-adapter.adoc"}}
{"id": "sha256:5b64ffb0b724d46004b4c5bbbdd768078a9d23ae7b22b3164b492ecd4b047c74", "content": "The following listing shows all the values that can be set for an `inbound-channel-adapter`:\n\n[source,xml]\n----\n<int-jpa:inbound-channel-adapter\n auto-startup=\"true\" <1>\n channel=\"\" <2>\n delete-after-poll=\"false\" <3>\n delete-per-row=\"false\" <4>\n entity-class=\"\" <5>\n entity-manager=\"\" <6>\n entity-manager-factory=\"\" <7>\n expect-single-result=\"false\" <8>\n id=\"\"\n jpa-operations=\"\" <9>\n jpa-query=\"\" <10>\n named-query=\"\" <11>\n native-query=\"\" <12>\n parameter-source=\"\" <13>\n send-timeout=\"\"> <14>\n <int:poller ref=\"myPoller\"/>\n </int-jpa:inbound-channel-adapter>\n----\n\n<1> This lifecycle attribute signals whether this component should automatically start when the application context starts.\nThis attribute defaults to `true`.\nOptional.\n<2> The channel to which the adapter sends a message with the payload from performing the desired JPA operation.\n<3> A boolean flag that indicates whether to delete the selected records after they have been polled by the adapter.\nBy default, the value is `false` (that is, the records are not deleted).\nYou must ensure that the component operates as part of a transaction.\nOtherwise, you may encounter an exception, such as: `java.lang.IllegalArgumentException: Removing a detached instance ...`.\nOptional.\n<4> A boolean flag that indicates whether the records can be deleted in bulk or must be deleted one record at a time.\nBy default, the value is `false` (that is, the records can be bulk-deleted).\nOptional.\n<5> The fully qualified name of the entity class to be queried from the database.\nThe adapter automatically builds a JPA Query based on the entity class name.\nOptional.\n<6> An instance of `jakarta.persistence.EntityManager` used to perform the JPA operations.\nOptional.\n<7> An instance of `jakarta.persistence.EntityManagerFactory` used to obtain an instance of `jakarta.persistence.EntityManager` that performs the JPA operations.\nOptional.\n<8> A boolean flag indicating whether the select operation is expected to return a single result or a `List` of results.\nIf this flag is set to `true`, the single entity selected is sent as the payload of the message.\nIf multiple entities are returned, an exception is thrown.\nIf `false`, the `List` of entities is sent as the payload of the message.\nThe value defaults to `false`.\nOptional.\n<9> An implementation of `org.springframework.integration.jpa.core.JpaOperations` used to perform the JPA operations.\nWe recommend not providing an implementation of your own but using the default `org.springframework.integration.jpa.core.DefaultJpaOperations` implementation.\nYou can use any of the `entity-manager`, `entity-manager-factory`, or `jpa-operations` attributes.\nOptional.\n<10> The JPA QL to be executed by this adapter.\nOptional.\n<11> The named query that needs to be executed by this adapter.\nOptional.\n<12> The native query executed by this adapter.\nYou can use any of the `jpa-query`, `named-query`, `entity-class`, or `native-query` attributes.\nOptional.\n<13> An implementation of `o.s.i.jpa.support.parametersource.ParameterSource` used to resolve the values of the parameters in the query.\nIgnored if the `entity-class` attribute has a value.\nOptional.\n<14> Maximum amount of time (in milliseconds) to wait when sending a message to the channel.\nOptional.\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/inbound-channel-adapter.adoc", "title": "inbound-channel-adapter", "heading": "Configuration Parameter Reference", "heading_level": 2, "file_order": 124, "section_index": 1, "content_hash": "5b64ffb0b724d46004b4c5bbbdd768078a9d23ae7b22b3164b492ecd4b047c74", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/inbound-channel-adapter.adoc"}}
{"id": "sha256:58fc2f43b278cd7cd6e2fa819f01aa5636094455e79af6937971367ff848cb00", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with Java:\n\n[source, java]\n----\n@SpringBootApplication\n@EntityScan(basePackageClasses = StudentDomain.class)\npublic class JpaJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(JpaJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Autowired\n private EntityManagerFactory entityManagerFactory;\n\n @Bean\n public JpaExecutor jpaExecutor() {\n JpaExecutor executor = new JpaExecutor(this.entityManagerFactory);\n jpaExecutor.setJpaQuery(\"from Student\");\n return executor;\n }\n\n @Bean\n @InboundChannelAdapter(channel = \"jpaInputChannel\",\n poller = @Poller(fixedDelay = \"${poller.interval}\"))\n public MessageSource<?> jpaInbound() {\n return new JpaPollingChannelAdapter(jpaExecutor());\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"jpaInputChannel\")\n public MessageHandler handler() {\n return message -> System.out.println(message.getPayload());\n }\n\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/inbound-channel-adapter.adoc", "title": "inbound-channel-adapter", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 124, "section_index": 2, "content_hash": "58fc2f43b278cd7cd6e2fa819f01aa5636094455e79af6937971367ff848cb00", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/inbound-channel-adapter.adoc"}}
{"id": "sha256:afac54700782f70a37efeedd4218db248ff682ec7574ab9138be27ab94e6c05a", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\n@EntityScan(basePackageClasses = StudentDomain.class)\npublic class JpaJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(JpaJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Autowired\n private EntityManagerFactory entityManagerFactory;\n\n @Bean\n public IntegrationFlow pollingAdapterFlow() {\n return IntegrationFlow\n .from(Jpa.inboundAdapter(this.entityManagerFactory)\n .entityClass(StudentDomain.class)\n .maxResults(1)\n .expectSingleResult(true),\n e -> e.poller(p -> p.trigger(new OnlyOnceTrigger())))\n .channel(c -> c.queue(\"pollingResults\"))\n .get();\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/inbound-channel-adapter.adoc", "title": "inbound-channel-adapter", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 124, "section_index": 3, "content_hash": "afac54700782f70a37efeedd4218db248ff682ec7574ab9138be27ab94e6c05a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/inbound-channel-adapter.adoc"}}
{"id": "sha256:2a69b32261773ddd7197bf8da335870a58b27333d8ee1d1fde1c43e5a164c33c", "content": "[[jpa-java-implementation]]\n\nEach of the provided components uses the `o.s.i.jpa.core.JpaExecutor` class, which, in turn, uses an implementation of the `o.s.i.jpa.core.JpaOperations` interface.\n`JpaOperations` operates like a typical Data Access Object (DAO) and provides methods such as find, persist, executeUpdate, and so on.\nFor most use cases, the default implementation (`o.s.i.jpa.core.DefaultJpaOperations`) should be sufficient.\nHowever, you can specify your own implementation if you require custom behavior.\n\nTo initialize a `JpaExecutor`, you must use one of the constructors that accept one of:\n\n* EntityManagerFactory\n* EntityManager\n* JpaOperations\n\nThe following example shows how to initialize a `JpaExecutor` with an `entityManagerFactory` and use it in an outbound gateway:\n\n[source,java]\n----\n@Bean\npublic JpaExecutor jpaExecutor() {\n JpaExecutor executor = new JpaExecutor(this.entityManagerFactory);\n executor.setJpaParameters(Collections.singletonList(new JpaParameter(\"firstName\", null, \"#this\")));\n executor.setUsePayloadAsParameterSource(true);\n executor.setExpectSingleResult(true);\n return executor;\n}\n\n@ServiceActivator(inputChannel = \"getEntityChannel\")\n@Bean\npublic MessageHandler retrievingJpaGateway() {\n JpaOutboundGateway gateway = new JpaOutboundGateway(jpaExecutor());\n gateway.setGatewayType(OutboundGatewayType.RETRIEVING);\n gateway.setOutputChannelName(\"resultsChannel\");\n return gateway;\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/java-implementation.adoc", "title": "java-implementation", "heading": "java-implementation", "heading_level": 1, "file_order": 125, "section_index": 0, "content_hash": "2a69b32261773ddd7197bf8da335870a58b27333d8ee1d1fde1c43e5a164c33c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/java-implementation.adoc"}}
{"id": "sha256:a6f432dd980df50057db4856034ccbc31b8dcf06269101002ba8d9de0dfb3c98", "content": "[[jpa-namespace-support]]\n\nWhen using XML namespace support, the underlying parser classes instantiate the relevant Java classes for you.\nThus, you typically need not deal with the inner workings of the JPA adapter.\nThis section documents the XML namespace support provided by Spring Integration and shows you how to use the XML Namespace support to configure the JPA components.\n\n[[jpa-namespace-support-common-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/namespace-support.adoc", "title": "namespace-support", "heading": "namespace-support", "heading_level": 1, "file_order": 126, "section_index": 0, "content_hash": "a6f432dd980df50057db4856034ccbc31b8dcf06269101002ba8d9de0dfb3c98", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/namespace-support.adoc"}}
{"id": "sha256:2893adf94a24e94550dc327fe5f81c8bbd4b3c4787eefd7b1e585d9f2b407dbd", "content": "Certain configuration parameters are shared by all JPA components:\n\n`auto-startup`::\nLifecycle attribute that signals whether this component should be started during the application context startup.\nDefaults to `true`.\nOptional.\n\n`id`::\nIdentifies the underlying Spring bean definition, which is an instance of either `EventDrivenConsumer` or `PollingConsumer`.\nOptional.\n\n`entity-manager-factory`::\nThe reference to the JPA entity manager factory that the adapter uses to create the `EntityManager`.\nYou must provide this attribute, the `entity-manager` attribute, or the `jpa-operations` attribute.\n\n`entity-manager`::\nThe reference to the JPA Entity Manager that the component uses.\nYou must provide this attribute, the `entity-manager-factory` attribute, or the `jpa-operations` attribute.\n+\nNOTE: Usually, your Spring application context defines only a JPA entity manager factory, and the `EntityManager` is injected by using the `@PersistenceContext` annotation.\nThis approach does not apply for the Spring Integration JPA components.\nUsually, injecting the JPA entity manager factory is best, but, when you want to inject an `EntityManager` explicitly, you have to define a `SharedEntityManagerBean`.\nFor more information, see the relevant https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/orm/jpa/support/SharedEntityManagerBean.html[Javadoc].\n+\nThe following example shows how to explicitly include an entity manager factory:\n+\n[source,xml]\n----\n<bean id=\"entityManager\"\n class=\"org.springframework.orm.jpa.support.SharedEntityManagerBean\">\n <property name=\"entityManagerFactory\" ref=\"entityManagerFactoryBean\" />\n</bean>\n----\n\n`jpa-operations`::\nA reference to a bean that implements the `JpaOperations` interface.\nIn rare cases, it might be advisable to provide your own implementation of the `JpaOperations` interface instead of relying on the default implementation (`org.springframework.integration.jpa.core.DefaultJpaOperations`).\nIf you use the `jpa-operations` attribute, you must not provide the JPA entity manager or JPA entity manager factory, because `JpaOperations` wraps the necessary datasource.\n\n`entity-class`::\nThe fully qualified name of the entity class.\nThe exact semantics of this attribute vary, depending on whether we are performing a `persist` or `update` operation or whether we are retrieving objects from the database.\n+\nWhen retrieving data, you can specify the `entity-class` attribute to indicate that you would like to retrieve objects of this type from the database.\nIn that case, you must not define any of the query attributes (`jpa-query`, `native-query`, or `named-query`).\n+\nWhen persisting data, the `entity-class` attribute indicates the type of object to persist.\nIf not specified for persist operations, the entity class is automatically retrieved from the message's payload.\n\n`jpa-query`::\nDefines the JPA query (Java Persistence Query Language) to be used.\n\n`native-query`::\nDefines the native SQL query to be used.\n\n`named-query`::\nRefers to a named query.\nA named query can be defined in either Native SQL or JPAQL, but the underlying JPA persistence provider handles that distinction internally.\n\n[[jpa-parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/namespace-support.adoc", "title": "namespace-support", "heading": "Common XML Namespace Configuration Attributes", "heading_level": 2, "file_order": 126, "section_index": 1, "content_hash": "2893adf94a24e94550dc327fe5f81c8bbd4b3c4787eefd7b1e585d9f2b407dbd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/namespace-support.adoc"}}
{"id": "sha256:eea39177cfc543bb7cb9367bf0877a67619871ce807a1e8d212077def437e92e", "content": "To provide parameters, you can use the `parameter` XML element.\nIt has a mechanism that lets you provide parameters for queries that are based on either the Java Persistence Query Language (JPQL) or native SQL queries.\nYou can also provide parameters for named queries.\n\nExpression-based Parameters::\nThe following example shows how to set an expression-based parameter:\n+\n[source,xml]\n----\n<int-jpa:parameter expression=\"payload.name\" name=\"firstName\"/>\n----\n\nValue-based Parameters::\nThe following example shows how to set a value-based parameter:\n+\n[source,xml]\n----\n<int-jpa:parameter name=\"name\" type=\"java.lang.String\" value=\"myName\"/>\n----\n\nPositional Parameters::\nThe following example shows how to set an expression-based parameter:\n+\n[source,xml]\n----\n<int-jpa:parameter expression=\"payload.name\"/>\n<int-jpa:parameter type=\"java.lang.Integer\" value=\"21\"/>\n----\n\n[[jpa-transactions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/namespace-support.adoc", "title": "namespace-support", "heading": "Providing JPA Query Parameters", "heading_level": 2, "file_order": 126, "section_index": 2, "content_hash": "eea39177cfc543bb7cb9367bf0877a67619871ce807a1e8d212077def437e92e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/namespace-support.adoc"}}
{"id": "sha256:a08c3e2fe8f607f04b2e63be725312925d0e00973982d756a2d0b66f7ced9165", "content": "All JPA operations (such as `INSERT`, `UPDATE`, and `DELETE`) require a transaction to be active whenever they are performed.\nFor inbound channel adapters, you need do nothing special.\nIt works similarly to the way we configure transaction managers with pollers that are used with other inbound channel adapters.\nThe following XML example configures a transaction manager that uses a poller with an inbound channel adapter:\n\n[source,xml]\n----\n<int-jpa:inbound-channel-adapter\n channel=\"inboundChannelAdapterOne\"\n entity-manager=\"em\"\n auto-startup=\"true\"\n jpa-query=\"select s from Student s\"\n expect-single-result=\"true\"\n delete-after-poll=\"true\">\n <int:poller fixed-rate=\"2000\" >\n <int:transactional propagation=\"REQUIRED\"\n transaction-manager=\"transactionManager\"/>\n </int:poller>\n</int-jpa:inbound-channel-adapter>\n----\n\nHowever, you may need to specifically start a transaction when using an outbound channel adapter or gateway.\nIf a `DirectChannel` is an input channel for the outbound adapter or gateway and if the transaction is active in the current thread of execution, the JPA operation is performed in the same transaction context.\nYou can also configure this JPA operation to run as a new transaction, as the following example shows:\n\n[source,xml]\n----\n<int-jpa:outbound-gateway\n request-channel=\"namedQueryRequestChannel\"\n reply-channel=\"namedQueryResponseChannel\"\n named-query=\"updateStudentByRollNumber\"\n entity-manager=\"em\"\n gateway-type=\"UPDATING\">\n <int-jpa:parameter name=\"lastName\" expression=\"payload\"/>\n <int-jpa:parameter name=\"rollNumber\" expression=\"headers['rollNumber']\"/>\n <int-jpa:transactional propagation=\"REQUIRES_NEW\"\n transaction-manager=\"transactionManager\"/>\n</int-jpa:outbound-gateway>\n----\n\nIn the preceding example, the transactional element of the outbound gateway or adapter specifies the transaction attributes.\nIt is optional to define this child element if you have `DirectChannel` as an input channel to the adapter, and you want the adapter to execute the operations in the same transaction context as the caller.\nIf, however, you use an `ExecutorChannel`, you must have the `transactional` element, because the invoking client's transaction context is not propagated.\n\nNOTE: Unlike the `transactional` element of the poller, which is defined in Spring Integration's namespace, the `transactional` element for the outbound gateway or adapter is defined in the JPA namespace.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/namespace-support.adoc", "title": "namespace-support", "heading": "Transaction Handling", "heading_level": 2, "file_order": 126, "section_index": 3, "content_hash": "a08c3e2fe8f607f04b2e63be725312925d0e00973982d756a2d0b66f7ced9165", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/namespace-support.adoc"}}
{"id": "sha256:c243fcd4eaeefac801fd8c778331f6b302be7481f9a738d0e80a1a2b0719aa28", "content": "[[jpa-outbound-channel-adapter]]\n\nThe JPA outbound channel adapter lets you accept messages over a request channel.\nThe payload can either be used as the entity to be persisted or used with the headers in the parameter expressions for a JPQL query.\nThe following sections cover the possible ways of performing these operations.\n\n[[jpa-outbound-channel-adapter-entity-class]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "outbound-channel-adapter", "heading_level": 1, "file_order": 127, "section_index": 0, "content_hash": "c243fcd4eaeefac801fd8c778331f6b302be7481f9a738d0e80a1a2b0719aa28", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc"}}
{"id": "sha256:f3e1783dab7352dc0c9031fbbd13f7157ffe001ce2aa3eff9ea339b4d574a448", "content": "The following XML configures the outbound channel adapter to persist an entity to the database:\n\n[source,xml]\n----\n<int-jpa:outbound-channel-adapter channel=\"entityTypeChannel\" <1>\n entity-class=\"org.springframework.integration.jpa.test.entity.Student\" <2>\n persist-mode=\"PERSIST\" <3>\n entity-manager=\"em\"/ > <4>\n----\n\n<1> The channel over which a valid JPA entity is sent to the JPA outbound channel adapter.\n<2> The fully qualified name of the entity class accepted by the adapter to be persisted in the database.\nYou can actually leave off this attribute in most cases as the adapter can determine the entity class automatically from the Spring Integration message payload.\n<3> The operation to be done by the adapter.\nThe valid values are `PERSIST`, `MERGE`, and `DELETE`.\nThe default value is `MERGE`.\n<4> The JPA entity manager to be used.\n\nThese four attributes of the `outbound-channel-adapter` configure it to accept entities over the input channel and process them to `PERSIST`, `MERGE`, or `DELETE` the entities from the underlying data source.\n\nNOTE: As of Spring Integration 3.0, payloads to `PERSIST` or `MERGE` can also be of type `https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Iterable.html[java.lang.Iterable]`.\nIn that case, each object returned by the `Iterable` is treated as an entity and persisted or merged using the underlying `EntityManager`.\nNull values returned by the iterator are ignored.\n\nNOTE: Starting with version 5.5.4, the `JpaOutboundGateway`, with a `JpaExecutor` configured with `PersistMode.DELETE`, can accept an `Iterable` payload to perform a batch removal persistent operation for the provided entities.\n\n[[jpa-using-jpaql]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "Using an Entity Class", "heading_level": 2, "file_order": 127, "section_index": 1, "content_hash": "f3e1783dab7352dc0c9031fbbd13f7157ffe001ce2aa3eff9ea339b4d574a448", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc"}}
{"id": "sha256:e65af083c93ad44648042c1c1c05bc3e6781ebc7764e7358e92f441aedd5d86d", "content": "The xref:jpa/outbound-channel-adapter.adoc#jpa-outbound-channel-adapter-entity-class[previous section] showed how to perform a `PERSIST` action by using an entity.\nThis section shows how to use an outbound channel adapter with JPA QL.\n\nThe following XML configures the outbound channel adapter to persist an entity to the database:\n\n[source,xml]\n----\n<int-jpa:outbound-channel-adapter channel=\"jpaQlChannel\" <1>\n jpa-query=\"update Student s set s.firstName = :firstName where s.rollNumber = :rollNumber\" <2>\n entity-manager=\"em\"> <3>\n <int-jpa:parameter name=\"firstName\" expression=\"payload['firstName']\"/> <4>\n <int-jpa:parameter name=\"rollNumber\" expression=\"payload['rollNumber']\"/>\n</int-jpa:outbound-channel-adapter>\n----\n\n<1> The input channel over which the message is sent to the outbound channel adapter.\n<2> The JPA QL to execute.\nThis query may contain parameters that are evaluated by using the `parameter` element.\n<3> The entity manager used by the adapter to perform the JPA operations.\n<4> The elements (one for each parameter) used to define the value of the parameter names for the JPA QL specified in the `query` attribute.\n\nThe `parameter` element accepts an attribute whose `name` corresponds to the named parameter specified in the provided JPA QL (point 2 in the preceding example).\nThe value of the parameter can either be static or be derived by using an expression.\nThe static value and the expression to derive the value are specified using the `value` and `expression` attributes, respectively.\nThese attributes are mutually exclusive.\n\nIf the `value` attribute is specified, you can provide an optional `type` attribute.\nThe value of this attribute is the fully qualified name of the class whose value is represented by the `value` attribute.\nBy default, the type is assumed to be a `java.lang.String`.\nThe following example shows how to define a JPA parameter:\n\n[source,xml]\n----\n<int-jpa:outbound-channel-adapter ...\n>\n <int-jpa:parameter name=\"level\" value=\"2\" type=\"java.lang.Integer\"/>\n <int-jpa:parameter name=\"name\" expression=\"payload['name']\"/>\n</int-jpa:outbound-channel-adapter>\n----\n\nAs the preceding example shows, you can use multiple `parameter` elements within an outbound channel adapter element and define some parameters by using expressions and others with static values.\nHowever, take care not to specify the same parameter name multiple times.\nYou should provide one `parameter` element for each named parameter specified in the JPA query.\nFor example, we specify two parameters: `level` and `name`.\nThe `level` attribute is a static value of type `java.lang.Integer`, while the `name` attribute is derived from the payload of the message.\n\nNOTE: Though specifying `select` is valid for JPA QL, it makes no sense to do so.\nOutbound channel adapters do not return any result.\nIf you want to select some values, consider using the outbound gateway instead.\n\n[[jpa-using-native-queries]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "Using JPA Query Language (JPA QL)", "heading_level": 2, "file_order": 127, "section_index": 2, "content_hash": "e65af083c93ad44648042c1c1c05bc3e6781ebc7764e7358e92f441aedd5d86d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc"}}
{"id": "sha256:d1dbde21cc0adbc9cdfd31e3436d6023bf2c3d10831c5cdbfd80187115ce9478", "content": "This section describes how to use native queries to perform operations with the JPA outbound channel adapter.\nUsing native queries is similar to using JPA QL, except that the queries are native database queries.\nBy using native queries, we lose database vendor independence, which we get using JPA QL.\n\nOne of the things we can achieve by using native queries is to perform database inserts, which is not possible with JPA QL.\n(To perform inserts, we send JPA entities to the channel adapter, as xref:jpa/outbound-channel-adapter.adoc#jpa-outbound-channel-adapter-entity-class[described earlier]).\nBelow is a small XML fragment that demonstrates the use of native query to insert values in a table.\n\nIMPORTANT: Named parameters may not be supported by your JPA provider in conjunction with native SQL queries.\nWhile they work fine with Hibernate, OpenJPA and EclipseLink do not support them.\nSee https://issues.apache.org/jira/browse/OPENJPA-111.\nSection 3.8.12 of the JPA 2.0 spec states: \"`Only positional parameter binding and positional access to result items may be portably used for native queries.`\"\n\nThe following example configures an outbound-channel-adapter with a native query:\n\n[source,xml]\n----\n<int-jpa:outbound-channel-adapter channel=\"nativeQlChannel\"\n native-query=\"insert into STUDENT_TABLE(FIRST_NAME,LAST_UPDATED) values (:lastName,:lastUpdated)\" <1>\n entity-manager=\"em\">\n <int-jpa:parameter name=\"lastName\" expression=\"payload['updatedLastName']\"/>\n <int-jpa:parameter name=\"lastUpdated\" expression=\"new java.util.Date()\"/>\n</int-jpa:outbound-channel-adapter>\n----\n\n<1> The native query executed by this outbound channel adapter.\n\nNote that the other attributes (such as `channel` and `entity-manager`) and the `parameter` element have the same semantics as they do for JPA QL.\n\n[[using-named-queries]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "Using Native Queries", "heading_level": 2, "file_order": 127, "section_index": 3, "content_hash": "d1dbde21cc0adbc9cdfd31e3436d6023bf2c3d10831c5cdbfd80187115ce9478", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc"}}
{"id": "sha256:254a3e82d924956fb6cba8b8d1de9881b4174e6d93e79f126d0570bcaddf7940", "content": "Using named queries is similar to using xref:jpa/outbound-channel-adapter.adoc#jpa-using-jpaql[JPA QL] or a xref:jpa/outbound-channel-adapter.adoc#jpa-using-native-queries[native query], except that we specify a named query instead of a query.\nFirst, we cover how to define a JPA named query.\nThen we cover how to declare an outbound channel adapter to work with a named query.\nIf we have an entity called `Student`, we can use annotations on the `Student` class to define two named queries: `selectStudent` and `updateStudent`.\nThe following example shows how to do so:\n\n[source,java]\n----\n@Entity\n@Table(name=\"Student\")\n@NamedQueries({\n @NamedQuery(name=\"selectStudent\",\n query=\"select s from Student s where s.lastName = 'Last One'\"),\n @NamedQuery(name=\"updateStudent\",\n query=\"update Student s set s.lastName = :lastName,\n lastUpdated = :lastUpdated where s.id in (select max(a.id) from Student a)\")\n})\npublic class Student {\n\n...\n}\n----\n\nAlternatively, you can use orm.xml to define named queries as the following example shows:\n\n[source,xml]\n----\n<entity-mappings ...>\n ...\n <named-query name=\"selectStudent\">\n <query>select s from Student s where s.lastName = 'Last One'</query>\n </named-query>\n</entity-mappings>\n----\n\nNow that we have shown how to define named queries by using annotations or by using `orm.xml`, we now show a small XML fragment that defines an `outbound-channel-adapter` by using a named query, as the following example shows:\n\n[source,xml]\n----\n<int-jpa:outbound-channel-adapter channel=\"namedQueryChannel\"\n named-query=\"updateStudent\" <1>\n entity-manager=\"em\">\n <int-jpa:parameter name=\"lastName\" expression=\"payload['updatedLastName']\"/>\n <int-jpa:parameter name=\"lastUpdated\" expression=\"new java.util.Date()\"/>\n</int-jpa:outbound-channel-adapter>\n----\n\n<1> The named query that we want the adapter to execute when it receives a message over the channel.\n\n[[jpaOutboundChannelAdapterParameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "Using Named Queries", "heading_level": 2, "file_order": 127, "section_index": 4, "content_hash": "254a3e82d924956fb6cba8b8d1de9881b4174e6d93e79f126d0570bcaddf7940", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc"}}
{"id": "sha256:4cdfd17d4864c881cff02193863ce3329ab51bcec5698c912572b491a22d92f3", "content": "The following listing shows all the attributes that you can set on an outbound channel adapter:\n\n[source,xml]\n----\n<int-jpa:outbound-channel-adapter\n auto-startup=\"true\" <1>\n channel=\"\" <2>\n entity-class=\"\" <3>\n entity-manager=\"\" <4>\n entity-manager-factory=\"\" <5>\n id=\"\"\n jpa-operations=\"\" <6>\n jpa-query=\"\" <7>\n named-query=\"\" <8>\n native-query=\"\" <9>\n order=\"\" <10>\n parameter-source-factory=\"\" <11>\n persist-mode=\"MERGE\" <12>\n flush=\"true\" <13>\n flush-size=\"10\" <14>\n clear-on-flush=\"true\" <15>\n use-payload-as-parameter-source=\"true\" <16>\n\t<int:poller/>\n\t<int-jpa:transactional/> <17>\n\t<int-jpa:parameter/> <18>\n</int-jpa:outbound-channel-adapter>\n----\n\n<1> Lifecycle attribute signaling whether this component should start during application context startup.\nIt defaults to `true`.\nOptional.\n<2> The channel from which the outbound adapter receives messages for performing the desired operation.\n<3> The fully qualified name of the entity class for the JPA Operation.\nThe `entity-class`, `query`, and `named-query` attributes are mutually exclusive.\nOptional.\n<4> An instance of `jakarta.persistence.EntityManager` used to perform the JPA operations.\nOptional.\n<5> An instance of `jakarta.persistence.EntityManagerFactory` used to obtain an instance of `jakarta.persistence.EntityManager`, which performs the JPA operations.\nOptional.\n<6> An implementation of `org.springframework.integration.jpa.core.JpaOperations` used to perform the JPA operations.\nWe recommend not providing an implementation of your own but using the default `org.springframework.integration.jpa.core.DefaultJpaOperations` implementation.\nYou can use any one of the `entity-manager`, `entity-manager-factory`, or `jpa-operations` attributes.\nOptional.\n<7> The JPA QL to be executed by this adapter.\nOptional.\n<8> The named query that needs to be executed by this adapter.\nOptional.\n<9> The native query to be executed by this adapter.\nYou can use any one of the `jpa-query`, `named-query`, or `native-query` attributes.\nOptional.\n<10> The order for this consumer when multiple consumers are registered, thereby managing load-balancing and failover.\nIt defaults to `Ordered.LOWEST_PRECEDENCE`.\nOptional.\n<11> An instance of `o.s.i.jpa.support.parametersource.ParameterSourceFactory` used to get an instance of `o.s.i.jpa.support.parametersource.ParameterSource`, which is used to resolve the values of the parameters in the query.\nIgnored if you perform operations by using a JPA entity.\nThe `parameter` sub-elements are mutually exclusive with the `parameter-source-factory` attribute and must be configured on the provided `ParameterSourceFactory`.\nOptional.\n<12> Accepts one of the following: `PERSIST`, `MERGE`, or `DELETE`.\nIndicates the operation that the adapter needs to perform.\nRelevant only if you use an entity for JPA operations.\nIgnored if you provide JPA QL, a named query, or a native query.\nIt defaults to `MERGE`.\nOptional.\nAs of Spring Integration 3.0, payloads to persist or merge can also be of type `https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html[java.lang.Iterable]`.\nIn that case, each object returned by the `Iterable` is treated as an entity and persisted or merged by using the underlying `EntityManager`.\nNull values returned by the iterator are ignored.\n<13> Set this value to `true` if you want to flush the persistence context immediately after persist, merge, or delete operations and do not want to rely on the `flushMode` of the `EntityManager`.\nIt defaults to `false`.\nApplies only if you did not specify the `flush-size` attribute.\nIf this attribute is set to `true`, `flush-size` is implicitly set to `1`, if no other value configured it.\n<14> Set this attribute to a value greater than '0' if you want to flush the persistence context immediately after persist, merge or delete operations and do not want to rely on the `flushMode` of the `EntityManager`.\nThe default value is set to `0`, which means \"'no flush'\".\nThis attribute is geared towards messages with `Iterable` payloads.\nFor instance, if `flush-size` is set to `3`, then `entityManager.flush()` is called after every third entity.\nFurthermore, `entityManager.flush()` is called once more after the entire loop.\nIf the 'flush-size' attribute specified with a value greater than '0', you need not configure the `flush` attribute.\n<15> Set this value to 'true' if you want to clear the persistence context immediately after each flush operation.\nThe attribute's value is applied only if the `flush` attribute is set to `true` or if the `flush-size` attribute is set to a value greater than `0`.\n<16> If set to `true`, the payload of the message is used as a source for parameters.\nIf set to `false`, however, the entire `Message` is available as a source for parameters.\nOptional.\n<17> Defines the transaction management attributes and the reference to the transaction manager to be used by the JPA adapter.\nOptional.\n<18> One or more `parameter` attributes -- one for each parameter used in the query.\nThe value or expression is evaluated to compute the value of the parameter.\nOptional.\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "Configuration Parameter Reference", "heading_level": 2, "file_order": 127, "section_index": 5, "content_hash": "4cdfd17d4864c881cff02193863ce3329ab51bcec5698c912572b491a22d92f3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc"}}
{"id": "sha256:189e7ff375ebb788667445130089f67c575a8e7ae494a7eb33dfc47493b61dbe", "content": "The following Spring Boot application shows an example of how to configure the outbound adapter with Java:\n\n[source, java]\n----\n@SpringBootApplication\n@EntityScan(basePackageClasses = StudentDomain.class)\n@IntegrationComponentScan\npublic class JpaJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(JpaJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Autowired\n private EntityManagerFactory entityManagerFactory;\n\n @MessagingGateway\n interface JpaGateway {\n\n @Gateway(requestChannel = \"jpaPersistChannel\")\n @Transactional\n void persistStudent(StudentDomain payload);\n\n }\n\n @Bean\n public JpaExecutor jpaExecutor() {\n JpaExecutor executor = new JpaExecutor(this.entityManagerFactory);\n jpaExecutor.setEntityClass(StudentDomain.class);\n jpaExecutor.setPersistMode(PersistMode.PERSIST);\n return executor;\n }\n\n @Bean\n @ServiceActivator(channel = \"jpaPersistChannel\")\n public MessageHandler jpaOutbound() {\n JpaOutboundGateway adapter = new JpaOutboundGateway(jpaExecutor());\n adapter.setProducesReply(false);\n return adapter;\n }\n\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 127, "section_index": 6, "content_hash": "189e7ff375ebb788667445130089f67c575a8e7ae494a7eb33dfc47493b61dbe", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc"}}
{"id": "sha256:5761d1bc7b09f606892ad350d1bb2368bee500f279cdaa523117ec3387e35573", "content": "The following Spring Boot application shows an example of how to configure the outbound adapter with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\n@EntityScan(basePackageClasses = StudentDomain.class)\npublic class JpaJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(JpaJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Autowired\n private EntityManagerFactory entityManagerFactory;\n\n @Bean\n public IntegrationFlow outboundAdapterFlow() {\n return f -> f\n .handle(Jpa.outboundAdapter(this.entityManagerFactory)\n .entityClass(StudentDomain.class)\n .persistMode(PersistMode.PERSIST),\n e -> e.transactional());\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc", "title": "outbound-channel-adapter", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 127, "section_index": 7, "content_hash": "5761d1bc7b09f606892ad350d1bb2368bee500f279cdaa523117ec3387e35573", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-channel-adapter.adoc"}}
{"id": "sha256:52bb833e2e9754dfccf05e5630ab148b60aa9c7b9e95d66b38ea955632c2c92b", "content": "[[jpa-outbound-gateways]]\n\nThe JPA inbound channel adapter lets you poll a database to retrieve one or more JPA entities.\nThe retrieved data is consequently used to start a Spring Integration flow that uses the retrieved data as a message payload.\n\nAdditionally, you can use JPA outbound channel adapters at the end of your flow in order to persist data, essentially stopping the flow at the end of the persistence operation.\n\nHowever, how can you execute JPA persistence operations in the middle of a flow? For example, you may have business data that you are processing in your Spring Integration message flow and that you would like to persist, yet you still need to use other components further downstream.\nAlternatively, instead of polling the database using a poller, you need to execute JPQL queries and actively retrieve data, which is then processed in subsequent components within your flow.\n\nThis is where JPA Outbound Gateways come into play.\nThey give you the ability to persist data as well as retrieving data.\nTo facilitate these uses, Spring Integration provides two types of JPA outbound gateways:\n\n* Updating outbound gateway\n* Retrieving outbound gateway\n\nWhenever the outbound gateway is used to perform an action that saves, updates, or solely deletes some records in the database, you need to use an updating outbound gateway.\nIf, for example, you use an `entity` to persist it, a merged and persisted entity is returned as a result.\nIn other cases, the number of records affected (updated or deleted) is returned instead.\n\nWhen retrieving (selecting) data from the database, we use a retrieving outbound gateway.\nWith a retrieving outbound gateway, we can use JPQL, Named Queries (native or JPQL-based), or Native Queries (SQL) for selecting the data and retrieving the results.\n\nAn updating outbound gateway is functionally similar to an outbound channel adapter, except that an updating outbound gateway sends a result to the gateway's reply channel after performing the JPA operation.\n\nA retrieving outbound gateway is similar to an inbound channel adapter.\n\nNOTE: We recommend you first read the xref:jpa/outbound-channel-adapter.adoc[Outbound Channel Adapter] section and the xref:jpa/inbound-channel-adapter.adoc[Inbound Channel Adapter] sections earlier in this chapter, as most of the common concepts are explained there.\n\nThis similarity was the main factor to use the central `JpaExecutor` class to unify common functionality as much as possible.\n\nCommon for all JPA outbound gateways and similar to the `outbound-channel-adapter`, we can use for performing various JPA operations:\n\n* Entity classes\n* JPA Query Language (JPQL)\n* Native query\n* Named query\n\nFor configuration examples see xref:jpa/outbound-gateways.adoc#outboundGatewaySamples[JPA Outbound Gateway Samples].\n\n[[jpa-outbound-gateway-common-parameters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-gateways.adoc", "title": "outbound-gateways", "heading": "outbound-gateways", "heading_level": 1, "file_order": 128, "section_index": 0, "content_hash": "52bb833e2e9754dfccf05e5630ab148b60aa9c7b9e95d66b38ea955632c2c92b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-gateways.adoc"}}
{"id": "sha256:05db2c371ea757634caf917279c62d4b6e037af1a2156eac12601ffd376291c3", "content": "JPA Outbound Gateways always have access to the Spring Integration `Message` as input.\nConsequently, the following parameters are available:\n\n`parameter-source-factory`::\nAn instance of `o.s.i.jpa.support.parametersource.ParameterSourceFactory` used to get an instance of `o.s.i.jpa.support.parametersource.ParameterSource`.\nThe `ParameterSource` is used to resolve the values of the parameters provided in the query.\nIf you perform operations by using a JPA entity, the `parameter-source-factory` attribute is ignored.\nThe `parameter` sub-elements are mutually exclusive with the `parameter-source-factory` and they have to be configured on the provided `ParameterSourceFactory`.\nOptional.\n\n`use-payload-as-parameter-source`::\nIf set to `true`, the payload of the `Message` is used as a source for parameters.\nIf set to `false`, the entire `Message` is available as a source for parameters.\nIf no JPA Parameters are passed in, this property defaults to `true`.\nThis means that, if you use a default `BeanPropertyParameterSourceFactory`, the bean properties of the payload are used as a source for parameter values for the JPA query.\nHowever, if JPA Parameters are passed in, this property, by default, evaluates to `false`.\nThe reason is that JPA Parameters let you provide SpEL Expressions.\nTherefore, it is highly beneficial to have access to the entire `Message`, including the headers.\nOptional.\n\n[[jpa-updating-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-gateways.adoc", "title": "outbound-gateways", "heading": "Common Configuration Parameters", "heading_level": 2, "file_order": 128, "section_index": 1, "content_hash": "05db2c371ea757634caf917279c62d4b6e037af1a2156eac12601ffd376291c3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-gateways.adoc"}}
{"id": "sha256:6eff4e26653dc1a0efac0bc8a5ddefba23a8475327c0de8d34c32f05907fa65e", "content": "The following listing shows all the attributes that you can set on an updating-outbound-gateway and describes the key attributes:\n\n[source,xml]\n----\n<int-jpa:updating-outbound-gateway request-channel=\"\" <1>\n auto-startup=\"true\"\n entity-class=\"\"\n entity-manager=\"\"\n entity-manager-factory=\"\"\n id=\"\"\n jpa-operations=\"\"\n jpa-query=\"\"\n named-query=\"\"\n native-query=\"\"\n order=\"\"\n parameter-source-factory=\"\"\n persist-mode=\"MERGE\"\n reply-channel=\"\" <2>\n reply-timeout=\"\" <3>\n use-payload-as-parameter-source=\"true\">\n\n <int:poller/>\n <int-jpa:transactional/>\n\n <int-jpa:parameter name=\"\" type=\"\" value=\"\"/>\n <int-jpa:parameter name=\"\" expression=\"\"/>\n</int-jpa:updating-outbound-gateway>\n----\n\n<1> The channel from which the outbound gateway receives messages for performing the desired operation.\nThis attribute is similar to the `channel` attribute of the `outbound-channel-adapter`.\nOptional.\n<2> The channel to which the gateway sends the response after performing the required JPA operation.\nIf this attribute is not defined, the request message must have a `replyChannel` header.\nOptional.\n<3> Specifies the time the gateway waits to send the result to the reply channel.\nOnly applies when the reply channel itself might block the send operation (for example, a bounded `QueueChannel` that is currently full).\nThe value is specified in milliseconds.\nOptional.\n\nThe remaining attributes are described earlier in this chapter.\nSee xref:jpa/inbound-channel-adapter.adoc#jpaInboundChannelAdapterParameters[Configuration Parameter Reference] and xref:jpa/outbound-channel-adapter.adoc#jpaOutboundChannelAdapterParameters[Configuration Parameter Reference].\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-gateways.adoc", "title": "outbound-gateways", "heading": "Updating Outbound Gateway", "heading_level": 2, "file_order": 128, "section_index": 2, "content_hash": "6eff4e26653dc1a0efac0bc8a5ddefba23a8475327c0de8d34c32f05907fa65e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-gateways.adoc"}}
{"id": "sha256:aff32d3f5bbd2d204868b83d28a60890aca48b3c6c43e2ede614ae68351f5d61", "content": "The following Spring Boot application shows an example of how configure the outbound adapter with Java:\n\n[source, java]\n----\n@SpringBootApplication\n@EntityScan(basePackageClasses = StudentDomain.class)\n@IntegrationComponentScan\npublic class JpaJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(JpaJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Autowired\n private EntityManagerFactory entityManagerFactory;\n\n @MessagingGateway\n interface JpaGateway {\n\n @Gateway(requestChannel = \"jpaUpdateChannel\")\n @Transactional\n void updateStudent(StudentDomain payload);\n\n }\n\n @Bean\n @ServiceActivator(channel = \"jpaUpdateChannel\")\n public MessageHandler jpaOutbound() {\n JpaOutboundGateway adapter =\n new JpaOutboundGateway(new JpaExecutor(this.entityManagerFactory));\n adapter.setOutputChannelName(\"updateResults\");\n return adapter;\n }\n\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-gateways.adoc", "title": "outbound-gateways", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 128, "section_index": 3, "content_hash": "aff32d3f5bbd2d204868b83d28a60890aca48b3c6c43e2ede614ae68351f5d61", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-gateways.adoc"}}
{"id": "sha256:e7bfcc3795a43440ecb33250518793bbe8004d7a4e8d4ddcd1002430845ddd25", "content": "The following Spring Boot application shows an example of how to configure the outbound adapter using the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\n@EntityScan(basePackageClasses = StudentDomain.class)\npublic class JpaJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(JpaJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Autowired\n private EntityManagerFactory entityManagerFactory;\n\n @Bean\n public IntegrationFlow updatingGatewayFlow() {\n return f -> f\n .handle(Jpa.updatingGateway(this.entityManagerFactory),\n e -> e.transactional(true))\n .channel(c -> c.queue(\"updateResults\"));\n }\n\n}\n----\n\n[[jpa-retrieving-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-gateways.adoc", "title": "outbound-gateways", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 128, "section_index": 4, "content_hash": "e7bfcc3795a43440ecb33250518793bbe8004d7a4e8d4ddcd1002430845ddd25", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-gateways.adoc"}}
{"id": "sha256:9b7f7c54e02186f2c7f76c692f264e8a462c695b3c3ee94263df04faac50875e", "content": "The following example demonstrates how to configure a retrieving outbound gateway:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@SpringBootApplication\n@EntityScan(basePackageClasses = StudentDomain.class)\npublic class JpaJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(JpaJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Autowired\n private EntityManagerFactory entityManagerFactory;\n\n @Bean\n public IntegrationFlow retrievingGatewayFlow() {\n return f -> f\n .handle(Jpa.retrievingGateway(this.entityManagerFactory)\n .jpaQuery(\"from Student s where s.id = :id\")\n .expectSingleResult(true)\n .parameterExpression(\"id\", \"payload\"))\n .channel(c -> c.queue(\"retrieveResults\"));\n }\n\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun retrievingGatewayFlow() =\n integrationFlow {\n handle(Jpa.retrievingGateway(this.entityManagerFactory)\n .jpaQuery(\"from Student s where s.id = :id\")\n .expectSingleResult(true)\n .parameterExpression(\"id\", \"payload\"))\n channel { queue(\"retrieveResults\") }\n }\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@SpringBootApplication\n@EntityScan(basePackageClasses = StudentDomain.class)\npublic class JpaJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(JpaJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Autowired\n private EntityManagerFactory entityManagerFactory;\n\n @Bean\n public JpaExecutor jpaExecutor() {\n JpaExecutor executor = new JpaExecutor(this.entityManagerFactory);\n jpaExecutor.setJpaQuery(\"from Student s where s.id = :id\");\n executor.setJpaParameters(Collections.singletonList(new JpaParameter(\"id\", null, \"payload\")));\n jpaExecutor.setExpectSingleResult(true);\n return executor;\n }\n\n @Bean\n @ServiceActivator(channel = \"jpaRetrievingChannel\")\n public MessageHandler jpaOutbound() {\n JpaOutboundGateway adapter = new JpaOutboundGateway(jpaExecutor());\n adapter.setOutputChannelName(\"retrieveResults\");\n adapter.setGatewayType(OutboundGatewayType.RETRIEVING);\n return adapter;\n }\n\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-jpa:retrieving-outbound-gateway request-channel=\"\"\n auto-startup=\"true\"\n delete-after-poll=\"false\"\n delete-in-batch=\"false\"\n entity-class=\"\"\n id-expression=\"\" <1>\n entity-manager=\"\"\n entity-manager-factory=\"\"\n expect-single-result=\"false\" <2>\n id=\"\"\n jpa-operations=\"\"\n jpa-query=\"\"\n max-results=\"\" <3>\n max-results-expression=\"\" <4>\n first-result=\"\" <5>\n first-result-expression=\"\" <6>\n named-query=\"\"\n native-query=\"\"\n order=\"\"\n parameter-source-factory=\"\"\n reply-channel=\"\"\n reply-timeout=\"\"\n use-payload-as-parameter-source=\"true\">\n <int:poller></int:poller>\n <int-jpa:transactional/>\n\n <int-jpa:parameter name=\"\" type=\"\" value=\"\"/>\n <int-jpa:parameter name=\"\" expression=\"\"/>\n</int-jpa:retrieving-outbound-gateway>\n----\n======\n\n<1> (Since Spring Integration 4.0) The SpEL expression that determines the `primaryKey` value for `EntityManager.find(Class entityClass, Object primaryKey)` method against the `requestMessage` as the root object of evaluation context.\nThe `entityClass` argument is determined from the `entity-class` attribute, if present.\nOtherwise, it is determined from the `payload` class.\nAll other attributes are disallowed if you use `id-expression`.\nOptional.\n<2> A boolean flag indicating whether the select operation is expected to return a single result or a `List` of results.\nIf this flag is set to `true`, a single entity is sent as the payload of the message.\nIf multiple entities are returned, an exception is thrown.\nIf `false`, the `List` of entities sent as the payload of the message.\nIt defaults to `false`.\nOptional.\n<3> This non-zero, non-negative integer value tells the adapter not to select more than the specified number of rows on execution of the select operation.\nBy default, if this attribute is not set, all the possible records are selected by a given query.\nThis attribute is mutually exclusive with `max-results-expression`.\nOptional.\n<4> An expression that can be used to find the maximum number of results in a result set.\nIt is mutually exclusive with `max-results`.\nOptional.\n<5> This non-zero, non-negative integer value tells the adapter the first record from which results are to be retrieved.\nThis attribute is mutually exclusive with `first-result-expression`.\nVersion 3.0 introduced this attribute.\nOptional.\n<6> This expression is evaluated against the message to find the position of the first record in the result set.\nThis attribute is mutually exclusive to `first-result`.\nVersion 3.0 introduced this attribute.\nOptional.\n\n[IMPORTANT]\n====\nWhen you choose to delete entities upon retrieval, and you have retrieved a collection of entities, by default, entities are deleted on a per-entity basis.\nThis may cause performance issues.\n\nAlternatively, you can set attribute `deleteInBatch` to `true`, which performs a batch delete.\nHowever, the limitation of doing so is that cascading deletes are not supported.\n\nJSR 317: Java Persistence 2.0 states in chapter 4.10, \"`Bulk Update and Delete Operations`\" that:\n\n\"`A delete operation only applies to entities of the specified class and its subclasses.\nIt does not cascade to related entities.`\"\n\nFor more information, see https://jcp.org/en/jsr/detail?id=317[JSR 317: Java Persistence 2.0]\n====\n\nNOTE: Starting with version 6.0, the `Jpa.retrievingGateway()` returns an empty list result when there are no entities returned by the query.\nPreviously `null` was returned ending the flow, or throwing an exception, depending on `requiresReply`.\nOr, to revert to the previous behavior, add a `filter` after the gateway to filter out empty lists.\nIt requires extra configuration in applications where empty list handling is a part of the downstream logic.\nSee xref:splitter.adoc#split-stream-and-flux[Splitter Discard Channel] for possible empty list handling options.\n\n[[outboundGatewaySamples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-gateways.adoc", "title": "outbound-gateways", "heading": "Retrieving Outbound Gateway", "heading_level": 2, "file_order": 128, "section_index": 5, "content_hash": "9b7f7c54e02186f2c7f76c692f264e8a462c695b3c3ee94263df04faac50875e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-gateways.adoc"}}
{"id": "sha256:b542cd1a6c577f69e228cdb31ef6bd07fdbe3220c3f62ee687e2e7d12c8a2a66", "content": "This section contains various examples of using the updating outbound gateway and the retrieving outbound gateway:\n\n[[update-by-using-an-entity-class]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-gateways.adoc", "title": "outbound-gateways", "heading": "JPA Outbound Gateway Samples", "heading_level": 2, "file_order": 128, "section_index": 6, "content_hash": "b542cd1a6c577f69e228cdb31ef6bd07fdbe3220c3f62ee687e2e7d12c8a2a66", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-gateways.adoc"}}
{"id": "sha256:533007b27e46d8a9d1100b7635339d91f72bb2696a547159ab4a8a2007fdb916", "content": "In the following example, an updating outbound gateway is persisted by using the `org.springframework.integration.jpa.test.entity.Student` entity class as a JPA defining parameter:\n\n[source,xml]\n----\n<int-jpa:updating-outbound-gateway request-channel=\"entityRequestChannel\" <1>\n reply-channel=\"entityResponseChannel\" <2>\n entity-class=\"org.springframework.integration.jpa.test.entity.Student\"\n entity-manager=\"em\"/>\n----\n\n<1> This is the request channel for the outbound gateway.\nIt is similar to the `channel` attribute of the `outbound-channel-adapter`.\n<2> This is where a gateway differs from an outbound adapter.\nThis is the channel over which the reply from the JPA operation is received.\nIf, however, you are not interested in the reply received and want only to perform the operation, using a JPA `outbound-channel-adapter` is the appropriate choice.\nIn this example, where we use an entity class, the reply is the entity object that was created or merged as a result of the JPA operation.\n\n[[update-using-jpql]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-gateways.adoc", "title": "outbound-gateways", "heading": "Update by Using an Entity Class", "heading_level": 3, "file_order": 128, "section_index": 7, "content_hash": "533007b27e46d8a9d1100b7635339d91f72bb2696a547159ab4a8a2007fdb916", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-gateways.adoc"}}
{"id": "sha256:a47bdae176440afb9cea4c49bf89c0109d025585b3686a0997332b1e26060f0e", "content": "The following example updates an entity by using the Java Persistence Query Language (JPQL),\nwhich mandates using an updating outbound gateway:\n\n[source,xml]\n----\n<int-jpa:updating-outbound-gateway request-channel=\"jpaqlRequestChannel\"\n reply-channel=\"jpaqlResponseChannel\"\n jpa-query=\"update Student s set s.lastName = :lastName where s.rollNumber = :rollNumber\" <1>\n entity-manager=\"em\">\n <int-jpa:parameter name=\"lastName\" expression=\"payload\"/>\n <int-jpa:parameter name=\"rollNumber\" expression=\"headers['rollNumber']\"/>\n</int-jpa:updating-outbound-gateway>\n----\n\n<1> The JPQL query that the gateway executes.\nSince we used updating outbound gateway, only `update` and `delete` JPQL queries would be sensible choices.\n\nWhen you send a message with a `String` payload that also contains a header called `rollNumber` with a `long` value, the last name of the student with the specified roll number is updated to the value in the message payload.\nWhen using an updating gateway, the return value is always an integer value, which denotes the number of records affected by execution of the JPA QL.\n\n[[retrieving-an-entity-using-jpql]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-gateways.adoc", "title": "outbound-gateways", "heading": "Update using JPQL", "heading_level": 3, "file_order": 128, "section_index": 8, "content_hash": "a47bdae176440afb9cea4c49bf89c0109d025585b3686a0997332b1e26060f0e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-gateways.adoc"}}
{"id": "sha256:202fd3ff640a0cefc5ee65ba37883fdcb24659f01f533b75373ce8178fc2d641", "content": "The following example uses a retrieving outbound gateway and JPQL to retrieve (select) one or more entities from the database:\n\n[source,xml]\n----\n<int-jpa:retrieving-outbound-gateway request-channel=\"retrievingGatewayReqChannel\"\n reply-channel=\"retrievingGatewayReplyChannel\"\n jpa-query=\"select s from Student s where s.firstName = :firstName and s.lastName = :lastName\"\n entity-manager=\"em\">\n <int-jpa:parameter name=\"firstName\" expression=\"payload\"/>\n <int-jpa:parameter name=\"lastName\" expression=\"headers['lastName']\"/>\n</int-jpa:outbound-gateway>\n----\n\n[[retrieving-an-entity-by-using-id-expression]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-gateways.adoc", "title": "outbound-gateways", "heading": "Retrieving an Entity using JPQL", "heading_level": 3, "file_order": 128, "section_index": 9, "content_hash": "202fd3ff640a0cefc5ee65ba37883fdcb24659f01f533b75373ce8178fc2d641", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-gateways.adoc"}}
{"id": "sha256:b277310e1465bac4fda360d8bc601ca799782299d994fe08ac594f2d830eb202", "content": "The following example uses a retrieving outbound gateway with `id-expression` to retrieve (find) one and only one entity from the database:\nThe `primaryKey` is the result of `id-expression` evaluation.\nThe `entityClass` is a class of Message `payload`.\n\n[source,xml]\n----\n<int-jpa:retrieving-outbound-gateway\n\trequest-channel=\"retrievingGatewayReqChannel\"\n reply-channel=\"retrievingGatewayReplyChannel\"\n id-expression=\"payload.id\"\n entity-manager=\"em\"/>\n----\n\n[[update-using-a-named-query]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-gateways.adoc", "title": "outbound-gateways", "heading": "Retrieving an Entity by Using `id-expression`", "heading_level": 3, "file_order": 128, "section_index": 10, "content_hash": "b277310e1465bac4fda360d8bc601ca799782299d994fe08ac594f2d830eb202", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-gateways.adoc"}}
{"id": "sha256:dc163fc96ca79f29e64487f5e1fbb9c13eec1623fd5265ae1fcfade771991ae5", "content": "Using a named query is basically the same as using a JPQL query directly.\nThe difference is that the `named-query` attribute is used instead, as the following example shows:\n\n[source,xml]\n----\n<int-jpa:updating-outbound-gateway request-channel=\"namedQueryRequestChannel\"\n reply-channel=\"namedQueryResponseChannel\"\n named-query=\"updateStudentByRollNumber\"\n entity-manager=\"em\">\n <int-jpa:parameter name=\"lastName\" expression=\"payload\"/>\n <int-jpa:parameter name=\"rollNumber\" expression=\"headers['rollNumber']\"/>\n</int-jpa:outbound-gateway>\n----\n\nNOTE: You can find a complete sample application that uses Spring Integration's JPA adapter https://github.com/spring-projects/spring-integration-samples/tree/main/basic/jpa[here].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/outbound-gateways.adoc", "title": "outbound-gateways", "heading": "Update using a Named Query", "heading_level": 3, "file_order": 128, "section_index": 11, "content_hash": "dc163fc96ca79f29e64487f5e1fbb9c13eec1623fd5265ae1fcfade771991ae5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/outbound-gateways.adoc"}}
{"id": "sha256:77f2d9eeb8d1e4a26ca9b0a6a886d278dfabc6864286e38ae4243f51f0603430", "content": "[[jpa-supported-persistence-providers]]\n\nThe Spring Integration JPA support has been tested against Hibernate persistence provider.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa/supported-persistence-providers.adoc", "title": "supported-persistence-providers", "heading": "supported-persistence-providers", "heading_level": 1, "file_order": 129, "section_index": 0, "content_hash": "77f2d9eeb8d1e4a26ca9b0a6a886d278dfabc6864286e38ae4243f51f0603430", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa/supported-persistence-providers.adoc"}}
{"id": "sha256:1a79ee08059e21a20c281ffd9196ad79de82e04f080864ff60dd8c2bc5afcd90", "content": "[[router-annotation]]\n\nWhen using `@Router` to annotate a method, the method may return either a `MessageChannel` or a `String` type.\nIn the latter case, the endpoint resolves the channel name as it does for the default output channel.\nAdditionally, the method may return either a single value or a collection.\nIf a collection is returned, the reply message is sent to multiple channels.\nTo summarize, the following method signatures are all valid:\n\n[source,java]\n----\n@Router\npublic MessageChannel route(Message message) {...}\n\n@Router\npublic List<MessageChannel> route(Message message) {...}\n\n@Router\npublic String route(Foo payload) {...}\n\n@Router\npublic List<String> route(Foo payload) {...}\n----\n\nIn addition to payload-based routing, a message may be routed based on metadata available within the message header as either a property or an attribute.\nIn this case, a method annotated with `@Router` may include a parameter annotated with `@Header`, which is mapped to a header value as the following example shows and documented in xref:configuration/annotations.adoc[Annotation Support]:\n\n[source,java]\n----\n@Router\npublic List<String> route(@Header(\"orderStatus\") OrderStatus status)\n----\n\nNOTE: For routing of XML-based Messages, including XPath support, see xref:xml.adoc[XML Support - Dealing with XML Payloads].\n\nSee also xref:dsl/java-routers.adoc[Message Routers] in the Java DSL chapter for more information about router configuration.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/annotation.adoc", "title": "annotation", "heading": "annotation", "heading_level": 1, "file_order": 130, "section_index": 0, "content_hash": "1a79ee08059e21a20c281ffd9196ad79de82e04f080864ff60dd8c2bc5afcd90", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/annotation.adoc"}}
{"id": "sha256:8bdf6d0a0639566976271dc7211e79101f20b9a3c12694ca38dd6a5fefd95434", "content": "[[router-common-parameters]]\n\nThis section describes the parameters common to all router parameters (the parameters with all their boxes ticked in the two tables shown earlier in this chapter).\n\n[[router-common-parameters-all]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/common-parameters.adoc", "title": "common-parameters", "heading": "common-parameters", "heading_level": 1, "file_order": 131, "section_index": 0, "content_hash": "8bdf6d0a0639566976271dc7211e79101f20b9a3c12694ca38dd6a5fefd95434", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/common-parameters.adoc"}}
{"id": "sha256:63f0c9a8d4bb0170758ae6c62e2ec31c072a98302e90c87b38ebb78dfb4183eb", "content": "The following parameters are valid for all routers inside and outside of chains.\n\n`apply-sequence`::\nThis attribute specifies whether sequence number and size headers should be added to each message.\nThis optional attribute defaults to `false`.\n\n`default-output-channel`::\nIf set, this attribute provides a reference to the channel where messages should be sent if channel resolution fails to return any channels.\nIf no default output channel is provided, the router throws an exception.\nIf you would like to silently drop those messages instead, set the default output channel attribute value to `nullChannel`.\n+\nNOTE: Starting with version 6.0, setting a default output channel also resets the `channelKeyFallback` option to `false`.\nSo, no attempts will be made to resolve a channel from its name, but rather fall back to this default output channel - similar to a Java `switch` statement.\nIf `channelKeyFallback` is set to `true` explicitly, the further logic depends on the `resolutionRequired` option: the message to a non-resolved channel from a key can reach a `defaultOutputChannel` only if `resolutionRequired` is `false`.\nTherefore, a configuration where `defaultOutputChannel` is provided and both `channelKeyFallback` & `resolutionRequired` are set to `true` is rejected by the `AbstractMappingMessageRouter` initialization phase.\n\n`resolution-required`::\nThis attribute specifies whether channel names must always be successfully resolved to channel instances that exist.\nIf set to `true`, a `MessagingException` is raised when the channel cannot be resolved.\nSetting this attribute to `false` causes any unresolvable channels to be ignored.\nThis optional attribute defaults to `true`.\n+\nNOTE: A Message is sent only to the `default-output-channel`, if specified, when `resolution-required` is `false` and the channel is not resolved.\n\n`ignore-send-failures`::\nIf set to `true`, failures to send to a message channel is ignored.\nIf set to `false`, a `MessageDeliveryException` is thrown instead, and, if the router resolves more than one channel, any subsequent channels do not receive the message.\n+\nThe exact behavior of this attribute depends on the type of the `Channel` to which the messages are sent.\nFor example, when using direct channels (single threaded), send failures can be caused by exceptions thrown by components much further downstream.\nHowever, when sending messages to a simple queue channel (asynchronous), the likelihood of an exception to be thrown is rather remote.\n+\nNOTE: While most routers route to a single channel, they can return more than one channel name.\nThe `recipient-list-router`, for instance, does exactly that.\nIf you set this attribute to `true` on a router that only routes to a single channel, any caused exception is swallowed, which usually makes little sense.\nIn that case, it would be better to catch the exception in an error flow at the flow entry point.\nTherefore, setting the `ignore-send-failures` attribute to `true` usually makes more sense when the router implementation returns more than one channel name, because the other channel(s) following the one that fails would still receive the message.\n+\nThis attribute defaults to `false`.\n\n`timeout`::\nThe `timeout` attribute specifies the maximum amount of time in milliseconds to wait when sending messages to the target Message Channels.\n\n[[router-common-parameters-top]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/common-parameters.adoc", "title": "common-parameters", "heading": "Inside and Outside a Chain", "heading_level": 2, "file_order": 131, "section_index": 1, "content_hash": "63f0c9a8d4bb0170758ae6c62e2ec31c072a98302e90c87b38ebb78dfb4183eb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/common-parameters.adoc"}}
{"id": "sha256:9e3b0cfdae208f7e50501eb8153256ed8bd4dfd7d2a4c54958ff4d6dce3fb4ba", "content": "The following parameters are valid only across all top-level routers that are outside of chains.\n\n`id`::\nIdentifies the underlying Spring bean definition, which, in the case of routers, is an instance of `EventDrivenConsumer` or `PollingConsumer`, depending on whether the router's `input-channel` is a `SubscribableChannel` or a `PollableChannel`, respectively.\nThis is an optional attribute.\n\n`auto-startup`::\nThis \"`lifecycle`\" attribute signaled whether this component should be started during startup of the application context.\nThis optional attribute defaults to `true`.\n\n`input-channel`::\nThe receiving message channel of this endpoint.\n\n`order`::\nThis attribute defines the order for invocation when this endpoint is connected as a subscriber to a channel.\nThis is particularly relevant when that channel uses a failover dispatching strategy.\nIt has no effect when this endpoint itself is a polling consumer for a channel with a queue.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/common-parameters.adoc", "title": "common-parameters", "heading": "Top-Level (Outside a Chain)", "heading_level": 2, "file_order": 131, "section_index": 2, "content_hash": "9e3b0cfdae208f7e50501eb8153256ed8bd4dfd7d2a4c54958ff4d6dce3fb4ba", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/common-parameters.adoc"}}
{"id": "sha256:de79efe1092f373e0a8a42015611c69428a795ee1d6f99f1650867f61c604474", "content": "[[dynamic-routers]]\n\nSpring Integration provides quite a few different router configurations for common content-based routing use cases as well as the option of implementing custom routers as POJOs.\nFor example, `PayloadTypeRouter` provides a simple way to configure a router that computes channels based on the payload type of the incoming message while `HeaderValueRouter` provides the same convenience in configuring a router that computes channels by evaluating the value of a particular message Header.\nThere are also expression-based (SpEL) routers, in which the channel is determined based on evaluating an expression.\nAll of these type of routers exhibit some dynamic characteristics.\n\nHowever, these routers all require static configuration.\nEven in the case of expression-based routers, the expression itself is defined as part of the router configuration, which means that the same expression operating on the same value always results in the computation of the same channel.\nThis is acceptable in most cases, since such routes are well-defined and therefore predictable.\nBut there are times when we need to change router configurations dynamically so that message flows may be routed to a different channel.\n\nFor example, you might want to bring down some part of your system for maintenance and temporarily re-reroute messages to a different message flow.\nAs another example, you may want to introduce more granularity to your message flow by adding another route to handle a more concrete type of `java.lang.Number` (in the case of `PayloadTypeRouter`).\n\nUnfortunately, with static router configuration to accomplish either of those goals, you would have to bring down your entire application, change the configuration of the router (change routes), and bring the application back up.\nThis is obviously not a solution anyone wants.\n\nThe https://www.enterpriseintegrationpatterns.com/DynamicRouter.html[dynamic router] pattern describes the mechanisms by which you can change or configure routers dynamically without bringing down the system or individual routers.\n\nBefore we get into the specifics of how Spring Integration supports dynamic routing, we need to consider the typical flow of a router:\n\n. Compute a channel identifier, which is a value calculated by the router once it receives the message.\nTypically, it is a String or an instance of the actual `MessageChannel`.\n. Resolve the channel identifier to a channel name.\nWe describe specifics of this process later in this section.\n. Resolve the channel name to the actual `MessageChannel`\n\nThere is not much that can be done with regard to dynamic routing if Step 1 results in the actual instance of the `MessageChannel`, because the `MessageChannel` is the final product of any router's job.\nHowever, if the first step results in a channel identifier that is not an instance of `MessageChannel`, you have quite a few possible ways to influence the process of deriving the `MessageChannel`.\nConsider the following example of a payload type router:\n\n[source,xml]\n----\n<int:payload-type-router input-channel=\"routingChannel\">\n <int:mapping type=\"java.lang.String\" channel=\"channel1\" />\n <int:mapping type=\"java.lang.Integer\" channel=\"channel2\" />\n</int:payload-type-router>\n----\n\nWithin the context of a payload type router, the three steps mentioned earlier would be realized as follows:\n\n. Compute a channel identifier that is the fully qualified name of the payload type (for example, `java.lang.String`).\n. Resolve the channel identifier to a channel name, where the result of the previous step is used to select the appropriate value from the payload type mapping defined in the `mapping` element.\n. Resolve the channel name to the actual instance of the `MessageChannel` as a reference to a bean within the application context (which is hopefully a `MessageChannel`) identified by the result of the previous step.\n\nIn other words, each step feeds the next step until the process completes.\n\nNow consider an example of a header value router:\n\n[source,xml]\n----\n<int:header-value-router input-channel=\"inputChannel\" header-name=\"testHeader\">\n <int:mapping value=\"foo\" channel=\"fooChannel\" />\n <int:mapping value=\"bar\" channel=\"barChannel\" />\n</int:header-value-router>\n----\n\nNow we can consider how the three steps work for a header value router:\n\n. Compute a channel identifier that is the value of the header identified by the `header-name` attribute.\n. Resolve the channel identifier to a channel name, where the result of the previous step is used to select the appropriate value from the general mapping defined in the `mapping` element.\n. Resolve the channel name to the actual instance of the `MessageChannel` as a reference to a bean within the application context (which is hopefully a `MessageChannel`) identified by the result of the previous step.\n\nThe preceding two configurations of two different router types look almost identical.\nHowever, if you look at the alternate configuration of the `HeaderValueRouter` we clearly see that there is no `mapping` sub element, as the following listing shows:\n\n[source,xml]\n----\n<int:header-value-router input-channel=\"inputChannel\" header-name=\"testHeader\"/>\n----\n\nHowever, the configuration is still perfectly valid.\nSo the natural question is what about the mapping in the second step?\n\nThe second step is now optional.\nIf `mapping` is not defined, then the channel identifier value computed in the first step is automatically treated as the `channel name`, which is now resolved to the actual `MessageChannel`, as in the third step.\nWhat it also means is that the second step is one of the key steps to providing dynamic characteristics to the routers, since it introduces a process that lets you change the way channel identifier resolves to the channel name, thus influencing the process of determining the final instance of the `MessageChannel` from the initial channel identifier.\n\nFor example, in the preceding configuration, assume that the `testHeader` value is 'kermit', which is now a channel identifier (the first step).\nSince there is no mapping in this router, resolving this channel identifier to a channel name (the second step) is impossible and this channel identifier is now treated as the channel name.\nHowever, what if there was a mapping but for a different value?\nThe end result would still be the same, because, if a new value cannot be determined through the process of resolving the channel identifier to a channel name, the channel identifier becomes the channel name.\n\nAll that is left is for the third step to resolve the channel name ('kermit') to an actual instance of the `MessageChannel` identified by this name.\nThat basically involves a bean lookup for the provided name.\nNow all messages that contain the header-value pair as `testHeader=kermit` are going to be routed to a `MessageChannel` whose bean name (its `id`) is 'kermit'.\n\nBut what if you want to route these messages to the 'simpson' channel? Obviously changing a static configuration works, but doing so also requires bringing your system down.\nHowever, if you have had access to the channel identifier map, you could introduce a new mapping where the header-value pair is now `kermit=simpson`, thus letting the second step treat 'kermit' as a channel identifier while resolving it to 'simpson' as the channel name.\n\nThe same obviously applies for `PayloadTypeRouter`, where you can now remap or remove a particular payload type mapping.\nIn fact, it applies to every other router, including expression-based routers, since their computed values now have a chance to go through the second step to be resolved to the actual `channel name`.\n\nAny router that is a subclass of the `AbstractMappingMessageRouter` (which includes most framework-defined routers) is a dynamic router, because the `channelMapping` is defined at the `AbstractMappingMessageRouter` level.\nThat map's setter method is exposed as a public method along with the 'setChannelMapping' and 'removeChannelMapping' methods.\nThese let you change, add, and remove router mappings at runtime, as long as you have a reference to the router itself.\nIt also means that you could expose these same configuration options through JMX (see xref:jmx.adoc[JMX Support]) or the Spring Integration control bus (see xref:control-bus.adoc[Control Bus]) functionality.\n\nIMPORTANT: Falling back to the channel key as the channel name is flexible and convenient.\nHowever, if you don't trust the message creator, a malicious actor (who has knowledge of the system) could create a message that is routed to an unexpected channel.\nFor example, if the key is set to the channel name of the router's input channel, such a message would be routed back to the router, eventually resulting in a stack overflow error.\nYou may therefore wish to disable this feature (set the `channelKeyFallback` property to `false`), and change the mappings instead if needed.\n\n[[dynamic-routers-control-bus]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/dynamic-routers.adoc", "title": "dynamic-routers", "heading": "dynamic-routers", "heading_level": 1, "file_order": 132, "section_index": 0, "content_hash": "de79efe1092f373e0a8a42015611c69428a795ee1d6f99f1650867f61c604474", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/dynamic-routers.adoc"}}
{"id": "sha256:43d33f54420b190fb994ec0084674c579b1c81c42f0f278e5fe9b2e7cd902a1f", "content": "One way to manage the router mappings is through the https://www.enterpriseintegrationpatterns.com/ControlBus.html[control bus] pattern, which exposes a control channel to which you can send control messages to manage and monitor Spring Integration components, including routers.\n\nNOTE: For more information about the control bus, see xref:control-bus.adoc[Control Bus].\n\nTypically, you would send a control message asking to invoke a particular operation on a particular managed component (such as a router).\nThe following managed operations (methods) are specific to changing the router resolution process:\n\n* `public void setChannelMapping(String key, String channelName)`: Lets you add a new or modify an existing mapping between `channel identifier` and `channel name`\n* `public void removeChannelMapping(String key)`: Lets you remove a particular channel mapping, thus disconnecting the relationship between `channel identifier` and `channel name`\n\nNote that these methods can be used for simple changes (such as updating a single route or adding or removing a route).\nHowever, if you want to remove one route and add another, the updates are not atomic.\nThis means that the routing table may be in an indeterminate state between the updates.\nStarting with version 4.0, you can now use the control bus to update the entire routing table atomically.\nThe following methods let you do so:\n\n* `public Map<String, String>getChannelMappings()`: Returns the current mappings.\n* `public void replaceChannelMappings(Properties channelMappings)`: Updates the mappings.\nNote that the `channelMappings` parameter is a `Properties` object, so this has to be added to the respective `IntegrationMessageHeaderAccessor.CONTROL_BUS_ARGUMENTS` header:\n\n[source]\n----\nProperties newMapping = new Properties();\nnewMapping.setProperty(\"foo\", \"bar\");\nnewMapping.setProperty(\"baz\", \"qux\");\nMessage<?> replaceChannelMappingsCommandMessage =\n MessageBuilder.withPayload(\"'router.handler'.replaceChannelMappings\")\n .setHeader(IntegrationMessageHeaderAccessor.CONTROL_BUS_ARGUMENTS, List.of(newMapping))\n .build();\n----\n\nFor programmatic changes to the map, we recommend that you use the `setChannelMappings` method, due to type-safety concerns.\n`replaceChannelMappings` ignores keys or values that are not `String` objects.\n\n[[dynamic-routers-jmx]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/dynamic-routers.adoc", "title": "dynamic-routers", "heading": "Manage Router Mappings using the Control Bus", "heading_level": 2, "file_order": 132, "section_index": 1, "content_hash": "43d33f54420b190fb994ec0084674c579b1c81c42f0f278e5fe9b2e7cd902a1f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/dynamic-routers.adoc"}}
{"id": "sha256:5789ecbe43a38013da26c407de4f37c927de85d719ca6db3ae725d3f7882b109", "content": "You can also use Spring's JMX support to expose a router instance and then use your favorite JMX client, (for example, JConsole) to manage those operations (methods) for changing the router's configuration.\n\nNOTE: For more information about Spring Integration's JMX support, see xref:jmx.adoc[JMX Support].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/dynamic-routers.adoc", "title": "dynamic-routers", "heading": "Manage Router Mappings by Using JMX", "heading_level": 2, "file_order": 132, "section_index": 2, "content_hash": "5789ecbe43a38013da26c407de4f37c927de85d719ca6db3ae725d3f7882b109", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/dynamic-routers.adoc"}}
{"id": "sha256:9b3ed09c28671b9e0b7aeff53b99196e1e542732b47cbb0120f9de8f98188c83", "content": "[[router-implementations]]\n\nSince content-based routing often requires some domain-specific logic, most use cases require Spring Integration's options for delegating to POJOs by using either the XML namespace support or annotations.\nBoth of these are discussed later.\nHowever, we first present a couple of implementations that fulfill common requirements.\n\n[[router-implementations-payloadtyperouter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/implementations.adoc", "title": "implementations", "heading": "implementations", "heading_level": 1, "file_order": 133, "section_index": 0, "content_hash": "9b3ed09c28671b9e0b7aeff53b99196e1e542732b47cbb0120f9de8f98188c83", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/implementations.adoc"}}
{"id": "sha256:12789578feeb4b324da8d4d210d12696e2a1e269d6336191388cf8d318cd7843", "content": "A `PayloadTypeRouter` sends messages to the channel defined by payload-type mappings, as the following example shows:\n\n[source,xml]\n----\n<bean id=\"payloadTypeRouter\"\n class=\"org.springframework.integration.router.PayloadTypeRouter\">\n <property name=\"channelMapping\">\n <map>\n <entry key=\"java.lang.String\" value-ref=\"stringChannel\"/>\n <entry key=\"java.lang.Integer\" value-ref=\"integerChannel\"/>\n </map>\n </property>\n</bean>\n----\n\nConfiguration of the `PayloadTypeRouter` is also supported by the namespace provided by Spring Integration (see `xref:configuration/namespace.adoc[Namespace Support]`), which essentially simplifies configuration by combining the `<router/>` configuration and its corresponding implementation (defined by using a `<bean/>` element) into a single and more concise configuration element.\nThe following example shows a `PayloadTypeRouter` configuration that is equivalent to the one above but uses the namespace support:\n\n[source,xml]\n----\n<int:payload-type-router input-channel=\"routingChannel\">\n <int:mapping type=\"java.lang.String\" channel=\"stringChannel\" />\n <int:mapping type=\"java.lang.Integer\" channel=\"integerChannel\" />\n</int:payload-type-router>\n----\n\nThe following example shows the equivalent router configured in Java:\n\n[source, java]\n----\n@ServiceActivator(inputChannel = \"routingChannel\")\n@Bean\npublic PayloadTypeRouter router() {\n PayloadTypeRouter router = new PayloadTypeRouter();\n router.setChannelMapping(String.class.getName(), \"stringChannel\");\n router.setChannelMapping(Integer.class.getName(), \"integerChannel\");\n return router;\n}\n----\n\nWhen using the Java DSL, there are two options.\n\nFirst, you can define the router object as shown in the preceding example:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow routerFlow1() {\n return IntegrationFlow.from(\"routingChannel\")\n .route(router())\n .get();\n}\n\npublic PayloadTypeRouter router() {\n PayloadTypeRouter router = new PayloadTypeRouter();\n router.setChannelMapping(String.class.getName(), \"stringChannel\");\n router.setChannelMapping(Integer.class.getName(), \"integerChannel\");\n return router;\n}\n----\n\nNote that the router can be, but does not have to be, a `@Bean`.\nThe flow registers it if it is not a `@Bean`.\n\nSecond, you can define the routing function within the DSL flow itself, as the following example shows:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow routerFlow2() {\n return IntegrationFlow.from(\"routingChannel\")\n .<Object, Class<?>>route(Object::getClass, m -> m\n .channelMapping(String.class, \"stringChannel\")\n .channelMapping(Integer.class, \"integerChannel\"))\n .get();\n}\n----\n\n[[router-implementations-headervaluerouter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/implementations.adoc", "title": "implementations", "heading": "`PayloadTypeRouter`", "heading_level": 2, "file_order": 133, "section_index": 1, "content_hash": "12789578feeb4b324da8d4d210d12696e2a1e269d6336191388cf8d318cd7843", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/implementations.adoc"}}
{"id": "sha256:2641e4d2f5bc926dcb76621e6f44f350651057120fdd878a44adf12b77714e45", "content": "A `HeaderValueRouter` sends Messages to the channel based on the individual header value mappings.\nWhen a `HeaderValueRouter` is created, it is initialized with the name of the header to be evaluated.\nThe value of the header could be one of two things:\n\n* An arbitrary value\n* A channel name\n\nIf it is an arbitrary value, additional mappings for these header values to channel names are required.\nOtherwise, no additional configuration is needed.\n\nSpring Integration provides a simple namespace-based XML configuration to configure a `HeaderValueRouter`.\nThe following example demonstrates configuration for the `HeaderValueRouter` when mapping of header values to channels is required:\n\n[source,xml]\n----\n<int:header-value-router input-channel=\"routingChannel\" header-name=\"testHeader\">\n <int:mapping value=\"someHeaderValue\" channel=\"channelA\" />\n <int:mapping value=\"someOtherHeaderValue\" channel=\"channelB\" />\n</int:header-value-router>\n----\n\nDuring the resolution process, the router defined in the preceding example may encounter channel resolution failures, causing an exception.\nIf you want to suppress such exceptions and send unresolved messages to the default output channel (identified with the `default-output-channel` attribute) set `resolution-required` to `false`.\n\nNormally, messages for which the header value is not explicitly mapped to a channel are sent to the `default-output-channel`.\nHowever, when the header value is mapped to a channel name but the channel cannot be resolved, setting the `resolution-required` attribute to `false` results in routing such messages to the `default-output-channel`.\n\nThe following example shows the equivalent router configured in Java:\n\n[source, java]\n----\n@ServiceActivator(inputChannel = \"routingChannel\")\n@Bean\npublic HeaderValueRouter router() {\n HeaderValueRouter router = new HeaderValueRouter(\"testHeader\");\n router.setChannelMapping(\"someHeaderValue\", \"channelA\");\n router.setChannelMapping(\"someOtherHeaderValue\", \"channelB\");\n return router;\n}\n----\n\nWhen using the Java DSL, there are two options.\nFirst, you can define the router object as shown in the preceding example:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow routerFlow1() {\n return IntegrationFlow.from(\"routingChannel\")\n .route(router())\n .get();\n}\n\npublic HeaderValueRouter router() {\n HeaderValueRouter router = new HeaderValueRouter(\"testHeader\");\n router.setChannelMapping(\"someHeaderValue\", \"channelA\");\n router.setChannelMapping(\"someOtherHeaderValue\", \"channelB\");\n return router;\n}\n----\n\nNote that the router can be, but does not have to be, a `@Bean`.\nThe flow registers it if it is not a `@Bean`.\n\nSecond, you can define the routing function within the DSL flow itself, as the following example shows:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow routerFlow2() {\n return IntegrationFlow.from(\"routingChannel\")\n .route(Message.class, m -> m.getHeaders().get(\"testHeader\", String.class),\n m -> m\n .channelMapping(\"someHeaderValue\", \"channelA\")\n .channelMapping(\"someOtherHeaderValue\", \"channelB\"),\n e -> e.id(\"headerValueRouter\"))\n .get();\n}\n----\n\nConfiguration where mapping of header values to channel names is not required, because header values themselves represent channel names.\nThe following example shows a router that does not require mapping of header values to channel names:\n\n[source,xml]\n----\n<int:header-value-router input-channel=\"routingChannel\" header-name=\"testHeader\"/>\n----\n\n[NOTE]\n=====\nSince Spring Integration 2.1, the behavior of resolving channels is more explicit.\nFor example, if you omit the `default-output-channel` attribute, the router was unable to resolve at least one valid channel, and any channel name resolution failures were ignored by setting `resolution-required` to `false`, then a `MessageDeliveryException` is thrown.\n\nBasically, by default, the router must be able to route messages successfully to at least one channel.\nIf you really want to drop messages, you must also have `default-output-channel` set to `nullChannel`.\n=====\n\n[[router-implementations-recipientlistrouter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/implementations.adoc", "title": "implementations", "heading": "`HeaderValueRouter`", "heading_level": 2, "file_order": 133, "section_index": 2, "content_hash": "2641e4d2f5bc926dcb76621e6f44f350651057120fdd878a44adf12b77714e45", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/implementations.adoc"}}
{"id": "sha256:623c568fa1f10ab3317091d46ecb80d79d5353a56271dd2196c784f5e2343e1f", "content": "A `RecipientListRouter` sends each received message to a statically defined list of message channels.\nThe following example creates a `RecipientListRouter`:\n\n[source,xml]\n----\n<bean id=\"recipientListRouter\"\n class=\"org.springframework.integration.router.RecipientListRouter\">\n <property name=\"channels\">\n <list>\n <ref bean=\"channel1\"/>\n <ref bean=\"channel2\"/>\n <ref bean=\"channel3\"/>\n </list>\n </property>\n</bean>\n----\n\nSpring Integration also provides namespace support for the `RecipientListRouter` configuration (see xref:configuration/namespace.adoc[Namespace Support]) as the following example shows:\n\n[source,xml]\n----\n<int:recipient-list-router id=\"customRouter\" input-channel=\"routingChannel\"\n timeout=\"1234\"\n ignore-send-failures=\"true\"\n apply-sequence=\"true\">\n <int:recipient channel=\"channel1\"/>\n <int:recipient channel=\"channel2\"/>\n</int:recipient-list-router>\n----\n\nThe following example shows the equivalent router configured in Java:\n\n[source, java]\n----\n@ServiceActivator(inputChannel = \"routingChannel\")\n@Bean\npublic RecipientListRouter router() {\n RecipientListRouter router = new RecipientListRouter();\n router.setSendTimeout(1_234L);\n router.setIgnoreSendFailures(true);\n router.setApplySequence(true);\n router.addRecipient(\"channel1\");\n router.addRecipient(\"channel2\");\n router.addRecipient(\"channel3\");\n return router;\n}\n----\n\nThe following example shows the equivalent router configured by using the Java DSL:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow routerFlow() {\n return IntegrationFlow.from(\"routingChannel\")\n .routeToRecipients(r -> r\n .applySequence(true)\n .ignoreSendFailures(true)\n .recipient(\"channel1\")\n .recipient(\"channel2\")\n .recipient(\"channel3\")\n .sendTimeout(1_234L))\n .get();\n}\n----\n\nNOTE: The 'apply-sequence' flag here has the same effect as it does for a publish-subscribe-channel, and, as with a publish-subscribe-channel, it is disabled by default on the `recipient-list-router`.\nSee xref:channel/configuration.adoc#channel-configuration-pubsubchannel[`PublishSubscribeChannel` Configuration] for more information.\n\nAnother convenient option when configuring a `RecipientListRouter` is to use Spring Expression Language (SpEL) support as selectors for individual recipient channels.\nDoing so is similar to using a filter at the beginning of a 'chain' to act as a \"`selective consumer`\".\nHowever, in this case, it is all combined rather concisely into the router's configuration, as the following example shows:\n\n[source,xml]\n----\n<int:recipient-list-router id=\"customRouter\" input-channel=\"routingChannel\">\n <int:recipient channel=\"channel1\" selector-expression=\"payload.equals('foo')\"/>\n <int:recipient channel=\"channel2\" selector-expression=\"headers.containsKey('bar')\"/>\n</int:recipient-list-router>\n----\n\nIn the preceding configuration, a SpEL expression identified by the `selector-expression` attribute is evaluated to determine whether this recipient should be included in the recipient list for a given input message.\nThe evaluation result of the expression must be a `boolean`.\nIf this attribute is not defined, the channel is always among the list of recipients.\n\n[[recipient-list-router-management]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/implementations.adoc", "title": "implementations", "heading": "`RecipientListRouter`", "heading_level": 2, "file_order": 133, "section_index": 3, "content_hash": "623c568fa1f10ab3317091d46ecb80d79d5353a56271dd2196c784f5e2343e1f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/implementations.adoc"}}
{"id": "sha256:be5d735332a6eeb6a08bf7db2bde662345d669e2c5b5c16a62e57914ba62b860", "content": "Starting with version 4.1, the `RecipientListRouter` provides several operations to manipulate recipients dynamically at runtime.\nThese management operations are presented by `RecipientListRouterManagement` through the `@ManagedResource` annotation.\nThey are available by using xref:control-bus.adoc[Control Bus] as well as by using JMX, as the following example shows:\n\n[source,xml]\n----\n<control-bus input-channel=\"controlBus\"/>\n\n<recipient-list-router id=\"simpleRouter\" input-channel=\"routingChannelA\">\n <recipient channel=\"channel1\"/>\n</recipient-list-router>\n\n<channel id=\"channel2\"/>\n----\n[source,java]\n----\nMessage<?> addRecipientCommandMessage =\n MessageBuilder.withPayload(\"'simpleRouter.handler'.addRecipient\")\n .setHeader(IntegrationMessageHeaderAccessor.CONTROL_BUS_ARGUMENTS, List.of(\"channel2\"))\n .build();\n----\n\nFrom the application startup the `simpleRouter`, has only one `channel1` recipient.\nBut after the `addRecipient` command, `channel2` recipient is added.\nIt is a \"`registering an interest in something that is part of the message`\" use case when we may be interested in messages from the router at some time period, so we are subscribing to the `recipient-list-router` and, at some point, decide to unsubscribe.\n\nBecause of the runtime management operation for the `<recipient-list-router>`, it can be configured without any `<recipient>` from the start.\nIn this case, the behavior of `RecipientListRouter` is the same when there is no one matching recipient for the message.\nIf `defaultOutputChannel` is configured, the message is sent there.\nOtherwise, the `MessageDeliveryException` is thrown.\n\n[[router-implementations-xpath-router]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/implementations.adoc", "title": "implementations", "heading": "`RecipientListRouterManagement`", "heading_level": 2, "file_order": 133, "section_index": 4, "content_hash": "be5d735332a6eeb6a08bf7db2bde662345d669e2c5b5c16a62e57914ba62b860", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/implementations.adoc"}}
{"id": "sha256:54050f09646d2cc5b79d2a8b85743bb8691bc80bf48d8269f057c569c2054021", "content": "The XPath Router is part of the XML Module.\nSee xref:xml/xpath-routing.adoc[Routing XML Messages with XPath].\n\n[[router-implementations-exception-router]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/implementations.adoc", "title": "implementations", "heading": "XPath Router", "heading_level": 2, "file_order": 133, "section_index": 5, "content_hash": "54050f09646d2cc5b79d2a8b85743bb8691bc80bf48d8269f057c569c2054021", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/implementations.adoc"}}
{"id": "sha256:cb1a403906add4325cd63746e47eae1ed45e19d1d4d5d1d5a6341f9cf6409378", "content": "Spring Integration also provides a special type-based router called `ErrorMessageExceptionTypeRouter` for routing error messages (defined as messages whose `payload` is a `Throwable` instance).\n`ErrorMessageExceptionTypeRouter` is similar to the `PayloadTypeRouter`.\nIn fact, they are almost identical.\nThe only difference is that, while `PayloadTypeRouter` navigates the instance hierarchy of a payload instance, (for example, `payload.getClass().getSuperclass()`) to find the most specific type and channel mappings, the `ErrorMessageExceptionTypeRouter` navigates the hierarchy of 'exception causes' (for example, `payload.getCause()`) to find the most specific `Throwable` type or channel mappings and uses `mappingClass.isInstance(cause)` to match the `cause` to the class or any super class.\n\nIMPORTANT: The channel mapping order in this case matters.\nSo, if there is a requirement to get mapping for an `IllegalArgumentException`, but not a `RuntimeException`, the last one must be configured on router first.\n\nNOTE: Since version 4.3 the `ErrorMessageExceptionTypeRouter` loads all mapping classes during the initialization phase to fail-fast for a `ClassNotFoundException`.\n\nThe following example shows a sample configuration for `ErrorMessageExceptionTypeRouter`:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return f -> f\n .routeByException(r -> r\n .channelMapping(IllegalArgumentException.class, \"illegalChannel\")\n .channelMapping(NullPointerException.class, \"npeChannel\")\n .defaultOutputChannel(\"defaultChannel\"));\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun someFlow() =\n integrationFlow {\n routeByException {\n channelMapping(IllegalArgumentException::class.java, \"illegalChannel\")\n channelMapping(NullPointerException::class.java, \"npeChannel\")\n defaultOutputChannel(\"defaultChannel\")\n }\n }\n----\n\nGroovy DSL::\n+\n[source, groovy, role=\"secondary\"]\n----\n@Bean\nsomeFlow() {\n integrationFlow {\n routeByException {\n channelMapping IllegalArgumentException, 'illegalChannel'\n channelMapping NullPointerException, 'npeChannel'\n defaultOutputChannel 'defaultChannel'\n }\n }\n}\n----\n\nXML DSL::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:exception-type-router input-channel=\"inputChannel\"\n default-output-channel=\"defaultChannel\">\n <int:mapping exception-type=\"java.lang.IllegalArgumentException\"\n channel=\"illegalChannel\"/>\n <int:mapping exception-type=\"java.lang.NullPointerException\"\n channel=\"npeChannel\"/>\n</int:exception-type-router>\n\n<int:channel id=\"illegalChannel\" />\n<int:channel id=\"npeChannel\" />\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/implementations.adoc", "title": "implementations", "heading": "Routing and Error Handling", "heading_level": 2, "file_order": 133, "section_index": 6, "content_hash": "cb1a403906add4325cd63746e47eae1ed45e19d1d4d5d1d5a6341f9cf6409378", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/implementations.adoc"}}
{"id": "sha256:309cea119278cbfc05b362f94a377ba8298c7e71155ba7fe356226f9569ced31", "content": "[[router-namespace]]\n\nSpring Integration provides a generic router.\nYou can use it for general-purpose routing (as opposed to the other routers provided by Spring Integration, each of which has some form of specialization).\n\nThe following section explains a router configuration with XML components.\n\nThe `router` element provides a way to connect a router to an input channel and also accepts the optional `default-output-channel` attribute.\nThe `ref` attribute references the bean name of a custom router implementation (which must extend `AbstractMessageRouter`).\nThe following example shows three generic routers:\n\n[source,xml]\n----\n<int:router ref=\"payloadTypeRouter\" input-channel=\"input1\"\n default-output-channel=\"defaultOutput1\"/>\n\n<int:router ref=\"recipientListRouter\" input-channel=\"input2\"\n default-output-channel=\"defaultOutput2\"/>\n\n<int:router ref=\"customRouter\" input-channel=\"input3\"\n default-output-channel=\"defaultOutput3\"/>\n\n<beans:bean id=\"customRouterBean\" class=\"org.foo.MyCustomRouter\"/>\n----\n\nAlternatively, `ref` may point to a POJO that contains the `@Router` annotation (shown later), or you can combine the `ref` with an explicit method name.\nSpecifying a method applies the same behavior described in the `@Router` annotation section, later in this document.\nThe following example defines a router that points to a POJO in its `ref` attribute:\n\n[source,xml]\n----\n<int:router input-channel=\"input\" ref=\"somePojo\" method=\"someMethod\"/>\n----\n\nWe generally recommend using a `ref` attribute if the custom router implementation is referenced in other `<router>` definitions.\nHowever, if the custom router implementation should be scoped to a single definition of the `<router>`, you can provide an inner bean definition, as the following example shows:\n\n[source,xml]\n----\n<int:router method=\"someMethod\" input-channel=\"input3\"\n default-output-channel=\"defaultOutput3\">\n <beans:bean class=\"org.foo.MyCustomRouter\"/>\n</int:router>\n----\n\nNOTE: Using both the `ref` attribute and an inner handler definition in the same `<router>` configuration is not allowed.\nDoing so creates an ambiguous condition and throws an exception.\n\nIMPORTANT: If the `ref` attribute references a bean that extends `AbstractMessageProducingHandler` (such as routers provided by the framework itself), the configuration is optimized to reference the router directly.\nIn this case, each `ref` attribute must refer to a separate bean instance (or a `prototype`-scoped bean) or use the inner `<bean/>` configuration type.\nHowever, this optimization applies only if you do not provide any router-specific attributes in the router XML definition.\nIf you inadvertently reference the same message handler from multiple beans, you get a configuration exception.\n\nThe following example shows the equivalent router configured in Java:\n\n[source, java]\n----\n@Bean\n@Router(inputChannel = \"routingChannel\")\npublic AbstractMessageRouter myCustomRouter() {\n return new AbstractMessageRouter() {\n\n @Override\n protected Collection<MessageChannel> determineTargetChannels(Message<?> message) {\n return // determine channel(s) for message\n }\n\n };\n}\n----\n\nThe following example shows the equivalent router configured by using the Java DSL:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow routerFlow() {\n return IntegrationFlow.from(\"routingChannel\")\n .route(myCustomRouter())\n .get();\n}\n\npublic AbstractMessageRouter myCustomRouter() {\n return new AbstractMessageRouter() {\n\n @Override\n protected Collection<MessageChannel> determineTargetChannels(Message<?> message) {\n return // determine channel(s) for message\n }\n\n };\n}\n----\n\nAlternately, you can route on data from the message payload, as the following example shows:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow routerFlow() {\n return IntegrationFlow.from(\"routingChannel\")\n .route(String.class, p -> p.contains(\"foo\") ? \"fooChannel\" : \"barChannel\")\n .get();\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/namespace.adoc", "title": "namespace", "heading": "namespace", "heading_level": 1, "file_order": 134, "section_index": 0, "content_hash": "309cea119278cbfc05b362f94a377ba8298c7e71155ba7fe356226f9569ced31", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/namespace.adoc"}}
{"id": "sha256:9991c978f756902d663e50bc0f20f2452ed378aea3065fda82cf40e2fdac7324", "content": "[[router-overview]]\n\nRouters are a crucial element in many messaging architectures.\nThey consume messages from a message channel and forward each consumed message to one or more different message channels depending on a set of conditions.\n\nSpring Integration provides the following routers:\n\n* xref:router/implementations.adoc#router-implementations-payloadtyperouter[Payload Type Router]\n* xref:router/implementations.adoc#router-implementations-headervaluerouter[Header Value Router]\n* xref:router/implementations.adoc#router-implementations-recipientlistrouter[Recipient List Router]\n* xref:xml/xpath-routing.adoc[XPath Router (part of the XML module)]\n* xref:router/implementations.adoc#router-implementations-exception-router[Error Message Exception Type Router]\n* xref:router/namespace.adoc[(Generic) Router]\n\nRouter implementations share many configuration parameters.\nHowever, certain differences exist between routers.\nFurthermore, the availability of configuration parameters depends on whether routers are used inside or outside a chain.\nIn order to provide a quick overview, all available attributes are listed in the two following tables .\n\nThe following table shows the configuration parameters available for a router outside a chain:\n\n.Routers Outside a Chain\n[cols=\"2,1,1,1,1,1,1\", options=\"header\"]\n|===\n| Attribute\n| router\n| header value router\n| xpath router\n| payload type router\n| recipient list route\n| exception type router\n\n| apply-sequence\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| default-output-channel\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| resolution-required\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| ignore-send-failures\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| timeout\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| id\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| auto-startup\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| input-channel\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| order\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| method\na| image::tickmark.png[]\n|\n|\n|\n|\n|\n\n| ref\na| image::tickmark.png[]\n|\n|\n|\n|\n|\n\n| expression\na| image::tickmark.png[]\n|\n|\n|\n|\n|\n\n| header-name\n|\na| image::tickmark.png[]\n|\n|\n|\n|\n\n| evaluate-as-string\n|\n|\na| image::tickmark.png[]\n|\n|\n|\n\n| xpath-expression-ref\n|\n|\na| image::tickmark.png[]\n|\n|\n|\n\n| converter\n|\n|\na| image::tickmark.png[]\n|\n|\n|\n|===\n\nThe following table shows the configuration parameters available for a router inside a chain:\n\n.Routers Inside a Chain\n[cols=\"2,1,1,1,1,1,1\", options=\"header\"]\n|===\n| Attribute\n| router\n| header value router\n| xpath router\n| payload type router\n| recipient list router\n| exception type router\n\n| apply-sequence\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| default-output-channel\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| resolution-required\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| ignore-send-failures\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| timeout\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\na| image::tickmark.png[]\n\n| id\n|\n|\n|\n|\n|\n|\n\n| auto-startup\n|\n|\n|\n|\n|\n|\n\n| input-channel\n|\n|\n|\n|\n|\n|\n\n| order\n|\n|\n|\n|\n|\n|\n\n| method\na| image::tickmark.png[]\n|\n|\n|\n|\n|\n\n| ref\na| image::tickmark.png[]\n|\n|\n|\n|\n|\n\n| expression\na| image::tickmark.png[]\n|\n|\n|\n|\n|\n\n| header-name\n|\na| image::tickmark.png[]\n|\n|\n|\n|\n\n| evaluate-as-string\n|\n|\na| image::tickmark.png[]\n|\n|\n|\n\n| xpath-expression-ref\n|\n|\na| image::tickmark.png[]\n|\n|\n|\n\n| converter\n|\n|\na| image::tickmark.png[]\n|\n|\n|\n|===\n\n[IMPORTANT]\n=====\nAs of Spring Integration 2.1, router parameters have been more standardized across all router implementations.\nConsequently, a few minor changes may break older Spring Integration-based applications.\n\nSince Spring Integration 2.1, the `ignore-channel-name-resolution-failures` attribute is removed in favor of consolidating its behavior with the `resolution-required` attribute.\nAlso, the `resolution-required` attribute now defaults to `true`.\n\nPrior to these changes, the `resolution-required` attribute defaulted to `false`, causing messages to be silently dropped when no channel was resolved and no `default-output-channel` was set.\nThe new behavior requires at least one resolved channel and, by default, throws a `MessageDeliveryException` if no channel was determined (or an attempt to send was not successful).\n\nIf you do desire to drop messages silently, you can set `default-output-channel=\"nullChannel\"`.\n=====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/overview.adoc", "title": "overview", "heading": "overview", "heading_level": 1, "file_order": 135, "section_index": 0, "content_hash": "9991c978f756902d663e50bc0f20f2452ed378aea3065fda82cf40e2fdac7324", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/overview.adoc"}}
{"id": "sha256:b0e3ff9cb8feccb37a532ebcfc260d2292f45c81e8fb00d53f1467ce0eaebf80", "content": "[[process-manager]]\n\nEnterprise integration patterns include the https://www.enterpriseintegrationpatterns.com/ProcessManager.html[process manager] pattern.\nYou can now easily implement this pattern by using custom process manager logic encapsulated in a `RoutingSlipRouteStrategy` within the routing slip.\nIn addition to a bean name, the `RoutingSlipRouteStrategy` can return any `MessageChannel` object, and there is no requirement that this `MessageChannel` instance be a bean in the application context.\nThis way, we can provide powerful dynamic routing logic when there is no way to predict which channel should be used.\nA `MessageChannel` can be created within the `RoutingSlipRouteStrategy` and returned.\nA `FixedSubscriberChannel` with an associated `MessageHandler` implementation is a good combination for such cases.\nFor example, you can route to a https://projectreactor.io/docs/core/release/reference/#getting-started[Reactive Streams], as the following example shows:\n\n[source,java]\n----\n@Bean\npublic PollableChannel resultsChannel() {\n return new QueueChannel();\n}\n@Bean\npublic RoutingSlipRouteStrategy routeStrategy() {\n return (requestMessage, reply) -> requestMessage.getPayload() instanceof String\n ? new FixedSubscriberChannel(m ->\n Mono.just((String) m.getPayload())\n .map(String::toUpperCase)\n .subscribe(v -> messagingTemplate().convertAndSend(resultsChannel(), v)))\n : new FixedSubscriberChannel(m ->\n Mono.just((Integer) m.getPayload())\n .map(v -> v * 2)\n .subscribe(v -> messagingTemplate().convertAndSend(resultsChannel(), v)));\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/process-manager.adoc", "title": "process-manager", "heading": "process-manager", "heading_level": 1, "file_order": 136, "section_index": 0, "content_hash": "b0e3ff9cb8feccb37a532ebcfc260d2292f45c81e8fb00d53f1467ce0eaebf80", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/process-manager.adoc"}}
{"id": "sha256:c02d9ed3e46354284a2e96a54cd2aac58d3fd4d1c212946bb3ee5f6d25c3c208", "content": "[[routing-slip]]\n\nStarting with version 4.1, Spring Integration provides an implementation of the https://www.enterpriseintegrationpatterns.com/RoutingTable.html[routing slip] enterprise integration pattern.\nIt is implemented as a `routingSlip` message header, which is used to determine the next channel in `AbstractMessageProducingHandler` instances, when an `outputChannel` is not specified for the endpoint.\nThis pattern is useful in complex, dynamic cases, when it can become difficult to configure multiple routers to determine message flow.\nWhen a message arrives at an endpoint that has no `output-channel`, the `routingSlip` is consulted to determine the next channel to which the message is sent.\nWhen the routing slip is exhausted, normal `replyChannel` processing resumes.\n\nConfiguration for the routing slip is presented as a `HeaderEnricher` option -- a semicolon-separated routing slip that contains `path` entries, as the following example shows:\n\n[source,xml]\n----\n<util:properties id=\"properties\">\n <beans:prop key=\"myRoutePath1\">channel1</beans:prop>\n <beans:prop key=\"myRoutePath2\">request.headers[myRoutingSlipChannel]</beans:prop>\n</util:properties>\n\n<context:property-placeholder properties-ref=\"properties\"/>\n\n<header-enricher input-channel=\"input\" output-channel=\"process\">\n <routing-slip\n value=\"${myRoutePath1}; @routingSlipRoutingPojo.get(request, reply);\n routingSlipRoutingStrategy; ${myRoutePath2}; finishChannel\"/>\n</header-enricher>\n----\n\nThe preceding example has:\n\n* A `<context:property-placeholder>` configuration to demonstrate that the entries in the routing slip `path` can be specified as resolvable keys.\n* The `<header-enricher>` `<routing-slip>` sub-element is used to populate the `RoutingSlipHeaderValueMessageProcessor` to the `HeaderEnricher` handler.\n* The `RoutingSlipHeaderValueMessageProcessor` accepts a `String` array of resolved routing slip `path` entries and returns (from `processMessage()`) a `singletonMap` with the `path` as `key` and `0` as initial `routingSlipIndex`.\n\nRouting Slip `path` entries can contain `MessageChannel` bean names, `RoutingSlipRouteStrategy` bean names, and Spring expressions (SpEL).\nThe `RoutingSlipHeaderValueMessageProcessor` checks each routing slip `path` entry against the `BeanFactory` on the first `processMessage` invocation.\nIt converts entries (which are not bean names in the application context) to `ExpressionEvaluatingRoutingSlipRouteStrategy` instances.\n`RoutingSlipRouteStrategy` entries are invoked multiple times, until they return null or an empty `String`.\n\nSince the routing slip is involved in the `getOutputChannel` process, we have a request-reply context.\nThe `RoutingSlipRouteStrategy` has been introduced to determine the next `outputChannel` that uses the `requestMessage` and the `reply` object.\nAn implementation of this strategy should be registered as a bean in the application context, and its bean name is used in the routing slip `path`.\nThe `ExpressionEvaluatingRoutingSlipRouteStrategy` implementation is provided.\nIt accepts a SpEL expression and an internal `ExpressionEvaluatingRoutingSlipRouteStrategy.RequestAndReply` object is used as the root object of the evaluation context.\nThis is to avoid the overhead of `EvaluationContext` creation for each `ExpressionEvaluatingRoutingSlipRouteStrategy.getNextPath()` invocation.\nIt is a simple Java bean with two properties: `Message<?> request` and `Object reply`.\nWith this expression implementation, we can specify routing slip `path` entries by using SpEL (for example, `@routingSlipRoutingPojo.get(request, reply)` and `request.headers[myRoutingSlipChannel]`) and avoid defining a bean for the `RoutingSlipRouteStrategy`.\n\nNOTE: The `requestMessage` argument is always a `Message<?>`.\nDepending on context, the reply object may be a `Message<?>`, an `AbstractIntegrationMessageBuilder`, or an arbitrary application domain object (when, for example, it is returned by a POJO method invoked by a service activator).\nIn the first two cases, the usual `Message` properties (`payload` and `headers`) are available when using SpEL (or a Java implementation).\nFor an arbitrary domain object, these properties are not available.\nFor this reason, be careful when you use routing slips in conjunction with POJO methods if the result is used to determine the next path.\n\nIMPORTANT: If a routing slip is involved in a distributed environment, we recommend not using inline expressions for the Routing Slip `path`.\nThis recommendation applies to distributed environments such as cross-JVM applications, using a `request-reply` through a message broker (such asxref:amqp.adoc[AMQP Support] or xref:jms.adoc[JMS Support]), or using a persistent `MessageStore` (xref:message-store.adoc[Message Store]) in the integration flow.\nThe framework uses `RoutingSlipHeaderValueMessageProcessor` to convert them to `ExpressionEvaluatingRoutingSlipRouteStrategy` objects, and they are used in the `routingSlip` message header.\nSince this class is not `Serializable` (it cannot be, because it depends on the `BeanFactory`), the entire `Message` becomes non-serializable and, in any distributed operation, we end up with a `NotSerializableException`.\nTo overcome this limitation, register an `ExpressionEvaluatingRoutingSlipRouteStrategy` bean with the desired SpEL and use its bean name in the routing slip `path` configuration.\n\nFor Java configuration, you can add a `RoutingSlipHeaderValueMessageProcessor` instance to the `HeaderEnricher` bean definition, as the following example shows:\n\n[source,java]\n----\n@Bean\n@Transformer(inputChannel = \"routingSlipHeaderChannel\")\npublic HeaderEnricher headerEnricher() {\n return new HeaderEnricher(Collections.singletonMap(IntegrationMessageHeaderAccessor.ROUTING_SLIP,\n new RoutingSlipHeaderValueMessageProcessor(\"myRoutePath1\",\n \"@routingSlipRoutingPojo.get(request, reply)\",\n \"routingSlipRoutingStrategy\",\n \"request.headers[myRoutingSlipChannel]\",\n \"finishChannel\")));\n}\n----\n\nThe routing slip algorithm works as follows when an endpoint produces a reply and no `outputChannel` has been defined:\n\n* The `routingSlipIndex` is used to get a value from the routing slip `path` list.\n* If the value from `routingSlipIndex` is `String`, it is used to get a bean from `BeanFactory`.\n* If a returned bean is an instance of `MessageChannel`, it is used as the next `outputChannel` and the `routingSlipIndex` is incremented in the reply message header (the routing slip `path` entries remain unchanged).\n* If a returned bean is an instance of `RoutingSlipRouteStrategy` and its `getNextPath` does not return an empty `String`, that result is used as a bean name for the next `outputChannel`.\nThe `routingSlipIndex` remains unchanged.\n* If `RoutingSlipRouteStrategy.getNextPath` returns an empty `String` or `null`, the `routingSlipIndex` is incremented and the `getOutputChannelFromRoutingSlip` is invoked recursively for the next Routing Slip `path` item.\n* If the next routing slip `path` entry is not a `String`, it must be an instance of `RoutingSlipRouteStrategy`.\n* When the `routingSlipIndex` exceeds the size of the routing slip `path` list, the algorithm moves to the default behavior for the standard `replyChannel` header.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/routing-slip.adoc", "title": "routing-slip", "heading": "routing-slip", "heading_level": 1, "file_order": 137, "section_index": 0, "content_hash": "c02d9ed3e46354284a2e96a54cd2aac58d3fd4d1c212946bb3ee5f6d25c3c208", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/routing-slip.adoc"}}
{"id": "sha256:1127006dc27952487191950b95ab355723171e1644b4ca30822acc961db2f427", "content": "[[router-spel]]\n\nSometimes, the routing logic may be simple, and writing a separate class for it and configuring it as a bean may seem like overkill.\nAs of Spring Integration 2.0, we offer an alternative that lets you use SpEL to implement simple computations that previously required a custom POJO router.\n\nNOTE: For more information about the Spring Expression Language, see the https://docs.spring.io/spring-framework/reference/core/expressions.html[relevant chapter in the Spring Framework Reference Guide].\n\nGenerally, a SpEL expression is evaluated and its result is mapped to a channel, as the following example shows:\n\n[source,xml]\n----\n<int:router input-channel=\"inChannel\" expression=\"payload.paymentType\">\n <int:mapping value=\"CASH\" channel=\"cashPaymentChannel\"/>\n <int:mapping value=\"CREDIT\" channel=\"authorizePaymentChannel\"/>\n <int:mapping value=\"DEBIT\" channel=\"authorizePaymentChannel\"/>\n</int:router>\n----\n\nThe following example shows the equivalent router configured in Java:\n\n[source, java]\n----\n@Router(inputChannel = \"routingChannel\")\n@Bean\npublic ExpressionEvaluatingRouter router() {\n ExpressionEvaluatingRouter router = new ExpressionEvaluatingRouter(\"payload.paymentType\");\n router.setChannelMapping(\"CASH\", \"cashPaymentChannel\");\n router.setChannelMapping(\"CREDIT\", \"authorizePaymentChannel\");\n router.setChannelMapping(\"DEBIT\", \"authorizePaymentChannel\");\n return router;\n}\n----\n\nThe following example shows the equivalent router configured in the Java DSL:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow routerFlow() {\n return IntegrationFlow.from(\"routingChannel\")\n .route(\"payload.paymentType\", r -> r\n .channelMapping(\"CASH\", \"cashPaymentChannel\")\n .channelMapping(\"CREDIT\", \"authorizePaymentChannel\")\n .channelMapping(\"DEBIT\", \"authorizePaymentChannel\"))\n .get();\n}\n----\n\nTo simplify things even more, the SpEL expression may evaluate to a channel name, as the following expression shows:\n\n[source,xml]\n----\n<int:router input-channel=\"inChannel\" expression=\"payload + 'Channel'\"/>\n----\n\nIn the preceding configuration, the result channel is computed by the SpEL expression, which concatenates the value of the `payload` with the literal `String`, 'Channel'.\n\nAnother virtue of SpEL for configuring routers is that an expression can return a `Collection`, effectively making every `<router>` a recipient list router.\nWhenever the expression returns multiple channel values, the message is forwarded to each channel.\nThe following example shows such an expression:\n\n[source,xml]\n----\n<int:router input-channel=\"inChannel\" expression=\"headers.channels\"/>\n----\n\nIn the above configuration, if the message includes a header with a name of 'channels' and the value of that header is a `List` of channel names, the message is sent to each channel in the list.\nYou may also find collection projection and collection selection expressions useful when you need to select multiple channels.\nFor further information, see:\n\n* https://docs.spring.io/spring-framework/reference/core/expressions/language-ref/collection-projection.html[Collection Projection]\n* https://docs.spring.io/spring-framework/reference/core/expressions/language-ref/collection-selection.html[Collection Selection]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router/spel.adoc", "title": "spel", "heading": "spel", "heading_level": 1, "file_order": 138, "section_index": 0, "content_hash": "1127006dc27952487191950b95ab355723171e1644b4ca30822acc961db2f427", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router/spel.adoc"}}
{"id": "sha256:722a04652dcff69b542a9c53d249549bcacc49b9e74e7b5b41e76df69064480f", "content": "[[sftp-dsf]]\n\nVersion 4.2 introduced the `DelegatingSessionFactory`, which allows the selection of the actual session factory at runtime.\nPrior to invoking the SFTP endpoint, you can call `setThreadKey()` on the factory to associate a key with the current thread.\nThat key is then used to look up the actual session factory to be used.\nYou can clear the key by calling `clearThreadKey()` after use.\n\nWe added convenience methods so that you can more easily do so from a message flow, as the following example shows:\n\n[source, xml]\n----\n<bean id=\"dsf\" class=\"org.springframework.integration.file.remote.session.DelegatingSessionFactory\">\n <constructor-arg>\n <bean class=\"o.s.i.file.remote.session.DefaultSessionFactoryLocator\">\n <!-- delegate factories here -->\n </bean>\n </constructor-arg>\n</bean>\n\n<int:service-activator input-channel=\"in\" output-channel=\"c1\"\n expression=\"@dsf.setThreadKey(#root, headers['factoryToUse'])\" />\n\n<int-sftp:outbound-gateway request-channel=\"c1\" reply-channel=\"c2\" ... />\n\n<int:service-activator input-channel=\"c2\" output-channel=\"out\"\n expression=\"@dsf.clearThreadKey(#root)\" />\n----\n\nIMPORTANT: When using session caching, (see xref:sftp/session-caching.adoc[SFTP Session Caching]), each of the delegates should be cached.\nYou cannot cache the `DelegatingSessionFactory` itself.\n\nStarting with version 5.0.7, the `DelegatingSessionFactory` can be used in conjunction with a `RotatingServerAdvice` to poll multiple servers; see xref:sftp/rotating-server-advice.adoc[Inbound Channel Adapters: Polling Multiple Servers and Directories].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/dsf.adoc", "title": "dsf", "heading": "dsf", "heading_level": 1, "file_order": 139, "section_index": 0, "content_hash": "722a04652dcff69b542a9c53d249549bcacc49b9e74e7b5b41e76df69064480f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/dsf.adoc"}}
{"id": "sha256:2ca526cb6905906c45dcca588cda25dc535c2c81c2130098544d7e074958d9cb", "content": "[[sftp-inbound]]\n\nThe SFTP inbound channel adapter is a special listener that connects to the server and listens for the remote directory events (such as a new file being created), at which point it initiates a file transfer.\nThe following example shows how to configure an SFTP inbound channel adapter:\n\n[source,xml]\n----\n<int-sftp:inbound-channel-adapter id=\"sftpAdapterAutoCreate\"\n session-factory=\"sftpSessionFactory\"\n channel=\"requestChannel\"\n filename-pattern=\"*.txt\"\n remote-directory=\"/foo/bar\"\n preserve-timestamp=\"true\"\n local-directory=\"file:target/foo\"\n auto-create-local-directory=\"true\"\n local-filename-generator-expression=\"#this.toUpperCase() + '.a'\"\n scanner=\"myDirScanner\"\n local-filter=\"myFilter\"\n temporary-file-suffix=\".writing\"\n max-fetch-size=\"-1\"\n delete-remote-files=\"false\">\n <int:poller fixed-rate=\"1000\"/>\n</int-sftp:inbound-channel-adapter>\n----\n\nThe preceding configuration example shows how to provide values for various attributes, including the following:\n\n* `local-directory`: The location to which files are going to be transferred\n* `remote-directory`: The remote source directory from which files are going to be transferred\n* `session-factory`: A reference to the bean we configured earlier\n\nBy default, the transferred file carries the same name as the original file.\nIf you want to override this behavior, you can set the `local-filename-generator-expression` attribute, which lets you provide a SpEL expression to generate the name of the local file.\nUnlike outbound gateways and adapters, where the root object of the SpEL evaluation context is a `Message`, this inbound adapter does not yet have the message at the time of evaluation, since that is what it ultimately generates with the transferred file as its payload.\nConsequently, the root object of the SpEL evaluation context is the original name of the remote file (a `String`).\n\nThe inbound channel adapter first retrieves the file to a local directory and then emits each file according to the poller configuration.\nStarting with version 5.0, you can limit the number of files fetched from the SFTP server when new file retrievals are needed.\nThis can be beneficial when the target files are large or when running in a clustered system with a persistent file list filter, discussed later in this section.\nUse `max-fetch-size` for this purpose.\nA negative value (the default) means no limit and all matching files are retrieved.\nSee xref:sftp/max-fetch.adoc[Inbound Channel Adapters: Controlling Remote File Fetching] for more information.\nSince version 5.0, you can also provide a custom `DirectoryScanner` implementation to the `inbound-channel-adapter` by setting the `scanner` attribute.\n\nStarting with Spring Integration 3.0, you can specify the `preserve-timestamp` attribute (the default is `false`).\nWhen `true`, the local file's modified timestamp is set to the value retrieved from the server.\nOtherwise, it is set to the current time.\n\nStarting with version 4.2, you can specify `remote-directory-expression` instead of `remote-directory`, which lets you dynamically determine the directory on each poll -- for example, `remote-directory-expression=\"@myBean.determineRemoteDir()\"`.\n\nSometimes, file filtering based on the simple pattern specified via `filename-pattern` attribute might not suffice.\nIf this is the case, you can use the `filename-regex` attribute to specify a regular expression, for example, `filename-regex=\".*\\.test$\"`.\nIf you need complete control, you can use the `filter` attribute to provide a reference to a custom implementation of the `org.springframework.integration.file.filters.FileListFilter`, which is a strategy interface for filtering a list of files.\nThis filter determines which remote files are retrieved.\nYou can also combine a pattern-based filter with other filters (such as an `AcceptOnceFileListFilter`, to avoid synchronizing files that have previously been fetched) by using a `CompositeFileListFilter`.\n\nThe `AcceptOnceFileListFilter` stores its state in memory.\nIf you wish the state to survive a system restart, consider using the `SftpPersistentAcceptOnceFileListFilter` instead.\nThis filter stores the accepted file names in an instance of the `MetadataStore` strategy (see xref:meta-data-store.adoc[Metadata Store]).\nThis filter matches on the filename and the remote modified time.\n\nSince version 4.0, this filter requires a `ConcurrentMetadataStore`.\nWhen used with a shared data store (such as `Redis` with the `RedisMetadataStore`), this lets filter keys be shared across multiple application or server instances.\n\nStarting with version 5.0, the `SftpPersistentAcceptOnceFileListFilter` with an in-memory `SimpleMetadataStore` is applied by default for the `SftpInboundFileSynchronizer`.\nThis filter is also applied, together with the `regex` or `pattern` option in the XML configuration, as well as through `SftpInboundChannelAdapterSpec` in Java DSL.\nYou can handle any other use-cases by using `CompositeFileListFilter` (or `ChainFileListFilter`).\n\nThe above discussion refers to filtering the files before retrieving them.\nOnce the files have been retrieved, an additional filter is applied to the files on the file system.\nBy default, this is an `AcceptOnceFileListFilter`, which, as discussed in this section, retains state in memory and does not consider the file's modified time.\nUnless your application removes files after processing, the adapter re-processes the files on disk by default after an application restarts.\n\nAlso, if you configure the `filter` to use a `SftpPersistentAcceptOnceFileListFilter` and the remote file timestamp changes (causing it to be re-fetched), the default local filter does not allow this new file to be processed.\n\nFor more information about this filter and how it is used, see xref:file/remote-persistent-flf.adoc[Remote Persistent File List Filters].\n\nYou can use the `local-filter` attribute to configure the behavior of the local file system filter.\nStarting with version 4.3.8, a `FileSystemPersistentAcceptOnceFileListFilter` is configured by default.\nThis filter stores the accepted file names and modified timestamp in an instance of the `MetadataStore` strategy (see xref:meta-data-store.adoc[Metadata Store]) and detects changes to the local file modified time.\nThe default `MetadataStore` is a `SimpleMetadataStore` that stores state in memory.\n\nSince version 4.1.5, these filters have a new property called `flushOnUpdate`, which causes them to flush the\nmetadata store on every update (if the store implements `Flushable`).\n\nIMPORTANT: Further, if you use a distributed `MetadataStore` (such as xref:redis.adoc#redis-metadata-store[Redis Metadata Store]), you can have multiple instances of the same adapter or application and be sure that one and only one instance processes a file.\n\nThe actual local filter is a `ChainFileListFilter` that contains a pattern filter that prevents processing files that are in the process of being downloaded (based on the `temporary-file-suffix`) and the supplied filter.\nFiles are downloaded with this suffix (the default is `.writing`), and the files are renamed to their final names when the transfer is complete, making them 'visible' to the filter.\n\nSee the https://github.com/spring-projects/spring-integration/tree/main/spring-integration-core/src/main/resources/org/springframework/integration/config[schema] for more detail on these attributes.\n\nSFTP inbound channel adapter is a polling consumer.\nTherefore, you must configure a poller (either a global default or a local element).\nOnce the file has been transferred to a local directory, a message with `java.io.File` as its payload type is generated and sent to the channel identified by the `channel` attribute.\n\nStarting with version 6.2, you can filter SFTP files based on last-modified strategy using `SftpLastModifiedFileListFilter`.\nThis filter can be configured with an `age` property so that only files older than this value are passed by the filter.\nThe age defaults to 60 seconds, but you should choose an age that is large enough to avoid picking up a file early (due to, say, network glitches).\nLook into its Javadoc for more information.\n\nIn contrast, starting with version 6.5, an `SftpRecentFileListFilter` has been introduced to accept only those files which are not older than provided `age`.\n\n[[more-on-file-filtering-and-large-files]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/inbound.adoc", "title": "inbound", "heading": "inbound", "heading_level": 1, "file_order": 140, "section_index": 0, "content_hash": "2ca526cb6905906c45dcca588cda25dc535c2c81c2130098544d7e074958d9cb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/inbound.adoc"}}
{"id": "sha256:5109866109e7fc9ddb724f8094108f8afd5126cc4d92d7c5297a96051d8a7b8a", "content": "Sometimes, a file that just appeared in the monitored (remote) directory is not complete.\nTypically, such a file is written with some temporary extension (such as `.writing` on a file named `something.txt.writing`) and then renamed after the writing process completes.\nIn most cases, developers are interested only in files that are complete and would like to filter only those files.\nTo handle these scenarios, you can use the filtering support provided by the `filename-pattern`, `filename-regex`, and `filter` attributes.\nIf you need a custom filter implementation, you can include a reference in your adapter by setting the `filter` attribute.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<int-sftp:inbound-channel-adapter id=\"sftpInbondAdapter\"\n channel=\"receiveChannel\"\n session-factory=\"sftpSessionFactory\"\n filter=\"customFilter\"\n local-directory=\"file:/local-test-dir\"\n remote-directory=\"/remote-test-dir\">\n <int:poller fixed-rate=\"1000\" max-messages-per-poll=\"10\" task-executor=\"executor\"/>\n</int-sftp:inbound-channel-adapter>\n\n<bean id=\"customFilter\" class=\"org.foo.CustomFilter\"/>\n----\n\n[[recovering-from-failures]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/inbound.adoc", "title": "inbound", "heading": "More on File Filtering and Large Files", "heading_level": 2, "file_order": 140, "section_index": 1, "content_hash": "5109866109e7fc9ddb724f8094108f8afd5126cc4d92d7c5297a96051d8a7b8a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/inbound.adoc"}}
{"id": "sha256:da8f91f9ebb122badbe98a73ba8afee23290b51c0739cf9096b7c3a25646cc26", "content": "You should understand the architecture of the adapter.\nA file synchronizer fetches the files, and a `FileReadingMessageSource` emits a message for each synchronized file.\nAs xref:sftp/inbound.adoc[discussed earlier], two filters are involved.\nThe `filter` attribute (and patterns) refers to the remote (SFTP) file list, to avoid fetching files that have already been fetched.\nthe `FileReadingMessageSource` uses the `local-filter` to determine which files are to be sent as messages.\n\nThe synchronizer lists the remote files and consults its filter.\nThe files are then transferred.\nIf an IO error occurs during file transfer, any files that have already been added to the filter are removed so that they are eligible to be re-fetched on the next poll.\nThis applies only if the filter implements `ReversibleFileListFilter` (such as the `AcceptOnceFileListFilter`).\n\nIf, after synchronizing the files, an error occurs on the downstream flow processing a file, no automatic rollback of the filter occurs, so the failed file is not reprocessed by default.\n\nIf you wish to reprocess such files after a failure, you can use a configuration similar to the following to facilitate the removal of the failed file from the filter:\n\n[source, xml]\n----\n<int-sftp:inbound-channel-adapter id=\"sftpAdapter\"\n session-factory=\"sftpSessionFactory\"\n channel=\"requestChannel\"\n remote-directory-expression=\"'/sftpSource'\"\n local-directory=\"file:myLocalDir\"\n auto-create-local-directory=\"true\"\n filename-pattern=\"*.txt\">\n <int:poller fixed-rate=\"1000\">\n <int:transactional synchronization-factory=\"syncFactory\" />\n </int:poller>\n</int-sftp:inbound-channel-adapter>\n\n<bean id=\"acceptOnceFilter\"\n class=\"org.springframework.integration.file.filters.AcceptOnceFileListFilter\" />\n\n<int:transaction-synchronization-factory id=\"syncFactory\">\n <int:after-rollback expression=\"payload.delete()\" />\n</int:transaction-synchronization-factory>\n\n<bean id=\"transactionManager\"\n class=\"org.springframework.integration.transaction.PseudoTransactionManager\" />\n----\n\nThe preceding configuration works for any `ResettableFileListFilter`.\n\nStarting with version 5.0, the inbound channel adapter can build subdirectories locally, according to the generated local file name.\nThat can be a remote sub-path as well.\nTo be able to read a local directory recursively for modification according to the hierarchy support, you can now supply an internal `FileReadingMessageSource` with a new `RecursiveDirectoryScanner` based on the `Files.walk()` algorithm.\nSee https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/synchronizer/AbstractInboundFileSynchronizingMessageSource.html#setScanner-org.springframework.integration.file.DirectoryScanner[`AbstractInboundFileSynchronizingMessageSource.setScanner()`] for more information.\nAlso, you can now switch the `AbstractInboundFileSynchronizingMessageSource` to the `WatchService`-based `DirectoryScanner` by using `setUseWatchService()` option.\nIt is also configured for all the `WatchEventType` instances to react for any modifications in local directory.\nThe reprocessing sample shown earlier is based on the built-in functionality of the `FileReadingMessageSource.WatchServiceDirectoryScanner`, which uses `ResettableFileListFilter.remove()` when the file is deleted (`StandardWatchEventKinds.ENTRY_DELETE`) from the local directory.\nSee xref:file/reading.adoc#watch-service-directory-scanner[`WatchServiceDirectoryScanner`] for more information.\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/inbound.adoc", "title": "inbound", "heading": "Recovering from Failures", "heading_level": 2, "file_order": 140, "section_index": 2, "content_hash": "da8f91f9ebb122badbe98a73ba8afee23290b51c0739cf9096b7c3a25646cc26", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/inbound.adoc"}}
{"id": "sha256:bea0b3034714b3a616df46616e5c490d3d321d45fe4faf181c5c71f372cfedf4", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with Java:\n\n[source, java]\n----\n@SpringBootApplication\npublic class SftpJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(SftpJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public SessionFactory<SftpClient.DirEntry> sftpSessionFactory() {\n DefaultSftpSessionFactory factory = new DefaultSftpSessionFactory(true);\n factory.setHost(\"localhost\");\n factory.setPort(port);\n factory.setUser(\"foo\");\n factory.setPassword(\"foo\");\n factory.setAllowUnknownKeys(true);\n factory.setTestSession(true);\n return new CachingSessionFactory<>(factory);\n }\n\n @Bean\n public SftpInboundFileSynchronizer sftpInboundFileSynchronizer() {\n SftpInboundFileSynchronizer fileSynchronizer = new SftpInboundFileSynchronizer(sftpSessionFactory());\n fileSynchronizer.setDeleteRemoteFiles(false);\n fileSynchronizer.setRemoteDirectory(\"foo\");\n fileSynchronizer.setFilter(new SftpSimplePatternFileListFilter(\"*.xml\"));\n return fileSynchronizer;\n }\n\n @Bean\n @InboundChannelAdapter(channel = \"sftpChannel\", poller = @Poller(fixedDelay = \"5000\"))\n public MessageSource<File> sftpMessageSource() {\n SftpInboundFileSynchronizingMessageSource source =\n new SftpInboundFileSynchronizingMessageSource(sftpInboundFileSynchronizer());\n source.setLocalDirectory(new File(\"sftp-inbound\"));\n source.setAutoCreateLocalDirectory(true);\n source.setLocalFilter(new AcceptOnceFileListFilter<File>());\n source.setMaxFetchSize(1);\n return source;\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"sftpChannel\")\n public MessageHandler handler() {\n return new MessageHandler() {\n\n @Override\n public void handleMessage(Message<?> message) throws MessagingException {\n System.out.println(message.getPayload());\n }\n\n };\n }\n\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/inbound.adoc", "title": "inbound", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 140, "section_index": 3, "content_hash": "bea0b3034714b3a616df46616e5c490d3d321d45fe4faf181c5c71f372cfedf4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/inbound.adoc"}}
{"id": "sha256:a35301a1288a17b407308150e675deabfa5dafc4172f1e19b5be1b7228e2a8c3", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class SftpJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(SftpJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public IntegrationFlow sftpInboundFlow() {\n return IntegrationFlow\n .from(Sftp.inboundAdapter(this.sftpSessionFactory)\n .preserveTimestamp(true)\n .remoteDirectory(\"foo\")\n .regexFilter(\".*\\\\.txt$\")\n .localFilenameExpression(\"#this.toUpperCase() + '.a'\")\n .localDirectory(new File(\"sftp-inbound\")),\n e -> e.id(\"sftpInboundAdapter\")\n .autoStartup(true)\n .poller(Pollers.fixedDelay(5000)))\n .handle(m -> System.out.println(m.getPayload()))\n .get();\n }\n}\n----\n\n[[sftp-incomplete]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/inbound.adoc", "title": "inbound", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 140, "section_index": 4, "content_hash": "a35301a1288a17b407308150e675deabfa5dafc4172f1e19b5be1b7228e2a8c3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/inbound.adoc"}}
{"id": "sha256:7d1fdc7e7fa80a95ad1bd4c21ed9127b939839ef44e8bb3c0db2d237cfde305f", "content": "See xref:file/reading.adoc#file-incomplete[Dealing With Incomplete Data].\n\nThe `SftpSystemMarkerFilePresentFileListFilter` is provided to filter remote files that don't have the corresponding marker file on the remote system.\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/sftp/filters/SftpSystemMarkerFilePresentFileListFilter.html[Javadoc] for configuration information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/inbound.adoc", "title": "inbound", "heading": "Dealing With Incomplete Data", "heading_level": 2, "file_order": 140, "section_index": 5, "content_hash": "7d1fdc7e7fa80a95ad1bd4c21ed9127b939839ef44e8bb3c0db2d237cfde305f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/inbound.adoc"}}
{"id": "sha256:06d218888a288bb35706d44d795a495fd24eb24bb9c5dd2fa99aaa4199388aba", "content": "[[sftp-max-fetch]]\n\nYou should consider two properties when configuring inbound channel adapters.\n`max-messages-per-poll`, as with all pollers, can be used to limit the number of messages emitted on each poll (if more than the configured value are ready).\n`max-fetch-size` (since version 5.0) can limit the number of files retrieved from the remote server at a time.\n\nThe following scenarios assume the starting state is an empty local directory:\n\n* `max-messages-per-poll=2` and `max-fetch-size=1`: The adapter fetches one file, emits it, fetches the next file, and emit it.\nThen it sleeps until the next poll.\n* `max-messages-per-poll=2` and `max-fetch-size=2`: The adapter fetches both files and then emits each one.\n* `max-messages-per-poll=2` and `max-fetch-size=4`: The adapter fetches up to 4 files (if available) and emits the first two (if there are at least two).\nThe next two files will be emitted in the next poll.\n* `max-messages-per-poll=2` and `max-fetch-size` not specified: The adapter fetches all remote files and emits the first two (if there are at least two).\nThe subsequent files are emitted on subsequent polls (two at a time).\nWhen all are consumed, the remote fetch is attempted again to pick up any new files.\n\nIMPORTANT: When you deploy multiple instances of an application, we recommend setting a small `max-fetch-size`, to avoid one instance \"`grabbing`\" all the files and starving other instances.\n\nAnother use for `max-fetch-size` is when you want to stop fetching remote files but continue to process files that have already been fetched.\nSetting the `maxFetchSize` property on the `MessageSource` (programmatically, via JMX, or via a xref:control-bus.adoc[control bus]) effectively stops the adapter from fetching more files but lets the poller continue to emit messages for files that have previously been fetched.\nIf the poller is active when the property is changed, the change takes effect on the next poll.\n\nStarting with version 5.1, the synchronizer can be provided with a `Comparator<?>`.\nThis is useful when restricting the number of files fetched with `maxFetchSize`.\n\nStarting with version 6.4, the `AbstractRemoteFileStreamingMessageSource` has now a convenient `clearFetchedCache()` API to remove references from cache for not processed remote files.\nThe references stay in cache because polling configuration does not allow processing all of them in one cycle, and the target `SessionFactory` might be changed between polling cycles, e.g., via `RotatingServerAdvice`.\n\nStarting with version 7.0, the `AbstractInboundFileSynchronizer` caches a filtered `Session.list(remoteDirectory)` after applying a `maxFetchSize` slicing.\nThe logic of the `AbstractInboundFileSynchronizer.transferFilesFromRemoteToLocal()` method is the following:\n\n- If `maxFetchSize > 0`, the lock is acquired against `remoteDirectory` to avoid race condition from different threads, when work is done around cache.\nThe performance degradation is minimal since all the later synchronizations deal only with in-memory cached leftover;\n- If no cache entry for the `remoteDirectory`, the `Session.list(remoteDirectory)` is called and all returned remote files are filtered;\n- the filtered result then sliced to the `maxFetchSize`;\n- then these file entries are being transferred to the local directory;\n- the rest of filtered remote files are cached for later synchronizations;\n- if there is a cache entry for the `remoteDirectory`, such a list is sliced to the maxFetchSize and iterated for the transfer to the local directory;\n- if one of the transfers fails, the `filter` is reset from the failed remote file.\nThe cache is also evicted; therefore, the next synchronization would start from a clean state.\n\nAlso see general xref:sftp/inbound.adoc[SFTP Inbound Channel Adapter] chapter for information about `FileListFilter` configuration.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/max-fetch.adoc", "title": "max-fetch", "heading": "max-fetch", "heading_level": 1, "file_order": 141, "section_index": 0, "content_hash": "06d218888a288bb35706d44d795a495fd24eb24bb9c5dd2fa99aaa4199388aba", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/max-fetch.adoc"}}
{"id": "sha256:d1cfd917f4c19e6a95d8e1f0b44f4c8b146d08f4cca9de1ec4ac1910bac4917a", "content": "[[sftp-outbound-gateway]]\n\nThe SFTP outbound gateway provides a limited set of commands that let you interact with a remote SFTP server:\n\n* `ls` (list files)\n* `nlst` (list file names)\n* `get` (retrieve a file)\n* `mget` (retrieve multiple files)\n* `rm` (remove file(s))\n* `mv` (move and rename file)\n* `put` (send a file)\n* `mput` (send multiple files)\n\n[[using-the-ls-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "outbound-gateway", "heading_level": 1, "file_order": 142, "section_index": 0, "content_hash": "d1cfd917f4c19e6a95d8e1f0b44f4c8b146d08f4cca9de1ec4ac1910bac4917a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:5c1921320ef3a01f77425cbf31df57ddfb580c901397db7887572ad7b04da762", "content": "`ls` lists remote files and supports the following options:\n\n* `-1`: Retrieve a list of filenames.\nThe default is to retrieve a list of `FileInfo` objects\n* `-a`: Include all files (including those starting with '.')\n* `-f`: Do not sort the list\n* `-dirs`: Include directories (excluded by default)\n* `-links`: Include symbolic links (excluded by default)\n* `-R`: List the remote directory recursively\n\nIn addition, filename filtering is provided in the same manner as the `inbound-channel-adapter`.\n\nThe message payload resulting from an `ls` operation is a list of file names or a list of `FileInfo` objects (depending on whether you usr the `-1` switch).\nThese objects provide information such as modified time, permissions, and others.\n\nThe remote directory that the `ls` command acted on is provided in the `file_remoteDirectory` header.\n\nWhen using the recursive option (`-R`), the `fileName` includes any subdirectory elements and represents the relative path to the file (relative to the remote directory).\nIf you use the `-dirs` option, each recursive directory is also returned as an element in the list.\nIn this case, we recommend that you not use the `-1` option, because you would not be able to distinguish files from directories, which you can do when you use `FileInfo` objects.\n\nIf remote path to list starts with a `/` symbol, it is treated by SFTP as an absolute path; without - as a relative path in the current user home.\n\n[[using-nlst-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `ls` Command", "heading_level": 2, "file_order": 142, "section_index": 1, "content_hash": "5c1921320ef3a01f77425cbf31df57ddfb580c901397db7887572ad7b04da762", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:18cfac5d0d45c3dc3f9f5f5722a514b12d05619f3ffc9f325993e09b443c7ec4", "content": "Version 5 introduced support for the `nlst` command.\n\n`nlst` lists remote file names and supports only one option:\n\n* `-f`: Do not sort the list\n\nThe message payload resulting from an `nlst` operation is a list of file names.\n\nThe `file_remoteDirectory` header holds the remote directory on which the `nlst` command acted.\n\nThe SFTP protocol does not provide the ability to list names.\nThis command is the equivalent of the `ls` command with the `-1` option and is added here for convenience.\n\n[[using-the-get-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using `nlst` Command", "heading_level": 2, "file_order": 142, "section_index": 2, "content_hash": "18cfac5d0d45c3dc3f9f5f5722a514b12d05619f3ffc9f325993e09b443c7ec4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:381c4269db2cd8e067fbec3909f08630a8c907d5fca688052244b4612bd27131", "content": "`get` retrieves a remote file and supports the following options:\n\n* `-P`: Preserve the timestamp of the remote file.\n* `-stream`: Retrieve the remote file as a stream.\n* `-D`: Delete the remote file after successful transfer.\nThe remote file is not deleted if the transfer is ignored, because the `FileExistsMode` is `IGNORE` and the local file already exists.\n\nThe `file_remoteDirectory` header holds the remote directory, and the `file_remoteFile` header holds the filename.\n\nThe message payload resulting from a `get` operation is a `File` object representing the retrieved file.\nIf you use the `-stream` option, the payload is an `InputStream` rather than a `File`.\nFor text files, a common use case is to combine this operation with a xref:file/splitter.adoc[file splitter] or a xref:transformer.adoc#stream-transformer[stream transformer].\nWhen consuming remote files as streams, you are responsible for closing the `Session` after the stream is consumed.\nFor convenience, the `Session` is provided in the `closeableResource` header, and `IntegrationMessageHeaderAccessor` offers convenience method:\n\n[source, java]\n----\nCloseable closeable = new IntegrationMessageHeaderAccessor(message).getCloseableResource();\nif (closeable != null) {\n closeable.close();\n}\n----\n\nFramework components, such as the xref:file/splitter.adoc[File Splitter] and xref:transformer.adoc#stream-transformer[Stream Transformer], automatically close the session after the data is transferred.\n\nThe following example shows how to consume a file as a stream:\n\n[source, xml]\n----\n<int-sftp:outbound-gateway session-factory=\"ftpSessionFactory\"\n request-channel=\"inboundGetStream\"\n command=\"get\"\n command-options=\"-stream\"\n expression=\"payload\"\n remote-directory=\"ftpTarget\"\n reply-channel=\"stream\" />\n\n<int-file:splitter input-channel=\"stream\" output-channel=\"lines\" />\n----\n\nNOTE: If you consume the input stream in a custom component, you must close the `Session`.\nYou can either do that in your custom code or route a copy of the message to a `service-activator` and use SpEL, as the following example shows:\n\n[source, xml]\n----\n<int:service-activator input-channel=\"closeSession\"\n expression=\"headers['closeableResource'].close()\" />\n----\n\n[[using-the-mget-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `get` Command", "heading_level": 2, "file_order": 142, "section_index": 3, "content_hash": "381c4269db2cd8e067fbec3909f08630a8c907d5fca688052244b4612bd27131", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:22a6c8a4b483b5acbdf3b3f168f99eac08c44155f7ffd62708a4d640a433ab3e", "content": "`mget` retrieves multiple remote files based on a pattern and supports the following options:\n\n* `-P`: Preserve the timestamps of the remote files.\n\n* `-R`: Retrieve the entire directory tree recursively.\n\n* `-x`: Throw an exception if no files match the pattern (otherwise, an empty list is returned).\n\n* `-D`: Delete each remote file after successful transfer.\nIf the transfer is ignored, the remote file is not deleted, because the `FileExistsMode` is `IGNORE` and the local file already exists.\n\nThe message payload resulting from an `mget` operation is a `List<File>` object (that is, a `List` of `File` objects, each representing a retrieved file).\n\nIMPORTANT: Starting with version 5.0, if the `FileExistsMode` is `IGNORE`, the payload of the output message no longer contains files that were not fetched due to the file already existing.\nPreviously, the array contained all files, including those that already existed.\n\nThe expression you use determines the remote path should produce a result that ends with `\\*` for example `myfiles/*` fetches the complete tree under `myfiles`.\n\nStarting with version 5.0, you can use a recursive `MGET`, combined with the `FileExistsMode.REPLACE_IF_MODIFIED` mode, to periodically synchronize an entire remote directory tree locally.\nThis mode sets the local file's last modified timestamp to the remote file's timestamp, regardless of the `-P` (preserve timestamp) option.\n\n.Notes for when using recursion (`-R`)\n[IMPORTANT]\n=====\n\nThe pattern is ignored and `*` is assumed.\nBy default, the entire remote tree is retrieved.\nHowever, you can filter files in the tree by providing a `FileListFilter`.\nYou can also filter directories in the tree this way.\nA `FileListFilter` can be provided by reference or by `filename-pattern` or `filename-regex` attributes.\nFor example, `filename-regex=\"(subDir|.*1.txt)\"` retrieves all files ending with `1.txt` in the remote directory and the subdirectory `subDir`.\nHowever, we describe an alternative available after this note.\n\nIf you filter a subdirectory, no additional traversal of that subdirectory is performed.\n\nThe `-dirs` option is not allowed (the recursive `mget` uses the recursive `ls` to obtain the directory tree and the directories themselves cannot be included in the list).\n\nTypically, you would use the `#remoteDirectory` variable in the `local-directory-expression` so that the remote directory structure is retained locally.\n=====\n\nThe persistent file list filters now have a boolean property `forRecursion`.\nSetting this property to `true`, also sets `alwaysAcceptDirectories`, which means that the recursive operation on the outbound gateways (`ls` and `mget`) will now always traverse the full directory tree each time.\nThis is to solve a problem where changes deep in the directory tree were not detected.\nIn addition, `forRecursion=true` causes the full path to files to be used as the metadata store keys; this solves a problem where the filter did not work properly if a file with the same name appears multiple times in different directories.\nIMPORTANT: This means that existing keys in a persistent metadata store will not be found for files beneath the top level directory.\nFor this reason, the property is `false` by default; this may change in a future release.\n\nStarting with version 5.0, you can configure the `SftpSimplePatternFileListFilter` and `SftpRegexPatternFileListFilter` to always pass directories by setting the `alwaysAcceptDirectorties` to `true`.\nDoing so allows recursion for a simple pattern, as the following examples show:\n\n[source, xml]\n----\n<bean id=\"starDotTxtFilter\"\n class=\"org.springframework.integration.sftp.filters.SftpSimplePatternFileListFilter\">\n <constructor-arg value=\"*.txt\" />\n <property name=\"alwaysAcceptDirectories\" value=\"true\" />\n</bean>\n\n<bean id=\"dotStarDotTxtFilter\"\n class=\"org.springframework.integration.sftp.filters.SftpRegexPatternFileListFilter\">\n <constructor-arg value=\"^.*\\.txt$\" />\n <property name=\"alwaysAcceptDirectories\" value=\"true\" />\n</bean>\n----\n\nYou can provide one of these filters by using the `filter` property on the gateway.\n\nSee also xref:sftp/outbound-gateway.adoc#sftp-partial[Outbound Gateway Partial Success (`mget` and `mput`)].\n\n[[sftp-put-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `mget` Command", "heading_level": 2, "file_order": 142, "section_index": 4, "content_hash": "22a6c8a4b483b5acbdf3b3f168f99eac08c44155f7ffd62708a4d640a433ab3e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:1c8004dd0813a941764411875689e2ca367c80c024ef19fda3095a7549d65a9a", "content": "`put` sends a file to the remote server.\nThe payload of the message can be a `java.io.File`, a `byte[]`, or a `String`.\nA `remote-filename-generator` (or expression) is used to name the remote file.\nOther available attributes include `remote-directory`, `temporary-remote-directory` and their `*-expression` equivalents: `use-temporary-file-name` and `auto-create-directory`.\nSee the https://github.com/spring-projects/spring-integration/tree/main/spring-integration-core/src/main/resources/org/springframework/integration/config[schema documentation] for more information.\n\nThe message payload resulting from a `put` operation is a `String` that contains the full path of the file on the server after transfer.\n\nVersion 4.3 introduced the `chmod` attribute, which changes the remote file permissions after upload.\nYou can use the conventional Unix octal format, for example, `600` allows read-write for the file owner only.\nWhen configuring the adapter using java, you can use `setChmod(0600)`.\n\n[[using-the-mput-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `put` Command", "heading_level": 2, "file_order": 142, "section_index": 5, "content_hash": "1c8004dd0813a941764411875689e2ca367c80c024ef19fda3095a7549d65a9a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:c0c73b05c2e23c2a6e1fdeebf1d385fa8a69a30b181d3f6912954a1dbccf9be8", "content": "`mput` sends multiple files to the server and supports the following option:\n\n* `-R`: Recursive -- send all files (possibly filtered) in the directory and subdirectories\n\nThe message payload must be a `java.io.File` (or `String`) that represents a local directory.\nSince version 5.1, a collection of `File` or `String` is also supported.\n\nThe same attributes as the xref:sftp/outbound-gateway.adoc#sftp-put-command[`put` command] are supported.\nIn addition, you can filter files in the local directory with one of `mput-pattern`, `mput-regex`, `mput-filter`, or `mput-filter-expression`.\nThe filter works with recursion, as long as the subdirectories themselves pass the filter.\nSubdirectories that do not pass the filter are not recursed.\n\nThe message payload resulting from an `mput` operation is a `List<String>` object (that is, a `List` of remote file paths resulting from the transfer).\n\nSee also xref:sftp/outbound-gateway.adoc#sftp-partial[Outbound Gateway Partial Success (`mget` and `mput`)].\n\nVersion 4.3 introduced the `chmod` attribute, which lets you change the remote file permissions after upload.\nYou can use the conventional Unix octal format, for example, `600` allows read-write for the file owner only.\nWhen configuring the adapter with Java, you can use `setChmodOctal(\"600\")` or `setChmod(0600)`.\n\n[[using-the-rm-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `mput` Command", "heading_level": 2, "file_order": 142, "section_index": 6, "content_hash": "c0c73b05c2e23c2a6e1fdeebf1d385fa8a69a30b181d3f6912954a1dbccf9be8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:002c76d9ec62094dbbc2b4d80071859fe5d0f1f35642ddc9750673abc2f30975", "content": "The `rm` command has no options.\n\nIf the remove operation was successful, the resulting message payload is `Boolean.TRUE`.\nOtherwise, the message payload is `Boolean.FALSE`.\nThe `file_remoteDirectory` header holds the remote directory, and the `file_remoteFile` header holds the file name.\n\n[[using-the-mv-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `rm` Command", "heading_level": 2, "file_order": 142, "section_index": 7, "content_hash": "002c76d9ec62094dbbc2b4d80071859fe5d0f1f35642ddc9750673abc2f30975", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:2a68ada96d2930b5f15aca22db0acde847f1c90972c208a1c8bc6723f6c7a8f9", "content": "The `mv` command has no options.\n\nThe `expression` attribute defines the \"`from`\" path, and the `rename-expression` attribute defines the \"`to`\" path.\nBy default, the `rename-expression` is `headers['file_renameTo']`.\nThis expression must not evaluate to null or an empty `String`.\nIf necessary, any remote directories needed are created.\nThe payload of the result message is `Boolean.TRUE`.\nThe `file_remoteDirectory` header holds the original remote directory, and the `file_remoteFile` header holds the filename.\nThe `file_renameTo` header holds the new path.\n\nStarting with version 5.5.6, the `remoteDirectoryExpression` can be used in the `mv` command for convenience.\nIf the \"`from`\" file is not a full file path, the result of `remoteDirectoryExpression` is used as the remote directory.\nThe same applies for the \"`to`\" file, for example, if the task is just to rename a remote file in some directory.\n\n[[additional-command-information]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Using the `mv` Command", "heading_level": 2, "file_order": 142, "section_index": 8, "content_hash": "2a68ada96d2930b5f15aca22db0acde847f1c90972c208a1c8bc6723f6c7a8f9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:f45cec5e906ba421255fa7eb0c3c9a4f5a59218b2d715efbd60015ec87eb8181", "content": "The `get` and `mget` commands support the `local-filename-generator-expression` attribute.\nIt defines a SpEL expression to generate the names of local files during the transfer.\nThe root object of the evaluation context is the request message.\nThe `remoteFileName` variable is also available.\nIt is particularly useful for `mget` (for example: `local-filename-generator-expression=\"#remoteFileName.toUpperCase() + headers.foo\"`).\n\nThe `get` and `mget` commands support the `local-directory-expression` attribute.\nIt defines a SpEL expression to generate the names of local directories during the transfer.\nThe root object of the evaluation context is the request message.\nThe `remoteDirectory` variable is also available.\nIt is particularly useful for `mget`, for example, `local-directory-expression=\"'/tmp/local/' + #remoteDirectory.toUpperCase() + headers.myheader\"`.\nThis attribute is mutually exclusive with the `local-directory` attribute.\n\nFor all commands, the 'expression' property of the gateway holds the path on which the command acts.\nFor the `mget` command, the expression might evaluate to `\\*`, meaning to retrieve all files, `somedirectory/*`, and other values that end with `*`.\n\nThe following example shows a gateway configured for an `ls` command:\n\n[source,xml]\n----\n<int-ftp:outbound-gateway id=\"gateway1\"\n session-factory=\"ftpSessionFactory\"\n request-channel=\"inbound1\"\n command=\"ls\"\n command-options=\"-1\"\n expression=\"payload\"\n reply-channel=\"toSplitter\"/>\n----\n\nThe payload of the message sent to the `toSplitter` channel is a list of `String` objects, each of which contains the name of a file.\nIf you omitted `command-options=\"-1\"`, the payload would be a list of `FileInfo` objects.\nYou can provide options as a space-delimited list, for example, `command-options=\"-1 -dirs -links\"`.\n\nStarting with version 4.2, the `GET`, `MGET`, `PUT`, and `MPUT` commands support a `FileExistsMode` property (`mode` when using the namespace support).\nThis affects the behavior when the local file exists (`GET` and `MGET`) or the remote file exists (`PUT` and `MPUT`).\nThe supported modes are `REPLACE`, `APPEND`, `FAIL`, and `IGNORE`.\nFor backwards compatibility, the default mode for `PUT` and `MPUT` operations is `REPLACE`.\nFor `GET` and `MGET` operations, the default is `FAIL`.\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Additional Command Information", "heading_level": 2, "file_order": 142, "section_index": 9, "content_hash": "f45cec5e906ba421255fa7eb0c3c9a4f5a59218b2d715efbd60015ec87eb8181", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:0ce7b66c742c7c7db02b5afafd039f4c29e00a9679669c4ece42b079ee930a43", "content": "The following Spring Boot application shows an example of how to configure the outbound gateway with Java:\n\n[source, java]\n----\n@SpringBootApplication\npublic class SftpJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(SftpJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"sftpChannel\")\n public MessageHandler handler() {\n return new SftpOutboundGateway(ftpSessionFactory(), \"ls\", \"'my_remote_dir/'\");\n }\n\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 142, "section_index": 10, "content_hash": "0ce7b66c742c7c7db02b5afafd039f4c29e00a9679669c4ece42b079ee930a43", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:a66a7c9a981607307ccfb85ff9b24d76088d6a4ae8010c051190decb867bac4e", "content": "The following Spring Boot application shows an example of how to configure the outbound gateway with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class SftpJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(SftpJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public SessionFactory<SftpClient.DirEntry> sftpSessionFactory() {\n DefaultSftpSessionFactory sf = new DefaultSftpSessionFactory();\n sf.setHost(\"localhost\");\n sf.setPort(port);\n sf.setUsername(\"foo\");\n sf.setPassword(\"foo\");\n factory.setTestSession(true);\n return new CachingSessionFactory<>(sf);\n }\n\n @Bean\n public QueueChannelSpec remoteFileOutputChannel() {\n return MessageChannels.queue();\n }\n\n @Bean\n public IntegrationFlow sftpMGetFlow() {\n return IntegrationFlow.from(\"sftpMgetInputChannel\")\n .handle(Sftp.outboundGateway(sftpSessionFactory(),\n AbstractRemoteFileOutboundGateway.Command.MGET, \"payload\")\n .options(AbstractRemoteFileOutboundGateway.Option.RECURSIVE)\n .regexFileNameFilter(\"(subSftpSource|.*1.txt)\")\n .localDirectoryExpression(\"'myDir/' + #remoteDirectory\")\n .localFilenameExpression(\"#remoteFileName.replaceFirst('sftpSource', 'localTarget')\"))\n .channel(\"remoteFileOutputChannel\")\n .get();\n }\n\n}\n----\n\n[[sftp-partial]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 142, "section_index": 11, "content_hash": "a66a7c9a981607307ccfb85ff9b24d76088d6a4ae8010c051190decb867bac4e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:77b140b3ab8e5a090b3cda443197596cbae56b550cd7d3ce3ff9cb95215fd0cd", "content": "When performing operations on multiple files (by using `mget` and `mput`) an exception can occur some time after one or more files have been transferred.\nIn this case (starting with version 4.2), a `PartialSuccessException` is thrown.\nAs well as the usual `MessagingException` properties (`failedMessage` and `cause`), this exception has two additional properties:\n\n* `partialResults`: The successful transfer results.\n* `derivedInput`: The list of files generated from the request message (such as local files to transfer for an `mput`).\n\nThese attributes let you determine which files were successfully transferred and which were not.\n\nIn the case of a recursive `mput`, the `PartialSuccessException` may have nested `PartialSuccessException` instances.\n\nConsider the following directory structure:\n\n[source]\n----\nroot/\n|- file1.txt\n|- subdir/\n | - file2.txt\n | - file3.txt\n|- zoo.txt\n----\n\nIf the exception occurs on `file3.txt`, the `PartialSuccessException` thrown by the gateway has `derivedInput` of `file1.txt`, `subdir`, and `zoo.txt` and `partialResults` of `file1.txt`.\nIts `cause` is another `PartialSuccessException` with `derivedInput` of `file2.txt` and `file3.txt` and `partialResults` of `file2.txt`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound-gateway.adoc", "title": "outbound-gateway", "heading": "Outbound Gateway Partial Success (`mget` and `mput`)", "heading_level": 2, "file_order": 142, "section_index": 12, "content_hash": "77b140b3ab8e5a090b3cda443197596cbae56b550cd7d3ce3ff9cb95215fd0cd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound-gateway.adoc"}}
{"id": "sha256:e3bd6c3695c24912ad9a9764893ef89ba8b710fe61a7407dc30deb6972f46d57", "content": "[[sftp-outbound]]\n\nThe SFTP outbound channel adapter is a special `MessageHandler` that connects to the remote directory and initiates a file transfer for every file it receives as the payload of an incoming `Message`.\nIt also supports several representations of the file so that you are not limited to the `File` object.\nSimilar to the FTP outbound adapter, the SFTP outbound channel adapter supports the following payloads:\n\n* `java.io.File`: The actual file object\n* `byte[]`: A byte array that represents the file contents\n* `java.lang.String`: Text that represents the file contents\n* `java.io.InputStream`: a stream of data to transfer to remote file\n* `org.springframework.core.io.Resource`: a resource for data to transfer to remote file\n\nThe following example shows how to configure an SFTP outbound channel adapter:\n\n[source,xml]\n----\n<int-sftp:outbound-channel-adapter id=\"sftpOutboundAdapter\"\n session-factory=\"sftpSessionFactory\"\n channel=\"inputChannel\"\n charset=\"UTF-8\"\n remote-file-separator=\"/\"\n remote-directory=\"foo/bar\"\n remote-filename-generator-expression=\"payload.getName() + '-mysuffix'\"\n filename-generator=\"fileNameGenerator\"\n use-temporary-filename=\"true\"\n chmod=\"600\"\n mode=\"REPLACE\"/>\n----\n\nSee the https://github.com/spring-projects/spring-integration/tree/main/spring-integration-core/src/main/resources/org/springframework/integration/config[schema] for more detail on these attributes.\n\n[[spel-and-the-sftp-outbound-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound.adoc", "title": "outbound", "heading": "outbound", "heading_level": 1, "file_order": 143, "section_index": 0, "content_hash": "e3bd6c3695c24912ad9a9764893ef89ba8b710fe61a7407dc30deb6972f46d57", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound.adoc"}}
{"id": "sha256:34bb00f3d382ad9a1e22d438c9d154ea3aba7accc252c783c51f4f192bfe4217", "content": "As with many other components in Spring Integration, you can use the Spring Expression Language (SpEL) when you configure an SFTP outbound channel adapter by specifying two attributes: `remote-directory-expression` and `remote-filename-generator-expression` (xref:sftp/inbound.adoc[described earlier]).\nThe expression evaluation context has the message as its root object, which lets you use expressions that can dynamically compute the file name or the existing directory path based on the data in the message (from either the 'payload' or the 'headers').\nIn the preceding example, we define the `remote-filename-generator-expression` attribute with an expression value that computes the file name based on its original name while also appending a suffix: '-mysuffix'.\n\nStarting with version 4.1, you can specify the `mode` when you are transferring the file.\nBy default, an existing file is overwritten.\nThe modes are defined by the `FileExistsMode` enumeration, which includes the following values:\n\n* `REPLACE` (default)\n* `REPLACE_IF_MODIFIED`\n* `APPEND`\n* `APPEND_NO_FLUSH`\n* `IGNORE`\n* `FAIL`\n\nWith `IGNORE` and `FAIL`, the file is not transferred.\n`FAIL` causes an exception to be thrown, while `IGNORE` silently ignores the transfer (although a `DEBUG` log entry is produced).\n\nVersion 4.3 introduced the `chmod` attribute, which you can use to change the remote file permissions after upload.\nYou can use the conventional Unix octal format, (for example, `600` allows read-write for the file owner only).\nWhen configuring the adapter using java, you can use `setChmodOctal(\"600\")` or `setChmod(0600)`.\n\n[[avoiding-partially-written-files]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound.adoc", "title": "outbound", "heading": "SpEL and the SFTP Outbound Adapter", "heading_level": 2, "file_order": 143, "section_index": 1, "content_hash": "34bb00f3d382ad9a1e22d438c9d154ea3aba7accc252c783c51f4f192bfe4217", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound.adoc"}}
{"id": "sha256:ef33cc54dd018ee725148c03557ef47c0f4f305a4b2129516b1347953939284a", "content": "One of the common problems when dealing with file transfers is the possibility of processing a partial file.\nA file might appear in the file system before its transfer is actually complete.\n\nTo deal with this issue, Spring Integration SFTP adapters use a common algorithm in which files are transferred under a temporary name and then renamed once they are fully transferred.\n\nBy default, every file that is in the process of being transferred appears in the file system with an additional suffix, which, by default, is `.writing`.\nYou can change by setting the `temporary-file-suffix` attribute.\n\nHowever, there may be situations where you do not want to use this technique, (for example, if the server does not permit renaming files).\nFor situations like this, you can disable this feature by setting `use-temporary-file-name` to `false` (the default is `true`).\nWhen this attribute is `false`, the file is written with its final name, and the consuming application needs some other mechanism to detect that the file is completely uploaded before accessing it.\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound.adoc", "title": "outbound", "heading": "Avoiding Partially Written Files", "heading_level": 2, "file_order": 143, "section_index": 2, "content_hash": "ef33cc54dd018ee725148c03557ef47c0f4f305a4b2129516b1347953939284a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound.adoc"}}
{"id": "sha256:0413710ed9a92124f98db3162ac2b59f6dc83d73caa5f0b5edb18893e637d6ff", "content": "The following Spring Boot application shows an example of how to configure the outbound adapter with Java:\n\n[source, java]\n----\n@SpringBootApplication\n@IntegrationComponentScan\npublic class SftpJavaApplication {\n\n public static void main(String[] args) {\n ConfigurableApplicationContext context =\n new SpringApplicationBuilder(SftpJavaApplication.class)\n .web(false)\n .run(args);\n MyGateway gateway = context.getBean(MyGateway.class);\n gateway.sendToSftp(new File(\"/foo/bar.txt\"));\n }\n\n @Bean\n public SessionFactory<SftpClient.DirEntry> sftpSessionFactory() {\n DefaultSftpSessionFactory factory = new DefaultSftpSessionFactory(true);\n factory.setHost(\"localhost\");\n factory.setPort(port);\n factory.setUser(\"foo\");\n factory.setPassword(\"foo\");\n factory.setAllowUnknownKeys(true);\n factory.setTestSession(true);\n return new CachingSessionFactory<SftpClient.DirEntry>(factory);\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"toSftpChannel\")\n public MessageHandler handler() {\n SftpMessageHandler handler = new SftpMessageHandler(sftpSessionFactory());\n handler.setRemoteDirectoryExpressionString(\"headers['remote-target-dir']\");\n handler.setFileNameGenerator(new FileNameGenerator() {\n\n @Override\n public String generateFileName(Message<?> message) {\n return \"handlerContent.test\";\n }\n\n });\n return handler;\n }\n\n @MessagingGateway\n public interface MyGateway {\n\n @Gateway(requestChannel = \"toSftpChannel\")\n void sendToSftp(File file);\n\n }\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound.adoc", "title": "outbound", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 143, "section_index": 3, "content_hash": "0413710ed9a92124f98db3162ac2b59f6dc83d73caa5f0b5edb18893e637d6ff", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound.adoc"}}
{"id": "sha256:c9f595ff5e07c7fafb5f6ad2ae76b0ec420cfbe49020edc55a24d571f5a24a86", "content": "The following Spring Boot application shows an example of how to configure the outbound adapter with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class SftpJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(SftpJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public IntegrationFlow sftpOutboundFlow() {\n return IntegrationFlow.from(\"toSftpChannel\")\n .handle(Sftp.outboundAdapter(this.sftpSessionFactory, FileExistsMode.FAIL)\n .useTemporaryFileName(false)\n .remoteDirectory(\"/foo\")\n ).get();\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/outbound.adoc", "title": "outbound", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 143, "section_index": 4, "content_hash": "c9f595ff5e07c7fafb5f6ad2ae76b0ec420cfbe49020edc55a24d571f5a24a86", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/outbound.adoc"}}
{"id": "sha256:3528b6a59a0d083090d7a130e5254614df4262e4ecad8912d4cff9d0dbbdd2cd", "content": "[[sftp-remote-file-info]]\n\nStarting with version 5.2, the `SftpStreamingMessageSource` (xref:sftp/streaming.adoc[SFTP Streaming Inbound Channel Adapter]), `SftpInboundFileSynchronizingMessageSource` (xref:sftp/inbound.adoc[SFTP Inbound Channel Adapter]) and \"read\"-commands of the `SftpOutboundGateway` (xref:sftp/outbound-gateway.adoc[SFTP Outbound Gateway]) provide additional headers in the message to produce with information about the remote file:\n\n* `FileHeaders.REMOTE_HOST_PORT` - the host:port pair the remote session has been connected to during file transfer operation;\n* `FileHeaders.REMOTE_DIRECTORY` - the remote directory the operation has been performed;\n* `FileHeaders.REMOTE_FILE` - the remote file name; applicable only for single file operations.\n\nSince the `SftpInboundFileSynchronizingMessageSource` doesn't produce messages against remote files, but using a local copy, the `AbstractInboundFileSynchronizer` stores an information about a remote file in the `MetadataStore` (which can be configured externally) in the URI style (`protocol://host:port/remoteDirectory#remoteFileName`) during synchronization operation.\nThis metadata is retrieved by the `SftpInboundFileSynchronizingMessageSource` when a local file is polled.\nWhen a local file is deleted, it is recommended to remove its metadata entry.\nThe `AbstractInboundFileSynchronizer` provides a `removeRemoteFileMetadata()` callback for this purpose.\nIn addition, there is a `setMetadataStorePrefix()` to be used in the metadata keys.\nIt is recommended to have this prefix be different from the one used in the `MetadataStore`-based `FileListFilter` implementations, when the same `MetadataStore` instance is shared between these components, to avoid entry overriding because both filter and `AbstractInboundFileSynchronizer` use the same local file name for the metadata entry key.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/remote-file-info.adoc", "title": "remote-file-info", "heading": "remote-file-info", "heading_level": 1, "file_order": 144, "section_index": 0, "content_hash": "3528b6a59a0d083090d7a130e5254614df4262e4ecad8912d4cff9d0dbbdd2cd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/remote-file-info.adoc"}}
{"id": "sha256:b021788e7794bbf70b5657b92b6e2b37ed5b6f5f88f7e39fb24105ad0946ad04", "content": "[[sftp-rft]]\n\nSpring Integration version 3.0 provides a new abstraction over the `SftpSession` object.\nThe template provides methods to send, retrieve (as an `InputStream`), remove, and rename files.\nIn addition, we provide an `execute` method to let the caller run multiple operations on the session.\nIn all cases, the template takes care of reliably closing the session.\nFor more information, see the https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/RemoteFileTemplate.html[Javadoc for `RemoteFileTemplate`] There is a subclass for SFTP: https://docs.spring.io/spring-integration/api/org/springframework/integration/sftp/session/SftpRemoteFileTemplate.html[`SftpRemoteFileTemplate`].\n\nWe added additional methods in version 4.1, including `getClientInstance()`.\nIt provides access to the underlying `ChannelSftp`, which enables access to low-level APIs.\n\nVersion 5.0 introduced the `RemoteFileOperations.invoke(OperationsCallback<F, T> action)` method.\nThis method lets several `RemoteFileOperations` calls be called in the scope of the same thread-bounded `Session`.\nThis is useful when you need to perform several high-level operations of the `RemoteFileTemplate` as one unit of work.\nFor example, `AbstractRemoteFileOutboundGateway` uses it with the `mput` command implementation, where we perform a `put` operation for each file in the provided directory and recursively for its subdirectories.\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/file/remote/RemoteFileTemplate.html#invoke-org.springframework.integration.file.remote.OperationsCallback-[Javadoc] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/rft.adoc", "title": "rft", "heading": "rft", "heading_level": 1, "file_order": 145, "section_index": 0, "content_hash": "b021788e7794bbf70b5657b92b6e2b37ed5b6f5f88f7e39fb24105ad0946ad04", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/rft.adoc"}}
{"id": "sha256:a9f2c1f799ef22a32b0d3d98c6dac2770184616f899414b18013cb041deecb54", "content": "[[sftp-rotating-server-advice]]\n\nStarting with version 5.0.7, the `RotatingServerAdvice` is available; when configured as a poller advice, the inbound adapters can poll multiple servers and directories.\nConfigure the advice and add it to the poller's advice chain as normal.\nA `DelegatingSessionFactory` is used to select the server see xref:ftp/dsf.adoc[Delegating Session Factory] for more information.\nThe advice configuration consists of a list of `RotationPolicy.KeyDirectory` objects.\n\n.Example\n[source, java]\n----\n@Bean\npublic RotatingServerAdvice advice() {\n List<RotationPolicy.KeyDirectory> keyDirectories = new ArrayList<>();\n keyDirectories.add(new RotationPolicy.KeyDirectory(\"one\", \"foo\"));\n keyDirectories.add(new RotationPolicy.KeyDirectory(\"one\", \"bar\"));\n keyDirectories.add(new RotationPolicy.KeyDirectory(\"two\", \"baz\"));\n keyDirectories.add(new RotationPolicy.KeyDirectory(\"two\", \"qux\"));\n keyDirectories.add(new RotationPolicy.KeyDirectory(\"three\", \"fiz\"));\n keyDirectories.add(new RotationPolicy.KeyDirectory(\"three\", \"buz\"));\n return new RotatingServerAdvice(delegatingSf(), keyDirectories);\n}\n----\n\nThis advice will poll directory `foo` on server `one` until no new files exist then move to directory `bar` and then directory `baz` on server `two`, etc.\n\nThis default behavior can be modified with the `fair` constructor arg:\n\n.fair\n[source, java]\n----\n@Bean\npublic RotatingServerAdvice advice() {\n ...\n return new RotatingServerAdvice(delegatingSf(), keyDirectories, true);\n}\n----\n\nIn this case, the advice will move to the next server/directory regardless of whether the previous poll returned a file.\n\nAlternatively, you can provide your own `RotationPolicy` to reconfigure the message source as needed:\n\n.policy\n[source, java]\n----\npublic interface RotationPolicy {\n\n void beforeReceive(MessageSource<?> source);\n\n void afterReceive(boolean messageReceived, MessageSource<?> source);\n\n}\n----\n\nand\n\n.custom\n[source, java]\n----\n@Bean\npublic RotatingServerAdvice advice() {\n return new RotatingServerAdvice(myRotationPolicy());\n}\n----\n\nThe `local-filename-generator-expression` attribute (`localFilenameGeneratorExpression` on the synchronizer) can now contain the `#remoteDirectory` variable.\nThis allows files retrieved from different directories to be downloaded to similar directories locally:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow flow() {\n return IntegrationFlow.from(Sftp.inboundAdapter(sf())\n .filter(new SftpPersistentAcceptOnceFileListFilter(new SimpleMetadataStore(), \"rotate\"))\n .localDirectory(new File(tmpDir))\n .localFilenameExpression(\"#remoteDirectory + T(java.io.File).separator + #root\")\n .remoteDirectory(\".\"),\n e -> e.poller(Pollers.fixedDelay(1).advice(advice())))\n .channel(MessageChannels.queue(\"files\"))\n .get();\n}\n----\n\nIMPORTANT: Do not configure a `TaskExecutor` on the poller when using this advice; see xref:changes-4.1-4.2.adoc#x4.2-conditional-pollers[Conditional Pollers for Message Sources] for more information.\n\nAlso see a convenient `AbstractRemoteFileStreamingMessageSource.clearFetchedCache()` API when not all fetched files are processed withing a single polling cycle, but `SessionFactory` might be rotated to different one.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/rotating-server-advice.adoc", "title": "rotating-server-advice", "heading": "rotating-server-advice", "heading_level": 1, "file_order": 146, "section_index": 0, "content_hash": "a9f2c1f799ef22a32b0d3d98c6dac2770184616f899414b18013cb041deecb54", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/rotating-server-advice.adoc"}}
{"id": "sha256:ed477fc86f97568af56fb4b3a49f9951f8f49b5f4a18ab8d3579760ee76a7843", "content": "[[sftp-server-events]]\n\nThe `ApacheMinaSftpEventListener`, added in version 5.2, listens for certain Apache Mina SFTP server events and publishes them as `ApplicationEvent` s which can be received by any `ApplicationListener` bean, `@EventListener` bean method, or xref:event.adoc#appevent-inbound[Event Inbound Channel Adapter].\n\nCurrently, supported events are:\n\n* `SessionOpenedEvent` - a client session was opened\n* `DirectoryCreatedEvent` - a directory was created\n* `FileWrittenEvent` - a file was written to\n* `PathMovedEvent` - a file or directory was renamed\n* `PathRemovedEvent` - a file or directory was removed\n* `SessionClosedEvent` - the client has disconnected\n\nEach of these is a subclass of `ApacheMinaSftpEvent`; you can configure a single listener to receive all the event types.\nThe `source` property of each event is a `ServerSession`, from which you can obtain information such as the client address; a convenient `getSession()` method is provided on the abstract event.\n\nTo configure the server with the listener (which must be a Spring bean), simply add it to the `SftpSubsystemFactory`:\n\n[source, java]\n----\nserver = SshServer.setUpDefaultServer();\n...\nSftpSubsystemFactory sftpFactory = new SftpSubsystemFactory();\nsftpFactory.addSftpEventListener(apacheMinaSftpEventListenerBean);\n...\n----\n\nTo consume these events using a Spring Integration event adapter:\n\n[source, java]\n----\n@Bean\npublic ApplicationEventListeningMessageProducer eventsAdapter() {\n ApplicationEventListeningMessageProducer producer =\n new ApplicationEventListeningMessageProducer();\n producer.setEventTypes(ApacheMinaSftpEvent.class);\n producer.setOutputChannel(eventChannel());\n return producer;\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/server-events.adoc", "title": "server-events", "heading": "server-events", "heading_level": 1, "file_order": 147, "section_index": 0, "content_hash": "ed477fc86f97568af56fb4b3a49f9951f8f49b5f4a18ab8d3579760ee76a7843", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/server-events.adoc"}}
{"id": "sha256:3250c90b649091e885ec408270c789ad2d2c2390780f6148054278db55dc1e40", "content": "[[sftp-session-caching]]\n\nIMPORTANT: Starting with Spring Integration version 3.0, sessions are no longer cached by default.\nThe `cache-sessions` attribute is no longer supported on endpoints.\nIf you wish to cache sessions, you must use a `CachingSessionFactory` (see the next example).\n\nIn versions prior to 3.0, the sessions were automatically cached by default.\nA `cache-sessions` attribute was available for disabling the auto caching, but that solution did not provide a way to configure other session-caching attributes.\nFor example, you could not limit on the number of sessions created.\nTo support that requirement and other configuration options, we added a `CachingSessionFactory`.\nIt provides `sessionCacheSize` and `sessionWaitTimeout` properties.\nAs its name suggests, the `sessionCacheSize` property controls how many active sessions the factory maintains in its cache (the default is unbounded).\nIf the `sessionCacheSize` threshold has been reached, any attempt to acquire another session blocks until either one of the cached sessions becomes available or until the wait time for a session expires (the default wait time is `Integer.MAX_VALUE`).\nThe `sessionWaitTimeout` property enables configuration of the wait time.\n\nIf you want your sessions to be cached, configure your default session factory (as xref:sftp/session-factory.adoc[described earlier]) and then wrap it in an instance of `CachingSessionFactory` where you may provide those additional properties.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<bean id=\"sftpSessionFactory\"\n class=\"org.springframework.integration.sftp.session.DefaultSftpSessionFactory\">\n <property name=\"host\" value=\"localhost\"/>\n</bean>\n\n<bean id=\"cachingSessionFactory\"\n class=\"org.springframework.integration.file.remote.session.CachingSessionFactory\">\n <constructor-arg ref=\"sftpSessionFactory\"/>\n <constructor-arg value=\"10\"/>\n <property name=\"sessionWaitTimeout\" value=\"1000\"/>\n</bean>\n----\n\nThe preceding example creates a `CachingSessionFactory` with its `sessionCacheSize` set to `10` and its `sessionWaitTimeout` set to one second (1000 milliseconds).\n\nStarting with Spring Integration version 3.0, the `CachingConnectionFactory` provides a `resetCache()` method.\nWhen invoked, all idle sessions are immediately closed and in-use sessions are closed when they are returned to the cache.\nWhen using `isSharedSession=true`, the channel is closed and the shared session is closed only when the last channel is closed.\nNew requests for sessions establish new sessions as necessary.\n\nStarting with version 5.1, the `CachingSessionFactory` has a new property `testSession`.\nWhen true, the session will be tested by performing a `REALPATH` command for an empty path to ensure it is still active; if not, it will be removed from the cache; a new session is created if no active sessions are in the cache.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/session-caching.adoc", "title": "session-caching", "heading": "session-caching", "heading_level": 1, "file_order": 148, "section_index": 0, "content_hash": "3250c90b649091e885ec408270c789ad2d2c2390780f6148054278db55dc1e40", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/session-caching.adoc"}}
{"id": "sha256:cc663582a02ffad0cd4738a976ff45637e5bd86a103e511836b05fcd23111aae", "content": "[[sftp-session-callback]]\n\nStarting with Spring Integration version 4.2, you can use a `MessageSessionCallback<F, T>` implementation with the `<int-sftp:outbound-gateway/>` (`SftpOutboundGateway`) to perform any operation on the `Session<SftpClient.DirEntry>` with the `requestMessage` context.\nYou can use it for any non-standard or low-level SFTP operation (or several), such as allowing access from an integration flow definition, or functional interface (lambda) implementation injection.\nThe following example uses a lambda:\n\n[source,java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"sftpChannel\")\npublic MessageHandler sftpOutboundGateway(SessionFactory<SftpClient.DirEntry> sessionFactory) {\n return new SftpOutboundGateway(sessionFactory,\n (session, requestMessage) -> session.list(requestMessage.getPayload()));\n}\n----\n\nAnother example might be to pre- or post-process the file data being sent or retrieved.\n\nWhen using XML configuration, the `<int-sftp:outbound-gateway/>` provides a `session-callback` attribute that lets you specify the `MessageSessionCallback` bean name.\n\nNOTE: The `session-callback` is mutually exclusive with the `command` and `expression` attributes.\nWhen configuring with Java, the `SftpOutboundGateway` class offers different constructors.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/session-callback.adoc", "title": "session-callback", "heading": "session-callback", "heading_level": 1, "file_order": 149, "section_index": 0, "content_hash": "cc663582a02ffad0cd4738a976ff45637e5bd86a103e511836b05fcd23111aae", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/session-callback.adoc"}}
{"id": "sha256:944250c45c5817f96921ea910c658c9bc148f7e6e45ddb147d7cfe15768dc230", "content": "[[sftp-session-factory]]\n\nIMPORTANT: As of version 3.0, sessions are no longer cached by default.\nSee xref:sftp/session-caching.adoc[SFTP Session Caching].\n\nBefore configuring SFTP adapters, you must configure an SFTP session factory.\nYou can configure the SFTP session factory with a regular bean definition, as the following example shows:\n\n[source,xml]\n----\n<beans:bean id=\"sftpSessionFactory\"\n class=\"org.springframework.integration.sftp.session.DefaultSftpSessionFactory\">\n <beans:property name=\"host\" value=\"localhost\"/>\n <beans:property name=\"privateKey\" value=\"classpath:META-INF/keys/sftpTest\"/>\n <beans:property name=\"privateKeyPassphrase\" value=\"springIntegration\"/>\n <beans:property name=\"port\" value=\"22\"/>\n <beans:property name=\"user\" value=\"kermit\"/>\n</beans:bean>\n----\n\nEvery time an adapter requests a session object from its `SessionFactory`, a new SFTP session is created.\nUnder the covers, the SFTP Session Factory relies on the https://mina.apache.org/sshd-project/index.html[Apache MINA SSHD] library to provide the SFTP capabilities.\n\nHowever, Spring Integration also supports the caching of SFTP sessions.\nSee xref:sftp/session-caching.adoc[SFTP Session Caching] for more information.\n\nNOTE: The `DefaultSftpSessionFactory` can use an externally configured or extended `SshClient`.\nFor example, the `org.eclipse.jgit.internal.transport.sshd.JGitSshClient` extension from the `org.eclipse.jgit:org.eclipse.jgit.ssh.apache` library may be used to provide support for HTTP/SOCKS proxies.\n\n[IMPORTANT]\n=====\nThe `SshClient` supports multiple channels (operations) over a connection to the server.\nBy default, the Spring Integration session factory uses a separate physical connection for each channel.\nSince Spring Integration 3.0, you can configure the session factory (using a boolean constructor arg - default `false`) to use a single connection to the server and create multiple `SftpClient` instances on that single connection.\n\nWhen using this feature, you must wrap the session factory in a caching session factory, as xref:sftp/session-caching.adoc[described later], so that the connection is not physically closed when an operation completes.\n\nIf the cache is reset, the session is disconnected only when the last channel is closed.\n\nThe connection is refreshed if it to be disconnected when a new operation obtains a session.\n=====\n\nNow all you need to do is inject this SFTP session factory into your adapters.\n\nNOTE: A more practical way to provide values for the SFTP session factory is to use Spring's https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-factory-placeholderconfigurer[property placeholder support].\n\nStarting with version 6.1.3, the `DefaultSftpSessionFactory` introduces a `createSftpClient(...)` to support a custom `SftpClient`.\nSee a sample below of how to override `createSftpChannelSubsystem()` method in your custom `SftpClient` to add, for example, some custom `RequestHandler` for SFTP sub-system requests and replies:\n\n[source, java]\n----\n@Override\nprotected ChannelSubsystem createSftpChannelSubsystem(ClientSession clientSession) {\n ChannelSubsystem sftpChannelSubsystem = super.createSftpChannelSubsystem(clientSession);\n sftpChannelSubsystem.addRequestHandler((channel, request, wantReply, buffer) -> ...);\n return sftpChannelSubsystem;\n}\n----\n\n[[sftp-session-factory-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/session-factory.adoc", "title": "session-factory", "heading": "session-factory", "heading_level": 1, "file_order": 150, "section_index": 0, "content_hash": "944250c45c5817f96921ea910c658c9bc148f7e6e45ddb147d7cfe15768dc230", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/session-factory.adoc"}}
{"id": "sha256:08e46f98ed02792be236eb16249a9615953a2fbc83e6670397a63a28885ea551", "content": "The following list describes all the properties that are exposed by the https://docs.spring.io/spring-integration/api/org/springframework/integration/sftp/session/DefaultSftpSessionFactory.html[`DefaultSftpSessionFactory`].\n\n`isSharedSession` (constructor argument)::When `true`, a single `SftpClient` is used for all the requested `SftpSession` instances.\nIt defaults to `false`.\n\n`sftpVersionSelector`::An `SftpVersionSelector` instance for SFTP protocol selection.\nThe default one is `SftpVersionSelector.CURRENT`.\n\n`host`::The URL of the host to which to connect.\nRequired.\n\n`hostConfig`::An `org.apache.sshd.client.config.hosts.HostConfigEntry` instance as an alternative for the user/host/port options.\nCan be configured with a proxy jump property.\n\n`port`::The port over which the SFTP connection shall be established.\nIf not specified, this value defaults to `22`.\nIf specified, this property must be a positive number.\n\n`user`::The remote user to use.\nRequired.\n\n`knownHostsResource`::An `org.springframework.core.io.Resource` that used for a host key repository.\nThe content of the resource has to be the same format as OpenSSH `known_hosts` file and is required and must be pre-populated if `allowUnknownKeys` is false.\n\n`password`::The password to authenticate against the remote host.\nIf a password is not provided, then the `privateKey` property is required.\n\n`privateKey`::An `org.springframework.core.io.Resource` that represents the location of the private key used for authenticating against the remote host.\nIf the `privateKey` is not provided, then the `password` property is required.\n\n`privateKeyPassphrase`::The password for the private key.\nIf you set `userInfo`, `privateKeyPassphrase` is not allowed .\nThe passphrase is obtained from that object.\nOptional.\n\n`timeout`::The timeout property is used as the socket timeout parameter, as well as the default connection timeout.\nDefaults to `30 seconds`.\nSetting to `0` means no timeout; to `null` - infinite wait.\n\n[[sftp-unk-keys]]\n`allowUnknownKeys`::Set to `true` to allow connections to hosts with unknown (or changed) keys.\nIts default is 'false'.\nIf `false`, a pre-populated `knownHosts` file is required.\n\n`userInteraction`::A custom `org.apache.sshd.client.auth.keyboard.UserInteraction` to be used during authentication.\n\nStarting with version 6.4, the `DefaultSftpSessionFactory` expose a `Consumer<SshClient>` configurer property to further customize an internal `SshClient`.\nFor example, this is how to change a default number of NIO workers and packet size for the client:\n\n[source, java]\n----\nsftpSessionFactory.setSshClientConfigurer((sshClient) -> {\n sshClient.setNioWorkers(27);\n PropertyResolverUtils.updateProperty(sshClient, CoreModuleProperties.MAX_PACKET_SIZE.getName(), 48 * 1024);\n});\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/session-factory.adoc", "title": "session-factory", "heading": "Configuration Properties", "heading_level": 2, "file_order": 150, "section_index": 1, "content_hash": "08e46f98ed02792be236eb16249a9615953a2fbc83e6670397a63a28885ea551", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/session-factory.adoc"}}
{"id": "sha256:14f7d3bbe3173d34f3f113dfcd71a2e5feed05d756a164337b9d72388718fb94", "content": "[[sftp-streaming]]\n\nVersion 4.3 introduced the streaming inbound channel adapter.\nThis adapter produces a message with payloads of type `InputStream`, letting you fetch files without writing to the local file system.\nSince the session remains open, the consuming application is responsible for closing the session when the file has been consumed.\nThe session is provided in the `closeableResource` header (`IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE`).\nStandard framework components, such as the `FileSplitter` and `StreamTransformer`, automatically close the session.\nSee xref:file/splitter.adoc[File Splitter] and xref:transformer.adoc#stream-transformer[Stream Transformer] for more information about these components.\nThe following example shows how to configure an SFTP streaming inbound channel adapter:\n\n[source, xml]\n----\n<int-sftp:inbound-streaming-channel-adapter id=\"ftpInbound\"\n channel=\"ftpChannel\"\n session-factory=\"sessionFactory\"\n filename-pattern=\"*.txt\"\n filename-regex=\".*\\.txt\"\n filter=\"filter\"\n filter-expression=\"@myFilterBean.check(#root)\"\n remote-file-separator=\"/\"\n comparator=\"comparator\"\n max-fetch-size=\"1\"\n remote-directory-expression=\"'foo/bar'\">\n <int:poller fixed-rate=\"1000\" />\n</int-sftp:inbound-streaming-channel-adapter>\n----\n\nYou can use only one of `filename-pattern`, `filename-regex`, `filter`, or `filter-expression`.\n\nIMPORTANT: Starting with version 5.0, by default, the `SftpStreamingMessageSource` adapter prevents duplicates for remote files by using `SftpPersistentAcceptOnceFileListFilter` based on the in-memory `SimpleMetadataStore`.\nBy default, this filter is also applied together with the filename pattern (or regex) as well.\nIf you need to allow duplicates, you can use the `AcceptAllFileListFilter`.\nYou can handle any other use cases by using `CompositeFileListFilter` (or `ChainFileListFilter`).\nThe Java configuration xref:sftp/streaming.adoc#sftp-streaming-java-config[shown later] shows one technique to remove the remote file after processing, avoiding duplicates.\n\nFor more information about the `SftpPersistentAcceptOnceFileListFilter`, and how it is used, see xref:file/remote-persistent-flf.adoc[Remote Persistent File List Filters].\n\nYou can use the `max-fetch-size` attribute to limit the number of files fetched on each poll when a fetch is necessary.\nSet it to `1` and use a persistent filter when running in a clustered environment.\nSee xref:sftp/max-fetch.adoc[Inbound Channel Adapters: Controlling Remote File Fetching] for more information.\n\nThe adapter puts the remote directory and the file name in headers (`FileHeaders.REMOTE_DIRECTORY` and `FileHeaders.REMOTE_FILE`, respectively).\nStarting with version 5.0, the `FileHeaders.REMOTE_FILE_INFO` header provides additional remote file information (in JSON).\nIf you set the `fileInfoJson` property on the `SftpStreamingMessageSource` to `false`, the header contains an `SftpFileInfo` object.\nYou can access the `SftpClient.DirEntry` object provided by the underlying `SftpClient` by using the `SftpFileInfo.getFileInfo()` method.\nThe `fileInfoJson` property is not available when you use XML configuration, but you can set it by injecting the `SftpStreamingMessageSource` into one of your configuration classes.\nSee also xref:sftp/remote-file-info.adoc[Remote File Information].\n\n[[sftp-streaming-java-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/streaming.adoc", "title": "streaming", "heading": "streaming", "heading_level": 1, "file_order": 151, "section_index": 0, "content_hash": "14f7d3bbe3173d34f3f113dfcd71a2e5feed05d756a164337b9d72388718fb94", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/streaming.adoc"}}
{"id": "sha256:ee05d52c7d97be875447a91ec7bceb5fb578b07e94b5d7ce4c977dc3a5230d4a", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with Java:\n\n[source, java]\n----\n@SpringBootApplication\npublic class SftpJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(SftpJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n @InboundChannelAdapter(channel = \"stream\")\n public MessageSource<InputStream> ftpMessageSource() {\n SftpStreamingMessageSource messageSource = new SftpStreamingMessageSource(template());\n messageSource.setRemoteDirectory(\"sftpSource/\");\n messageSource.setFilter(new AcceptAllFileListFilter<>());\n messageSource.setMaxFetchSize(1);\n return messageSource;\n }\n\n @Bean\n @Transformer(inputChannel = \"stream\", outputChannel = \"data\")\n public org.springframework.integration.transformer.Transformer transformer() {\n return new StreamTransformer(\"UTF-8\");\n }\n\n @Bean\n public SftpRemoteFileTemplate template() {\n return new SftpRemoteFileTemplate(sftpSessionFactory());\n }\n\n @ServiceActivator(inputChannel = \"data\", adviceChain = \"after\")\n @Bean\n public MessageHandler handle() {\n return System.out::println;\n }\n\n @Bean\n public ExpressionEvaluatingRequestHandlerAdvice after() {\n ExpressionEvaluatingRequestHandlerAdvice advice = new ExpressionEvaluatingRequestHandlerAdvice();\n advice.setOnSuccessExpression(\n \"@template.remove(headers['file_remoteDirectory'] + '/' + headers['file_remoteFile'])\");\n advice.setPropagateEvaluationFailures(true);\n return advice;\n }\n\n}\n----\n\nNotice that, in this example, the message handler downstream of the transformer has an `advice` that removes the remote file after processing.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp/streaming.adoc", "title": "streaming", "heading": "Configuring with Java Configuration", "heading_level": 2, "file_order": 151, "section_index": 1, "content_hash": "ee05d52c7d97be875447a91ec7bceb5fb578b07e94b5d7ce4c977dc3a5230d4a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp/streaming.adoc"}}
{"id": "sha256:141d87469bb702e26777bb3992e7d037992efcc20a521fe94eba7894e5f321d6", "content": "[[xml-transformation]]\n\nThis section covers how to transform XML payloads\n\n[[xml-transformation-beans]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/transformation.adoc", "title": "transformation", "heading": "transformation", "heading_level": 1, "file_order": 152, "section_index": 0, "content_hash": "141d87469bb702e26777bb3992e7d037992efcc20a521fe94eba7894e5f321d6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/transformation.adoc"}}
{"id": "sha256:cfe7117a904594734666d8b1ffca0187d20793f257e77033e755363f19f9872a", "content": "This section will explain the workings of the following transformers and how to configure them as beans:\n\n* link:#xml-unmarshalling-transformer[UnmarshallingTransformer]\n* link:#xml-marshalling-transformer[MarshallingTransformer]\n* link:#xml-xslt-payload-transformers[XsltPayloadTransformer]\n\nAll the XML transformers extend either https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/AbstractTransformer.html[`AbstractTransformer`] or https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/AbstractPayloadTransformer.html[`AbstractPayloadTransformer`] and therefore implement https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/Transformer.html[`Transformer`].\nWhen configuring XML transformers as beans in Spring Integration, you would normally configure the `Transformer` in conjunction with a https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/MessageTransformingHandler.html[`MessageTransformingHandler`].\nThis lets the transformer be used as an endpoint.\nFinally, we discuss the namespace support, which allows for configuring the transformers as elements in XML.\n\n[[xml-unmarshalling-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/transformation.adoc", "title": "transformation", "heading": "Configuring Transformers as Beans", "heading_level": 2, "file_order": 152, "section_index": 1, "content_hash": "cfe7117a904594734666d8b1ffca0187d20793f257e77033e755363f19f9872a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/transformation.adoc"}}
{"id": "sha256:84888f9ddf4cab889f904b2fde66d1b63740403bdf09e3a5893f895288c3fe60", "content": "An https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/UnmarshallingTransformer.html[`UnmarshallingTransformer`] lets an XML `Source` be unmarshalled by using implementations of the https://docs.spring.io/spring/docs/current/spring-framework-reference/html/oxm.html[Spring OXM] `Unmarshaller`.\nSpring's Object/XML Mapping support provides several implementations that support marshalling and unmarshalling by using https://en.wikipedia.org/wiki/Java_Architecture_for_XML_Binding[JAXB], https://castor-data-binding.github.io/castor/reference-guide/reference/xml/xml-framework.html[Castor], https://en.wikipedia.org/wiki/JiBX[JiBX], and others.\nThe unmarshaller requires an instance of `Source`.\nIf the message payload is not an instance of `Source`, conversion is still attempted.\nCurrently, `String`, `File`, `byte[]` and `org.w3c.dom.Document` payloads are supported.\nTo create a custom conversion to a `Source`, you can inject an implementation of a https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/source/SourceFactory.html[`SourceFactory`].\n\nNOTE: If you do not explicitly set a `SourceFactory`, the property on the `UnmarshallingTransformer` is, by default, set to a https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/source/DomSourceFactory.html[`DomSourceFactory`].\n\nStarting with version 5.0, the `UnmarshallingTransformer` also supports an `org.springframework.ws.mime.MimeMessage` as the incoming payload.\nThis can be useful when we receive a raw `WebServiceMessage` with MTOM attachments over SOAP .\nSee xref:ws.adoc#mtom-support[MTOM Support] for more information.\n\nThe following example shows how to define an unmarshalling transformer:\n\n[source,xml]\n----\n<bean id=\"unmarshallingTransformer\" class=\"o.s.i.xml.transformer.UnmarshallingTransformer\">\n <constructor-arg>\n <bean class=\"org.springframework.oxm.jaxb.Jaxb2Marshaller\">\n <property name=\"contextPath\" value=\"org.example\" />\n </bean>\n </constructor-arg>\n</bean>\n----\n\n[[xml-marshalling-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/transformation.adoc", "title": "transformation", "heading": "UnmarshallingTransformer", "heading_level": 3, "file_order": 152, "section_index": 2, "content_hash": "84888f9ddf4cab889f904b2fde66d1b63740403bdf09e3a5893f895288c3fe60", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/transformation.adoc"}}
{"id": "sha256:dd2d9d3875090a5793a55bf57629a26cf7393eb1309b0d86a231d9bbe5bd10ee", "content": "The https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/MarshallingTransformer.html[`MarshallingTransformer`] lets an object graph be converted into XML by using a Spring OXM `Marshaller`.\nBy default, the `MarshallingTransformer` returns a `DomResult`.\nHowever, you can control the type of result by configuring an alternative `ResultFactory`, such as `StringResultFactory`.\nIn many cases, it is more convenient to transform the payload into an alternative XML format.\nTo do so, configure a `ResultTransformer`.\nSpring integration provides two implementations, one that converts to `String` and another that converts to `Document`.\nThe following example configures a marshalling transformer that transforms to a document:\n\n[source,xml]\n----\n<bean id=\"marshallingTransformer\" class=\"o.s.i.xml.transformer.MarshallingTransformer\">\n <constructor-arg>\n <bean class=\"org.springframework.oxm.jaxb.Jaxb2Marshaller\">\n <property name=\"contextPath\" value=\"org.example\"/>\n </bean>\n </constructor-arg>\n <constructor-arg>\n <bean class=\"o.s.i.xml.transformer.ResultToDocumentTransformer\"/>\n </constructor-arg>\n</bean>\n----\n\nBy default, the `MarshallingTransformer` passes the payload object to the `Marshaller`.\nHowever, if its boolean `extractPayload` property is set to `false`, the entire `Message` instance is passed to the `Marshaller` instead.\nThat may be useful for certain custom implementations of the `Marshaller` interface, but, typically, the payload is the appropriate source object for marshalling when you delegate to any of the various `Marshaller` implementations.\n\n[[xml-xslt-payload-transformers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/transformation.adoc", "title": "transformation", "heading": "Using `MarshallingTransformer`", "heading_level": 3, "file_order": 152, "section_index": 3, "content_hash": "dd2d9d3875090a5793a55bf57629a26cf7393eb1309b0d86a231d9bbe5bd10ee", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/transformation.adoc"}}
{"id": "sha256:153dc3a3ed1aa36aa038f93d0228fbc932578f9db23ca6fe2b89f1523105dd93", "content": "The https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/XsltPayloadTransformer.html[`XsltPayloadTransformer`] transforms XML payloads by using https://en.wikipedia.org/wiki/XSL_Transformations[Extensible Stylesheet Language Transformations] (XSLT).\nThe transformer's constructor requires an instance of either https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/io/Resource.html[Resource] or https://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Templates.html[Templates] to be passed in.\nPassing in a `Templates` instance allows for greater configuration of the `TransformerFactory` used to create the template instance.\n\nAs with the link:#xml-unmarshalling-transformer[`UnmarshallingTransformer`], the `XsltPayloadTransformer` does the actual XSLT transformation against instances of `Source`.\nTherefore, if the message payload is not an instance of `Source`, conversion is still attempted.\n`String` and `Document` payloads are supported directly.\n\nTo create a custom conversion to a `Source`, you can inject an implementation of a https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/source/SourceFactory.html[`SourceFactory`].\n\nNOTE: If a `SourceFactory` is not set explicitly, the property on the `XsltPayloadTransformer` is, by default, set to a https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/source/DomSourceFactory.html[`DomSourceFactory`].\n\nBy default, the `XsltPayloadTransformer` creates a message with a https://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Result.html[`Result`] payload, similar to the `XmlPayloadMarshallingTransformer`.\nYou can customize this by providing a https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/result/ResultFactory.html[`ResultFactory`] or a https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/ResultTransformer.html[`ResultTransformer`].\n\nThe following example configures a bean that works as an XSLT payload transformer:\n\n[source,xml]\n----\n<bean id=\"xsltPayloadTransformer\" class=\"o.s.i.xml.transformer.XsltPayloadTransformer\">\n <constructor-arg value=\"classpath:org/example/xsl/transform.xsl\"/>\n <constructor-arg>\n <bean class=\"o.s.i.xml.transformer.ResultToDocumentTransformer\"/>\n </constructor-arg>\n</bean>\n----\n\nStarting with Spring Integration 3.0, you can specify the transformer factory class name by using a constructor argument.\nYou can do so by using the `transformer-factory-class` attribute when you use the namespace.\n\n[[xml-using-result-transformers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/transformation.adoc", "title": "transformation", "heading": "XsltPayloadTransformer", "heading_level": 3, "file_order": 152, "section_index": 4, "content_hash": "153dc3a3ed1aa36aa038f93d0228fbc932578f9db23ca6fe2b89f1523105dd93", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/transformation.adoc"}}
{"id": "sha256:fda261c5e421993ad1f2147c6969f5ac6d2f1a0e612fb9f556d4a9d962fb29be", "content": "Both the `MarshallingTransformer` and the `XsltPayloadTransformer` let you specify a https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/ResultTransformer.html[`ResultTransformer`].\nThus, if the marshalling or XSLT transformation returns a https://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Result.html[`Result`], you have the option to also use a `ResultTransformer` to transform the `Result` into another format.\nSpring Integration provides two concrete `ResultTransformer` implementations:\n\n* https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/ResultToDocumentTransformer.html[`ResultToDocumentTransformer`]\n* https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/ResultToStringTransformer.html[`ResultToStringTransformer`]\n\nBy default, the `MarshallingTransformer` always returns a https://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Result.html[`Result`].\nBy specifying a `ResultTransformer`, you can customize the type of payload returned.\n\nThe behavior is slightly more complex for the `XsltPayloadTransformer`.\nBy default, if the input payload is an instance of `String` or https://docs.oracle.com/javase/6/docs/api/org/w3c/dom/Document.html[`Document`] the `resultTransformer` property is ignored.\n\nHowever, if the input payload is a https://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Source.html[`Source`] or any other type, the `resultTransformer` property is applied.\nAdditionally, you can set the `alwaysUseResultFactory` property to `true`, which also causes the specified `resultTransformer` to be used.\n\nFor more information and examples, see xref:xml/transformation.adoc#xml-using-result-transformers-namespace[Namespace Configuration and Result Transformers].\n\n[[xml-transformer-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/transformation.adoc", "title": "transformation", "heading": "Using `ResultTransformer` Implementations", "heading_level": 3, "file_order": 152, "section_index": 5, "content_hash": "fda261c5e421993ad1f2147c6969f5ac6d2f1a0e612fb9f556d4a9d962fb29be", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/transformation.adoc"}}
{"id": "sha256:813c5b5811ff6d139f31c7f2d70403b69fb059fc4beec80b4cc3f956de18bf20", "content": "Namespace support for all XML transformers is provided in the Spring Integration XML namespace, a template for which was xref:xml/xpath-namespace-support.adoc[shown earlier].\nThe namespace support for transformers creates an instance of either `EventDrivenConsumer` or `PollingConsumer`, according to the type of the provided input channel.\nThe namespace support is designed to reduce the amount of XML configuration by allowing the creation of an endpoint and transformer that use one element.\n\n[[using-an-unmarshallingtransformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/transformation.adoc", "title": "transformation", "heading": "Namespace Support for XML Transformers", "heading_level": 2, "file_order": 152, "section_index": 6, "content_hash": "813c5b5811ff6d139f31c7f2d70403b69fb059fc4beec80b4cc3f956de18bf20", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/transformation.adoc"}}
{"id": "sha256:6956fe0626efe466fddbbbb85f72e881818afe83a83207ba28e136bb88613d4c", "content": "The namespace support for the `UnmarshallingTransformer` is shown below.\nSince the namespace creates an endpoint instance rather than a transformer, you can nest a poller within the element to control the polling of the input channel.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<int-xml:unmarshalling-transformer id=\"defaultUnmarshaller\"\n input-channel=\"input\" output-channel=\"output\"\n unmarshaller=\"unmarshaller\"/>\n\n<int-xml:unmarshalling-transformer id=\"unmarshallerWithPoller\"\n input-channel=\"input\" output-channel=\"output\"\n unmarshaller=\"unmarshaller\">\n <int:poller fixed-rate=\"2000\"/>\n<int-xml:unmarshalling-transformer/>\n----\n\n[[using-a-marshallingtransformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/transformation.adoc", "title": "transformation", "heading": "Using an `UnmarshallingTransformer`", "heading_level": 3, "file_order": 152, "section_index": 7, "content_hash": "6956fe0626efe466fddbbbb85f72e881818afe83a83207ba28e136bb88613d4c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/transformation.adoc"}}
{"id": "sha256:8aac95d205de3f3648aae7188bb663aa6bc7bf96f448eb94e687ec3279d8926a", "content": "The namespace support for the marshalling transformer requires an `input-channel`, an `output-channel`, and a reference to a `marshaller`.\nYou can use the optional `result-type` attribute to control the type of result created.\nValid values are `StringResult` or `DomResult` (the default).\nThe following example configures a marshalling transformer:\n\n[source,xml]\n----\n<int-xml:marshalling-transformer\n input-channel=\"marshallingTransformerStringResultFactory\"\n output-channel=\"output\"\n marshaller=\"marshaller\"\n result-type=\"StringResult\" />\n\n<int-xml:marshalling-transformer\n input-channel=\"marshallingTransformerWithResultTransformer\"\n output-channel=\"output\"\n marshaller=\"marshaller\"\n result-transformer=\"resultTransformer\" />\n\n<bean id=\"resultTransformer\" class=\"o.s.i.xml.transformer.ResultToStringTransformer\"/>\n----\n\nWhere the provided result types do not suffice, you can provide a reference to a custom implementation of `ResultFactory` as an alternative to setting the `result-type` attribute by using the `result-factory` attribute.\nThe `result-type` and `result-factory` attributes are mutually exclusive.\n\nNOTE: Internally, the `StringResult` and `DomResult` result types are represented by the `ResultFactory` implementations: https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/result/StringResultFactory.html[`StringResultFactory`] and https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/result/DomResultFactory.html[`DomResultFactory`] respectively.\n\n[[using-an-xsltpayloadtransformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/transformation.adoc", "title": "transformation", "heading": "Using a `MarshallingTransformer`", "heading_level": 3, "file_order": 152, "section_index": 8, "content_hash": "8aac95d205de3f3648aae7188bb663aa6bc7bf96f448eb94e687ec3279d8926a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/transformation.adoc"}}
{"id": "sha256:3cd1d26e19183e28dc7784fbdd4799bd0c77bcf688ff4d0595d80e027f2b185f", "content": "Namespace support for the `XsltPayloadTransformer` lets you either pass in a `Resource` (in order to create the https://docs.oracle.com/javase/6/docs/api/javax/xml/transform/Templates.html[`Templates`] instance) or pass in a pre-created `Templates` instance as a reference.\nAs with the marshalling transformer, you can control the type of the result output by specifying either the `result-factory` or the `result-type` attribute.\nWhen you need to convert a result before sending, you can use a `result-transformer` attribute to reference an implementation of `ResultTransformer`.\n\nIMPORTANT: If you specify the `result-factory` or the `result-type` attribute, the `alwaysUseResultFactory` property on the underlying https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/XsltPayloadTransformer.html[`XsltPayloadTransformer`] is set to `true` by the https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/config/XsltPayloadTransformerParser.html[`XsltPayloadTransformerParser`].\n\nThe following example configures two XSLT transformers:\n\n[source,xml]\n----\n<int-xml:xslt-transformer id=\"xsltTransformerWithResource\"\n input-channel=\"withResourceIn\" output-channel=\"output\"\n xsl-resource=\"org/springframework/integration/xml/config/test.xsl\"/>\n\n<int-xml:xslt-transformer id=\"xsltTransformerWithTemplatesAndResultTransformer\"\n input-channel=\"withTemplatesAndResultTransformerIn\" output-channel=\"output\"\n xsl-templates=\"templates\"\n result-transformer=\"resultTransformer\"/>\n----\n\nYou may need to have access to `Message` data, such as the `Message` headers, in order to assist with transformation.\nFor example, you may need to get access to certain `Message` headers and pass them on as parameters to a transformer, for example, `transformer.setParameter(..)`.\nSpring Integration provides two convenient ways to accomplish this, as the following example shows:\n\n[source,xml]\n----\n<int-xml:xslt-transformer id=\"paramHeadersCombo\"\n input-channel=\"paramHeadersComboChannel\" output-channel=\"output\"\n xsl-resource=\"classpath:transformer.xslt\"\n xslt-param-headers=\"testP*, *foo, bar, baz\">\n\n <int-xml:xslt-param name=\"helloParameter\" value=\"hello\"/>\n <int-xml:xslt-param name=\"firstName\" expression=\"headers.fname\"/>\n</int-xml:xslt-transformer>\n----\n\nIf message header names match one-to-one to parameter names, you can use the `xslt-param-headers` attribute.\nIn it, you can use wildcards for simple pattern matching.\nIt supports the following simple pattern styles: `xxx*`, `*xxx`, `*xxx*`, and `xxx*yyy`.\n\nYou can also configure individual XSLT parameters by using the `<xslt-param/>` element.\nOn that element, you can set the `expression` attribute or the `value` attribute.\nThe `expression` attribute should be any valid SpEL expression with the `Message` being the root object of the expression evaluation context.\nThe `value` attribute (as with any `value` in Spring beans) lets you specify simple scalar values.\nYou can also use property placeholders (such as `${some.value}`).\nSo, with the `expression` and `value` attributes, you can map XSLT parameters to any accessible part of the `Message` as well as any literal value.\n\nStarting with Spring Integration 3.0, you can now specify the transformer factory class name by setting the `transformer-factory-class` attribute.\n\n[[xml-using-result-transformers-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/transformation.adoc", "title": "transformation", "heading": "Using an `XsltPayloadTransformer`", "heading_level": 3, "file_order": 152, "section_index": 9, "content_hash": "3cd1d26e19183e28dc7784fbdd4799bd0c77bcf688ff4d0595d80e027f2b185f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/transformation.adoc"}}
{"id": "sha256:3db9611c383dda44dc916b0d8f7ea21b82777aefee1db60354c679b3d0338af7", "content": "We cover using result transformers in xref:xml/transformation.adoc#xml-using-result-transformers[Using `ResultTransformer` Implementations].\nThe examples in this section use XML namespace configuration to illustrate several special use cases.\nFirst, we define the `ResultTransformer`, as the following example shows:\n\n[source,xml]\n----\n<beans:bean id=\"resultToDoc\" class=\"o.s.i.xml.transformer.ResultToDocumentTransformer\"/>\n----\n\nThis `ResultTransformer` accepts either a `StringResult` or a `DOMResult` as input and converts the input into a `Document`.\n\nNow we can declare the transformer as follows:\n\n[source,xml]\n----\n<int-xml:xslt-transformer input-channel=\"in\" output-channel=\"fahrenheitChannel\"\n xsl-resource=\"classpath:noop.xslt\" result-transformer=\"resultToDoc\"/>\n----\n\nIf the incoming message's payload is of type `Source`, then, as a first step, the `Result` is determined by using the `ResultFactory`.\nAs we did not specify a `ResultFactory`, the default `DomResultFactory` is used, meaning that the transformation yields a `DomResult`.\n\nHowever, as we specified a `ResultTransformer`, it is used and the resulting `Message` payload is of type `Document`.\n\nIMPORTANT: The specified `ResultTransformer` is ignored with `String` or `Document` payloads.\nIf the incoming message's payload is of type `String`, the payload after the XSLT transformation is a `String`.\nSimilarly, if the incoming message's payload is of type `Document`, the payload after the XSLT transformation is a`Document`.\n\nIf the message payload is not a `Source`, a `String`, or a `Document`, as a fallback option, we try to create a`Source` by using the default https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/source/SourceFactory.html[`SourceFactory`].\nAs we did not specify a `SourceFactory` explicitly by using the `source-factory` attribute, the default https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/source/DomSourceFactory.html[`DomSourceFactory`] is used.\nIf successful, the XSLT transformation is executed as if the payload was of type `Source`, as described in the previous paragraphs.\n\nNOTE: The `DomSourceFactory` supports the creation of a `DOMSource` from a `Document`, a `File`, or a `String` payload.\n\nThe next transformer declaration adds a `result-type` attribute that uses `StringResult` as its value.\nThe `result-type` is internally represented by the `StringResultFactory`.\nThus, you could have also added a reference to a `StringResultFactory`, by using the `result-factory` attribute, which would have been the same.\nThe following example shows that transformer declaration:\n\n[source,xml]\n----\n<int-xml:xslt-transformer input-channel=\"in\" output-channel=\"fahrenheitChannel\"\n xsl-resource=\"classpath:noop.xslt\" result-transformer=\"resultToDoc\"\n result-type=\"StringResult\"/>\n----\n\nBecause we use a `ResultFactory`, the `alwaysUseResultFactory` property of the `XsltPayloadTransformer` class is implicitly set to `true`.\nConsequently, the referenced `ResultToDocumentTransformer` is used.\n\nTherefore, if you transform a payload of type `String`, the resulting payload is of type https://docs.oracle.com/javase/6/docs/api/org/w3c/dom/Document.html[`Document`].\n\n[[xsltpayloadtransformer-and-output-method]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/transformation.adoc", "title": "transformation", "heading": "Namespace Configuration and Result Transformers", "heading_level": 2, "file_order": 152, "section_index": 10, "content_hash": "3db9611c383dda44dc916b0d8f7ea21b82777aefee1db60354c679b3d0338af7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/transformation.adoc"}}
{"id": "sha256:22e8f0d8e8cf2d873748eb459bf34e6e7bdab39aaee45f122a5e5095f0e6c094", "content": "`<xsl:output method=\"text\"/>` tells the XSLT template to produce only text content from the input source.\nIn this particular case, we have no reason to use a `DomResult`.\nTherefore, the https://docs.spring.io/spring-integration/api/org/springframework/integration/xml/transformer/XsltPayloadTransformer.html[`XsltPayloadTransformer`] defaults to `StringResult` if the https://docs.oracle.com/javase/7/docs/api/javax/xml/transform/Transformer.html#getOutputProperties()[output property] called `method` of the underlying `javax.xml.transform.Transformer` returns `text`.\nThis coercion is performed independently of the inbound payload type.\nThis behavior is available only if the `result-type` attribute or the `result-factory` attribute for the `<int-xml:xslt-transformer>` component is set.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/transformation.adoc", "title": "transformation", "heading": "`XsltPayloadTransformer` and `<xsl:output method=\"text\"/>`", "heading_level": 3, "file_order": 152, "section_index": 11, "content_hash": "22e8f0d8e8cf2d873748eb459bf34e6e7bdab39aaee45f122a5e5095f0e6c094", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/transformation.adoc"}}
{"id": "sha256:e673460bbed08c2288c5b056d618edeb353f43fa34daca7544285288632b87dd", "content": "[[xml-validating-filter]]\n\nThe XML Validating Filter lets you validate incoming messages against provided schema instances.\nThe following schema types are supported:\n\n* xml-schema (https://www.w3.org/2001/XMLSchema)\n* relax-ng (https://relaxng.org)\n\nMessages that fail validation can either be silently dropped or be forwarded to a definable `discard-channel`.\nFurthermore, you can configure this filter to throw an `Exception` in case validation fails.\n\nThe following listing shows all the available configuration parameters:\n\n[source,xml]\n----\n<int-xml:validating-filter discard-channel=\"\" <1>\n id=\"\" <2>\n input-channel=\"\" <3>\n output-channel=\"\" <4>\n schema-location=\"\" <5>\n schema-type=\"xml-schema\" <6>\n throw-exception-on-rejection=\"false\" <7>\n xml-converter=\"\" <8>\n xml-validator=\"\"> <9>\n <int:poller .../> <10>\n</int-xml:validating-filter>\n----\n\n<1> Message channel where you want rejected messages to be sent.\nOptional.\n<2> ID for the underlying bean definition.\nOptional.\n<3> The receiving message channel of this endpoint.\nOptional.\n<4> Message channel where you want accepted messages to be sent.\nOptional.\n<5> Sets the location of the schema to validate the message's payload against.\nInternally uses the `org.springframework.core.io.Resource` interface.\nYou can set this attribute or the `xml-validator` attribute but not both.\nOptional.\n<6> Sets the schema type.\nCan be either `xml-schema` or `relax-ng`.\nOptional.\nIf not set, it defaults to `xml-schema`, which internally translates to `org.springframework.xml.validation.XmlValidatorFactory#SCHEMA_W3C_XML`.\n<7> If `true`, a `MessageRejectedException` is thrown if validation fails for the provided Message's payload.\nDefaults to `false` if not set.\nOptional.\n<8> Reference to a custom `org.springframework.integration.xml.XmlPayloadConverter` strategy.\nOptional.\n<9> Reference to a custom `sorg.springframework.xml.validation.XmlValidator` strategy.\nYou can set this attribute or the `schema-location` attribute but not both.\nOptional.\n<10> A poller to use with the XPath filter.\nOptional.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/validating-filter.adoc", "title": "validating-filter", "heading": "validating-filter", "heading_level": 1, "file_order": 153, "section_index": 0, "content_hash": "e673460bbed08c2288c5b056d618edeb353f43fa34daca7544285288632b87dd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/validating-filter.adoc"}}
{"id": "sha256:281d010915d5827f38c0349b29c75aebe7bbc2e2f42832a8c6ca48c6c284c8ae", "content": "[[xml-xpath-filter]]\n\nThis component defines an XPath-based message filter.\nInternally, these components use a `MessageFilter` that wraps an instance of `AbstractXPathMessageSelector`.\n\nNOTE: See xref:filter.adoc[Filter] for further details.\n\nTo use the XPath filter, you must, at a minimum, provide an XPath expression either by declaring the `xpath-expression` element or by referencing an XPath Expression in the `xpath-expression-ref` attribute.\n\nIf the provided XPath expression evaluates to a `boolean` value, no further configuration parameters are necessary.\nHowever, if the XPath expression evaluates to a `String`, you should set the `match-value` attribute, against which the evaluation result is matched.\n\n`match-type` has three options:\n\n* `exact`: Correspond to `equals` on `java.lang.String`.\nThe underlying implementation uses a `StringValueTestXPathMessageSelector`\n\n* `case-insensitive`: Correspond to `equals-ignore-case` on `java.lang.String`.\nThe underlying implementation uses a `StringValueTestXPathMessageSelector`\n\n* `regex`: Matches operations one `java.lang.String`.\nThe underlying implementation uses a `RegexTestXPathMessageSelector`\n\nWhen providing a 'match-type' value of 'regex', the value provided with the `match-value` attribute must be a valid regular expression.\n\nThe following example shows all the available attributes for the `xpath-filter` element:\n\n[source,xml]\n----\n<int-xml:xpath-filter discard-channel=\"\" <1>\n id=\"\" <2>\n input-channel=\"\" <3>\n match-type=\"exact\" <4>\n match-value=\"\" <5>\n output-channel=\"\" <6>\n throw-exception-on-rejection=\"false\" <7>\n xpath-expression-ref=\"\"> <8>\n <int-xml:xpath-expression ... /> <9>\n <int:poller ... /> <10>\n</int-xml:xpath-filter>\n----\n\n<1> Message channel where you want rejected messages to be sent.\nOptional.\n<2> ID for the underlying bean definition.\nOptional.\n<3> The receiving message channel of this endpoint.\nOptional.\n<4> Type of match to apply between the XPath evaluation result and the `match-value`.\nThe default is `exact`.\nOptional.\n<5> String value to be matched against the XPath evaluation result.\nIf you do not set this attribute, the XPath evaluation must produce a boolean result.\nOptional.\n<6> The channel to which messages that matched the filter criteria are dispatched.\nOptional.\n<7> By default, this property is set to `false` and rejected messages (those did not match the filter criteria) are silently dropped.\nHowever, if set to `true`, message rejection results in an error condition and an exception being propagated upstream to the caller.\nOptional.\n<8> Reference to an XPath expression instance to evaluate.\n<9> This child element sets the XPath expression to be evaluated.\nIf you do not include this element, you must set the `xpath-expression-ref` attribute.\nAlso, you can include only one `xpath-expression` element.\n<10> A poller to use with the XPath filter.\nOptional.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-filter.adoc", "title": "xpath-filter", "heading": "xpath-filter", "heading_level": 1, "file_order": 154, "section_index": 0, "content_hash": "281d010915d5827f38c0349b29c75aebe7bbc2e2f42832a8c6ca48c6c284c8ae", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-filter.adoc"}}
{"id": "sha256:b8097953ac7f3d9946db29074483f2d9188c79e47028a1c84a373852703b2de5", "content": "[[xml-xpath-header-enricher]]\n\nThe XPath header enricher defines a header enricher message transformer that evaluates an XPath expression against the message payload and inserts the result of the evaluation into a message header.\n\nThe following listing shows all the available configuration parameters:\n\n[source,xml]\n----\n<int-xml:xpath-header-enricher default-overwrite=\"true\" <1>\n id=\"\" <2>\n input-channel=\"\" <3>\n output-channel=\"\" <4>\n should-skip-nulls=\"true\"> <5>\n <int:poller></int:poller> <6>\n <int-xml:header name=\"\" <7>\n evaluation-type=\"STRING_RESULT\" <8>\n header-type=\"int\" <9>\n overwrite=\"true\" <10>\n xpath-expression=\"\" <11>\n xpath-expression-ref=\"\"/> <12>\n</int-xml:xpath-header-enricher>\n\n----\n\n<1> Specifies the default boolean value for whether to overwrite existing header values.\nIt takes effect only for child elements that do not provide their own `overwrite` attribute.\nIf you do not set the `default-overwrite` attribute, the specified header values do not overwrite any existing ones with the same header names.\nOptional.\n<2> ID for the underlying bean definition.\nOptional.\n<3> The receiving message channel of this endpoint.\nOptional.\n<4> Channel to which enriched messages are sent.\nOptional.\n<5> Specifies whether null values, such as might be returned from an expression evaluation, should be skipped.\nThe default value is `true`.\nIf a null value should trigger removal of the corresponding header, set this to `false`.\nOptional.\n<6> A poller to use with the header enricher.\nOptional.\n<7> The name of the header to be enriched.\nMandatory.\n<8> The result type expected from the XPath evaluation.\nIf you did not set a `header-type` attribute, this is the type of the header value.\nThe following values are allowed: `BOOLEAN_RESULT`, `STRING_RESULT`, `NUMBER_RESULT`, `NODE_RESULT`, and `NODE_LIST_RESULT`.\nIf not set, it defaults internally to `XPathEvaluationType.STRING_RESULT`.\nOptional.\n<9> The fully qualified class name for the header value type.\nThe result of the XPath evaluation is converted to this type by `ConversionService`.\nThis allows, for example, a `NUMBER_RESULT` (a double) to be converted to an `Integer`.\nThe type can be declared as a primitive (such as `int`), but the result is always the equivalent wrapper class (such as `Integer`).\nThe same integration `ConversionService` discussed in xref:endpoint.adoc#payload-type-conversion[Payload Type Conversion] is used for the conversion, so conversion to custom types is supported by adding a custom converter to the service.\nOptional.\n<10> Boolean value to indicate whether this header value should overwrite an existing header value for the same name if already present on the input `Message`.\n<11> The XPath expression as a `String`.\nYou must set either this attribute or `xpath-expression-ref`, but not both.\n<12> The XPath expression reference.\nYou must set either this attribute or `xpath-expression`, but not both.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-header-enricher.adoc", "title": "xpath-header-enricher", "heading": "xpath-header-enricher", "heading_level": 1, "file_order": 155, "section_index": 0, "content_hash": "b8097953ac7f3d9946db29074483f2d9188c79e47028a1c84a373852703b2de5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-header-enricher.adoc"}}
{"id": "sha256:3192ad313c0a1fc8140afa5f1448c47a2346a36df0208296c07cff45e2890de0", "content": "[[xpath-namespace-support]]\n\nAll components within the Spring Integration XML module provide namespace support.\nIn order to enable namespace support, you need to import the schema for the Spring Integration XML Module.\nThe following example shows a typical setup:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int=\"http://www.springframework.org/schema/integration\"\n xmlns:int-xml=\"http://www.springframework.org/schema/integration/xml\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration.xsd\n http://www.springframework.org/schema/integration/xml\n https://www.springframework.org/schema/integration/xml/spring-integration-xml.xsd\">\n</beans>\n----\n\n[[xml-xpath-expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-namespace-support.adoc", "title": "xpath-namespace-support", "heading": "xpath-namespace-support", "heading_level": 1, "file_order": 156, "section_index": 0, "content_hash": "3192ad313c0a1fc8140afa5f1448c47a2346a36df0208296c07cff45e2890de0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-namespace-support.adoc"}}
{"id": "sha256:63b308f5e32cd1d66456e977f9b8b9143814efd3e04b769672b4969cd8eb5634", "content": "Many of the components within the Spring Integration XML module work with XPath Expressions.\nEach of those components either references an XPath Expression that has been defined as a top-level element or uses a nested `<xpath-expression/>` element.\n\nAll forms of XPath expressions result in the creation of an `XPathExpression` that uses the Spring `org.springframework.xml.xpath.XPathExpressionFactory`.\nWhen XPath expressions are created, the best XPath implementation that is available on the classpath is used (either JAXP 1.3+ or Jaxen, with JAXP being preferred).\n\nNOTE: Internally, Spring Integration uses the XPath functionality provided by the Spring Web Services project (https://www.spring.io/spring-ws).\nSpecifically, we use the Spring Web Services XML module (spring-xml-x.x.x.jar).\nFor a deeper understanding, see the respective documentation at https://docs.spring.io/spring-ws/docs/current/reference/#xpath.\n\nHere is an overview of all available configuration parameters of the `xpath-expression` element:\nThe following listing shows the available attributes for the `xpath-expression` element:\n\n[source,xml]\n----\n<int-xml:xpath-expression expression=\"\" <1>\n id=\"\" <2>\n namespace-map=\"\" <3>\n ns-prefix=\"\" <4>\n ns-uri=\"\"> <5>\n <map></map> <6>\n</int-xml:xpath-expression>\n----\n\n<1> Defines an XPath expression.\nRequired.\n<2> The identifier of the underlying bean definition.\nIt is an instance of `org.springframework.xml.xpath.XPathExpression`.\nOptional.\n<3> Reference to a map that contains namespaces.\nThe key of the map defines the namespace prefix, and the value of the map sets the namespace URI.\nIt is not valid to specify both this attribute and the `map` element or the `ns-prefix` and `ns-uri` attributes.\nOptional.\n<4> Lets you set the namespace prefix directly as an attribute on the XPath expression element.\nIf you set `ns-prefix`, you must also set the `ns-uri` attribute.\nOptional.\n<5> Lets you directly set the namespace URI as an attribute on the XPath expression element.\nIf you set `ns-uri`, you must also set the `ns-prefix` attribute.\nOptional.\n<6> Defines a map that contains namespaces.\nOnly one `map` child element is allowed.\nThe key of the map defines the namespace prefix, and the value of the map sets the namespace URI.\nIt is not valid to specify both this element and the `map` attribute or set the `ns-prefix` and `ns-uri` attributes.\nOptional.\n\n[[providing-namespaces-optional-to-xpath-expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-namespace-support.adoc", "title": "xpath-namespace-support", "heading": "XPath Expressions", "heading_level": 2, "file_order": 156, "section_index": 1, "content_hash": "63b308f5e32cd1d66456e977f9b8b9143814efd3e04b769672b4969cd8eb5634", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-namespace-support.adoc"}}
{"id": "sha256:bce6c05d6c21c69e7165b7b35a326d9ce2f5bab7662074eb4b3b999be7f701d9", "content": "For the XPath Expression Element, you can provide namespace information as configuration parameters.\nYou can define namespaces by using one of the following choices:\n\n* Reference a map by using the `namespace-map` attribute\n* Provide a map of namespaces by using the `map` sub-element\n* Specify the `ns-prefix` and `ns-uri` attributes\n\nAll three options are mutually exclusive.\nOnly one option can be set.\n\nThe following example shows several different ways to use XPath expressions, including the options for setting the XML namespaces xref:xpath-namespace-support[mentioned earlier]:\n\n[source,xml]\n----\n<int-xml:xpath-filter id=\"filterReferencingXPathExpression\"\n xpath-expression-ref=\"refToXpathExpression\"/>\n\n<int-xml:xpath-expression id=\"refToXpathExpression\" expression=\"/name\"/>\n\n<int-xml:xpath-filter id=\"filterWithoutNamespace\">\n <int-xml:xpath-expression expression=\"/name\"/>\n</int-xml:xpath-filter>\n\n<int-xml:xpath-filter id=\"filterWithOneNamespace\">\n <int-xml:xpath-expression expression=\"/ns1:name\"\n ns-prefix=\"ns1\" ns-uri=\"www.example.org\"/>\n</int-xml:xpath-filter>\n\n<int-xml:xpath-filter id=\"filterWithTwoNamespaces\">\n <int-xml:xpath-expression expression=\"/ns1:name/ns2:type\">\n <map>\n <entry key=\"ns1\" value=\"www.example.org/one\"/>\n <entry key=\"ns2\" value=\"www.example.org/two\"/>\n </map>\n </int-xml:xpath-expression>\n</int-xml:xpath-filter>\n\n<int-xml:xpath-filter id=\"filterWithNamespaceMapReference\">\n <int-xml:xpath-expression expression=\"/ns1:name/ns2:type\"\n namespace-map=\"defaultNamespaces\"/>\n</int-xml:xpath-filter>\n\n<util:map id=\"defaultNamespaces\">\n <util:entry key=\"ns1\" value=\"www.example.org/one\"/>\n <util:entry key=\"ns2\" value=\"www.example.org/two\"/>\n</util:map>\n----\n\n[[using-xpath-expressions-with-default-namespaces]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-namespace-support.adoc", "title": "xpath-namespace-support", "heading": "Providing Namespaces (Optional) to XPath Expressions", "heading_level": 3, "file_order": 156, "section_index": 2, "content_hash": "bce6c05d6c21c69e7165b7b35a326d9ce2f5bab7662074eb4b3b999be7f701d9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-namespace-support.adoc"}}
{"id": "sha256:073607c43f6dae5e991c210d2637b3283342b2cb455044ee4313e21e9b5acac9", "content": "When working with default namespaces, you may run into situations that behave differently than you might expect.\nAssume we have the following XML document (which represents an order of two books):\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<order>\n <orderItem>\n <isbn>0321200683</isbn>\n <quantity>2</quantity>\n </orderItem>\n <orderItem>\n <isbn>1590596439</isbn>\n <quantity>1</quantity>\n </orderItem>\n</order>\n----\n\nThis document does not declare a namespace.\nTherefore, applying the following XPath Expression works as expected:\n\n[source,xml]\n----\n<int-xml:xpath-expression expression=\"/order/orderItem\" />\n----\n\nYou might expect that the same expression also works for the following XML file:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<order xmlns=\"http://www.example.org/orders\">\n\t<orderItem>\n <isbn>0321200683</isbn>\n <quantity>2</quantity>\n\t</orderItem>\n\t<orderItem>\n <isbn>1590596439</isbn>\n <quantity>1</quantity>\n\t</orderItem>\n</order>\n----\n\nThe preceding example looks exactly the same as the previous example but declares a default namespace.\n\nHowever, the previous XPath expression (`/order/orderItem`) fails in this case.\n\nIn order to solve this issue, you must provide a namespace prefix and a namespace URI either by setting the `ns-prefix` and `ns-uri` attributes or by setting the `namespace-map` attribute.\nThe namespace URI must match the namespace declared in your XML document.\nIn the preceding example, that is `http://www.example.org/orders`.\n\nYou can, however, arbitrarily choose the namespace prefix.\nIn fact, providing an empty string actually works.\n(However, null is not allowed.)\nIn the case of a namespace prefix consisting of an empty string, your Xpath expression must use a colon (`:`) to indicate the default namespace.\nIf you leave off the colon, the XPath expression does not match.\nThe following XPath Expression matches against the XML document in the preceding example:\n\n[source,xml]\n----\n<int-xml:xpath-expression expression=\"/:order/:orderItem\"\n ns-prefix=\"\" ns-uri=\"https://www.example.org/prodcuts\"/>\n----\n\nYou can also provide any other arbitrarily chosen namespace prefix.\nThe following XPath expression (which use the `myorder` namespace prefix) also matches:\n\n[source,xml]\n----\n<int-xml:xpath-expression expression=\"/myorder:order/myorder:orderItem\"\n ns-prefix=\"myorder\" ns-uri=\"https://www.example.org/prodcuts\"/>\n----\n\nThe namespace URI is the really important piece of information, not the prefix.\nThe https://github.com/jaxen-xpath/jaxen[Jaxen] summarizes the point very well:\n\n[quote]\nIn XPath 1.0, all unprefixed names are unqualified.\nThere is no requirement that the prefixes used in the XPath expression are the same as the prefixes used in the document being queried.\nOnly the namespace URIs need to match, not the prefixes.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-namespace-support.adoc", "title": "xpath-namespace-support", "heading": "Using XPath Expressions with Default Namespaces", "heading_level": 3, "file_order": 156, "section_index": 3, "content_hash": "073607c43f6dae5e991c210d2637b3283342b2cb455044ee4313e21e9b5acac9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-namespace-support.adoc"}}
{"id": "sha256:728ca98ee0e40509e3258cc2ed0fcf3d7ada903897f80e2c14339c4640241a4d", "content": "[[xml-xpath-routing]]\n\nSimilar to SpEL-based routers, Spring Integration provides support for routing messages based on XPath expressions, which lets you create a message endpoint with an input channel but no output channel.\nInstead, one or more output channels are determined dynamically.\nThe following example shows how to create such a router:\n\n[source,xml]\n----\n<int-xml:xpath-router id=\"orderTypeRouter\" input-channel=\"orderChannel\">\n <int-xml:xpath-expression expression=\"/order/type\"/>\n</int-xml:xpath-router>\n----\n\nNOTE: For an overview of attributes that are common among Routers, see xref:router/common-parameters.adoc[Common Router Parameters].\n\nInternally, XPath expressions are evaluated as type `NODESET` and converted to a `List<String>` that represents channel names.\nTypically, such a list contains a single channel name.\nHowever, based on the results of an XPath Expression, the XPath router can also take on the characteristics of a recipient list router if the XPath expression returns more than one value.\nIn that case, the `List<String>` contains more than one channel name.\nConsequently, messages are sent to all the channels in the list.\n\nThus, assuming that the XML file passed to the following router configuration contains many `responder` sub-elements that represent channel names, the message is sent to all of those channels:\n\n[source,xml]\n----\n<!-- route the order to all responders-->\n<int-xml:xpath-router id=\"responderRouter\" input-channel=\"orderChannel\">\n <int-xml:xpath-expression expression=\"/request/responders\"/>\n</int-xml:xpath-router>\n\n----\n\nIf the returned values do not represent the channel names directly, you can specify additional mapping parameters to map those returned values to actual channel names.\nFor example, if the `/request/responders` expression results in two values (`responderA` and `responderB`), but you do not want to couple the responder names to channel names, you can provide additional mapping configuration, such as the following:\n\n[source,xml]\n----\n<!-- route the order to all responders-->\n<int-xml:xpath-router id=\"responderRouter\" input-channel=\"orderChannel\">\n <int-xml:xpath-expression expression=\"/request/responders\"/>\n <int-xml:mapping value=\"responderA\" channel=\"channelA\"/>\n <int-xml:mapping value=\"responderB\" channel=\"channelB\"/>\n</int-xml:xpath-router>\n\n----\n\nAs already mentioned, the default evaluation type for XPath expressions is `NODESET`, which is converted to a `List<String>` of channel names, which handles single channel scenarios as well as multiple channel scenarios.\n\nNonetheless, certain XPath expressions may evaluate as type `String` from the very beginning.\nConsider, for example, the following XPath Expression:\n\n[source,xml]\n----\nname(./node())\n----\n\nThis expression returns the name of the root node.\nIf the default evaluation type `NODESET` is being used, it results in an exception.\n\nFor these scenarios, you can use the `evaluate-as-string` attribute, which lets you manage the evaluation type.\nIt is `FALSE` by default.\nHowever, if you set it to `TRUE`, the `String` evaluation type is used.\n\n[NOTE]\n=====\nXPath 1.0 specifies 4 data types:\n\n* Node-sets\n* Strings\n* Number\n* Boolean\n\nWhen the XPath Router evaluates expressions by using the optional `evaluate-as-string` attribute, the return value is determined by the `string()` function, as defined in the XPath specification.\nThis means that if the expression selects multiple nodes, it returns the string value of the first node.\n\nFor further information, see:\n\n* https://www.w3.org/TR/xpath/[Specification: XML Path Language (XPath) Version 1.0]\n* https://www.w3.org/TR/xpath-functions-31[XPath specification - string() function]\n=====\n\nFor example, if we want to route based on the name of the root node, we can use the following configuration:\n\n[source,xml]\n----\n<int-xml:xpath-router id=\"xpathRouterAsString\"\n input-channel=\"xpathStringChannel\"\n evaluate-as-string=\"true\">\n <int-xml:xpath-expression expression=\"name(./node())\"/>\n</int-xml:xpath-router>\n----\n\nThe out-of-the-box `#xpath()` xref:spel.adoc#built-in-spel-functions[SpEL function] is also powerful enough to use with a generic router definition, including recipient list router:\n\n[source,xml]\n----\n<int:recipient-list-router input-channel=\"xpathRecipientsInput\">\n <int:recipient channel=\"channelA\" selector-expression=\"#xpath(payload, '/passenger/age/text() &lt;= 2', 'boolean')\"/>\n <int:recipient channel=\"channelB\" selector-expression=\"#xpath(payload, '/passenger/age/text() > 12', 'boolean')\"/>\n</int:recipient-list-router>\n----\n\n[[xpath-routing-converter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-routing.adoc", "title": "xpath-routing", "heading": "xpath-routing", "heading_level": 1, "file_order": 157, "section_index": 0, "content_hash": "728ca98ee0e40509e3258cc2ed0fcf3d7ada903897f80e2c14339c4640241a4d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-routing.adoc"}}
{"id": "sha256:0cbd6812fc142f27a675cf6696b7e45452d82f8a989da0133699e23a4250a09a", "content": "For XPath Routers, you can also specify the Converter to use when converting payloads prior to XPath evaluation.\nAs such, the XPath Router supports custom implementations of the `XmlPayloadConverter` strategy, and when configuring an `xpath-router` element in XML, a reference to such an implementation may be provided via the `converter` attribute.\n\nIf this reference is not explicitly provided, the `DefaultXmlPayloadConverter` is used.\nIt should be sufficient in most cases, since it can convert from Node, Document, Source, File, and String typed payloads.\nIf you need to extend beyond the capabilities of that default implementation, then an upstream Transformer is generally a better option in most cases, rather than providing a reference to a custom implementation of this strategy here.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-routing.adoc", "title": "xpath-routing", "heading": "XML Payload Converter", "heading_level": 2, "file_order": 157, "section_index": 1, "content_hash": "0cbd6812fc142f27a675cf6696b7e45452d82f8a989da0133699e23a4250a09a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-routing.adoc"}}
{"id": "sha256:65e23d0b71800c14fd7ebf47ce06bc5b5479e416d43b3d3073ea199430bb8e1a", "content": "[[xpath-spel-function]]\n\nSpring Integration, since version 3.0, provides the built-in `#xpath` SpEL function, which invokes the `XPathUtils.evaluate(...)` static method.\nThis method delegates to an `org.springframework.xml.xpath.XPathExpression`.\nThe following listing shows some usage examples:\n\n[source,xml]\n----\n<transformer expression=\"#xpath(payload, '/name')\"/>\n\n<filter expression=\"#xpath(payload, headers.xpath, 'boolean')\"/>\n\n<splitter expression=\"#xpath(payload, '//book', 'document_list')\"/>\n\n<router expression=\"#xpath(payload, '/person/@age', 'number')\">\n <mapping channel=\"output1\" value=\"16\"/>\n <mapping channel=\"output2\" value=\"45\"/>\n</router>\n----\n\nThe `#xpath()` also supports a third optional parameter for converting the result of the XPath evaluation.\nIt can be one of the String constants (`string`, `boolean`, `number`, `node`, `node_list` and `document_list`) or an `org.springframework.xml.xpath.NodeMapper` instance.\nBy default, the `#xpath` SpEL function returns a `String` representation of the XPath evaluation.\n\nNOTE: To enable the `#xpath` SpEL function, you can add the `spring-integration-xml.jar` to the classpath.\nYou do not need to declare any components from the Spring Integration XML Namespace.\n\nFor more information, see \"`xref:spel.adoc[Spring Expression Language (SpEL)].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-spel-function.adoc", "title": "xpath-spel-function", "heading": "xpath-spel-function", "heading_level": 1, "file_order": 158, "section_index": 0, "content_hash": "65e23d0b71800c14fd7ebf47ce06bc5b5479e416d43b3d3073ea199430bb8e1a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-spel-function.adoc"}}
{"id": "sha256:6c6dc86371fe9b05270add3ec8b27a27c9d447e9ea5da7a58b7ec650130ff1eb", "content": "[[xml-xpath-splitting]]\n\n`XPathMessageSplitter` supports messages with either `String` or `Document` payloads.\nThe splitter uses the provided XPath expression to split the payload into a number of nodes.\nBy default, this results in each `Node` instance becoming the payload of a new message.\nWhen each message should be a `Document`, you can set the `createDocuments` flag.\nWhere a `String` payload is passed in, the payload is converted and then split before being converted back to a number of `String` messages.\nThe XPath splitter implements `MessageHandler` and should therefore be configured in conjunction with an appropriate endpoint (see the namespace support example after the following example for a simpler configuration alternative).\nThe following example configures a bean that uses an `XPathMessageSplitter`:\n\n[source,xml]\n----\n<bean id=\"splittingEndpoint\"\n class=\"org.springframework.integration.endpoint.EventDrivenConsumer\">\n <constructor-arg ref=\"orderChannel\" />\n <constructor-arg>\n <bean class=\"org.springframework.integration.xml.splitter.XPathMessageSplitter\">\n <constructor-arg value=\"/order/items\" />\n <property name=\"documentBuilder\" ref=\"customisedDocumentBuilder\" />\n <property name=\"outputChannel\" ref=\"orderItemsChannel\" />\n </bean>\n </constructor-arg>\n</bean>\n----\n\nXPath splitter namespace support lets you create a message endpoint with an input channel and output channel, as the following example shows:\n\n[source,xml]\n----\n<!-- Split the order into items and create a new message for each item node -->\n<int-xml:xpath-splitter id=\"orderItemSplitter\"\n input-channel=\"orderChannel\"\n output-channel=\"orderItemsChannel\">\n <int-xml:xpath-expression expression=\"/order/items\"/>\n</int-xml:xpath-splitter>\n\n<!-- Split the order into items, create a new document for each item-->\n<int-xml:xpath-splitter id=\"orderItemDocumentSplitter\"\n input-channel=\"orderChannel\"\n output-channel=\"orderItemsChannel\"\n create-documents=\"true\">\n <int-xml:xpath-expression expression=\"/order/items\"/>\n <int:poller fixed-rate=\"2000\"/>\n</int-xml:xpath-splitter>\n----\n\nStarting with version 4.2, the `XPathMessageSplitter` exposes the `outputProperties` (such as `OutputKeys.OMIT_XML_DECLARATION`) property for an `javax.xml.transform.Transformer` instance when a request `payload` is not of type `org.w3c.dom.Node`.\nThe following example defines a property and uses it with the `output-properties` property:\n\n[source,xml]\n----\n<util:properties id=\"outputProperties\">\n\t<beans:prop key=\"#{T (javax.xml.transform.OutputKeys).OMIT_XML_DECLARATION}\">yes</beans:prop>\n</util:properties>\n\n<xpath-splitter input-channel=\"input\"\n output-properties=\"outputProperties\">\n <xpath-expression expression=\"/orders/order\"/>\n</xpath-splitter>\n----\n\nStarting with `version 4.2`, the `XPathMessageSplitter` exposes an `iterator` option as a `boolean` flag (defaults to `true`).\nThis allows the \"`streaming`\" of split nodes in the downstream flow.\nWith the `iterator` mode set to `true`, each node is transformed while iterating.\nWhen `false`, all entries are first transformed, before the split nodes start being sent to the output channel.\n(You can think of the difference as \"`transform, send, transform, send`\" versus \"`transform, transform, send, send`\".)\nSee xref:splitter.adoc[Splitter] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-splitting.adoc", "title": "xpath-splitting", "heading": "xpath-splitting", "heading_level": 1, "file_order": 159, "section_index": 0, "content_hash": "6c6dc86371fe9b05270add3ec8b27a27c9d447e9ea5da7a58b7ec650130ff1eb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-splitting.adoc"}}
{"id": "sha256:eec4b5f968bb7c4e51555add4059f2282921b85c9d6b361159175b198780cbdb", "content": "[[xml-xpath-transformer]]\n\nWhen it comes to message transformation, XPath is a great way to transform messages that have XML payloads.\nYou can do so by defining XPath transformers with the `<xpath-transformer/>` element.\n\n[[simple-xpath-transformation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-transformer.adoc", "title": "xpath-transformer", "heading": "xpath-transformer", "heading_level": 1, "file_order": 160, "section_index": 0, "content_hash": "eec4b5f968bb7c4e51555add4059f2282921b85c9d6b361159175b198780cbdb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-transformer.adoc"}}
{"id": "sha256:6792b22ad4aaf7089d2a191210aac3b9c28d343da7b4403c0c8ca668c1a016e9", "content": "Consider the following transformer configuration:\n\n[source,xml]\n----\n<int-xml:xpath-transformer input-channel=\"inputChannel\" output-channel=\"outputChannel\"\n xpath-expression=\"/person/@name\" />\n----\n\nAlso consider the following `Message`:\n\n[source,java]\n----\nMessage<?> message =\n MessageBuilder.withPayload(\"<person name='John Doe' age='42' married='true'/>\").build();\n----\n\nAfter sending this message to the 'inputChannel', the XPath transformer configured earlier transforms this XML Message to a simple `Message` with a payload of 'John Doe', all based on the simple XPath Expression specified in the `xpath-expression` attribute.\n\nXPath also lets you perform a simple conversion of an extracted element to a desired type.\nValid return types are defined in `javax.xml.xpath.XPathConstants` and follow the conversion rules specified by the `javax.xml.xpath.XPath` interface.\n\nThe following constants are defined by the `XPathConstants` class: `BOOLEAN`, `DOM_OBJECT_MODEL`, `NODE`, `NODESET`, `NUMBER`, and `STRING`.\n\nYou can configure the desired type by using the `evaluation-type` attribute of the `<xpath-transformer/>` element, as the following example shows (twice):\n\n[source,xml]\n----\n<int-xml:xpath-transformer input-channel=\"numberInput\" xpath-expression=\"/person/@age\"\n evaluation-type=\"NUMBER_RESULT\" output-channel=\"output\"/>\n\n<int-xml:xpath-transformer input-channel=\"booleanInput\"\n xpath-expression=\"/person/@married = 'true'\"\n evaluation-type=\"BOOLEAN_RESULT\" output-channel=\"output\"/>\n----\n\n[[node-mappers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-transformer.adoc", "title": "xpath-transformer", "heading": "Simple XPath Transformation", "heading_level": 2, "file_order": 160, "section_index": 1, "content_hash": "6792b22ad4aaf7089d2a191210aac3b9c28d343da7b4403c0c8ca668c1a016e9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-transformer.adoc"}}
{"id": "sha256:c2a8d229238111e8917156132633a2083194b57b3726040919b97fadbf399c65", "content": "If you need to provide custom mapping for the node extracted by the XPath expression, you can provide a reference to the implementation of the `org.springframework.xml.xpath.NodeMapper` (an interface used by `XPathOperations` implementations for mapping `Node` objects on a per-node basis).\nTo provide a reference to a `NodeMapper`, you can use the `node-mapper` attribute, as the following example shows:\n\n[source,xml]\n----\n<int-xml:xpath-transformer input-channel=\"nodeMapperInput\" xpath-expression=\"/person/@age\"\n node-mapper=\"testNodeMapper\" output-channel=\"output\"/>\n----\n\nThe following example shows a `NodeMapper` implementation that works with the preceding example:\n\n[source,java]\n----\nclass TestNodeMapper implements NodeMapper {\n public Object mapNode(Node node, int nodeNum) throws DOMException {\n return node.getTextContent() + \"-mapped\";\n }\n}\n----\n\n[[xml-payload-converter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-transformer.adoc", "title": "xpath-transformer", "heading": "Node Mappers", "heading_level": 2, "file_order": 160, "section_index": 2, "content_hash": "c2a8d229238111e8917156132633a2083194b57b3726040919b97fadbf399c65", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-transformer.adoc"}}
{"id": "sha256:6ba2d8906168d53a3d8c8094a853d12afce93c07120cf44facdde0001c69d3ed", "content": "You can also use an implementation of the `org.springframework.integration.xml.XmlPayloadConverter` to provide more granular transformation.\nThe following example shows how to define one:\n\n[source,xml]\n----\n<int-xml:xpath-transformer input-channel=\"customConverterInput\"\n output-channel=\"output\" xpath-expression=\"/test/@type\"\n converter=\"testXmlPayloadConverter\" />\n----\n\nThe following example shows an `XmlPayloadConverter` implementation that works with the preceding example:\n\n[source,java]\n----\nclass TestXmlPayloadConverter implements XmlPayloadConverter {\n public Source convertToSource(Object object) {\n throw new UnsupportedOperationException();\n }\n //\n public Node convertToNode(Object object) {\n try {\n return DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(\n new InputSource(new StringReader(\"<test type='custom'/>\")));\n }\n catch (Exception e) {\n throw new IllegalStateException(e);\n }\n }\n //\n public Document convertToDocument(Object object) {\n throw new UnsupportedOperationException();\n }\n}\n----\n\nIf you do not provide this reference, the `DefaultXmlPayloadConverter` is used.\nIt should suffice in most cases, because it can convert from `Node`, `Document`, `Source`, `File`, `String`, `InputStream`, and `byte[]` payloads.\nIf you need to extend beyond the capabilities of that default implementation, an upstream `Transformer` is probably a better option than providing a reference to a custom implementation of this strategy here.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml/xpath-transformer.adoc", "title": "xpath-transformer", "heading": "XML Payload Converter", "heading_level": 2, "file_order": 160, "section_index": 3, "content_hash": "6ba2d8906168d53a3d8c8094a853d12afce93c07120cf44facdde0001c69d3ed", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml/xpath-transformer.adoc"}}
{"id": "sha256:6e5ba72581d2241a37d1807cf27454d42486f046e85d225c11dc64b7ac4e5195", "content": "[[aggregator]]\n\nBasically a mirror-image of the splitter, the aggregator is a type of message handler that receives multiple messages and combines them into a single message.\nIn fact, an aggregator is often a downstream consumer in a pipeline that includes a splitter.\n\nTechnically, the aggregator is more complex than a splitter because it is stateful.\nIt must hold the messages to be aggregated and determine when the complete group of messages is ready to be aggregated.\nIn order to do so, it requires a `MessageStore`.\n\n[[aggregator-functionality]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "aggregator", "heading_level": 1, "file_order": 161, "section_index": 0, "content_hash": "6e5ba72581d2241a37d1807cf27454d42486f046e85d225c11dc64b7ac4e5195", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:7019513c04b7af5a42a779ddbf69d15b6c9ea3bc20ab9af3c68b1bb6b49c42e8", "content": "The Aggregator combines a group of related messages, by correlating and storing them, until the group is deemed to be complete.\nAt that point, the aggregator creates a single message by processing the whole group and sends the aggregated message as output.\n\nImplementing an aggregator requires providing the logic to perform the aggregation (that is, the creation of a single message from many).\nTwo related concepts are correlation and release.\n\nCorrelation determines how messages are grouped for aggregation.\nIn Spring Integration, correlation is done by default, based on the `IntegrationMessageHeaderAccessor.CORRELATION_ID` message header.\nMessages with the same `IntegrationMessageHeaderAccessor.CORRELATION_ID` are grouped together.\nHowever, you can customize the correlation strategy to allow other ways of specifying how the messages should be grouped together.\nTo do so, you can implement a `CorrelationStrategy` (covered later in this chapter).\n\nTo determine the point at which a group of messages is ready to be processed, a `ReleaseStrategy` is consulted.\nThe default release strategy for the aggregator releases a group when all messages included in a sequence are present, based on the `IntegrationMessageHeaderAccessor.SEQUENCE_SIZE` header.\nYou can override this default strategy by providing a reference to a custom `ReleaseStrategy` implementation.\n\n[[aggregator-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Functionality", "heading_level": 2, "file_order": 161, "section_index": 1, "content_hash": "7019513c04b7af5a42a779ddbf69d15b6c9ea3bc20ab9af3c68b1bb6b49c42e8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:2a17f19a7a08197087872e661f3ac85f688ce1c871eca9261c2293bda295d5aa", "content": "The Aggregation API consists of a number of classes:\n\n* The interface `MessageGroupProcessor`, and its subclasses: `MethodInvokingAggregatingMessageGroupProcessor` and `ExpressionEvaluatingMessageGroupProcessor`\n* The `ReleaseStrategy` interface and its default implementation: `SimpleSequenceSizeReleaseStrategy`\n* The `CorrelationStrategy` interface and its default implementation: `HeaderAttributeCorrelationStrategy`\n\n[[aggregatingmessagehandler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Programming Model", "heading_level": 2, "file_order": 161, "section_index": 2, "content_hash": "2a17f19a7a08197087872e661f3ac85f688ce1c871eca9261c2293bda295d5aa", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:6ce950735ca437364f8a4d6788dee455ce7980efc6bafda2d126ee5f7fc74e31", "content": "The `AggregatingMessageHandler` (a subclass of `AbstractCorrelatingMessageHandler`) is a `MessageHandler` implementation, encapsulating the common functionality of an aggregator (and other correlating use cases), which are as follows:\n\n* Correlating messages into a group to be aggregated\n* Maintaining those messages in a `MessageStore` until the group can be released\n* Deciding when the group can be released\n* Aggregating the released group into a single message\n* Recognizing and responding to an expired group\n\nThe responsibility for deciding how the messages should be grouped together is delegated to a `CorrelationStrategy` instance.\nThe responsibility for deciding whether the message group can be released is delegated to a `ReleaseStrategy` instance.\n\nThe following listing shows a brief highlight of the base `AbstractAggregatingMessageGroupProcessor` (the responsibility for implementing the `aggregatePayloads` method is left to the developer):\n\n[source,java]\n----\npublic abstract class AbstractAggregatingMessageGroupProcessor\n implements MessageGroupProcessor {\n\n protected Map<String, Object> aggregateHeaders(MessageGroup group) {\n // default implementation exists\n }\n\n protected abstract Object aggregatePayloads(MessageGroup group, Map<String, Object> defaultHeaders);\n\n}\n----\n\nSee `DefaultAggregatingMessageGroupProcessor`, `ExpressionEvaluatingMessageGroupProcessor` and `MethodInvokingMessageGroupProcessor` as out-of-the-box implementations of the `AbstractAggregatingMessageGroupProcessor`.\n\nStarting with version 5.2, a `Function<MessageGroup, Map<String, Object>>` strategy is available for the `AbstractAggregatingMessageGroupProcessor` to merge and compute (aggregate) headers for an output message.\nThe `DefaultAggregateHeadersFunction` implementation is available with logic that returns all headers that have no conflicts among the group; an absent header on one or more messages within the group is not considered a conflict.\nConflicting headers are omitted.\nAlong with the newly introduced `DelegatingMessageGroupProcessor`, this function is used for any arbitrary (non-`AbstractAggregatingMessageGroupProcessor`) `MessageGroupProcessor` implementation.\nEssentially, the framework injects a provided function into an `AbstractAggregatingMessageGroupProcessor` instance and wraps all other implementations into a `DelegatingMessageGroupProcessor`.\nThe difference in logic between the `AbstractAggregatingMessageGroupProcessor` and the `DelegatingMessageGroupProcessor` that the latter doesn't compute headers in advance, before calling the delegate strategy, and doesn't invoke the function if the delegate returns a `Message` or `AbstractIntegrationMessageBuilder`.\nIn that case, the framework assumes that the target implementation has taken care of producing a proper set of headers populated into the returned result.\nThe `Function<MessageGroup, Map<String, Object>>` strategy is available as the `headers-function` reference attribute for XML configuration, as the `AggregatorSpec.headersFunction()` option for the Java DSL and as `AggregatorFactoryBean.setHeadersFunction()` for plain Java configuration.\n\nThe `CorrelationStrategy` is owned by the `AbstractCorrelatingMessageHandler` and has a default value based on the `IntegrationMessageHeaderAccessor.CORRELATION_ID` message header, as the following example shows:\n\n[source,java]\n----\npublic AbstractCorrelatingMessageHandler(MessageGroupProcessor processor, MessageGroupStore store,\n CorrelationStrategy correlationStrategy, ReleaseStrategy releaseStrategy) {\n ...\n this.correlationStrategy = correlationStrategy == null ?\n new HeaderAttributeCorrelationStrategy(IntegrationMessageHeaderAccessor.CORRELATION_ID) : correlationStrategy;\n this.releaseStrategy = releaseStrategy == null ? new SimpleSequenceSizeReleaseStrategy() : releaseStrategy;\n ...\n}\n----\n\nAs for the actual processing of the message group, the default implementation is the `DefaultAggregatingMessageGroupProcessor`.\nIt creates a single `Message` whose payload is a `List` of the payloads received for a given group.\nThis works well for simple scatter-gather implementations with a splitter, a publish-subscribe channel, or a recipient list router upstream.\n\nNOTE: When using a publish-subscribe channel or a recipient list router in this type of scenario, be sure to enable the `apply-sequence` flag.\nDoing so adds the necessary headers: `CORRELATION_ID`, `SEQUENCE_NUMBER`, and `SEQUENCE_SIZE`.\nThat behavior is enabled by default for splitters in Spring Integration, but it is not enabled for publish-subscribe channels or for recipient list routers because those components may be used in a variety of contexts in which these headers are not necessary.\n\nWhen implementing a specific aggregator strategy for an application, you can extend `AbstractAggregatingMessageGroupProcessor` and implement the `aggregatePayloads` method.\nHowever, there are better solutions, less coupled to the API, for implementing the aggregation logic, which can be configured either through XML or through annotations.\n\nIn general, any POJO can implement the aggregation algorithm if it provides a method that accepts a single `java.util.List` as an argument (parameterized lists are supported as well).\nThis method is invoked for aggregating messages as follows:\n\n* If the argument is a `java.util.Collection<T>` and the parameter type T is assignable to `Message`, the whole list of messages accumulated for aggregation is sent to the aggregator.\n* If the argument is a non-parameterized `java.util.Collection` or the parameter type is not assignable to `Message`, the method receives the payloads of the accumulated messages.\n* If the return type is not assignable to `Message`, it is treated as the payload for a `Message` that is automatically created by the framework.\n\nNOTE: In the interest of code simplicity and promoting best practices such as low coupling, testability, and others, the preferred way of implementing the aggregation logic is through a POJO and using the XML or annotation support for configuring it in the application.\n\nStarting with version 5.3, after processing a message group, an `AbstractCorrelatingMessageHandler` performs a `MessageBuilder.popSequenceDetails()` message headers modification for the proper splitter-aggregator scenario with several nested levels.\nIt is done only if the message group release result is not a collection of messages.\nIn that case a target `MessageGroupProcessor` is responsible for the `MessageBuilder.popSequenceDetails()` call while building those messages.\n\nIf the `MessageGroupProcessor` returns a `Message`, a `MessageBuilder.popSequenceDetails()` will be performed on the output message only if the `sequenceDetails` matches with first message in group.\n(Previously this has been done only if a plain payload or an `AbstractIntegrationMessageBuilder` has been returned from the `MessageGroupProcessor`.)\n\nThis functionality can be controlled by a new `popSequence` `boolean` property, so the `MessageBuilder.popSequenceDetails()` can be disabled in some scenarios when correlation details have not been populated by the standard splitter.\nThis property, essentially, undoes what has been done by the nearest upstream `applySequence = true` in the `AbstractMessageSplitter`.\nSee xref:splitter.adoc[Splitter] for more information.\n\n[[agg-message-collection]]\nIMPORTANT: The `SimpleMessageGroup.getMessages()` method returns an `unmodifiableCollection`.\nTherefore, if an aggregating POJO method has a `Collection<Message>` parameter, the argument passed in is exactly that `Collection` instance and, when you use a `SimpleMessageStore` for the aggregator, that original `Collection<Message>` is cleared after releasing the group.\nConsequently, the `Collection<Message>` variable in the POJO is cleared too, if it is passed out of the aggregator.\nIf you wish to simply release that collection as-is for further processing, you must build a new `Collection` (for example, `new ArrayList<Message>(messages)`).\nStarting with version 4.3, the framework no longer copies the messages to a new collection to avoid undesired extra object creation.\n\nPrior to version 4.2, it was not possible to provide a `MessageGroupProcessor` by using XML configuration.\nOnly POJO methods could be used for aggregation.\nNow, if the framework detects that the referenced (or inner) bean implements `MessageProcessor`, it is used as the aggregator's output processor.\n\nIf you wish to release a collection of objects from a custom `MessageGroupProcessor` as the payload of a message, your class should extend `AbstractAggregatingMessageGroupProcessor` and implement `aggregatePayloads()`.\n\nAlso, since version 4.2, a `SimpleMessageGroupProcessor` is provided.\nIt returns the collection of messages from the group, which, as indicated earlier, causes the released messages to be sent individually.\n\nThis lets the aggregator work as a message barrier, where arriving messages are held until the release strategy fires and the group is released as a sequence of individual messages.\n\nStarting with version 6.0, the splitting behaviour, described above, works only if the group processor is a `SimpleMessageGroupProcessor`.\nOtherwise, with any other `MessageGroupProcessor` implementation that returns a `Collection<Message>`, only a single reply message is emitted with the whole collection of messages as its payload.\nSuch logic is dictated by the canonical purpose of an aggregator - collect request messages by some key and produce a single grouped message.\n\nPrior to version 6.5, if a `MessageGroupProcessor` (usually lambda from DSL) returns a collection of payloads, the `AbstractCorrelatingMessageHandler` has failed with the `IllegalArgumentException` stating that only collection of messages is possible.\nFrom now on such a restriction is eliminated, and a returned collection of payloads is emitted as a single reply message from the aggregator with just headers from the last request message.\nIf header aggregation is required alongside a collection of payloads, an `AbstractAggregatingMessageGroupProcessor` implementations are recommended to be used instead of plain `MessageGroupProcessor` functional interface.\n\n[[releasestrategy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "`AggregatingMessageHandler`", "heading_level": 3, "file_order": 161, "section_index": 3, "content_hash": "6ce950735ca437364f8a4d6788dee455ce7980efc6bafda2d126ee5f7fc74e31", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:8b27efae8fb88c0e954b2944fa3737756bad7ea87e642897113a16d2ef26e397", "content": "The `ReleaseStrategy` interface is defined as follows:\n\n[source,java]\n----\npublic interface ReleaseStrategy {\n\n boolean canRelease(MessageGroup group);\n\n}\n----\n\nIn general, any POJO can implement the completion decision logic if it provides a method that accepts a single `java.util.List` as an argument (parameterized lists are supported as well) and returns a boolean value.\nThis method is invoked after the arrival of each new message to decide whether the group is complete or not, as follows:\n\n* If the argument is a `java.util.List<T>` and the parameter type `T` is assignable to `Message`, the whole list of messages accumulated in the group is sent to the method.\n* If the argument is a non-parametrized `java.util.List` or the parameter type is not assignable to `Message`, the method receives the payloads of the accumulated messages.\n* The method must return `true` if the message group is ready for aggregation or false otherwise.\n\nThe following example shows how to use the `@ReleaseStrategy` annotation for a `List` of type `Message`:\n\n[source,java]\n----\npublic class MyReleaseStrategy {\n\n @ReleaseStrategy\n public boolean canMessagesBeReleased(List<Message<?>>) {...}\n}\n----\n\nThe following example shows how to use the `@ReleaseStrategy` annotation for a `List` of type `String`:\n\n[source,java]\n----\npublic class MyReleaseStrategy {\n\n @ReleaseStrategy\n public boolean canMessagesBeReleased(List<String>) {...}\n}\n----\n\nBased on the signatures in the preceding two examples, the POJO-based release strategy is passed a `Collection` of not-yet-released messages (if you need access to the whole `Message`) or a `Collection` of payload objects (if the type parameter is anything other than `Message`).\nThis satisfies the majority of use cases.\nHowever, if, for some reason, you need to access the full `MessageGroup`, you should provide an implementation of the `ReleaseStrategy` interface.\n\n[WARNING]\n=====\nWhen handling potentially large groups, you should understand how these methods are invoked, because the release strategy may be invoked multiple times before the group is released.\nThe most efficient is an implementation of `ReleaseStrategy`, because the aggregator can invoke it directly.\nThe second most efficient is a POJO method with a `Collection<Message<?>>` parameter type.\nThe least efficient is a POJO method with a `Collection<Something>` type.\nThe framework has to copy the payloads from the messages in the group into a new collection (and possibly attempt conversion on the payloads to `Something`) every time the release strategy is called.\nUsing `Collection<?>` avoids the conversion but still requires creating the new `Collection`.\n\nFor these reasons, for large groups, we recommended that you implement `ReleaseStrategy`.\n=====\n\nWhen the group is released for aggregation, all its not-yet-released messages are processed and removed from the group.\nIf the group is also complete, (that is, if all messages from a sequence have arrived or if there is no sequence defined), then the group is marked as complete.\nAny new messages for this group are sent to the discard channel (if defined).\nSetting `expire-groups-upon-completion` to `true` (the default is `false`) removes the entire group, and any new messages (with the same correlation ID as the removed group) form a new group.\nYou can release partial sequences by using a `MessageGroupStoreReaper` together with `send-partial-result-on-expiry` being set to `true`.\n\nStarting with version 6.5, the correlation handler can also be configured with a `discardIndividuallyOnExpiry` option to discard the whole group as a single message.\nEssentially, the payload of this message is a list of messages from the expired group.\nWorks only if `sendPartialResultOnExpiry` is set to `false` (default) and `dicardChannel` is provided.\n\nIMPORTANT: To facilitate discarding of late-arriving messages, the aggregator must maintain the state about the group after it has been released.\nThis can eventually cause out-of-memory conditions.\nTo avoid such situations, you should consider configuring a `MessageGroupStoreReaper` to remove the group metadata.\nThe expiry parameters should be set to expire groups once a point has been reached, after which late messages are not expected to arrive.\nFor information about configuring a reaper, see xref:aggregator.adoc#reaper[Managing State in an Aggregator: `MessageGroupStore`].\n\nSpring Integration provides an implementation for `ReleaseStrategy`: `SimpleSequenceSizeReleaseStrategy`.\nThis implementation consults the `SEQUENCE_NUMBER` and `SEQUENCE_SIZE` headers of each arriving message to decide when a message group is complete and ready to be aggregated.\nAs shown earlier, it is also the default strategy.\n\nNOTE: Before version 5.0, the default release strategy was `SequenceSizeReleaseStrategy`, which does not perform well with large groups.\nWith that strategy, duplicate sequence numbers are detected and rejected.\nThis operation can be expensive.\n\nIf you are aggregating large groups, you don't need to release partial groups, and you don't need to detect/reject duplicate sequences, consider using the `SimpleSequenceSizeReleaseStrategy` instead - it is much more efficient for these use cases, and is the default since _version 5.0_ when partial group release is not specified.\n\n[[aggregating-large-groups]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "`ReleaseStrategy`", "heading_level": 3, "file_order": 161, "section_index": 4, "content_hash": "8b27efae8fb88c0e954b2944fa3737756bad7ea87e642897113a16d2ef26e397", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:6910a52f7f0060a6aa5ebb57f32b148167770745e7487c5c0573a47299028140", "content": "The 4.3 release changed the default `Collection` for messages in a `SimpleMessageGroup` to `HashSet` (it was previously a `BlockingQueue`).\nThis was expensive when removing individual messages from large groups (an O(n) linear scan was required).\nAlthough the hash set is generally much faster to remove, it can be expensive for large messages because the hash has to be calculated on both inserts and removes.\nIf you have messages that are expensive to hash, consider using some other collection type.\nAs discussed in xref:message-store.adoc#message-group-factory[Using `MessageGroupFactory`], a `SimpleMessageGroupFactory` is provided so that you can select the `Collection` that best suits your needs.\nYou can also provide your own factory implementation to create some other `Collection<Message<?>>`.\n\nThe following example shows how to configure an aggregator with the previous implementation and a `SimpleSequenceSizeReleaseStrategy`:\n\n[source, xml]\n----\n<int:aggregator input-channel=\"aggregate\"\n output-channel=\"out\" message-store=\"store\" release-strategy=\"releaser\" />\n\n<bean id=\"store\" class=\"org.springframework.integration.store.SimpleMessageStore\">\n <property name=\"messageGroupFactory\">\n <bean class=\"org.springframework.integration.store.SimpleMessageGroupFactory\">\n <constructor-arg value=\"BLOCKING_QUEUE\"/>\n </bean>\n </property>\n</bean>\n\n<bean id=\"releaser\" class=\"SimpleSequenceSizeReleaseStrategy\" />\n----\n\nNOTE: If the filter endpoint is involved in the flow upstream of an aggregator, the sequence size release strategy (fixed or based on the `sequenceSize` header) is not going to serve its purpose because some messages from a sequence may be discarded by the filter.\nIn this case it is recommended to choose another `ReleaseStrategy`, or use compensation messages sent from a discard sub-flow carrying some information in their content to be skipped in a custom complete group function.\nSee xref:filter.adoc[Filter] for more information.\n\n[[correlation-strategy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Aggregating Large Groups", "heading_level": 3, "file_order": 161, "section_index": 5, "content_hash": "6910a52f7f0060a6aa5ebb57f32b148167770745e7487c5c0573a47299028140", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:c865b0772a1a1e76fd907f6616d8d212defd1418fc3533e1d4fd00ab8672137b", "content": "The `CorrelationStrategy` interface is defined as follows:\n\n[source,java]\n----\npublic interface CorrelationStrategy {\n\n Object getCorrelationKey(Message<?> message);\n\n}\n----\n\nThe method returns an `Object` that represents the correlation key used for associating the message with a message group.\nThe key must satisfy the criteria used for a key in a `Map` with respect to the implementation of `equals()` and `hashCode()`.\n\nIn general, any POJO can implement the correlation logic, and the rules for mapping a message to a method's argument (or arguments) are the same as for a `ServiceActivator` (including support for `@Header` annotations).\nThe method must return a value, and the value must not be `null`.\n\nSpring Integration provides an implementation for `CorrelationStrategy`: `HeaderAttributeCorrelationStrategy`.\nThis implementation returns the value of one of the message headers (whose name is specified by a constructor argument) as the correlation key.\nBy default, the correlation strategy is a `HeaderAttributeCorrelationStrategy` that returns the value of the `CORRELATION_ID` header attribute.\nIf you have a custom header name you would like to use for correlation, you can configure it on an instance of `HeaderAttributeCorrelationStrategy` and provide that as a reference for the aggregator's correlation strategy.\n\n[[lock-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Correlation Strategy", "heading_level": 3, "file_order": 161, "section_index": 6, "content_hash": "c865b0772a1a1e76fd907f6616d8d212defd1418fc3533e1d4fd00ab8672137b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:9b45b2942add24741e4bfaa874a005836d1462e5201e2733bbc6226dee4bee56", "content": "Changes to groups are thread safe.\nSo, when you send messages for the same correlation ID concurrently, only one of them will be processed in the aggregator, making it effectively as a *single-threaded per message group*.\nA `LockRegistry` is used to obtain a lock for the resolved correlation ID.\nA `DefaultLockRegistry` is used by default (in-memory).\nFor synchronizing updates across servers where a shared `MessageGroupStore` is being used, you must configure a shared lock registry.\n\n[[aggregator-deadlocks]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Lock Registry", "heading_level": 3, "file_order": 161, "section_index": 7, "content_hash": "9b45b2942add24741e4bfaa874a005836d1462e5201e2733bbc6226dee4bee56", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:b3b82fad7188a55937620fce229a5dcb4913e3d753b493dafd1f9c205ac82b2a", "content": "As discussed above, when message groups are mutated (messages added or released), a lock is held.\n\nConsider the following flow:\n\n[source]\n----\n...->aggregator1-> ... ->aggregator2-> ...\n----\n\nIf there are multiple threads, **and the aggregators share a common lock registry**, it is possible to get a deadlock.\nThis will cause hung threads and `jstack <pid>` might present a result such as:\n\n[source]\n----\nFound one Java-level deadlock:\n=============================\n\"t2\":\n waiting for ownable synchronizer 0x000000076c1cbfa0, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),\n which is held by \"t1\"\n\"t1\":\n waiting for ownable synchronizer 0x000000076c1ccc00, (a java.util.concurrent.locks.ReentrantLock$NonfairSync),\n which is held by \"t2\"\n----\n\nThere are several ways to avoid this problem:\n\n* ensure each aggregator has its own lock registry (this can be a shared registry across application instances, but two or more aggregators in the flow must each have a distinct registry)\n* use an `ExecutorChannel` or `QueueChannel` as the output channel of the aggregator so that the downstream flow runs on a new thread\n* starting with version 5.1.1, set the `releaseLockBeforeSend` aggregator property to `true`\n\nNOTE: This problem can also be caused if, for some reason, the output of a single aggregator is eventually routed back to the same aggregator.\nOf course, the first solution above does not apply in this case.\n\n[[aggregator-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Avoiding Deadlocks", "heading_level": 3, "file_order": 161, "section_index": 8, "content_hash": "b3b82fad7188a55937620fce229a5dcb4913e3d753b493dafd1f9c205ac82b2a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:fc03f2d3a1b032f048761f923f876d7d461060eb53b046e10b6ce5f406a1f661", "content": "See xref:dsl/java-aggregators.adoc[Aggregators and Resequencers] for how to configure an aggregator in Java DSL.\n\n[[aggregator-xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Configuring an Aggregator in Java DSL", "heading_level": 2, "file_order": 161, "section_index": 9, "content_hash": "fc03f2d3a1b032f048761f923f876d7d461060eb53b046e10b6ce5f406a1f661", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:2137ed1fe981150531868f5a54b2cd5c251ff3f2dac7969b49f6699a82c368c8", "content": "Spring Integration supports the configuration of an aggregator with XML through the `<aggregator/>` element.\nThe following example shows an example of an aggregator:\n\n[source,xml]\n----\n<channel id=\"inputChannel\"/>\n\n<int:aggregator id=\"myAggregator\" <1>\n auto-startup=\"true\" <2>\n input-channel=\"inputChannel\" <3>\n output-channel=\"outputChannel\" <4>\n discard-channel=\"throwAwayChannel\" <5>\n message-store=\"persistentMessageStore\" <6>\n order=\"1\" <7>\n send-partial-result-on-expiry=\"false\" <8>\n send-timeout=\"1000\" <9>\n\n correlation-strategy=\"correlationStrategyBean\" <10>\n correlation-strategy-method=\"correlate\" <11>\n correlation-strategy-expression=\"headers['foo']\" <12>\n\n ref=\"aggregatorBean\" <13>\n method=\"aggregate\" <14>\n\n release-strategy=\"releaseStrategyBean\" <15>\n release-strategy-method=\"release\" <16>\n release-strategy-expression=\"size() == 5\" <17>\n\n expire-groups-upon-completion=\"false\" <18>\n empty-group-min-timeout=\"60000\" <19>\n\n lock-registry=\"lockRegistry\" <20>\n\n group-timeout=\"60000\" <21>\n group-timeout-expression=\"size() ge 2 ? 100 : -1\" <22>\n expire-groups-upon-timeout=\"true\" <23>\n\n scheduler=\"taskScheduler\" > <24>\n <expire-transactional/> <25>\n <expire-advice-chain/> <26>\n</aggregator>\n\n<int:channel id=\"outputChannel\"/>\n\n<int:channel id=\"throwAwayChannel\"/>\n\n<bean id=\"persistentMessageStore\" class=\"org.springframework.integration.jdbc.store.JdbcMessageStore\">\n <constructor-arg ref=\"dataSource\"/>\n</bean>\n\n<bean id=\"aggregatorBean\" class=\"sample.PojoAggregator\"/>\n\n<bean id=\"releaseStrategyBean\" class=\"sample.PojoReleaseStrategy\"/>\n\n<bean id=\"correlationStrategyBean\" class=\"sample.PojoCorrelationStrategy\"/>\n----\n\n<1> The id of the aggregator is optional.\n<2> Lifecycle attribute signaling whether the aggregator should be started during application context startup.\nOptional (the default is 'true').\n<3> The channel from which where aggregator receives messages.\nRequired.\n<4> The channel to which the aggregator sends the aggregation results.\nOptional (because incoming messages can themselves specify a reply channel in the 'replyChannel' message header).\n<5> The channel to which the aggregator sends the messages that timed out (if `send-partial-result-on-expiry` is `false`).\nOptional.\n<6> A reference to a `MessageGroupStore` used to store groups of messages under their correlation key until they are complete.\nOptional.\nBy default, it is a volatile in-memory store.\nSee xref:message-store.adoc[Message Store] for more information.\n<7> The order of this aggregator when more than one handle is subscribed to the same `DirectChannel` (use for load-balancing purposes).\nOptional.\n<8> Indicates that expired messages should be aggregated and sent to the 'output-channel' or 'replyChannel' once their containing `MessageGroup` is expired (see https://docs.spring.io/spring-integration/api/org/springframework/integration/store/MessageGroupStore.html#expireMessageGroups-long[`MessageGroupStore.expireMessageGroups(long)`]).\nOne way of expiring a `MessageGroup` is by configuring a `MessageGroupStoreReaper`.\nHowever, you can alternatively expire `MessageGroup` by calling `MessageGroupStore.expireMessageGroups(timeout)`.\nYou can accomplish that through a Control Bus operation or, if you have a reference to the `MessageGroupStore` instance, by invoking `expireMessageGroups(timeout)`.\nOtherwise, by itself, this attribute does nothing.\nIt serves only as an indicator of whether to discard or send to the output or reply channel any messages that are still in the `MessageGroup` that is about to be expired.\nOptional (the default is `false`).\nNOTE: This attribute might more properly be called `send-partial-result-on-timeout`, because the group may not actually expire if `expire-groups-upon-timeout` is set to `false`.\n<9> The timeout interval to wait when sending a reply `Message` to the `output-channel` or `discard-channel`.\nDefaults to `30` seconds.\nIt is applied only if the output channel has some 'sending' limitations, such as a `QueueChannel` with a fixed 'capacity'.\nIn this case, a `MessageDeliveryException` is thrown.\nFor `AbstractSubscribableChannel` implementations, the `send-timeout` is ignored.\nFor `group-timeout(-expression)`, the `MessageDeliveryException` from the scheduled expiring task leads this task to be rescheduled.\nOptional.\n<10> A reference to a bean that implements the message correlation (grouping) algorithm.\nThe bean can be an implementation of the `CorrelationStrategy` interface or a POJO.\nIn the latter case, the `correlation-strategy-method` attribute must be defined as well.\nOptional (by default, the aggregator uses the `IntegrationMessageHeaderAccessor.CORRELATION_ID` header).\n<11> A method defined on the bean referenced by `correlation-strategy`.\nIt implements the correlation decision algorithm.\nOptional, with restrictions (`correlation-strategy` must be present).\n<12> A SpEL expression representing the correlation strategy.\nExample: `\"headers['something']\"`.\nOnly one of `correlation-strategy` or `correlation-strategy-expression` is allowed.\n<13> A reference to a bean defined in the application context.\nThe bean must implement the aggregation logic, as described earlier.\nOptional (by default, the list of aggregated messages becomes a payload of the output message).\n<14> A method defined on the bean referenced by the `ref` attribute.\nIt implements the message aggregation algorithm.\nOptional (it depends on `ref` attribute being defined).\n<15> A reference to a bean that implements the release strategy.\nThe bean can be an implementation of the `ReleaseStrategy` interface or a POJO.\nIn the latter case, the `release-strategy-method` attribute must be defined as well.\nOptional (by default, the aggregator uses the `IntegrationMessageHeaderAccessor.SEQUENCE_SIZE` header attribute).\n<16> A method defined on the bean referenced by the `release-strategy` attribute.\nIt implements the completion decision algorithm.\nOptional, with restrictions (`release-strategy` must be present).\n<17> A SpEL expression representing the release strategy.\nThe root object for the expression is a `MessageGroup`.\nExample: `\"size() == 5\"`.\nOnly one of `release-strategy` or `release-strategy-expression` is allowed.\n<18> When set to `true` (the default is `false`), completed groups are removed from the message store, letting subsequent messages with the same correlation form a new group.\nThe default behavior is to send messages with the same correlation as a completed group to the `discard-channel`.\n<19> Applies only if a `MessageGroupStoreReaper` is configured for the `MessageStore` of the `<aggregator>`.\nBy default, when a `MessageGroupStoreReaper` is configured to expire partial groups, empty groups are also removed.\nEmpty groups exist after a group is normally released.\nThe empty groups enable the detection and discarding of late-arriving messages.\nIf you wish to expire empty groups on a longer schedule than expiring partial groups, set this property.\nEmpty groups are then not removed from the `MessageStore` until they have not been modified for at least this number of milliseconds.\nNote that the actual time to expire an empty group is also affected by the reaper's `timeout` property, and it could be as much as this value plus the timeout.\n<20> A reference to a `org.springframework.integration.util.LockRegistry` bean.\nIt used to obtain a `Lock` based on the `groupId` for concurrent operations on the `MessageGroup`.\nBy default, an internal `DefaultLockRegistry` is used.\nUse of a distributed `LockRegistry`, such as the `ZookeeperLockRegistry`, ensures only one instance of the aggregator can operate on a group concurrently.\nSee xref:redis.adoc#redis-lock-registry[Redis Lock Registry] or xref:zookeeper.adoc#zk-lock-registry[Zookeeper Lock Registry] for more information.\n<21> A timeout (in milliseconds) to force the `MessageGroup` complete when the `ReleaseStrategy` does not release the group when the current message arrives.\nThis attribute provides a built-in time-based release strategy for the aggregator when there is a need to emit a partial result (or discard the group) if a new message does not arrive for the `MessageGroup` within the timeout which counts from the time the last message arrived.\nTo set up a timeout which counts from the time the `MessageGroup` was created see `group-timeout-expression` information.\nWhen a new message arrives at the aggregator, any existing `ScheduledFuture<?>` for its `MessageGroup` is canceled.\nIf the `ReleaseStrategy` returns `false` (meaning do not release) and `groupTimeout > 0`, a new task is scheduled to expire the group.\nWe do not advise setting this attribute to zero (or a negative value).\nDoing so effectively disables the aggregator because every message group is immediately completed.\nYou can, however, conditionally set it to zero (or a negative value) by using an expression.\nSee `group-timeout-expression` for information.\nThe action taken during the completion depends on the `ReleaseStrategy` and the `send-partial-group-on-expiry` attribute.\nSee xref:aggregator.adoc#agg-and-group-to[Aggregator and Group Timeout] for more information.\nIt is mutually exclusive with `group-timeout-expression` attribute.\n<22> The SpEL expression that evaluates to a `groupTimeout` with the `MessageGroup` as the `#root` evaluation context object.\nUsed for scheduling the `MessageGroup` to be forced complete.\nIf the expression evaluates to `null`, the completion is not scheduled.\nIf it evaluates to zero, the group is completed immediately on the current thread.\nIn effect, this provides a dynamic `group-timeout` property.\nAs an example, if you wish to forcibly complete a `MessageGroup` after 10 seconds have elapsed since the time the group was created you might consider using the following SpEL expression: `timestamp + 10000 - T(System).currentTimeMillis()` where `timestamp` is provided by `MessageGroup.getTimestamp()` as the `MessageGroup` here is the `#root` evaluation context object.\nBear in mind however that the group creation time might differ from the time of the first arrived message depending on other group expiration properties' configuration.\nSee `group-timeout` for more information.\nMutually exclusive with `group-timeout` attribute.\n<23> When a group is completed due to a timeout (or by a `MessageGroupStoreReaper`), the group is expired (completely removed) by default.\nLate arriving messages start a new group.\nYou can set this to `false` to complete the group but have its metadata remain so that late arriving messages are discarded.\nEmpty groups can be expired later using a `MessageGroupStoreReaper` together with the `empty-group-min-timeout` attribute.\nIt defaults to 'true'.\n<24> A `TaskScheduler` bean reference to schedule the `MessageGroup` to be forced complete if no new message arrives for the `MessageGroup` within the `groupTimeout`.\nIf not provided, the default scheduler (`taskScheduler`) registered in the `ApplicationContext` (`ThreadPoolTaskScheduler`) is used.\nThis attribute does not apply if `group-timeout` or `group-timeout-expression` is not specified.\n<25> Since version 4.1.\nIt lets a transaction be started for the `forceComplete` operation.\nIt is initiated from a `group-timeout(-expression)` or by a `MessageGroupStoreReaper` and is not applied to the normal `add`, `release`, and `discard` operations.\nOnly this subelement or `<expire-advice-chain/>` is allowed.\n<26> Since _version 4.1_.\nIt allows the configuration of any `Advice` for the `forceComplete` operation.\nIt is initiated from a `group-timeout(-expression)` or by a `MessageGroupStoreReaper` and is not applied to the normal `add`, `release`, and `discard` operations.\nOnly this subelement or `<expire-transactional/>` is allowed.\nA transaction `Advice` can also be configured here by using the Spring `tx` namespace.\n\n[[aggregator-expiring-groups]]\n[IMPORTANT]\n.Expiring Groups\n=====\nThere are two attributes related to expiring (completely removing) groups.\nWhen a group is expired, there is no record of it, and, if a new message arrives with the same correlation, a new group is started.\nWhen a group is completed (without expiry), the empty group remains and late-arriving messages are discarded.\nEmpty groups can be removed later by using a `MessageGroupStoreReaper` in combination with the `empty-group-min-timeout` attribute.\n\n`expire-groups-upon-completion` relates to \"`normal`\" completion when the `ReleaseStrategy` releases the group.\nThis defaults to `false`.\n\nIf a group is not complete normally but is released or discarded because of a timeout, the group is normally expired.\nSince version 4.1, you can control this behavior by using `expire-groups-upon-timeout`.\nIt defaults to `true` for backwards compatibility.\n\nNOTE: When a group is timed out, the `ReleaseStrategy` is given one more opportunity to release the group.\nIf it does so and `expire-groups-upon-timeout` is false, expiration is controlled by `expire-groups-upon-completion`.\nIf the group is not released by the release strategy during timeout, then the expiration is controlled by the `expire-groups-upon-timeout`.\nTimed-out groups are either discarded or a partial release occurs (based on `send-partial-result-on-expiry`).\n\nSince version 5.0, empty groups are also scheduled for removal after `empty-group-min-timeout`.\nIf `expireGroupsUponCompletion == false` and `minimumTimeoutForEmptyGroups > 0`, the task to remove the group is scheduled when normal or partial sequences release happens.\n\nStarting with version 5.4, the aggregator (and resequencer) can be configured to expire orphaned groups (those in a persistent message store that might not otherwise be released).\nThe `expireTimeout` (if greater than `0`) indicates that groups older than this value in the store should be purged.\nThe `purgeOrphanedGroups()` method is called on startup and, together with the provided `expireDuration`, periodically within a scheduled task.\nThis method is also can be called externally at any time.\nThe expiration logic is fully delegated to the `forceComplete(MessageGroup)` functionality according to the provided expiration options mentioned above.\nSuch a periodic purge functionality is useful when a message store is needed to be cleaned up from those old groups which are not going to be released anymore with regular message arrival logic.\nIn most cases this happens after an application restarts, when using a persistent message group store.\nThe functionality is similar to the `MessageGroupStoreReaper` with a scheduled task, but provides a convenient way to deal with old groups within specific components, when using group timeout instead of a reaper.\nThe `MessageGroupStore` must be provided exclusively for the current correlation endpoint.\nOtherwise, one aggregator may purge groups from another.\nWith the aggregator, groups expired using this technique will either be discarded or released as a partial group, depending on the `expireGroupsUponCompletion` property.\n=====\n\nWe generally recommend using a `ref` attribute if a custom aggregator handler implementation may be referenced in other `<aggregator>` definitions.\nHowever, if a custom aggregator implementation is only being used by a single definition of the `<aggregator>`, you can use an inner bean definition (starting with version 1.0.3) to configure the aggregation POJO within the `<aggregator>` element, as the following example shows:\n\n[source,xml]\n----\n<aggregator input-channel=\"input\" method=\"sum\" output-channel=\"output\">\n <beans:bean class=\"org.foo.PojoAggregator\"/>\n</aggregator>\n----\n\nNOTE: Using both a `ref` attribute and an inner bean definition in the same `<aggregator>` configuration is not allowed, as it creates an ambiguous condition.\nIn such cases, an Exception is thrown.\n\nThe following example shows an implementation of the aggregator bean:\n\n[source,java]\n----\npublic class PojoAggregator {\n\n public Long add(List<Long> results) {\n long total = 0l;\n for (long partialResult: results) {\n total += partialResult;\n }\n return total;\n }\n}\n----\n\nAn implementation of the completion strategy bean for the preceding example might be as follows:\n\n[source,java]\n----\npublic class PojoReleaseStrategy {\n...\n public boolean canRelease(List<Long> numbers) {\n int sum = 0;\n for (long number: numbers) {\n sum += number;\n }\n return sum >= maxValue;\n }\n}\n----\n\nNOTE: Wherever it makes sense to do so, the release strategy method and the aggregator method can be combined into a single bean.\n\nAn implementation of the correlation strategy bean for the example above might be as follows:\n\n[source,java]\n----\npublic class PojoCorrelationStrategy {\n...\n public Long groupNumbersByLastDigit(Long number) {\n return number % 10;\n }\n}\n----\n\nThe aggregator in the preceding example would group numbers by some criterion (in this case, the remainder after dividing by ten) and hold the group until the sum of the numbers provided by the payloads exceeds a certain value.\n\nNOTE: Wherever it makes sense to do so, the release strategy method, the correlation strategy method, and the aggregator method can be combined in a single bean.\n(Actually, all of them or any two of them can be combined.)\n\n[[aggregator-spel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Configuring an Aggregator with XML", "heading_level": 3, "file_order": 161, "section_index": 10, "content_hash": "2137ed1fe981150531868f5a54b2cd5c251ff3f2dac7969b49f6699a82c368c8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:d2515adf9b3790b08cee62e11f677d64f72402741df657af05063e2a2a696fec", "content": "Since Spring Integration 2.0, you can handle the various strategies (correlation, release, and aggregation) with https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions[SpEL], which we recommend if the logic behind such a release strategy is relatively simple.\nSuppose you have a legacy component that was designed to receive an array of objects.\nWe know that the default release strategy assembles all aggregated messages in the `List`.\nNow we have two problems.\nFirst, we need to extract individual messages from the list.\nSecond, we need to extract the payload of each message and assemble the array of objects.\nThe following example solves both problems:\n\n[source,java]\n----\npublic String[] processRelease(List<Message<String>> messages){\n List<String> stringList = new ArrayList<>();\n for (Message<String> message : messages) {\n stringList.add(message.getPayload());\n }\n return stringList.toArray(new String[]{});\n}\n----\n\nHowever, with SpEL, such a requirement could actually be handled relatively easily with a one-line expression, thus sparing you from writing a custom class and configuring it as a bean.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<int:aggregator input-channel=\"aggChannel\"\n output-channel=\"replyChannel\"\n expression=\"#this.![payload].toArray()\"/>\n----\n\nIn the preceding configuration, we use a https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions[collection projection] expression to assemble a new collection from the payloads of all the messages in the list and then transform it to an array, thus achieving the same result as the earlier Java code.\n\nYou can apply the same expression-based approach when dealing with custom release and correlation strategies.\n\nInstead of defining a bean for a custom `CorrelationStrategy` in the `correlation-strategy` attribute, you can implement your simple correlation logic as a SpEL expression and configure it in the `correlation-strategy-expression` attribute, as the following example shows:\n\n[source,xml]\n----\ncorrelation-strategy-expression=\"payload.person.id\"\n----\n\nIn the preceding example, we assume that the payload has a `person` attribute with an `id`, which is going to be used to correlate messages.\n\nLikewise, for the `ReleaseStrategy`, you can implement your release logic as a SpEL expression and configure it in the `release-strategy-expression` attribute.\nThe root object for evaluation context is the `MessageGroup` itself.\nThe `List` of messages can be referenced by using the `message` property of the group within the expression.\n\nNOTE: In releases prior to version 5.0, the root object was the collection of `Message<?>`, as the previous example shows:\n\n[source,xml]\n----\nrelease-strategy-expression=\"!messages.?[payload==5].empty\"\n----\n\nIn the preceding example, the root object of the SpEL evaluation context is the `MessageGroup` itself, and you are stating that, as soon as there is a message with payload of `5` in this group, the group should be released.\n\n[[agg-and-group-to]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Aggregators and Spring Expression Language (SpEL)", "heading_level": 4, "file_order": 161, "section_index": 11, "content_hash": "d2515adf9b3790b08cee62e11f677d64f72402741df657af05063e2a2a696fec", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:60d2ad44dbee6b5d3f8741411a268b2790c2d9e961b997dcf4c4afac75a63128", "content": "Starting with version 4.0, two new mutually exclusive attributes have been introduced: `group-timeout` and `group-timeout-expression`.\nSee xref:aggregator.adoc#aggregator-xml[Configuring an Aggregator with XML].\nIn some cases, you may need to emit the aggregator result (or discard the group) after a timeout if the `ReleaseStrategy` does not release when the current message arrives.\nFor this purpose, the `groupTimeout` option lets scheduling the `MessageGroup` be forced to complete, as the following example shows:\n\n[source,xml]\n----\n<aggregator input-channel=\"input\" output-channel=\"output\"\n send-partial-result-on-expiry=\"true\"\n group-timeout-expression=\"size() ge 2 ? 10000 : -1\"\n release-strategy-expression=\"messages[0].headers.sequenceNumber == messages[0].headers.sequenceSize\"/>\n----\n\nWith this example, the normal release is possible if the aggregator receives the last message in sequence as defined by the `release-strategy-expression`.\nIf that specific message does not arrive, the `groupTimeout` forces the group to complete after ten seconds, as long as the group contains at least two Messages.\n\nThe results of forcing the group to complete depend on the `ReleaseStrategy` and the `send-partial-result-on-expiry`.\nFirst, the release strategy is again consulted to see if a normal release is to be made.\nWhile the group has not changed, the `ReleaseStrategy` can decide to release the group at this time.\nIf the release strategy still does not release the group, it is expired.\nIf `send-partial-result-on-expiry` is `true`, existing messages in the (partial) `MessageGroup` are released as a normal aggregator reply message to the `output-channel`.\nOtherwise, it is discarded.\n\nThere is a difference between `groupTimeout` behavior and `MessageGroupStoreReaper` (see xref:aggregator.adoc#aggregator-xml[Configuring an Aggregator with XML]).\nThe reaper initiates forced completion for all ``MessageGroup``s in the `MessageGroupStore` periodically.\nThe `groupTimeout` does it for each `MessageGroup` individually if a new message does not arrive during the `groupTimeout`.\nAlso, the reaper can be used to remove empty groups (those retained in order to discard late messages if `expire-groups-upon-completion` is false).\n\nStarting with version 5.5, the `groupTimeoutExpression` can be evaluated to a `java.util.Date` instance.\nThis can be useful in cases like determining a scheduled task moment based on the group creation time (`MessageGroup.getTimestamp()`) instead of a current message arrival as it is calculated when `groupTimeoutExpression` is evaluated to `long`:\n\n[source,xml]\n----\ngroup-timeout-expression=\"size() ge 2 ? new java.util.Date(timestamp + 200) : null\"\n----\n\n[[aggregator-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Aggregator and Group Timeout", "heading_level": 4, "file_order": 161, "section_index": 12, "content_hash": "60d2ad44dbee6b5d3f8741411a268b2790c2d9e961b997dcf4c4afac75a63128", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:abff8bd3c247ca3f34f4f5bb40e2b5ca74b5bd48b2eff03e195ca5770cf33a65", "content": "The following example shows an aggregator configured with annotations:\n\n[source,java]\n----\npublic class Waiter {\n ...\n\n @Aggregator <1>\n public Delivery aggregatingMethod(List<OrderItem> items) {\n ...\n }\n\n @ReleaseStrategy <2>\n public boolean releaseChecker(List<Message<?>> messages) {\n ...\n }\n\n @CorrelationStrategy <3>\n public String correlateBy(OrderItem item) {\n ...\n }\n}\n----\n\n<1> An annotation indicating that this method should be used as an aggregator.\nIt must be specified if this class is used as an aggregator.\n<2> An annotation indicating that this method is used as the release strategy of an aggregator.\nIf not present on any method, the aggregator uses the `SimpleSequenceSizeReleaseStrategy`.\n<3> An annotation indicating that this method should be used as the correlation strategy of an aggregator.\nIf no correlation strategy is indicated, the aggregator uses the `HeaderAttributeCorrelationStrategy` based on `CORRELATION_ID`.\n\nAll of the configuration options provided by the XML element are also available for the `@Aggregator` annotation.\n\nThe aggregator can be either referenced explicitly from XML or, if the `@MessageEndpoint` is defined on the class, detected automatically through classpath scanning.\n\nAnnotation configuration (`@Aggregator` and others) for the Aggregator component covers only simple use cases, where most default options are sufficient.\nIf you need more control over those options when using annotation configuration, consider using a `@Bean` definition for the `AggregatingMessageHandler` and mark its `@Bean` method with `@ServiceActivator`, as the following example shows:\n\n[source,java]\n----\n@ServiceActivator(inputChannel = \"aggregatorChannel\")\n@Bean\npublic MessageHandler aggregator(MessageGroupStore jdbcMessageGroupStore) {\n AggregatingMessageHandler aggregator =\n new AggregatingMessageHandler(new DefaultAggregatingMessageGroupProcessor(),\n jdbcMessageGroupStore);\n aggregator.setOutputChannel(resultsChannel());\n aggregator.setGroupTimeoutExpression(new ValueExpression<>(500L));\n aggregator.setTaskScheduler(this.taskScheduler);\n return aggregator;\n}\n----\n\nSee xref:aggregator.adoc#aggregator-api[Programming Model] and xref:configuration/meta-annotations.adoc#annotations_on_beans[Annotations on `@Bean` Methods] for more information.\n\nNOTE: Starting with version 4.2, the `AggregatorFactoryBean` is available to simplify Java configuration for the `AggregatingMessageHandler`.\n\n[[reaper]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Configuring an Aggregator with Annotations", "heading_level": 3, "file_order": 161, "section_index": 13, "content_hash": "abff8bd3c247ca3f34f4f5bb40e2b5ca74b5bd48b2eff03e195ca5770cf33a65", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:4a6b694acf4458a5440fd0dbccef1732cce9763ba99a09dcf9204cd0b8658e27", "content": "Aggregator (and some other patterns in Spring Integration) is a stateful pattern that requires decisions to be made based on a group of messages that have arrived over a period of time, all with the same correlation key.\nThe design of the interfaces in the stateful patterns (such as `ReleaseStrategy`) is driven by the principle that the components (whether defined by the framework or by a user) should be able to remain stateless.\nAll states are carried by the `MessageGroup` and its management is delegated to the `MessageGroupStore`.\nThe `MessageGroupStore` interface is defined as follows:\n\n[source,java]\n----\npublic interface MessageGroupStore {\n\n int getMessageCountForAllMessageGroups();\n\n int getMarkedMessageCountForAllMessageGroups();\n\n int getMessageGroupCount();\n\n MessageGroup getMessageGroup(Object groupId);\n\n MessageGroup addMessageToGroup(Object groupId, Message<?> message);\n\n MessageGroup markMessageGroup(MessageGroup group);\n\n MessageGroup removeMessageFromGroup(Object key, Message<?> messageToRemove);\n\n MessageGroup markMessageFromGroup(Object key, Message<?> messageToMark);\n\n void removeMessageGroup(Object groupId);\n\n void registerMessageGroupExpiryCallback(MessageGroupCallback callback);\n\n int expireMessageGroups(long timeout);\n}\n----\n\nFor more information, see the https://docs.spring.io/spring-integration/api/org/springframework/integration/store/MessageGroupStore.html[Javadoc].\n\nThe `MessageGroupStore` accumulates state information in `MessageGroups` while waiting for a release strategy to be triggered, and that event might not ever happen.\nSo, to prevent stale messages from lingering, and for volatile stores to provide a hook for cleaning up when the application shuts down, the `MessageGroupStore` lets you register callbacks to apply to its `MessageGroups` when they expire.\nThe interface is very straightforward, as the following listing shows:\n\n[source,java]\n----\npublic interface MessageGroupCallback {\n\n void execute(MessageGroupStore messageGroupStore, MessageGroup group);\n\n}\n----\n\nThe callback has direct access to the store and the message group so that it can manage the persistent state (for example, by entirely removing the group from the store).\n\nThe `MessageGroupStore` maintains a list of these callbacks, which it applies, on demand, to all messages whose timestamps are earlier than a time supplied as a parameter (see the `registerMessageGroupExpiryCallback(..)` and `expireMessageGroups(..)` methods, described earlier).\n\nIMPORTANT: It is important not to use the same `MessageGroupStore` instance in different aggregator components, when you intend to rely on the `expireMessageGroups` functionality.\nEvery `AbstractCorrelatingMessageHandler` registers its own `MessageGroupCallback` based on the `forceComplete()` callback.\nThis way each group for expiration may be completed or discarded by the wrong aggregator.\nStarting with version 5.0.10, a `UniqueExpiryCallback` is used from the `AbstractCorrelatingMessageHandler` for the registration callback in the `MessageGroupStore`.\nThe `MessageGroupStore`, in turn, checks for presence an instance of this class and logs an error with an appropriate message if one is already present in the callbacks set.\nThis way the Framework disallows usage of the `MessageGroupStore` instance in different aggregators/resequencers to avoid the mentioned side effect of expiration the groups not created by the particular correlation handler.\n\nYou can call the `expireMessageGroups` method with a timeout value.\nAny message older than the current time minus this value is expired and has the callbacks applied.\nThus, it is the user of the store that defines what is meant by message group \"`expiry`\".\n\nAs a convenience for users, Spring Integration provides a wrapper for the message expiry in the form of a `MessageGroupStoreReaper`, as the following example shows:\n\n[source,xml]\n----\n<bean id=\"reaper\" class=\"org...MessageGroupStoreReaper\">\n <property name=\"messageGroupStore\" ref=\"messageStore\"/>\n <property name=\"timeout\" value=\"30000\"/>\n</bean>\n\n<task:scheduled-tasks scheduler=\"scheduler\">\n <task:scheduled ref=\"reaper\" method=\"run\" fixed-rate=\"10000\"/>\n</task:scheduled-tasks>\n----\n\nThe reaper is a `Runnable`.\nIn the preceding example, the message group store's expire method is called every ten seconds.\nThe timeout itself is 30 seconds.\n\nNOTE: It is important to understand that the 'timeout' property of `MessageGroupStoreReaper` is an approximate value and is impacted by the rate of the task scheduler, since this property is only checked on the next scheduled execution of the `MessageGroupStoreReaper` task.\nFor example, if the timeout is set for ten minutes but the `MessageGroupStoreReaper` task is scheduled to run every hour and the last execution of the `MessageGroupStoreReaper` task happened one minute before the timeout, the `MessageGroup` does not expire for the next 59 minutes.\nConsequently, we recommend setting the rate to be at least equal to the value of the timeout or shorter.\n\nIn addition to the reaper, the expiry callbacks are invoked when the application shuts down through a lifecycle callback in the `AbstractCorrelatingMessageHandler`.\n\nThe `AbstractCorrelatingMessageHandler` registers its own expiry callback, and this is the link with the boolean flag `send-partial-result-on-expiry` in the XML configuration of the aggregator.\nIf the flag is set to `true`, then, when the expiry callback is invoked, any unmarked messages in groups that are not yet released can be sent on to the output channel.\n\nIMPORTANT: Since the `MessageGroupStoreReaper` is called from a scheduled task, and may result in the production of a message (depending on the `sendPartialResultOnExpiry` option) to a downstream integration flow, it is recommended to supply a custom `TaskScheduler` with a `MessagePublishingErrorHandler` to handler exceptions via an `errorChannel`, as it might be expected by the regular aggregator release functionality.\nThe same logic applies for group timeout functionality which also relies on a `TaskScheduler`.\nSee xref:scatter-gather.adoc#scatter-gather-error-handling[Error Handling] for more information.\n\n[IMPORTANT]\n=====\nWhen a shared `MessageStore` is used for different correlation endpoints, you must configure a proper `CorrelationStrategy` to ensure uniqueness for group IDs.\nOtherwise, unexpected behavior may happen when one correlation endpoint releases or expires messages from others.\nMessages with the same correlation key are stored in the same message group.\n\nSome `MessageStore` implementations allow using the same physical resources, by partitioning the data.\nFor example, the `JdbcMessageStore` has a `region` property, and the `MongoDbMessageStore` has a `collectionName` property.\n\nFor more information about the `MessageStore` interface and its implementations, see xref:message-store.adoc[Message Store].\n=====\n\n[[flux-aggregator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Managing State in an Aggregator: `MessageGroupStore`", "heading_level": 2, "file_order": 161, "section_index": 14, "content_hash": "4a6b694acf4458a5440fd0dbccef1732cce9763ba99a09dcf9204cd0b8658e27", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:30a596bc3ab5246a74c86c1f40a8d6d400d041be08bc959d162c6bbb84329098", "content": "In version 5.2, the `FluxAggregatorMessageHandler` component has been introduced.\nIt is based on the Project Reactor `Flux.groupBy()` and `Flux.window()` operators.\nThe incoming messages are emitted into the `FluxSink` initiated by the `Flux.create()` in the constructor of this component.\nIf the `outputChannel` is not provided or it is not an instance of `ReactiveStreamsSubscribableChannel`, the subscription to the main `Flux` is done from the `Lifecycle.start()` implementation.\nOtherwise, it is postponed to the subscription done by the `ReactiveStreamsSubscribableChannel` implementation.\nThe messages are grouped by the `Flux.groupBy()` using a `CorrelationStrategy` for the group key.\nBy default, the `IntegrationMessageHeaderAccessor.CORRELATION_ID` header of the message is consulted.\n\nBy default, every closed window is released as a `Flux` in payload of a message to produce.\nThis message contains all the headers from the first message in the window.\nThis `Flux` in the output message payload must be subscribed and processed downstream.\nSuch a logic can be customized (or superseded) by the `setCombineFunction(Function<Flux<Message<?>>, Mono<Message<?>>>)` configuration option of the `FluxAggregatorMessageHandler`.\nFor example, if we would like to have a `List` of payloads in the final message, we can configure a `Flux.collectList()` like this:\n\n[source,java]\n----\nfluxAggregatorMessageHandler.setCombineFunction(\n (messageFlux) ->\n messageFlux\n .map(Message::getPayload)\n .collectList()\n .map(GenericMessage::new));\n----\n\nThere are several options in the `FluxAggregatorMessageHandler` to select an appropriate window strategy:\n\n* `setBoundaryTrigger(Predicate<Message<?>>)` - is propagated to the `Flux.windowUntil()` operator.\nSee its Javadocs for more information.\nHas a precedence over all other window options.\n* `setWindowSize(int)` and `setWindowSizeFunction(Function<Message<?>, Integer>)` - is propagated to the `Flux.window(int)` or `windowTimeout(int, Duration)`.\nBy default, a window size is calculated from the first message in group and its `IntegrationMessageHeaderAccessor.SEQUENCE_SIZE` header.\n* `setWindowTimespan(Duration)` - is propagated to the `Flux.window(Duration)` or `windowTimeout(int, Duration)` depending on the window size configuration.\n* `setWindowConfigurer(Function<Flux<Message<?>>, Flux<Flux<Message<?>>>>)` - a function to apply a transformation into the grouped fluxes for any custom window operation not covered by the exposed options.\n\nSince this component is a `MessageHandler` implementation it can simply be used as a `@Bean` definition together with a `@ServiceActivator` messaging annotation.\nWith Java DSL it can be used from the `.handle()` EIP-method.\nThe sample below demonstrates how we can register an `IntegrationFlow` at runtime and how a `FluxAggregatorMessageHandler` can be correlated with a splitter upstream:\n\n[source,java]\n----\nIntegrationFlow fluxFlow =\n (flow) -> flow\n .split()\n .channel(MessageChannels.flux())\n .handle(new FluxAggregatorMessageHandler());\n\nIntegrationFlowContext.IntegrationFlowRegistration registration =\n this.integrationFlowContext.registration(fluxFlow)\n .register();\n\n@SuppressWarnings(\"unchecked\")\nFlux<Message<?>> window =\n registration.getMessagingTemplate()\n .convertSendAndReceive(new Integer[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }, Flux.class);\n----\n\n[[agg-message-group-condition]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Flux Aggregator", "heading_level": 2, "file_order": 161, "section_index": 15, "content_hash": "30a596bc3ab5246a74c86c1f40a8d6d400d041be08bc959d162c6bbb84329098", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:1c2e080ef43b2784bf855e3e44df3cfd9d6cb03fc59bc50602f5aa0cbc9f40bc", "content": "Starting with version 5.5, an `AbstractCorrelatingMessageHandler` (including its Java & XML DSLs) exposes a `groupConditionSupplier` option of the `BiFunction<Message<?>, String, String>` implementation.\nThis function is used on each message added to the group, and a result condition sentence is stored into the group for future consideration.\nThe `ReleaseStrategy` may consult this condition instead of iterating over all the messages in the group.\nSee `GroupConditionProvider` JavaDocs and xref:message-store.adoc#message-group-condition[Message Group Condition] for more information.\n\nSee also xref:file/aggregator.adoc[File Aggregator].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/aggregator.adoc", "title": "aggregator", "heading": "Condition on the Message Group", "heading_level": 2, "file_order": 161, "section_index": 16, "content_hash": "1c2e080ef43b2784bf855e3e44df3cfd9d6cb03fc59bc50602f5aa0cbc9f40bc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/aggregator.adoc"}}
{"id": "sha256:57ae25b1cde7cde33d6fa65af608d4143a6fb660b5a1305d081499323f4f785c", "content": "[[amqp]]\n\nSpring Integration provides channel adapters for receiving and sending messages by using the Advanced Message Queuing Protocol (AMQP).\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-amqp</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-amqp:{project-version}\"\n----\n======\n\nThe following adapters are available:\n\n* xref:amqp/inbound-channel-adapter.adoc[Inbound Channel Adapter]\n* xref:amqp/inbound-gateway.adoc[Inbound Gateway]\n* xref:amqp/outbound-channel-adapter.adoc[Outbound Channel Adapter]\n* xref:amqp/outbound-gateway.adoc[Outbound Gateway]\n* xref:amqp/async-outbound-gateway.adoc[Async Outbound Gateway]\n* xref:amqp/rmq-streams.adoc#rmq-stream-inbound-channel-adapter[RabbitMQ Stream Queue Inbound Channel Adapter]\n* xref:amqp/rmq-streams.adoc#rmq-stream-outbound-channel-adapter[RabbitMQ Stream Queue Outbound Channel Adapter]\n* xref:amqp/amqp-1.0.adoc[AMQP 1.0 Channel Adapters]\n\nSpring Integration also provides a point-to-point message channel and a publish-subscribe message channel backed by AMQP Exchanges and Queues.\n\nTo provide AMQP support, Spring Integration relies on (https://spring.io/spring-amqp[Spring AMQP]), which applies core Spring concepts to the development of AMQP-based messaging solutions.\nSpring AMQP provides similar semantics to (https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#jms[Spring JMS]).\n\nWhereas the provided AMQP Channel Adapters are intended for unidirectional messaging (send or receive) only, Spring Integration also provides inbound and outbound AMQP gateways for request-reply operations.\n\nTIP:\nYou should familiarize yourself with the https://docs.spring.io/spring-amqp/reference[reference documentation of the Spring AMQP project].\nIt provides much more in-depth information about Spring's integration with AMQP in general and RabbitMQ in particular.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/amqp.adoc", "title": "amqp", "heading": "amqp", "heading_level": 1, "file_order": 162, "section_index": 0, "content_hash": "57ae25b1cde7cde33d6fa65af608d4143a6fb660b5a1305d081499323f4f785c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/amqp.adoc"}}
{"id": "sha256:ac904a45b0283aee0fd85908fd72088109a3cffcd9298b7e8ddb07e81d6d0ebc", "content": "[[barrier]]\n\nSometimes, we need to suspend a message flow thread until some other asynchronous event occurs.\nFor example, consider an HTTP request that publishes a message to RabbitMQ.\nWe might wish to not reply to the user until the RabbitMQ broker has issued an acknowledgment that the message was received.\n\nIn version 4.2, Spring Integration introduced the `<barrier/>` component for this purpose.\nThe underlying `MessageHandler` is the `BarrierMessageHandler`.\nThis class also implements `MessageTriggerAction`, in which a message passed to the `trigger()` method releases a corresponding thread in the `handleRequestMessage()` method (if present).\n\nThe suspended thread and trigger thread are correlated by invoking a `CorrelationStrategy` on the messages.\nWhen a message is sent to the `input-channel`, the thread is suspended for up to `requestTimeout` milliseconds, waiting for a corresponding trigger message.\nThe default correlation strategy uses the `IntegrationMessageHeaderAccessor.CORRELATION_ID` header.\nWhen a trigger message arrives with the same correlation, the thread is released.\nThe message sent to the `output-channel` after release is constructed by using a `MessageGroupProcessor`.\nBy default, the message is a `Collection<?>` of the two payloads, and the headers are merged by using a `DefaultAggregatingMessageGroupProcessor`.\n\nCAUTION: If the `trigger()` method is invoked first (or after the main thread times out), it is suspended for up to `triggerTimeout` waiting for the suspending message to arrive.\nIf you do not want to suspend the trigger thread, consider handing off to a `TaskExecutor` instead so that its thread is suspended instead.\n\nNOTE: Prior version 5.4, there was only one `timeout` option for both request and trigger messages, but in some use-case it is better to have different timeouts for those actions.\nTherefore `requestTimeout` and `triggerTimeout` options have been introduced.\n\nThe `requires-reply` property determines the action to take if the suspended thread times out before the trigger message arrives.\nBy default, it is `false`, which means the endpoint returns `null`, the flow ends, and the thread returns to the caller.\nWhen `true`, a `ReplyRequiredException` is thrown.\n\nYou can call the `trigger()` method programmatically (obtain the bean reference by using the name, `barrier.handler` -- where `barrier` is the bean name of the barrier endpoint).\nAlternatively, you can configure an `<outbound-channel-adapter/>` to trigger the release.\n\nIMPORTANT: Only one thread can be suspended with the same correlation.\nThe same correlation can be used multiple times but only once concurrently.\nAn exception is thrown if a second thread arrives with the same correlation.\n\nThe following example shows how to use a custom header for correlation:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@ServiceActivator(inputChannel=\"in\")\n@Bean\npublic BarrierMessageHandler barrier(MessageChannel out, MessageChannel lateTriggerChannel) {\n BarrierMessageHandler barrier = new BarrierMessageHandler(10000);\n barrier.setOutputChannel(out());\n barrier.setDiscardChannel(lateTriggerChannel);\n return barrier;\n}\n\n@ServiceActivator (inputChannel=\"release\")\n@Bean\npublic MessageHandler releaser(MessageTriggerAction barrier) {\n return barrier::trigger;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:barrier id=\"barrier1\" input-channel=\"in\" output-channel=\"out\"\n correlation-strategy-expression=\"headers['myHeader']\"\n output-processor=\"myOutputProcessor\"\n discard-channel=\"lateTriggerChannel\"\n timeout=\"10000\">\n</int:barrier>\n\n<int:outbound-channel-adapter channel=\"release\" ref=\"barrier1.handler\" method=\"trigger\" />\n----\n======\n\nDepending on which one has a message arrive first, either the thread sending a message to `in` or the thread sending a message to `release` waits for up to ten seconds until the other message arrives.\nWhen the message is released, the `out` channel is sent a message that combines the result of invoking the custom `MessageGroupProcessor` bean, named `myOutputProcessor`.\nIf the main thread times out and a trigger arrives later, you can configure a discard channel to which the late trigger is sent.\nThe trigger message is also discarded if a request message does not arrive in time.\n\nFor an example of this component, see the https://github.com/spring-projects/spring-integration-samples/tree/main/basic/barrier[barrier sample application].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/barrier.adoc", "title": "barrier", "heading": "barrier", "heading_level": 1, "file_order": 163, "section_index": 0, "content_hash": "ac904a45b0283aee0fd85908fd72088109a3cffcd9298b7e8ddb07e81d6d0ebc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/barrier.adoc"}}
{"id": "sha256:aba3a0cc28741a9ba1278086f9ac3dee599c9e03d33535c42463517d9ddf60e9", "content": "[[bridge]]\n\nA messaging bridge is a relatively trivial endpoint that connects two message channels or channel adapters.\nFor example, you may want to connect a `PollableChannel` to a `SubscribableChannel` so that the subscribing endpoints do not have to worry about any polling configuration.\nInstead, the messaging bridge provides the polling configuration.\n\nBy providing an intermediary poller between two channels, you can use a messaging bridge to throttle inbound messages.\nThe poller's trigger determines the rate at which messages arrive at the second channel, and the poller's `maxMessagesPerPoll` property enforces a limit on the throughput.\n\nAnother valid use for a messaging bridge is to connect two different systems.\nIn such a scenario, Spring Integration's role is limited to making the connection between these systems and managing a poller, if necessary.\nIt is probably more common to have at least a transformer between the two systems to translate between their formats.\nIn that case, the channels can be provided as the 'input-channel' and 'output-channel' of a transformer endpoint.\nIf data format translation is not required, the messaging bridge may indeed be sufficient.\n\n[[bridge-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/bridge.adoc", "title": "bridge", "heading": "bridge", "heading_level": 1, "file_order": 164, "section_index": 0, "content_hash": "aba3a0cc28741a9ba1278086f9ac3dee599c9e03d33535c42463517d9ddf60e9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/bridge.adoc"}}
{"id": "sha256:42605406fb0d39e102956ce8c8ecf44b62acff3d0fde16b4b73310c8156b727e", "content": "You can use the `<bridge>` element is used to create a messaging bridge between two message channels or channel adapters.\nTo do so, provide the `input-channel` and `output-channel` attributes, as the following example shows:\n\n[source,xml]\n----\n<int:bridge input-channel=\"input\" output-channel=\"output\"/>\n----\n\nAs mentioned above, a common use case for the messaging bridge is to connect a `PollableChannel` to a `SubscribableChannel`.\nWhen performing this role, the messaging bridge may also serve as a throttler:\n\n[source,xml]\n----\n<int:bridge input-channel=\"pollable\" output-channel=\"subscribable\">\n <int:poller max-messages-per-poll=\"10\" fixed-rate=\"5000\"/>\n </int:bridge>\n----\n\nYou can use a similar mechanism to connect channel adapters.\nThe following example shows a simple \"`echo`\" between the `stdin` and `stdout` adapters from Spring Integration's `stream` namespace:\n\n[source,xml]\n----\n<int-stream:stdin-channel-adapter id=\"stdin\"/>\n\n <int-stream:stdout-channel-adapter id=\"stdout\"/>\n\n <int:bridge id=\"echo\" input-channel=\"stdin\" output-channel=\"stdout\"/>\n----\n\nSimilar configurations work for other (potentially more useful) Channel Adapter bridges, such as file-to-JMS or mail-to-file.\nUpcoming chapters cover the various channel adapters.\n\nNOTE: If no 'output-channel' is defined on a bridge, the reply channel provided by the inbound message is used, if available.\nIf neither an output nor a reply channel is available, an exception is thrown.\n\n[[bridge-annot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/bridge.adoc", "title": "bridge", "heading": "Configuring a Bridge with XML", "heading_level": 2, "file_order": 164, "section_index": 1, "content_hash": "42605406fb0d39e102956ce8c8ecf44b62acff3d0fde16b4b73310c8156b727e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/bridge.adoc"}}
{"id": "sha256:6a200f1e2b7c7cc0a43023063093e9d8b73f2728171befcd694dbf34400610dc", "content": "The following example shows how to configure a bridge in Java by using the `@BridgeFrom` annotation:\n\n[source, java]\n----\n@Bean\npublic PollableChannel polled() {\n return new QueueChannel();\n}\n\n@Bean\n@BridgeFrom(value = \"polled\", poller = @Poller(fixedDelay = \"5000\", maxMessagesPerPoll = \"10\"))\npublic SubscribableChannel direct() {\n return new DirectChannel();\n}\n----\n\nThe following example shows how to configure a bridge in Java by using the `@BridgeTo` annotation:\n\n[source, java]\n----\n@Bean\n@BridgeTo(value = \"direct\", poller = @Poller(fixedDelay = \"5000\", maxMessagesPerPoll = \"10\"))\npublic PollableChannel polled() {\n return new QueueChannel();\n}\n\n@Bean\npublic SubscribableChannel direct() {\n return new DirectChannel();\n}\n----\n\nAlternately, you can use a `BridgeHandler`, as the following example shows:\n\n[source, java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"polled\",\n poller = @Poller(fixedRate = \"5000\", maxMessagesPerPoll = \"10\"))\npublic BridgeHandler bridge() {\n BridgeHandler bridge = new BridgeHandler();\n bridge.setOutputChannelName(\"direct\");\n return bridge;\n}\n----\n\n[[bridge-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/bridge.adoc", "title": "bridge", "heading": "Configuring a Bridge with Java Configuration", "heading_level": 2, "file_order": 164, "section_index": 2, "content_hash": "6a200f1e2b7c7cc0a43023063093e9d8b73f2728171befcd694dbf34400610dc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/bridge.adoc"}}
{"id": "sha256:1933aa821191c07b5eeb01444862b0195aeb25fefb20366333d2a60dda690484", "content": "You can use the Java Domain Specific Language (DSL) to configure a bridge, as the following example shows:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow bridgeFlow() {\n return IntegrationFlow.from(\"polled\")\n .bridge(e -> e.poller(Pollers.fixedDelay(5000).maxMessagesPerPoll(10)))\n .channel(\"direct\")\n .get();\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/bridge.adoc", "title": "bridge", "heading": "Configuring a Bridge with the Java DSL", "heading_level": 2, "file_order": 164, "section_index": 3, "content_hash": "1933aa821191c07b5eeb01444862b0195aeb25fefb20366333d2a60dda690484", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/bridge.adoc"}}
{"id": "sha256:3f0b6e07f4523eccd90faac9738e097690e4efa7abdef00f727dedfe3e71d257", "content": "[[camel]]\n\nSpring Integration provides an API and configuration to communicate with https://camel.apache.org[Apache Camel] endpoints declared in the same application context.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-camel</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-camel:{project-version}\"\n----\n======\n\nSpring Integration and Apache Camel implement Enterprise Integration Patterns and provide a convenient way to compose them, but the projects use a different approach for their API and abstractions implementation.\nSpring Integration fully relies on a dependency injection container from Spring Core.\nIt uses many other Spring projects (Spring Data, Spring AMQP, Spring for Apache Kafka etc.) for its channel adapter implementations.\nIt also uses the `MessageChannel` abstraction as a first-class citizen of which developers need to be aware of, when composing their integration flows.\nApache Camel, on the other hand, does not provide a first-class citizen abstraction of a message channel and proposes to compose its routes via internal exchanges, hidden from the API.\nIn addition, it requires some extra https://camel.apache.org/manual/spring.html[dependencies and configurations] for it to be used in a Spring application.\n\nEven if it doesn't matter for the final enterprise integration solution, how its parts are implemented, a developer experience and high productivity are taken into account.\nTherefore, developers may choose one framework over another for many reasons or both if there is a gap in some target systems support.\nSpring Integration and Apache Camel applications can interact with each other through many external protocols for which they implement channel adapters.\nFor example, a Spring Integration flow may publish a record to an Apache Kafka topic which is consumed by an Apache Camel endpoint on the consumer side.\nOr, an Apache Camel route may write data into an SFTP file into the directory, which is polled by a SFTP Inbound Channel Adapter from Spring Integration.\nOr, within the same Spring application context they can communicate via an `ApplicationEvent`.\n\nTo make the development process easier and to avoid unnecessary network hops, Spring Integration now provides a channel adapter to call an Apache Camel endpoint and, optionally, wait for a reply.\nThere is no inbound channel adapter because using the Apache Camel https://camel.apache.org/manual/bean-binding.html[Bean Binding] is enough to call any bean in the Spring application context, including xref:gateway.adoc[].\n\n[[camel-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/camel.adoc", "title": "camel", "heading": "camel", "heading_level": 1, "file_order": 165, "section_index": 0, "content_hash": "3f0b6e07f4523eccd90faac9738e097690e4efa7abdef00f727dedfe3e71d257", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/camel.adoc"}}
{"id": "sha256:04b50a009cd883281f542393f8ece6fda28721d126b46b6ea8358d9d3ab87853", "content": "The `CamelMessageHandler` is an `AbstractReplyProducingMessageHandler` implementation and can work in both one-way (default) and request-reply modes.\nIt uses an `org.apache.camel.ProducerTemplate` to send (or send and receive) into an `org.apache.camel.Endpoint`.\nAn interaction mode can be controlled by the `ExchangePattern` option (which can be evaluated at runtime against the request message via a SpEL expression).\nThe target Apache Camel endpoint can be configured explicitly or as a SpEL expression to be evaluated at runtime.\nOtherwise, it falls back to the `defaultEndpoint` provided on the `ProducerTemplate`.\nInstead of specifying the endpoint, an in-line, explicit `LambdaRouteBuilder` can be provided, for example, to make a call into an Apache Camel component for which there is no channel adapter support in Spring Integration.\n\nIn addition, a `HeaderMapper<org.apache.camel.Message>` (the `CamelHeaderMapper` is a default implementation) can be provided, to determine which headers to map between the Spring Integration and Apache Camel messages.\nBy default, all headers are mapped.\n\nThe `CamelMessageHandler` supports an `async` mode calling `ProducerTemplate.asyncSend()` and producing a `CompletableFuture` for reply processing (if any).\n\nThe `exchangeProperties` can be customized via a SpEL expression, which must evaluate to a `Map`.\n\nIf a `ProducerTemplate` is not provided, it is created via a `CamelContext` bean resolved from the application context.\n\n[source, java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"sendToCamel\")\nCamelMessageHandler camelService(ProducerTemplate producerTemplate) {\n CamelHeaderMapper headerMapper = new CamelHeaderMapper();\n headerMapper.setOutboundHeaderNames(\"\");\n headerMapper.setInboundHeaderNames(\"testHeader\");\n\n CamelMessageHandler camelMessageHandler = new CamelMessageHandler(producerTemplate);\n camelMessageHandler.setEndpointUri(\"direct:simple\");\n camelMessageHandler.setExchangePatternExpression(spelExpressionParser.parseExpression(\"headers.exchangePattern\"));\n camelMessageHandler.setHeaderMapper(headerMapper);\n return camelMessageHandler;\n}\n----\n\nFor Java DSL flow definitions this channel adapter can be configured with a few variants provided by the `Camel` factory:\n\n[source, java]\n----\n@Bean\nIntegrationFlow camelFlow() {\n return f -> f\n .handle(Camel.gateway().endpointUri(\"direct:simple\"))\n .handle(Camel.route(this::camelRoute))\n .handle(Camel.handler().endpointUri(\"log:com.mycompany.order?level=WARN\"));\n}\n\nprivate void camelRoute(RouteBuilder routeBuilder) {\n routeBuilder.from(\"direct:inbound\").transform(routeBuilder.simple(\"${body.toUpperCase()}\"));\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/camel.adoc", "title": "camel", "heading": "Outbound Channel Adapter for Apache Camel", "heading_level": 2, "file_order": 165, "section_index": 1, "content_hash": "04b50a009cd883281f542393f8ece6fda28721d126b46b6ea8358d9d3ab87853", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/camel.adoc"}}
{"id": "sha256:6cc4470824cae5eff2323ca4bb516673f7dc99fbcfb66a8ead6df1a195b95078", "content": "[[cassandra]]\n\nSpring Integration provides channel adapters (starting with version 6.0) for performing database operations against an Apache Cassandra cluster.\nIt is fully based on the https://spring.io/projects/spring-data-cassandra[Spring Data for Apache Cassandra] project.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-cassandra</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-cassandra:{project-version}\"\n----\n======\n\n[[cassandra-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cassandra.adoc", "title": "cassandra", "heading": "cassandra", "heading_level": 1, "file_order": 166, "section_index": 0, "content_hash": "6cc4470824cae5eff2323ca4bb516673f7dc99fbcfb66a8ead6df1a195b95078", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cassandra.adoc"}}
{"id": "sha256:76215043dde38b7736cb58961ad8931f25d954386af66cf36ef40d86e7d606a4", "content": "The `CassandraMessageHandler` is an `AbstractReplyProducingMessageHandler` implementation and can work in both one-way (default) and request-reply modes (a `producesReply` option).\nIt is asynchronous by default (`setAsync(false)` to reset) and performs reactive `INSERT`, `UPDATE`, `DELETE` or `STATEMENT` operations against the provided `ReactiveCassandraOperations`.\nThe type of operation can be configured via the `CassandraMessageHandler.Type` option.\nThe `ingestQuery` sets the mode into an `INSERT`; the `query` or `statementExpression`, or `statementProcessor` sets the mode into a `STATEMENT`.\n\nThe following code snippets demonstrate various configurations for this channel adapter or gateway:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\nIntegrationFlow cassandraSelectFlow(ReactiveCassandraOperations cassandraOperations) {\n return flow -> flow\n .handle(Cassandra.outboundGateway(cassandraOperations)\n .query(\"SELECT * FROM book WHERE author = :author limit :size\")\n .parameter(\"author\", \"payload\")\n .parameter(\"size\", m -> m.getHeaders().get(\"limit\")))\n .channel(c -> c.flux(\"resultChannel\"));\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun outboundReactive(cassandraOperations: ReactiveCassandraOperations) =\n integrationFlow {\n handle(\n Cassandra.outboundChannelAdapter(cassandraOperations)\n .statementExpression(\"T(QueryBuilder).truncate('book').build()\")\n ) { async(false) }\n }\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@ServiceActivator(inputChannel = \"cassandraSelectChannel\")\n@Bean\npublic MessageHandler cassandraMessageHandler() {\n CassandraMessageHandler cassandraMessageHandler = new CassandraMessageHandler(this.template);\n cassandraMessageHandler.setQuery(\"SELECT * FROM book WHERE author = :author limit :size\");\n\n Map<String, Expression> params = new HashMap<>();\n params.put(\"author\", PARSER.parseExpression(\"payload\"));\n params.put(\"size\", PARSER.parseExpression(\"headers.limit\"));\n\n cassandraMessageHandler.setParameterExpressions(params);\n\n cassandraMessageHandler.setOutputChannel(resultChannel());\n cassandraMessageHandler.setProducesReply(true);\n return cassandraMessageHandler;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-cassandra:outbound-channel-adapter id=\"outboundAdapter\"\n cassandra-template=\"cassandraTemplate\"\n write-options=\"writeOptions\"\n auto-startup=\"false\"\n async=\"false\"/>\n\n<int-cassandra:outbound-gateway id=\"outgateway\"\n request-channel=\"input\"\n cassandra-template=\"cassandraTemplate\"\n mode=\"STATEMENT\"\n write-options=\"writeOptions\"\n query=\"SELECT * FROM book limit :size\"\n reply-channel=\"resultChannel\"\n auto-startup=\"true\">\n <int-cassandra:parameter-expression name=\"author\" expression=\"payload\"/>\n <int-cassandra:parameter-expression name=\"size\" expression=\"headers.limit\"/>\n</int-cassandra:outbound-gateway>\n----\n======\n\nIf a `CassandraMessageHandler` is used as a gateway in the default async mode, a `Mono<WriteResult>` is produced, which is handled according to the provided `MessageChannel` implementation.\nFor true reactive processing a `FluxMessageChannel` is recommended for the output channel configuration.\nIn sync mode `Mono.block()` is called to obtain the reply value.\n\nIf `INSERT`, `UPDATE` or `DELETE` operations are performed, an entity (marked `org.springframework.data.cassandra.core.mapping.Table`) is expected in the request message payload.\nIf the payload is a list of entities, then the respective batch operation is performed.\n\nThe `ingestQuery` mode expects the payload to be present as a matrix of values to insert - `List<List<?>>`.\nFor example, if the entity is like this:\n\n[source,java]\n----\n@Table(\"book\")\npublic record Book(@PrimaryKey String isbn,\n String title,\n @Indexed String author,\n int pages,\n LocalDate saleDate,\n boolean isInStock) {\n\n}\n----\n\nAnd channel adapter has this configuration:\n\n[source,java]\n----\n@Bean\npublic MessageHandler cassandraMessageHandler3() {\n CassandraMessageHandler cassandraMessageHandler = new CassandraMessageHandler(this.template);\n String cqlIngest = \"insert into book (isbn, title, author, pages, saleDate, isInStock) values (?, ?, ?, ?, ?, ?)\";\n cassandraMessageHandler.setIngestQuery(cqlIngest);\n cassandraMessageHandler.setAsync(false);\n return cassandraMessageHandler;\n}\n----\n\nThe request message payload must be converted like this:\n\n[source,java]\n----\nList<List<Object>> ingestBooks =\n payload.stream()\n .map(book ->\n List.<Object>of(\n book.isbn(),\n book.title(),\n book.author(),\n book.pages(),\n book.saleDate(),\n book.isInStock()))\n .toList();\n----\n\nFor more sophisticated use-cases, the payload can be as an instance of `com.datastax.oss.driver.api.core.cql.Statement`.\nThe `com.datastax.oss.driver.api.querybuilder.QueryBuilder` API is recommended to build various statements to execute against Apache Cassandra.\nFor example, to remove all the data from the `Book` table, a message with a payload like this can be sent to the `CassandraMessageHandler`: `QueryBuilder.truncate(\"book\").build()`.\nAlternatively, for logic based on a request message, a `statementExpression` or `statementProcessor` can be provided for the `CassandraMessageHandler` to build a `Statement` based on that message.\nFor convenience, a `com.datastax.oss.driver.api.querybuilder` is registered as an `import` into a SpEL evaluation context, so a target expression can be as simple as this:\n\n[source,xml]\n----\nstatement-expression=\"T(QueryBuilder).selectFrom(\"book\").all()\"\n----\n\nThe `setParameterExpressions(Map<String, Expression> parameterExpressions)` represents bindable named query parameters and is used only with a `setQuery(String query)` option.\nSee Java and XML samples mentioned above.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cassandra.adoc", "title": "cassandra", "heading": "Cassandra Outbound Components", "heading_level": 2, "file_order": 166, "section_index": 1, "content_hash": "76215043dde38b7736cb58961ad8931f25d954386af66cf36ef40d86e7d606a4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cassandra.adoc"}}
{"id": "sha256:6219870d0e8feca4bf31244177ac0a662c94cee4b1588ac0a20bdf90df0f6e6c", "content": "[[chain]]\n\nThe `MessageHandlerChain` is an implementation of `MessageHandler` that can be configured as a single message endpoint while actually delegating to a chain of other handlers, such as filters, transformers, splitters, and so on.\nWhen several handlers need to be connected in a fixed, linear progression, this can lead to a much simpler configuration.\nFor example, it is fairly common to provide a transformer before other components.\nSimilarly, when you provide a filter before some other component in a chain, you essentially create a https://www.enterpriseintegrationpatterns.com/MessageSelector.html[selective consumer].\nIn either case, the chain requires only a single `input-channel` and a single `output-channel`, eliminating the need to define channels for each individual component.\n\nNOTE: The `MessageHandlerChain` is mostly designed for an XML configuration.\nFor Java DSL, an `IntegrationFlow` definition can be treated as a chain component, but it has nothing to do with concepts and principles described in this chapter below.\nSee xref:dsl.adoc#java-dsl[Java DSL] for more information.\n\nTIP: Spring Integration's `Filter` provides a boolean property: `throwExceptionOnRejection`.\nWhen you provide multiple selective consumers on the same point-to-point channel with different acceptance criteria, you should set this value 'true' (the default is `false`) so that the dispatcher knows that the message was rejected and, as a result, tries to pass the message on to other subscribers.\nIf the exception were not thrown, it would appear to the dispatcher that the message had been passed on successfully even though the filter had dropped the message to prevent further processing.\nIf you do indeed want to \"`drop`\" the messages, the filter's 'discard-channel' might be useful, since it does give you a chance to perform some operation with the dropped message, such as sending it to a JMS queue or writing it to a log.\n\nThe handler chain simplifies configuration while internally maintaining the same degree of loose coupling between components, and it is trivial to modify the configuration if at some point a non-linear arrangement is required.\n\nInternally, the chain is expanded into a linear setup of the listed endpoints, separated by anonymous channels.\nThe reply channel header is not taken into account within the chain.\nOnly after the last handler is invoked is the resulting message forwarded to the reply channel or the chain's output channel.\nBecause of this setup, all handlers except the last must implement the `MessageProducer` interface (which provides a 'setOutputChannel()' method).\nIf the `outputChannel` on the `MessageHandlerChain` is set, the last handler needs only an output channel.\n\nNOTE: As with other endpoints, the `output-channel` is optional.\nIf there is a reply message at the end of the chain, the output-channel takes precedence.\nHowever, if it is not available, the chain handler checks for a reply channel header on the inbound message as a fallback.\n\nIn most cases, you need not implement `MessageHandler` yourself.\nThe next section focuses on namespace support for the chain element.\nMost Spring Integration endpoints, such as service activators and transformers, are suitable for use within a `MessageHandlerChain`.\n\n[[chain-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/chain.adoc", "title": "chain", "heading": "chain", "heading_level": 1, "file_order": 167, "section_index": 0, "content_hash": "6219870d0e8feca4bf31244177ac0a662c94cee4b1588ac0a20bdf90df0f6e6c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/chain.adoc"}}
{"id": "sha256:312d1b1977a95ec8ad4bc299f8d52877c6eb538d4455db54eaaa790c07c6b3c4", "content": "The `<chain>` element provides an `input-channel` attribute.\nIf the last element in the chain is capable of producing reply messages (optional), it also supports an `output-channel` attribute.\nThe sub-elements are then filters, transformers, splitters, and service-activators.\nThe last element may also be a router or an outbound channel adapter.\nThe following example shows a chain definition:\n\n[source,xml]\n----\n<int:chain input-channel=\"input\" output-channel=\"output\">\n <int:filter ref=\"someSelector\" throw-exception-on-rejection=\"true\"/>\n <int:header-enricher>\n <int:header name=\"thing1\" value=\"thing2\"/>\n </int:header-enricher>\n <int:service-activator ref=\"someService\" method=\"someMethod\"/>\n</int:chain>\n----\n\nThe `<header-enricher>` element used in the preceding example sets a message header named `thing1` with a value of `thing2` on the message.\nA header enricher is a specialization of `Transformer` that touches only header values.\nYou could obtain the same result by implementing a `MessageHandler` that did the header modifications and wiring that as a bean, but the header-enricher is a simpler option.\n\nThe `<chain>` can be configured as the last \"`closed-box`\" consumer of the message flow.\nFor this solution, you can put it at the end of the <chain> some <outbound-channel-adapter>, as the following example shows:\n\n[source,xml]\n----\n<int:chain input-channel=\"input\">\n <int-xml:marshalling-transformer marshaller=\"marshaller\" result-type=\"StringResult\" />\n <int:service-activator ref=\"someService\" method=\"someMethod\"/>\n <int:header-enricher>\n <int:header name=\"thing1\" value=\"thing2\"/>\n </int:header-enricher>\n <int:logging-channel-adapter level=\"INFO\" log-full-message=\"true\"/>\n</int:chain>\n----\n\n.Disallowed Attributes and Elements\n[IMPORTANT]\n=====\nCertain attributes, such as `order` and `input-channel` are not allowed to be specified on components used within a chain.\nThe same is true for the poller subelement.\n\nFor the Spring Integration core components, the XML schema itself enforces some of these constraints.\nHowever, for non-core components or your own custom components, these constraints are enforced by the XML namespace parser, not by the XML schema.\n\nThese XML namespace parser constraints were added with Spring Integration 2.2.\nIf you try to use disallowed attributes and elements, the XML namespace parser throws a `BeanDefinitionParsingException`.\n=====\n\n[[using-the-id-attribute]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/chain.adoc", "title": "chain", "heading": "Configuring a Chain", "heading_level": 2, "file_order": 167, "section_index": 1, "content_hash": "312d1b1977a95ec8ad4bc299f8d52877c6eb538d4455db54eaaa790c07c6b3c4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/chain.adoc"}}
{"id": "sha256:b6b10832327426a3692eb5491f41b7d9dd0ff4b8a36d84dfc94fae1429a837c6", "content": "Beginning with Spring Integration 3.0, if a chain element is given an `id` attribute, the bean name for the element is a combination of the chain's `id` and the `id` of the element itself.\nElements without `id` attributes are not registered as beans, but each one is given a `componentName` that includes the chain `id`.\nConsider the following example:\n\n[source,xml]\n----\n<int:chain id=\"somethingChain\" input-channel=\"input\">\n <int:service-activator id=\"somethingService\" ref=\"someService\" method=\"someMethod\"/>\n <int:object-to-json-transformer/>\n</int:chain>\n----\n\nIn the preceding example:\n\n* The `<chain>` root element has an `id` of 'somethingChain'.\nConsequently, the `AbstractEndpoint` implementation (`PollingConsumer` or `EventDrivenConsumer`, depending on the `input-channel` type) bean takes this value as its bean name.\n\n* The `MessageHandlerChain` bean acquires a bean alias (`somethingChain.handler`), which allows direct access to this bean from the `BeanFactory`.\n\n* The `<service-activator>` is not a fully fledged messaging endpoint (it is not a `PollingConsumer` or `EventDrivenConsumer`).\nIt is a `MessageHandler` within the `<chain>`.\nIn this case, the bean name registered with the `BeanFactory` is 'somethingChain$child.somethingService.handler'.\n\n* The `componentName` of this `ServiceActivatingHandler` takes the same value but without the '.handler' suffix.\nIt becomes 'somethingChain$child.somethingService'.\n\n* The last `<chain>` sub-component, `<object-to-json-transformer>`, does not have an `id` attribute.\nIts `componentName` is based on its position in the `<chain>`.\nIn this case, it is 'somethingChain$child#1'.\n(The final element of the name is the order within the chain, beginning with '#0').\nNote, this transformer is not registered as a bean within the application context, so it does not get a `beanName`.\nHowever, its `componentName` has a value that is useful for logging and other purposes.\n\nThe `id` attribute for `<chain>` elements lets them be eligible for xref:jmx.adoc#jmx-mbean-exporter[JMX export], and they are trackable in the xref:message-history.adoc[message history].\nYou can access them from the `BeanFactory` by using the appropriate bean name, as discussed earlier.\n\nTIP: It is useful to provide an explicit `id` attribute on `<chain>` elements to simplify the identification of subcomponents in logs and to provide access to them from the `BeanFactory` etc.\n\n[[chain-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/chain.adoc", "title": "chain", "heading": "Using the 'id' Attribute", "heading_level": 2, "file_order": 167, "section_index": 2, "content_hash": "b6b10832327426a3692eb5491f41b7d9dd0ff4b8a36d84dfc94fae1429a837c6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/chain.adoc"}}
{"id": "sha256:1068979d60fb4693bb7bf941e23e5d527557922c10b414c90c84e518681a4ac1", "content": "Sometimes, you need to make a nested call to another chain from within a chain and then come back and continue execution within the original chain.\nTo accomplish this, you can use a messaging gateway by including a <gateway> element, as the following example shows:\n\n[source,xml]\n----\n<int:chain id=\"main-chain\" input-channel=\"in\" output-channel=\"out\">\n <int:header-enricher>\n <int:header name=\"name\" value=\"Many\" />\n </int:header-enricher>\n <int:service-activator>\n <bean class=\"org.foo.SampleService\" />\n </int:service-activator>\n <int:gateway request-channel=\"inputA\"/>\n</int:chain>\n\n<int:chain id=\"nested-chain-a\" input-channel=\"inputA\">\n <int:header-enricher>\n <int:header name=\"name\" value=\"Moe\" />\n </int:header-enricher>\n <int:gateway request-channel=\"inputB\"/>\n <int:service-activator>\n <bean class=\"org.foo.SampleService\" />\n </int:service-activator>\n</int:chain>\n\n<int:chain id=\"nested-chain-b\" input-channel=\"inputB\">\n <int:header-enricher>\n <int:header name=\"name\" value=\"Jack\" />\n </int:header-enricher>\n <int:service-activator>\n <bean class=\"org.foo.SampleService\" />\n </int:service-activator>\n</int:chain>\n----\n\nIn the preceding example, `nested-chain-a` is called at the end of `main-chain` processing by the 'gateway' element configured there.\nWhile in `nested-chain-a`, a call to a `nested-chain-b` is made after header enrichment.\nThen the flow comes back to finish execution in `nested-chain-b`.\nFinally, the flow returns to `main-chain`.\nWhen the nested version of a `<gateway>` element is defined in the chain, it does not require the `service-interface` attribute.\nInstead, it takes the message in its current state and places it on the channel defined in the `request-channel` attribute.\nWhen the downstream flow initiated by that gateway completes, a `Message` is returned to the gateway and continues its journey within the current chain.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/chain.adoc", "title": "chain", "heading": "Calling a Chain from within a Chain", "heading_level": 2, "file_order": 167, "section_index": 3, "content_hash": "1068979d60fb4693bb7bf941e23e5d527557922c10b414c90c84e518681a4ac1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/chain.adoc"}}
{"id": "sha256:8caef4f1c9cf767aa4f510fcf106ca0a7a29c205e7131ff82ac041ba3187763a", "content": "[[migration-1.0-2.0]]\n\nSee the https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-1.0-to-2.0-Migration-Guide[Migration Guide] for important changes that might affect your applications.\n\n[[migration-spring-30-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "changes-1.0-2.0", "heading_level": 1, "file_order": 168, "section_index": 0, "content_hash": "8caef4f1c9cf767aa4f510fcf106ca0a7a29c205e7131ff82ac041ba3187763a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:8f96b69580d87cc3271ea0ab886385c2decf97d541d394b12a602c4607c98850", "content": "Spring Integration 2.0 is built on top of Spring 3.0.5 and makes many of its features available to our users.\n\n[[2.0-spel-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Spring 3 support", "heading_level": 2, "file_order": 168, "section_index": 1, "content_hash": "8f96b69580d87cc3271ea0ab886385c2decf97d541d394b12a602c4607c98850", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:a4bb01d659368bafad2c9551cad66df2d0c71728487b50f82c7360e7ced37721", "content": "You can now use SpEL expressions within the transformer, router, filter, splitter, aggregator, service-activator, header-enricher, and many more elements of the Spring Integration core namespace as well as within various adapters.\nThis guide includes many samples.\n\n[[conversion-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Support for the Spring Expression Language (SpEL)", "heading_level": 3, "file_order": 168, "section_index": 2, "content_hash": "a4bb01d659368bafad2c9551cad66df2d0c71728487b50f82c7360e7ced37721", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:333379829e4f9336cdb8bfb7efbe27ca2d2d24a3fd302ad480d8b08dd67d0dba", "content": "You can now benefit from the conversion service support provided with Spring while configuring many Spring Integration components, such as a https://www.enterpriseintegrationpatterns.com/DatatypeChannel.html[Datatype channel].\nSee xref:channel/implementations.adoc[Message Channel Implementations] and xref:service-activator.adoc[Service Activator].\nAlso, the SpEL support mentioned in the previous point also relies upon the conversion service.\nTherefore, you can register converters once and take advantage of them anywhere you use SpEL expressions.\n\n[[task-scheduler-poller-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Conversion Service and Converter", "heading_level": 3, "file_order": 168, "section_index": 3, "content_hash": "333379829e4f9336cdb8bfb7efbe27ca2d2d24a3fd302ad480d8b08dd67d0dba", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:9cc1147def31d060c674640d9d0e2f4bcbe4a9295ed28298516043d3043060d1", "content": "Spring 3.0 defines two new strategies related to scheduling: `TaskScheduler` and `Trigger`.\nSpring Integration (which uses a lot of scheduling) now builds upon these.\nIn fact, Spring Integration 1.0 had originally defined some of the components (such as `CronTrigger`) that have now been migrated into Spring 3.0's core API.\nNow you can benefit from reusing the same components within the entire application context (not just Spring Integration configuration).\nWe also greatly simplified configuration of Spring Integration pollers by providing attributes for directly configuring rates, delays, cron expressions, and trigger references.\nSee xref:overview.adoc#overview-endpoints-channeladapter[Channel Adapter] for sample configurations.\n\n[[rest-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "`TaskScheduler` and `Trigger`", "heading_level": 3, "file_order": 168, "section_index": 4, "content_hash": "9cc1147def31d060c674640d9d0e2f4bcbe4a9295ed28298516043d3043060d1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:e3e4eb134aba20e1d7d4c55450202c996bdeff70472526a472ba6d4cac9d42ac", "content": "Our outbound HTTP adapters now delegate to Spring's `RestTemplate` for executing the HTTP request and handling its response.\nThis also means that you can reuse any custom `HttpMessageConverter` implementations.\nSee xref:http/outbound.adoc[HTTP Outbound Components] for more details.\n\n[[new-eip]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "`RestTemplate` and `HttpMessageConverter`", "heading_level": 3, "file_order": 168, "section_index": 5, "content_hash": "e3e4eb134aba20e1d7d4c55450202c996bdeff70472526a472ba6d4cac9d42ac", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:baa2ab103f952778b181ff8826ea1b8a16561d52c2f7a4927831bb04b39430c2", "content": "Also in 2.0, we have added support for even more of the patterns described in Hohpe and Woolf's https://www.enterpriseintegrationpatterns.com/[Enterprise Integration Patterns] book.\n\n[[new-message-history]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Enterprise Integration Pattern Additions", "heading_level": 2, "file_order": 168, "section_index": 6, "content_hash": "baa2ab103f952778b181ff8826ea1b8a16561d52c2f7a4927831bb04b39430c2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:caece94e62065a144d6cb4188cf3a837a463fbc42b72f1de6635b966789642d5", "content": "We now provide support for the https://www.enterpriseintegrationpatterns.com/MessageHistory.html[message history] pattern, letting you keep track of all traversed components, including the name of each channel and endpoint as well as the timestamp of that traversal.\nSee xref:message-history.adoc[Message History] for more details.\n\n[[new-message-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Message History", "heading_level": 3, "file_order": 168, "section_index": 7, "content_hash": "caece94e62065a144d6cb4188cf3a837a463fbc42b72f1de6635b966789642d5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:0bacd652f8486b96a40cee28e789befd7618ab0c3cad2e36859f84d33cd8d56e", "content": "We now provide support for the https://www.enterpriseintegrationpatterns.com/MessageStore.html[message store] pattern.\nThe message store provides a strategy for persisting messages on behalf of any process whose scope extends beyond a single transaction, such as the aggregator and the resequencer.\nMany sections of this guide include samples of how to use a message store, as it affects several areas of Spring Integration.\nSee xref:message-store.adoc[Message Store], xref:claim-check.adoc[Claim Check], xref:channel.adoc[Message Channels], xref:overview.adoc#overview-endpoints-aggregator[Aggregator], xref:jdbc.adoc[JDBC Support]`\", and xref:resequencer.adoc[Resequencer] for more details.\n\n[[new-claim-check]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Message Store", "heading_level": 3, "file_order": 168, "section_index": 8, "content_hash": "0bacd652f8486b96a40cee28e789befd7618ab0c3cad2e36859f84d33cd8d56e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:266afc80b5485193e8ff18b16028926048ff2ed630a02e6901b8e0a8cd53cdb0", "content": "We have added an implementation of the https://www.enterpriseintegrationpatterns.com/StoreInLibrary.html[claim check] pattern.\nThe idea behind the claim check pattern is that you can exchange a message payload for a \"`claim ticket`\".\nThis lets you reduce bandwidth and avoid potential security issues when sending messages across channels.\nSee xref:claim-check.adoc[Claim Check] for more details.\n\n[[new-control-bus]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Claim Check", "heading_level": 3, "file_order": 168, "section_index": 9, "content_hash": "266afc80b5485193e8ff18b16028926048ff2ed630a02e6901b8e0a8cd53cdb0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:de192e64bc948274b204cdf04e6fa5bc8812847d6a2c20d414064409676c542c", "content": "We have provided implementations of the https://www.enterpriseintegrationpatterns.com/ControlBus.html[control bus] pattern, which lets you use messaging to manage and monitor endpoints and channels.\nThe implementations include both a SpEL-based approach and one that runs Groovy scripts.\nSee xref:control-bus.adoc[Control Bus] for more details.\n\n[[new-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Control Bus", "heading_level": 3, "file_order": 168, "section_index": 10, "content_hash": "de192e64bc948274b204cdf04e6fa5bc8812847d6a2c20d414064409676c542c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:b8b715bdb8d56449476caad7bcd2f38f05d20f77364258420138869e765a2c27", "content": "We have added several new channel adapters and messaging gateways in Spring Integration 2.0.\n\n[[new-ip]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "New Channel Adapters and Gateways", "heading_level": 2, "file_order": 168, "section_index": 11, "content_hash": "b8b715bdb8d56449476caad7bcd2f38f05d20f77364258420138869e765a2c27", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:ff360fdb3a1a67be6927c7a9c3dbe1f4a2e6e7c4f3af21d7d184947601584f8a", "content": "We have added channel adapters for receiving and sending messages over the TCP and UDP internet protocols.\nSee xref:ip.adoc[TCP and UDP Support] for more details.\nSee also the following blog: https://spring.io/blog/2010/03/29/using-udp-and-tcp-adapters-in-spring-integration-2-0-m3/[\"`Using UDP and TCP Adapters in Spring Integration 2.0 M3`\"].\n\n[[new-twitter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "TCP and UDP Adapters", "heading_level": 3, "file_order": 168, "section_index": 12, "content_hash": "ff360fdb3a1a67be6927c7a9c3dbe1f4a2e6e7c4f3af21d7d184947601584f8a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:1af80905b1d68d349d30d7c7bb67e58cd61ffcfd49d31d55baa12f8bce7339b4", "content": "Twitter adapters provides support for sending and receiving Twitter status updates as well as direct messages.\nYou can also perform Twitter Searches with an inbound channel adapter.\nSee https://github.com/spring-projects/spring-integration-extensions/tree/main/spring-integration-social-twitter[Spring Integration Social Twitter] for more details.\n\n[[new-xmpp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Twitter Adapters", "heading_level": 3, "file_order": 168, "section_index": 13, "content_hash": "1af80905b1d68d349d30d7c7bb67e58cd61ffcfd49d31d55baa12f8bce7339b4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:53a18866301ceaf267071ad23007502024f55973781cf3973247dfafac75c810", "content": "The new XMPP adapters support both chat messages and presence events.\nSee xref:xmpp.adoc[XMPP Support] for more details.\n\n[[new-ftp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "XMPP Adapters", "heading_level": 3, "file_order": 168, "section_index": 14, "content_hash": "53a18866301ceaf267071ad23007502024f55973781cf3973247dfafac75c810", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:102632ae1f2cf430c48aaa6a4f33c0de69beefc0dbc6b6baa4ce5d225ed1c2d6", "content": "Inbound and outbound file transfer support over FTP and FTPS is now available.\nSee xref:ftp.adoc[FTP/FTPS Adapters] for more details.\n\n[[new-sftp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "FTP and FTPS Adapters", "heading_level": 3, "file_order": 168, "section_index": 15, "content_hash": "102632ae1f2cf430c48aaa6a4f33c0de69beefc0dbc6b6baa4ce5d225ed1c2d6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:35aeb7084ca231bcf1f91f54a27694807dab3f9f84102ecc687d40fa73de4c23", "content": "Inbound and outbound file transfer support over SFTP is now available.\nSee xref:sftp.adoc[SFTP Adapters] for more details.\n\n[[new-feed]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "SFTP Adapters", "heading_level": 3, "file_order": 168, "section_index": 16, "content_hash": "35aeb7084ca231bcf1f91f54a27694807dab3f9f84102ecc687d40fa73de4c23", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:3ffbc60674d5df6f6a68964459f0398cbd6bd02cebf50a8d8f908b85144ed853", "content": "We have also added channel adapters for receiving news feeds (ATOM and RSS).\nSee xref:feed.adoc[Feed Adapter] for more details.\n\n[[new-other]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Feed Adapters", "heading_level": 3, "file_order": 168, "section_index": 17, "content_hash": "3ffbc60674d5df6f6a68964459f0398cbd6bd02cebf50a8d8f908b85144ed853", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:97b362f1da3f7cea9cca0f92c3772108dc3d3384b88ecc104d8e79063b45f74d", "content": "Spring Integration adds a number of other features.\nThis section describes them.\n\n[[new-groovy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Other Additions", "heading_level": 2, "file_order": 168, "section_index": 18, "content_hash": "97b362f1da3f7cea9cca0f92c3772108dc3d3384b88ecc104d8e79063b45f74d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:68fd59dcceff5a50226a59cb4afca87e7604870560421dab3fc0fa286bb71968", "content": "Spring Integration 2.0 added Groovy support, letting you use the Groovy scripting language to provide integration and business logic.\nSee xref:groovy.adoc[Groovy support] for more details.\n\n[[new-map-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Groovy Support", "heading_level": 3, "file_order": 168, "section_index": 19, "content_hash": "68fd59dcceff5a50226a59cb4afca87e7604870560421dab3fc0fa286bb71968", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:20bee8bccde826c902b356bebbfb9b628c6659bedf5c24851e6587806db99ac1", "content": "These symmetrical transformers convert payload objects to and from `Map` objects.\nSee xref:transformer.adoc[Transformer] for more details.\n\n[[new-json-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Map Transformers", "heading_level": 3, "file_order": 168, "section_index": 20, "content_hash": "20bee8bccde826c902b356bebbfb9b628c6659bedf5c24851e6587806db99ac1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:3597d5f8e7230352532348f9c44d972ec88a740852932999ea2ba5b13e10b7a4", "content": "These symmetrical transformers convert payload objects to and from JSON.\nSee xref:transformer.adoc[Transformer] for more details.\n\n[[new-serialize-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "JSON Transformers", "heading_level": 3, "file_order": 168, "section_index": 21, "content_hash": "3597d5f8e7230352532348f9c44d972ec88a740852932999ea2ba5b13e10b7a4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:12025a4c91c44415cd386ed268ee7615189aabc150c7d6e92f335ced8bd9f6cd", "content": "These symmetrical transformers convert payload objects to and from byte arrays.\nThey also support the serializer and deserializer strategy interfaces that Spring 3.0.5 added.\nSee xref:transformer.adoc[Transformer] for more details.\n\n[[new-refactoring]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Serialization Transformers", "heading_level": 3, "file_order": 168, "section_index": 22, "content_hash": "12025a4c91c44415cd386ed268ee7615189aabc150c7d6e92f335ced8bd9f6cd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:d4c9a44974176dcd33256f57398caea00466f767b05a28ce3935d5419a52f7d6", "content": "The core API went through some significant refactoring to make it simpler and more usable.\nAlthough we anticipate that the impact to developers should be minimal, you should read through this document to find what was changed.\nSpecifically, you should read xref:router/dynamic-routers.adoc[Dynamic Routers], xref:gateway.adoc[Messaging Gateways], xref:http/outbound.adoc[HTTP Outbound Components], xref:overview.adoc#overview-components-message[Message], and xref:overview.adoc#overview-endpoints-aggregator[Aggregator].\nIf you directly depend on some of the core components (`Message`, `MessageHeaders`, `MessageChannel`, `MessageBuilder`, and others), you need to update any import statements.\nWe restructured some packaging to provide the flexibility we needed for extending the domain model while avoiding any cyclical dependencies (it is a policy of the framework to avoid such \"`tangles`\").\n\n[[new-infrastructure]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Framework Refactoring", "heading_level": 2, "file_order": 168, "section_index": 23, "content_hash": "d4c9a44974176dcd33256f57398caea00466f767b05a28ce3935d5419a52f7d6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:1ccb5ca62a6f3601457ab30c78119fb0e42649f30f220704075605cab4eb65ad", "content": "With Spring Integration 2.0, we switched our build environment to use Git for source control.\nTo access our repository, visit https://git.springsource.org/spring-integration.\nWe have also switched our build system to https://gradle.org/[Gradle].\n\n[[new-samples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "New Source Control Management and Build Infrastructure", "heading_level": 2, "file_order": 168, "section_index": 24, "content_hash": "1ccb5ca62a6f3601457ab30c78119fb0e42649f30f220704075605cab4eb65ad", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:fd20348508ce6079d758e5b0fef06503b306239eca4b30c9ebb2b97da4870dc2", "content": "With Spring Integration 2.0, we have decoupled the samples from our main release distribution.\nPlease read the following blog to get more information: https://spring.io/blog/2010/09/29/new-spring-integration-samples/[New Spring Integration Samples].\nWe have also created many new samples, including samples for every new adapter.\n\n[[new-sts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "New Spring Integration Samples", "heading_level": 2, "file_order": 168, "section_index": 25, "content_hash": "fd20348508ce6079d758e5b0fef06503b306239eca4b30c9ebb2b97da4870dc2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:19bc1946889484c67496ad8b34103cdfd2ca0e919fd7a25b9e6d1b55b6c1141a", "content": "There is an amazing new visual editor for Spring Integration included within the latest version of SpringSource Tool Suite.\nIf you are not already using STS, you can download it at https://spring.io/tools/sts[Spring Tool Suite].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-1.0-2.0.adoc", "title": "changes-1.0-2.0", "heading": "Spring Tool Suite Visual Editor for Spring Integration", "heading_level": 2, "file_order": 168, "section_index": 26, "content_hash": "19bc1946889484c67496ad8b34103cdfd2ca0e919fd7a25b9e6d1b55b6c1141a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-1.0-2.0.adoc"}}
{"id": "sha256:39ef272b697f599e1b48636ee35b14f998212360df882648e00f182ac4f6e36d", "content": "[[migration-2.0-2.1]]\n\nSee the https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-2.0-to-2.1-Migration-Guide[Migration Guide] for important changes that might affect your applications.\n\n[[x2.1-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "changes-2.0-2.1", "heading_level": 1, "file_order": 169, "section_index": 0, "content_hash": "39ef272b697f599e1b48636ee35b14f998212360df882648e00f182ac4f6e36d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:e070fc4593dbc1ecb4d82b155bc721b46d847e013ba704e7fa0b19e05fca4487", "content": "Version 2.1 added a number of new components.\n\n[[x2.1-new-scripting-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "New Components", "heading_level": 2, "file_order": 169, "section_index": 1, "content_hash": "e070fc4593dbc1ecb4d82b155bc721b46d847e013ba704e7fa0b19e05fca4487", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:5d73755d52dd93e4b6c875b5dd478e6e34062a592fc77aaf86c5d04e09588a86", "content": "In Spring Integration 2.0, we added support for https://groovy.codehaus.org/[Groovy].\nWith Spring Integration 2.1, we expanded support for additional languages substantially by implementing support for https://www.jcp.org/en/jsr/detail?id=223[JSR-223] (\"`Scripting for the Java Platform`\").\nNow you have the ability to use any scripting language that supports JSR-223 including:\n\n* Javascript\n* Ruby and JRuby\n* Python and Jython\n* Groovy\n\nFor further details, see xref:scripting.adoc[Scripting Support].\n\n[[x2.1-new-amqp-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "JSR-223 Scripting Support", "heading_level": 3, "file_order": 169, "section_index": 2, "content_hash": "5d73755d52dd93e4b6c875b5dd478e6e34062a592fc77aaf86c5d04e09588a86", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:536d55984ec30e4c5b199265d70239a8af86a5ede644514c78662ed9136c0f19", "content": "Spring Integration 2.1 added several channel adapters for receiving and sending messages by using the https://www.amqp.org/[Advanced Message Queuing Protocol] (AMQP).\nFurthermore, Spring Integration also provides a point-to-point message channel and a publish-subscribe message channel, both of which are backed by AMQP Exchanges and Queues.\n\nFor further details, see xref:amqp.adoc[AMQP Support].\n\n[[x2.1-new-mongodb-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "AMQP Support", "heading_level": 3, "file_order": 169, "section_index": 3, "content_hash": "536d55984ec30e4c5b199265d70239a8af86a5ede644514c78662ed9136c0f19", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:d6cde1a1450e49e5f5c4ff607ac2a9c88a9ea8ef97ec1df6bcf4f3f6f0b4c3c7", "content": "As of version 2.1, Spring Integration provides support for https://www.mongodb.org/[MongoDB] by providing a MongoDB-based `MessageStore`.\n\nFor further details, see xref:mongodb.adoc[MongoDb Support].\n\n[[x2.1-new-redis-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "MongoDB Support", "heading_level": 3, "file_order": 169, "section_index": 4, "content_hash": "d6cde1a1450e49e5f5c4ff607ac2a9c88a9ea8ef97ec1df6bcf4f3f6f0b4c3c7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:839ec6267fd148c10824e8939a7f33631394052cb3b74453ae1981bc233bc248", "content": "As of version 2.1, Spring Integration supports https://redis.io/[Redis], an advanced key-value store, by providing a Redis-based `MessageStore` as well as publish-subscribe messaging adapters.\n\nFor further details, see xref:redis.adoc[Redis Support].\n\n[[x2.1-new-resource-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "Redis Support", "heading_level": 3, "file_order": 169, "section_index": 5, "content_hash": "839ec6267fd148c10824e8939a7f33631394052cb3b74453ae1981bc233bc248", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:de4cdb7de365cb00e4096b69c5e40fd48c11ce27c3cc580656d93e462ed5c574", "content": "In version 2.1, we introduced a new resource inbound channel adapter that builds upon Spring's resource abstraction to support greater flexibility across a variety of actual types of underlying resources, such as a file, a URL, or a classpath resource.\nTherefore, it is similar to but more generic than the file inbound channel adapter.\n\nFor further details, see xref:resource.adoc#resource-inbound-channel-adapter[Resource Inbound Channel Adapter].\n\n[[x2.1-new-stored-proc-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "Support for Spring's Resource abstraction", "heading_level": 3, "file_order": 169, "section_index": 6, "content_hash": "de4cdb7de365cb00e4096b69c5e40fd48c11ce27c3cc580656d93e462ed5c574", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:bcc757f3f3c9858ab5544cf99d862c0ec666f351dabc6799fd4edc60334246b2", "content": "With Spring Integration 2.1, the `JDBC` Module also provides stored procedure support by adding several new components, including inbound and outbound channel adapters and an outbound gateway.\nThe stored procedure support leverages Spring's https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/simple/SimpleJdbcCall.html[`SimpleJdbcCall`] class and consequently supports stored procedures for:\n\n* Apache Derby\n* DB2\n* MySQL\n* Microsoft SQL Server\n* Oracle\n* PostgreSQL\n* Sybase\n\nThe stored procedure components also support SQL functions for the following databases:\n\n* MySQL\n* Microsoft SQL Server\n* Oracle\n* PostgreSQL\n\nFor further details, see xref:jdbc/stored-procedures.adoc[Stored Procedures].\n\n[[x2.1-new-xpath-filter-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "Stored Procedure Components", "heading_level": 3, "file_order": 169, "section_index": 7, "content_hash": "bcc757f3f3c9858ab5544cf99d862c0ec666f351dabc6799fd4edc60334246b2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:f80dcab12161c25f9e0a98b120a80b2274da3d49d780ff796348e4cc4b68011a", "content": "Spring Integration 2.1 provides a new XPath-based message filter.\nIt is part of the `XML` module.\nThe XPath filter lets you filter messages by using XPath Expressions.\nWe also added documentation for the XML validating filter.\n\nFor more details, see xref:xml/xpath-filter.adoc[Using the XPath Filter] and xref:xml/validating-filter.adoc[XML Validating Filter].\n\n[[x2.1-new-payload-enricher-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "XPath and XML Validating Filter", "heading_level": 3, "file_order": 169, "section_index": 8, "content_hash": "f80dcab12161c25f9e0a98b120a80b2274da3d49d780ff796348e4cc4b68011a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:72a1eace0f3e70f5eaccc14dfbe08fb7b8437843d1d1199f0866fc196852bb13", "content": "Since Spring Integration 2.1, we added the payload enricher.\nA payload enricher defines an endpoint that typically passes a https://docs.spring.io/spring-integration/api/org/springframework/integration/Message.html[`Message`] to the exposed request channel and then expects a reply message.\nThe reply message then becomes the root object for evaluation of expressions to enrich the target payload.\n\nFor further details, see xref:content-enrichment.adoc#payload-enricher[Payload Enricher].\n\n[[x2.1-new-ftp-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "Payload Enricher", "heading_level": 3, "file_order": 169, "section_index": 9, "content_hash": "72a1eace0f3e70f5eaccc14dfbe08fb7b8437843d1d1199f0866fc196852bb13", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:ef46d89071ac94fc588da14a177de95cacc8b4884170c302f1164c6bea510459", "content": "Spring Integration 2.1 provides two new outbound gateways to interact with remote File Transfer Protocol (FTP) or Secure File Transfer Protocol (SFT) servers.\nThese two gateways let you directly execute a limited set of remote commands.\n\nFor instance, you can use these outbound gateways to list, retrieve, and delete remote files and have the Spring Integration message flow continue with the remote server's response.\n\nFor further details, see xref:ftp/outbound-gateway.adoc[FTP Outbound Gateway] and xref:sftp/outbound-gateway.adoc[SFTP Outbound Gateway].\n\n[[x2.1-new-ftp-session-caching]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "FTP and SFTP Outbound Gateways", "heading_level": 3, "file_order": 169, "section_index": 10, "content_hash": "ef46d89071ac94fc588da14a177de95cacc8b4884170c302f1164c6bea510459", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:b4c28b1df0edc1a8f1ef2add1a29dac2522ec20abbf4d576012bbc06e7379716", "content": "As of version 2.1, we have exposed more flexibility with regards to session management for remote file adapters (for example, FTP, SFTP, and others).\n\nSpecifically, we deprecated the `cache-sessions` attribute (which is available via the XML namespace support).\nAs an alternative, we added the `sessionCacheSize` and `sessionWaitTimeout` attributes on the `CachingSessionFactory`.\n\nFor further details, see xref:ftp/session-caching.adoc[FTP Session Caching] and xref:sftp/session-caching.adoc[SFTP Session Caching].\n\n[[x2.1-framework-refactorings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "FTP Session Caching", "heading_level": 3, "file_order": 169, "section_index": 11, "content_hash": "b4c28b1df0edc1a8f1ef2add1a29dac2522ec20abbf4d576012bbc06e7379716", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:745390e63e73ad633fc285b7f7f067f537b8127c5cf5b9e2a88355c0909a3ad8", "content": "We refactored the Spring Integration framework in a number of ways, all described in this section.\n\n[[x2.1-router-standardization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "Framework Refactoring", "heading_level": 2, "file_order": 169, "section_index": 12, "content_hash": "745390e63e73ad633fc285b7f7f067f537b8127c5cf5b9e2a88355c0909a3ad8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:0a5dc3195d533bd66a3104fe03b9a6c425ffe3a48d63b2383e473b8ffdf31909", "content": "We standardized router parameters across all router implementations with Spring Integration 2.1 to provide a more consistent user experience.\n\nIn Spring Integration 2.1, we removed the `ignore-channel-name-resolution-failures` attribute in favor of consolidating its behavior with the `resolution-required` attribute.\nAlso, the `resolution-required` attribute now defaults to `true`.\n\nStarting with Spring Integration 2.1, routers no longer silently drop any messages if no default output channel was defined.\nThis means that, by default, routers now require at least one resolved channel (if no `default-output-channel` was set) and, by default, throw a `MessageDeliveryException` if no channel was determined (or an attempt to send was not successful).\n\nIf, however, you do want to drop messages silently, you can set `default-output-channel=\"nullChannel\"`.\n\nIMPORTANT: With the standardization of router parameters and the consolidation of the parameters described earlier, older Spring Integration based applications may break.\n\nFor further details, see `xref:router.adoc[Routers]`.\n\n[[x2.1-schema-updated]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "Standardizing Router Configuration", "heading_level": 3, "file_order": 169, "section_index": 13, "content_hash": "0a5dc3195d533bd66a3104fe03b9a6c425ffe3a48d63b2383e473b8ffdf31909", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:bdfcd07cba7d211f7cb5d627cf1a87a22001f8e00f93ee88fd797c6b927d872e", "content": "Spring Integration 2.1 ships with an updated XML Schema (version 2.1).\nIt provides many improvements, such as the Router standardizations xref:changes-2.0-2.1.adoc#x2.1-router-standardization[discussed earlier].\n\nFrom now on, developers must always declare the latest XML schema (currently version 2.1).\nAlternatively, they can use the version-less schema.\nGenerally, the best option is to use version-less namespaces, as these automatically use the latest available version of Spring Integration.\n\nThe following example declares a version-less Spring Integration namespace:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int=\"http://www.springframework.org/schema/integration\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration.xsd\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n...\n</beans>\n----\n\nThe following example declares a Spring Integration namespace with an explicit version:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int=\"http://www.springframework.org/schema/integration\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration-2.2.xsd\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n...\n</beans>\n----\n\nThe old 1.0 and 2.0 schemas are still there.\nHowever, if an application context still references one of those deprecated schemas, the validator fails on initialization.\n\n[[x2.1-source-control-infrastructure]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "XML Schemas updated to 2.1", "heading_level": 3, "file_order": 169, "section_index": 14, "content_hash": "bdfcd07cba7d211f7cb5d627cf1a87a22001f8e00f93ee88fd797c6b927d872e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:95f32c8c65012e5f546ea581ad7d5769f6fa6dde0890db53fd354a778352c1eb", "content": "Version 2.1 introduced a number of changes to source control management and build infrastructure.\nThis section covers those changes.\n\n[[x2.1-move-to-github]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "Source Control Management and Build Infrastructure", "heading_level": 2, "file_order": 169, "section_index": 15, "content_hash": "95f32c8c65012e5f546ea581ad7d5769f6fa6dde0890db53fd354a778352c1eb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:b48b468781d6898c720e4b1190f785262af061e3fab6e25bd1bde04124efcc6f", "content": "Since version 2.0, the Spring Integration project uses https://git-scm.com/[Git] for version control.\nTo increase community visibility even further, the project was moved from SpringSource hosted Git repositories to https://www.github.com/[Github].\nThe Spring Integration Git repository is located at: https://github.com/spring-projects/spring-integration[spring-integration].\n\nFor the project, we also improved the process of providing code contributions.\nFurther, we ensure that every commit is peer-reviewed.\nIn fact, core committers now follow the same process as contributors.\nFor more details, see https://github.com/spring-projects/spring-integration/blob/main/CONTRIBUTING.adoc[Contributing].\n\n[[x2.1-sonar]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "Source Code Now Hosted on Github", "heading_level": 3, "file_order": 169, "section_index": 16, "content_hash": "b48b468781d6898c720e4b1190f785262af061e3fab6e25bd1bde04124efcc6f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:4080ccf9464e601760ef650eca129c956e111067cc5d423f02f1920a11a91531", "content": "In an effort to provide better source code visibility and consequently to monitor the quality of Spring Integration's source code, we set up an instance of https://www.sonarqube.org/[Sonar].\nWe gather metrics nightly and make them available at https://sonar.spring.io/dashboard?id=org.springframework.integration%3Aspring-integration%3Amain[sonar.spring.io].\n\n[[x2.1-new-samples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "Improved Source Code Visibility with Sonar", "heading_level": 3, "file_order": 169, "section_index": 17, "content_hash": "4080ccf9464e601760ef650eca129c956e111067cc5d423f02f1920a11a91531", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:622cfc954b400dca772da43658e09e2b4546e231a6a2071519fc9d0459b7838b", "content": "For the 2.1 release of Spring Integration, we also expanded the Spring Integration Samples project and added many new samples, such as samples that cover AMQP support, a sample that showcases the new payload enricher, a sample illustrating techniques for testing Spring Integration flow fragments, and a sample for executing stored procedures against Oracle databases.\nFor details, visit https://github.com/spring-projects/spring-integration-samples[spring-integration-samples].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.0-2.1.adoc", "title": "changes-2.0-2.1", "heading": "New Samples", "heading_level": 2, "file_order": 169, "section_index": 18, "content_hash": "622cfc954b400dca772da43658e09e2b4546e231a6a2071519fc9d0459b7838b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.0-2.1.adoc"}}
{"id": "sha256:96fd08e88629251254ed285e5af69c29f5f8b7f697f38ff1e2582b982f10b0ec", "content": "[[migration-2.1-2.2]]\n\nSee the https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-2.1-to-2.2-Migration-Guide[Migration Guide] for important changes that might affect your applications.\nYou can find migration guides for all versions back to 2.1 on the https://github.com/spring-projects/spring-integration/wiki[wiki].\n\n[[x2.2-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "changes-2.1-2.2", "heading_level": 1, "file_order": 170, "section_index": 0, "content_hash": "96fd08e88629251254ed285e5af69c29f5f8b7f697f38ff1e2582b982f10b0ec", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:fd8a09ad954c7e10dd3a204e95c42207c769babb4c13bd366365f16ce45944e3", "content": "Version 2.2 added a number of new components.\n\n[[x2.2-redis-store-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "New Components", "heading_level": 2, "file_order": 170, "section_index": 1, "content_hash": "fd8a09ad954c7e10dd3a204e95c42207c769babb4c13bd366365f16ce45944e3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:05f19a4fc6defbeed2c5408a639cb5898e729fe19355dc45ca17ac1b2252d18d", "content": "Spring Integration now has `RedisStore` Inbound and Outbound Channel Adapters, letting you write and read `Message` payloads to and from Redis collections.\nFor more information, see xref:redis.adoc#redis-store-outbound-channel-adapter[RedisStore Outbound Channel Adapter] and xref:redis.adoc#redis-store-inbound-channel-adapter[Redis Store Inbound Channel Adapter].\n\n[[x2.2-mongo-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "`RedisStore` Inbound and Outbound Channel Adapters", "heading_level": 3, "file_order": 170, "section_index": 2, "content_hash": "05f19a4fc6defbeed2c5408a639cb5898e729fe19355dc45ca17ac1b2252d18d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:15091dcddc8472b47071d53121634166796315b3bc7488a07a03beecb351dcb9", "content": "Spring Integration now has MongoDB inbound and outbound channel adapters, letting you write and read `Message` payloads to and from a MongoDB document store.\nFor more information, see xref:mongodb.adoc#mongodb-outbound-channel-adapter[MongoDB Outbound Channel Adapter] and xref:mongodb.adoc#mongodb-inbound-channel-adapter[MongoDB Inbound Channel Adapter].\n\n[[x2.2-jpa]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "MongoDB Inbound and Outbound Channel Adapters", "heading_level": 3, "file_order": 170, "section_index": 3, "content_hash": "15091dcddc8472b47071d53121634166796315b3bc7488a07a03beecb351dcb9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:eaf6f211f6526dff708e670573be120f5b711ae31189b2aa4f5b78840c49ede3", "content": "Spring Integration now includes components for the Java Persistence API (JPA) for retrieving and persisting JPA entity objects.\nThe JPA Adapter includes the following components:\n\n* xref:jpa/inbound-channel-adapter.adoc[Inbound channel adapter]\n* xref:jpa/outbound-channel-adapter.adoc[Outbound channel adapter]\n* xref:jpa/outbound-gateways.adoc#jpa-updating-outbound-gateway[Updating outbound gateway]\n* xref:jpa/outbound-gateways.adoc#jpa-retrieving-outbound-gateway[Retrieving outbound gateway]\n\nFor more information, see xref:jpa.adoc[JPA Support].\n\n[[x2.2-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "JPA Endpoints", "heading_level": 3, "file_order": 170, "section_index": 4, "content_hash": "eaf6f211f6526dff708e670573be120f5b711ae31189b2aa4f5b78840c49ede3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:7ee4a42ab3bb6625d708c445117ceac56b852e9405fa758d979e4abbc56c7cbc", "content": "This section describes general changes from version 2.1 to version 2.2.\n\n[[x2.2-spring-31]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "General Changes", "heading_level": 2, "file_order": 170, "section_index": 5, "content_hash": "7ee4a42ab3bb6625d708c445117ceac56b852e9405fa758d979e4abbc56c7cbc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:d9a8b60df518dd99150615300caf0610dd096a031a2fc0b2b9936c8a190ca9fe", "content": "Spring Integration now uses Spring 3.1.\n\n[[x2.2-handler-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "Spring 3.1 Used by Default", "heading_level": 3, "file_order": 170, "section_index": 6, "content_hash": "d9a8b60df518dd99150615300caf0610dd096a031a2fc0b2b9936c8a190ca9fe", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:881cdcf863e419d86a6905e16ed45970dcc64664e1f0a972c89b72f1f6bee86c", "content": "The ability to add an `<advice-chain/>` to a poller has been available for some time.\nHowever, the behavior added by this affects the entire integration flow.\nIt did not address the ability to add (for example) retry to an individual endpoint.\nThe 2.2 release introduced the `<request-handler-advice-chain/>` to many endpoints.\n\nIn addition, we added three standard advice classes for this purpose:\n\n* `MessageHandlerRetryAdvice`\n* `MessageHandlerCircuitBreakerAdvice`\n* `ExpressionEvaluatingMessageHandlerAdvice`\n\nFor more information, see xref:handler-advice.adoc[Adding Behavior to Endpoints].\n\n[[x2.2-transaction-sync]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "Adding Behavior to Endpoints", "heading_level": 3, "file_order": 170, "section_index": 7, "content_hash": "881cdcf863e419d86a6905e16ed45970dcc64664e1f0a972c89b72f1f6bee86c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:ae1381111ebe00a0a249aacfc55e2655de2b56fed572709014af263c569caa3f", "content": "Pollers can now participate in Spring's Transaction Synchronization feature.\nThis allows for synchronizing such operations as renaming files by an inbound channel adapter, depending on whether the transaction commits or rolls back.\n\nIn addition, you can enable these features when no \"`real`\" transaction is present, by means of a `PseudoTransactionManager`.\n\nFor more information, see xref:transactions.adoc#transaction-synchronization[Transaction Synchronization].\n\n[[x2.2-file-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "Transaction Synchronization and Pseudo Transactions", "heading_level": 3, "file_order": 170, "section_index": 8, "content_hash": "ae1381111ebe00a0a249aacfc55e2655de2b56fed572709014af263c569caa3f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:38c275e73219b4746b70dc214566770fe564d6ad516e4322c222e0d61f562470", "content": "When using the file outbound channel adapter or the file outbound gateway, you can use a new `mode` property.\nPrior to Spring Integration 2.2, target files were replaced when they existed.\nNow you can specify the following options:\n\n* `REPLACE` (default)\n* `APPEND`\n* `FAIL`\n* `IGNORE`\n\nFor more information, see xref:file/writing.adoc#file-writing-destination-exists[Dealing with Existing Destination Files].\n\n[[x2.2-outbound-gateways]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "File Adapter: Improved File Overwrite and Append Handling", "heading_level": 3, "file_order": 170, "section_index": 9, "content_hash": "38c275e73219b4746b70dc214566770fe564d6ad516e4322c222e0d61f562470", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:e425fad5496b92292ea6e5bd5c2bfc82ff04981f81c0667a79382bda0fec8fc4", "content": "The XML Namespace support adds the reply-timeout attribute to the following outbound gateways:\n\n* AMQP Outbound Gateway\n* File Outbound Gateway\n* FTP Outbound Gateway\n* SFTP Outbound Gateway\n* WS Outbound Gateway\n\n[[x2.2-amqp-11]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "Reply-Timeout Added to More Outbound Gateways", "heading_level": 3, "file_order": 170, "section_index": 10, "content_hash": "e425fad5496b92292ea6e5bd5c2bfc82ff04981f81c0667a79382bda0fec8fc4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:6b9c341e98cf6e6156b84e3faa441fa5810b01219b22a39d7bd30d67cad7ed52", "content": "Spring Integration now uses Spring AMQP 1.1.\nThis enables several features to be used within a Spring Integration application, including the following:\n\n* A fixed reply queue for the outbound gateway\n* HA (mirrored) queues\n* Publisher confirmations\n* Returned messages\n* Support for dead letter exchanges and dead letter queues\n\n[[x2.2-jdbc-11]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "Spring-AMQP 1.1", "heading_level": 3, "file_order": 170, "section_index": 11, "content_hash": "6b9c341e98cf6e6156b84e3faa441fa5810b01219b22a39d7bd30d67cad7ed52", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:9097f1faccff9243a2a630ced350fd36e635d841f874d992afe4ea7cb8de3eab", "content": "[[spel-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "JDBC Support - Stored Procedures Components", "heading_level": 3, "file_order": 170, "section_index": 12, "content_hash": "9097f1faccff9243a2a630ced350fd36e635d841f874d992afe4ea7cb8de3eab", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:ef1f854c5513fffa6bf1e4af2f478ddc5c94a03c78571d2b20011a4bd4b95130", "content": "When using the stored procedure components of the Spring Integration JDBC Adapter, you can now provide stored procedure names or stored function names by using the Spring Expression Language (SpEL).\n\nDoing so lets you specify the stored procedures to be invoked at runtime.\nFor example, you can provide stored procedure names that you would like to execute through message headers.\nFor more information, see xref:jdbc/stored-procedures.adoc[Stored Procedures].\n\n[[jmx-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "SpEL Support", "heading_level": 4, "file_order": 170, "section_index": 13, "content_hash": "ef1f854c5513fffa6bf1e4af2f478ddc5c94a03c78571d2b20011a4bd4b95130", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:8f78c1b616909582d1082df0996f3dae070cd610c50d5f9e096ef6d15000efb8", "content": "The stored procedure components now provide basic JMX support, exposing some of their properties as MBeans:\n\n* Stored procedure name\n* Stored procedure name expression\n* `JdbcCallOperations` cache statistics\n\n[[x2.2-jdbc-gateway-update-optional]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "JMX Support", "heading_level": 4, "file_order": 170, "section_index": 14, "content_hash": "8f78c1b616909582d1082df0996f3dae070cd610c50d5f9e096ef6d15000efb8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:ef57c4430d85c9ed2080ec5de14c0e34ddd8294953506a166c1b068c6b68fec0", "content": "When you use the JDBC outbound gateway, the update query is no longer mandatory.\nYou can now provide only a select query by using the request message as a source of parameters.\n\n[[x2.2-jdbc-message-store-channels]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "JDBC Support: Outbound Gateway", "heading_level": 3, "file_order": 170, "section_index": 15, "content_hash": "ef57c4430d85c9ed2080ec5de14c0e34ddd8294953506a166c1b068c6b68fec0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:a762848655f9eec5a01bdb23aaa1df9570155c8ba03066a41496dc8825047d0c", "content": "We added a new message channel-specific message store implementation, providing a more scalable solution using database-specific SQL queries.\nFor more information, see xref:jdbc/message-store.adoc#jdbc-message-store-channels[Backing Message Channels].\n\n[[x2.2-shutdown]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "JDBC Support: Channel-specific Message Store Implementation", "heading_level": 3, "file_order": 170, "section_index": 16, "content_hash": "a762848655f9eec5a01bdb23aaa1df9570155c8ba03066a41496dc8825047d0c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:ba23700439cf36c9475ae66f8b73fb72c3037d4028c467f54d9e37a15fbf6e85", "content": "We added a method called `stopActiveComponents()` to the `IntegrationMBeanExporter`.\nIt allows a Spring Integration application to be shut down in an orderly manner, disallowing new inbound messages to certain adapters and waiting for some time to allow in-flight messages to complete.\n\n[[x2.2-jms-og]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "Orderly Shutdown", "heading_level": 3, "file_order": 170, "section_index": 17, "content_hash": "ba23700439cf36c9475ae66f8b73fb72c3037d4028c467f54d9e37a15fbf6e85", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:3f52a233c36bcc70557467843c66f3d9a2b3fc60f9bff159300f46d325b1c6d8", "content": "You can now configure the JMS outbound gateway to use a `MessageListener` container to receive replies.\nDoing so can improve performance of the gateway.\n\n[[x2.2-o-t-j-t]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "JMS Outbound Gateway Improvements", "heading_level": 3, "file_order": 170, "section_index": 18, "content_hash": "3f52a233c36bcc70557467843c66f3d9a2b3fc60f9bff159300f46d325b1c6d8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:53b374ce8497a99b8ddac8c8ae6df2d03cf155bf33b6318a7b1142f9bfaa00dd", "content": "By default, the `ObjectToJsonTransformer` now sets the `content-type` header to `application/json`.\nFor more information, see xref:transformer.adoc[Transformer].\n\n[[httpChanges]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "`ObjectToJsonTransformer`", "heading_level": 3, "file_order": 170, "section_index": 19, "content_hash": "53b374ce8497a99b8ddac8c8ae6df2d03cf155bf33b6318a7b1142f9bfaa00dd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:a19b62afdda7c57d795c0058ff4811243522fa2bdfacc737a16480df5849a070", "content": "Java serialization over HTTP is no longer enabled by default.\nPreviously, when setting an `expected-response-type` on a `Serializable` object, the `Accept` header was not properly set up.\nWe updated the `SerializingHttpMessageConverter` to set the `Accept` header to `application/x-java-serialized-object`.\nHowever, because this could cause incompatibility with existing applications, we decided to no longer automatically add this converter to the HTTP endpoints.\n\nIf you wish to use Java serialization, you need to add the `SerializingHttpMessageConverter` to the appropriate endpoints by using the `message-converters` attribute (when you use XML configuration) or by using the `setMessageConverters()` method (in Java).\n\nAlternatively, you may wish to consider using JSON instead.\nIt is enabled by having `Jackson` on the classpath.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.1-2.2.adoc", "title": "changes-2.1-2.2", "heading": "HTTP Support", "heading_level": 3, "file_order": 170, "section_index": 20, "content_hash": "a19b62afdda7c57d795c0058ff4811243522fa2bdfacc737a16480df5849a070", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.1-2.2.adoc"}}
{"id": "sha256:fdf51907d450e8dbc62c201d6240057f6ebf699559f2b30505a61d4d95fe3009", "content": "[[migration-2.2-3.0]]\n\nSee the https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-2.2-to-3.0-Migration-Guide[Migration Guide] for important changes that might affect your applications.\nYou can find migration guides for all versions back to 2.1 on the https://github.com/spring-projects/spring-integration/wiki[wiki].\n\n[[x3.0-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "changes-2.2-3.0", "heading_level": 1, "file_order": 171, "section_index": 0, "content_hash": "fdf51907d450e8dbc62c201d6240057f6ebf699559f2b30505a61d4d95fe3009", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:7b866e1b05c5a2e4dae84597141f5024380ecfa45b71b0963a7dc6dd4d78cb11", "content": "Version 3.0 added a number of new components.\n\n[[x3.0-request-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "New Components", "heading_level": 2, "file_order": 171, "section_index": 1, "content_hash": "7b866e1b05c5a2e4dae84597141f5024380ecfa45b71b0963a7dc6dd4d78cb11", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:bb59d72ef65cd8f84df5472b063ddadd9b784b46becb5f3a747c0f56d72a1470", "content": "The HTTP module now provides powerful request mapping support for inbound endpoints.\nWe replaced the `UriPathHandlerMapping` class with `IntegrationRequestMappingHandlerMapping`, which is registered under the bean name of `integrationRequestMappingHandlerMapping` in the application context.\nUpon parsing of the HTTP inbound endpoint, either a new `IntegrationRequestMappingHandlerMapping` bean is registered or an existing bean is reused.\nTo achieve flexible request mapping configuration, Spring Integration provides the `<request-mapping/>` child element for `<http:inbound-channel-adapter/>` and the `<http:inbound-gateway/>`.\nBoth HTTP inbound endpoints are now fully based on the request mapping infrastructure that was introduced with Spring MVC 3.1.\nFor example, multiple paths are supported on a single inbound endpoint.\nFor more information see xref:http/namespace.adoc[HTTP Namespace Support].\n\n[[x3.0-spel-customization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "HTTP Request Mapping", "heading_level": 3, "file_order": 171, "section_index": 2, "content_hash": "bb59d72ef65cd8f84df5472b063ddadd9b784b46becb5f3a747c0f56d72a1470", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:a1c44844a6b660c3f7071733025e9763b58b617b848ffb222ca43cfdb086254d", "content": "We added a new `IntegrationEvaluationContextFactoryBean` to allow configuration of custom `PropertyAccessor` implementations and functions for use in SpEL expressions throughout the framework.\nFor more information, see xref:spel.adoc[Spring Expression Language (SpEL)].\n\n[[x3.0-spel-functions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Spring Expression Language (SpEL) Configuration", "heading_level": 3, "file_order": 171, "section_index": 3, "content_hash": "a1c44844a6b660c3f7071733025e9763b58b617b848ffb222ca43cfdb086254d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:584bfb07c191c3d502bd4f29fb171e286b75dbcb4ffad88296b0b540070d9f73", "content": "To customize the SpEL `EvaluationContext` with static `Method` functions, we introduced the `<spel-function/>` component.\nWe also added two built-in functions: `#jsonPath` and `#xpath`.\nFor more information, see xref:spel.adoc#spel-functions[SpEL Functions].\n\n[[x3.0-spel-property-accessors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "SpEL Functions Support", "heading_level": 3, "file_order": 171, "section_index": 4, "content_hash": "584bfb07c191c3d502bd4f29fb171e286b75dbcb4ffad88296b0b540070d9f73", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:a68fd9cdb590b7c6b5281cd29f73a57abb08402d8d827654130e14deb85c5543", "content": "To customize the SpEL `EvaluationContext` with `PropertyAccessor` implementations, we added the `<spel-property-accessors/>` component.\nFor more information, see xref:spel.adoc#spel-property-accessors[Property Accessors].\n\n[[x3.0-redis-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "SpEL PropertyAccessors Support", "heading_level": 3, "file_order": 171, "section_index": 5, "content_hash": "a68fd9cdb590b7c6b5281cd29f73a57abb08402d8d827654130e14deb85c5543", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:60bb3efe17d6240bfe6623ac1e48bfb66aac453642719a2301cd943c8be12dcc", "content": "We added a new Redis-based https://docs.spring.io/spring-integration/api/org/springframework/integration/metadata/MetadataStore.html[`MetadataStore`] implementation.\nYou can use the `RedisMetadataStore` to maintain the state of a `MetadataStore` across application restarts.\nThis new `MetadataStore` implementation can be used with adapters, such as:\n\n* Twitter inbound adapters\n* Feed inbound channel adapter\n\nWe added new queue-based components.\nWe added the `<int-redis:queue-inbound-channel-adapter/>` and `<int-redis:queue-outbound-channel-adapter/>` components to perform 'right pop' and 'left push' operations, respectively, on a Redis List.\n\nFor more information, \"`see xref:redis.adoc[Redis Support]`\".\n\n[[x3.0-hcr]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Redis: New Components", "heading_level": 3, "file_order": 171, "section_index": 6, "content_hash": "60bb3efe17d6240bfe6623ac1e48bfb66aac453642719a2301cd943c8be12dcc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:86d984fcfafa7520c289e8f43cf6cdf0762bd28f41b682942bb6f822fd34b1fe", "content": "You can now instruct the framework to store reply channels and error channels in a registry for later resolution.\nThis is useful for cases where the `replyChannel` or `errorChannel` might be lost (for example, when serializing a message).\nSee xref:content-enrichment.adoc#header-enricher[Header Enricher] for more information.\n\n[[x3.0-configurable-mongo-MS]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Header Channel Registry", "heading_level": 3, "file_order": 171, "section_index": 7, "content_hash": "86d984fcfafa7520c289e8f43cf6cdf0762bd28f41b682942bb6f822fd34b1fe", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:78e5638bd3cb87668b8ff031d1943c9401bcee5a830eaa944daa6a11e09f47f1", "content": "In addition to the existing `eMongoDbMessageStore`, we introduced a new `ConfigurableMongoDbMessageStore`.\nThis provides a more robust and flexible implementation of `MessageStore` for MongoDB.\nIt does not have backward compatibility with the existing store, but we recommend using it for new applications.\nExisting applications can use it, but messages in the old store are not available.\nSee xref:mongodb.adoc[MongoDb Support] for more information.\n\n[[x3.0-syslog]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "MongoDB support: New `ConfigurableMongoDbMessageStore`", "heading_level": 3, "file_order": 171, "section_index": 8, "content_hash": "78e5638bd3cb87668b8ff031d1943c9401bcee5a830eaa944daa6a11e09f47f1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:a00c0a510f8f0b790d82b86f530f4889737bec20b0a5cfe1d89f48770dd57d8a", "content": "Building on the 2.2 `SyslogToMapTransformer`, Spring Integration 3.0 introduces `UDP` and `TCP` inbound channel adapters especially tailored for receiving SYSLOG messages.\nFor more information, see xref:syslog.adoc[Syslog Support].\n\n[[x3.0-tail]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Syslog Support", "heading_level": 3, "file_order": 171, "section_index": 9, "content_hash": "a00c0a510f8f0b790d82b86f530f4889737bec20b0a5cfe1d89f48770dd57d8a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:ceaa1e8791a68f1d7ac2793b2e5a47d392ff92921ae64cae2bbf5f42516fdf68", "content": "We added file inbound channel adapters that use the `tail` command to generate messages when lines are added to the end of text files.\nSee xref:file/reading.adoc#file-tailing['tail'ing Files].\n\n[[x3.0-jmx]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "`tail` Support", "heading_level": 3, "file_order": 171, "section_index": 10, "content_hash": "ceaa1e8791a68f1d7ac2793b2e5a47d392ff92921ae64cae2bbf5f42516fdf68", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:e90fc38e5fb2a8056f2f4b2f05351edf3440cebb80d1c3ebb265db921a4837ea", "content": "We added `<int-jmx:tree-polling-channel-adapter/>`.\nThis adapter queries the JMX MBean tree and sends a message with a payload that is the graph of objects that match the query.\nBy default, the MBeans are mapped to primitives and simple Objects (such as `Map`, `List`, and arrays).\nIt permits simple transformation to, for example, JSON.\n\nThe `IntegrationMBeanExporter` now allows the configuration of a custom `ObjectNamingStrategy` by using the `naming-strategy` attribute.\n\nFor more information, see xref:jmx.adoc[JMX Support].\n\n[[x3.0-tcp-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "JMX Support", "heading_level": 3, "file_order": 171, "section_index": 11, "content_hash": "e90fc38e5fb2a8056f2f4b2f05351edf3440cebb80d1c3ebb265db921a4837ea", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:02a0a37d337d8a13a28e9e630922d56d508028fa43c56206baa4a909dc0f43ac", "content": "`TcpConnection` instances now emit `ApplicationEvent` instances (specifically `TcpConnectionEvent` instances) when connections are opened or closed or when an exception occurs.\nThis change lets applications be informed of changes to TCP connections by using the normal Spring `ApplicationListener` mechanism.\n\nWe renamed `AbstractTcpConnection` to `TcpConnectionSupport`.\nCustom connections that are subclasses of this class can use its methods to publish events.\nSimilarly, we renamed `AbstractTcpConnectionInterceptor` to `TcpConnectionInterceptorSupport`.\n\nIn addition, we added `<int-ip:tcp-connection-event-inbound-channel-adapter/>`.\nBy default, this adapter sends all `TcpConnectionEvent` instances to a `Channel`.\n\nFurther, the TCP connection factories now provide a new method called `getOpenConnectionIds()`, which returns a list of identifiers for all open connections.\nIt lets applications broadcast to all open connections, among other uses.\n\nFinally, the connection factories also provide a new method called `closeConnection(String connectionId)`, which lets applications explicitly close a connection by using its ID.\n\nFor more information see xref:changes-4.1-4.2.adoc#x4.2-tcp-events[TCP Connection Events].\n\n[[x3.0-inbound-script]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "TCP/IP Connection Events and Connection Management", "heading_level": 3, "file_order": 171, "section_index": 12, "content_hash": "02a0a37d337d8a13a28e9e630922d56d508028fa43c56206baa4a909dc0f43ac", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:421e202eae2f9d02159346a1da58b4d8d7096f75b116f9a23fedaa5159a85570", "content": "The `<int:inbound-channel-adapter/>` now supports using `<expression/>` and `<script/>` child elements to create a `MessageSource`.\nSee xref:channel-adapter.adoc#channel-adapter-expressions-and-scripts[Channel Adapter Expressions and Scripts].\n\n[[x3.0-content-enricher-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Inbound Channel Adapter Script Support", "heading_level": 3, "file_order": 171, "section_index": 13, "content_hash": "421e202eae2f9d02159346a1da58b4d8d7096f75b116f9a23fedaa5159a85570", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:2c236c2edb4a50d3ccd8fd2a8bf2acf0a65cdaaf7a69ee1a2d177b868af5c3b2", "content": "The content enricher now provides configuration for `<header/>` child elements, to enrich the outbound message with headers based on the reply message from the underlying message flow.\nFor more information see xref:content-enrichment.adoc#payload-enricher[Payload Enricher].\n\n[[x3.0-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Content Enricher: Headers Enrichment Support", "heading_level": 3, "file_order": 171, "section_index": 14, "content_hash": "2c236c2edb4a50d3ccd8fd2a8bf2acf0a65cdaaf7a69ee1a2d177b868af5c3b2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:c7dc867f52a0ea7c89d789615323fb451b8f22e8e7622f95ca51b250ce2dc331", "content": "This section describes general changes from version 2.2 to version 3.0.\n\n[[x3.0-message-id]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "General Changes", "heading_level": 2, "file_order": 171, "section_index": 15, "content_hash": "c7dc867f52a0ea7c89d789615323fb451b8f22e8e7622f95ca51b250ce2dc331", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:3ba0a8d67cd43827f537445d0ec8986183216ef3c8b647971007e0e41820267e", "content": "Previously, message IDs were generated by using the JDK `UUID.randomUUID()` method.\nWith this release, the default mechanism has been changed to use a more efficient and significantly faster algorithm.\nIn addition, we added the ability to change the strategy used to generate message IDs.\nFor more information see xref:message.adoc#message-id-generation[Message ID Generation].\n\n[[x3.0-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Message ID Generation", "heading_level": 3, "file_order": 171, "section_index": 16, "content_hash": "3ba0a8d67cd43827f537445d0ec8986183216ef3c8b647971007e0e41820267e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:97657240557f101f75bd3958dbcb9b4af320cdbc8185506f18c4fccbc74e8cd8", "content": "You can now set common headers across all gateway methods, and we added more options for adding information to the message about which method was invoked.\n\nYou can now entirely customize the way that gateway method calls are mapped to messages.\n\nThe `GatewayMethodMetadata` is now a public class.\nIt lets you programmatically configure the `GatewayProxyFactoryBean` from Java.\n\nFor more information, see xref:gateway.adoc[Messaging Gateways].\n\n[[x3.0-http-endpointss]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "\"`<gateway>`\" Changes", "heading_level": 3, "file_order": 171, "section_index": 17, "content_hash": "97657240557f101f75bd3958dbcb9b4af320cdbc8185506f18c4fccbc74e8cd8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:c03907b6646ce30942ddad1b2e93ed023b7a824677d82c9487381848c9111b4e", "content": "* *Outbound Endpoint `encode-uri`*: `<http:outbound-gateway/>` and `<http:outbound-channel-adapter/>` now provide an `encode-uri` attribute to allow disabling the encoding of the URI object before sending the request.\n\n* *Inbound Endpoint `merge-with-default-converters`*: `<http:inbound-gateway/>` and `<http:inbound-channel-adapter/>` now have a `merge-with-default-converters` attribute to include the list of default `HttpMessageConverter` instances after the custom message converters.\n\n* *`If-Modified-Since` and `If-Unmodified-Since` HTTP Headers*: Previously, the `If-Modified-Since` and `If-Unmodified-Since` HTTP headers were incorrectly processed within from and to HTTP headers mapped in the `DefaultHttpHeaderMapper`.\nNow, in addition to correcting that issue, `DefaultHttpHeaderMapper` provides date parsing from formatted strings for any HTTP headers that accept date-time values.\n\n* *Inbound Endpoint Expression Variables*: In addition to the existing `#requestParams` and `#pathVariables`, the `<http:inbound-gateway/>` and `<http:inbound-channel-adapter/>` now support additional useful variables: `#matrixVariables`, `#requestAttributes`, `#requestHeaders`, and `#cookies`.\nThese variables are available in both payload and header expressions.\n\n* *Outbound Endpoint 'uri-variables-expression'*: HTTP outbound endpoints now support the `uri-variables-expression` attribute to specify an `Expression` to evaluate a `Map` for all URI variable placeholders within URL template.\nThis allows selection of a different map of expressions based on the outgoing message.\n\nFor more information, see xref:http.adoc[HTTP Support].\n\n[[x3.0-json-transformers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "HTTP Endpoint Changes", "heading_level": 3, "file_order": 171, "section_index": 18, "content_hash": "c03907b6646ce30942ddad1b2e93ed023b7a824677d82c9487381848c9111b4e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:26b137f22c1aba3e7af204f34195c5a6c9fc0069d212cb8135cda2dd1038d8b3", "content": "* A new abstraction for JSON conversion has been introduced.\nImplementations for Jackson 1.x and Jackson 2 are currently provided, with the version being determined by presence on the classpath.\nPreviously, only Jackson 1.x was supported.\n\n* The `ObjectToJsonTransformer` and `JsonToObjectTransformer` now emit/consume headers containing type information.\n\nFor more information, see \"`JSON Transformers`\" in xref:transformer.adoc[Transformer].\n\n[[x3.0-id-for-chain-sub-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Jackson Support (JSON)", "heading_level": 3, "file_order": 171, "section_index": 19, "content_hash": "26b137f22c1aba3e7af204f34195c5a6c9fc0069d212cb8135cda2dd1038d8b3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:b7a2cdd92f2889cd1fc3dc0cda5fbd26328534b351cce0d7ef18d32682b43db4", "content": "Previously, the `id` attribute for elements within a `<chain>` was ignored and, in some cases, disallowed.\nNow, the `id` attribute is allowed for all elements within a `<chain>`.\nThe bean names of chain elements is a combination of the surrounding chain's `id` and the `id` of the element itself.\nFor example: 'myChain$child.myTransformer.handler'.\nFor more information see, xref:chain.adoc[Message Handler Chain].\n\n[[x3.0-corr-endpoint-empty-groups]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Chain Elements `id` Attribute", "heading_level": 3, "file_order": 171, "section_index": 20, "content_hash": "b7a2cdd92f2889cd1fc3dc0cda5fbd26328534b351cce0d7ef18d32682b43db4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:18242971a23edf1f95a772ba9f2bc282ad577724260deca440ab515d105dc342", "content": "The `AbstractCorrelatingMessageHandler` provides a new property called `empty-group-min-timeout` to allow empty group expiry to run on a longer schedule than expiring partial groups.\nEmpty groups are not removed from the `MessageStore` until they have not been modified for at least this number of milliseconds.\nFor more information, see xref:aggregator.adoc#aggregator-xml[Configuring an Aggregator with XML].\n\n[[x3.0-filelistfilter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Aggregator 'empty-group-min-timeout' property", "heading_level": 3, "file_order": 171, "section_index": 21, "content_hash": "18242971a23edf1f95a772ba9f2bc282ad577724260deca440ab515d105dc342", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:34f23e17974f2e6d6a9e4ce0403c09479f44946d92444834da1a74c620e927c5", "content": "New `FileListFilter` implementations that use a persistent `MetadataStore` are now available.\nYou can use these to prevent duplicate files after a system restart.\nSee xref:file/reading.adoc[Reading Files], xref:ftp/inbound.adoc[FTP Inbound Channel Adapter], and xref:sftp/inbound.adoc[SFTP Inbound Channel Adapter] for more information.\n\n[[x3.0-scripting-variables]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Persistent File List Filters (file, (S)FTP)", "heading_level": 3, "file_order": 171, "section_index": 22, "content_hash": "34f23e17974f2e6d6a9e4ce0403c09479f44946d92444834da1a74c620e927c5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:1aaddb1bca55bed846873e797b53c86b017a2e142f4cc37313a0cc1748893fd5", "content": "We introduced a new `variables` attribute for scripting components.\nIn addition, variable bindings are now allowed for inline scripts.\nSee xref:groovy.adoc[Groovy support] and xref:scripting.adoc[Scripting Support] for more information.\n\n[[x3.0-direct-channel-lb-ref]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Scripting Support: Variables Changes", "heading_level": 3, "file_order": 171, "section_index": 23, "content_hash": "1aaddb1bca55bed846873e797b53c86b017a2e142f4cc37313a0cc1748893fd5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:661a25770b2ec765d75896cdd135a3d7eea513de8f9f8277bf66a89b37691db8", "content": "Previously, when configuring `LoadBalancingStrategy` on the channel's `dispatcher` child element, the only available option was to use a pre-defined enumeration of values which did not let developers set a custom implementation of the `LoadBalancingStrategy`.\nYou can now use `load-balancer-ref` to provide a reference to a custom implementation of the `LoadBalancingStrategy`.\nFor more information, see xref:channel/implementations.adoc#channel-implementations-directchannel[`DirectChannel`].\n\n[[x3.0-pub-sub]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Direct Channel Load Balancing configuration", "heading_level": 3, "file_order": 171, "section_index": 24, "content_hash": "661a25770b2ec765d75896cdd135a3d7eea513de8f9f8277bf66a89b37691db8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:4c61676705d25277e1a50282edfe64888887b20c81560e55801b3f57881d8ce3", "content": "Previously, sending to a <publish-subscribe-channel/> that had no subscribers would return a `false` result.\nIf used in conjunction with a `MessagingTemplate`, this would result in an exception being thrown.\nNow, the `PublishSubscribeChannel` has a property called `minSubscribers` (default: `0`).\nIf the message is sent to at least the minimum number of subscribers, the send operation is deemed to be successful (even if the number is zero).\nIf an application expects to get an exception under these conditions, set the minimum subscribers to at least 1.\n\n[[x3.0--s-ftp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "PublishSubscribeChannel Behavior", "heading_level": 3, "file_order": 171, "section_index": 25, "content_hash": "4c61676705d25277e1a50282edfe64888887b20c81560e55801b3f57881d8ce3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:b3c4c4847e449135b2e4febd2876394e98d0be5993e5532be57162132b6290ee", "content": "The FTP, SFTP and FTPS endpoints no longer cache sessions by default.\n\nWe removed the deprecated `cached-sessions` attribute from all endpoints.\nPreviously, the embedded caching mechanism controlled by this attribute's value did not provide a way to limit the size of the cache, which could grow indefinitely.\nRelease 2.1 introduced `CachingConnectionFactory`, and it became the preferred (and is now the only) way to cache sessions.\n\n`CachingConnectionFactory` now provides a new method: `resetCache()`.\nThis method immediately closes idle sessions and causes in-use sessions to be closed as and when they are returned to the cache.\n\nThe `DefaultSftpSessionFactory` (in conjunction with a `CachingSessionFactory`) now supports multiplexing channels over a single SSH connection (SFTP Only).\n\n[[ftp-sftp-and-ftps-inbound-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "FTP, SFTP and FTPS Changes", "heading_level": 3, "file_order": 171, "section_index": 26, "content_hash": "b3c4c4847e449135b2e4febd2876394e98d0be5993e5532be57162132b6290ee", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:a4d9507859db650b8673355c25eda42457dbfe0417f778d998ffb6a9cd2e6a64", "content": "Previously, there was no way to override the default filter used to process files retrieved from a remote server.\nThe `filter` attribute determines which files are retrieved, but the `FileReadingMessageSource` uses an `AcceptOnceFileListFilter`.\nThis means that, if a new copy of a file is retrieved with the same name as a previously copied file, no message was sent from the adapter.\n\nWith this release, a new attribute `local-filter` lets you override the default filter (for example, with an `AcceptAllFileListFilter` or some other custom filter).\n\nIf you want the behavior of the `AcceptOnceFileListFilter` to be maintained across JVM executions, you can now configure a custom filter that retains state, perhaps on the file system.\n\nInbound channel adapters now support the `preserve-timestamp` attribute, which sets the local file modified timestamp to the timestamp from the server (default: `false`).\n\n[[ftp-sftp-and-ftps-gateways]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "FTP, SFTP and FTPS Inbound Adapters", "heading_level": 4, "file_order": 171, "section_index": 27, "content_hash": "a4d9507859db650b8673355c25eda42457dbfe0417f778d998ffb6a9cd2e6a64", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:58a756c41cbb75ca90ee3cd7ced0837c68908b30ed7895037ad6731a5d071b8c", "content": "The gateways now support the `mv` command, enabling the renaming of remote files.\n\nThe gateways now support recursive `ls` and `mget` commands, enabling the retrieval of a remote file tree.\n\nThe gateways now support `put` and `mput` commands, enabling sending files to the remote server.\n\nThe `local-filename-generator-expression` attribute is now supported, enabling the naming of local files during retrieval.\nBy default, the same name as the remote file is used.\n\nThe `local-directory-expression` attribute is now supported, enabling the naming of local directories during retrieval (based on the remote directory).\n\n[[remote-file-template]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "FTP, SFTP, and FTPS Gateways", "heading_level": 4, "file_order": 171, "section_index": 28, "content_hash": "58a756c41cbb75ca90ee3cd7ced0837c68908b30ed7895037ad6731a5d071b8c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:d817619bbfa41bf81802f61768d5ac60f1b143d0d73176c6fdf960b259b1809a", "content": "A new higher-level abstraction (`RemoteFileTemplate`) is provided over the `Session` implementations used by the FTP and SFTP modules.\nWhile it is used internally by endpoints, you can also use this abstraction programmatically.\nLike all Spring `*Template` implementations, it reliably closes the underlying session while allowing low level access to the session.\n\nFor more information, see xref:ftp.adoc[FTP/FTPS Adapters] and xref:sftp.adoc[SFTP Adapters].\n\n[[x3.0-outbound-gateway-requires-reply]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Remote File Template", "heading_level": 4, "file_order": 171, "section_index": 29, "content_hash": "d817619bbfa41bf81802f61768d5ac60f1b143d0d73176c6fdf960b259b1809a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:dfc57360fe23df231eaae467465432c331ee1ef48606ac70db1818be03d68ad4", "content": "All outbound gateways (such as `<jdbc:outbound-gateway/>` or `<jms:outbound-gateway/>`) are designed for 'request-reply' scenarios.\nA response is expected from the external service and is published to the `reply-channel` or the `replyChannel` message header.\nHowever, there are some cases where the external system might not always return a result (for example,\na `<jdbc:outbound-gateway/>` when a SELECT ends with an empty `ResultSet` or perhaps a one-way web service).\nConsequently, developers needed an option to configure whether or not a reply is required.\nFor this purpose, we introduced the `requires-reply` attribute for outbound gateway components.\nIn most cases, the default value for `requires-reply` is `true`.\nIf there is no result, a `ReplyRequiredException` is thrown.\nChanging the value to `false` means that, if an external service does not return anything, the message flow ends at that point, similar to an outbound channel adapter.\n\nNOTE: The WebService outbound gateway has an additional attribute called `ignore-empty-responses`.\nIt is used to treat an empty `String` response as if no response were received.\nBy default, it is `true`, but you can set it to `false` to allow the application to receive an empty `String` in the reply message payload.\nWhen the attribute is `true`, an empty string is treated as no response for the purposes of the `requires-reply` attribute.\nBy default, `requires-reply` is false for the WebService outbound gateway.\n\nNote that the `requiresReply` property was previously present but set to `false` in the `AbstractReplyProducingMessageHandler`, and there was no way to configure it on outbound gateways by using the XML namespace.\n\nIMPORTANT: Previously, a gateway receiving no reply would silently end the flow (with a DEBUG log message).\nBy default, with this change, an exception is now thrown by most gateways.\nTo revert to the previous behavior, set `requires-reply` to `false`.\n\n[[x3.0-amqp-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "'requires-reply' Attribute for Outbound Gateways", "heading_level": 3, "file_order": 171, "section_index": 30, "content_hash": "dfc57360fe23df231eaae467465432c331ee1ef48606ac70db1818be03d68ad4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:e2df77218560365716843e65e815506d19bbafe33ad02eda6142475b93ab47d2", "content": "Previously, the <int-amqp:outbound-gateway/> mapped headers before invoking the message converter, and the converter could overwrite headers such as `content-type`.\nThe outbound adapter maps the headers after the conversion, which means headers like `content-type` from the outbound `Message` (if present) are used.\n\nStarting with this release, the gateway now maps the headers after the message conversion, consistent with the adapter.\nIf your application relies on the previous behavior (where the converter's headers overrode the mapped headers), you either need to filter those headers (before the message reaches the gateway) or set them appropriately.\nThe headers affected by the `SimpleMessageConverter` are `content-type` and `content-encoding`.\nCustom message converters may set other headers.\n\n[[x3.0-stored-proc-sql-return-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "AMQP Outbound Gateway Header Mapping", "heading_level": 3, "file_order": 171, "section_index": 31, "content_hash": "e2df77218560365716843e65e815506d19bbafe33ad02eda6142475b93ab47d2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:cf81227c4ed54f771b10afe56abee40cabccef5324cd129b0a66fdfe1a410ef5", "content": "For more complex database-specific types not supported by the standard `CallableStatement.getObject` method, we introduced two new additional attributes to the `<sql-parameter-definition/>` element with OUT-direction:\n\n* `type-name`\n* `return-type`\n\nThe `row-mapper` attribute of the stored procedure inbound channel adapter `<returning-resultset/>` child element now supports a reference to a `RowMapper` bean definition.\nPreviously, it contained only a class name (which is still supported).\n\nFor more information, see xref:jdbc/stored-procedures.adoc[Stored Procedures].\n\n[[x3.0-ws-outbound-uri-substitution]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Stored Procedure Components Improvements", "heading_level": 3, "file_order": 171, "section_index": 32, "content_hash": "cf81227c4ed54f771b10afe56abee40cabccef5324cd129b0a66fdfe1a410ef5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:ad1df8df4828a733cdfce42fc3e70b9554b5dbf8aea6aede0215ba879955d6de", "content": "The web service outbound gateway 'uri' attribute now supports `<uri-variable/>` substitution for all URI schemes supported by Spring Web Services.\nFor more information, see xref:ws.adoc#outbound-uri[Outbound URI Configuration].\n\n[[x3.0-redis]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Web Service Outbound URI Configuration", "heading_level": 3, "file_order": 171, "section_index": 33, "content_hash": "ad1df8df4828a733cdfce42fc3e70b9554b5dbf8aea6aede0215ba879955d6de", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:16325fa3efd1bd39580857b1fd10966db5b5be0a83e9d1540c9ed4a6d97a16e3", "content": "The Redis inbound channel adapter can now use a `null` value for the `serializer` property, with the raw data being the message payload.\n\nThe Redis outbound channel adapter now has the `topic-expression` property to determine the Redis topic for the `Message` at runtime.\n\nThe Redis inbound channel adapter, in addition to the existing `topics` attribute, now has the `topic-patterns` attribute.\n\nFor more information, see xref:redis.adoc[Redis Support].\n\n[[x3.0-advising-filters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Redis Adapter Changes", "heading_level": 3, "file_order": 171, "section_index": 34, "content_hash": "16325fa3efd1bd39580857b1fd10966db5b5be0a83e9d1540c9ed4a6d97a16e3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:bc30f79b8b46ff05d7217f18a375ad6bae2fb61118d56ad6558c79c599ff5922", "content": "Previously, when a `<filter/>` had a `<request-handler-advice-chain/>`, the discard action was all performed within the scope of the advice chain (including any downstream flow on the `discard-channel`).\nThe filter element now has an attribute called `discard-within-advice` (default: `true`) to allow the discard action to be performed after the advice chain completes.\nSee xref:handler-advice/advising-filters.adoc[Advising Filters].\n\n[[x3.0-annotation-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Advising Filters", "heading_level": 3, "file_order": 171, "section_index": 35, "content_hash": "bc30f79b8b46ff05d7217f18a375ad6bae2fb61118d56ad6558c79c599ff5922", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:f2664f38bf6abb5f17dd40012b0ce1e6c6c05662bae2d0ceee3439a0f4b6da78", "content": "Request handler advice chains can now be configured using annotations.\nSee xref:handler-advice/advising-with-annotations.adoc[Advising Endpoints Using Annotations].\n\n[[x3.0-o-t-s-t]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Advising Endpoints using Annotations", "heading_level": 3, "file_order": 171, "section_index": 36, "content_hash": "f2664f38bf6abb5f17dd40012b0ce1e6c6c05662bae2d0ceee3439a0f4b6da78", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:7d54e14108786cfd79d7ffbed257332c3286caad0f3b66d5d91b6dd37ce9ef33", "content": "This transformer now correctly transforms `byte[]` and `char[]` payloads to `String`.\nFor more information, see xref:transformer.adoc[Transformer].\n\n[[x3.0-jpa-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "ObjectToStringTransformer Improvements", "heading_level": 3, "file_order": 171, "section_index": 37, "content_hash": "7d54e14108786cfd79d7ffbed257332c3286caad0f3b66d5d91b6dd37ce9ef33", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:22ee8e3e47a9dd2492c1acee0196b75da4c28fc32dfd064a5732aabf1e21c8c9", "content": "Payloads to persist or merge can now be of type `https://docs.oracle.com/javase/7/docs/api/java/lang/Iterable.html[java.lang.Iterable]`.\n\nIn that case, each object returned by the `Iterable` is treated as an entity and persisted or merged by using the underlying `EntityManager`.\nNull values returned by the iterator are ignored.\n\nThe JPA adapters now have additional attributes to optionally flush and clear entities from the associated persistence context after performing persistence operations.\n\nRetrieving gateways had no mechanism to specify the first record to be retrieved, which is a common use case.\nThe retrieving gateways now support specifying this parameter by adding the `first-result` and `first-result-expression` attributes to the gateway definition.\nFor more information, see xref:jpa/outbound-gateways.adoc#jpa-retrieving-outbound-gateway[Retrieving Outbound Gateway].\n\nThe JPA retrieving gateway and inbound adapter now have an attribute to specify the maximum number of results in a result set as an expression.\nIn addition, we introduced the `max-results` attribute to replace `max-number-of-results`, which has been deprecated.\n`max-results` and `max-results-expression` are used to provide the maximum number of results or an expression to compute the maximum number of results, respectively, in the result set.\n\nFor more information, see xref:jpa.adoc[JPA Support].\n\n[[x3.0-dalay-expression]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "JPA Support Changes", "heading_level": 3, "file_order": 171, "section_index": 38, "content_hash": "22ee8e3e47a9dd2492c1acee0196b75da4c28fc32dfd064a5732aabf1e21c8c9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:3aa4dd89a09d9a2d621e9ff2d633adb42d0b523d81c4b780c8fead1ba6a65fdc", "content": "Previously, the `<delayer>` provided a `delay-header-name` attribute to determine the delay value at runtime.\nIn complex cases, the `<delayer>` had to be preceded with a `<header-enricher>`.\nSpring Integration 3.0 introduced the `expression` attribute and `expression` child element for dynamic delay determination.\nThe `delay-header-name` attribute is now deprecated, because you can specify the header evaluation in the `expression`.\nIn addition, we introduced the `ignore-expression-failures` to control the behavior when an expression evaluation fails.\nFor more information, see xref:delayer.adoc[Delayer].\n\n[[x3.0-jdbc-mysql-v5_6_4]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Delayer: delay expression", "heading_level": 3, "file_order": 171, "section_index": 39, "content_hash": "3aa4dd89a09d9a2d621e9ff2d633adb42d0b523d81c4b780c8fead1ba6a65fdc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:199a4c9c49b779ae375addbf91d951368aebdf0bd02db101a44ebe4bdd4acf27", "content": "Spring Integration 3.0 adds a new set of DDL scripts for MySQL version 5.6.4 and higher.\nNow MySQL supports fractional seconds and is thus improving the FIFO ordering when polling from a MySQL-based message store.\nFor more information, see xref:jdbc/message-store.adoc#jdbc-message-store-generic[The Generic JDBC Message Store].\n\n[[x3.0-event-for-imap-idle]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "JDBC Message Store Improvements", "heading_level": 3, "file_order": 171, "section_index": 40, "content_hash": "199a4c9c49b779ae375addbf91d951368aebdf0bd02db101a44ebe4bdd4acf27", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:841fea32459f8740e072cd5e051a6336e8f811f0e0cfd7bf37572bf3fcb8a1d9", "content": "Previously, if an IMAP idle connection failed, it was logged, but there was no mechanism to inform an application.\nSuch exceptions now generate `ApplicationEvent` instances.\nApplications can obtain these events by using an `<int-event:inbound-channel-adapter>` or any `ApplicationListener` configured to receive an `ImapIdleExceptionEvent` (or one of its super classes).\n\n[[x3.0-tcp-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "IMAP Idle Connection Exceptions", "heading_level": 3, "file_order": 171, "section_index": 41, "content_hash": "841fea32459f8740e072cd5e051a6336e8f811f0e0cfd7bf37572bf3fcb8a1d9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:5888ef87a895fbc96c940b02c256653286211c8fab6222057c06ba8579fbc930", "content": "The TCP connection factories now enable the configuration of a flexible mechanism to transfer selected headers (as well as the payload) over TCP.\nA new `TcpMessageMapper` enables the selection of the headers, and you need to configure an appropriate serializer or deserializer to write the resulting `Map` to the TCP stream.\nWe added a `MapJsonSerializer` as a convenient mechanism to transfer headers and payload over TCP.\nFor more information, see xref:ip/correlation.adoc#ip-headers[Transferring Headers].\n\n[[x3.0-jms-mdca-te]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "Message Headers and TCP", "heading_level": 3, "file_order": 171, "section_index": 42, "content_hash": "5888ef87a895fbc96c940b02c256653286211c8fab6222057c06ba8579fbc930", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:5b412c4c225f5ad364e38dbe9b91954587d65027701a8f9ea61c0368b9c2a1ea", "content": "Previously, when configuring a `<message-driven-channel-adapter/>`, if you wished to use a specific `TaskExecutor`, you had to declare a container bean and provide it to the adapter by setting the `container` attribute.\nWe added the `task-executor`, letting it be set directly on the adapter.\nThis is in addition to several other container attributes that were already available.\n\n[[x3.0-xslt-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "JMS Message Driven Channel Adapter", "heading_level": 3, "file_order": 171, "section_index": 43, "content_hash": "5b412c4c225f5ad364e38dbe9b91954587d65027701a8f9ea61c0368b9c2a1ea", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:8b30e32e54c52f99b6a32d7f57e553812a5faad32dfb91cca0d90561e17d1e8c", "content": "You can now specify the transformer factory class name by setting the `transformer-factory-class` attribute.\nSee `xref:xml/transformation.adoc#xml-xslt-payload-transformers[XsltPayloadTransformer]`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-2.2-3.0.adoc", "title": "changes-2.2-3.0", "heading": "`XsltPayloadTransformer`", "heading_level": 3, "file_order": 171, "section_index": 44, "content_hash": "8b30e32e54c52f99b6a32d7f57e553812a5faad32dfb91cca0d90561e17d1e8c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-2.2-3.0.adoc"}}
{"id": "sha256:09043d8abdd3ed3847176f46ebe737329cbf01fc63f8729f8e7b319f0bec2bb2", "content": "[[migration-3.0-4.0]]\n\nSee the https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-3.0-to-4.0-Migration-Guide[Migration Guide] for important changes that might affect your applications.\nYou can find migration guides for all versions back to 2.1 on the https://github.com/spring-projects/spring-integration/wiki[wiki].\n\n[[x4.0-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "changes-3.0-4.0", "heading_level": 1, "file_order": 172, "section_index": 0, "content_hash": "09043d8abdd3ed3847176f46ebe737329cbf01fc63f8729f8e7b319f0bec2bb2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:8f8a091463f9b01f5ca8ced952561484dcd790258a5faac3fb49915a4b3b72e6", "content": "Version 4.0 added a number of new components.\n\n[[x4.0-mqtt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "New Components", "heading_level": 2, "file_order": 172, "section_index": 1, "content_hash": "8f8a091463f9b01f5ca8ced952561484dcd790258a5faac3fb49915a4b3b72e6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:07d1e4587d62dd6d53c5b0f618165589907b1d477f392be3eb2bdbb3056135f5", "content": "The MQTT channel adapters (previously available in the Spring Integration Extensions repository) are now available as part of the normal Spring Integration distribution.\nSee xref:mqtt.adoc[MQTT Support].\n\n[[x4.0-enable-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "MQTT Channel Adapters", "heading_level": 3, "file_order": 172, "section_index": 2, "content_hash": "07d1e4587d62dd6d53c5b0f618165589907b1d477f392be3eb2bdbb3056135f5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:a0b6645417466d033efaee631344b47e107d7e296d0e9115c6781b6e273725f2", "content": "We added the `@EnableIntegration` annotation to permit declaration of standard Spring Integration beans when using `@Configuration` classes.\nSee xref:configuration/annotations.adoc[Annotation Support] for more information.\n\n[[x4.0-component-scan]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`@EnableIntegration`", "heading_level": 3, "file_order": 172, "section_index": 3, "content_hash": "a0b6645417466d033efaee631344b47e107d7e296d0e9115c6781b6e273725f2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:57ac678f04baa1e841a19046887cc1a0c52c6c475b2d2eca55f067ad372bdb0d", "content": "We added the `@IntegrationComponentScan` annotation to permit classpath scanning for Spring Integration-specific components.\nSee xref:configuration/annotations.adoc[Annotation Support] for more information.\n\n[[x4.0-message-history]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`@IntegrationComponentScan`", "heading_level": 3, "file_order": 172, "section_index": 4, "content_hash": "57ac678f04baa1e841a19046887cc1a0c52c6c475b2d2eca55f067ad372bdb0d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:c0359266e2222212bec479c39245455eee8b463789dd60b57b07f84be7e9eb97", "content": "You can now enable message history with the `@EnableMessageHistory` annotation in a `@Configuration` class.\nIn addition, a JMX MBean can modify the message history settings.\nAlso, `MessageHistory` can track auto-created `MessageHandler` instances for annotated endpoints (such as `@ServiceActivator`, `@Splitter`, and others).\nFor more information, see xref:message-history.adoc[Message History].\n\n[[x4.0-messaging-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "\"`@EnableMessageHistory`\"", "heading_level": 3, "file_order": 172, "section_index": 5, "content_hash": "c0359266e2222212bec479c39245455eee8b463789dd60b57b07f84be7e9eb97", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:cc785e207d0fa9c519808bc5f0bcfb0076ade00e42d9842e42bf61034a57e683", "content": "You can now configure messaging gateway interfaces with the `@MessagingGateway` annotation.\nIt is an analogue of the `<int:gateway/>` XML element.\nFor more information, see xref:gateway.adoc#messaging-gateway-annotation[`@MessagingGateway` Annotation].\n\n[[x4.0-boot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`@MessagingGateway`", "heading_level": 3, "file_order": 172, "section_index": 6, "content_hash": "cc785e207d0fa9c519808bc5f0bcfb0076ade00e42d9842e42bf61034a57e683", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:4172798d58dd65fcf583a6d87d92a07c5e633f10fce02f05938f186420de92ad", "content": "As well as the `@EnableIntegration` annotation mentioned earlier, we introduced a hook to allow the Spring Integration infrastructure beans to be configured with Spring Boot's `@EnableAutoConfiguration` annotation.\nFor more information, see https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html[\"`Auto-configuration`\"] in the Spring Boot Reference Guide.\n\n[[x4.0-global-channel-interceptor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Spring Boot `@EnableAutoConfiguration`", "heading_level": 3, "file_order": 172, "section_index": 7, "content_hash": "4172798d58dd65fcf583a6d87d92a07c5e633f10fce02f05938f186420de92ad", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:9d48876c227c2485a596491e1af9c3f92fa3e8aeb4e2f8f40ca87172f46455b8", "content": "As well as the `@EnableIntegration` annotation mentioned above, we introduced the `@GlobalChannelInterceptor` annotation.\nFor more information, see xref:configuration/annotations.adoc[Annotation Support].\n\n[[x4.0-integration-converter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`@GlobalChannelInterceptor`", "heading_level": 3, "file_order": 172, "section_index": 8, "content_hash": "9d48876c227c2485a596491e1af9c3f92fa3e8aeb4e2f8f40ca87172f46455b8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:faa4e2b7bdc431b4888e5e5627d337182216fa0514f56f0276c836ca160692fb", "content": "We introduced the `@IntegrationConverter` annotation as an analogue of the `<int:converter/>` component.\nFor more information, see xref:configuration/annotations.adoc[Annotation Support].\n\n[[x4.0-enable-publisher]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`@IntegrationConverter`", "heading_level": 3, "file_order": 172, "section_index": 9, "content_hash": "faa4e2b7bdc431b4888e5e5627d337182216fa0514f56f0276c836ca160692fb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:2ab5b972a9aa0e69b052a18bc13927d9f53d4bb6522c29c3ef1ac668293a4566", "content": "We added the `@EnablePublisher` annotation to allow the specification of a `default-publisher-channel` for `@Publisher` annotations.\nSee xref:configuration/annotations.adoc[Annotation Support] for more information.\n\n[[x4.0-redis-cms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`@EnablePublisher`", "heading_level": 3, "file_order": 172, "section_index": 10, "content_hash": "2ab5b972a9aa0e69b052a18bc13927d9f53d4bb6522c29c3ef1ac668293a4566", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:d7d4c7424f8714b143ee584c6caad8b73576085381d86aabbf778a2356f1e301", "content": "We added a Redis `MessageGroupStore` that is optimized for use when backing a `QueueChannel` for persistence.\nFor more information, see xref:redis.adoc#redis-cms[Redis Channel Message Stores].\n\nWe added a Redis `ChannelPriorityMessageStore`.\nYou can use it to retrieve messages by priority.\nFor more information, see xref:redis.adoc#redis-cms[Redis Channel Message Stores].\n\n[[x4.0-priority-channel-mondodb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Redis Channel Message Stores", "heading_level": 3, "file_order": 172, "section_index": 11, "content_hash": "d7d4c7424f8714b143ee584c6caad8b73576085381d86aabbf778a2356f1e301", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:6a51793e1873000c2d35e738fad8537530426c4a777f86e4421535818ea75175", "content": "The MongoDB support now provides the `MongoDbChannelMessageStore`, which is a channel-specific `MessageStore` implementation.\nWith `priorityEnabled = true`, you can use it in `<int:priority-queue>` elements to achieve priority order polling of persisted messages.\nFor more information see xref:mongodb.adoc#mongodb-priority-channel-message-store[MongoDB Channel Message Store].\n\n[[x4.0-MBeanExport-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "MongodDB Channel Message Store", "heading_level": 3, "file_order": 172, "section_index": 12, "content_hash": "6a51793e1873000c2d35e738fad8537530426c4a777f86e4421535818ea75175", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:b9d3889b59192d4683140b89702dfde79f42ed8e8cf14d99c051a41ee465b813", "content": "You can now enable the `IntegrationMBeanExporter` with the `@EnableIntegrationMBeanExport` annotation in a `@Configuration` class.\nFor more information, see xref:jmx.adoc#jmx-mbean-exporter[MBean Exporter].\n\n[[x4.0-channel-security-interceptor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`@EnableIntegrationMBeanExport`", "heading_level": 3, "file_order": 172, "section_index": 13, "content_hash": "b9d3889b59192d4683140b89702dfde79f42ed8e8cf14d99c051a41ee465b813", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:970677c5e623626e3c820841ec613907a568967fdfee396e7c6d7930d6234b16", "content": "`ChannelSecurityInterceptorFactoryBean` now supports configuration of Spring Security for message channels that use `@Configuration` classes.\nFor more information, see xref:security.adoc[Security in Spring Integration].\n\n[[x4.0-redis-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`ChannelSecurityInterceptorFactoryBean`", "heading_level": 3, "file_order": 172, "section_index": 14, "content_hash": "970677c5e623626e3c820841ec613907a568967fdfee396e7c6d7930d6234b16", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:42014677d55e61ed87694ee022572d5ee8eb9ac4421033f4af02b57c35b211e5", "content": "The Redis support now provides the `<outbound-gateway>` component to perform generic Redis commands by using the `RedisConnection#execute` method.\nFor more information, see xref:redis.adoc#redis-outbound-gateway[Redis Outbound Command Gateway].\n\n[[x4.0-redis-lock-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Redis Command Gateway", "heading_level": 3, "file_order": 172, "section_index": 15, "content_hash": "42014677d55e61ed87694ee022572d5ee8eb9ac4421033f4af02b57c35b211e5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:98bbce075b4128b9fc082fec8a131d7f00947ed37a6d4152d542a22938778ccc", "content": "The `RedisLockRegistry` is now available to support global locks visible to multiple application instances and servers.\nThese can be used with aggregating message handlers across multiple application instances such that group release occurs on only one instance.\nFor more information, see xref:redis.adoc#redis-lock-registry[Redis Lock Registry] and xref:overview.adoc#overview-endpoints-aggregator[Aggregator].\n\n[[x4.0-poller-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`RedisLockRegistry`", "heading_level": 3, "file_order": 172, "section_index": 16, "content_hash": "98bbce075b4128b9fc082fec8a131d7f00947ed37a6d4152d542a22938778ccc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:09b8de8910d9a6cc846711efa34a5a58696e00e69a1a139cc29ef37151db2070", "content": "Annotation-based messaging configuration can now have a `poller` attribute.\nThis means that methods annotated with `@ServiceActivator`, `@Aggregator`, and similar annotations can now use an `inputChannel` that is a reference to a `PollableChannel`.\nFor more information, see xref:configuration/annotations.adoc[Annotation Support].\n\n[[x4.0-inbound-channel-adapter-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`@Poller`", "heading_level": 3, "file_order": 172, "section_index": 17, "content_hash": "09b8de8910d9a6cc846711efa34a5a58696e00e69a1a139cc29ef37151db2070", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:dbdd82e160d31e92ac63cb6e45a77a05d085853e8688e39c643d9b1752f64897", "content": "We added the `@InboundChannelAdapter` method annotation.\nIt is an analogue of the `<int:inbound-channel-adapter>` XML component.\nIn addition, all messaging annotations now provide `SmartLifecycle` options.\nFor more information, see xref:configuration/annotations.adoc[Annotation Support].\n\n[[x4.0-twitter-sog]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`@InboundChannelAdapter` and `SmartLifecycle` for Annotated Endpoints", "heading_level": 3, "file_order": 172, "section_index": 18, "content_hash": "dbdd82e160d31e92ac63cb6e45a77a05d085853e8688e39c643d9b1752f64897", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:d0032f95942788ee0c8dce6d3649a02a3790f1729b17208d449b47b000fac046", "content": "We added a new twitter endpoint: `<int-twitter-search-outbound-gateway/>`.\nUnlike the search inbound adapter, which polls by using the same search query each time, the outbound gateway allows on-demand customized queries.\nFor more information, see https://github.com/spring-projects/spring-integration-extensions/tree/main/spring-integration-social-twitter[Spring Integration Social Twitter].\n\n[[x4.0-bridge-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Twitter Search Outbound Gateway", "heading_level": 3, "file_order": 172, "section_index": 19, "content_hash": "d0032f95942788ee0c8dce6d3649a02a3790f1729b17208d449b47b000fac046", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:b906004c11ea0158e0f44b24e2bb4e7639ef17db12eb526042ec8496cb610738", "content": "We introduced `@BridgeFrom` and `@BridgeTo` `@Bean` method annotations to mark `MessageChannel` beans in `@Configuration` classes.\nFor more information, see xref:configuration/annotations.adoc[Annotation Support].\n\n[[x4.0-meta-messaging-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`@BridgeFrom` and `@BridgeTo` Annotations", "heading_level": 3, "file_order": 172, "section_index": 20, "content_hash": "b906004c11ea0158e0f44b24e2bb4e7639ef17db12eb526042ec8496cb610738", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:b8bc1f64ea696c7c4daa0c271019190c594cde32fedc8e09bdd1f6543543ba9c", "content": "Messaging annotations (`@ServiceActivator`, `@Router`, `@MessagingGateway`, and others) can now be configured as meta-annotations for user-defined messaging annotations.\nIn addition, the user-defined annotations can have the same attributes (`inputChannel`, `@Poller`, `autoStartup`, and others).\nFor more information, see xref:configuration/annotations.adoc[Annotation Support].\n\n[[x4.0-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Meta-messaging Annotations", "heading_level": 3, "file_order": 172, "section_index": 21, "content_hash": "b8bc1f64ea696c7c4daa0c271019190c594cde32fedc8e09bdd1f6543543ba9c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:58ce5863730908dbc83ea7b7978bc278c6e0f4faedb8ed7859d874b7692da21b", "content": "This section describes general changes from version 3.0 to version 4.0.\n\n[[requires-spring-framework-4-0]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "General Changes", "heading_level": 2, "file_order": 172, "section_index": 22, "content_hash": "58ce5863730908dbc83ea7b7978bc278c6e0f4faedb8ed7859d874b7692da21b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:278790cc4b45e73c65e33e1721d117a198becdfc4cb8d6fde8749786cc1f8ac7", "content": "We moved the core messaging abstractions (`Message`, `MessageChannel`, and others) to the Spring Framework `spring-messaging` module.\nDevelopers who reference these classes directly in their code need to make changes, as described in the first section of the https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-3.0-to-4.0-Migration-Guide[3.0 to 4.0 Migration Guide].\n\n[[x4.0-xpath-header-enricher-header-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Requires Spring Framework 4.0", "heading_level": 3, "file_order": 172, "section_index": 23, "content_hash": "278790cc4b45e73c65e33e1721d117a198becdfc4cb8d6fde8749786cc1f8ac7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:77c9b81c279d2c0a32a6cb76c62e366ed097b6f89a16943a031d493e55c8236a", "content": "We introduced the `header-type` attribute for the `header` child element of the `<int-xml:xpath-header-enricher>`.\nThis attribute provides the target type for the header value (to which the result of the XPath expression evaluation is converted).\nFor more information see xref:xml/xpath-header-enricher.adoc[XPath Header Enricher].\n\n[[x4.0-object-to-json-transformer-result-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Header Type for XPath Header Enricher", "heading_level": 3, "file_order": 172, "section_index": 24, "content_hash": "77c9b81c279d2c0a32a6cb76c62e366ed097b6f89a16943a031d493e55c8236a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:b0e7a97de7a113c9ce7e48e4a882e5b0387c734b8f35995efdea89e56b907fe0", "content": "We introduced the `result-type` attribute for the `<int:object-to-json-transformer>`.\nThis attribute provides the target type for the result of mapping an object to JSON.\nIt supports `STRING` (the default) and `NODE`.\nFor more information see xref:transformer.adoc#transformer-xpath-spel-function[Since version 3.0, Spring Integration also provides a built-in `#xpath` SpEL function for use in expressions.].\n\n[[x4.0-jms-header-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Object To JSON Transformer: Node Result", "heading_level": 3, "file_order": 172, "section_index": 25, "content_hash": "b0e7a97de7a113c9ce7e48e4a882e5b0387c734b8f35995efdea89e56b907fe0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:992ecd621e39598fc3db03b2cccc75ec53dfd5c76924547b610fe4af5b0edba9", "content": "The `DefaultJmsHeaderMapper` now maps an incoming `JMSPriority` header to the Spring Integration `priority` header.\nPreviously, `priority` was only considered for outbound messages.\nFor more information, see xref:changes-3.0-4.0.adoc#x4.0-jms-header-mapping[Mapping Message Headers to and from JMS Message].\n\n[[x4.0-jms-ob]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "JMS Header Mapping", "heading_level": 3, "file_order": 172, "section_index": 26, "content_hash": "992ecd621e39598fc3db03b2cccc75ec53dfd5c76924547b610fe4af5b0edba9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:4dc075f64cf30836d2b62989adb88a3ef9926548e048c2618f4db5f95dff6862", "content": "The JMS outbound channel adapter now supports the `session-transacted` attribute (default: `false`).\nPreviously, you had to inject a customized `JmsTemplate` to use transactions.\nSee xref:changes-3.0-4.0.adoc#x4.0-jms-ob[Outbound Channel Adapter].\n\n[[x4.0-jms-ib]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "JMS Outbound Channel Adapter", "heading_level": 3, "file_order": 172, "section_index": 27, "content_hash": "4dc075f64cf30836d2b62989adb88a3ef9926548e048c2618f4db5f95dff6862", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:78b122a4b97f42b91108110b81b64f1258339b313bb25e9d27609e0239d2782f", "content": "The JMS inbound channel adapter now supports the `session-transacted` attribute (default: `false`).\nPreviously, you had to inject a customized `JmsTemplate` to use transactions.\nThe adapter allowed 'transacted' in the `acknowledgeMode`, which was incorrect and didn't work.\nThis value is no longer allowed.\nSee xref:changes-3.0-4.0.adoc#x4.0-jms-ib[Inbound Channel Adapter].\n\n[[x4.0-datatype-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "JMS Inbound Channel Adapter", "heading_level": 3, "file_order": 172, "section_index": 28, "content_hash": "78b122a4b97f42b91108110b81b64f1258339b313bb25e9d27609e0239d2782f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:fae1ea2360c7a741c1f92677fa5e7fb5d94804213096e682f5ebb2efebd4f453", "content": "You can now specify a `MessageConverter` to be used when converting (if necessary) payloads to one of the accepted `datatype` instances in a Datatype channel.\nFor more information, see xref:channel/configuration.adoc#channel-datatype-channel[Datatype Channel Configuration].\n\n[[x4.0-retry-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Datatype Channels", "heading_level": 3, "file_order": 172, "section_index": 29, "content_hash": "fae1ea2360c7a741c1f92677fa5e7fb5d94804213096e682f5ebb2efebd4f453", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:30b39ef9071a5be328d0258d32c8a54e6b7456775c40f75a2e557e7423238a69", "content": "We added simplified namespace support to configure a `RequestHandlerRetryAdvice`.\nFor more information, see xref:handler-advice/classes.adoc#retry-config[Configuring the Retry Advice].\n\n[[x4.0-release-strategy-group-timeout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Simpler Retry Advice Configuration", "heading_level": 3, "file_order": 172, "section_index": 30, "content_hash": "30b39ef9071a5be328d0258d32c8a54e6b7456775c40f75a2e557e7423238a69", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:ec643aff613e9e67eda5c2a5b2b2b1853af425e8cf81eae558e71b67ba84ec5e", "content": "We added the mutually exclusive `group-timeout` and `group-timeout-expression` attributes to `<int:aggregator>` and `<int:resequencer>`.\nThese attributes allow forced completion of a partial `MessageGroup`, provided the `ReleaseStrategy` does not release a group and no further messages arrive within the time specified.\nFor more information, see xref:aggregator.adoc#aggregator-xml[Configuring an Aggregator with XML].\n\n[[x4.0-redis-metadata]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Correlation Endpoint: Time-based Release Strategy", "heading_level": 3, "file_order": 172, "section_index": 31, "content_hash": "ec643aff613e9e67eda5c2a5b2b2b1853af425e8cf81eae558e71b67ba84ec5e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:db809463fa6b54333b32ce8c11af7d4beea5d71baceb33b9c51ef85eef3608f7", "content": "The `RedisMetadataStore` now implements `ConcurrentMetadataStore`, letting it be used, for example, in an `AbstractPersistentAcceptOnceFileListFilter` implementation in a multiple application instance or server environment.\nFor more information, see xref:redis.adoc#redis-metadata-store[Redis Metadata Store], xref:file/reading.adoc[Reading Files], xref:ftp/inbound.adoc[FTP Inbound Channel Adapter], and xref:sftp/inbound.adoc[SFTP Inbound Channel Adapter].\n\n[[x4.0-jdbc-cs]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Redis Metadata Store", "heading_level": 3, "file_order": 172, "section_index": 32, "content_hash": "db809463fa6b54333b32ce8c11af7d4beea5d71baceb33b9c51ef85eef3608f7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:b2d3ce8d44c5938b308e8207ccc74f3d811b7498078ee00f078a64da10446cec", "content": "T`JdbcChannelMessageStore` now implements `PriorityCapableChannelMessageStore`, letting it be used as a `message-store` reference for `priority-queue` instances.\nFor more information, see xref:jdbc/message-store.adoc#jdbc-message-store-channels[Backing Message Channels].\n\n[[x4.0-amqp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "`JdbcChannelMessageStore` and `PriorityChannel`", "heading_level": 3, "file_order": 172, "section_index": 33, "content_hash": "b2d3ce8d44c5938b308e8207ccc74f3d811b7498078ee00f078a64da10446cec", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:2ce5718b7cc643cf6937521a112aee7845c48cdc847092be2895190d6aa0fee5", "content": "Spring AMQP, by default, creates persistent messages on the broker.\nYou can override this behavior by setting the `amqp_deliveryMode` header or customizing the mappers.\nWe added a convenient `default-delivery-mode` attribute to the adapters to provide easier configuration of this important setting.\nFor more information, see xref:amqp/outbound-channel-adapter.adoc[Outbound Channel Adapter] and xref:amqp/outbound-gateway.adoc[Outbound Gateway].\n\n[[x4.0-ftp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "AMQP Endpoints Delivery Mode", "heading_level": 3, "file_order": 172, "section_index": 34, "content_hash": "2ce5718b7cc643cf6937521a112aee7845c48cdc847092be2895190d6aa0fee5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:a6810ef4ebcc0ce1610e25a7c38d9cb2bed105ace393d50554b08008cd1a8e81", "content": "The `DefaultFtpSessionFactory` now exposes the `connectTimeout`, `defaultTimeout`, and `dataTimeout` properties, avoiding the need to subclass the factory to set these common properties.\nThe `postProcess*` methods are still available for more advanced configuration.\nSee xref:ftp/session-factory.adoc[FTP Session Factory] for more information.\n\n[[x4.0-twitter-status-updating]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "FTP Timeouts", "heading_level": 3, "file_order": 172, "section_index": 35, "content_hash": "a6810ef4ebcc0ce1610e25a7c38d9cb2bed105ace393d50554b08008cd1a8e81", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:0e0b9e29b80446579da850f3ca826aeaa6e2500afbf43cf7bda5f5d3a4041396", "content": "The `StatusUpdatingMessageHandler` (`<int-twitter:outbound-channel-adapter>`) now supports the `tweet-data-expression` attribute to build a `org.springframework.social.twitter.api.TweetData` object for updating the timeline status.\nThis feature allows, for example, attaching an image.\nSee https://github.com/spring-projects/spring-integration-extensions/tree/main/spring-integration-social-twitter[Spring Integration Social Twitter] for more information.\n\n[[x4.0-jpa-id-expression]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Twitter: `StatusUpdatingMessageHandler`", "heading_level": 3, "file_order": 172, "section_index": 36, "content_hash": "0e0b9e29b80446579da850f3ca826aeaa6e2500afbf43cf7bda5f5d3a4041396", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:0b6f239ea0da554b61b992471c03afe47c7beef2b6d07124b5990008952402f7", "content": "We introduced the `id-expression` attribute for `<int-jpa:retrieving-outbound-gateway>` to perform `EntityManager.find(Class entityClass, Object primaryKey)`.\nSee xref:jpa/outbound-gateways.adoc#jpa-retrieving-outbound-gateway[Retrieving Outbound Gateway] for more information.\n\n[[x4.0-tcp-deserializer-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "JPA Retrieving Gateway: `id-expression`", "heading_level": 3, "file_order": 172, "section_index": 37, "content_hash": "0b6f239ea0da554b61b992471c03afe47c7beef2b6d07124b5990008952402f7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:34d66dd1896a79c04989734dc673886c9db749b1312148be15ce6fcc2bba2831", "content": "When one of the standard deserializers encounters a problem decoding the input stream to a message, it now emits a `TcpDeserializationExceptionEvent`, letting applications examine the data at the point at which the exception occurred.\nSee xref:changes-4.1-4.2.adoc#x4.2-tcp-events[TCP Connection Events] for more information.\n\n[[x4.0-bean-messaging-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "TCP Deserialization Events", "heading_level": 3, "file_order": 172, "section_index": 38, "content_hash": "34d66dd1896a79c04989734dc673886c9db749b1312148be15ce6fcc2bba2831", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:76e618dee6039934aafa403f0b3c43782504e836ed3540b05267c24bfc35dcf9", "content": "You can now configure messaging annotations (`@ServiceActivator`, `@Router`, `@InboundChannelAdapter`, and others) on `@Bean` definitions in `@Configuration` classes.\nFor more information, see xref:configuration/annotations.adoc[Annotation Support].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-3.0-4.0.adoc", "title": "changes-3.0-4.0", "heading": "Messaging Annotations on `@Bean` Definitions", "heading_level": 3, "file_order": 172, "section_index": 39, "content_hash": "76e618dee6039934aafa403f0b3c43782504e836ed3540b05267c24bfc35dcf9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-3.0-4.0.adoc"}}
{"id": "sha256:4c37df8113eb4e62f5aa3f510281bc3deca0d7b5ed41cc7699fe114123b02cb6", "content": "[[migration-4.0-4.1]]\n\nSee the https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-4.0-to-4.1-Migration-Guide[Migration Guide] for important changes that might affect your applications.\nYou can find migration guides for all versions back to 2.1 on the https://github.com/spring-projects/spring-integration/wiki[wiki].\n\n[[new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "changes-4.0-4.1", "heading_level": 1, "file_order": 173, "section_index": 0, "content_hash": "4c37df8113eb4e62f5aa3f510281bc3deca0d7b5ed41cc7699fe114123b02cb6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:9fef0ee45327c80d64a0d0dd31948707cc3c29db16e5c35114184ed18b3bc356", "content": "Version 4.1 added a number of new components.\n\n[[x4.1-promise-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "New Components", "heading_level": 2, "file_order": 173, "section_index": 1, "content_hash": "9fef0ee45327c80d64a0d0dd31948707cc3c29db16e5c35114184ed18b3bc356", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:3b01751dd5410a03cb669bdbd5416ac997c9145edfd0cd528d92e3359cbec75c", "content": "The messaging gateway methods now support a Reactor `Promise` return type.\nSee xref:jms.adoc#jms-async-gateway[Asynchronous Gateway].\n\n[[x4.1-web-socket-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Promise<?> Gateway", "heading_level": 3, "file_order": 173, "section_index": 2, "content_hash": "3b01751dd5410a03cb669bdbd5416ac997c9145edfd0cd528d92e3359cbec75c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:5ea92080df64e30aca0d9ecc5c820293f9403cd3dc485fd65b3e24c3a30e4e95", "content": "The `WebSocket` module is now available.\nIt is fully based on the Spring WebSocket and Spring Messaging modules and provides an `<inbound-channel-adapter>` and an `<outbound-channel-adapter>`.\nSee xref:web-sockets.adoc[WebSockets Support] for more information.\n\n[[x4.1-scatter-gather]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "WebSocket support", "heading_level": 3, "file_order": 173, "section_index": 3, "content_hash": "5ea92080df64e30aca0d9ecc5c820293f9403cd3dc485fd65b3e24c3a30e4e95", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:47b53f02b656a98d6d3458eb0257fffb71aafdb781c8afc62f3d10bcc1206504", "content": "We implemented the scatter-gather enterprise integration pattern.\nSee xref:scatter-gather.adoc[Scatter-Gather] for more information.\n\n[[x4.1-Routing-Slip]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Scatter-Gather Enterprise Integration Pattern", "heading_level": 3, "file_order": 173, "section_index": 4, "content_hash": "47b53f02b656a98d6d3458eb0257fffb71aafdb781c8afc62f3d10bcc1206504", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:94d5221f66a3f34bf5c52efb703a79d8642d2593782d0e27c70690d1a683d0e3", "content": "We added the routing slip EIP pattern implementation.\nSee xref:router/routing-slip.adoc[Routing Slip] for more information.\n\n[[x4.1-idempotent-receiver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Routing Slip Pattern", "heading_level": 3, "file_order": 173, "section_index": 5, "content_hash": "94d5221f66a3f34bf5c52efb703a79d8642d2593782d0e27c70690d1a683d0e3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:d93cedbd60d25cfa2ab84d8ed81469184dcd85c1766b88bf2bbed9f18c2e8918", "content": "We added the idempotent receiver enterprise integration pattern implementation by adding the `<idempotent-receiver>` component in XML or the `IdempotentReceiverInterceptor` and `IdempotentReceiver` annotations for Java configuration.\nSee xref:handler-advice/idempotent-receiver.adoc[Idempotent Receiver Enterprise Integration Pattern] and the https://docs.spring.io/spring-integration/api/index.html[Javadoc] for more information.\n\n[[x4.1-BoonJsonObjectMapper]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Idempotent Receiver Pattern", "heading_level": 3, "file_order": 173, "section_index": 6, "content_hash": "d93cedbd60d25cfa2ab84d8ed81469184dcd85c1766b88bf2bbed9f18c2e8918", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:80863f762d0c70b2f632ca48aa0fd97ae71a8c829123c780b9e148fa549afd43", "content": "We added the Boon `JsonObjectMapper` for the JSON transformers.\nSee xref:transformer.adoc[Transformer] for more information.\n\n[[x4.1-redis-queue-gateways]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Boon `JsonObjectMapper`", "heading_level": 3, "file_order": 173, "section_index": 7, "content_hash": "80863f762d0c70b2f632ca48aa0fd97ae71a8c829123c780b9e148fa549afd43", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:10db35f33dade62f410e617af627a4b5290ca384a9a59e3703a85c9f4cb07400", "content": "We added the `<redis-queue-inbound-gateway>` and `<redis-queue-outbound-gateway>` components.\nSee xref:redis.adoc#redis-queue-inbound-gateway[Redis Queue Inbound Gateway] and xref:redis.adoc#redis-queue-outbound-gateway[Redis Queue Outbound Gateway].\n\n[[x4.1-PollSkipAdvice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Redis Queue Gateways", "heading_level": 3, "file_order": 173, "section_index": 8, "content_hash": "10db35f33dade62f410e617af627a4b5290ca384a9a59e3703a85c9f4cb07400", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:54ff5424912251547f39ae23d4ac4f190608cc39667691a8be5fad3363412d97", "content": "We added the `PollSkipAdvice`, which you can use within the `<advice-chain>` of the `<poller>` to determine if the current poll should be suppressed (skipped) by some condition that you implement with `PollSkipStrategy`.\nSee xref:polling-consumer.adoc#polling-consumer[Poller] for more information.\n\n[[x4.1-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "`PollSkipAdvice`", "heading_level": 3, "file_order": 173, "section_index": 9, "content_hash": "54ff5424912251547f39ae23d4ac4f190608cc39667691a8be5fad3363412d97", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:cd11e86f689fb559cf9bf40c04ce4dd53348d4064254442c211691c1a60e64e7", "content": "This section describes general changes from version 4.0 to version 4.1.\n\n[[x4.1-amqp-inbound-missing-queues]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "General Changes", "heading_level": 2, "file_order": 173, "section_index": 10, "content_hash": "cd11e86f689fb559cf9bf40c04ce4dd53348d4064254442c211691c1a60e64e7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:70fee3d4fd2af6d090e917f3bf3535b764eb35bab8b5b540e5a466ac84420b50", "content": "Elements that use a message listener container (inbound endpoints and channel) now support the `missing-queues-fatal` attribute.\nSee xref:amqp.adoc[AMQP Support] for more information.\n\n[[x4.1-amqp-outbound-lazy-connect]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "AMQP Inbound Endpoints, Channel", "heading_level": 3, "file_order": 173, "section_index": 11, "content_hash": "70fee3d4fd2af6d090e917f3bf3535b764eb35bab8b5b540e5a466ac84420b50", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:205e99e3f76dc8b8a713c2f6ab2d180247d76dec5910e4191b0e37f3137555b1", "content": "The AMQP outbound endpoints support a new property called `lazy-connect` (default: `true`).\nWhen `true`, the connection to the broker is not established until the first message arrives (assuming there are no inbound endpoints, which always try to establish the connection during startup).\nWhen set to `false`, an attempt to establish the connection is made during application startup.\nSee xref:amqp.adoc[AMQP Support] for more information.\n\n[[x4.1-sms-copy-on-get]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "AMQP Outbound Endpoints", "heading_level": 3, "file_order": 173, "section_index": 12, "content_hash": "205e99e3f76dc8b8a713c2f6ab2d180247d76dec5910e4191b0e37f3137555b1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:8bcbce7aef4760c758a8a3db2ace9a90f1b8f5f1ec8d1eeae8f8d99bf3aa1e45", "content": "The `SimpleMessageStore` no longer makes a copy of the group when calling `getMessageGroup()`.\nSee xref:message-store.adoc#sms-caution[[WARNING]] for more information.\n\n[[x4.1-ws-encode-uri]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "SimpleMessageStore", "heading_level": 3, "file_order": 173, "section_index": 13, "content_hash": "8bcbce7aef4760c758a8a3db2ace9a90f1b8f5f1ec8d1eeae8f8d99bf3aa1e45", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:fdfb6416c41559a6c376e7708284abda240b5ea8ca49c2db6381697a8e129fb4", "content": "The `<ws:outbound-gateway/>` now provides an `encode-uri` attribute to allow disabling the encoding of the URI object before sending the request.\n\n[[x4.1-http-status-code]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Web Service Outbound Gateway: `encode-uri`", "heading_level": 3, "file_order": 173, "section_index": 14, "content_hash": "fdfb6416c41559a6c376e7708284abda240b5ea8ca49c2db6381697a8e129fb4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:7a5802a9fdb7612a3c865da44e6f5b48dab567e0e3a03f104f1749a72262fa88", "content": "The `<http:inbound-channel-adapter>` can now be configured with a `status-code-expression` to override the default `200 OK` status.\nSee xref:http/namespace.adoc[HTTP Namespace Support] for more information.\n\n[[x4.1-mqtt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Http Inbound Channel Adapter and Status Code", "heading_level": 3, "file_order": 173, "section_index": 15, "content_hash": "7a5802a9fdb7612a3c865da44e6f5b48dab567e0e3a03f104f1749a72262fa88", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:ad91db8bdd575fb40f4123b7f67a915bc170bc6b6f46293d838f4891e88ccb81", "content": "You can now configure the MQTT channel adapters to connect to multiple servers -- for example, to support High Availability (HA).\nSee xref:mqtt.adoc[MQTT Support] for more information.\n\nThe MQTT message-driven channel adapter now supports specifying the QoS setting for each subscription.\nSee xref:mqtt.adoc#mqtt-inbound[Inbound (Message-driven) Channel Adapter] for more information.\n\nThe MQTT outbound channel adapter now supports asynchronous sends, avoiding blocking until delivery is confirmed.\nSee xref:mqtt.adoc#mqtt-outbound[Outbound Channel Adapter] for more information.\n\nIt is now possible to programmatically subscribe to and unsubscribe from topics at runtime.\nSee xref:mqtt.adoc#mqtt-inbound[Inbound (Message-driven) Channel Adapter] for more information.\n\n[[x4.1-sftp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "MQTT Adapter Changes", "heading_level": 3, "file_order": 173, "section_index": 16, "content_hash": "ad91db8bdd575fb40f4123b7f67a915bc170bc6b6f46293d838f4891e88ccb81", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:fc0e5ceebb480675328ee35317b2c1816ec57525895324946cf1c5c0751df8b1", "content": "The FTP and SFTP outbound channel adapters now support appending to remote files and taking specific actions when a remote file already exists.\nThe remote file templates now also supports this, as well as `rmdir()` and `exists()`.\nIn addition, the remote file templates provide access to the underlying client object, enabling access to low-level APIs.\n\nSee xref:ftp.adoc[FTP/FTPS Adapters] and xref:sftp.adoc[SFTP Adapters] for more information.\n\n[[x4.1-splitter-iterator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "FTP and SFTP Adapter Changes", "heading_level": 3, "file_order": 173, "section_index": 17, "content_hash": "fc0e5ceebb480675328ee35317b2c1816ec57525895324946cf1c5c0751df8b1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:b2d9edda534d549ecd538fdcd7ae914136aa2ebb52d61b6282e44a3dfd97fd3e", "content": "`Splitter` components now support an `Iterator` as the result object for producing output messages.\nSee xref:splitter.adoc[Splitter] for more information.\n\n[[x4.1-aggregator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Splitter and Iterator", "heading_level": 3, "file_order": 173, "section_index": 18, "content_hash": "b2d9edda534d549ecd538fdcd7ae914136aa2ebb52d61b6282e44a3dfd97fd3e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:c67cc254fa81733a015b64da0e5107bc73f26eb2b2b8172d9d2d2c3d8701f7f1", "content": "`Aggregator` instancess now support a new attribute `expire-groups-upon-timeout`.\nSee xref:overview.adoc#overview-endpoints-aggregator[Aggregator] for more information.\n\n[[x4.1-content-enricher-improvement]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Aggregator", "heading_level": 3, "file_order": 173, "section_index": 19, "content_hash": "c67cc254fa81733a015b64da0e5107bc73f26eb2b2b8172d9d2d2c3d8701f7f1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:bee99f61ae23c13129a539fb18596e5aa881edb0a2a8958c88d610980493c25a", "content": "We added a `null-result-expression` attribute, which is evaluated and returned if `<enricher>` returns `null`.\nYou can add it in `<header>` and `<property>`.\nSee xref:content-enrichment.adoc[Content Enricher] for more information.\n\nWe added an `error-channel` attribute, which is used to handle an error flow if an `Exception` occurs downstream of the `request-channel`.\nThis lets you return an alternative object to use for enrichment.\nSee xref:content-enrichment.adoc[Content Enricher] for more information.\n\n[[x4.1-header-channel-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Content Enricher Improvements", "heading_level": 3, "file_order": 173, "section_index": 20, "content_hash": "bee99f61ae23c13129a539fb18596e5aa881edb0a2a8958c88d610980493c25a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:e36bd0f9ffd8540448eec964193344e3d17315fd7e8ff185cca10f84d840abe1", "content": "The `<header-enricher/>` element's `<header-channels-to-string/>` child element can now override the header channel registry's default time for retaining channel mappings.\nSee xref:content-enrichment.adoc#header-channel-registry[Header Channel Registry] for more information.\n\n[[x4.1-orderly-shutdown]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Header Channel Registry", "heading_level": 3, "file_order": 173, "section_index": 21, "content_hash": "e36bd0f9ffd8540448eec964193344e3d17315fd7e8ff185cca10f84d840abe1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:3c71f3ee6d7ecd40f78c67ffa9cb612cd31482bd9cab4e5cc57c34bbba5b25a3", "content": "We made improvements to the orderly shutdown algorithm.\nSee xref:shutdown.adoc[Orderly Shutdown] for more information.\n\n[[x4.1-recipientListRouter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Orderly Shutdown", "heading_level": 3, "file_order": 173, "section_index": 22, "content_hash": "3c71f3ee6d7ecd40f78c67ffa9cb612cd31482bd9cab4e5cc57c34bbba5b25a3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:9936e668a6299af863938240a224c6ac149838b7c68131238eb69ab64803b802", "content": "The `RecipientListRouter` now provides several management operations to configure recipients at runtime.\nWith that, you can now configure the `<recipient-list-router>` without any `<recipient>` from the start.\nSee xref:router/implementations.adoc#recipient-list-router-management[`RecipientListRouterManagement`] for more information.\n\n[[x4.1-AbstractHeaderMapper-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Management for `RecipientListRouter`", "heading_level": 3, "file_order": 173, "section_index": 23, "content_hash": "9936e668a6299af863938240a224c6ac149838b7c68131238eb69ab64803b802", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:6e306b82e6f102eb269234c34fad144952262f4c2193a11ed0d2f19bfe9a5553", "content": "The `AbstractHeaderMapper` implementation now provides the additional `NON_STANDARD_HEADERS` token to map any user-defined headers, which are not mapped by default.\nSee xref:amqp/message-headers.adoc[AMQP Message Headers] for more information.\n\n[[x4.1-amqp-channels]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "AbstractHeaderMapper: NON_STANDARD_HEADERS token", "heading_level": 3, "file_order": 173, "section_index": 24, "content_hash": "6e306b82e6f102eb269234c34fad144952262f4c2193a11ed0d2f19bfe9a5553", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:4738e25fad31f61d8437b96f67a45335c311fbb3e7d4a0b4daf5122f237e3a55", "content": "We introduced the `template-channel-transacted` attribute for AMQP `MessageChannel` instances.\nSee xref:amqp/channels.adoc[AMQP-backed Message Channels] for more information.\n\n[[x4.1-syslog]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "AMQP Channels: `template-channel-transacted`", "heading_level": 3, "file_order": 173, "section_index": 25, "content_hash": "4738e25fad31f61d8437b96f67a45335c311fbb3e7d4a0b4daf5122f237e3a55", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:e7e818cfba13ddfe2149abc48c339ac814b80307d339370be1398c65d8247cba", "content": "The default syslog message converter now has an option to retain the original message in the payload while still setting the headers.\nSee xref:syslog.adoc#syslog-inbound-adapter[Syslog Inbound Channel Adapter] for more information.\n\n[[x4.1-async-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Syslog Adapter", "heading_level": 3, "file_order": 173, "section_index": 26, "content_hash": "e7e818cfba13ddfe2149abc48c339ac814b80307d339370be1398c65d8247cba", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:81622a4abcf3a7f13ac80ddc59b1a9d2db89d1a133542e5ddbb08d0c55939d07", "content": "In addition to the `Promise` return type xref:changes-4.0-4.1.adoc#x4.1-promise-gateway[mentioned earlier], gateway methods may now return a `ListenableFuture`, introduced in Spring Framework 4.0.\nYou can also disable asynchronous processing in the gateway, letting a downstream flow directly return a `Future`.\nSee xref:jms.adoc#jms-async-gateway[Asynchronous Gateway].\n\n[[x4.1-aggregator-advice-chain]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Asynchronous Gateway", "heading_level": 3, "file_order": 173, "section_index": 27, "content_hash": "81622a4abcf3a7f13ac80ddc59b1a9d2db89d1a133542e5ddbb08d0c55939d07", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:15c0c81de900e737cad9bed6966b1422e5efa4d5bb4a60260e0dedf08dc9c1a1", "content": "`Aggregator` and `Resequencer` now support `<expire-advice-chain/>` and `<expire-transactional/>` child elements to advise the `forceComplete` operation.\nSee xref:aggregator.adoc#aggregator-xml[Configuring an Aggregator with XML] for more information.\n\n[[x4.1-script-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Aggregator Advice Chain", "heading_level": 3, "file_order": 173, "section_index": 28, "content_hash": "15c0c81de900e737cad9bed6966b1422e5efa4d5bb4a60260e0dedf08dc9c1a1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:b252f1ab3d87d02313861d62d2d6ee08d9017ab08a3afde7615d0243bb73d096", "content": "The `<int:outbound-channel-adapter/>` now supports the `<script/>` child element.\nThe underlying script must have a `void` return type or return `null`.\nSee xref:groovy.adoc[Groovy support] and xref:scripting.adoc[Scripting Support].\n\n[[x4.1-reseq]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Outbound Channel Adapter and Scripts", "heading_level": 3, "file_order": 173, "section_index": 29, "content_hash": "b252f1ab3d87d02313861d62d2d6ee08d9017ab08a3afde7615d0243bb73d096", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:a1e67c96eb3e286a518e354d366de540d514729a1a45296f9d00ce11860bf2a6", "content": "When a message group in a resequencer times out (using `group-timeout` or a `MessageGroupStoreReaper`), late arriving messages are now, by default, discarded immediately.\nSee xref:resequencer.adoc[Resequencer].\n\n[[x4.1-Optional-Parameter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Resequencer Changes", "heading_level": 3, "file_order": 173, "section_index": 30, "content_hash": "a1e67c96eb3e286a518e354d366de540d514729a1a45296f9d00ce11860bf2a6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:79d52e4eec7cc2b943089418f53e60015ba4630adb98c48b73d84c1bb87d7baa", "content": "Spring Integration now consistently handles the Java 8's `Optional` type.\nSee xref:service-activator.adoc#service-activator-namespace[Configuring Service Activator].\n\n[[x4.1-queue-channel-queue.typ]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "Optional POJO method parameter", "heading_level": 3, "file_order": 173, "section_index": 31, "content_hash": "79d52e4eec7cc2b943089418f53e60015ba4630adb98c48b73d84c1bb87d7baa", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:9aaf3903df365a94b557c6066790bf8c1554230fd105f183fc51f8cc674d412a", "content": "The `QueueChannel` backed `Queue type` has been changed from `BlockingQueue` to the more generic `Queue`.\nThis change allows the use of any external `Queue` implementation (for example, Reactor's `PersistentQueue`).\nSee xref:channel/configuration.adoc#channel-configuration-queuechannel[`QueueChannel` Configuration].\n\n[[x4.1-channel-interceptor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "`QueueChannel` backed Queue type", "heading_level": 3, "file_order": 173, "section_index": 32, "content_hash": "9aaf3903df365a94b557c6066790bf8c1554230fd105f183fc51f8cc674d412a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:857a1dba9b84e60868e3fae3650bd20f3649d93caa85926f346d802ac116a0bf", "content": "The `ChannelInterceptor` now supports additional `afterSendCompletion()` and `afterReceiveCompletion()` methods.\nSee xref:channel/interceptors.adoc[Channel Interceptors].\n\n[[x4.1-mail-peek]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "`ChannelInterceptor` Changes", "heading_level": 3, "file_order": 173, "section_index": 33, "content_hash": "857a1dba9b84e60868e3fae3650bd20f3649d93caa85926f346d802ac116a0bf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:ca03c5bcf1d576ea5be6d0dbeba64414cf219d4c54b9de5bb9d37e2d1f5fff30", "content": "Since version 4.1.1 there is a change of behavior if you explicitly set the `mail.[protocol].peek` JavaMail property to `false` (where `[protocol]` is `imap` or `imaps`).\nSee xref:changes-4.0-4.1.adoc#x4.1-mail-peek[[IMPORTANT]].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.0-4.1.adoc", "title": "changes-4.0-4.1", "heading": "IMAP PEEK", "heading_level": 3, "file_order": 173, "section_index": 34, "content_hash": "ca03c5bcf1d576ea5be6d0dbeba64414cf219d4c54b9de5bb9d37e2d1f5fff30", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.0-4.1.adoc"}}
{"id": "sha256:235bc5e4d4a5659d6e2081131332dd4df92401d6c18ab796017ca5dc52b402b1", "content": "[[migration-4.1-4.2]]\n\nSee the https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-4.1-to-4.2-Migration-Guide[Migration Guide] for important changes that might affect your applications.\nYou can find migration guides for all versions back to 2.1 on the https://github.com/spring-projects/spring-integration/wiki[wiki].\n\n[[x4.2-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "changes-4.1-4.2", "heading_level": 1, "file_order": 174, "section_index": 0, "content_hash": "235bc5e4d4a5659d6e2081131332dd4df92401d6c18ab796017ca5dc52b402b1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:a3422fb5522bff17abf1031c1a4171a77ed3168c63f0b6a892eedc4bc55ef548", "content": "Version 4.2 added a number of new components.\n\n[[x4.2-JMX]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "New Components", "heading_level": 2, "file_order": 174, "section_index": 1, "content_hash": "a3422fb5522bff17abf1031c1a4171a77ed3168c63f0b6a892eedc4bc55ef548", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:31a1f2ce71089ef8b99ece704a92c52eeb3840de1169016f1e87f9e3cf5549cd", "content": "We added a new `MetricsFactory` strategy interface.\nThis change, together with other changes in the JMX and management infrastructure, provides much more control over management configuration and runtime performance.\n\nHowever, this has some important implications for (some) user environments.\n\nFor complete details, see xref:metrics.adoc[Metrics and Management] and xref:jmx.adoc#jmx-42-improvements[JMX Improvements].\n\n[[x4.2-mongodb-metadata-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Major Management/JMX Rework", "heading_level": 3, "file_order": 174, "section_index": 2, "content_hash": "31a1f2ce71089ef8b99ece704a92c52eeb3840de1169016f1e87f9e3cf5549cd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:bdebedccecf6cd1c67527eebe2ef624f8143b53120c4104f07594e2fc533e9d6", "content": "The `MongoDbMetadataStore` is now available.\nFor more information, see xref:mongodb.adoc#mongodb-metadata-store[MongoDB Metadata Store].\n\n[[x4.2-secured-channel-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "MongoDB Metadata Store", "heading_level": 3, "file_order": 174, "section_index": 3, "content_hash": "bdebedccecf6cd1c67527eebe2ef624f8143b53120c4104f07594e2fc533e9d6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:90d080293a1f8718a62faa57bf61fc5e1180032c009d68fccc5d1a4992936ed0", "content": "We introduced the `@SecuredChannel` annotation, replacing the deprecated `ChannelSecurityInterceptorFactoryBean`.\nFor more information, see xref:security.adoc[Security in Spring Integration].\n\n[[x4.2-security-context-propagation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "SecuredChannel Annotation", "heading_level": 3, "file_order": 174, "section_index": 4, "content_hash": "90d080293a1f8718a62faa57bf61fc5e1180032c009d68fccc5d1a4992936ed0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:f0d6d49015fa3bd33eff79f734a7666f5f4ad555bd42757dc4f9725c4bf80da0", "content": "We introduced the `SecurityContextPropagationChannelInterceptor` for the `SecurityContext` propagation from one message flow's thread to another.\nFor more information, see xref:security.adoc[Security in Spring Integration].\n\n[[x4.2-file-splitter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "`SecurityContext` Propagation", "heading_level": 3, "file_order": 174, "section_index": 5, "content_hash": "f0d6d49015fa3bd33eff79f734a7666f5f4ad555bd42757dc4f9725c4bf80da0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:53e0385635006d0a47f2d65a1be1f44a581287e15f018ac78b796eea6ee11040", "content": "In 4.1.2, we added `FileSplitter`, which splits text files into lines.\nIt now has full support in the `int-file:` namespace.\nSee xref:file/splitter.adoc[File Splitter] for more information.\n\n[[x4.2-zk]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "FileSplitter", "heading_level": 3, "file_order": 174, "section_index": 6, "content_hash": "53e0385635006d0a47f2d65a1be1f44a581287e15f018ac78b796eea6ee11040", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:aedb84fad70916653629094094654ea22ec7ddf94f0401a33084cde36d3d8efc", "content": "We added Zookeeper support to the framework to assist when running on a clustered or multi-host environment.\nThe change impacts the following features:\n\n* `ZookeeperMetadataStore`\n* `ZookeeperLockRegistry`\n* Zookeeper Leadership\n\nSee xref:zookeeper.adoc[Zookeeper Support] for more information.\n\n[[x4.2-barrier]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Zookeeper Support", "heading_level": 3, "file_order": 174, "section_index": 7, "content_hash": "aedb84fad70916653629094094654ea22ec7ddf94f0401a33084cde36d3d8efc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:9702150e9fcc06676550656348d25d76eed5b8fb65acf4c5e326e2c6575a5e23", "content": "A new thread `<int:barrier/>` component is available, letting a thread be suspended until some asynchronous event occurs.\nSee xref:barrier.adoc[Thread Barrier] for more information.\n\n[[x4.2-stomp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Thread Barrier", "heading_level": 3, "file_order": 174, "section_index": 8, "content_hash": "9702150e9fcc06676550656348d25d76eed5b8fb65acf4c5e326e2c6575a5e23", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:253ef549530ee327ade361cc414a23b1b4a0e7d929d5ba227fbf291a2e249839", "content": "We added STOMP support to the framework as an inbound and outbound channel adapters pair.\nSee xref:stomp.adoc[STOMP Support] for more information.\n\n[[x4.2-codec]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "STOMP Support", "heading_level": 3, "file_order": 174, "section_index": 9, "content_hash": "253ef549530ee327ade361cc414a23b1b4a0e7d929d5ba227fbf291a2e249839", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:559d9e6d145e7c3b346b578e6cdcbe9d8b9469938965a46a94f02a2a15562f6c", "content": "A new `Codec` abstraction has been introduced, to encode and decode objects to and from `byte[]`.\nWe added an implementation that uses Kryo.\nWe also added codec-based transformers and message converters.\nSee xref:codec.adoc[Codec] for more information.\n\n[[x4.2-prepared-statement-setter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Codec", "heading_level": 3, "file_order": 174, "section_index": 10, "content_hash": "559d9e6d145e7c3b346b578e6cdcbe9d8b9469938965a46a94f02a2a15562f6c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:bfa68f1e4684539c89799c0451d633e0f62d55da9acbf45eb249b961ce904e2d", "content": "A new `MessagePreparedStatementSetter` functional interface callback is available for the `JdbcMessageHandler` (`<int-jdbc:outbound-gateway>` and `<int-jdbc:outbound-channel-adapter>`) as an alternative to using `SqlParameterSourceFactory` to populate parameters on the `PreparedStatement` with the `requestMessage` context.\nSee xref:jdbc/outbound-channel-adapter.adoc[Outbound Channel Adapter] for more information.\n\n[[x4.2-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Message PreparedStatement Setter", "heading_level": 3, "file_order": 174, "section_index": 11, "content_hash": "bfa68f1e4684539c89799c0451d633e0f62d55da9acbf45eb249b961ce904e2d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:6ee490214a8ecaf9b11fd21743df27f6286d7e6bafd33dd00ae9c9c4363d15e1", "content": "This section describes general changes from version 4.1 to version 4.2.\n\n[[x4.2-wire-tap]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "General Changes", "heading_level": 2, "file_order": 174, "section_index": 12, "content_hash": "6ee490214a8ecaf9b11fd21743df27f6286d7e6bafd33dd00ae9c9c4363d15e1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:1ae169bf09acbfe3c92cb184ceef40d0a565d013647fa9a13f742b223e2d159b", "content": "As an alternative to the existing `selector` attribute, the `<wire-tap/>` element now supports the `selector-expression` attribute.\n\n[[x4.2-file-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "WireTap", "heading_level": 3, "file_order": 174, "section_index": 13, "content_hash": "1ae169bf09acbfe3c92cb184ceef40d0a565d013647fa9a13f742b223e2d159b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:1a98d550bd57fb646102e364e9b6c2872aec199ff67b6c1e3b1600fe5617fd39", "content": "See xref:file.adoc[File Support] for more information about these changes.\n\n[[appending-new-lines]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "File Changes", "heading_level": 3, "file_order": 174, "section_index": 14, "content_hash": "1a98d550bd57fb646102e364e9b6c2872aec199ff67b6c1e3b1600fe5617fd39", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:fe7dbe602295f32f0f4edd5c6df8ef52d47f944a6f4448cd15eecd64a62f1242", "content": "The `<int-file:outbound-channel-adapter>` and `<int-file:outbound-gateway>` now support an `append-new-line` attribute.\nIf set to `true`, a new line is appended to the file after a message is written.\nThe default attribute value is `false`.\n\n[[ignoring-hidden-files]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Appending New Lines", "heading_level": 4, "file_order": 174, "section_index": 15, "content_hash": "fe7dbe602295f32f0f4edd5c6df8ef52d47f944a6f4448cd15eecd64a62f1242", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:167602ef421d5f2653340155ce0e818ebffcf7d1802ddc28e1be887a2ca89ea3", "content": "We added the `ignore-hidden` attribute for the `<int-file:inbound-channel-adapter>` to let you set whether to pick up hidden files from the source directory.\nIt defaults to `true`.\n\n[[writing-inputstream-payloads]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Ignoring Hidden Files", "heading_level": 4, "file_order": 174, "section_index": 16, "content_hash": "167602ef421d5f2653340155ce0e818ebffcf7d1802ddc28e1be887a2ca89ea3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:ff4c0704a0543f94e69aeca8104417e581304800954f35f73497196607690705", "content": "The `FileWritingMessageHandler` now also accepts `InputStream` as a valid message payload type.\n\n[[headdirectoryscanner]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Writing `InputStream` Payloads", "heading_level": 4, "file_order": 174, "section_index": 17, "content_hash": "ff4c0704a0543f94e69aeca8104417e581304800954f35f73497196607690705", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:fb1b285b65d864feeb35cfe5f41470e7686f01c5d743a2dabecc72b02579493d", "content": "You can now use the `HeadDirectoryScanner` with other `FileListFilter` implementations.\n\n[[last-modified-filter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "`HeadDirectoryScanner`", "heading_level": 4, "file_order": 174, "section_index": 18, "content_hash": "fb1b285b65d864feeb35cfe5f41470e7686f01c5d743a2dabecc72b02579493d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:69d89f1a44a2c9761c2e0cbba968a9576262ebe9aef74aac59c8e0fc1927c6a7", "content": "We added the `LastModifiedFileListFilter`.\n\n[[watch-service-directory-scanner]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Last Modified Filter", "heading_level": 4, "file_order": 174, "section_index": 19, "content_hash": "69d89f1a44a2c9761c2e0cbba968a9576262ebe9aef74aac59c8e0fc1927c6a7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:43f8bafa7cbcdf885bb5b44ee065b975c82cba2d9f6035b0b78f4d6a0e305a6f", "content": "We added the `WatchServiceDirectoryScanner`.\n\n[[persistent-file-list-filter-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Watch Service Directory Scanner", "heading_level": 4, "file_order": 174, "section_index": 20, "content_hash": "43f8bafa7cbcdf885bb5b44ee065b975c82cba2d9f6035b0b78f4d6a0e305a6f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:56e78883592e489e17f0434fc8c2b215970c08b3ad18774a8022856181927033", "content": "The `AbstractPersistentFileListFilter` has a new property (`flushOnUpdate`) which, when set to `true`, calls `flush()` on the metadata store if it implements `Flushable` (for example, `PropertiesPersistingMetadataStore`).\n\n[[x4.2-class-package-change]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Persistent File List Filter Changes", "heading_level": 4, "file_order": 174, "section_index": 21, "content_hash": "56e78883592e489e17f0434fc8c2b215970c08b3ad18774a8022856181927033", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:89eaa961d91f4448b38a9df14266fd1d6336db9bb567c6abdec197740ed8d196", "content": "We moved the `ScatterGatherHandler` class from the `org.springframework.integration.handler` to the `org.springframework.integration.scattergather`.\n\n[[tcp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Class Package Change", "heading_level": 3, "file_order": 174, "section_index": 22, "content_hash": "89eaa961d91f4448b38a9df14266fd1d6336db9bb567c6abdec197740ed8d196", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:f8da6b9530fc710d9ebe96c3270b9572a312933cbd46835dc9dfec74e24f70c2", "content": "This section describes general changes to the Spring Integration TCP functionality.\n\n[[x4.2-tcp-serializers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "TCP Changes", "heading_level": 3, "file_order": 174, "section_index": 23, "content_hash": "f8da6b9530fc710d9ebe96c3270b9572a312933cbd46835dc9dfec74e24f70c2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:a0a8c6b5d8f8b54dc1cba449a156bf22bf860ec767e4fef12b1faca918d5bff4", "content": "The TCP `Serializers` no longer `flush()` the `OutputStream`.\nThis is now done by the `TcpNxxConnection` classes.\nIf you use the serializers directly within your code, you may have to `flush()` the `OutputStream`.\n\n[[x4.2-tcp-server-exceptions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "TCP Serializers", "heading_level": 4, "file_order": 174, "section_index": 24, "content_hash": "a0a8c6b5d8f8b54dc1cba449a156bf22bf860ec767e4fef12b1faca918d5bff4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:89c4fa31ad16242b0eb6bf08f8f5eea20fbd94cdb8901fd2cd10c84ae04f1f0c", "content": "`TcpConnectionServerExceptionEvent` instances are now published whenever an unexpected exception occurs on a TCP server socket (also added to 4.1.3 and 4.0.7).\nSee xref:changes-4.1-4.2.adoc#x4.2-tcp-events[TCP Connection Events] for more information.\n\n[[x4.2-tcp-server-port]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Server Socket Exceptions", "heading_level": 4, "file_order": 174, "section_index": 25, "content_hash": "89c4fa31ad16242b0eb6bf08f8f5eea20fbd94cdb8901fd2cd10c84ae04f1f0c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:b5201a2f74e44b4c03cf3d09e2f841d41baa5694ba5be27f76a1a02b06be1574", "content": "If you configure a TCP server socket factory to listen on a random port, you can now obtain the actual port chosen by the OS by using `getPort()`.\n`getServerSocketAddress()` is also available.\n\nSee \"xref:ip/tcp-connection-factories.adoc[TCP Connection Factories]\" for more information.\n\n[[x4.2-tcp-gw-rto]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "TCP Server Port", "heading_level": 4, "file_order": 174, "section_index": 26, "content_hash": "b5201a2f74e44b4c03cf3d09e2f841d41baa5694ba5be27f76a1a02b06be1574", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:72de6df24bb45ffe14c4e56310d46e84c3df3970549038bfb520900ed02143d8", "content": "The `TcpOutboundGateway` now supports `remote-timeout-expression` as an alternative to the existing `remote-timeout` attribute.\nThis allows setting the timeout based on each message.\n\nAlso, the `remote-timeout` no longer defaults to the same value as `reply-timeout`, which has a completely different meaning.\n\nSee xref:ip/endpoint-reference.adoc#tcp-ob-gateway-attributes[.TCP Outbound Gateway Attributes] for more information.\n\n[[x4.2-tcp-ssl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "TCP Gateway Remote Timeout", "heading_level": 4, "file_order": 174, "section_index": 27, "content_hash": "72de6df24bb45ffe14c4e56310d46e84c3df3970549038bfb520900ed02143d8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:aec99793c2dbc3020604df488290c8b27e3e920b64d6a1ca798109b7d5150371", "content": "`TcpConnection` implementations now support `getSslSession()` to let you extract information from the session to add to message headers.\nSee xref:ip/msg-headers.adoc[IP Message Headers] for more information.\n\n[[x4.2-tcp-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "TCP SSLSession Available for Header Mapping", "heading_level": 4, "file_order": 174, "section_index": 28, "content_hash": "aec99793c2dbc3020604df488290c8b27e3e920b64d6a1ca798109b7d5150371", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:a63a2a0e7ffc17b222d848381cfb2b884f80d03257df2e21ef3d204ad0e18246", "content": "New events are now published whenever a correlation exception occurs -- such as sending a message to a non-existent socket.\n\nThe `TcpConnectionEventListeningMessageProducer` is deprecated.\nUse the generic event adapter instead.\n\nSee xref:changes-4.1-4.2.adoc#x4.2-tcp-events[TCP Connection Events] for more information.\n\n[[x4.2-inbound-channel-adapter-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "TCP Events", "heading_level": 4, "file_order": 174, "section_index": 29, "content_hash": "a63a2a0e7ffc17b222d848381cfb2b884f80d03257df2e21ef3d204ad0e18246", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:a3f0bb6fcae5323699863f9cac7b1e8057c6438f41c507a94070053fd96ff4b0", "content": "Previously, the `@Poller` on an inbound channel adapter defaulted the `maxMessagesPerPoll` attribute to `-1` (infinity).\nThis was inconsistent with the XML configuration of `<inbound-channel-adapter/>`, which defaults to `1`.\nThe annotation now defaults this attribute to `1`.\n\n[[x4.2-api-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "`@InboundChannelAdapter` Changes", "heading_level": 3, "file_order": 174, "section_index": 30, "content_hash": "a3f0bb6fcae5323699863f9cac7b1e8057c6438f41c507a94070053fd96ff4b0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:46aae974a0126e5106d376b9a2e1a0e46ad53ecee5d77ae3f7aa874cc05d1788", "content": "`o.s.integration.util.FunctionIterator` now requires a `o.s.integration.util.Function` instead of a `reactor.function.Function`.\nThis was done to remove an unnecessary hard dependency on Reactor.\nAny uses of this iterator need to change the import.\n\nReactor is still supported for functionality such as the `Promise` gateway.\nThe dependency was removed for those users who do not need it.\n\n[[x4.2-jms-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "API Changes", "heading_level": 3, "file_order": 174, "section_index": 31, "content_hash": "46aae974a0126e5106d376b9a2e1a0e46ad53ecee5d77ae3f7aa874cc05d1788", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:210156db6bb8cb8ec0141bbeef5cc6748d2fcf64a80edfd4965f827748887546", "content": "This section describes general changes to the Spring Integration TCP functionality.\n\n[[reply-listener-lazy-initialization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "JMS Changes", "heading_level": 3, "file_order": 174, "section_index": 32, "content_hash": "210156db6bb8cb8ec0141bbeef5cc6748d2fcf64a80edfd4965f827748887546", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:9dee2097fdd02c9c09bf1a02d23d91af3f3cd65e26c26da5cc915779c2722fb7", "content": "You can now configure the reply listener in JMS outbound gateways to be initialized on-demand and stopped after an idle period, instead of being controlled by the gateway's lifecycle.\nSee xref:jms.adoc#jms-outbound-gateway[Outbound Gateway] for more information.\n\n[[conversion-errors-in-message-driven-endpoints]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Reply Listener Lazy Initialization", "heading_level": 4, "file_order": 174, "section_index": 33, "content_hash": "9dee2097fdd02c9c09bf1a02d23d91af3f3cd65e26c26da5cc915779c2722fb7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:3dcdc669f5b893df62d12129ef5324e80a488ba8a5bded6b0197fff8b16ef5a9", "content": "The `error-channel` is now used for the conversion errors.\nIn previous versions, they caused transaction rollback and message redelivery.\n\nSee xref:changes-2.2-3.0.adoc#x3.0-jms-mdca-te[Message-driven Channel Adapter] and xref:jms.adoc#jms-inbound-gateway[Inbound Gateway] for more information.\n\n[[default-acknowledge-mode]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Conversion Errors in Message-Driven Endpoints", "heading_level": 4, "file_order": 174, "section_index": 34, "content_hash": "3dcdc669f5b893df62d12129ef5324e80a488ba8a5bded6b0197fff8b16ef5a9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:31acb05f9908402c231e345f16fa94da47e10951dfefc41f1441d7ad600d1cdf", "content": "When using an implicitly defined `DefaultMessageListenerContainer`, the default `acknowledge` is now `transacted`.\nWe recommend using `transacted` when using this container, to avoid message loss.\nThis default now applies to the message-driven inbound adapter and the inbound gateway.\nIt was already the default for JMS-backed channels.\n\nSee xref:changes-2.2-3.0.adoc#x3.0-jms-mdca-te[Message-driven Channel Adapter] and xref:jms.adoc#jms-inbound-gateway[Inbound Gateway] for more information.\n\n[[shared-subscriptions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Default Acknowledge Mode", "heading_level": 4, "file_order": 174, "section_index": 35, "content_hash": "31acb05f9908402c231e345f16fa94da47e10951dfefc41f1441d7ad600d1cdf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:79e3c950cc72ddddd9aaa28d0aa7fc4d67f44c913d8a3dbcfdeff9f24aff09f2", "content": "We added Namespace support for shared subscriptions (JMS 2.0) to message-driven endpoints and the `<int-jms:publish-subscribe-channel>`.\nPreviously, you had to wire up listener containers as `<bean/>` declarations to use shared connections.\n\nSee xref:jms.adoc[JMS Support] for more information.\n\n[[x4.2-conditional-pollers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Shared Subscriptions", "heading_level": 4, "file_order": 174, "section_index": 36, "content_hash": "79e3c950cc72ddddd9aaa28d0aa7fc4d67f44c913d8a3dbcfdeff9f24aff09f2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:294ff8b056c94860bfe455c36f53b3fa6166ed3287a7bfeb2af6b71a46b39c19", "content": "We now provide much more flexibility for dynamic polling.\n\nSee xref:changes-4.1-4.2.adoc#x4.2-conditional-pollers[Conditional Pollers for Message Sources] for more information.\n\n[[x4.2-amqp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Conditional Pollers", "heading_level": 3, "file_order": 174, "section_index": 37, "content_hash": "294ff8b056c94860bfe455c36f53b3fa6166ed3287a7bfeb2af6b71a46b39c19", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:37cc7137c76e4564f2ed828b298369ec63460099a9f9e01a2ba69fc27df0bf17", "content": "This section describes general changes to the Spring Integration AMQP functionality.\n\n[[publisher-confirmations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "AMQP Changes", "heading_level": 3, "file_order": 174, "section_index": 38, "content_hash": "37cc7137c76e4564f2ed828b298369ec63460099a9f9e01a2ba69fc27df0bf17", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:9a9e43f267b66888e67c11a0872824c9019c302dd485bf3e7f103275094395f6", "content": "The `<int-amqp:outbound-gateway>` now supports `confirm-correlation-expression`, `confirm-ack-channel`, and `confirm-nack-channel` attributes (which have a purpose similar to that of `<int-amqp:outbound-channel-adapter>`).\n\n[[correlation-data]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Publisher Confirmations", "heading_level": 4, "file_order": 174, "section_index": 39, "content_hash": "9a9e43f267b66888e67c11a0872824c9019c302dd485bf3e7f103275094395f6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:8014143e26c699ef66c8cc393eb05623afd404b34e7e52dca86759b08d34b4ea", "content": "For both the outbound channel adapter and the inbound gateway, if the correlation data is a `Message<?>`, it becomes the basis of the message on the ack or nack channel, with the additional header(s) added.\nPreviously, any correlation data (including `Message<?>`) was returned as the payload of the ack or nack message.\n\n[[inbound-gateway-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Correlation Data", "heading_level": 4, "file_order": 174, "section_index": 40, "content_hash": "8014143e26c699ef66c8cc393eb05623afd404b34e7e52dca86759b08d34b4ea", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:2d5067a2081e00534ec79fa8ea135326157c7ea08f489552c6c379e2240dd441", "content": "The `<int-amqp:inbound-gateway>` now exposes the `amqp-template` attribute to allow more control over an external bean for the reply `RabbitTemplate`.\nYou can also provide your own `AmqpTemplate` implementation.\nIn addition, you can use `default-reply-to` if the request message does not have a `replyTo` property.\n\nSee xref:amqp.adoc[AMQP Support] for more information.\n\n[[x4.2-xpath-splitter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Inbound Gateway Properties", "heading_level": 4, "file_order": 174, "section_index": 41, "content_hash": "2d5067a2081e00534ec79fa8ea135326157c7ea08f489552c6c379e2240dd441", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:c175b40be5f0c3cee25232674d386dcafe5c24a28ca5658df6a26e6937d5002e", "content": "The `XPathMessageSplitter` (`<int-xml:xpath-splitter>`) now allows the configuration of `output-properties` for the internal `javax.xml.transform.Transformer` and supports an `Iterator` mode (defaults to `true`) for the XPath evaluation `org.w3c.dom.NodeList` result.\n\nSee xref:xml/xpath-splitting.adoc[Splitting XML Messages] for more information.\n\n[[x4.2-http-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "XPath Splitter Improvements", "heading_level": 3, "file_order": 174, "section_index": 42, "content_hash": "c175b40be5f0c3cee25232674d386dcafe5c24a28ca5658df6a26e6937d5002e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:6d0525c414d58bec5c85513343ffdf9a4140abd2cdc8799b94f8780ea68d2a0e", "content": "This section describes general changes to the Spring Integration HTTP functionality.\n\n[[cors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "HTTP Changes", "heading_level": 3, "file_order": 174, "section_index": 43, "content_hash": "6d0525c414d58bec5c85513343ffdf9a4140abd2cdc8799b94f8780ea68d2a0e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:acc367523ff4fd5e7f9434690bcc753fa24532e5aa4b2ad7beaeabd14a0907d5", "content": "The HTTP inbound endpoints (`<int-http:inbound-channel-adapter>` and `<int-http:inbound-gateway>`) now allow the\nconfiguration of Cross-origin Resource Sharing (CORS).\n\nSee xref:http/namespace.adoc#http-cors[Cross-origin Resource Sharing (CORS) Support] for more information.\n\n[[inbound-gateway-timeout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "CORS", "heading_level": 4, "file_order": 174, "section_index": 44, "content_hash": "acc367523ff4fd5e7f9434690bcc753fa24532e5aa4b2ad7beaeabd14a0907d5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:4ab9bd86a46aa27554f75bea1311da4c114f62f4627d0547832390fbd9136f0c", "content": "You can configure the HTTP inbound gate way to return a status code that you specify when a request times out.\nThe default is now `500 Internal Server Error` instead of `200 OK`.\n\nSee xref:http/namespace.adoc#http-response-statuscode[Response Status Code] for more information.\n\n[[form-data]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Inbound Gateway Timeout", "heading_level": 4, "file_order": 174, "section_index": 45, "content_hash": "4ab9bd86a46aa27554f75bea1311da4c114f62f4627d0547832390fbd9136f0c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:57080e6df62487f445d42530acb4f9fe946649c27288842fac05bf1f2b88d9b5", "content": "We added documentation for proxying `multipart/form-data` requests.\nSee xref:http.adoc[HTTP Support] for more information.\n\n[[x4.2-gw]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Form Data", "heading_level": 4, "file_order": 174, "section_index": 46, "content_hash": "57080e6df62487f445d42530acb4f9fe946649c27288842fac05bf1f2b88d9b5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:c01e3dd08518d762e6e4b94f76fd38f3ad89220fc17fa49115242ee87b407732", "content": "This section describes general changes to the Spring Integration Gateway functionality.\n\n[[gateway-methods-can-return-completablefuture<?>]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Gateway Changes", "heading_level": 3, "file_order": 174, "section_index": 47, "content_hash": "c01e3dd08518d762e6e4b94f76fd38f3ad89220fc17fa49115242ee87b407732", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:766422780623fe930da23ae526131cf64abc1aeddb8a87df18b2869dc670c9cc", "content": "When using Java 8, gateway methods can now return `CompletableFuture<?>`.\nSee xref:gateway.adoc#gw-completable-future[`CompletableFuture`] for more information.\n\n[[messaginggateway-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Gateway Methods can Return `CompletableFuture<?>`", "heading_level": 4, "file_order": 174, "section_index": 48, "content_hash": "766422780623fe930da23ae526131cf64abc1aeddb8a87df18b2869dc670c9cc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:55d4175b530028f41d057528d1f78fc230f413966d2ba35aebec26347db1b7e2", "content": "The request and reply timeout properties are now `String` instead of `Long` to allow configuration with property placeholders or SpEL.\nSee xref:gateway.adoc#messaging-gateway-annotation[`@MessagingGateway` Annotation].\n\n[[x4.2-aggregator-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "MessagingGateway Annotation", "heading_level": 4, "file_order": 174, "section_index": 49, "content_hash": "55d4175b530028f41d057528d1f78fc230f413966d2ba35aebec26347db1b7e2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:ebb631e45113ba732f5ba9f844284e38b6ada0bb618e4f47967b1a11df2fe1ec", "content": "This section describes general changes to the Spring Integration aggregator functionality.\n\n[[aggregator-performance]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Aggregator Changes", "heading_level": 3, "file_order": 174, "section_index": 50, "content_hash": "ebb631e45113ba732f5ba9f844284e38b6ada0bb618e4f47967b1a11df2fe1ec", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:95ee22d3c1fee1d122f781c416573cb24e4461dd2b76831234ea01994d1f994d", "content": "This release includes some performance improvements for aggregating components (aggregator, resequencer, and others), by more efficiently removing messages from groups when they are released.\nNew methods (`removeMessagesFromGroup`) have been added to the message store.\nSet the `removeBatchSize` property (default: `100`) to adjust the number of messages deleted in each operation.\nCurrently, the JDBC, Redis, and MongoDB message stores support this property.\n\n[[output-message-group-processor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Aggregator Performance", "heading_level": 4, "file_order": 174, "section_index": 51, "content_hash": "95ee22d3c1fee1d122f781c416573cb24e4461dd2b76831234ea01994d1f994d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:77c145bbf2a5bcba1eb4b71bba4a714952071427bb2199416bd45eda80589b79", "content": "When using a `ref` or inner bean for the aggregator, you can now directly bind a `MessageGroupProcessor`.\nIn addition, we added a `SimpleMessageGroupProcessor` that returns the collection of messages in the group.\nWhen an output processor produces a collection of `Message<?>`, the aggregator releases those messages individually.\nConfiguring the `SimpleMessageGroupProcessor` makes the aggregator a message barrier, where messages are held up until they all arrive and are then released individually.\nSee xref:overview.adoc#overview-endpoints-aggregator[Aggregator] for more information.\n\n[[ftp-and-sftp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Output Message Group Processor", "heading_level": 4, "file_order": 174, "section_index": 52, "content_hash": "77c145bbf2a5bcba1eb4b71bba4a714952071427bb2199416bd45eda80589b79", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:2254aab1b308ad9d72581a31b74c064b0d1dacea91e8f7513e0832e86f008716", "content": "This section describes general changes to the Spring Integration FTP and SFTP functionality.\n\n[[inbound-channel-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "FTP and SFTP Changes", "heading_level": 3, "file_order": 174, "section_index": 53, "content_hash": "2254aab1b308ad9d72581a31b74c064b0d1dacea91e8f7513e0832e86f008716", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:cea4c63831325430bb7c7a5b05159aefc65c7e0b021c21a667b7860aea66e880", "content": "You can now specify a `remote-directory-expression` on the inbound channel adapters, to determine the directory at runtime.\nSee xref:ftp.adoc[FTP/FTPS Adapters] and xref:sftp.adoc[SFTP Adapters] for more information.\n\n[[gateway-partial-results]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Inbound Channel Adapters", "heading_level": 4, "file_order": 174, "section_index": 54, "content_hash": "cea4c63831325430bb7c7a5b05159aefc65c7e0b021c21a667b7860aea66e880", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:a8d831051cad899bb7b06caaaf11d3f498d265ac6910c2a9e28c21259880651c", "content": "When you use FTP or SFTP outbound gateways to operate on multiple files (with `mget` and `mput`), an exception can\noccur after part of the request is completed.\nIf such a condition occurs, a `PartialSuccessException` that contains the partial results is thrown.\nSee xref:ftp/outbound-gateway.adoc[FTP Outbound Gateway] and xref:sftp/outbound-gateway.adoc[SFTP Outbound Gateway] for more information.\n\n[[delegating-session-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Gateway Partial Results", "heading_level": 4, "file_order": 174, "section_index": 55, "content_hash": "a8d831051cad899bb7b06caaaf11d3f498d265ac6910c2a9e28c21259880651c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:8522f60c85ce1bcae2873885614584ba68b8ffa646cf5f0745e9a0502a1a1204", "content": "We added a delegating session factory, enabling the selection of a particular session factory based on some thread context value.\n\nSee xref:ftp/dsf.adoc[Delegating Session Factory] and xref:sftp/dsf.adoc[Delegating Session Factory] for more information.\n\n[[default-sftp-session-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Delegating Session Factory", "heading_level": 4, "file_order": 174, "section_index": 56, "content_hash": "8522f60c85ce1bcae2873885614584ba68b8ffa646cf5f0745e9a0502a1a1204", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:b97bfbde09883bb1cdb7b12342d7f0aa8513276d642f9aa7e55fa9814b16b8f3", "content": "Previously, the `DefaultSftpSessionFactory` unconditionally allowed connections to unknown hosts.\nThis is now configurable (default: `false`).\n\nThe factory now requires a configured `knownHosts`, file unless the `allowUnknownKeys` property is `true` (default: `false`).\n\nSee xref:sftp/session-factory.adoc#sftp-unk-keys[`allowUnknownKeys`::Set to `true` to allow connections to hosts with unknown (or changed) keys.] for more information.\n\n[[message-session-callback]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Default Sftp Session Factory", "heading_level": 4, "file_order": 174, "section_index": 57, "content_hash": "b97bfbde09883bb1cdb7b12342d7f0aa8513276d642f9aa7e55fa9814b16b8f3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:d8d3101ca157d2b71e87626d659c1b7bea09d789240215e055a4ec9e15b0ae6c", "content": "We introduced the `MessageSessionCallback<F, T>` to perform any custom `Session` operations with the `requestMessage` context in the `<int-(s)ftp:outbound-gateway/>`.\n\nSee xref:ftp/session-callback.adoc[Using `MessageSessionCallback`] and xref:sftp/session-callback.adoc[MessageSessionCallback] for more information.\n\n[[websocket-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Message Session Callback", "heading_level": 4, "file_order": 174, "section_index": 58, "content_hash": "d8d3101ca157d2b71e87626d659c1b7bea09d789240215e055a4ec9e15b0ae6c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:c99a8e184089f235c44516eeae2ecf4ad53f9c6298d393ff316ffe946c103dd1", "content": "We added `WebSocketHandlerDecoratorFactory` support to the `ServerWebSocketContainer` to allow chained customization for the internal `WebSocketHandler`.\nSee xref:web-sockets.adoc#web-sockets-namespace[WebSockets Namespace Support] for more information.\n\n[[application-event-adapters-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Websocket Changes", "heading_level": 3, "file_order": 174, "section_index": 59, "content_hash": "c99a8e184089f235c44516eeae2ecf4ad53f9c6298d393ff316ffe946c103dd1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:ad3f84d62c5fece564ec961e5251384ebc8e83c5d9c118763615662c712b0211", "content": "The `ApplicationEvent` adapters can now operate with `payload` as an `event` to directly allow omitting custom `ApplicationEvent` extensions.\nFor this purpose, we introduced the `publish-payload` boolean attribute has been introduced on the `<int-event:outbound-channel-adapter>`.\nSee xref:event.adoc[Spring `ApplicationEvent` Support] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.1-4.2.adoc", "title": "changes-4.1-4.2", "heading": "Application Event Adapters changes", "heading_level": 3, "file_order": 174, "section_index": 60, "content_hash": "ad3f84d62c5fece564ec961e5251384ebc8e83c5d9c118763615662c712b0211", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.1-4.2.adoc"}}
{"id": "sha256:090a3628231f5366b0caf77df2f14c9bf4bd4c48fe10fed30cca6c3ad59b60b0", "content": "[[migration-4.2-4.3]]\n\nSee the https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-4.2-to-4.3-Migration-Guide[Migration Guide]\nfor important changes that might affect your applications.\nYou can find migration guides for all versions back to 2.1 on the https://github.com/spring-projects/spring-integration/wiki[Wiki].\n\n[[x4.3-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "changes-4.2-4.3", "heading_level": 1, "file_order": 175, "section_index": 0, "content_hash": "090a3628231f5366b0caf77df2f14c9bf4bd4c48fe10fed30cca6c3ad59b60b0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:2677dd3df43cbbde89b53ac34b679dc30b5cb821c6b886517effb5783d154168", "content": "Version 4.3 added a number of new components.\n\n[[amqp-async-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "New Components", "heading_level": 2, "file_order": 175, "section_index": 1, "content_hash": "2677dd3df43cbbde89b53ac34b679dc30b5cb821c6b886517effb5783d154168", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:d99f6799453a74f154dfea6d5da401f4639eacdf272b372e204af46044cc7327", "content": "See xref:amqp.adoc#amqp-async-outbound-gateway[Asynchronous Outbound Gateway].\n\n[[messagegroupfactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "AMQP Async Outbound Gateway", "heading_level": 3, "file_order": 175, "section_index": 2, "content_hash": "d99f6799453a74f154dfea6d5da401f4639eacdf272b372e204af46044cc7327", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:375d1daa3b769e242a06f677c67a038fb29fb938022a7f64a4382bcd868bcb88", "content": "We introduced the `MessageGroupFactory` strategy to allow control over `MessageGroup` instances in `MessageGroupStore` logic.\nWe added `SimpleMessageGroupFactory` implementation for the `SimpleMessageGroup`, with the `GroupType.HASH_SET` as the default\nfactory for the standard `MessageGroupStore` implementations.\nSee xref:message-store.adoc[Message Store] for more information.\n\n[[persistentmessagegroup]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "`MessageGroupFactory`", "heading_level": 3, "file_order": 175, "section_index": 3, "content_hash": "375d1daa3b769e242a06f677c67a038fb29fb938022a7f64a4382bcd868bcb88", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:ba4e8e05119a7c78b6568134d3e7269d93680f92b1e179ad6213e55267b2fcfd", "content": "We added the `PersistentMessageGroup` (lazy-load proxy) implementation for persistent `MessageGroupStore` instances,\nwhich return this instance for the `getMessageGroup()` when their `lazyLoadMessageGroups` is `true` (the default).\nSee xref:message-store.adoc[Message Store] for more information.\n\n[[ftp-and-sftp-streaming-inbound-channel-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "`PersistentMessageGroup`", "heading_level": 3, "file_order": 175, "section_index": 4, "content_hash": "ba4e8e05119a7c78b6568134d3e7269d93680f92b1e179ad6213e55267b2fcfd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:6a111656e31013877b1391c14f1fa96be647323925b0a0155ee8a48731f590f4", "content": "We added inbound channel adapters that return an `InputStream` for each file, letting you retrieve remote files without writing them to the local file system.\nSee xref:ftp/streaming.adoc[FTP Streaming Inbound Channel Adapter] and xref:sftp/streaming.adoc[SFTP Streaming Inbound Channel Adapter] for more information.\n\n[[streamtransformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "FTP and SFTP Streaming Inbound Channel Adapters", "heading_level": 3, "file_order": 175, "section_index": 5, "content_hash": "6a111656e31013877b1391c14f1fa96be647323925b0a0155ee8a48731f590f4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:6049c0efbdbca070528d1d598bfdf0c1e8413d6987bfb56a56c7144648d97987", "content": "We added `StreamTransformer` to transform an `InputStream` payload to either a `byte[]` or a `String`.\nSee xref:transformer.adoc#stream-transformer[Stream Transformer] for more information.\n\n[[integration-graph]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "`StreamTransformer`", "heading_level": 3, "file_order": 175, "section_index": 6, "content_hash": "6049c0efbdbca070528d1d598bfdf0c1e8413d6987bfb56a56c7144648d97987", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:abc7f40065adc9940c590fdf5f9fd478c423871dd707f47c85c4891e35c82044", "content": "We added `IntegrationGraphServer`, together with the `IntegrationGraphController` REST service, to expose the runtime model of a Spring Integration application as a graph.\nSee xref:graph.adoc#integration-graph[Integration Graph] for more information.\n\n[[jdbc-lock-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Integration Graph", "heading_level": 3, "file_order": 175, "section_index": 7, "content_hash": "abc7f40065adc9940c590fdf5f9fd478c423871dd707f47c85c4891e35c82044", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:8cb3d12005331c579066332b165addc826eed672e236353af9891afc46107118", "content": "We added `JdbcLockRegistry` for distributed locks shared through a database table.\nSee xref:jdbc.adoc#jdbc-lock-registry[JDBC Lock Registry] for more information.\n\n[[leaderinitiator-for-lockregistry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "JDBC Lock Registry", "heading_level": 3, "file_order": 175, "section_index": 8, "content_hash": "8cb3d12005331c579066332b165addc826eed672e236353af9891afc46107118", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:61ceb2a209252a4749d6a1ee48a527eda5ff37b19ab9100c38bc8f6540ca67ec", "content": "We added `LeaderInitiator` implementation based on the `LockRegistry` strategy.\nSee xref:endpoint.adoc#leadership-event-handling[Leadership Event Handling] for more information.\n\n[[x4.3-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "`LeaderInitiator` for `LockRegistry`", "heading_level": 3, "file_order": 175, "section_index": 9, "content_hash": "61ceb2a209252a4749d6a1ee48a527eda5ff37b19ab9100c38bc8f6540ca67ec", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:8211f940ca755b46dd1382934f179fefb8348b936bc161da5e96e38309af7f79", "content": "This section describes general changes that version 4.3 brought to Spring Integration.\n\n[[core-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "General Changes", "heading_level": 2, "file_order": 175, "section_index": 10, "content_hash": "8211f940ca755b46dd1382934f179fefb8348b936bc161da5e96e38309af7f79", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:f0f33cf031e05a834b032139982b250de6e2a1182cdfd3a62b4b69193e801145", "content": "This section describes general changes to the core of Spring Integration.\n\n[[outbound-gateway-within-a-chain]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Core Changes", "heading_level": 3, "file_order": 175, "section_index": 11, "content_hash": "f0f33cf031e05a834b032139982b250de6e2a1182cdfd3a62b4b69193e801145", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:2a59aa59a161da899be5182075860e496e47f2d35ebb61c3cd25c9837e63ff89", "content": "Previously, you could specify a `reply-channel` on an outbound gateway within a chain.\nIt was completely ignored.\nThe gateway's reply goes to the next chain element or, if the gateway is the last element, to the chain's output channel.\nThis condition is now detected and disallowed.\nIf you have such a configuration, remove the `reply-channel`.\n\n[[asynchronous-service-activator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Outbound Gateway within a Chain", "heading_level": 4, "file_order": 175, "section_index": 12, "content_hash": "2a59aa59a161da899be5182075860e496e47f2d35ebb61c3cd25c9837e63ff89", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:66d18ada8db15c0df523e5e47461302351ff4cd4cadf8bb9b208a6f3df795d16", "content": "We added an option to make the service activator be synchronous.\nSee xref:service-activator.adoc#async-service-activator[Asynchronous Service Activator] for more information.\n\n[[messaging-annotation-support-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Asynchronous Service Activator", "heading_level": 4, "file_order": 175, "section_index": 13, "content_hash": "66d18ada8db15c0df523e5e47461302351ff4cd4cadf8bb9b208a6f3df795d16", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:13cf453b25ed15978a291eae1e04d98fc410e0ae51ef17ba8762d46f6e039e38", "content": "The messaging annotation support does not require a `@MessageEndpoint` (or any other `@Component`) annotation declaration on the class level.\nTo restore the previous behavior, set the `spring.integration.messagingAnnotations.require.componentAnnotation` of\n`spring.integration.properties` to `true`.\nSee xref:configuration/global-properties.adoc[Global Properties] and xref:configuration/annotations.adoc[Annotation Support] for more information.\n\n[[mail-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Messaging Annotation Support changes", "heading_level": 4, "file_order": 175, "section_index": 14, "content_hash": "13cf453b25ed15978a291eae1e04d98fc410e0ae51ef17ba8762d46f6e039e38", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:5eb71d8803ff6acf4b1858961b40aa7a967c2a733a0e53ea371cbaebca514ad9", "content": "This section describes general changes to the Spring Integration Mail functionality.\n\n[[customizable-user-flag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Mail Changes", "heading_level": 3, "file_order": 175, "section_index": 15, "content_hash": "5eb71d8803ff6acf4b1858961b40aa7a967c2a733a0e53ea371cbaebca514ad9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:c9fa633ad5a636c510569081cac0332d65d4e5d199579984dfe5ac4b4b55a417", "content": "The customizable `userFlag` (added in 4.2.2 to provide customization of the flag used to denote that the mail has been\nseen) is now available in the XML namespace.\nSee xref:mail.adoc#imap-seen[Marking IMAP Messages When `Recent` Is Not Supported] for more information.\n\n[[mail-message-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Customizable User Flag", "heading_level": 4, "file_order": 175, "section_index": 16, "content_hash": "c9fa633ad5a636c510569081cac0332d65d4e5d199579984dfe5ac4b4b55a417", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:3a97c9cf5d6a83e5030c65328d417a0743950f442c324e21042ce56535702f54", "content": "You can now map inbound mail messages with the `MessageHeaders` containing the mail headers and the payload containing the email content.\nPreviously, the payload was always the raw `MimeMessage`.\nSee xref:mail.adoc#mail-mapping[Inbound Mail Message Mapping] for more information.\n\n[[jms-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Mail Message Mapping", "heading_level": 4, "file_order": 175, "section_index": 17, "content_hash": "3a97c9cf5d6a83e5030c65328d417a0743950f442c324e21042ce56535702f54", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:6a6799efe870c368b4585350f973a93a35eab88789fa9d6a0b8325e09acf518f", "content": "This section describes general changes to the Spring Integration JMS functionality.\n\n[[header-mapper]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "JMS Changes", "heading_level": 3, "file_order": 175, "section_index": 18, "content_hash": "6a6799efe870c368b4585350f973a93a35eab88789fa9d6a0b8325e09acf518f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:e87d86d7e9394b5f9263514e7eaa1e88f591127af16f7ab2efabe5bccfdccfbe", "content": "The `DefaultJmsHeaderMapper` now maps the standard `correlationId` header as a message property by invoking its `toString()` method.\nSee xref:changes-3.0-4.0.adoc#x4.0-jms-header-mapping[Mapping Message Headers to and from JMS Message] for more information.\n\n[[asynchronous-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Header Mapper", "heading_level": 4, "file_order": 175, "section_index": 19, "content_hash": "e87d86d7e9394b5f9263514e7eaa1e88f591127af16f7ab2efabe5bccfdccfbe", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:b9c735bad35162ea206cdb197f6d6d7250c6a5f9b8ed569a85fa837d9689eb57", "content": "The JMS outbound gateway now has an `async` property.\nSee xref:jms.adoc#jms-async-gateway[Async Gateway] for more information.\n\n[[aggregator-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Asynchronous Gateway", "heading_level": 4, "file_order": 175, "section_index": 20, "content_hash": "b9c735bad35162ea206cdb197f6d6d7250c6a5f9b8ed569a85fa837d9689eb57", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:29821fc20acd6e1a6015ea5245ef981a21efae383435a51821679a8bf4ce8948", "content": "There is a change in behavior when a POJO aggregator releases a collection of `Message<?>` objects.\nThis is rare, but, if your application does that, you need to make a small change to your POJO.\nSee this xref:aggregator.adoc#agg-message-collection[IMPORTANT: The `SimpleMessageGroup.getMessages()` method returns an `unmodifiableCollection`.] note for more information.\n\n[[tcp/udp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Aggregator Changes", "heading_level": 3, "file_order": 175, "section_index": 21, "content_hash": "29821fc20acd6e1a6015ea5245ef981a21efae383435a51821679a8bf4ce8948", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:902f2c8917263829c688082d2da6d3ecf612fb47ed4f7f87ad7f3e6fd4b5f444", "content": "This section describes general changes to the Spring Integration TCP/UDP functionality.\n\n[[events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "TCP/UDP Changes", "heading_level": 3, "file_order": 175, "section_index": 22, "content_hash": "902f2c8917263829c688082d2da6d3ecf612fb47ed4f7f87ad7f3e6fd4b5f444", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:f3bedd3935bc5058252b2eb4cf501959c5e59eea38d4651b226707e87f36a09b", "content": "A new `TcpConnectionServerListeningEvent` is emitted when a server connection factory is started.\nSee xref:changes-4.1-4.2.adoc#x4.2-tcp-events[TCP Connection Events] for more information.\n\nYou can now use the `destination-expression` and `socket-expression` attributes on `<int-ip:udp-outbound-channel-adapter>`.\nSee xref:ip/udp-adapters.adoc[UDP Adapters] for more information.\n\n[[stream-deserializers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Events", "heading_level": 4, "file_order": 175, "section_index": 23, "content_hash": "f3bedd3935bc5058252b2eb4cf501959c5e59eea38d4651b226707e87f36a09b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:c4009ac6a7aed9a85143c0f8abc2d4b45c367dbb6032048d7f4095a2c4b86ee2", "content": "The various deserializers that cannot allocate the final buffer until the whole message has been assembled now support pooling the raw buffer into which the data is received rather than creating and discarding a buffer for each message.\nSee xref:ip/tcp-connection-factories.adoc[TCP Connection Factories] for more information.\n\n[[tcp-message-mapper]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Stream Deserializers", "heading_level": 4, "file_order": 175, "section_index": 24, "content_hash": "c4009ac6a7aed9a85143c0f8abc2d4b45c367dbb6032048d7f4095a2c4b86ee2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:634ce5054ce0cb4286e4244fe6974d9717d98dae2ee460ff855ab1ab74a2edb2", "content": "The message mapper now, optionally, sets a configured content type header.\nSee xref:ip/msg-headers.adoc[IP Message Headers] for more information.\n\n[[file-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "TCP Message Mapper", "heading_level": 4, "file_order": 175, "section_index": 25, "content_hash": "634ce5054ce0cb4286e4244fe6974d9717d98dae2ee460ff855ab1ab74a2edb2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:78d50fe6367ad4da5c9dadafcbf7091c1d44dd160a84d14794e8693fd212d95d", "content": "This section describes general changes to the Spring Integration File functionality.\n\n[[destination-directory-creation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "File Changes", "heading_level": 3, "file_order": 175, "section_index": 26, "content_hash": "78d50fe6367ad4da5c9dadafcbf7091c1d44dd160a84d14794e8693fd212d95d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:85781f730a32807119d4b875879bd6d3a9d5503ca0fcc34816620f9a127d386e", "content": "The generated file name for the `FileWritingMessageHandler` can represent a sub-path to save the desired directory structure for a file in the target directory.\nSee xref:file/writing.adoc#file-writing-file-names[Generating File Names] for more information.\n\nThe `FileReadingMessageSource` now hides the `WatchService` directory scanning logic in the inner class.\nWe added the `use-watch-service` and `watch-events` options to enable this behavior.\nWe deprecated the top-level `WatchServiceDirectoryScanner` because of inconsistency around the API.\nSee xref:file.adoc#watch-service-directory-scanner[`WatchServiceDirectoryScanner`] for more information.\n\n[[buffer-size]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Destination Directory Creation", "heading_level": 4, "file_order": 175, "section_index": 27, "content_hash": "85781f730a32807119d4b875879bd6d3a9d5503ca0fcc34816620f9a127d386e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:2e2cd08707710e51514eaef31d597ec91246a5b825a92cf7eaa81106271ca5ff", "content": "When writing files, you can now specify the buffer size.\n\n[[appending-and-flushing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Buffer Size", "heading_level": 4, "file_order": 175, "section_index": 28, "content_hash": "2e2cd08707710e51514eaef31d597ec91246a5b825a92cf7eaa81106271ca5ff", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:2f637513b691a2537af2b0fc79b6f9343938e6929f700acec4b64fe4525a2df3", "content": "You can now avoid flushing files when appending and use a number of strategies to flush the data during idle periods.\nSee xref:file/writing.adoc#file-flushing[Flushing Files When Using `APPEND_NO_FLUSH`] for more information.\n\n[[preserving-timestamps]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Appending and Flushing", "heading_level": 4, "file_order": 175, "section_index": 29, "content_hash": "2f637513b691a2537af2b0fc79b6f9343938e6929f700acec4b64fe4525a2df3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:c34c01e78accc93c1f03fb2b946605ec174060d513c93ae150137ea9f9a1944a", "content": "You can now configure the outbound channel adapter to set the destination file's `lastmodified` timestamp.\nSee xref:file/writing.adoc#file-timestamps[File Timestamps] for more information.\n\n[[splitter-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Preserving Timestamps", "heading_level": 4, "file_order": 175, "section_index": 30, "content_hash": "c34c01e78accc93c1f03fb2b946605ec174060d513c93ae150137ea9f9a1944a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:440258d9b2ca906b905bafbc6f891ea4d3d71b39ae97825febf6ab1c478d6d94", "content": "The `FileSplitter` now automatically closes an FTP or SFTP session when the file is completely read.\nThis applies when the outbound gateway returns an `InputStream` or when you use the new FTP or SFTP streaming channel adapters.\nWe also introduced a new `markers-json` option to convert `FileSplitter.FileMarker` to JSON `String` for relaxed downstream network interaction.\nSee xref:file/splitter.adoc[File Splitter] for more information.\n\n[[file-filters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Splitter Changes", "heading_level": 4, "file_order": 175, "section_index": 31, "content_hash": "440258d9b2ca906b905bafbc6f891ea4d3d71b39ae97825febf6ab1c478d6d94", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:74f1e680c47ca2e421d2b4519607cde533aa83d6d2fb7a27a1d21679da636dc1", "content": "We added `ChainFileListFilter` as an alternative to `CompositeFileListFilter`.\nSee xref:file/reading.adoc[Reading Files] for more information.\n\n[[amqp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "File Filters", "heading_level": 4, "file_order": 175, "section_index": 32, "content_hash": "74f1e680c47ca2e421d2b4519607cde533aa83d6d2fb7a27a1d21679da636dc1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:8bdaea6864d69c84c74b3eb8a63e228d4e506804c09f40e9091bd05f004a7c21", "content": "This section describes general changes to the Spring Integration AMQP functionality.\n\n[[content-type-message-converter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "AMQP Changes", "heading_level": 3, "file_order": 175, "section_index": 33, "content_hash": "8bdaea6864d69c84c74b3eb8a63e228d4e506804c09f40e9091bd05f004a7c21", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:09220f3dc9dacbf69ddf36c9a9957c73490edb9591332497eb67e0bd445f5a59", "content": "The outbound endpoints now support a `RabbitTemplate` configured with a `ContentTypeDelegatingMessageConverter` such\nthat you can choose the converter based on the message content type.\nSee xref:amqp/content-type-conversion-outbound.adoc[Outbound Message Conversion] for more information.\n\n[[headers-for-delayed-message-handling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Content Type Message Converter", "heading_level": 4, "file_order": 175, "section_index": 34, "content_hash": "09220f3dc9dacbf69ddf36c9a9957c73490edb9591332497eb67e0bd445f5a59", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:e169b870423847dae59c4ff5c59bb90983ea8b959343dcdb1ad2a949676fd0f7", "content": "Spring AMQP 1.6 adds support for https://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/[delayed message exchanges].\nHeader mapping now supports the headers (`amqp_delay` and `amqp_receivedDelay`) used by this feature.\n\n[[amqp-backed-channels]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Headers for Delayed Message Handling", "heading_level": 4, "file_order": 175, "section_index": 35, "content_hash": "e169b870423847dae59c4ff5c59bb90983ea8b959343dcdb1ad2a949676fd0f7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:a141fa2af6bec8bf3778e4fdd9eddb78b46f33494253b0ac115240f245de6305", "content": "AMQP-backed channels now support message mapping.\nSee xref:amqp/channels.adoc[AMQP-backed Message Channels] for more information.\n\n[[redis-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "AMQP-Backed Channels", "heading_level": 4, "file_order": 175, "section_index": 36, "content_hash": "a141fa2af6bec8bf3778e4fdd9eddb78b46f33494253b0ac115240f245de6305", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:7ae49ddf56c7f465aa3a7de6aa70270787420de6a63f22148b446bf25917c10d", "content": "This section describes general changes to the Spring Integration Redis functionality.\n\n[[list-push/pop-direction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Redis Changes", "heading_level": 3, "file_order": 175, "section_index": 37, "content_hash": "7ae49ddf56c7f465aa3a7de6aa70270787420de6a63f22148b446bf25917c10d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:6af1cf191cb5a15fda3dbc13d06e34964a20973f15e791b21ad6c88ba72d659f", "content": "Previously, the queue channel adapters always used the Redis list in a fixed direction, pushing to the left end and reading from the right end.\nYou can now configure the reading and writing direction with the `rightPop` and `leftPush` options for the\n`RedisQueueMessageDrivenEndpoint` and `RedisQueueOutboundChannelAdapter`, respectively.\nSee xref:redis.adoc#redis-queue-inbound-channel-adapter[Redis Queue Inbound Channel Adapter] and xref:redis.adoc#redis-queue-outbound-channel-adapter[Redis Queue Outbound Channel Adapter] for more information.\n\n[[queue-inbound-gateway-default-serializer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "List Push/Pop Direction", "heading_level": 4, "file_order": 175, "section_index": 38, "content_hash": "6af1cf191cb5a15fda3dbc13d06e34964a20973f15e791b21ad6c88ba72d659f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:32f60831db688e064e7b3b78ec491ed9f7405add6a5a0d5ef4860c087c7630dd", "content": "The default serializer in the inbound gateway has been changed to a `JdkSerializationRedisSerializer` for compatibility with the outbound gateway.\nSee xref:redis.adoc#redis-queue-inbound-gateway[Redis Queue Inbound Gateway] for more information.\n\n[[http-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Queue Inbound Gateway Default Serializer", "heading_level": 4, "file_order": 175, "section_index": 39, "content_hash": "32f60831db688e064e7b3b78ec491ed9f7405add6a5a0d5ef4860c087c7630dd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:362c25a104b8dada08631b93425b3e7a08151c5e158e0f8f193ee33057f13832", "content": "Previously, with requests that had a body (such as `POST`) that had no `content-type` header, the body was ignored.\nWith this release, the content type of such requests is considered to be `application/octet-stream` as recommended\nby RFC 2616.\nSee xref:http/inbound.adoc[Http Inbound Components] for more information.\n\n`uriVariablesExpression` now uses a `SimpleEvaluationContext` by default (since 4.3.15).\nSee xref:http/namespace.adoc#mapping-uri-variables[Mapping URI Variables] for more information.\n\n[[sftp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "HTTP Changes", "heading_level": 3, "file_order": 175, "section_index": 40, "content_hash": "362c25a104b8dada08631b93425b3e7a08151c5e158e0f8f193ee33057f13832", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:f648b1b079179c39eb908cc886647fdb85977c85c949c0b95b929f84416e5b6b", "content": "This section describes general changes to the Spring Integration SFTP functionality.\n\n[[factory-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "SFTP Changes", "heading_level": 3, "file_order": 175, "section_index": 41, "content_hash": "f648b1b079179c39eb908cc886647fdb85977c85c949c0b95b929f84416e5b6b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:5cb02900bc91defcc7bbaaccb4bdef34b6c9a35502e7a8f366c6552951a10492", "content": "We added a new factory bean to simplify the configuration of Jsch proxies for SFTP.\nSee `JschProxyFactoryBean` for more information.\n\n[[chmod-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Factory Bean", "heading_level": 4, "file_order": 175, "section_index": 42, "content_hash": "5cb02900bc91defcc7bbaaccb4bdef34b6c9a35502e7a8f366c6552951a10492", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:812d1a9e3acf9cd58a960357bc3c09bb8fa57701be86e6e2a724d555c6bfd06a", "content": "The SFTP outbound gateway (for `put` and `mput` commands) and the SFTP outbound channel adapter now support the `chmod` attribute to change the remote file permissions after uploading.\nSee `xref:sftp/outbound.adoc[SFTP Outbound Channel Adapter]` and `xref:sftp/outbound-gateway.adoc[SFTP Outbound Gateway]` for more information.\n\n[[ftp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "`chmod` Changes", "heading_level": 4, "file_order": 175, "section_index": 43, "content_hash": "812d1a9e3acf9cd58a960357bc3c09bb8fa57701be86e6e2a724d555c6bfd06a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:69b691f056e4a797326021de8955ead115e791082c386ec34791ed52dd08860b", "content": "This section describes general changes to the Spring Integration FTP functionality.\n\n[[session-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "FTP Changes", "heading_level": 3, "file_order": 175, "section_index": 44, "content_hash": "69b691f056e4a797326021de8955ead115e791082c386ec34791ed52dd08860b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:4a5f59ae08dd476ea8678d8a92fb82661788c116fadfe24b1accd01d37c3f76e", "content": "The `FtpSession` now supports `null` for the `list()` and `listNames()` methods, since underlying FTP Client can use it.\nWith that, you can now configure the `FtpOutboundGateway` without the `remoteDirectory` expression.\nYou can also configure the `<int-ftp:inbound-channel-adapter>` without `remote-directory` or `remote-directory-expression`.\nSee xref:ftp.adoc[FTP/FTPS Adapters] for more information.\n\n[[router-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Session Changes", "heading_level": 4, "file_order": 175, "section_index": 45, "content_hash": "4a5f59ae08dd476ea8678d8a92fb82661788c116fadfe24b1accd01d37c3f76e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:5e8c40c460cf978d0090478a09d36186197ab27fb2566412c762a8bc5ac54c19", "content": "The `ErrorMessageExceptionTypeRouter` now supports the `Exception` superclass mappings to avoid duplication for the same channel in case of multiple inheritors.\nFor this purpose, the `ErrorMessageExceptionTypeRouter` loads mapping classes during initialization to fail-fast for a `ClassNotFoundException`.\n\nSee xref:router.adoc[Routers] for more information.\n\n[[header-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Router Changes", "heading_level": 3, "file_order": 175, "section_index": 46, "content_hash": "5e8c40c460cf978d0090478a09d36186197ab27fb2566412c762a8bc5ac54c19", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:60992b4167af5318d544aba898029fd94ac4612f2dbbff4a0851e49649d497a4", "content": "This section describes the changes to header mapping between version 4.2 and 4.3.\n\n[[general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Header Mapping", "heading_level": 3, "file_order": 175, "section_index": 47, "content_hash": "60992b4167af5318d544aba898029fd94ac4612f2dbbff4a0851e49649d497a4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:126eb996719571bb6dad9ce4e216ac5fd6b933976ccb7f6aa7fdd7b7d39ecf7e", "content": "AMQP, WS, and XMPP header mappings (such as `request-header-mapping` and `reply-header-mapping`) now support negated patterns.\nSee xref:amqp/message-headers.adoc[AMQP Message Headers], xref:ws.adoc#ws-message-headers[WS Message Headers], and xref:xmpp.adoc#xmpp-message-headers[XMPP Message Headers] for more information.\n\n[[amqp-header-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "General", "heading_level": 4, "file_order": 175, "section_index": 48, "content_hash": "126eb996719571bb6dad9ce4e216ac5fd6b933976ccb7f6aa7fdd7b7d39ecf7e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:e3db32b0d8dc26eef5206fc0aefac4a8168e9ce428ad688010e7dd85ba7e04b1", "content": "Previously, only standard AMQP headers were mapped by default.\nYou had to explicitly enable mapping of user-defined headers.\nWith this release, all headers are mapped by default.\nIn addition, the inbound `amqp_deliveryMode` header is no longer mapped by default.\nSee xref:amqp/message-headers.adoc[AMQP Message Headers] for more information.\n\n[[groovy-scripts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "AMQP Header Mapping", "heading_level": 4, "file_order": 175, "section_index": 49, "content_hash": "e3db32b0d8dc26eef5206fc0aefac4a8168e9ce428ad688010e7dd85ba7e04b1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:e7e74271b5d9f1c30f8cd521a6727fff499663ec98585a477d867ec7332caf52", "content": "You can now configure groovy scripts with the `compile-static` hint or any other `CompilerConfiguration` options.\nSee xref:groovy.adoc#groovy-config[Groovy Configuration] for more information.\n\n[[inboundchanneladapter-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "Groovy Scripts", "heading_level": 3, "file_order": 175, "section_index": 50, "content_hash": "e7e74271b5d9f1c30f8cd521a6727fff499663ec98585a477d867ec7332caf52", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:b756cb004d6012e53c9888d755f8ec277c096550401afff8d49dacfb9aab4258", "content": "The `@InboundChannelAdapter` now has an alias `channel` attribute for the regular `value`.\nIn addition, the target `SourcePollingChannelAdapter` components can now resolve the target `outputChannel` bean from its provided name (`outputChannelName` options) in a late-binding manner.\nSee xref:configuration/annotations.adoc[Annotation Support] for more information.\n\n[[xmpp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "`@InboundChannelAdapter` Changes", "heading_level": 3, "file_order": 175, "section_index": 51, "content_hash": "b756cb004d6012e53c9888d755f8ec277c096550401afff8d49dacfb9aab4258", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:ca322829b8e8dfd8415f03ae7b6705e26eb622401d89eee7c131647f5e6e27ea", "content": "The XMPP channel adapters now support the XMPP Extensions (XEP).\nSee xref:xmpp.adoc#xmpp-extensions[XMPP Extensions] for more information.\n\n[[wiretap-late-binding]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "XMPP Changes", "heading_level": 3, "file_order": 175, "section_index": 52, "content_hash": "ca322829b8e8dfd8415f03ae7b6705e26eb622401d89eee7c131647f5e6e27ea", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:5c4c96dc045a4b2037c4e4f268b5c9aebd0461b084cf13eb81949f806da1d143", "content": "The `WireTap` `ChannelInterceptor` now can accept a `channelName` that is resolved to the target `MessageChannel`\nlater, during the first active interceptor operation.\nSee xref:channel/configuration.adoc#channel-wiretap[Wire Tap] for more information.\n\n[[channelmessagestorequeryprovider-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "WireTap Late Binding", "heading_level": 3, "file_order": 175, "section_index": 53, "content_hash": "5c4c96dc045a4b2037c4e4f268b5c9aebd0461b084cf13eb81949f806da1d143", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:7045820659f62e451506716be8b0b2c256ec52d15f1c8c89953dd9d14ca0d7a4", "content": "The `ChannelMessageStoreQueryProvider` now supports H2 databases.\nSee xref:jdbc/message-store.adoc#jdbc-message-store-channels[Backing Message Channels] for more information.\n\n[[websocket-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "`ChannelMessageStoreQueryProvider` Changes", "heading_level": 3, "file_order": 175, "section_index": 54, "content_hash": "7045820659f62e451506716be8b0b2c256ec52d15f1c8c89953dd9d14ca0d7a4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:aa7a63ef3b0337a9b303fb693b8b7ba10820e33dbcc7416929c0dc39ab47c968", "content": "The `ServerWebSocketContainer` now exposes an `allowedOrigins` option, and `SockJsServiceOptions` exposes a `suppressCors` option.\nSee xref:web-sockets.adoc[WebSockets Support] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.2-4.3.adoc", "title": "changes-4.2-4.3", "heading": "WebSocket Changes", "heading_level": 3, "file_order": 175, "section_index": 55, "content_hash": "aa7a63ef3b0337a9b303fb693b8b7ba10820e33dbcc7416929c0dc39ab47c968", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.2-4.3.adoc"}}
{"id": "sha256:2fcbf7884245769bd0a00829ee4a9bd26b2f6427b89b67b91e818b2850083299", "content": "[[migration-4.3-5.0]]\n\nSee the https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-4.3-to-5.0-Migration-Guide[Migration Guide] for important changes that might affect your applications.\nYou can find migration guides for all versions back to 2.1 on the https://github.com/spring-projects/spring-integration/wiki[wiki].\n\n[[x5.0-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "changes-4.3-5.0", "heading_level": 1, "file_order": 176, "section_index": 0, "content_hash": "2fcbf7884245769bd0a00829ee4a9bd26b2f6427b89b67b91e818b2850083299", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:7c0af3de9627fe9060e2468a1130145030ef30c00079fa0c8b44610c433f2e2b", "content": "Version 5.0 added a number of new components.\n\n[[java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "New Components", "heading_level": 2, "file_order": 176, "section_index": 1, "content_hash": "7c0af3de9627fe9060e2468a1130145030ef30c00079fa0c8b44610c433f2e2b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:7fd54db9319f5f2ae96ffb00cd7e1c57ad10b7e041965085b97539dcc2690adf", "content": "The separate https://github.com/spring-projects/spring-integration-java-dsl[Spring Integration Java DSL] project has now been merged into the core Spring Integration project.\nThe `IntegrationComponentSpec` implementations for channel adapters and gateways are distributed to their specific modules.\nSee xref:dsl.adoc#java-dsl[Java DSL] for more information about Java DSL support.\nSee also the https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-4.3-to-5.0-Migration-Guide#java-dsl[4.3 to 5.0 Migration Guide] for the required steps to move to Spring Integration 5.0.\n\n[[testing-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Java DSL", "heading_level": 3, "file_order": 176, "section_index": 2, "content_hash": "7fd54db9319f5f2ae96ffb00cd7e1c57ad10b7e041965085b97539dcc2690adf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:895ba5fbb2fd102a37e394510cd79a4c8eb479eb895c785ae2ba88f6afe134ca", "content": "We created a new Spring Integration Test Framework to help with testing Spring Integration applications.\nNow, with the `@SpringIntegrationTest` annotation on test classes and the `MockIntegration` factory, you can make your JUnit tests for integration flows somewhat easier.\n\nSee xref:testing.adoc[Testing support] for more information.\n\n[[mongodb-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Testing Support", "heading_level": 3, "file_order": 176, "section_index": 3, "content_hash": "895ba5fbb2fd102a37e394510cd79a4c8eb479eb895c785ae2ba88f6afe134ca", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:1a66a080e660638315ee21e2af162941cdc7bc6586bf0dc6a0fa6aebf89875be", "content": "The new `MongoDbOutboundGateway` lets you make queries to the database on demand by sending a message to its request channel.\n\nSee xref:mongodb.adoc#mongodb-outbound-gateway[MongoDB Outbound Gateway] for more information.\n\n[[webflux-gateways-and-channel-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "MongoDB Outbound Gateway", "heading_level": 3, "file_order": 176, "section_index": 4, "content_hash": "1a66a080e660638315ee21e2af162941cdc7bc6586bf0dc6a0fa6aebf89875be", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:1e1cecdb3abd2e9b405beadee96daefacccfa1376facf0c62cc1bda43bf9f3e8", "content": "We introduced the new WebFlux support module for Spring WebFlux Framework gateways and channel adapters.\n\nSee xref:webflux.adoc[WebFlux Support] for more information.\n\n[[content-type-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "WebFlux Gateways and Channel Adapters", "heading_level": 3, "file_order": 176, "section_index": 5, "content_hash": "1e1cecdb3abd2e9b405beadee96daefacccfa1376facf0c62cc1bda43bf9f3e8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:696eee3ed3048d9ce8bf06e3cf8b3c27d77f97ffe643bf0c6515a197a2bbb12e", "content": "Now that we use the new `InvocableHandlerMethod`-based infrastructure for service method invocations, we can perform `contentType` conversion from the payload to a target method argument.\n\nSee xref:endpoint.adoc#content-type-conversion[Content Type Conversion] for more information.\n\n[[errormessagepublisher-and-errormessagestrategy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Content Type Conversion", "heading_level": 3, "file_order": 176, "section_index": 6, "content_hash": "696eee3ed3048d9ce8bf06e3cf8b3c27d77f97ffe643bf0c6515a197a2bbb12e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:535b1730a24791a22437555dc4d774ddd71a3efe288eb59648c4dd404e155733", "content": "We added `ErrorMessagePublisher` and the `ErrorMessageStrategy` for creating `ErrorMessage` instances.\n\nSee xref:scatter-gather.adoc#scatter-gather-error-handling[Error Handling] for more information.\n\n[[jdbc-metadata-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "`ErrorMessagePublisher` and `ErrorMessageStrategy`", "heading_level": 3, "file_order": 176, "section_index": 7, "content_hash": "535b1730a24791a22437555dc4d774ddd71a3efe288eb59648c4dd404e155733", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:108aa7792ed146e13d1e9433b66dd38a27e6320ac7d0013910c9c1e561e1fcd8", "content": "We added a JDBC implementation of the `MetadataStore` implementation.\nThis is useful when you need to ensure transactional boundaries for metadata.\n\nSee xref:jdbc.adoc#jdbc-metadata-store[JDBC Metadata Store] for more information.\n\n[[x5.0-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "JDBC Metadata Store", "heading_level": 3, "file_order": 176, "section_index": 8, "content_hash": "108aa7792ed146e13d1e9433b66dd38a27e6320ac7d0013910c9c1e561e1fcd8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:2f28854827d871e713f89df7c89c88ff6b72eae94fc0254d1b0e388e2db1fdce", "content": "Spring Integration is now fully based on Spring Framework `5.0` and Project Reactor `3.1`.\nPrevious Project Reactor versions are no longer supported.\n\n[[core-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "General Changes", "heading_level": 2, "file_order": 176, "section_index": 9, "content_hash": "2f28854827d871e713f89df7c89c88ff6b72eae94fc0254d1b0e388e2db1fdce", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:22d710b8c7538960e3123e4544ddfb0f877db45b4d3bd2871f62c23484328370", "content": "The `@Poller` annotation now has the `errorChannel` attribute for easier configuration of the underlying `MessagePublishingErrorHandler`.\nSee xref:configuration/annotations.adoc[Annotation Support] for more information.\n\nAll the request-reply endpoints (based on `AbstractReplyProducingMessageHandler`) can now start transactions and, therefore, make the whole downstream flow transactional.\nSee xref:handler-advice/tx-handle-message.adoc[Transaction Support] for more information.\n\nThe `SmartLifecycleRoleController` now provides methods to obtain status of endpoints in roles.\nSee xref:endpoint.adoc#endpoint-roles[Endpoint Roles] for more information.\n\nBy default, POJO methods are now invoked by using an `InvocableHandlerMethod`, but you can configure them to use SpEL, as before.\nSee xref:overview.adoc#pojo-invocation[POJO Method invocation] for more information.\n\nWhen targeting POJO methods as message handlers, you can now mark one of the service methods with the `@Default` annotation to provide a fallback mechanism for non-matched conditions.\nSee xref:service-activator.adoc#service-activator-namespace[Configuring Service Activator] for more information.\n\nWe added a simple `PassThroughTransactionSynchronizationFactory` to always store a polled message in the current transaction context.\nThat message is used as a `failedMessage` property of the `MessagingException`, which wraps any raw exception thrown during transaction completion.\nSee xref:transactions.adoc#transaction-synchronization[Transaction Synchronization] for more information.\n\nThe aggregator expression-based `ReleaseStrategy` now evaluates the expression against the `MessageGroup` instead of just the collection of `Message<?>`.\nSee xref:aggregator.adoc#aggregator-spel[Aggregators and Spring Expression Language (SpEL)] for more information.\n\nYou can now supply the `ObjectToMapTransformer` with a customized `JsonObjectMapper`.\n\nSee xref:aggregator.adoc#aggregator-spel[Aggregators and Spring Expression Language (SpEL)] for more information.\n\nThe `@GlobalChannelInterceptor` annotation and `<int:channel-interceptor>` now support negative patterns (via `!` prepending) for component names matching.\nSee xref:channel/configuration.adoc#global-channel-configuration-interceptors[Global Channel Interceptor Configuration] for more information.\n\nWhen a candidate failed to acquire the lock, the `LockRegistryLeaderInitiator` now emits a new `OnFailedToAcquireMutexEvent` through `DefaultLeaderEventPublisher`.\nSee `xref:endpoint.adoc#leadership-event-handling[Leadership Event Handling]` for more information.\n\n[[gateway-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Core Changes", "heading_level": 3, "file_order": 176, "section_index": 10, "content_hash": "22d710b8c7538960e3123e4544ddfb0f877db45b4d3bd2871f62c23484328370", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:1c283c6daef783b6a58e2bcea5cedbe13ef375b9635f6ed6e6e1ca6ddb24aafb", "content": "When the gateway method has a `void` return type and an error channel is provided, the gateway now correctly sets the `errorChannel` header.\nPreviously, the header was not populated.\nThis caused synchronous downstream flows (running on the calling thread) to send the exception to the configured channel, but an exception on an asynchronous downstream flow would be sent to the default `errorChannel` instead.\n\nThe `RequestReplyExchanger` interface now has a `throws MessagingException` clause to meet the proposed messages exchange contract.\n\nYou can now specify the request and reply timeouts with SpEL expressions.\nSee xref:gateway.adoc[Messaging Gateways] for more information.\n\n[[aggregator-performance-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Gateway Changes", "heading_level": 3, "file_order": 176, "section_index": 11, "content_hash": "1c283c6daef783b6a58e2bcea5cedbe13ef375b9635f6ed6e6e1ca6ddb24aafb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:72e32f9ceaadc823f5a953bd30210223f3023bcb24c3631483f327d6435e7f0e", "content": "By default, aggregators now use a `SimpleSequenceSizeReleaseStrategy`, which is more efficient, especially with large groups.\nEmpty groups are now scheduled for removal after `empty-group-min-timeout`.\nSee xref:overview.adoc#overview-endpoints-aggregator[Aggregator] for more information.\n\n[[splitter-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Aggregator Performance Changes", "heading_level": 3, "file_order": 176, "section_index": 12, "content_hash": "72e32f9ceaadc823f5a953bd30210223f3023bcb24c3631483f327d6435e7f0e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:bc70757c51441fbc79750496dfcfefe6dedcc15eff7a07e097deb74b095690a1", "content": "The splitter component can now handle and split Java `Stream` and Reactive Streams `Publisher` objects.\nIf the output channel is a `ReactiveStreamsSubscribableChannel`, the `AbstractMessageSplitter` builds a `Flux` for subsequent iteration instead of a regular `Iterator`, independent of the object being split.\nIn addition, `AbstractMessageSplitter` provides `protected obtainSizeIfPossible()` methods to allow determination of the size of the `Iterable` and `Iterator` objects, if that is possible.\nSee xref:splitter.adoc[Splitter] for more information.\n\n[[jms-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Splitter Changes", "heading_level": 3, "file_order": 176, "section_index": 13, "content_hash": "bc70757c51441fbc79750496dfcfefe6dedcc15eff7a07e097deb74b095690a1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:fdedf39d5a4f9a3787e0837417de1245911e07184964962d721385faba9fb080", "content": "Previously, Spring Integration JMS XML configuration used a default bean name of `connectionFactory` for the JMS connection factory, letting the property be omitted from component definitions.\nWe renamed it to `jmsConnectionFactory`, which is the bean name used by Spring Boot to auto-configure the JMS connection factory bean.\n\nIf your application relies on the previous behavior, you can rename your `connectionFactory` bean to `jmsConnectionFactory` or specifically configure your components to use your bean by using its current name.\nSee xref:jms.adoc[JMS Support] for more information.\n\n[[mail-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "JMS Changes", "heading_level": 3, "file_order": 176, "section_index": 14, "content_hash": "fdedf39d5a4f9a3787e0837417de1245911e07184964962d721385faba9fb080", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:4efeb5f3a45c50c55a69a63dc571eff684d5f40abf8ef48d4370425de94023d6", "content": "Some inconsistencies with rendering IMAP mail content have been resolved.\nSee xref:mail.adoc#imap-format-important[the note in the \"`Mail-receiving Channel Adapter`\" section] for more information.\n\n[[feed-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Mail Changes", "heading_level": 3, "file_order": 176, "section_index": 15, "content_hash": "4efeb5f3a45c50c55a69a63dc571eff684d5f40abf8ef48d4370425de94023d6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:9ba94f341c653fa40e02612be9e212595ec3a350da68b19509a9045f67c6f9ed", "content": "Instead of the `com.rometools.fetcher.FeedFetcher`, which is deprecated in ROME, we introduced a new `Resource` property for the `FeedEntryMessageSource`.\nSee xref:feed.adoc[Feed Adapter] for more information.\n\n[[file-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Feed Changes", "heading_level": 3, "file_order": 176, "section_index": 16, "content_hash": "9ba94f341c653fa40e02612be9e212595ec3a350da68b19509a9045f67c6f9ed", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:7c2eebaa18522b734cde5946098c56c2d379a29a83998c7b38022a398d6dc139", "content": "We introduced the new `FileHeaders.RELATIVE_PATH` message header to represent relative path in `FileReadingMessageSource`.\n\nThe tail adapter now supports `idleEventInterval` to emit events when there is no data in the file during that period.\n\nThe flush predicates for the `FileWritingMessageHandler` now have an additional parameter.\n\nThe file outbound channel adapter and gateway (`FileWritingMessageHandler`) now support the `REPLACE_IF_MODIFIED` `FileExistsMode`.\n\nThey also now support setting file permissions on the newly written file.\n\nA new `FileSystemMarkerFilePresentFileListFilter` is now available.\nSee xref:file/reading.adoc#file-incomplete[Dealing With Incomplete Data] for more information.\n\nThe `FileSplitter` now provides a `firstLineAsHeader` option to carry the first line of content as a header in the messages emitted for the remaining lines.\n\nSee xref:file.adoc[File Support] for more information.\n\n[[ftp-and-sftp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "File Changes", "heading_level": 3, "file_order": 176, "section_index": 17, "content_hash": "7c2eebaa18522b734cde5946098c56c2d379a29a83998c7b38022a398d6dc139", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:379a37d663cad7f38671d350d4e88f43c076135f0b99daa8a51431317e9c0325", "content": "The inbound channel adapters now have a property called `max-fetch-size`, which is used to limit the number of files fetched during a poll when no files are currently in the local directory.\nBy default, they also are configured with a `FileSystemPersistentAcceptOnceFileListFilter` in the `local-filter`.\n\nYou can also provide a custom `DirectoryScanner` implementation to inbound channel adapters by setting the newly introduced `scanner` attribute.\n\nYou can now configure the regex and pattern filters to always pass directories.\nThis can be useful when you use recursion in the outbound gateways.\n\nBy default, all the inbound channel adapters (streaming and synchronization-based) now use an appropriate `AbstractPersistentAcceptOnceFileListFilter` implementation to prevent duplicate downloads of remote files.\n\nThe FTP and SFTP outbound gateways now support the `REPLACE_IF_MODIFIED` `FileExistsMode` when fetching remote files.\n\nThe FTP and SFTP streaming inbound channel adapters now add remote file information in a message header.\n\nThe FTP and SFTP outbound channel adapters (as well as the `PUT` command for outbound gateways) now support `InputStream` as `payload`, too.\n\nThe inbound channel adapters can now build file trees locally by using a newly introduced `RecursiveDirectoryScanner`.\nSee the `scanner` option in the xref:ftp/inbound.adoc[FTP Inbound Channel Adapter] section for injection.\nAlso, you can now switch these adapters to the `WatchService` instead.\n\nWe added The `NLST` command to the `AbstractRemoteFileOutboundGateway` to perform the list files names remote command.\n\nYou can now supply the `FtpOutboundGateway` with `workingDirExpression` to change the FTP client working directory for the current request message.\n\nThe `RemoteFileTemplate` is supplied now with the `invoke(OperationsCallback<F, T> action)` to perform several `RemoteFileOperations` calls in the scope of the same, thread-bounded, `Session`.\n\nWe added new filters for detecting incomplete remote files.\n\nThe `FtpOutboundGateway` and `SftpOutboundGateway` now support an option to remove the remote file after a successful transfer by using the `GET` or `MGET` commands.\n\nSee xref:ftp.adoc[FTP/FTPS Adapters] and xref:sftp.adoc[SFTP Adapters] for more information.\n\n[[integration-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "FTP and SFTP Changes", "heading_level": 3, "file_order": 176, "section_index": 18, "content_hash": "379a37d663cad7f38671d350d4e88f43c076135f0b99daa8a51431317e9c0325", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:5b7978d0885e277c16cef2e17512fd3c43815357b21ada0a4cbfdba3664156e0", "content": "Version 4.3.2 added a new `spring.integration.readOnly.headers` global property to let you customize the list of headers that should not be copied to a newly created `Message` by the `MessageBuilder`.\nSee xref:configuration/global-properties.adoc[Global Properties] for more information.\n\n[[stream-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Integration Properties", "heading_level": 3, "file_order": 176, "section_index": 19, "content_hash": "5b7978d0885e277c16cef2e17512fd3c43815357b21ada0a4cbfdba3664156e0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:ff17282545d1404849954284b9da19b421d3c77d1c3487716f4747d6444a1f5b", "content": "We added a new option on the `CharacterStreamReadingMessageSource` to let it be used to \"`pipe`\" stdin and publish an application event when the pipe is closed.\nSee xref:stream.adoc#stream-reading[Reading from Streams] for more information.\n\n[[barrier-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Stream Changes", "heading_level": 3, "file_order": 176, "section_index": 20, "content_hash": "ff17282545d1404849954284b9da19b421d3c77d1c3487716f4747d6444a1f5b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:95ee2c7fdb03a5ccfc9ffa0154af0cc5b43459f257c330b2c84160953d3f2d93", "content": "The `BarrierMessageHandler` now supports a discard channel to which late-arriving trigger messages are sent.\nSee xref:barrier.adoc[Thread Barrier] for more information.\n\n[[amqp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Barrier Changes", "heading_level": 3, "file_order": 176, "section_index": 21, "content_hash": "95ee2c7fdb03a5ccfc9ffa0154af0cc5b43459f257c330b2c84160953d3f2d93", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:7feceeb3045306a9e5501447d4ca3cab06b82dea7d6df449c8af4e10938dcbc2", "content": "The AMQP outbound endpoints now support setting a delay expression when you use the RabbitMQ Delayed Message Exchange plugin.\n\nThe inbound endpoints now support the Spring AMQP `DirectMessageListenerContainer`.\n\nPollable AMQP-backed channels now block the poller thread for the poller's configured `receiveTimeout` (default: one second).\n\nHeaders, such as `contentType`, that are added to message properties by the message converter are now used in the final message.\nPreviously, it depended on the converter type as to which headers and message properties appeared in the final message.\nTo override the headers set by the converter, set the `headersMappedLast` property to `true`.\nSee xref:amqp.adoc[AMQP Support] for more information.\n\n[[http-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "AMQP Changes", "heading_level": 3, "file_order": 176, "section_index": 22, "content_hash": "7feceeb3045306a9e5501447d4ca3cab06b82dea7d6df449c8af4e10938dcbc2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:b4c0680dd59b2f920fc67ef5b0d2973fffe34aa03bebb2e44c687d8ccd7e60c9", "content": "By default, the `DefaultHttpHeaderMapper.userDefinedHeaderPrefix` property is now an empty string instead of `X-`.\nSee xref:http/header-mapping.adoc[HTTP Header Mappings] for more information.\n\nBy default, `uriVariablesExpression` now uses a `SimpleEvaluationContext` (since 5.0.4).\n\nSee xref:http/namespace.adoc#mapping-uri-variables[Mapping URI Variables] for more information.\n\n[[mqtt-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "HTTP Changes", "heading_level": 3, "file_order": 176, "section_index": 23, "content_hash": "b4c0680dd59b2f920fc67ef5b0d2973fffe34aa03bebb2e44c687d8ccd7e60c9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:6087d6464531c63ae79d50dda6a19c35cb0335db1030c328f55ac466f2be39e4", "content": "Inbound messages are now mapped with the `RECEIVED_TOPIC`, `RECEIVED_QOS`, and `RECEIVED_RETAINED` headers to avoid inadvertent propagation to outbound messages when an application relays messages.\n\nThe outbound channel adapter now supports expressions for the topic, qos, and retained properties.\nThe defaults remain the same.\nSee xref:mqtt.adoc[MQTT Support] for more information.\n\n[[stomp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "MQTT Changes", "heading_level": 3, "file_order": 176, "section_index": 24, "content_hash": "6087d6464531c63ae79d50dda6a19c35cb0335db1030c328f55ac466f2be39e4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:5b2affb60a444b553791c46c902c92b6e7d1d6f9bb75885e22ca506511578986", "content": "We changed the STOMP module to use `ReactorNettyTcpStompClient`, based on the Project Reactor `3.1` and `reactor-netty` extension.\nWe renamed `Reactor2TcpStompSessionManager` to `ReactorNettyTcpStompSessionManager`, according to the `ReactorNettyTcpStompClient` foundation.\nSee xref:stomp.adoc[STOMP Support] for more information.\n\n[[web-services-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "STOMP Changes", "heading_level": 3, "file_order": 176, "section_index": 25, "content_hash": "5b2affb60a444b553791c46c902c92b6e7d1d6f9bb75885e22ca506511578986", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:40aa94509b4bfc52f2b94ce5d01784bdb1d9c6bee91397ee1a1c6eabcbb74676", "content": "You can now supply `WebServiceOutboundGateway` instances with an externally configured `WebServiceTemplate` instances.\n\n`DefaultSoapHeaderMapper` can now map a `javax.xml.transform.Source` user-defined header to a SOAP header element.\n\nSimple WebService inbound and outbound gateways can now deal with the complete `WebServiceMessage` as a `payload`, allowing the manipulation of MTOM attachments.\n\nSee xref:ws.adoc[Web Services Support] for more information.\n\n[[redis-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Web Services Changes", "heading_level": 3, "file_order": 176, "section_index": 26, "content_hash": "40aa94509b4bfc52f2b94ce5d01784bdb1d9c6bee91397ee1a1c6eabcbb74676", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:cff0eb6cd71dd5b4b4a5938b46d6966b76a632edb54067ad77391383da5f9c63", "content": "The `RedisStoreWritingMessageHandler` is supplied now with additional `String`-based setters for SpEL expressions (for convenience with Java configuration).\nYou can now configure the `zsetIncrementExpression` on the `RedisStoreWritingMessageHandler` as well.\nIn addition, this property has been changed from `true` to `false` since the `INCR` option on `ZADD` Redis command is optional.\n\nYou can now supply the `RedisInboundChannelAdapter` with an `Executor` for executing Redis listener invokers.\nIn addition, the received messages now contain a `RedisHeaders.MESSAGE_SOURCE` header to indicate the source of the message (topic or pattern).\n\nSee xref:redis.adoc[Redis Support] for more information.\n\n[[tcp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Redis Changes", "heading_level": 3, "file_order": 176, "section_index": 27, "content_hash": "cff0eb6cd71dd5b4b4a5938b46d6966b76a632edb54067ad77391383da5f9c63", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:9bc0a5b8e76d533ad0011cda696436efdc39bb455327fd0bc7f0598035d92718", "content": "We added a new `ThreadAffinityClientConnectionFactory` to bind TCP connections to threads.\n\nYou can now configure the TCP connection factories to support `PushbackInputStream` instances, letting deserializers \"`unread`\" (push back) bytes after \"`reading ahead`\".\n\nWe added a `ByteArrayElasticRawDeserializer` without `maxMessageSize` to control and buffer incoming data as needed.\n\nSee xref:ip.adoc[TCP and UDP Support] for more information.\n\n[[jdbc-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "TCP Changes", "heading_level": 3, "file_order": 176, "section_index": 28, "content_hash": "9bc0a5b8e76d533ad0011cda696436efdc39bb455327fd0bc7f0598035d92718", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:08feba72e2f11381e4be18367d3c7fa61eef97f2664441273405d32982fb3a1a", "content": "The `JdbcMessageChannelStore` now provides a setter for `ChannelMessageStorePreparedStatementSetter`, letting you customize message insertion in the store.\n\nThe `ExpressionEvaluatingSqlParameterSourceFactory` now provides a setter for `sqlParameterTypes`, letting you customize the SQL types of the parameters.\n\nSee xref:jdbc.adoc[JDBC Support] for more information.\n\n[[metrics-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "JDBC Changes", "heading_level": 3, "file_order": 176, "section_index": 29, "content_hash": "08feba72e2f11381e4be18367d3c7fa61eef97f2664441273405d32982fb3a1a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:327a1d731d9e1a46214d12c6edcf5932a9c7c16da1ec6b6738b7fda5b239814b", "content": "https://micrometer.io/[Micrometer] application monitoring is now supported (since version 5.0.2).\nSee xref:metrics.adoc#micrometer-integration[Micrometer Integration] for more information.\n\nIMPORTANT: Changes were made to the Micrometer `Meters` in version 5.0.3 to make them more suitable for use in dimensional systems.\nFurther changes were made in 5.0.4.\nIf you use Micrometer, we recommend a minimum of version 5.0.4.\n\n[[endpointid-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "Metrics Changes", "heading_level": 3, "file_order": 176, "section_index": 30, "content_hash": "327a1d731d9e1a46214d12c6edcf5932a9c7c16da1ec6b6738b7fda5b239814b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:4b087572cdf63fd4d2edbea96b7fd52038374e8c9125081478fda674de7a162e", "content": "Introduced in version 5.0.4, this annotation provides control over bean naming when you use Java configuration.\nSee xref:overview.adoc#endpoint-bean-names[Endpoint Bean Names] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-4.3-5.0.adoc", "title": "changes-4.3-5.0", "heading": "`@EndpointId` Annotations", "heading_level": 3, "file_order": 176, "section_index": 31, "content_hash": "4b087572cdf63fd4d2edbea96b7fd52038374e8c9125081478fda674de7a162e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-4.3-5.0.adoc"}}
{"id": "sha256:c37d52401a1a8b268791e7792d82b77937efd2fa39e31410eaecd39a0785bb5d", "content": "[[migration-5.0-5.1]]\n\n[[x5.1-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "changes-5.0-5.1", "heading_level": 1, "file_order": 177, "section_index": 0, "content_hash": "c37d52401a1a8b268791e7792d82b77937efd2fa39e31410eaecd39a0785bb5d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:efaa5ac31e5d61d8871edd5b5754653adeaa83ed17c5505ba8f7126e8fe2765a", "content": "The following components are new in 5.1:\n\n* xref:changes-5.0-5.1.adoc#x5.1-AmqpDedicatedChannelAdvice[`AmqpDedicatedChannelAdvice`]\n\n[[x5.1-AmqpDedicatedChannelAdvice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "New Components", "heading_level": 2, "file_order": 177, "section_index": 1, "content_hash": "efaa5ac31e5d61d8871edd5b5754653adeaa83ed17c5505ba8f7126e8fe2765a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:9d700f4a425bc099c443bb5fd4c1f300a5b9dde875a54a132c43813626e64f24", "content": "See xref:amqp/strict-ordering.adoc[Strict Message Ordering].\n\n[[x5.1-Functions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "`AmqpDedicatedChannelAdvice`", "heading_level": 3, "file_order": 177, "section_index": 2, "content_hash": "9d700f4a425bc099c443bb5fd4c1f300a5b9dde875a54a132c43813626e64f24", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:4d98193e8927f28c82f32b63adfbf59125816dbda184ecd2b87cdc972edf2d83", "content": "The `java.util.function` interfaces now have improved integration support in the Framework components.\nAlso, Kotlin lambdas now can be used for handler and source methods.\n\nSee xref:functions-support.adoc[`java.util.function` Interfaces Support].\n\n[[x5.1-LongRunningTest]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "Improved Function Support", "heading_level": 3, "file_order": 177, "section_index": 3, "content_hash": "4d98193e8927f28c82f32b63adfbf59125816dbda184ecd2b87cdc972edf2d83", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:87d6f6df33adafcaae45bfdb20a6ee4d8632d40b3f8d5b51290839a756da5461", "content": "A JUnit Jupiter `@LongRunningTest` conditional annotation is provided to check the environment or system properties for the `RUN_LONG_INTEGRATION_TESTS` entry with the value of `true` to determine if test should be run or skipped.\n\nSee xref:testing.adoc#test-junit-conditions[JUnit Conditions].\n\n[[x5.1-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "`@LongRunningTest`", "heading_level": 3, "file_order": 177, "section_index": 4, "content_hash": "87d6f6df33adafcaae45bfdb20a6ee4d8632d40b3f8d5b51290839a756da5461", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:27470e16ff528ee03c6b6c9a8033caf1877706e5d1634cf82da76fe5dc5f398f", "content": "The following changes have been made in version 5.1:\n\n* xref:changes-5.0-5.1.adoc#x5.1-java-dsl[Java DSL]\n* xref:changes-5.0-5.1.adoc#x5.1-dispatcher-exceptions[Dispatcher Exceptions]\n* xref:changes-5.0-5.1.adoc#x5.1-global-channel-interceptors[Global Channel Interceptors]\n* xref:changes-5.0-5.1.adoc#x5.1-object-to-json-transformer[`ObjectToJsonTransformer`]\n* xref:changes-5.0-5.1.adoc#x5.1-integration-flows-generated-bean-names[Integration Flows: Generated Bean Names]\n* xref:changes-5.0-5.1.adoc#x5.1-aggregator[Aggregator Changes]\n* xref:changes-5.0-5.1.adoc#x5.1-publisher[@Publisher annotation changes]\n* xref:changes-5.0-5.1.adoc#x51.-integration-graph[Integration Graph Customization]\n* xref:changes-5.0-5.1.adoc#x51.-global-properties[Integration Global Properties]\n* xref:changes-5.0-5.1.adoc#x51.-poller-annotation[The `receiveTimeout` for `@Poller`]\n\n[[x5.1-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "General Changes", "heading_level": 2, "file_order": 177, "section_index": 5, "content_hash": "27470e16ff528ee03c6b6c9a8033caf1877706e5d1634cf82da76fe5dc5f398f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:66517c7e334e1ebdca31718db299994f28fc70679cc8f8085c46ba2575e9d0f3", "content": "The `IntegrationFlowContext` is now an interface and `IntegrationFlowRegistration` is an inner interface of `IntegrationFlowContext`.\n\nA new `logAndReply()` operator has been introduced for convenience when you wish to log at the end of a flow for request-reply configurations.\nThis avoids confusion with `log()` which is treated as a one-way end flow component.\n\nA generated bean name for any `NamedComponent` within an integration flow is now based on the component type for better readability from visual tools, logs analyzers and metrics collectors.\n\nThe `GenericHandler.handle()` now excepts a `MessageHeaders` type for the second argument.\n\n[[x5.1-dispatcher-exceptions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "Java DSL", "heading_level": 3, "file_order": 177, "section_index": 6, "content_hash": "66517c7e334e1ebdca31718db299994f28fc70679cc8f8085c46ba2575e9d0f3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:59d656ee229412ca408612e45de9bada70118b9a40c0d0f0669dd03b83ea11c4", "content": "Exceptions caught and re-thrown by `AbstractDispatcher` are now more consistent:\n\n* A `MessagingException` of any kind that has a `failedMessage` property is re-thrown unchanged.\n* All other exceptions are wrapped in a `MessageDeliveryException` with the `failedMessage` property set.\n\nPreviously:\n\n* A `MessagingException` of any kind that has a `failedMessage` property was re-thrown unchanged\n* A `MessagingException` that had no `failedMessage` property was wrapped in a `MessagingException` with the `failedMessage` property set.\n* Other `RuntimeException` instances were re-thrown unchanged.\n* Checked exceptions were wrapped in a `MessageDeliveryException` with the `failedMessage` property set.\n\n[[x5.1-global-channel-interceptors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "Dispatcher Exceptions", "heading_level": 3, "file_order": 177, "section_index": 7, "content_hash": "59d656ee229412ca408612e45de9bada70118b9a40c0d0f0669dd03b83ea11c4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:6239d09b7e71641d23d197cd73c08925760d18508501f7f43e7930688d762382", "content": "Global channel interceptors now apply to dynamically registered channels, such as through the `IntegrationFlowContext` when using the Java DSL or beans that are initialized using `beanFactory.initializeBean()`.\nPreviously, when beans were created after the application context was refreshed, interceptors were not applied.\n\n[[x5.1-channel-interceptors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "Global Channel Interceptors", "heading_level": 3, "file_order": 177, "section_index": 8, "content_hash": "6239d09b7e71641d23d197cd73c08925760d18508501f7f43e7930688d762382", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:2efb56f7d84cd9bdb83fd586c225efea66ee7fdf3479e1b2e1cd01951c5734c0", "content": "`ChannelInterceptor.postReceive()` is no longer called when no message is received; it is no longer necessary to check for a `null` `Message<?>`.\nPreviously, the method was called.\nIf you have an interceptor that relies on the previous behavior, implement `afterReceiveCompleted()` instead, since that method is invoked, regardless of whether a message is received or not.\nFurthermore, the `PolledAmqpChannel` and `PolledJmsChannel` previously did not invoke `afterReceiveCompleted()` with `null`; they now do.\n\n[[x5.1-object-to-json-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "Channel Interceptors", "heading_level": 3, "file_order": 177, "section_index": 9, "content_hash": "2efb56f7d84cd9bdb83fd586c225efea66ee7fdf3479e1b2e1cd01951c5734c0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:efe4b18dc961b9f8da6333b33f626ca119142d5ddcf9add1e5ef8ad2903936b4", "content": "A new `ResultType.BYTES` mode is introduced for the `ObjectToJsonTransformer`.\n\nSee xref:transformer.adoc#json-transformers[JSON Transformers] for more information.\n\n[[x5.1-integration-flows-generated-bean-names]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "`ObjectToJsonTransformer`", "heading_level": 3, "file_order": 177, "section_index": 10, "content_hash": "efe4b18dc961b9f8da6333b33f626ca119142d5ddcf9add1e5ef8ad2903936b4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:b80befd35bc75786868230fad92a594fc10774927536624f3342955007f18768", "content": "Starting with version 5.0.5, generated bean names for the components in an `IntegrationFlow` include the flow bean name, followed by a dot, as a prefix.\nFor example, if a flow bean were named `flowBean`, a generated bean might be named `flowBean.generatedBean`.\n\nSee xref:dsl/java-flows.adoc[Working With Message Flows] for more information.\n\n[[x5.1-aggregator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "Integration Flows: Generated Bean Names", "heading_level": 3, "file_order": 177, "section_index": 11, "content_hash": "b80befd35bc75786868230fad92a594fc10774927536624f3342955007f18768", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:9d40fbd6893f306dfb282aabf647ede4e30a867ed1929747f5217f8bd6f0f9f5", "content": "If the `groupTimeout` is evaluated to a negative value, an aggregator now expires the group immediately.\nOnly `null` is considered as a signal to do nothing for the current message.\n\nA new `popSequence` property has been introduced to allow (by default) to call a `MessageBuilder.popSequenceDetails()` for the output message.\nAlso an `AbstractAggregatingMessageGroupProcessor` returns now an `AbstractIntegrationMessageBuilder` instead of the whole `Message` for optimization.\n\nSee xref:overview.adoc#overview-endpoints-aggregator[Aggregator] for more information.\n\n[[x5.1-publisher]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "Aggregator Changes", "heading_level": 3, "file_order": 177, "section_index": 12, "content_hash": "9d40fbd6893f306dfb282aabf647ede4e30a867ed1929747f5217f8bd6f0f9f5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:a773958a5553b4ffe194bc7c2abb6d0474e4e7e96cc01e96d608dfb93a184ad5", "content": "Starting with version 5.1, you must explicitly turn on the `@Publisher` AOP functionality by using `@EnablePublisher` or by using the `<int:enable-publisher>` child element on `<int:annotation-config>`.\nAlso the `proxy-target-class` and `order` attributes have been added for tuning the `ProxyFactory` configuration.\n\nSee xref:message-publishing.adoc#publisher-annotation[Annotation-driven Configuration with the `@Publisher` Annotation] for more information.\n\n[[x5.1-files]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "@Publisher annotation changes", "heading_level": 3, "file_order": 177, "section_index": 13, "content_hash": "a773958a5553b4ffe194bc7c2abb6d0474e4e7e96cc01e96d608dfb93a184ad5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:50eab6d6cdbe943f695375a6322aaf07cb8ce63a42b4477c6de1e759117ce698", "content": "If you are using `FileExistsMode.APPEND` or `FileExistsMode.APPEND_NO_FLUSH` you can provide a `newFileCallback` that will be called when creating a new file.\nThis callback receives the newly created file and the message that triggered the callback.\nThis could be used to write a CSV header, for an example.\n\nThe `FileReadingMessageSource` now doesn't check and create a directory until its `start()` is called.\nSo, if an Inbound Channel Adapter for the `FileReadingMessageSource` has `autoStartup = false`, there are no failures against the file system during application start up.\n\nSee xref:file.adoc[File Support] for more information.\n\n[[x5.1-amqp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "Files Changes", "heading_level": 2, "file_order": 177, "section_index": 14, "content_hash": "50eab6d6cdbe943f695375a6322aaf07cb8ce63a42b4477c6de1e759117ce698", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:489dbae918cf1cc9cc2a27886bcacfd4efdf3244b76a502c5db3d585005fd131", "content": "We have made `ID` and `Timestamp` header mapping changes in the `DefaultAmqpHeaderMapper`.\nSee the note near the bottom of xref:amqp/message-headers.adoc[AMQP Message Headers] for more information.\n\nThe `contentType` header is now correctly mapped as an entry in the general headers map.\nSee xref:amqp/message-headers.adoc#amqp-content-type[contentType Header] for more information.\n\nStarting with version 5.1.3, if a message conversion exception occurs when using manual acknowledgments, and an error channel is defined, the payload is a `ManualAckListenerExecutionFailedException` with additional `channel` and `deliveryTag` properties.\nThis enables the error flow to ack/nack the original message.\nSee xref:amqp/conversion-inbound.adoc[Inbound Message Conversion] for more information.\n\n[[x5.1-jdbc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "AMQP Changes", "heading_level": 2, "file_order": 177, "section_index": 15, "content_hash": "489dbae918cf1cc9cc2a27886bcacfd4efdf3244b76a502c5db3d585005fd131", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:6191aeb46c3d41612d8556ce15dd634d37a879ac331f81e9aca4025978469ca0", "content": "A confusing `max-rows-per-poll` property on the JDBC Inbound Channel Adapter and JDBC Outbound Gateway has been deprecated in favor of the newly introduced `max-rows` property.\n\nThe `JdbcMessageHandler` supports now a `batchUpdate` functionality when the payload of the request message is an instance of an `Iterable` type.\n\nThe indexes for the `INT_CHANNEL_MESSAGE` table (for the `JdbcChannelMessageStore`) have been optimized.\nIf you have large message groups in such a store, you may wish to alter the indexes.\n\nSee xref:jdbc.adoc[JDBC Support] for more information.\n\n[[x5.1-ftp-sftp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "JDBC Changes", "heading_level": 2, "file_order": 177, "section_index": 16, "content_hash": "6191aeb46c3d41612d8556ce15dd634d37a879ac331f81e9aca4025978469ca0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:7e2e65577eb8e80f63223154768ca6c1fd8fcc216fc2833fa75b37a204679d9e", "content": "A `RotatingServerAdvice` is now available to poll multiple servers and directories with the inbound channel adapters.\nSee xref:ftp/rotating-server-advice.adoc[Inbound Channel Adapters: Polling Multiple Servers and Directories] and xref:sftp/rotating-server-advice.adoc[Inbound Channel Adapters: Polling Multiple Servers and Directories] for more information.\n\nAlso, inbound adapter `localFilenameExpression` instances can contain the `#remoteDirectory` variable, which contains the remote directory being polled.\nThe generic type of the comparators (used to sort the fetched file list for the streaming adapters) has changed from `Comparator<AbstractFileInfo<F>>` to `Comparator<F>`.\nSee xref:ftp/streaming.adoc[FTP Streaming Inbound Channel Adapter] and xref:sftp/streaming.adoc[SFTP Streaming Inbound Channel Adapter] for more information.\n\nIn addition, the synchronizers for inbound channel adapters can now be provided with a `Comparator`.\nThis is useful when using `maxFetchSize` to limit the files retrieved.\n\nThe `CachingSessionFactory` has a new property `testSession` which, when true, causes the factory to perform a `test()` operation on the `Session` when checking out an existing session from the cache.\n\nSee xref:sftp/session-caching.adoc[SFTP Session Caching] and xref:ftp/session-caching.adoc[FTP Session Caching] for more information.\n\nThe outbound gateway MPUT command now supports a message payload with a collection of files or strings.\nSee xref:sftp/outbound-gateway.adoc[SFTP Outbound Gateway] and xref:ftp/outbound-gateway.adoc[FTP Outbound Gateway] for more information.\n\n[[x51.-tcp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "FTP and SFTP Changes", "heading_level": 2, "file_order": 177, "section_index": 17, "content_hash": "7e2e65577eb8e80f63223154768ca6c1fd8fcc216fc2833fa75b37a204679d9e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:7f76ef3c4f0d9b80a26b5ae07f70b6a2de027a691be0db1ecef4361ab68b3236", "content": "When using SSL, host verification is now enabled, by default, to prevent man-in-the-middle attacks with a trusted certificate.\nSee xref:ip/ssl-tls.adoc#tcp-ssl-host-verification[Host Verification] for more information.\n\nIn addition the key and trust store types can now be configured on the `DefaultTcpSSLContextSupport`.\n\n[[x5.1-twitter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "TCP Support", "heading_level": 2, "file_order": 177, "section_index": 18, "content_hash": "7f76ef3c4f0d9b80a26b5ae07f70b6a2de027a691be0db1ecef4361ab68b3236", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:e7c05d9f869d0ea0e3521922db336586c4e29efb20919cc90cdda1edca5fbacf", "content": "Since the Spring Social project has moved to https://spring.io/blog/2018/07/03/spring-social-end-of-life-announcement[end of life status], Twitter support in Spring Integration has been moved to the Extensions project.\nSee https://github.com/spring-projects/spring-integration-extensions/tree/main/spring-integration-social-twitter[Spring Integration Social Twitter] for more information.\n\n[[x51.-jms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "Twitter Support", "heading_level": 2, "file_order": 177, "section_index": 19, "content_hash": "e7c05d9f869d0ea0e3521922db336586c4e29efb20919cc90cdda1edca5fbacf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:83d9ed3b7e51b7083319817fa2772105ee3d56e9cdea53c5859c9e00f7650f50", "content": "The `JmsSendingMessageHandler` now provides `deliveryModeExpression` and `timeToLiveExpression` options to determine respective QoS options for JMS message to send at runtime.\nThe `DefaultJmsHeaderMapper` now allows to map inbound `JMSDeliveryMode` and `JMSExpiration` properties via setting to `true` respective `setMapInboundDeliveryMode()` and `setMapInboundExpiration()` options.\nWhen a `JmsMessageDrivenEndpoint` or `JmsInboundGateway` is stopped, the associated listener container is now shut down; this closes its shared connection and any consumers.\nYou can configure the endpoints to revert to the previous behavior.\n\nSee xref:jms.adoc[JMS Support] for more information.\n\n[[x51.-http]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "JMS Support", "heading_level": 2, "file_order": 177, "section_index": 20, "content_hash": "83d9ed3b7e51b7083319817fa2772105ee3d56e9cdea53c5859c9e00f7650f50", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:5c7e64da52e62a38fc1d562900274bd6eadeb931acfcdb026ca4f9138c8989df", "content": "The `statusCodeExpression` (and `Function`) is now supplied with the `RequestEntity<?>` as a root object for evaluation context, so request headers, method, URI and body are available for target status code calculation.\n\nSee xref:http.adoc[HTTP Support] and xref:webflux.adoc[WebFlux Support] for more information.\n\n[[x51.-jmx]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "HTTP/WebFlux Support", "heading_level": 2, "file_order": 177, "section_index": 21, "content_hash": "5c7e64da52e62a38fc1d562900274bd6eadeb931acfcdb026ca4f9138c8989df", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:a57866a0775cd6563459a731161e2bdf8eac6b7ec1536a7d0a51dba606484b25", "content": "Object name key values are now quoted if they contain any characters other than those allowed in a Java identifier (or period `.`).\nFor example `org.springframework.integration:type=MessageChannel,` `name=\"input:foo.myGroup.errors\"`.\nThis has the side effect that previously \"allowed\" names, with such characters, will now be quoted.\nFor example `org.springframework.integration:type=MessageChannel,` `name=\"input#foo.myGroup.errors\"`.\n\n[[x51.-micrometer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "JMX Changes", "heading_level": 2, "file_order": 177, "section_index": 22, "content_hash": "a57866a0775cd6563459a731161e2bdf8eac6b7ec1536a7d0a51dba606484b25", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:cdf37d63e763ed6ba3cc916fa6f9f84019d57af448dadd067d4cd3c5b149920d", "content": "It is now simpler to customize the standard Micrometer meters created by the framework.\nSee xref:metrics.adoc#micrometer-integration[Micrometer Integration] for more information.\n\n[[x51.-integration-graph]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "Micrometer Support Changes", "heading_level": 2, "file_order": 177, "section_index": 23, "content_hash": "cdf37d63e763ed6ba3cc916fa6f9f84019d57af448dadd067d4cd3c5b149920d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:4854da8389bea06ee25784afead5eec55224b864707471d904174626861a888f", "content": "It is now possible to add additional properties to the ``IntegrationNode``s via `Function<NamedComponent, Map<String, Object>> additionalPropertiesCallback` on the `IntegrationGraphServer`.\nSee xref:graph.adoc#integration-graph[Integration Graph] for more information.\n\n[[x51.-global-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "Integration Graph Customization", "heading_level": 2, "file_order": 177, "section_index": 24, "content_hash": "4854da8389bea06ee25784afead5eec55224b864707471d904174626861a888f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:995d6329e05082511354a1002a28a47362b14352d72aabd4a0a646b6a371fac3", "content": "The Integration global properties (including defaults) can now be printed in the logs, when a `DEBUG` logic level is turned on for the `org.springframework.integration` category.\nSee xref:configuration/global-properties.adoc[Global Properties] for more information.\n\n[[x51.-poller-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "Integration Global Properties", "heading_level": 2, "file_order": 177, "section_index": 25, "content_hash": "995d6329e05082511354a1002a28a47362b14352d72aabd4a0a646b6a371fac3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:b0f651403545844498e905ed4889167d11a2325e0ecf922311a60ef2d90ff250", "content": "The `@Poller` annotation now provides a `receiveTimeout` option for convenience.\nSee xref:configuration/annotations.adoc#configuration-using-poller-annotation[Using the `@Poller` Annotation] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.0-5.1.adoc", "title": "changes-5.0-5.1", "heading": "The `receiveTimeout` for `@Poller`", "heading_level": 2, "file_order": 177, "section_index": 26, "content_hash": "b0f651403545844498e905ed4889167d11a2325e0ecf922311a60ef2d90ff250", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.0-5.1.adoc"}}
{"id": "sha256:3e5fbd23cf8a03faa1d5765a4a2baed3a61fea823160058fcb0911a50944c8e9", "content": "[[migration-5.1-5.2]]\n\n[[x5.2-package-class]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "changes-5.1-5.2", "heading_level": 1, "file_order": 178, "section_index": 0, "content_hash": "3e5fbd23cf8a03faa1d5765a4a2baed3a61fea823160058fcb0911a50944c8e9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:008924cd36444a72242c6d8c626b70814f7dbf05078175214bea481fa3271bf6", "content": "`Pausable` has been moved from `o.s.i.endpoint` to `o.s.i.core`.\n\n[[x5.2-behavior]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "Package and Class Changes", "heading_level": 2, "file_order": 178, "section_index": 1, "content_hash": "008924cd36444a72242c6d8c626b70814f7dbf05078175214bea481fa3271bf6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:703a92ebb65ebaf5e021ae4b1418a024fbac8c0fbdaec7f037e4af6664522d62", "content": "See the https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-5.1-to-5.2-Migration-Guide[Migration Guide] about behavior changes in this version.\n\n[[x5.2-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "Behavior Changes", "heading_level": 2, "file_order": 178, "section_index": 2, "content_hash": "703a92ebb65ebaf5e021ae4b1418a024fbac8c0fbdaec7f037e4af6664522d62", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:5357fde9da7b690e7b75e28f31d1f09f4380ab0740c77d04487c2fd5ae7d611e", "content": "[[x5.2-rsocket-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "New Components", "heading_level": 2, "file_order": 178, "section_index": 3, "content_hash": "5357fde9da7b690e7b75e28f31d1f09f4380ab0740c77d04487c2fd5ae7d611e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:cff2a8147760eab9e92bce598c802b363183a2da775b6107bdc7a0e5539ca71d", "content": "The `spring-integration-rsocket` module is now available with channel adapter implementations for RSocket protocol support.\nSee xref:rsocket.adoc[RSocket Support] for more information.\n\n[[x5.2-rate-limit-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "RSocket Support", "heading_level": 3, "file_order": 178, "section_index": 4, "content_hash": "cff2a8147760eab9e92bce598c802b363183a2da775b6107bdc7a0e5539ca71d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:beb4d9d5b09c5ff500eb1d318fc103b33d43bb9f66de241c7b1e2896481ee088", "content": "The `RateLimiterRequestHandlerAdvice` is now available for limiting requests rate on handlers.\nSee xref:handler-advice/classes.adoc#rate-limiter-advice[Rate Limiter Advice] for more information.\n\n[[x5.2-cache-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "Rate Limit Advice Support", "heading_level": 3, "file_order": 178, "section_index": 5, "content_hash": "beb4d9d5b09c5ff500eb1d318fc103b33d43bb9f66de241c7b1e2896481ee088", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:f4fbafae4e56e276e8c0319e1294426456ffe28ce062aaed7495d233e60db760", "content": "The `CacheRequestHandlerAdvice` is now available for caching request results on handlers.\nSee xref:handler-advice/classes.adoc#cache-advice[Caching Advice] for more information.\n\n[[x5.2-kotlin-scripts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "Caching Advice Support", "heading_level": 3, "file_order": 178, "section_index": 6, "content_hash": "f4fbafae4e56e276e8c0319e1294426456ffe28ce062aaed7495d233e60db760", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:c376777d86fb88c46a6f43cb1d8aec3a329c0d2a6bb9d55031c760d30a33b4b0", "content": "The JSR223 scripting module now includes a support for Kotlin scripts.\nSee xref:scripting.adoc[Scripting Support] for more information.\n\n[[x5.2-flux-aggregator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "Kotlin Scripts Support", "heading_level": 3, "file_order": 178, "section_index": 7, "content_hash": "c376777d86fb88c46a6f43cb1d8aec3a329c0d2a6bb9d55031c760d30a33b4b0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:f50c2e4dc20268902bf5083b2ccc1741af035cd52be57d3debac41b846d76b22", "content": "The `FluxAggregatorMessageHandler` is now available for grouping and windowing messages logic based on the Project Reactor `Flux` operators.\nSee xref:aggregator.adoc#flux-aggregator[Flux Aggregator] for more information.\n\n[[x5.2-sftp-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "Flux Aggregator Support", "heading_level": 3, "file_order": 178, "section_index": 8, "content_hash": "f50c2e4dc20268902bf5083b2ccc1741af035cd52be57d3debac41b846d76b22", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:63a33508fe0deb4ce97e7657f85d128a298dd0946a784ee84617dda62107c337", "content": "The FTP and SFTP modules now provide an event listener for certain Apache Mina FTP/SFTP server events.\nSee xref:ftp/server-events.adoc[Apache Mina FTP Server Events] and xref:sftp/server-events.adoc[Apache Mina SFTP Server Events] for more information.\n\n[[x5.2-avro]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "FTP/SFTP Event Publisher", "heading_level": 3, "file_order": 178, "section_index": 9, "content_hash": "63a33508fe0deb4ce97e7657f85d128a298dd0946a784ee84617dda62107c337", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:37c1c79e60b47126f3f8b53b0adb70220d1c2ebfa517ce8e14b9c46c65d6724a", "content": "Simple Apache Avro transformers are now provided.\nSee xref:changes-5.1-5.2.adoc#x5.2-avro[Avro Transformers] for more information.\n\n[[x5.2-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "Avro Transformers", "heading_level": 3, "file_order": 178, "section_index": 10, "content_hash": "37c1c79e60b47126f3f8b53b0adb70220d1c2ebfa517ce8e14b9c46c65d6724a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:36493cda34d231c18a41cf93283ddc3f3733a584f3c3a37275353ab5013c77e3", "content": "The `JsonToObjectTransformer` now supports generics for the target object to deserialize into.\nSee xref:transformer.adoc#json-transformers[JSON Transformers] for more information.\n\nThe `splitter` now supports a `discardChannel` configuration option.\nSee xref:splitter.adoc[Splitter] for more information.\n\nThe Control Bus can now handle `Pausable` (extension of `Lifecycle`) operations.\nSee xref:control-bus.adoc[Control Bus] for more information.\n\nThe `Function<MessageGroup, Map<String, Object>>` strategy has been introduced for the aggregator component to merge and compute headers for output messages.\nSee xref:aggregator.adoc#aggregator-api[Aggregator Programming Model] for more information.\n\nAll the ``MessageHandlingException``s thrown in the framework, includes now a bean resource and source for back tracking a configuration part in case no end-user code involved.\nSee xref:scatter-gather.adoc#scatter-gather-error-handling[Error Handling] for more information.\n\nFor better end-user experience, Java DSL now provides a configurer variant for starting flow with a gateway interface.\nSee `IntegrationFlows.from(Class<?> serviceInterface, Consumer<GatewayProxySpec> endpointConfigurer)` JavaDocs for more information.\nAlso a `MethodArgsHolder` is now a root object for evaluation context for all the expressions in the `GatewayProxyFactoryBean`.\nThe `#args` and `#method` evaluation context variables are now deprecated.\nSee xref:gateway.adoc[Messaging Gateways] for more information.\n\n[[x5.2-amqp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "General Changes", "heading_level": 2, "file_order": 178, "section_index": 11, "content_hash": "36493cda34d231c18a41cf93283ddc3f3733a584f3c3a37275353ab5013c77e3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:5c3918d99648664f130789943c4f95a8f85f9248d442332c3d25e4339c8e2aa7", "content": "The outbound endpoints can now be configured to synthesize a \"nack\" if no publisher confirm is received within a timeout.\nSee xref:changes-4.0-4.1.adoc#x4.1-amqp-outbound-lazy-connect[Outbound Channel Adapter] for more information.\n\nThe inbound channel adapter can now receive batched messages as a `List<?>` payload instead of receiving a discrete message for each batch fragment.\nSee xref:amqp/inbound-channel-adapter.adoc#amqp-debatching[Batched Messages] for more information.\n\nThe outbound channel adapter can now be configured to block the calling thread until a publisher confirm (acknowledgment) is received.\nSee xref:amqp/outbound-channel-adapter.adoc[Outbound Channel Adapter] for more information.\n\n[[x5.2-file]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "AMQP Changes", "heading_level": 3, "file_order": 178, "section_index": 12, "content_hash": "5c3918d99648664f130789943c4f95a8f85f9248d442332c3d25e4339c8e2aa7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:a2c2dbb119a649646fd6dd7e6dc94ce0eeacee1dd282f251492135c45e109e4e", "content": "Some improvements to filtering remote files have been made.\nSee xref:file/remote-persistent-flf.adoc[Remote Persistent File List Filters] for more information.\n\n[[x5.2-tcp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "File Changes", "heading_level": 3, "file_order": 178, "section_index": 13, "content_hash": "a2c2dbb119a649646fd6dd7e6dc94ce0eeacee1dd282f251492135c45e109e4e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:373f559bd7ec8f76cea41fb1811b5d5bf2ca5c19826f654adcd982b2677ecc70", "content": "The length header used by the `ByteArrayLengthHeaderSerializer` can now include the length of the header in addition to the payload.\nSee xref:ip/tcp-connection-factories.adoc#tcp-codecs[Message Demarcation (Serializers and Deserializers)] for more information.\n\nWhen using a `TcpNioServerConnectionFactory`, priority is now given to accepting new connections over reading from existing connections, but it is configurable.\nSee xref:ip/note-nio.adoc[About Non-blocking I/O (NIO)] for more information.\n\nThe outbound gateway has a new property `closeStreamAfterSend`; when used with a new connection for each request/reply it signals EOF to the server, without closing the connection.\nThis is useful for servers that use the EOF to signal end of message instead of some delimiter in the data.\nSee xref:ip/tcp-gateways.adoc[TCP Gateways] for more information.\n\nThe client connection factories now support `connectTimeout` which causes an exception to be thrown if the connection is not established in that time.\nSee xref:ip.adoc#tcp-connection-factory[ TCP Connection Factories] for more information.\n\n`SoftEndOfStreamException` is now a `RuntimeException` instead of extending `IOException`.\n\n[[x5.2-mail]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "TCP Changes", "heading_level": 3, "file_order": 178, "section_index": 14, "content_hash": "373f559bd7ec8f76cea41fb1811b5d5bf2ca5c19826f654adcd982b2677ecc70", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:621c854ed14a76703d1226531e98e8ff7731be0da44db33aa1579817b7b3d21b", "content": "The `AbstractMailReceiver` has now an `autoCloseFolder` option (`true` by default), to disable an automatic folder close after a fetch, but populate `IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE` header instead for downstream interaction.\nSee xref:mail.adoc#mail-inbound[Mail-receiving Channel Adapter] for more information.\n\n[[x5.2-http]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "Mail Changes", "heading_level": 3, "file_order": 178, "section_index": 15, "content_hash": "621c854ed14a76703d1226531e98e8ff7731be0da44db33aa1579817b7b3d21b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:70631d519b485c40a6ad3dccdd357781f2e902d8d893c8442ac8856e1e415a3c", "content": "The HTTP inbound endpoint now support a request payload validation.\nSee xref:http.adoc[HTTP Support] for more information.\n\n[[x5.2-webflux]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "HTTP Changes", "heading_level": 3, "file_order": 178, "section_index": 16, "content_hash": "70631d519b485c40a6ad3dccdd357781f2e902d8d893c8442ac8856e1e415a3c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:47cc607dc1ff96e8355774e392586903a7549a83b4a5afb76c7f355316b0d690", "content": "The `WebFluxRequestExecutingMessageHandler` now supports a `Publisher`, `Resource` and `MultiValueMap` as a request message `payload`.\nThe `WebFluxInboundEndpoint` now supports a request payload validation.\nSee xref:webflux.adoc[WebFlux Support] for more information.\n\n[[x5.2-mongodb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "WebFlux Changes", "heading_level": 3, "file_order": 178, "section_index": 17, "content_hash": "47cc607dc1ff96e8355774e392586903a7549a83b4a5afb76c7f355316b0d690", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:b83746ab42cfcab85b029315dec65507f084d8da3ac9021893c89507b06d3c63", "content": "The `MongoDbMessageStore` can now be configured with custom converters.\nSee xref:mongodb.adoc[MongoDB Support] for more information.\n\n[[x5.2-routers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "MongoDb Changes", "heading_level": 3, "file_order": 178, "section_index": 18, "content_hash": "b83746ab42cfcab85b029315dec65507f084d8da3ac9021893c89507b06d3c63", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:5f43ef3f7d6e8d61bb0907eb1009cc968078ac504dab05fe64b9056c904dfb13", "content": "You can now disable falling back to the channel key as the channel bean name.\nSee xref:router/dynamic-routers.adoc[Dynamic Routers] for more information.\n\n[[x5.2--ftp-sftp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "Router Changes", "heading_level": 3, "file_order": 178, "section_index": 19, "content_hash": "5f43ef3f7d6e8d61bb0907eb1009cc968078ac504dab05fe64b9056c904dfb13", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:dd512f3ae03437991e3a088a4e413197f023b56da0e0091bb1600f73699794bd", "content": "The `RotatingServerAdvice` is decoupled now from the `RotationPolicy` and its `StandardRotationPolicy`.\n\nThe remote file information, including host/port and directory are included now into message headers in the `AbstractInboundFileSynchronizingMessageSource` and `AbstractRemoteFileStreamingMessageSource` implementations.\nAlso this information is included into headers in the read operations results of the `AbstractRemoteFileOutboundGateway` implementations.\nThe FTP outbound endpoints now support `chmod` to change permissions on the uploaded file.\n(SFTP already supported it since version 4.3).\nSee xref:ftp.adoc[FTP(S) Support] and xref:sftp.adoc[SFTP Support] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.1-5.2.adoc", "title": "changes-5.1-5.2", "heading": "FTP/SFTP Changes", "heading_level": 3, "file_order": 178, "section_index": 20, "content_hash": "dd512f3ae03437991e3a088a4e413197f023b56da0e0091bb1600f73699794bd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.1-5.2.adoc"}}
{"id": "sha256:454ac3fb0bd34c9d9494f5a9b1894df72d61493ec0912ecea7e454aea646ec36", "content": "[[migration-5.2-5.3]]\n\n[[x5.3-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "changes-5.2-5.3", "heading_level": 1, "file_order": 179, "section_index": 0, "content_hash": "454ac3fb0bd34c9d9494f5a9b1894df72d61493ec0912ecea7e454aea646ec36", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:826f3685abd033404091d64513a97342923f16e09f75ab9b2b177000515fcf65", "content": "[[x5.3-integration-pattern]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "New Components", "heading_level": 2, "file_order": 179, "section_index": 1, "content_hash": "826f3685abd033404091d64513a97342923f16e09f75ab9b2b177000515fcf65", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:b1633930fcb69d3fceb3426693b2b55f8a7910de9f304fd7bd9350581867386e", "content": "The `IntegrationPattern` abstraction has been introduced to indicate which enterprise integration pattern (an `IntegrationPatternType`) and category a Spring Integration component belongs to.\nSee its JavaDocs and xref:graph.adoc#integration-graph[Integration Graph] for more information about this abstraction and its use-cases.\n\n[[x5.3-reactive-message-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "Integration Pattern", "heading_level": 3, "file_order": 179, "section_index": 2, "content_hash": "b1633930fcb69d3fceb3426693b2b55f8a7910de9f304fd7bd9350581867386e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:23cf92663e134e55dbfb47202eb888120a6aeffca3662ebc7cfb936f5f9983ab", "content": "The `ReactiveMessageHandler` is now natively supported in the framework.\nSee xref:reactive-streams.adoc#reactive-message-handler[ReactiveMessageHandler] for more information.\n\n[[x5.3-reactive-message-source-producer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "`ReactiveMessageHandler`", "heading_level": 3, "file_order": 179, "section_index": 3, "content_hash": "23cf92663e134e55dbfb47202eb888120a6aeffca3662ebc7cfb936f5f9983ab", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:a8af0b123093cddb69c37fe076a6dc50882f776ea72a15313d662ececc1aba23", "content": "The `ReactiveMessageSourceProducer` is a reactive implementation of the `MessageProducerSupport` to wrap a provided `MessageSource` into a `Flux` for on demand `receive()` calls.\nSee xref:reactive-streams.adoc[Reactive Streams Support] for more information.\n\n[[x5.3-java-dsl-extensions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "`ReactiveMessageSourceProducer`", "heading_level": 3, "file_order": 179, "section_index": 4, "content_hash": "a8af0b123093cddb69c37fe076a6dc50882f776ea72a15313d662ececc1aba23", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:7c1d746e3e50a3a1ef6d3f3da3e7dc6c649047ff8ed6b3df1533a0742a0df8f9", "content": "A new `IntegrationFlowExtension` API has been introduced to allow extension of the existing Java DSL with custom or composed EIP-operators.\nThis also can be used to introduce customizers for any out-of-the-box `IntegrationComponentSpec` extensions.\nSee xref:changes-5.2-5.3.adoc#x5.3-java-dsl-extensions[DSL Extensions] for more information.\n\n[[x5.3-kotlin-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "Java DSL Extensions", "heading_level": 3, "file_order": 179, "section_index": 5, "content_hash": "7c1d746e3e50a3a1ef6d3f3da3e7dc6c649047ff8ed6b3df1533a0742a0df8f9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:bb78cfd60d337a4855c4011943d64a52f74f1238c9a8cc21fceba00abdecb207", "content": "The Kotlin DSL for integration flow configurations has been introduced.\nSee xref:kotlin-dsl.adoc[Kotlin DSL Chapter] for more information.\n\n[[x5.3-reactive-request-handler-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "Kotlin DSL", "heading_level": 3, "file_order": 179, "section_index": 6, "content_hash": "bb78cfd60d337a4855c4011943d64a52f74f1238c9a8cc21fceba00abdecb207", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:d69bd8b002f3b93d8428410d4b8147c73f904530499adede78c3bdc3a12b4ae8", "content": "A `ReactiveRequestHandlerAdvice` is provided to customize `Mono` replies from message handlers.\nSee xref:handler-advice/reactive.adoc[Reactive Advice] for more information.\n\n[[x5.3-handle-message-advice-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "ReactiveRequestHandlerAdvice", "heading_level": 3, "file_order": 179, "section_index": 7, "content_hash": "d69bd8b002f3b93d8428410d4b8147c73f904530499adede78c3bdc3a12b4ae8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:68b0056aa336fff465c1e5fbf4fa9d97fe7f079f84456425acf47c6577f47077", "content": "A `HandleMessageAdviceAdapter` is provided to wrap any `MethodInterceptor` for applying on the `MessageHandler.handleMessage()` instead of a default `AbstractReplyProducingMessageHandler.RequestHandler.handleRequestMessage()` behavior.\nSee xref:handler-advice/handle-message.adoc[Handling Message Advice] for more information.\n\n[[x5.3-mongodb-reactive-channel-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "HandleMessageAdviceAdapter", "heading_level": 3, "file_order": 179, "section_index": 8, "content_hash": "68b0056aa336fff465c1e5fbf4fa9d97fe7f079f84456425acf47c6577f47077", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:b91127d734381e86d631b818f3a94489d7306164044f5ceb8c55d466578749c3", "content": "The `spring-integration-mongodb` module now provides channel adapter implementations for the Reactive MongoDb driver support in Spring Data.\nAlso, a reactive implementation for MongoDb change stream support is present with the `MongoDbChangeStreamMessageProducer`.\nSee xref:mongodb.adoc[MongoDB Support] for more information.\n\n[[x5.3-receive-message-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "MongoDB Reactive Channel Adapters", "heading_level": 3, "file_order": 179, "section_index": 9, "content_hash": "b91127d734381e86d631b818f3a94489d7306164044f5ceb8c55d466578749c3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:b02c10ca26d881456afedcfda21b0b287f0b4a530b7070bbb83cd85bbe0b0247", "content": "A special `ReceiveMessageAdvice` has been introduced to proxy exactly `MessageSource.receive()` or `PollableChannel.receive()`.\nSee xref:polling-consumer.adoc#smart-polling[Smart Polling] for more information.\n\n[[x5.3-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "ReceiveMessageAdvice", "heading_level": 3, "file_order": 179, "section_index": 10, "content_hash": "b02c10ca26d881456afedcfda21b0b287f0b4a530b7070bbb83cd85bbe0b0247", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:bbed454cbffeb279cf4ea9fcd77ce9d2b84a6a521d00bee7a0d3a3e4a2cf5f57", "content": "The gateway proxy now doesn't proxy `default` methods by default.\nSee xref:gateway.adoc#gateway-calling-default-methods[Invoking `default` Methods] for more information.\n\nInternal components (such as `_org.springframework.integration.errorLogger`) now have a shortened name when they are represented in the integration graph.\nSee xref:graph.adoc#integration-graph[Integration Graph] for more information.\n\nIn the aggregator, when the `MessageGroupProcessor` returns a `Message`, the `MessageBuilder.popSequenceDetails()` is performed on the output message if the `sequenceDetails` matches the header in the first message of the group.\nSee xref:aggregator.adoc#aggregator-api[Aggregator Programming Model] for more information.\n\nA new `publishSubscribeChannel()` operator, based on the `BroadcastCapableChannel` and `BroadcastPublishSubscribeSpec`, was added into Java DSL.\nThis fluent API has its advantage when we configure sub-flows as pub-sub subscribers for broker-backed channels like `SubscribableJmsChannel`, `SubscribableRedisChannel` etc.\nSee xref:dsl/java-subflows.adoc[Sub-flows support] for more information.\n\nTransactional support in Spring Integration now also includes options to configure a `ReactiveTransactionManager` if a `MessageSource` or `MessageHandler` implementation produces a reactive type for payload to send.\nSee `TransactionInterceptorBuilder` for more information.\nSee also xref:transactions.adoc#reactive-transactions[Reactive Transactions].\n\nA new `intercept()` operator to register `ChannelInterceptor` instances without creating explicit channels was added into Java DSL.\nSee xref:dsl/java-intercept.adoc[Operator intercept()] for more information.\n\nThe `MessageStoreSelector` has a new mechanism to compare an old and new value.\nSee xref:handler-advice/idempotent-receiver.adoc[Idempotent Receiver Enterprise Integration Pattern] for more information.\n\nThe `MessageProducerSupport` base class now has a `subscribeToPublisher(Publisher<? extends Message<?>>)` API to allow implementation of message-driven producer endpoints which emit messages via reactive `Publisher`.\nSee xref:reactive-streams.adoc[Reactive Streams Support] for more information.\n\n[[x5.3-amqp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "General Changes", "heading_level": 2, "file_order": 179, "section_index": 11, "content_hash": "bbed454cbffeb279cf4ea9fcd77ce9d2b84a6a521d00bee7a0d3a3e4a2cf5f57", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:a82df9e1d312a6fcbeda4fc4b1780d335675235c5de7a4bd2ab29c937d369b54", "content": "The outbound channel adapter has a new property `multiSend` allowing multiple messages to be sent within the scope of one `RabbitTemplate` invocation.\nSee xref:amqp/outbound-channel-adapter.adoc[AMQP Outbound Channel Adapter] for more information.\n\nThe inbound channel adapter now supports a listener container with the `consumerBatchEnabled` property set to `true`.\nSee xref:amqp/inbound-channel-adapter.adoc[AMQP Inbound Channel Adapter]\n\n[[x5.3-http]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "AMQP Changes", "heading_level": 2, "file_order": 179, "section_index": 12, "content_hash": "a82df9e1d312a6fcbeda4fc4b1780d335675235c5de7a4bd2ab29c937d369b54", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:10e91fff5b521a7d9e9c0445b8740c23fa262e5ba0c4b7888914f22f97897f02", "content": "The `encodeUri` property on the `AbstractHttpRequestExecutingMessageHandler` has been deprecated in favor of newly introduced `encodingMode`.\nSee `DefaultUriBuilderFactory.EncodingMode` JavaDocs and xref:http/namespace.adoc#http-uri-encoding[Controlling URI Encoding] for more information.\nThis also affects `WebFluxRequestExecutingMessageHandler`, respective Java DSL and XML configuration.\nThe same option is added into an `AbstractWebServiceOutboundGateway`.\n\n[[x5.3-ws]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "HTTP Changes", "heading_level": 2, "file_order": 179, "section_index": 13, "content_hash": "10e91fff5b521a7d9e9c0445b8740c23fa262e5ba0c4b7888914f22f97897f02", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:30fa79fe07132084371db8b0164aa2a773715712e09f67e11d22b8a17740338b", "content": "Java DSL support has been added for Web Service components.\nThe `encodeUri` property on the `AbstractWebServiceOutboundGateway` has been deprecated in favor of newly introduced `encodingMode` - similar to HTTP changes above.\nSee xref:ws.adoc[Web Services Support] for more information.\n\n[[x5.3-tcp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "Web Services Changes", "heading_level": 2, "file_order": 179, "section_index": 14, "content_hash": "30fa79fe07132084371db8b0164aa2a773715712e09f67e11d22b8a17740338b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:d030c2d2ac4adc5884bcce016b3cadac563e6a47ef2a0a78d8e118ac397177fe", "content": "The `FailoverClientConnectionFactory` no longer fails back, by default, until the current connection fails.\nSee xref:ip/tcp-connection-factories.adoc#failover-cf[TCP Failover Client Connection Factory] for more information.\n\nThe `TcpOutboundGateway` now supports asynchronous request/reply.\nSee xref:ip/tcp-gateways.adoc[TCP Gateways] for more information.\n\nYou can now configure client connections to perform some arbitrary test on new connections.\nSee xref:ip/testing-connections.adoc[Testing Connections] for more information.\n\n[[x5.3-rsocket]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "TCP Changes", "heading_level": 2, "file_order": 179, "section_index": 15, "content_hash": "d030c2d2ac4adc5884bcce016b3cadac563e6a47ef2a0a78d8e118ac397177fe", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:03ecffcf9db1e4cc8d01f4dcb73c53da24fb93725f1bb29464a6ac908121d9b2", "content": "A `decodeFluxAsUnit` option has been added to the `RSocketInboundGateway` with the meaning to decode incoming `Flux` as a single unit or apply decoding for each event in it.\nSee xref:rsocket.adoc#rsocket-inbound[RSocket Inbound Gateway] for more information.\n\n[[x5.3-zookeeper]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "RSocket Changes", "heading_level": 2, "file_order": 179, "section_index": 16, "content_hash": "03ecffcf9db1e4cc8d01f4dcb73c53da24fb93725f1bb29464a6ac908121d9b2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:d0c3c72be1ca0e6c7fc4a0c743d3c8647ae785e23f3b5c00437710e55a272bb9", "content": "A `LeaderInitiatorFactoryBean` (as well as its XML `<int-zk:leader-listener>`) exposes a `candidate` option for more control over a `Candidate` configuration.\nSee xref:zookeeper.adoc#zk-leadership[Leadership event handling] for more information.\n\n[[x5.3-mqtt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "Zookeeper Changes", "heading_level": 2, "file_order": 179, "section_index": 17, "content_hash": "d0c3c72be1ca0e6c7fc4a0c743d3c8647ae785e23f3b5c00437710e55a272bb9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:a9552a99631090a011a668ca2692aa5304a9f932ec4597963c7d3066064dcd40", "content": "The inbound channel adapter can now be configured to provide user control over when a message is acknowledged as being delivered.\nSee xref:mqtt.adoc#mqtt-ack-mode[Manual Acks] for more information.\n\nThe outbound adapter now publishes a `MqttConnectionFailedEvent` when a connection can't be created, or is lost.\nPreviously, only the inbound adapter did so.\nSee xref:mqtt.adoc#mqtt-events[MQTT Events].\n\n[[x5.3-sftp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "MQTT Changes", "heading_level": 2, "file_order": 179, "section_index": 18, "content_hash": "a9552a99631090a011a668ca2692aa5304a9f932ec4597963c7d3066064dcd40", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:d00a9c8e26ebdd4361f501e70dd5e89206505a9d73cde15839da8269199b2f7c", "content": "The `FileTransferringMessageHandler` (for FTP and SFTP, for example) in addition to `File`, `byte[]`, `String` and `InputStream` now also supports an `org.springframework.core.io.Resource`.\nSee xref:sftp.adoc[SFTP Support] and xref:ftp.adoc[FTP Support] for more information.\n\n[[x5.3-file]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "(S)FTP Changes", "heading_level": 2, "file_order": 179, "section_index": 19, "content_hash": "d00a9c8e26ebdd4361f501e70dd5e89206505a9d73cde15839da8269199b2f7c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:686baba3d66134ffcf192aad24a148dd24e7894fe3e12df9ff2dc6b3adb705b8", "content": "The `FileSplitter` doesn't require a Jackson processor (or similar) dependency any more for the `markersJson` mode.\nIt uses a `SimpleJsonSerializer` for a straightforward string representation of the `FileSplitter.FileMarker` instances.\nSee xref:file/splitter.adoc[FileSplitter] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.2-5.3.adoc", "title": "changes-5.2-5.3", "heading": "File Changes", "heading_level": 2, "file_order": 179, "section_index": 20, "content_hash": "686baba3d66134ffcf192aad24a148dd24e7894fe3e12df9ff2dc6b3adb705b8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.2-5.3.adoc"}}
{"id": "sha256:0ea87d2d3bf736e3048d843d7e153c203a63bb433b487ecb70dabb2668a126be", "content": "[[migration-5.3-5.4]]\n\n[[x5.4-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.3-5.4.adoc", "title": "changes-5.3-5.4", "heading": "changes-5.3-5.4", "heading_level": 1, "file_order": 180, "section_index": 0, "content_hash": "0ea87d2d3bf736e3048d843d7e153c203a63bb433b487ecb70dabb2668a126be", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.3-5.4.adoc"}}
{"id": "sha256:02c3b323424a6aa9e3db4ecb0d448d36a5c0737b2a4d5bf5b921b8a93f4105e9", "content": "[[x5.4-sik]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.3-5.4.adoc", "title": "changes-5.3-5.4", "heading": "New Components", "heading_level": 2, "file_order": 180, "section_index": 1, "content_hash": "02c3b323424a6aa9e3db4ecb0d448d36a5c0737b2a4d5bf5b921b8a93f4105e9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.3-5.4.adoc"}}
{"id": "sha256:948cd72863d14c31588a3b95da5ece8a5ce2ed73def66f9031678eaa1ee927c4", "content": "The standalone https://projects.spring.io/spring-integration-kafka/[Spring Integration for Apache Kafka] project has been merged as a `spring-integration-kafka` module to this project.\n\nThe `KafkaProducerMessageHandler` `sendTimeoutExpression` default has changed.\n\nYou can now access the `Future<?>` for underlying `send()` operations.\n\nSee xref:kafka.adoc[Spring for Apache Kafka Support] for more information.\n\n[[x5.4-r2dbc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.3-5.4.adoc", "title": "changes-5.3-5.4", "heading": "Channel Adapters for Apache Kafka", "heading_level": 2, "file_order": 180, "section_index": 2, "content_hash": "948cd72863d14c31588a3b95da5ece8a5ce2ed73def66f9031678eaa1ee927c4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.3-5.4.adoc"}}
{"id": "sha256:fc8650470d0c7c4f6f5d3ed19945b2fed2b9694b9aa95b10ea9f5e324476a9b7", "content": "The Channel Adapters for R2DBC database interaction have been introduced.\nSee xref:r2dbc.adoc[R2DBC Support] for more information.\n\n[[x5.4-redis-stream]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.3-5.4.adoc", "title": "changes-5.3-5.4", "heading": "R2DBC Channel Adapters", "heading_level": 2, "file_order": 180, "section_index": 3, "content_hash": "fc8650470d0c7c4f6f5d3ed19945b2fed2b9694b9aa95b10ea9f5e324476a9b7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.3-5.4.adoc"}}
{"id": "sha256:bbc59c221610cf37bd45455e26efef0aab18c0406bae273cd1e4be14bf119e5d", "content": "The Channel Adapters for Redis Stream support have been introduced.\nSee xref:redis.adoc#redis-stream-outbound[Redis Stream Outbound Channel Adapter] for more information.\n\n[[x5.4-renewable-lock]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.3-5.4.adoc", "title": "changes-5.3-5.4", "heading": "Redis Stream Support", "heading_level": 2, "file_order": 180, "section_index": 4, "content_hash": "bbc59c221610cf37bd45455e26efef0aab18c0406bae273cd1e4be14bf119e5d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.3-5.4.adoc"}}
{"id": "sha256:2e3e9d1c4ac085a63263fa9e4783f4779d20e97c399fdbe67b08a44ec52285fb", "content": "A Renewable lock registry has been introduced to allow renew lease of a distributed lock.\nSee xref:jdbc.adoc#jdbc-lock-registry[JDBC implementation] for more information.\n\n[[x5.4-zeromq]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.3-5.4.adoc", "title": "changes-5.3-5.4", "heading": "Renewable Lock Registry", "heading_level": 2, "file_order": 180, "section_index": 5, "content_hash": "2e3e9d1c4ac085a63263fa9e4783f4779d20e97c399fdbe67b08a44ec52285fb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.3-5.4.adoc"}}
{"id": "sha256:ac13c87895062f39458086af972722dbb2f3c6a5c695ad0e41f927515382398a", "content": "`ZeroMqChannel`, `ZeroMqMessageHandler` and `ZeroMqMessageProducer` have been introduced.\nSee xref:zeromq.adoc[ZeroMQ Support] for more information.\n\n[[x5.4-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.3-5.4.adoc", "title": "changes-5.3-5.4", "heading": "ZeroMQ Support", "heading_level": 2, "file_order": 180, "section_index": 6, "content_hash": "ac13c87895062f39458086af972722dbb2f3c6a5c695ad0e41f927515382398a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.3-5.4.adoc"}}
{"id": "sha256:607c52e5ad3a3735d164a771d3f78f62224f3f568b4b66eb9b69657f65810819", "content": "The one-way messaging gateway (the `void` method return type) now sets a `nullChannel` explicitly into the `replyChannel` header to ignore any possible downstream replies.\nSee xref:gateway.adoc#gateway-default-reply-channel[Setting the Default Reply Channel] for more information.\n\nAlso the gateway method invokers (`GatewayProxyFactoryBean.MethodInvocationGateway`) are now supplied with the managed bean name as a combination of gateway proxy bean name plus method signature.\nFor example: `sampleGateway#echo(String)`.\nThis effects message history and metrics exposed for the gateway method calls and also give fine-grained logs during start and close of application context.\n\nThe aggregator (and resequencer) can now expire orphaned groups (groups in a persistent store where no new messages arrive after an application restart).\nSee xref:aggregator.adoc#aggregator-expiring-groups[Aggregator Expiring Groups] for more information.\n\nThe legacy metrics that were replaced by Micrometer meters have been removed.\n\nThe xref:barrier.adoc[Thread Barrier] has now two separate timeout options: `requestTimeout` and `triggerTimeout`.\n\n[[x5.4-tcp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.3-5.4.adoc", "title": "changes-5.3-5.4", "heading": "General Changes", "heading_level": 2, "file_order": 180, "section_index": 7, "content_hash": "607c52e5ad3a3735d164a771d3f78f62224f3f568b4b66eb9b69657f65810819", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.3-5.4.adoc"}}
{"id": "sha256:810ab41129c1fc2c46c3b20549d24054825059e44636f060a25b5b0009c885b8", "content": "Connection factories now support multiple sending components (`TcpSender`); they remain limited to one receiving component (`TcpListener`).\nThis allows, for example, an inbound gateway and outbound channel adapter to share the same factory, supporting both request/reply and arbitrary messaging from the server to the client.\nShared factories should not be used with outbound gateways, unless single-use connections or the `ThreadAffinityClientConnectionFactory` are being used.\nSee xref:ip/correlation.adoc#ip-collaborating-adapters[Collaborating Channel Adapters] and xref:ip/tcp-gateways.adoc[TCP Gateways] for more information.\n\nThe UDP channel adapters can now be configured with a `SocketCustomizer` which allows the setting of socket properties that are not directly supported by the adapters.\nSee xref:ip/udp-adapters.adoc[UDP Adapters] for more information.\n\n[[x5.4-amqp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.3-5.4.adoc", "title": "changes-5.3-5.4", "heading": "TCP/UDP Changes", "heading_level": 2, "file_order": 180, "section_index": 8, "content_hash": "810ab41129c1fc2c46c3b20549d24054825059e44636f060a25b5b0009c885b8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.3-5.4.adoc"}}
{"id": "sha256:a8a15c76dbc72a33132399f72f075e2a26f39ee26a23e01685c3c50e0bc0cc62", "content": "The outbound endpoints now have a new mechanism for handling publisher confirms and returns.\nSee xref:amqp/alternative-confirms-returns.adoc[Alternative Mechanism for Publisher Confirms and Returns] for more information.\n\nA new `BatchMode.EXTRACT_PAYLOAD_WITH_HEADERS` is supported by the `AmqpInboundChannelAdapter`.\nSee xref:amqp/inbound-channel-adapter.adoc[Inbound Channel Adapter] for more information.\n\n[[x5.4-mail]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.3-5.4.adoc", "title": "changes-5.3-5.4", "heading": "AMQP Changes", "heading_level": 2, "file_order": 180, "section_index": 9, "content_hash": "a8a15c76dbc72a33132399f72f075e2a26f39ee26a23e01685c3c50e0bc0cc62", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.3-5.4.adoc"}}
{"id": "sha256:ac1b5cda06b730cd5d3ce4415dc4f6516c073ad0a15c2f16aa5d092a05821a97", "content": "The `AbstractMailReceiver` can now produce the `MimeMessage` as-is without eager fetching its content.\nSee xref:mail.adoc#mail-inbound[Mail-receiving Channel Adapter] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.3-5.4.adoc", "title": "changes-5.3-5.4", "heading": "Mail Changes", "heading_level": 2, "file_order": 180, "section_index": 10, "content_hash": "ac1b5cda06b730cd5d3ce4415dc4f6516c073ad0a15c2f16aa5d092a05821a97", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.3-5.4.adoc"}}
{"id": "sha256:7e62d1fbb4b87b983719e90bf868c261b81c0da7fb9951361fb191c181442dea", "content": "[[migration-5.4-5.5]]\n\n[[x5.5-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "changes-5.4-5.5", "heading_level": 1, "file_order": 181, "section_index": 0, "content_hash": "7e62d1fbb4b87b983719e90bf868c261b81c0da7fb9951361fb191c181442dea", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:ccd7ca7c84c2b94517781795e67ef2aeb3d2aee90be351a99d36cc87707c3976", "content": "[[x5.5-file-aggregator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "New Components", "heading_level": 2, "file_order": 181, "section_index": 1, "content_hash": "ccd7ca7c84c2b94517781795e67ef2aeb3d2aee90be351a99d36cc87707c3976", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:9aea20b3fb60916bb4f8c531acd2cb274c028825ecd59b60158fb130ed493f56", "content": "A `FileSplitter.FileMaker`-based implementation of `CorrelationStrategy`, `ReleaseStrategy` and `MessageGroupProcessor` as a `FileAggregator` component was introduced.\nSee xref:file/aggregator.adoc[File Aggregator] for more information.\n\n[[x5.5-mqtt-v5]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "File Aggregator", "heading_level": 2, "file_order": 181, "section_index": 2, "content_hash": "9aea20b3fb60916bb4f8c531acd2cb274c028825ecd59b60158fb130ed493f56", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:c3505c0189beba5ade728c1f87c88a54a8ff6078f2b96585f76fc58e1236a740", "content": "The `Mqttv5PahoMessageDrivenChannelAdapter` and `Mqttv5PahoMessageHandler` (including respective `MqttHeaderMapper`) were introduced to support MQTT v5 protocol communication.\nSee xref:mqtt.adoc#mqtt-v5[MQTT v5 Support] for more information.\n\n[[x5.5-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "MQTT v5 Support", "heading_level": 2, "file_order": 181, "section_index": 3, "content_hash": "c3505c0189beba5ade728c1f87c88a54a8ff6078f2b96585f76fc58e1236a740", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:653586ca0efa45baf888f543a86ffe26c8b8ba50a3c0779334694c7b6b1d9466", "content": "All the persistent `MessageGroupStore` implementation provide a `streamMessagesForGroup(Object groupId)` contract based on the target database streaming API.\nSee xref:message-store.adoc[Message Store] for more information.\n\nThe `integrationGlobalProperties` bean (if declared) must be now an instance of `org.springframework.integration.context.IntegrationProperties` instead of `java.util.Properties`, which support is deprecated for backward compatibility.\nThe `spring.integration.channels.error.requireSubscribers=true` global property is added to indicate that the global default `errorChannel` must be configured with the `requireSubscribers` option (or not).\nThe `spring.integration.channels.error.ignoreFailures=true` global property is added to indicate that the global default `errorChannel` must ignore (or not) dispatching errors and pass the message to the next handler.\nSee xref:configuration/global-properties.adoc[Global Properties] for more information.\n\nAn `AbstractPollingEndpoint` (source polling channel adapter and polling consumer) treats `maxMessagesPerPoll == 0` as to skip calling the source.\nIt can be changed to different value later on, e.g. via a Control Bus.\nSee xref:endpoint.adoc#endpoint-pollingconsumer[Polling Consumer] for more information.\n\nThe `ConsumerEndpointFactoryBean` now accept a `reactiveCustomizer` `Function` to any input channel as reactive stream source and use a `ReactiveStreamsConsumer` underneath.\nThis is covered as a `ConsumerEndpointSpec.reactive()` option in Java DSL and as a `@Reactive` nested annotation for the messaging annotations.\nSee xref:reactive-streams.adoc[Reactive Streams Support] for more information.\n\nThe `groupTimeoutExpression` for a correlation message handler (an `Aggregator` and `Resequencer`) can now be evaluated to a `java.util.Date` for some fine-grained scheduling use-cases.\nAlso the `BiFunction groupConditionSupplier` option is added to the `AbstractCorrelatingMessageHandler` to supply a `MessageGroup` condition against a message to be added to the group.\nSee xref:overview.adoc#overview-endpoints-aggregator[Aggregator] for more information.\n\nThe `MessageGroup` abstraction can be supplied with a `condition` to evaluate later on to make a decision for the group.\nSee xref:message-store.adoc#message-group-condition[Message Group Condition] for more information.\n\n[[x5.5-integration-flows-composition]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "General Changes", "heading_level": 2, "file_order": 181, "section_index": 4, "content_hash": "653586ca0efa45baf888f543a86ffe26c8b8ba50a3c0779334694c7b6b1d9466", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:d69cdc32a6b6e2200f8a4204de1e2cd62f0af3b940246432a990420841a1beb9", "content": "The new `IntegrationFlows.from(IntegrationFlow)` factory method has been added to allow starting the current `IntegrationFlow` from the output of an existing flow.\nIn addition, the `IntegrationFlowDefinition` has added a `to(IntegrationFlow)` terminal operator to continue the current flow at the input channel of some other flow.\nSee xref:dsl/integration-flows-composition.adoc[Integration Flows Composition] for more information.\n\n[[x5.5-amqp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "Integration Flows Composition", "heading_level": 2, "file_order": 181, "section_index": 5, "content_hash": "d69cdc32a6b6e2200f8a4204de1e2cd62f0af3b940246432a990420841a1beb9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:620f6c860ceb2518dc16665f7bcef8ed1cd569b56d5b558b5912c09f125d76f5", "content": "The `AmqpInboundChannelAdapter` and `AmqpInboundGateway` (and the respective Java DSL builders) now support an `org.springframework.amqp.rabbit.retry.MessageRecoverer` as an AMQP-specific alternative to the general purpose `RecoveryCallback`.\nSee xref:amqp.adoc[AMQP Support] for more information.\n\n[[x5.5-redis]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "AMQP Changes", "heading_level": 2, "file_order": 181, "section_index": 6, "content_hash": "620f6c860ceb2518dc16665f7bcef8ed1cd569b56d5b558b5912c09f125d76f5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:e28b26ce32d298097514bafcd26e9527c1026d7ddaac316027ae6c87d143f0c6", "content": "The `ReactiveRedisStreamMessageProducer` has now setters for all the `StreamReceiver.StreamReceiverOptionsBuilder` options, including an `onErrorResume` function.\nSee xref:redis.adoc[Redis Support] for more information.\n\n[[x5.5-http]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "Redis Changes", "heading_level": 2, "file_order": 181, "section_index": 7, "content_hash": "e28b26ce32d298097514bafcd26e9527c1026d7ddaac316027ae6c87d143f0c6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:6e3efa3e3595cbe909e840faaac26e2706d38623ae0fd24566a4aa656f52c21e", "content": "The `HttpRequestExecutingMessageHandler` doesn't fallback to the `application/x-java-serialized-object` content type any more and lets the `RestTemplate` make the final decision for the request body conversion based on the `HttpMessageConverter` provided.\nIt also has now an `extractResponseBody` flag (which is `true` by default) to return just the response body, or to return the whole `ResponseEntity` as the reply message payload, independently of the provided `expectedResponseType`.\nSame option is presented for the `WebFluxRequestExecutingMessageHandler`, too.\nSee xref:http.adoc[HTTP Support] for more information.\n\n[[x5.5-file]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "HTTP Changes", "heading_level": 2, "file_order": 181, "section_index": 8, "content_hash": "6e3efa3e3595cbe909e840faaac26e2706d38623ae0fd24566a4aa656f52c21e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:bb913f2ebea1f459ae41d192e81b67cead34c735d1d8f83b0a1b0bff7dd2926b", "content": "The persistent file list filters now have a boolean property `forRecursion`.\nSetting this property to `true`, also sets `alwaysAcceptDirectories`, which means that the recursive operation on the outbound gateways (`ls` and `mget`) will now always traverse the full directory tree each time.\nThis is to solve a problem where changes deep in the directory tree were not detected.\nIn addition, `forRecursion=true` causes the full path to files to be used as the metadata store keys; this solves a problem where the filter did not work properly if a file with the same name appears multiple times in different directories.\nIMPORTANT: This means that existing keys in a persistent metadata store will not be found for files beneath the top level directory.\nFor this reason, the property is `false` by default; this may change in a future release.\n\nThe `FileInboundChannelAdapterSpec` has now a convenient `recursive(boolean)` option instead of requiring an explicit reference to the `RecursiveDirectoryScanner`.\n\nThe `remoteDirectoryExpression` can now be used in the `mv` command for convenience.\n\n[[x5.5-mongodb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "File/FTP/SFTP Changes", "heading_level": 2, "file_order": 181, "section_index": 9, "content_hash": "bb913f2ebea1f459ae41d192e81b67cead34c735d1d8f83b0a1b0bff7dd2926b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:38c16e168fbf94927c2e651c1bb9fd2139bedcff21e75b84900e5a22b2a6724b", "content": "The `MongoDbMessageSourceSpec` was added into MongoDd Java DSL.\nAn `update` option is now exposed on both the `MongoDbMessageSource` and `ReactiveMongoDbMessageSource` implementations.\n\nSee xref:mongodb.adoc[MongoDb Support] for more information.\n\n[[x5.5-websocket]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "MongoDb Changes", "heading_level": 2, "file_order": 181, "section_index": 10, "content_hash": "38c16e168fbf94927c2e651c1bb9fd2139bedcff21e75b84900e5a22b2a6724b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:26223e15fc76c9f6fc1c3de9344bdc1acfb737209dacbc3e9b6742d88d804c8d", "content": "The WebSocket channel adapters based on `ServerWebSocketContainer` can now be registered and removed at runtime.\n\nSee xref:web-sockets.adoc[WebSockets Support] for more information.\n\n[[x5.5-jpa]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "WebSockets Changes", "heading_level": 2, "file_order": 181, "section_index": 11, "content_hash": "26223e15fc76c9f6fc1c3de9344bdc1acfb737209dacbc3e9b6742d88d804c8d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:cfe9807fe44115c62e528c65b893d72070cc8da67f44d6120272fbdb499f5db0", "content": "The `JpaOutboundGateway` now supports an `Iterable` message payload for a `PersistMode.DELETE`.\n\nSee xref:jpa/outbound-channel-adapter.adoc[Outbound Channel Adapter] for more information.\n\n[[x55-gw]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "JPA Changes", "heading_level": 2, "file_order": 181, "section_index": 12, "content_hash": "cfe9807fe44115c62e528c65b893d72070cc8da67f44d6120272fbdb499f5db0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:b54728ce820013b17aa9c685a9fd4aabdddd9e7d2141b1630a69728c3474de9b", "content": "Previously, when using XML configuration, `@Gateway.payloadExpression` was ignored for no-argument methods.\nThere is one possible breaking change - if the method is annotated with `@Payload` as well as `@Gateway` (with a different expression) previously, the `@Payload` would be applied, now the `@Gateway.payloadExpression` is applied.\nSee xref:gateway.adoc#gateway-configuration-annotations[Gateway Configuration with Annotations and XML] and xref:gateway.adoc#gateway-calling-no-argument-methods[Invoking No-Argument Methods] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.4-5.5.adoc", "title": "changes-5.4-5.5", "heading": "Gateway Changes", "heading_level": 2, "file_order": 181, "section_index": 13, "content_hash": "b54728ce820013b17aa9c685a9fd4aabdddd9e7d2141b1630a69728c3474de9b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.4-5.5.adoc"}}
{"id": "sha256:7ffd4c6f787f459b46e1ae435b5c3058997f32a60bf0364a3cbd25653b1cb371", "content": "[[migration-5.5-6.0]]\n\n[[x6.0-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "changes-5.5-6.0", "heading_level": 1, "file_order": 182, "section_index": 0, "content_hash": "7ffd4c6f787f459b46e1ae435b5c3058997f32a60bf0364a3cbd25653b1cb371", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:e79fce1fba4bc082735acbbe283430df64c7b98ce6edab56695e18c273b78a19", "content": "A Groovy DSL implementation for integration flow definitions has been added.\nSee xref:groovy-dsl.adoc[Groovy DSL] for more information.\n\n[[x6.0-mqtt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "New Components", "heading_level": 2, "file_order": 182, "section_index": 1, "content_hash": "e79fce1fba4bc082735acbbe283430df64c7b98ce6edab56695e18c273b78a19", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:403ea727d75a958065d1608abc53fa60309eb2490e1990c5841f9b6a2503b15e", "content": "A new MQTT `ClientManager` has been added to support a reusable MQTT connection across different channel adapters.\nSee xref:mqtt.adoc#mqtt-shared-client[Shared MQTT Client Support] for more information.\n\n[[x6.0-graphql]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "MQTT ClientManager", "heading_level": 3, "file_order": 182, "section_index": 2, "content_hash": "403ea727d75a958065d1608abc53fa60309eb2490e1990c5841f9b6a2503b15e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:b47e99c9bbe1d7e2478a31d8eddcbf9bf56ac67cfd943d59923a9babe5300d06", "content": "The GraphQL support has been added.\nSee xref:graphql.adoc[GraphQL Support] for more information.\n\n[[x6.0-camel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "GraphQL Support", "heading_level": 3, "file_order": 182, "section_index": 3, "content_hash": "b47e99c9bbe1d7e2478a31d8eddcbf9bf56ac67cfd943d59923a9babe5300d06", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:208b95bfb2123399d333cbfe14d727af6cc2e2dc4e71cc3be4de28e9b98c63d7", "content": "Support for Apache Camel routes has been introduced.\nSee xref:camel.adoc[Apache Camel Support] for more information.\n\n[[x6.0-hazelcast]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "Apache Camel Support", "heading_level": 3, "file_order": 182, "section_index": 4, "content_hash": "208b95bfb2123399d333cbfe14d727af6cc2e2dc4e71cc3be4de28e9b98c63d7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:80bfb082643c87ac4963461b081c26850a4d4f128c79724862e40b8969348c3e", "content": "The Hazelcast Spring Integration Extensions project has been migrated as the `spring-integration-hazelcast` module.\nSee xref:hazelcast.adoc[Hazelcast Support] for more information.\n\n[[x6.0-smb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "Hazelcast Support", "heading_level": 3, "file_order": 182, "section_index": 5, "content_hash": "80bfb082643c87ac4963461b081c26850a4d4f128c79724862e40b8969348c3e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:ed3dedc052cf8788808b8d231be3cae91fcfcf86d04aee731332f0f74d45c344", "content": "SMB support has been added from the Spring Integration Extensions project.\nThe Java DSL (see `org.springframework.integration.smb.dsl.Smb` factory) also has been added to this module.\nAn `SmbStreamingMessageSource` and `SmbOutboundGateway` implementation are introduced.\nSee xref:smb.adoc[SMB Support] for more information.\n\n[[x6.0-postgres]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "SMB Support", "heading_level": 3, "file_order": 182, "section_index": 6, "content_hash": "ed3dedc052cf8788808b8d231be3cae91fcfcf86d04aee731332f0f74d45c344", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:4e86d66c448e4f57d526cea9fddfe069e694fa55ccf263f814f15f8d5077a1e1", "content": "A `PostgresSubscribableChannel` allows to receive push notifications via `PostgresChannelMessageTableSubscriber` upon new messages add to the `JdbcChannelMessageStore`.\n\nSee xref:jdbc/message-store.adoc#postgresql-push[PostgreSQL: Receiving Push Notifications] for more information.\n\n[[x6.0-rmq]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "PostgreSQL Push Notification", "heading_level": 3, "file_order": 182, "section_index": 7, "content_hash": "4e86d66c448e4f57d526cea9fddfe069e694fa55ccf263f814f15f8d5077a1e1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:da67ee1bcaa774e0527ddf28f3631f13f73213a4866e22c12ba9befe68e9efeb", "content": "The AMQP module has been enhanced to provide support for inbound and outbound channel adapters using RabbitMQ Stream Queues.\nSee xref:amqp/rmq-streams.adoc[RabbitMQ Stream Queue Support] for more information.\n\n[[x6.0-sftp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "RabbitMQ Stream Queue Support", "heading_level": 3, "file_order": 182, "section_index": 8, "content_hash": "da67ee1bcaa774e0527ddf28f3631f13f73213a4866e22c12ba9befe68e9efeb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:4e0273e3ebc0c02d0343a6b82b369dd435d51b30521f4ad8e21a41ddbfdb257a", "content": "The SFTP modules has been fully reworked from outdated JCraft JSch library to more robust and modern `org.apache.sshd:sshd-sftp` module of the Apache MINA project.\n\nSee xref:sftp.adoc[SFTP Adapters] for more information.\n\n[[x6.0-micrometer-observation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "Apache MINA SFTP", "heading_level": 3, "file_order": 182, "section_index": 9, "content_hash": "4e0273e3ebc0c02d0343a6b82b369dd435d51b30521f4ad8e21a41ddbfdb257a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:37bd70a0924087454da5079bbe2284cb09be08e012b719284386b81dccfdd17f", "content": "Enabling observation for timers and tracing using Micrometer is now supported.\nSee xref:metrics.adoc#micrometer-observation[Micrometer Observation] for more information.\n\n[[x6.0-graalmv-polyglot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "Micrometer Observation", "heading_level": 3, "file_order": 182, "section_index": 10, "content_hash": "37bd70a0924087454da5079bbe2284cb09be08e012b719284386b81dccfdd17f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:583b39c7fe4997668ab59ff22ab7807339d64f6c7dc3cf3cf28a40d74a40f9b1", "content": "The Scripting module now provides a `PolyglotScriptExecutor` implementation based on the GraalVM Polyglot support.\nJavaScript support is now based on this executor since its JSR223 implementation has been removed from Java by itself.\nSee xref:scripting.adoc[Scripting Support] for more information.\n\n[[x6.0-cassandra]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "GraalVM Polyglot Support", "heading_level": 3, "file_order": 182, "section_index": 11, "content_hash": "583b39c7fe4997668ab59ff22ab7807339d64f6c7dc3cf3cf28a40d74a40f9b1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:a2c4f68c01d3396cddded3711f2287d11d1e780d1ff72e2a24b04e546b958a01", "content": "The Apache Cassandra Spring Integration Extensions project has been migrated as the `spring-integration-cassandra` module.\nSee xref:cassandra.adoc[Apache Cassandra Support] for more information.\n\n[[x6.0-kotlin-coroutines]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "Apache Cassandra Support", "heading_level": 3, "file_order": 182, "section_index": 12, "content_hash": "a2c4f68c01d3396cddded3711f2287d11d1e780d1ff72e2a24b04e546b958a01", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:9bebfa7a59b854e30ca96143e1538f565b978e5fdfc18118c7cd3f311b1c720c", "content": "Kotlin Coroutines support has been introduced to the framework.\n\nSee xref:kotlin-functions.adoc#kotlin-coroutines[Kotlin Coroutines] for more information.\n\n[[x6.0-aot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "Kotlin Coroutines", "heading_level": 3, "file_order": 182, "section_index": 13, "content_hash": "9bebfa7a59b854e30ca96143e1538f565b978e5fdfc18118c7cd3f311b1c720c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:4d2de7e6cb95471eeebe262eb190612e3c851e21e26543e86303bf9c7afadf46", "content": "Support for creating GraalVM native images is provided.\nSee xref:native-aot.adoc[Native Images Support] for more information.\n\n[[x6.0-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "Native Images", "heading_level": 3, "file_order": 182, "section_index": 14, "content_hash": "4d2de7e6cb95471eeebe262eb190612e3c851e21e26543e86303bf9c7afadf46", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:c076ce9721689e99e4708f25d10311b9c446c29170f7fdedf69c28af6f581152", "content": "The messaging annotations are now `@Repeatable` and the same type can be declared several times on the same service method.\nThe messaging annotations don't require a `poller` attribute as an array of `@Poller` anymore.\n\nSee xref:configuration/annotations.adoc[Annotation Support] for more information.\n\nFor convenience, the XML and Java DSL for Scatter-Gather, based on the `RecipientListRouter`, now sets an `applySequence = true`, so the gatherer part can rely on the default correlation strategies.\n\nSee xref:scatter-gather.adoc[Scatter-Gather] for more information.\n\nAnother convenient behavior change has been made to the `AbstractMappingMessageRouter`.\nNow, setting a `defaultOutputChannel` also resets the `channelKeyFallback` property to `false`, so no attempts will be made to resolve a channel from its key, but the logic immediately falls back to sending the message to the `defaultOutputChannel`.\n\nSee xref:router/common-parameters.adoc#router-common-parameters-all[Router Options] for more information.\n\nThe `AggregatingMessageHandler` now does not split a `Collection<Message<?>>` result of the `MessageGroupProcessor` (unless it is a `SimpleMessageGroupProcessor`) on the output, but emits a single message containing this whole collection as a payload.\n\nSee xref:overview.adoc#overview-endpoints-aggregator[Aggregator] for more information.\n\nThe `IntegrationFlows` factory is now marked as deprecated in favor of the fluent API available in the `IntegrationFlow` interface itself.\nThe factory class will be removed in the future releases.\n\nSee xref:dsl.adoc#java-dsl[Java DSL] for more information.\n\nThe `org.springframework.util.concurrent.ListenableFuture` has been deprecated starting with Spring Framework `6.0`.\nAll Spring Integration async API has been migrated to the `CompletableFuture`.\n\nThe Messaging Gateway interface method can now return `Future<Void>` and `Mono<Void>` with a proper asynchronous execution of the downstream flow.\n\nAlongside with a `@MessagingGateway` annotation the interface can also be marked with a `@Primary`.\n\n`@MessagingGateway` interfaces can now be use as an `@Import` resources for configuration.\n\nThe default naming strategy for gateway proxy beans can be customized via `@IntegrationComponentScan.nameGenerator()` attribute.\nIf `AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR` bean is present, it is consulted otherwise before falling back to the `AnnotationBeanNameGenerator`.\n\nSee xref:gateway.adoc[Messaging Gateway] for more information.\n\nThe `integrationGlobalProperties` bean is now declared by the framework as an instance of `org.springframework.integration.context.IntegrationProperties` instead of the previously deprecated `java.util.Properties`.\n\nMessage handlers which produce a collection as a reply (e.g. `JpaOutboundGateway`, `JdbcOutboundGateway` and other DB-based gateways) now return an empty result list if no records are returned by the query.\nPreviously, `null` was returned ending the flow, or throwing an exception, depending on `requiresReply`.\n\n[[x6.0-rmi]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "General Changes", "heading_level": 2, "file_order": 182, "section_index": 15, "content_hash": "c076ce9721689e99e4708f25d10311b9c446c29170f7fdedf69c28af6f581152", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:8ebc2e86a8903e62edd1c71acba26f751f6cad2f8ca2cb684ea45b393d1fdcef", "content": "The `spring-integration-rmi` module has been removed altogether after being deprecated in previous versions.\nThere is no replacement: it is recommended to migrate to more secure network and application protocols, such as WebSockets, RSockets, gRPC or REST.\n\n[[x6.0-gemfire]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "RMI Removal", "heading_level": 2, "file_order": 182, "section_index": 16, "content_hash": "8ebc2e86a8903e62edd1c71acba26f751f6cad2f8ca2cb684ea45b393d1fdcef", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:3181e46d2aedc848d7437f8002b96dd211f31ad97ee68c28ca3ae0813bd8be53", "content": "The `spring-integration-gemfire` module has been removed altogether since there is no Spring Data `2022.0.0` support for VMware GemFire or Apache Geode.\n\n[[x6.0-http]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "GemFire Removal", "heading_level": 2, "file_order": 182, "section_index": 17, "content_hash": "3181e46d2aedc848d7437f8002b96dd211f31ad97ee68c28ca3ae0813bd8be53", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:28fb057cdce90f02c6cef4e8c2a990ffd9eec6ec72f6437008f4f9a0e90886db", "content": "The `#cookies` variable for expression evaluation context, exposed in the `HttpRequestHandlingEndpointSupport`, is now a `MultiValueMap` to carry all the values for cookies set by the client.\nSee xref:http.adoc[HTTP Support] for more information.\n\n[[x6.0-kafka]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "HTTP Changes", "heading_level": 2, "file_order": 182, "section_index": 18, "content_hash": "28fb057cdce90f02c6cef4e8c2a990ffd9eec6ec72f6437008f4f9a0e90886db", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:82681e7034c6cf8682cfb0820c70c6a939870b8c1e078bb38a319c9298e2e3d5", "content": "When providing a `RetryTemplate` on the inbound gateway or message-driven channel adapter, if an `errorChannel` is also provided, an `ErrorMessageSendingRecoverer` is automatically configured.\n\nIn addition, the new `KafkaErrorMessageSendingRecoverer` is provided; this can be used with a `DefaultErrorHandler` to avoid issues with long aggregated retry delays causing partitions rebalances.\n\nSee xref:kafka.adoc[Spring for Apache Kafka Support] for more information.\n\n[[x6.0-jdbc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "Apache Kafka Changes", "heading_level": 2, "file_order": 182, "section_index": 19, "content_hash": "82681e7034c6cf8682cfb0820c70c6a939870b8c1e078bb38a319c9298e2e3d5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:5175d8e7f86fbd967ab83bdcbcaa918233ba6e4834a80c0fc50bd53c543ce967", "content": "The `DefaultLockRepository` can now be supplied with a `PlatformTransactionManager` instead of relying on the primary bean from the application context.\n\nSee xref:jdbc.adoc#jdbc-lock-registry[JDBC Lock Registry] for more information.\n\n[[x6.0-tcp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "JDBC Changes", "heading_level": 2, "file_order": 182, "section_index": 20, "content_hash": "5175d8e7f86fbd967ab83bdcbcaa918233ba6e4834a80c0fc50bd53c543ce967", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:16d15a3b6b0e07fd945c27c17dc1a9e2a26b7a8e175d28242caf249f7b57ffa8", "content": "The `lookupHost` property of the `AbstractConnectionFactory` and `DatagramPacketMessageMapper` is now set to `false` by default to avoid delays in the environments where DNS is not configured.\n\nSee xref:ip.adoc[TCP and UDP Support] for more information.\n\n[[x6.0-jms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "TCP/IP Changes", "heading_level": 2, "file_order": 182, "section_index": 21, "content_hash": "16d15a3b6b0e07fd945c27c17dc1a9e2a26b7a8e175d28242caf249f7b57ffa8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:8ad9fe0d74f7c6b7db26bfedf1fa3b4f22583ea65c6da2875f4b6034fffc4d1f", "content": "The `JmsOutboundGateway` now creates a `TemporaryTopic` instead of `TemporaryQueue` if `replyPubSubDomain` option is set to `true`.\n\nSee xref:jms.adoc[JMS Support] for more information.\n\n[[x6.0-security]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "JMS Changes", "heading_level": 2, "file_order": 182, "section_index": 22, "content_hash": "8ad9fe0d74f7c6b7db26bfedf1fa3b4f22583ea65c6da2875f4b6034fffc4d1f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:c2fc95ff6f9b84a1acc7ac59daf10c6741255761a727afd5c13e40283465af62", "content": "The `ChannelSecurityInterceptor` and its annotation `@SecuredChannel` and XML `<secured-channels>` configurations have been deprecated in favor of `AuthorizationChannelInterceptor`.\n\nSee xref:security.adoc[Security Support] for more information.\n\n[[x6.0-webflux]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "Security Changes", "heading_level": 2, "file_order": 182, "section_index": 23, "content_hash": "c2fc95ff6f9b84a1acc7ac59daf10c6741255761a727afd5c13e40283465af62", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:09c6bb889d3c78108c0e40b386eebe31d4a0b1d900326dcdf886f20d862e0dc0", "content": "Webclient Request attributes support has been added for `WebFluxRequestExecutingMessageHandler`.\n\nSee xref:webflux.adoc#webflux-request-attributes[WebFlux Request Attributes] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-5.5-6.0.adoc", "title": "changes-5.5-6.0", "heading": "Webflux Request Attributes Support", "heading_level": 2, "file_order": 182, "section_index": 24, "content_hash": "09c6bb889d3c78108c0e40b386eebe31d4a0b1d900326dcdf886f20d862e0dc0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-5.5-6.0.adoc"}}
{"id": "sha256:f396cd35c5965975fb5b73009db7ac647662623a427d73ec3ffbc77e57632557", "content": "[[migration-6.0-6.1]]\n\n[[x6.1-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "changes-6.0-6.1", "heading_level": 1, "file_order": 183, "section_index": 0, "content_hash": "f396cd35c5965975fb5b73009db7ac647662623a427d73ec3ffbc77e57632557", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:bbe41133523d7700d676306f3ed3e4dcf57cc35b1b9fb8fc418e5df1390e3315", "content": "[[x6.1-zip]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "New Components", "heading_level": 2, "file_order": 183, "section_index": 1, "content_hash": "bbe41133523d7700d676306f3ed3e4dcf57cc35b1b9fb8fc418e5df1390e3315", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:6d0369e3b76ddd9c171d16f61e15470ca469ebcf5ee2f3425aee5c1044106268", "content": "The Zip Spring Integration Extension project has been migrated as the `spring-integration-zip` module.\nSee xref:zip.adoc[Zip Support] for more information.\n\n[[x6.1-context-holder-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "Zip Support", "heading_level": 3, "file_order": 183, "section_index": 2, "content_hash": "6d0369e3b76ddd9c171d16f61e15470ca469ebcf5ee2f3425aee5c1044106268", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:da704d799a3b8b016c9505ecb6df2b5bc580edb1120d7ae341a3b6f3bf10ca7c", "content": "The `ContextHolderRequestHandlerAdvice` allows to store a value from a request message into some context around `MessageHandler` execution.\nSee xref:handler-advice/context-holder.adoc[Context Holder Advice] for more information.\n\n[[x6.1-handle-reactive]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "`ContextHolderRequestHandlerAdvice`", "heading_level": 3, "file_order": 183, "section_index": 3, "content_hash": "da704d799a3b8b016c9505ecb6df2b5bc580edb1120d7ae341a3b6f3bf10ca7c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:7e31b2ab8943db5c37d18ff7bef7b936f603f144c9c8f93ffde2d43609fde5e3", "content": "The `IntegrationFlow` can now end with a convenient `handleReactive(ReactiveMessageHandler)` operator.\nSee xref:reactive-streams.adoc#reactive-message-handler[`ReactiveMessageHandler`] for more information.\n\n[[x6.1-partitioned-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "The `handleReactive()` operator for Java DSL", "heading_level": 3, "file_order": 183, "section_index": 4, "content_hash": "7e31b2ab8943db5c37d18ff7bef7b936f603f144c9c8f93ffde2d43609fde5e3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:3d266e11fb2c0a78ee35c933b78bcba9d5eb7136afaa7e7c5005cbfebed66e47", "content": "A new `PartitionedChannel` has been introduced to process messages with the same partition key in the same thread.\nSee xref:channel/implementations.adoc#partitioned-channel[`PartitionedChannel`] for more information.\n\n[[x6.1-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "`PartitionedChannel`", "heading_level": 2, "file_order": 183, "section_index": 5, "content_hash": "3d266e11fb2c0a78ee35c933b78bcba9d5eb7136afaa7e7c5005cbfebed66e47", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:0163125295563f8a808c7e590c6217b0a48ddf04cc07816b7b7b714bdab542f9", "content": "- Added support for transforming to/from Protocol Buffers.\nSee xref:transformer.adoc#Protobuf-transformers[Protocol Buffers Transformers] for more information.\n\n- The `MessageFilter` now emits a warning into logs when message is silently discarded and dropped.\nSee xref:filter.adoc[Filter] for more information.\n\n- The default timeout for send and receive operations in gateways and replying channel adapters has been changed from infinity to `30` seconds.\nOnly one left as a `1` second is a `receiveTimeout` for `PollingConsumer` to not block a scheduler thread too long and let other queued tasks to be performed with the `TaskScheduler`.\n\n- The `IntegrationComponentSpec.get()` method has been deprecated with removal planned for the next version.\nSince `IntegrationComponentSpec` is a `FactoryBean`, its bean definition must stay as is without any target object resolutions.\nThe Java DSL and the framework by itself will manage the `IntegrationComponentSpec` lifecycle.\nSee xref:dsl.adoc#java-dsl[ Java DSL] for more information.\n\n- The `AbstractMessageProducingHandler` is marked as an `async` by default if its output channel is configured to a `ReactiveStreamsSubscribableChannel`.\nSee xref:service-activator.adoc#async-service-activator[Asynchronous Service Activator] for more information.\n\n[[x6.1-web-sockets]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "General Changes", "heading_level": 2, "file_order": 183, "section_index": 6, "content_hash": "0163125295563f8a808c7e590c6217b0a48ddf04cc07816b7b7b714bdab542f9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:7999f893af485715e018e86ee417e415bef99567f9b76822a41b908fd5b32ce9", "content": "A `ClientWebSocketContainer` can now be configured with a predefined `URI` instead of a combination of `uriTemplate` and `uriVariables`.\nSee xref:web-sockets.adoc#web-socket-overview[WebSocket Overview] for more information.\n\n[[x6.1-jms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "Web Sockets Changes", "heading_level": 2, "file_order": 183, "section_index": 7, "content_hash": "7999f893af485715e018e86ee417e415bef99567f9b76822a41b908fd5b32ce9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:cccdd4aa71dbba0d07bf258057691d7900ececfdc0842796b2c66c6c785b8b3e", "content": "The `JmsInboundGateway`, via its `ChannelPublishingJmsMessageListener`, can now be configured with a `replyToExpression` to resolve a reply destination against the request message at runtime.\nSee xref:jms.adoc#jms-inbound-gateway[JMS Inbound Gateway] for more information.\n\n[[x6.1-mail]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "JMS Changes", "heading_level": 2, "file_order": 183, "section_index": 8, "content_hash": "cccdd4aa71dbba0d07bf258057691d7900ececfdc0842796b2c66c6c785b8b3e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:0d0091172df2c0975f0bb180ef55295d796b44dfd2ef35ce9afe7239b446f9fa", "content": "The (previously deprecated) `ImapIdleChannelAdapter.sendingTaskExecutor` property has been removed in favor of an asynchronous message process downstream in the flow.\nSee xref:mail.adoc#mail-inbound[Mail-receiving Channel Adapter] for more information.\n\n[[x6.1-file]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "Mail Changes", "heading_level": 2, "file_order": 183, "section_index": 9, "content_hash": "0d0091172df2c0975f0bb180ef55295d796b44dfd2ef35ce9afe7239b446f9fa", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:547b2b93611493bf7b13184ec3c14c16f03ed482e2f13985ca2a8c42d3161d62", "content": "The `FileReadingMessageSource` now exposes `watchMaxDepth` and `watchDirPredicate` options for the `WatchService`.\nSee xref:file.adoc#watch-service-directory-scanner[ `WatchServiceDirectoryScanner`] for more information.\n\n[[x6.1-amqp]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "Files Changes", "heading_level": 2, "file_order": 183, "section_index": 10, "content_hash": "547b2b93611493bf7b13184ec3c14c16f03ed482e2f13985ca2a8c42d3161d62", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:1ee0a8a8297bedd420ec4f1528cce0c1753e5785daa9d2020c942ec279f03343", "content": "The Java DSL API for Rabbit Streams (the `RabbitStream` factory) exposes additional properties for simple configurations.\nSee xref:amqp/rmq-streams.adoc[`RabbitMQ Stream Queue Support`] for more information.\n\n[[x6.1-jdbc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "AMQP Changes", "heading_level": 2, "file_order": 183, "section_index": 11, "content_hash": "1ee0a8a8297bedd420ec4f1528cce0c1753e5785daa9d2020c942ec279f03343", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:378b2276c1fda15a754ebf8e64f06d12832511d2423694c050653e7031ca2049", "content": "The `DefaultLockRepository` now exposes setters for `insert`, `update` and `renew` queries.\nSee xref:jdbc.adoc#jdbc-lock-registry[ JDBC Lock Registry] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.0-6.1.adoc", "title": "changes-6.0-6.1", "heading": "JDBC Changes", "heading_level": 2, "file_order": 183, "section_index": 12, "content_hash": "378b2276c1fda15a754ebf8e64f06d12832511d2423694c050653e7031ca2049", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.0-6.1.adoc"}}
{"id": "sha256:ebd090930dc87dd22149c757e2f03ced4145e53cda853d1b3f6d977703aa4800", "content": "[[migration-6.1-6.2]]\n\n[[x6.2-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.1-6.2.adoc", "title": "changes-6.1-6.2", "heading": "changes-6.1-6.2", "heading_level": 1, "file_order": 184, "section_index": 0, "content_hash": "ebd090930dc87dd22149c757e2f03ced4145e53cda853d1b3f6d977703aa4800", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.1-6.2.adoc"}}
{"id": "sha256:9b5f7a970228eb0d7daf32989d7c931a4802b906ab30c3008f0fdf80dfc2a254", "content": "[[x6.2-debezium]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.1-6.2.adoc", "title": "changes-6.1-6.2", "heading": "New Components", "heading_level": 2, "file_order": 184, "section_index": 1, "content_hash": "9b5f7a970228eb0d7daf32989d7c931a4802b906ab30c3008f0fdf80dfc2a254", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.1-6.2.adoc"}}
{"id": "sha256:5ca7ba5b58e271b687b88c6e89de1923453bffd7d3528c4e6c95b760228988c6", "content": "The Debezium Engine based Change Data Capture (CDC) channel adapter, that allows capturing database change events, converting them into Messages and streaming those to the outbound channels.\nSee xref:debezium.adoc[Debezium Support] for more information.\n\n[[x6.2-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.1-6.2.adoc", "title": "changes-6.1-6.2", "heading": "Debezium Inbound Channel Adapter", "heading_level": 3, "file_order": 184, "section_index": 2, "content_hash": "5ca7ba5b58e271b687b88c6e89de1923453bffd7d3528c4e6c95b760228988c6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.1-6.2.adoc"}}
{"id": "sha256:67d5b4d288f16d40c752600d7fbc57b234a050f6dd5ba4e16a50f230dc558cc7", "content": "- The XML configuration for `<poller>` and `@Poller` annotation now support ISO 8601 duration format for `fixed-delay`, `fixed-rate` and `initial-delay` options.\nSee xref:endpoint.adoc#endpoint-pollingconsumer[Polling Consumer] for more information.\n\n- Java, Groovy and Kotlin DSLs have now context-specific methods in the `IntegrationFlowDefinition` with a single `Consumer` argument to configure an endpoint and its handler with one builder and readable options.\nSee, for example, `transformWith()`, `splitWith()` in xref:dsl.adoc#java-dsl[Java DSL Chapter].\n\n- A new `spring.integration.endpoints.defaultTimeout` global property has been introduced to override the default 30 seconds timeout for all the endpoints in the application.\nSee xref:configuration/global-properties.adoc[Global Properties] for more information.\n\n- The `@MessagingGateway` and `GatewayEndpointSpec` provided by the Java DSL now expose the `errorOnTimeout` property of the internal `MethodInvocationGateway` extension of the `MessagingGatewaySupport`.\nSee xref:gateway.adoc#gateway-no-response[Gateway Behavior When No response Arrives] for more information.\n\n- The `LockRegistry` provides template-like API to execute provided task while locked.\nSee xref:distributed-locks.adoc[Distributed Locks] for more information.\n\n- The default trigger for polling endpoint is now a `PeriodicTrigger` instance with a 1 second fixed delay period; previously, the default was 10 milliseconds.\nSee xref:endpoint.adoc#endpoint-pollingconsumer[Polling Consumer] for more information.\n\n[[x6.2-websockets]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.1-6.2.adoc", "title": "changes-6.1-6.2", "heading": "General Changes", "heading_level": 2, "file_order": 184, "section_index": 3, "content_hash": "67d5b4d288f16d40c752600d7fbc57b234a050f6dd5ba4e16a50f230dc558cc7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.1-6.2.adoc"}}
{"id": "sha256:21cf0aff59e280dff2d7c9fe2f4531abcc15b7dfa7ea778827967657c55fc2f9", "content": "- For the server and client WebSocket containers, the send buffer overflow strategy is now configurable in `IntegrationWebSocketContainer` and in XML via `send-buffer-overflow-strategy`.\nThis strategy determines the behavior when a session's outbound message buffer has reached the configured limit.\nSee xref:web-sockets.adoc#websocket-client-container-attributes[WebSockets Support] for more information.\n\n[[x6.2-kafka]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.1-6.2.adoc", "title": "changes-6.1-6.2", "heading": "WebSockets Changes", "heading_level": 2, "file_order": 184, "section_index": 4, "content_hash": "21cf0aff59e280dff2d7c9fe2f4531abcc15b7dfa7ea778827967657c55fc2f9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.1-6.2.adoc"}}
{"id": "sha256:4d4a30524ccd68334d5d6f5e592e5777ede69a9b567b665feb5522524b325a94", "content": "The `KafkaMessageSource` now extracts an `ErrorHandlingDeserializer` configuration from the consumer properties and re-throws `DeserializationException` extracted from failed record headers.\nSee xref:kafka.adoc#kafka-inbound-pollable[Kafka Inbound Channel Adapter] for more information.\n\n[[x6.2-jdbc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.1-6.2.adoc", "title": "changes-6.1-6.2", "heading": "Apache Kafka Support Changes", "heading_level": 2, "file_order": 184, "section_index": 5, "content_hash": "4d4a30524ccd68334d5d6f5e592e5777ede69a9b567b665feb5522524b325a94", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.1-6.2.adoc"}}
{"id": "sha256:8e1d91e84e9c6051e9c2a4cd1758eb72a5d54f0e480b63416e0bc72648ab26e1", "content": "The `JdbcMessageStore`, `JdbcChannelMessageStore`, `JdbcMetadataStore`, and `DefaultLockRepository` implement `SmartLifecycle` and perform a `SELECT COUNT` query, on their respective tables, in the `start()` method to ensure that the required table (according to the provided prefix) is present in the target database.\nThe `PostgresChannelMessageStoreQueryProvider` now provides single `DELETE...RETURNING` statement for polling queries.\nFor this purpose the `ChannelMessageStoreQueryProvider` exposes `isSingleStatementForPoll` option which is consulted from the `JdbcChannelMessageStore`.\nSee xref:jdbc/message-store.adoc[JDBC Message Store] for more information.\n\n[[x6.2-mongodb]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.1-6.2.adoc", "title": "changes-6.1-6.2", "heading": "JDBC Support Changes", "heading_level": 2, "file_order": 184, "section_index": 6, "content_hash": "8e1d91e84e9c6051e9c2a4cd1758eb72a5d54f0e480b63416e0bc72648ab26e1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.1-6.2.adoc"}}
{"id": "sha256:22b79b4404195c533e35b7bf2de169fa043783656636359ad1632c7c81c130c0", "content": "A new option `setCreateIndexes(boolean)` has been introduced in `AbstractConfigurableMongoDbMessageStore` to disable the auto indexes creation.\nSee xref:mongodb.adoc#mongodb-message-store[MongoDB Message Store] for an example.\n\n[[x6.2-remote-files]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.1-6.2.adoc", "title": "changes-6.1-6.2", "heading": "MongoDB Support Changes", "heading_level": 2, "file_order": 184, "section_index": 7, "content_hash": "22b79b4404195c533e35b7bf2de169fa043783656636359ad1632c7c81c130c0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.1-6.2.adoc"}}
{"id": "sha256:6987b2880ce757b0335e3b5fa4ed268b4613515346552d5b8f49ead041160195", "content": "`FtpLastModifiedFileListFilter`, `SftpLastModifiedFileListFilter` and `SmbLastModifiedFileListFilter` have been introduced to allow files filtering based on a last-modified strategy respectively for `FTP`, `SFTP` and `SMB`.\nSee xref:ftp/inbound.adoc#ftp-inbound[FTP Inbound Channel Adapter], xref:sftp/inbound.adoc#sftp-inbound[SFTP Inbound Channel Adapter], and xref:smb.adoc#smb-inbound[SMB Inbound Channel Adapter] for more information.\n\n[[x6.2-sftp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.1-6.2.adoc", "title": "changes-6.1-6.2", "heading": "Remote Files Support Changes", "heading_level": 2, "file_order": 184, "section_index": 8, "content_hash": "6987b2880ce757b0335e3b5fa4ed268b4613515346552d5b8f49ead041160195", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.1-6.2.adoc"}}
{"id": "sha256:7e1fb463cd9e5a79881ce60cb57d7855c8b61facb6fc97ac115411eaf3f7a40e", "content": "A new `DefaultSftpSessionFactory.createSftpClient(...)` method has been introduced to support a custom `SftpClient` when overridden.\nSee xref:sftp/session-factory.adoc#sftp-session-factory[SFTP Session Factory] for more information.\n\n[[x6.2-security-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.1-6.2.adoc", "title": "changes-6.1-6.2", "heading": "SFTP Support Changes", "heading_level": 2, "file_order": 184, "section_index": 9, "content_hash": "7e1fb463cd9e5a79881ce60cb57d7855c8b61facb6fc97ac115411eaf3f7a40e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.1-6.2.adoc"}}
{"id": "sha256:07fb4f2089dbbd98c26626c3f86d438f9e8e7090db4b5b13aaa69149d6275fa5", "content": "The last class in `spring-integration-security` module `SecurityContextPropagationChannelInterceptor` has been deprecated in favor of similar class moved to `spring-security-messaging` module.\nSee xref:security.adoc[Security in Spring Integration] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.1-6.2.adoc", "title": "changes-6.1-6.2", "heading": "Security Support Changes", "heading_level": 2, "file_order": 184, "section_index": 10, "content_hash": "07fb4f2089dbbd98c26626c3f86d438f9e8e7090db4b5b13aaa69149d6275fa5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.1-6.2.adoc"}}
{"id": "sha256:0d66973e5cdbba644a983969fbe05f0ae875c63c84cc6e382a261f76377483e6", "content": "[[migration-6.2-6.3]]\n\n[[x6.3-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.2-6.3.adoc", "title": "changes-6.2-6.3", "heading": "changes-6.2-6.3", "heading_level": 1, "file_order": 185, "section_index": 0, "content_hash": "0d66973e5cdbba644a983969fbe05f0ae875c63c84cc6e382a261f76377483e6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.2-6.3.adoc"}}
{"id": "sha256:e0c50dfb728898b901f7621cfbf8500fa5c3cd0bd22c3a704f79deb7bffdaadd", "content": "[[x6.3-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.2-6.3.adoc", "title": "changes-6.2-6.3", "heading": "New Components", "heading_level": 2, "file_order": 185, "section_index": 1, "content_hash": "e0c50dfb728898b901f7621cfbf8500fa5c3cd0bd22c3a704f79deb7bffdaadd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.2-6.3.adoc"}}
{"id": "sha256:9781df350bdaefea858fc40cee8bf079daa812b8acb324042a59bcd910063fd7", "content": "The `MessageHistory` header is now mutable, append-only container.\nAnd all the subsequent tracks don't create new message - only their entry is added to existing message history header.\nSee xref:message-history.adoc[Message History Chapter] for more information.\n\nAll the `MessageChannel` implementations based on the `UnicastingDispatcher` now can be configured with a `Predicate<Exception> failoverStrategy` for dynamic decision for the failover on the exception thrown from the current `MessageHandler`.\nSee xref:channel/configuration.adoc[Message Channel Configuration] for more information.\n\n[[x6.3-security-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.2-6.3.adoc", "title": "changes-6.2-6.3", "heading": "General Changes", "heading_level": 2, "file_order": 185, "section_index": 2, "content_hash": "9781df350bdaefea858fc40cee8bf079daa812b8acb324042a59bcd910063fd7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.2-6.3.adoc"}}
{"id": "sha256:53ac17c835a09f4cc67aa1e1a5bce3bebe42655900ff7f2ce5f049c0d8388629", "content": "The `spring-integration-security` module is completely removed (being deprecated previously) in favor of API from `spring-security-messaging` module.\nSee xref:security.adoc[Security in Spring Integration] for more information.\n\n[[x6.3-mqtt]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.2-6.3.adoc", "title": "changes-6.2-6.3", "heading": "Security Support Changes", "heading_level": 2, "file_order": 185, "section_index": 3, "content_hash": "53ac17c835a09f4cc67aa1e1a5bce3bebe42655900ff7f2ce5f049c0d8388629", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.2-6.3.adoc"}}
{"id": "sha256:332ba845e92bed42d0aa1110478f856b9cfbbbea10536ec539f73d43766b25b3", "content": "The fine-grained configuration based on `MqttSubscription` API is exposed on the `Mqttv5PahoMessageDrivenChannelAdapter`.\nSee xref:mqtt.adoc[MQTT Support] for more information.\n\n[[x6.3-testing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.2-6.3.adoc", "title": "changes-6.2-6.3", "heading": "MQTT Support Changes", "heading_level": 2, "file_order": 185, "section_index": 4, "content_hash": "332ba845e92bed42d0aa1110478f856b9cfbbbea10536ec539f73d43766b25b3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.2-6.3.adoc"}}
{"id": "sha256:8581bbdceac62815e13bb18cb19c986ea0aba9ef318b97bb72b1e591e7ae6c1a", "content": "The `MockIntegrationContext.substituteTriggerFor()` API has been introduced.\nSee xref:testing.adoc[Testing Support] for more information.\n\n[[x6.3-jms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.2-6.3.adoc", "title": "changes-6.2-6.3", "heading": "Testing Support Changes", "heading_level": 2, "file_order": 185, "section_index": 5, "content_hash": "8581bbdceac62815e13bb18cb19c986ea0aba9ef318b97bb72b1e591e7ae6c1a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.2-6.3.adoc"}}
{"id": "sha256:f97bbc9df06f9d28b6aee2677a84d901c6c772223b1000ff69d4e8fc1fb69917", "content": "The `ChannelPublishingJmsMessageListener` can now be supplied with a `RetryTemplate` and `RecoveryCallback<Message<?>>` for retries on the downstream send operations.\nSee xref:jms.adoc#jms-message-driven-channel-adapter[Message Driven Channel Adapter] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.2-6.3.adoc", "title": "changes-6.2-6.3", "heading": "JMS Support Changes", "heading_level": 2, "file_order": 185, "section_index": 6, "content_hash": "f97bbc9df06f9d28b6aee2677a84d901c6c772223b1000ff69d4e8fc1fb69917", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.2-6.3.adoc"}}
{"id": "sha256:21c4ea7d2b4f16b3ab779a6c82b1b5d49ad5a75c521160336711c08de5f97054", "content": "[[migration-6.3-6.4]]\n\n[[x6.4-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "changes-6.3-6.4", "heading_level": 1, "file_order": 186, "section_index": 0, "content_hash": "21c4ea7d2b4f16b3ab779a6c82b1b5d49ad5a75c521160336711c08de5f97054", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:410299cf4b8a226406a0d32364ab640e4aab9a20f92163aa8589e584d9653fcf", "content": "A `BaseMessageBuilder` class has been extracted from the `MessageBuilder` to simplify a custom builder implementation where the most of the logic should be the same as `MessageBuilder` one.\nSee xref:message.adoc#message-builder[`MessageBuilder`] for more information.\n\nThe new Control Bus interaction model is implemented in the `ControlBusCommandRegistry`.\nA new `ControlBusFactoryBean` class is recommended to be used instead of deprecated `ExpressionControlBusFactoryBean`.\nSee xref:control-bus.adoc[Control Bus] for more information.\n\nAlso, a `ControlBusController` (together with an `@EnableControlBusController`) is introduced for managing exposed commands by the mentioned `ControlBusCommandRegistry`.\nSee xref:http.adoc[HTTP Support] for more information.\n\nThe SpEL evaluation infrastructure now supports configuration for `IndexAccessor`.\nAlso, an out-of-the-box `JsonIndexAccessor` is provided.\nSee xref:spel.adoc[SpEL Support] for more information.\n\n[[x6.4-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "New Components", "heading_level": 2, "file_order": 186, "section_index": 1, "content_hash": "410299cf4b8a226406a0d32364ab640e4aab9a20f92163aa8589e584d9653fcf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:76591bf77f03e0b514db5c7f9b03e5e96456ee7aaad379554ca8205af5f68bb3", "content": "The Java DSL `SourcePollingChannelAdapterSpec` can now be configured with a custom `TaskScheduler`\n\n[[x6.4-remote-files-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "General Changes", "heading_level": 2, "file_order": 186, "section_index": 2, "content_hash": "76591bf77f03e0b514db5c7f9b03e5e96456ee7aaad379554ca8205af5f68bb3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:e95d32aa384714af160b252c76f9306195235988eb9f2bcad6e3f4d5c8f40838", "content": "The `AbstractRemoteFileStreamingMessageSource` has now a convenient `clearFetchedCache()` API to remove references from cache for not processed remote files.\nThe references stay in cache because polling configuration does not allow to process all the fetched in one cycle, and the target `SessionFactory` might be changed between polling cycles, e.g. via `RotatingServerAdvice`.\n\n[[x6.4-jdbc-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "Remote File Adapters Changes", "heading_level": 2, "file_order": 186, "section_index": 3, "content_hash": "e95d32aa384714af160b252c76f9306195235988eb9f2bcad6e3f4d5c8f40838", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:acc35b84beb79d19c1298c6d0087a16917f361d81846ea7a5df69794ae05d296", "content": "The `LobHandler` (and respective API) has been deprecated for removal in Spring Framework `6.2`.\nRespective option on `JdbcMessageStore` (and similar) have been deprecated as well.\nThe byte array handling for serialized message is fully deferred to JDBC driver.\n\nThe `LockRepository.delete()` method return the result of removing ownership of a distributed lock.\nAnd the `JdbcLockRegistry.JdbcLock.unlock()` method throws `ConcurrentModificationException` if the ownership of the lock is expired.\nSee xref:jdbc.adoc[JDBC Support] for more information.\n\n[[x6.4-zeromq-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "JDBC Changes", "heading_level": 2, "file_order": 186, "section_index": 4, "content_hash": "acc35b84beb79d19c1298c6d0087a16917f361d81846ea7a5df69794ae05d296", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:5383290970df470c19a64a8ac489cb04e9e994abac4ec2791e40970711748b0f", "content": "The outbound component `ZeroMqMessageHandler` (and respective API) can now bind a TCP port instead of connecting to a given URL.\nSee xref:zeromq.adoc[ZeroMQ Support] for more information.\n\n[[x6.4-redis-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "ZeroMQ Changes", "heading_level": 2, "file_order": 186, "section_index": 5, "content_hash": "5383290970df470c19a64a8ac489cb04e9e994abac4ec2791e40970711748b0f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:e9a166f0fc126847f707010c1130de40cd8f1859a7c7767917a18b80cd7bf5ad", "content": "Instead of throwing `IllegalStateException`, the `RedisLockRegistry.RedisLock.unlock()` method throws `ConcurrentModificationException` if the ownership of the lock is expired.\nAdd a `RedisLockRegistry.setRenewalTaskScheduler()` to periodic lock renewal.\nSee xref:redis.adoc[Redis Support] for more information.\n\n[[x6.4-groovy-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "Redis Changes", "heading_level": 2, "file_order": 186, "section_index": 6, "content_hash": "e9a166f0fc126847f707010c1130de40cd8f1859a7c7767917a18b80cd7bf5ad", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:e878fe3896ad3695b77b1248b5052c37f0796fc40e24c4b110d9c36fdbabbbef", "content": "The `ControlBusFactoryBean` (and respective `<int-groovy:control-bus>` XML tag) has been deprecated (for removal) in favor of new introduced `ControlBusFactoryBean` based on a new model implemented in the `ControlBusCommandRegistry`.\nSee xref:control-bus.adoc[Control Bus] for more information.\n\n[[x6.4-sftp-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "Groovy Changes", "heading_level": 2, "file_order": 186, "section_index": 7, "content_hash": "e878fe3896ad3695b77b1248b5052c37f0796fc40e24c4b110d9c36fdbabbbef", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:0d6862df2e8ccfb811aedacb2d203628bc89face7080ad73bdfdf3ca6382e737", "content": "The `DefaultSftpSessionFactory` now exposes a `Consumer<SshClient>` configurer property to further customize an internal `SshClient`.\nSee xref:sftp/session-factory.adoc[SFTP Session Factory] for more information.\n\n[[x6.4-mqtt-support-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "SFTP Support Changes", "heading_level": 2, "file_order": 186, "section_index": 8, "content_hash": "0d6862df2e8ccfb811aedacb2d203628bc89face7080ad73bdfdf3ca6382e737", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:6af177d96259cf128a81c2ce27ecb2280546a4e9259b89ba117ea42ad1cd39e5", "content": "Multiple instances of `MqttPahoMessageDrivenChannelAdapter` and `Mqttv5PahoMessageDrivenChannelAdapter` can now be added at runtime using corresponding `ClientManager` through `IntegrationFlowContext`\nAlso a `MqttMessageNotDeliveredEvent` event has been introduced to emit when action callback reacts to the delivery failure.\nSee xref:mqtt.adoc[MQTT Support] for more information.\n\n[[x6.4-zip-support-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "MQTT Support Changes", "heading_level": 2, "file_order": 186, "section_index": 9, "content_hash": "6af177d96259cf128a81c2ce27ecb2280546a4e9259b89ba117ea42ad1cd39e5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:d37e801b1635cde09bf2bcc145a8479e99d16a71b14394ae28c42ebae9c6fd15", "content": "The `ZipTransformer` now exposes a `fileNameGenerator` property to customize a target zip file (and optional zip entry) name generation.\nSee xref:zip.adoc[Zip Support] for more information.\n\n[[x6.4-scripting-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "Zip Support Changes", "heading_level": 2, "file_order": 186, "section_index": 10, "content_hash": "d37e801b1635cde09bf2bcc145a8479e99d16a71b14394ae28c42ebae9c6fd15", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:80e7ba926a6d18310fc929e376bfeb557327f2a41a28d8dc9abd44dfb992a12d", "content": "The Python scripts evaluation is now migrated to the GraalVM Polyglot.\nSee xref:scripting.adoc[Scripting Support] for more information.\n\n[[x6.4-mail-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "Scripting Changes", "heading_level": 2, "file_order": 186, "section_index": 11, "content_hash": "80e7ba926a6d18310fc929e376bfeb557327f2a41a28d8dc9abd44dfb992a12d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:c494d0ef6cf5f8f3e931989cee679772af095afbd784a9ea38396e8ba77c9887", "content": "The `AbstractMailReceiver` exposes an option to disable setting `Flags.Flag.FLAGGED` into a received message as fallback flag.\nSee xref:mail.adoc[Mail Support] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.3-6.4.adoc", "title": "changes-6.3-6.4", "heading": "Mail Changes", "heading_level": 2, "file_order": 186, "section_index": 12, "content_hash": "c494d0ef6cf5f8f3e931989cee679772af095afbd784a9ea38396e8ba77c9887", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.3-6.4.adoc"}}
{"id": "sha256:8a4acc264c0d9075e9497c412d77f2091075c3a3dd55e828dfbb6230b24857a6", "content": "[[migration-6.4-6.5]]\n\n[[x6.5-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "changes-6.4-6.5", "heading_level": 1, "file_order": 187, "section_index": 0, "content_hash": "8a4acc264c0d9075e9497c412d77f2091075c3a3dd55e828dfbb6230b24857a6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:88ac8860c80c500841ff9956ddd27017a5545333a45eadad57170f44d755dda4", "content": "The deprecated previously usage of `org.springframework.util.concurrent.ListenableFuture` has been removed in favor of `CompletableFuture`.\n\nThe previously deprecated SpEL-based Control Bus components have been removed in favor of functionality around `ControlBusCommandRegistry`.\nThe `<control-bus use-registry=\"\">` attribute is deprecated now without replacement since only `ControlBusCommandRegistry` functionality is available.\nThe Java DSL `controlBusOnRegistry()` operator is deprecated in favor of restored `controlBus()` which is fully based now on the `ControlBusCommandRegistry`.\nSee xref:control-bus.adoc[Control Bus] for more information.\n\nThe `AbstractCorrelatingMessageHandler` does not throw an `IllegalArgumentException` for the collection of payloads as a result of the `MessageGroupProcessor`.\nInstead, such a collection is wrapped into a single reply message.\nSee xref:aggregator.adoc[Aggregator] for more information.\n\nThe `AbstractMessageChannel` beans now throw a special `MessageDispatchingException` when an attempt is made to send a message to an application that is not running.\n\nIn general, it is a design error to try to produce a message from `afterPropertiesSet()`, `@PostConstruct` or bean definition methods.\nThe `SmartLifecycle.start()` is preferred way for this kind of logic, or better to do that via inbound channel adapters.\n\nThe Java DSL `gateway()` operator now fully supports an `async(true)` behavior.\nSee xref:gateway.adoc[] for more information.\n\n[[x6.5-lock-request-handler-advice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "General Changes", "heading_level": 2, "file_order": 187, "section_index": 1, "content_hash": "88ac8860c80c500841ff9956ddd27017a5545333a45eadad57170f44d755dda4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:9ce33328ce21e72dcfb0f251b0b39e3a213dc830d023a9b4db84740469ec27e2", "content": "A new `LockRequestHandlerAdvice` is introduced to keep the lock for a key based on a request message for message handler invocation.\nSee xref:handler-advice.adoc[] for more information.\n\n[[x6.5-correlation-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "The `LockRequestHandlerAdvice`", "heading_level": 2, "file_order": 187, "section_index": 2, "content_hash": "9ce33328ce21e72dcfb0f251b0b39e3a213dc830d023a9b4db84740469ec27e2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:42a517ca19f3d1f8cbebb655357a84595a525f8467f1416de52d5261544c7646", "content": "The aggregator and resequencer can now discard the whole expired group as a single message via setting `discardIndividuallyOnExpiry` to `false`.\nSee xref:aggregator.adoc#releasestrategy[ReleaseStrategy] for more information.\n\n[[x6.5-message-store-with-locks]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "The `discardIndividuallyOnExpiry` Option For Correlation Handlers", "heading_level": 2, "file_order": 187, "section_index": 3, "content_hash": "42a517ca19f3d1f8cbebb655357a84595a525f8467f1416de52d5261544c7646", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:b8d84f59625e585137c2134eda6cc3298d1bf5a41c5ae066ff6f9439407de3f8", "content": "The `AbstractMessageGroupStore` now can be configured with a `LockRegistry` to perform series of persistent operation atomically.\nSee xref:message-store.adoc#use-lock-registry[Use LockRegistry] for more information.\n\n[[x6.5-observation-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "The `LockRegistry` in the `MessageStore`", "heading_level": 2, "file_order": 187, "section_index": 4, "content_hash": "b8d84f59625e585137c2134eda6cc3298d1bf5a41c5ae066ff6f9439407de3f8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:1d8ca5713fd36a33ff4b794235cd59dc83922087fd616411691d32524342648a", "content": "The `SourcePollingChannelAdapter` endpoint now starts a `CONSUMER` kind observation for the received message.\nThe `MessageReceiverContext` now distinguishes between `handler`, `message-source` and `message-producer` values for the `spring.integration.type` low cardinality tag.\nSee xref:metrics.adoc#micrometer-observation[Micrometer Observation] for more information.\n\n[[x6.5-mqtt-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "Micrometer Observation Changes", "heading_level": 2, "file_order": 187, "section_index": 5, "content_hash": "1d8ca5713fd36a33ff4b794235cd59dc83922087fd616411691d32524342648a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:ecfc796201bc6a61b593b3bbcc6ab79f23998ce8eed6d28b9e6f95128fa1c5ec", "content": "The `org.eclipse.paho:org.eclipse.paho.client.mqttv3` dependency for `spring-integration-mqtt` is now also optional as `org.eclipse.paho:org.eclipse.paho.mqttv5.client` always was.\nSee xref:mqtt.adoc[MQTT Support] for more information.\n\n[[x6.5-kafka-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "Optional Paho MQTT Dependencies", "heading_level": 2, "file_order": 187, "section_index": 6, "content_hash": "ecfc796201bc6a61b593b3bbcc6ab79f23998ce8eed6d28b9e6f95128fa1c5ec", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:f067e4ce7f812e2efe9110653706749307a53724944c72b5adf280006dfd7397", "content": "The `KafkaMessageSource` and `KafkaMessageDrivenChannelAdapter` now generate `MessageHeaders.ID` and `MessageHeaders.TIMESTAMP` headers by default as the rest of Spring Integration channel adapters.\nThe behavior can be restored to the previous with injection of the `MessagingMessageConverter` with default settings.\nSee xref:kafka.adoc[Apache Kafka Support] for more information.\n\n[[x6.5-file-filter-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "Apache Kafka support Changes", "heading_level": 2, "file_order": 187, "section_index": 7, "content_hash": "f067e4ce7f812e2efe9110653706749307a53724944c72b5adf280006dfd7397", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:14aea29f776bed23071563de709804190a23d58d499ca00cbf0b470893c02a62", "content": "The `AbstractRecentFileListFilter` strategy has been introduced to accept only those files which are not old enough according to the provided `age`.\nThe respective implementations are provided: `RecentFileListFilter`, `FtpRecentFileListFilter`, `SftpRecentFileListFilter` and `SmbRecentFileListFilter`.\nSee xref:file/reading.adoc[Reading Files] for more information.\n\n[[x6.5-file-exists-mode-expression]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "The Recent File Filter Support", "heading_level": 2, "file_order": 187, "section_index": 8, "content_hash": "14aea29f776bed23071563de709804190a23d58d499ca00cbf0b470893c02a62", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:ba8a1e4a3ff3149fef99542c6d1c2d68e7d0daa2aba63b182d08a52f07e57a47", "content": "The remote file gateways (`AbstractRemoteFileOutboundGateway`) now support dynamic resolution of `FileExistsMode` at runtime via SpEL expressions.\nSee xref:ftp/rft.adoc[Remote File Gateways] for more information.\n\n[[x6.5-hazelcast-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "FileExistsMode Expression Support", "heading_level": 2, "file_order": 187, "section_index": 9, "content_hash": "ba8a1e4a3ff3149fef99542c6d1c2d68e7d0daa2aba63b182d08a52f07e57a47", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:0ab4692a8cf944d5cb3dafb66286eddf52b9a32acf31116c0e924ca36dda2715", "content": "The `HazelcastLockRegistry` and Hazelcast `LeaderInitiator` have been deprecated due to Hazelcast CP Subsystem migration to Enterprise Edition.\nSee xref:hazelcast.adoc[Hazelcast Support] for more information.\n\n[[x6.5-jdbc-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "Hazelcast Module Deprecations", "heading_level": 2, "file_order": 187, "section_index": 10, "content_hash": "0ab4692a8cf944d5cb3dafb66286eddf52b9a32acf31116c0e924ca36dda2715", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:923e2eb5089b0651aaccc48aec21685580cdcb653c797d33f43a71229f6c254b", "content": "The `BeanPropertySqlParameterSourceFactory` now internally uses the `MapSqlParameterSource` if provided input is a `Map`.\nAlso, `JdbcMessageHandler` exposes a `usePayloadAsParameterSource` flag to allow working with parameter source only against message payload.\nThat's where the mentioned `MapSqlParameterSource` comes useful for request messages with map payloads.\nSee xref:jdbc.adoc[JDBC Support] for more information.\n\n[[x6.5-redis-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "JDBC Support", "heading_level": 2, "file_order": 187, "section_index": 11, "content_hash": "923e2eb5089b0651aaccc48aec21685580cdcb653c797d33f43a71229f6c254b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:3c1b1ac9859348ec2fde4ba54f7aeb6adf315ba9e913ff8ca865e37505f4922a", "content": "The `ReactiveRedisStreamMessageHandler` now exposes a `Function<Message<?>, RedisStreamCommands.XAddOptions>` to provide additional `XADD` option via convenient `RedisStreamCommands.XAddOptions` API.\nSee xref:redis.adoc#redis-stream-outbound[Redis Support] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.4-6.5.adoc", "title": "changes-6.4-6.5", "heading": "Redis Stream Support", "heading_level": 2, "file_order": 187, "section_index": 12, "content_hash": "3c1b1ac9859348ec2fde4ba54f7aeb6adf315ba9e913ff8ca865e37505f4922a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.4-6.5.adoc"}}
{"id": "sha256:4c97ee834bbf2161aadf80c397424cf44c60010fae83b45cec1795434d60c08c", "content": "[[migration-6.5-7.0]]\n\n[[x7.0-general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.5-7.0.adoc", "title": "changes-6.5-7.0", "heading": "changes-6.5-7.0", "heading_level": 1, "file_order": 188, "section_index": 0, "content_hash": "4c97ee834bbf2161aadf80c397424cf44c60010fae83b45cec1795434d60c08c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.5-7.0.adoc"}}
{"id": "sha256:2f1e14200dbb9e17696a268dc7723586c3d480d4bdce1aee52d1ee4723e29ed1", "content": "Junit 4-Based Support Components are deprecated.\n\nThe project now leverages https://jspecify.dev/docs/start-here/[JSpecify] annotations to expose null-safe APIs and to check the consistency of those nullability declarations with https://github.com/uber/NullAway[NullAway] as part of its build.\n\nThe `spring-retry` dependency, together with all its API usage have been replaced by retry API in Spring Framework Core module.\nThis breaking change is the natural evolution of the whole Spring portfolio.\nIn general, the following references have been migrated:\n\n- `org.springframework.retry.support.RetryTemplate` -> `org.springframework.core.retry.RetryTemplate`;\n- `org.springframework.retry.RetryPolicy` -> `org.springframework.core.retry.RetryPolicy`;\n- `org.springframework.retry.RecoveryCallback` -> `org.springframework.integration.core.RecoveryCallback`.\nThere is no `RecoveryCallback` abstraction in the Spring Framework, since regular `try..catch` on the `RetryException` is enough.\nFor Spring Integration, the `RecoveryCallback` makes sense as a dead-letter publisher to an error channel;\n- `org.springframework.retry.backoff.BackOffPolicy` -> `org.springframework.util.backoff.BackOff`.\nHowever, it is not exposed directly as a `RetryTemplate` options: rather as an internal API backed by the configuration via `RetryPolicy.Builder`;\n- The `RetryContext` in AMPQ, JMS and Apache Kafka channel adapters is replaced with an internal `AttributeAccessor` implementation.\n\nTherefore, the following project classes have suffered breaking changes:\n\n- `AmqpBaseInboundChannelAdapterSpec`\n- `AmqpBaseInboundGatewaySpec`\n- `AmqpInboundChannelAdapter`\n- `AmqpInboundGateway`\n- `PostgresSubscribableChannel`\n- `ChannelPublishingJmsMessageListener`\n- `JmsInboundGatewaySpec`\n- `JmsMessageDrivenChannelAdapterSpec`\n- `KafkaInboundGatewaySpec`\n- `KafkaMessageDrivenChannelAdapterSpec`\n- `KafkaInboundEndpoint`\n- `KafkaInboundGateway`\n- `KafkaMessageDrivenChannelAdapter`\n\nThe `RequestHandlerRetryAdvice` was rebuilt to avoid external API as much as possible.\nFor the stateless retry logic, there is just enough to provide a `org.springframework.core.retry.RetryPolicy`.\nThe stateful retry logic is activated by the `Function<Message<?>, Object> stateKeyFunction`.\nThe `RetryStateGenerator` abstraction and its `SpelExpressionRetryStateGenerator` implementation have been removed due to dependency on the `spring-retry` API.\n\nThe `max-attempts` attribute of the `<int:handler-retry-advice>` XML component has been renamed to the `max-retries` to better reflect the logic behind this property which is exactly about the number of attempts to call a failing handler.\n\nSee xref:handler-advice/classes.adoc#retry-advice[Retry Advice] for more information.\n\nAll the modules now follow the standard package structure.\nThe inbound and outbound components are declared in the `inbound` and `outbound` packages, respectively.\nThe `MessageChannel` implementations in the `channel` package.\nMost of the modules have followed this rule from day one.\nThe refactoring for package structure in this version includes the rest of modules: `spring-integration-file`, `spring-integration-ftp`, `spring-integration-ip`, `spring-integration-jdbc`, `spring-integration-jms`, `spring-integration-jmx`, `spring-integration-mail`, `spring-integration-sftp`, `spring-integration-stream` and `spring-integration-ws`.\nThe classes which were in root packages are marked now as deprecated.\n\n[[x7.0-new-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.5-7.0.adoc", "title": "changes-6.5-7.0", "heading": "General Changes", "heading_level": 2, "file_order": 188, "section_index": 1, "content_hash": "2f1e14200dbb9e17696a268dc7723586c3d480d4bdce1aee52d1ee4723e29ed1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.5-7.0.adoc"}}
{"id": "sha256:f29acccc040f42b3295ad79c008ed11a05eeb540c81bef54cd0885c3b43ad386", "content": "A new `DistributedLock` interface has been introduced, providing new methods, `lock(Duration ttl`) and `tryLock(long time, TimeUnit unit, Duration ttl)`, to acquire a lock with a custom time-to-live (TTL).\nSee xref:distributed-locks.adoc[] for more information.\n\nThe Jackson 2 support has been deprecated for removal.\nJackson 3 is now the default with new components: `JacksonJsonObjectMapper`, `JacksonPropertyAccessor`, `JacksonIndexAccessor`, and `JacksonMessagingUtils`.\nSee their Javadocs for more information and deprecated classes for a migration path.\n\nThe `spring-integration-amqp` module now implements channel adapters for RabbitMQ AMQP 1.0 support.\nThe dedicated xref:amqp/amqp-1.0.adoc[AMQP 1.0 Support] chapter provides more information.\n\n[[x7.0-jdbc-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.5-7.0.adoc", "title": "changes-6.5-7.0", "heading": "New Components", "heading_level": 2, "file_order": 188, "section_index": 2, "content_hash": "f29acccc040f42b3295ad79c008ed11a05eeb540c81bef54cd0885c3b43ad386", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.5-7.0.adoc"}}
{"id": "sha256:37018026eb71688b8bcdac68c4447743fefcd2746649060c035bed6b1c935120", "content": "The JDBC module now provides a Java DSL API via its dedicated `org.springframework.integration.jdbc.dsl.Jdbc` factory.\nThe xref:jdbc/dsl.adoc[] chapter provides more details.\n\nThe `JdbcLock` now supports the feature of customized time-to-live for the lock status data.\nSee xref:jdbc/lock-registry.adoc[] for more information.\n\nThe message stores now use a `MESSAGE_CONTENT` column name for serialized messages instead of `MESSAGE_BYTES` since the content might not always be stored as a byte array.\nAll the out-of-the-box SQL schemas have been changed, too, to rely on the `MESSAGE_CONTENT` name for the respective column in the `INT_MESSAGE` and `INT_CHANNEL_MESSAGE` tables.\nSee xref:jdbc/message-store.adoc[] for more information.\n\nThe `JdbcChannelMessageStore` now supports JSON serialization as an alternative to Java serialization.\nNew components `JsonChannelMessageStorePreparedStatementSetter` and `JsonMessageRowMapper` enable storing messages in JSON format.\nThis requires modifying the database schema to use text-based column types (such as `JSONB`, `JSON`, `TEXT`, or `CLOB`) instead of binary types.\nSee xref:jdbc/message-store-json.adoc[] for more information.\n\n[[x7.0-redis-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.5-7.0.adoc", "title": "changes-6.5-7.0", "heading": "JDBC Changes", "heading_level": 3, "file_order": 188, "section_index": 3, "content_hash": "37018026eb71688b8bcdac68c4447743fefcd2746649060c035bed6b1c935120", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.5-7.0.adoc"}}
{"id": "sha256:39995a43f724cefad9f46b212da9da068ebf233ff40fe36b3a3271e1b52fc2b1", "content": "The `RedisLock` now supports the feature of customized time-to-live for the lock status data.\nSee xref:redis.adoc#redis-lock-registry[Redis Lock Registry] for more information.\n\n[[x7.0-hazelcast-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.5-7.0.adoc", "title": "changes-6.5-7.0", "heading": "Redis Changes", "heading_level": 3, "file_order": 188, "section_index": 4, "content_hash": "39995a43f724cefad9f46b212da9da068ebf233ff40fe36b3a3271e1b52fc2b1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.5-7.0.adoc"}}
{"id": "sha256:348bc73d35c9f3019e8a0c19e32e0820f9472490f5b481a8f04c555aa4c311ea", "content": "Previously deprecated classes in the `spring-integation-hazelcast` module, such as `LeaderInitiator`, `HazelcastMembershipListener`, `HazelcastLocalInstanceRegistrar` and `HazelcastLockRegistry`, are now removed due to not supported CP-subsystem in Hazelcast library for Open Source.\n\n[[x7.0-mqtt-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.5-7.0.adoc", "title": "changes-6.5-7.0", "heading": "Hazelcast Changes", "heading_level": 3, "file_order": 188, "section_index": 5, "content_hash": "348bc73d35c9f3019e8a0c19e32e0820f9472490f5b481a8f04c555aa4c311ea", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.5-7.0.adoc"}}
{"id": "sha256:458a47ee6d924bc80eaa9557f4c12010ff29fd4ac58be48f3fa7db3031804c51", "content": "The `AbstractMqttMessageDrivenChannelAdapter` and `ClientManager` implementations now expose a `quiescentTimeout` option which is propagated in their `stop()` method down to the `disconnectForcibly()` API of the MQTT Paho clients.\nSee xref:mqtt.adoc[] for more information.\n\n[[x7.0-files-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.5-7.0.adoc", "title": "changes-6.5-7.0", "heading": "MQTT Changes", "heading_level": 3, "file_order": 188, "section_index": 6, "content_hash": "458a47ee6d924bc80eaa9557f4c12010ff29fd4ac58be48f3fa7db3031804c51", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.5-7.0.adoc"}}
{"id": "sha256:63602ac5fd4fbb1b50f8151c8f1306e6727826dcf61867a719faf121fa5fd282", "content": "The `FileReadingMessageSource` now can be configured with a SpEL `Expression` for its `directory` property.\nSee xref:file/reading.adoc[] for more information.\n\n[[x7.0-remote-files-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.5-7.0.adoc", "title": "changes-6.5-7.0", "heading": "Files Changes", "heading_level": 3, "file_order": 188, "section_index": 7, "content_hash": "63602ac5fd4fbb1b50f8151c8f1306e6727826dcf61867a719faf121fa5fd282", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.5-7.0.adoc"}}
{"id": "sha256:ce7a080667b71d5178edd7d2f5c63f5ae8c22b62d0395c9c37d1c9eb59ca1f02", "content": "The `AbstractInboundFileSynchronizer` now caches a filtered result of the `Session.list(remoteDirectory)` after slicing by the `maxFetchSize`.\nSo, later synchronizations deal with the cache only by the `maxFetchSize` until the cache is exhausted.\nSee xref:sftp/max-fetch.adoc[] for more information.\n\nAll the `AbstractPersistentAcceptOnceFileListFilter` implementations now use a \"long file name\" for the metadata entry key.\nPreviously, just a file name may cause the metadata overriding problem when the same filter is used for different directories with same file names.\nFor example, the `RotatingServerAdvice` may switch to directories based on the timestamp, but files are placed there with the same name according to business logic.\nSee xref:file/remote-persistent-flf.adoc[Remote Persistent File List Filters] for more information.\n\n[[x7.0-null-safety]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.5-7.0.adoc", "title": "changes-6.5-7.0", "heading": "Remote Files Support Changes", "heading_level": 3, "file_order": 188, "section_index": 8, "content_hash": "ce7a080667b71d5178edd7d2f5c63f5ae8c22b62d0395c9c37d1c9eb59ca1f02", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.5-7.0.adoc"}}
{"id": "sha256:69a88239ae487e3ee68349cfe2e0df5cd26ae4aa4eb71f4a17afc0a0281e12d8", "content": "Updated the codebase to use JSpecify and NullAway, adding a comprehensive null safety implementation that uses `@NullMarked` annotations to default all types to non-null at the package level and `@Nullable` annotations to explicitly mark types that can be null.\nSee xref:null-safety.adoc[] for more information.\n\n[[x7.0-smb-upgrade]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.5-7.0.adoc", "title": "changes-6.5-7.0", "heading": "Null Safety", "heading_level": 3, "file_order": 188, "section_index": 9, "content_hash": "69a88239ae487e3ee68349cfe2e0df5cd26ae4aa4eb71f4a17afc0a0281e12d8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.5-7.0.adoc"}}
{"id": "sha256:c2a7f21db7ec187ac333761c47611c007a88914fd51c431540e1c2124d6310a2", "content": "The JCIFS library behind the SMB support module has been upgraded to 3.0.0.\nIt is a major rewrite of the codebase and implements a new package structure.\nThis is a breaking change, and direct references to components of the JCIFS library will need to be updated.\nSee xref:smb.adoc[] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/changes-6.5-7.0.adoc", "title": "changes-6.5-7.0", "heading": "SMB Support Changes", "heading_level": 3, "file_order": 188, "section_index": 10, "content_hash": "c2a7f21db7ec187ac333761c47611c007a88914fd51c431540e1c2124d6310a2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/changes-6.5-7.0.adoc"}}
{"id": "sha256:b1140aa97b4b8415a5d0bb1fcc05f785f96d6394f377b7b88a129fdc2e3fd30c", "content": "[[channel-adapter]]\n\nA channel adapter is a message endpoint that enables connecting a single sender or receiver to a message channel.\nSpring Integration provides a number of adapters to support various transports, such as JMS, file, HTTP, web services, mail, and more.\nUpcoming chapters of this reference guide discuss each adapter.\nHowever, this chapter focuses on the simple but flexible method-invoking channel adapter support.\nThere are both inbound and outbound adapters, and each may be configured with XML elements provided in the core namespace.\nThese provide an easy way to extend Spring Integration, as long as you have a method that can be invoked as either a source or a destination.\n\n[[channel-adapter-namespace-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel-adapter.adoc", "title": "channel-adapter", "heading": "channel-adapter", "heading_level": 1, "file_order": 189, "section_index": 0, "content_hash": "b1140aa97b4b8415a5d0bb1fcc05f785f96d6394f377b7b88a129fdc2e3fd30c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel-adapter.adoc"}}
{"id": "sha256:a39cc4efeaa21c40e27235262700ff22c0357b249b6b2fd5fff1a2de0e2a4b0e", "content": "An `inbound-channel-adapter` element (a `SourcePollingChannelAdapter` in Java configuration) can invoke any method on a Spring-managed object and send a non-null return value to a `MessageChannel` after converting the method's output to a `Message`.\nWhen the adapter's subscription is activated, a poller tries to receive messages from the source.\nThe poller is scheduled with the `TaskScheduler` according to the provided configuration.\nTo configure the polling interval or cron expression for an individual channel adapter, you can provide a 'poller' element with one of the scheduling attributes, such as 'fixed-rate' or 'cron'.\nThe following example defines two `inbound-channel-adapter` instances:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow source1() {\n return IntegrationFlow.from(() -> new GenericMessage<>(...),\n e -> e.poller(p -> p.fixedRate(5000)))\n ...\n .get();\n}\n\n@Bean\npublic IntegrationFlow source2() {\n return IntegrationFlow.from(() -> new GenericMessage<>(...),\n e -> e.poller(p -> p.cron(\"30 * 9-17 * * MON-FRI\")))\n ...\n .get();\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\npublic class SourceService {\n\n @InboundChannelAdapter(channel = \"channel1\", poller = @Poller(fixedRate = \"5000\"))\n Object method1() {\n ...\n }\n\n @InboundChannelAdapter(channel = \"channel2\", poller = @Poller(cron = \"30 * 9-17 * * MON-FRI\"))\n Object method2() {\n ...\n }\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun messageSourceFlow() =\n integrationFlow( { GenericMessage<>(...) },\n { poller { it.fixedRate(5000) } }) {\n ...\n }\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:inbound-channel-adapter ref=\"source1\" method=\"method1\" channel=\"channel1\">\n <int:poller fixed-rate=\"5000\"/>\n</int:inbound-channel-adapter>\n\n<int:inbound-channel-adapter ref=\"source2\" method=\"method2\" channel=\"channel2\">\n <int:poller cron=\"30 * 9-17 * * MON-FRI\"/>\n</int:channel-adapter>\n----\n======\n\nSee also xref:channel-adapter.adoc#channel-adapter-expressions-and-scripts[Channel Adapter Expressions and Scripts].\n\nNOTE: If no poller is provided, then a single default poller must be registered within the context.\nSee xref:endpoint.adoc#endpoint-namespace[Endpoint Namespace Support] for more detail.\n\nNOTE: The default trigger for polling endpoint is a `PeriodicTrigger` instance with a `1` second fixed delay period.\n\n[IMPORTANT]\n.Important: Poller Configuration\n=====\nAll the `inbound-channel-adapter` types are backed by a `SourcePollingChannelAdapter`, which means they contain a poller configuration that polls the `MessageSource` (to invoke a custom method that produces the value that becomes a `Message` payload) based on the configuration specified in the Poller.\nThe following example shows the configuration of two pollers:\n\n[source,xml]\n----\n<int:poller max-messages-per-poll=\"1\" fixed-rate=\"1000\"/>\n\n<int:poller max-messages-per-poll=\"10\" fixed-rate=\"1000\"/>\n----\n\nIn the first configuration, the polling task is invoked once per poll, and, during each task (poll), the method (which results in the production of the message) is invoked once, based on the `max-messages-per-poll` attribute value.\nIn the second configuration, the polling task is invoked 10 times per poll or until it returns 'null', thus possibly producing ten messages per poll while each poll happens at one-second intervals.\nHowever, what happens if the configuration looks like the following example:\n\n[source,xml]\n----\n<int:poller fixed-rate=\"1000\"/>\n----\n\nNote that there is no `max-messages-per-poll` specified.\nAs we cover later, the identical poller configuration in the `PollingConsumer` (for example, `service-activator`, `filter`, `router`, and others) would have a default value of `-1` for `max-messages-per-poll`, which means \"`execute the polling task non-stop unless the polling method returns null (perhaps because there are no more messages in the `QueueChannel`)`\" and then sleep for one second.\n\nHowever, in the `SourcePollingChannelAdapter`, it is a bit different.\nThe default value for `max-messages-per-poll` is `1`, unless you explicitly set it to a negative value (such as `-1`).\nThis makes sure that the poller can react to lifecycle events (such as start and stop) and prevents it from potentially spinning in an infinite loop if the implementation of the custom method of the `MessageSource` has a potential to never return null and happens to be non-interruptible.\n\nHowever, if you are sure that your method can return null, and you need to poll for as many sources as available per each poll, you should explicitly set `max-messages-per-poll` to a negative value, as the following example shows:\n\n[source,xml]\n----\n<int:poller max-messages-per-poll=\"-1\" fixed-rate=\"1000\"/>\n----\n\nStarting with version 5.5, a `0` value for `max-messages-per-poll` has a special meaning - skip the `MessageSource.receive()` call altogether, which may be considered as pausing for this inbound channel adapter until the `maxMessagesPerPoll` is changed to a non-zero value at a later time, e.g. via a Control Bus.\n\nStarting with version 6.2, the `fixed-delay` and `fixed-rate` can be configured in https://en.wikipedia.org/wiki/ISO_8601#Durations[ISO 8601 Duration] format, e.g. `PT10S`, `P1D` etc.\nIn addition, an `initial-interval` of the underlying `PeriodicTrigger` is also exposed with similar value formats as `fixed-delay` and `fixed-rate`.\n\nAlso see xref:endpoint.adoc#global-default-poller[Global Default Poller] for more information.\n=====\n\n[[channel-adapter-namespace-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel-adapter.adoc", "title": "channel-adapter", "heading": "Configuring An Inbound Channel Adapter", "heading_level": 2, "file_order": 189, "section_index": 1, "content_hash": "a39cc4efeaa21c40e27235262700ff22c0357b249b6b2fd5fff1a2de0e2a4b0e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel-adapter.adoc"}}
{"id": "sha256:3b35e128d855896bb219eca13906ef3e693b8a9162ba5a41ef02d1c776a64c70", "content": "An `outbound-channel-adapter` element (a `@ServiceActivator` for Java configuration) can also connect a `MessageChannel` to any POJO consumer method that should be invoked with the payload of messages sent to that channel.\nThe following example shows how to define an outbound channel adapter:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow outboundChannelAdapterFlow(MyPojo myPojo) {\n return f -> f\n .handle(myPojo, \"handle\");\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\npublic class MyPojo {\n\n @ServiceActivator(channel = \"channel1\")\n void handle(Object payload) {\n ...\n }\n\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun outboundChannelAdapterFlow(myPojo: MyPojo) =\n integrationFlow {\n handle(myPojo, \"handle\")\n }\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:outbound-channel-adapter channel=\"channel1\" ref=\"target\" method=\"handle\"/>\n\n<beans:bean id=\"target\" class=\"org.MyPojo\"/>\n----\n======\n\nIf the channel being adapted is a `PollableChannel`, you must provide a poller subelement (the `@Poller` sub-annotation on the `@ServiceActivator`), as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\npublic class MyPojo {\n\n @ServiceActivator(channel = \"channel1\", poller = @Poller(fixedRate = \"3000\"))\n void handle(Object payload) {\n ...\n }\n\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:outbound-channel-adapter channel=\"channel2\" ref=\"target\" method=\"handle\">\n <int:poller fixed-rate=\"3000\" />\n</int:outbound-channel-adapter>\n\n<beans:bean id=\"target\" class=\"org.MyPojo\"/>\n----\n======\n\nYou should use a `ref` attribute if the POJO consumer implementation can be reused in other `<outbound-channel-adapter>` definitions.\nHowever, if the consumer implementation is referenced by only a single definition of the `<outbound-channel-adapter>`, you can define it as an inner bean, as the following example shows:\n\n[source,xml]\n----\n<int:outbound-channel-adapter channel=\"channel\" method=\"handle\">\n <beans:bean class=\"org.Foo\"/>\n</int:outbound-channel-adapter>\n----\n\nNOTE: Using both the `ref` attribute and an inner handler definition in the same `<outbound-channel-adapter>` configuration is not allowed, as it creates an ambiguous condition.\nSuch a configuration results in an exception being thrown.\n\nAny channel adapter can be created without a `channel` reference, in which case it implicitly creates an instance of `DirectChannel`.\nThe created channel's name matches the `id` attribute of the `<inbound-channel-adapter>` or `<outbound-channel-adapter>` element.\nTherefore, if `channel` is not provided, `id` is required.\n\n[[channel-adapter-expressions-and-scripts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel-adapter.adoc", "title": "channel-adapter", "heading": "Configuring An Outbound Channel Adapter", "heading_level": 2, "file_order": 189, "section_index": 2, "content_hash": "3b35e128d855896bb219eca13906ef3e693b8a9162ba5a41ef02d1c776a64c70", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel-adapter.adoc"}}
{"id": "sha256:469a21844b93e06703a78f93df56451136a74ddd0231670c93ec5cf3f41ad367", "content": "Like many other Spring Integration components, the `<inbound-channel-adapter>` and `<outbound-channel-adapter>` also provide support for SpEL expression evaluation.\nTo use SpEL, provide the expression string in the 'expression' attribute instead of providing the 'ref' and 'method' attributes that are used for method-invocation on a bean.\nWhen an expression is evaluated, it follows the same contract as method-invocation where: the expression for an `<inbound-channel-adapter>` generates a message any time the evaluation result is a non-null value, while the expression for an `<outbound-channel-adapter>` must be the equivalent of a void-returning method invocation.\n\nStarting with Spring Integration 3.0, an `<int:inbound-channel-adapter/>` can also be configured with a SpEL `<expression/>` (or even with a `<script/>`) sub-element, for when more sophistication is required than can be achieved with the simple 'expression' attribute.\nIf you provide a script as a `Resource` by using the `location` attribute, you can also set `refresh-check-delay`, which allows the resource to be periodically refreshed.\nIf you want the script to be checked on each poll, you would need to coordinate this setting with the poller's trigger, as the following example shows:\n\n[source,xml]\n----\n<int:inbound-channel-adapter ref=\"source1\" method=\"method1\" channel=\"channel1\">\n <int:poller max-messages-per-poll=\"1\" fixed-delay=\"5000\"/>\n <script:script lang=\"ruby\" location=\"Foo.rb\" refresh-check-delay=\"5000\"/>\n</int:inbound-channel-adapter>\n----\n\nSee also the `cacheSeconds` property on the `ReloadableResourceBundleExpressionSource` when using the `<expression/>` sub-element.\nFor more information regarding expressions, see xref:spel.adoc[Spring Expression Language (SpEL)].\nFor scripts, see xref:groovy.adoc[Groovy support] and xref:scripting.adoc[Scripting Support].\n\nIMPORTANT: The `<int:inbound-channel-adapter/>` (`SourcePollingChannelAdapter`) is an endpoint which starts a message flow by periodically triggering to poll some underlying `MessageSource`.\nSince, at the time of polling, there is no message object, expressions and scripts do not have access to a root `Message`, so there are no payload or headers properties that are available in most other messaging SpEL expressions.\nThe script can generate and return a complete `Message` object with headers and payload or only a payload, which is added to a message with basic headers by the framework.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel-adapter.adoc", "title": "channel-adapter", "heading": "Channel Adapter Expressions and Scripts", "heading_level": 2, "file_order": 189, "section_index": 3, "content_hash": "469a21844b93e06703a78f93df56451136a74ddd0231670c93ec5cf3f41ad367", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel-adapter.adoc"}}
{"id": "sha256:ea4ed0c90cbe904993cade2adb63049f25ec88479fb459f70f05ba8bc3a142eb", "content": "[[channel]]\n\nWhile the `Message` plays the crucial role of encapsulating data, it is the `MessageChannel` that decouples message producers from message consumers.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/channel.adoc", "title": "channel", "heading": "channel", "heading_level": 1, "file_order": 190, "section_index": 0, "content_hash": "ea4ed0c90cbe904993cade2adb63049f25ec88479fb459f70f05ba8bc3a142eb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/channel.adoc"}}
{"id": "sha256:f94d0e883480d375dcc7626abcb6b03e27c07f39b7e2a3a732217f9a3ee76158", "content": "[[claim-check]]\n\nIn earlier sections, we covered several content enricher components that can help you deal with situations where a message is missing a piece of data.\nWe also discussed content filtering, which lets you remove data items from a message.\nHowever, there are times when we want to hide data temporarily.\nFor example, in a distributed system, we may receive a message with a very large payload.\nSome intermittent message processing steps may not need access to this payload and some may only need to access certain headers, so carrying the large message payload through each processing step may cause performance degradation, may produce a security risk, and may make debugging more difficult.\n\nThe https://www.enterpriseintegrationpatterns.com/StoreInLibrary.html[store in a library] (or claim check) pattern describes a mechanism that lets you store data in a well-known place while maintaining only a pointer (a claim check) to where that data is located.\nYou can pass that pointer around as the payload of a new message, thereby letting any component within the message flow get the actual data as soon as it needs it.\nThis approach is very similar to the certified mail process, where you get a claim check in your mailbox and then have to go to the post office to claim your actual package.\nIt is also the same idea as baggage claim after a flight or in a hotel.\n\nSpring Integration provides two types of claim check transformers:\n\n* Incoming Claim Check Transformer\n* Outgoing Claim Check Transformer\n\nConvenient namespace-based mechanisms are available to configure them.\n\n[[claim-check-in]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/claim-check.adoc", "title": "claim-check", "heading": "claim-check", "heading_level": 1, "file_order": 191, "section_index": 0, "content_hash": "f94d0e883480d375dcc7626abcb6b03e27c07f39b7e2a3a732217f9a3ee76158", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/claim-check.adoc"}}
{"id": "sha256:b2eb8dbb70e86ad0ca1b284a6f40bd43bc777f788a0451dffaf48ce99f017952", "content": "An incoming claim check transformer transforms an incoming message by storing it in the message store identified by its `message-store` attribute.\nThe following example defines an incoming claim check transformer:\n\n[source,xml]\n----\n<int:claim-check-in id=\"checkin\"\n input-channel=\"checkinChannel\"\n message-store=\"testMessageStore\"\n output-channel=\"output\"/>\n----\n\nIn the preceding configuration, the message that is received on the `input-channel` is persisted to the message store identified with the `message-store` attribute and indexed with a generated ID.\nThat ID is the claim check for that message.\nThe claim check also becomes the payload of the new (transformed) message that is sent to the `output-channel`.\n\nNow, assume that at some point you do need access to the actual message.\nYou can access the message store manually and get the contents of the message, or you can use the same approach (to creating a transformer) except that now you transform the Claim Check to the actual message by using an outgoing claim check transformer.\n\nThe following listing provides an overview of all available parameters of an incoming claim check transformer:\n\n[source,xml]\n----\n<int:claim-check-in auto-startup=\"true\" <1>\n id=\"\" <2>\n input-channel=\"\" <3>\n message-store=\"messageStore\" <4>\n order=\"\" <5>\n output-channel=\"\" <6>\n send-timeout=\"\"> <7>\n <int:poller></int:poller> <8>\n</int:claim-check-in>\n----\n\n<1> Lifecycle attribute signaling whether this component should be started during application context startup.\nIt defaults to `true`.\nThis attribute is not available inside a `Chain` element.\nOptional.\n<2> ID identifying the underlying bean definition (`MessageTransformingHandler`).\nThis attribute is not available inside a `Chain` element.\nOptional.\n<3> The receiving message channel of this endpoint.\nThis attribute is not available inside a `Chain` element.\nOptional.\n<4> Reference to the `MessageStore` to be used by this claim check transformer.\nIf not specified, the default reference is to a bean named `messageStore`.\nOptional.\n<5> Specifies the order for invocation when this endpoint is connected as a subscriber to a channel.\nThis is particularly relevant when that channel uses a `failover` dispatching strategy.\nIt has no effect when this endpoint is itself a polling consumer for a channel with a queue.\nThis attribute is not available inside a `Chain` element.\nOptional.\n<6> Identifies the message channel where the message is sent after being processed by this endpoint.\nThis attribute is not available inside a `Chain` element.\nOptional.\n<7> Specifies the maximum amount of time (in milliseconds) to wait when sending a reply message to the output channel.\nDefaults to `30` seconds.\nThis attribute is not available inside a `Chain` element.\nOptional.\n<8> Defines a poller.\nThis element is not available inside a `Chain` element.\nOptional.\n\n[[claim-check-out]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/claim-check.adoc", "title": "claim-check", "heading": "Incoming Claim Check Transformer", "heading_level": 2, "file_order": 191, "section_index": 1, "content_hash": "b2eb8dbb70e86ad0ca1b284a6f40bd43bc777f788a0451dffaf48ce99f017952", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/claim-check.adoc"}}
{"id": "sha256:45c4df5bf729bade01b537ec691ce643d9e34d414c87297024376a1fd2c892e4", "content": "An outgoing claim check transformer lets you transform a message with a claim check payload into a message with the original content as its payload.\n\n[source,xml]\n----\n<int:claim-check-out id=\"checkout\"\n input-channel=\"checkoutChannel\"\n message-store=\"testMessageStore\"\n output-channel=\"output\"/>\n----\n\nIn the preceding configuration, the message received on the `input-channel` should have a claim check as its payload.\nThe outgoing claim check transformer transforms it into a message with the original payload by querying the message store for a message identified by the provided claim check.\nIt then sends the newly checked-out message to the `output-channel`.\n\nThe following listing provides an overview of all available parameters of an outgoing claim check transformer:\n\n[source,xml]\n----\n<int:claim-check-out auto-startup=\"true\" <1>\n id=\"\" <2>\n input-channel=\"\" <3>\n message-store=\"messageStore\" <4>\n order=\"\" <5>\n output-channel=\"\" <6>\n remove-message=\"false\" <7>\n send-timeout=\"\"> <8>\n <int:poller></int:poller> <9>\n</int:claim-check-out>\n----\n\n<1> Lifecycle attribute signaling whether this component should be started during application context startup.\nIt defaults to `true`.\nThis attribute is not available inside a `Chain` element.\nOptional.\n<2> ID identifying the underlying bean definition (`MessageTransformingHandler`).\nThis attribute is not available inside a `Chain` element.\nOptional.\n<3> The receiving message channel of this endpoint.\nThis attribute is not available inside a `Chain` element.\nOptional.\n<4> Reference to the `MessageStore` to be used by this claim check transformer.\nIf not specified, the default reference is to a bean named `messageStore`.\nOptional.\n<5> Specifies the order for invocation when this endpoint is connected as a subscriber to a channel.\nThis is particularly relevant when that channel is using a `failover` dispatching strategy.\nIt has no effect when this endpoint is itself a polling consumer for a channel with a queue.\nThis attribute is not available inside a `Chain` element.\nOptional.\n<6> Identifies the message channel where the message is sent after being processed by this endpoint.\nThis attribute is not available inside a `Chain` element.\nOptional.\n<7> If set to `true`, the message is removed from the `MessageStore` by this transformer.\nThis setting is useful when a message can be \"`claimed`\" only once.\nIt defaults to `false`.\nOptional.\n<8> Specifies the maximum amount of time (in milliseconds) to wait when sending a reply message to the output channel.\nIt defaults to `30` seconds.\nThis attribute is not available inside a `Chain` element.\nOptional.\n<9> Defines a poller.\nThis element is not available inside a `Chain` element.\nOptional.\n\n[[claim-once]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/claim-check.adoc", "title": "claim-check", "heading": "Outgoing Claim Check Transformer", "heading_level": 2, "file_order": 191, "section_index": 2, "content_hash": "45c4df5bf729bade01b537ec691ce643d9e34d414c87297024376a1fd2c892e4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/claim-check.adoc"}}
{"id": "sha256:6819a723464ce3f28950a4b1a302bf222264aa84a9658bfb399469ad74da3d56", "content": "Sometimes, a particular message must be claimed only once.\nAs an analogy, consider a process of handling airplane luggage.\nYou're checking in your luggage on departure and claiming it on arrival.\nOnce the luggage has been claimed, it cannot be claimed again without first checking it back in.\nTo accommodate such cases, we introduced a `remove-message` boolean attribute on the `claim-check-out` transformer.\nThis attribute is set to `false` by default.\nHowever, if set to `true`, the claimed message is removed from the `MessageStore` so that it cannot be claimed again.\n\nThis feature has an impact in terms of storage space, especially in the case of the in-memory `Map`-based `SimpleMessageStore`, where failing to remove messages could ultimately lead to an `OutOfMemoryException`.\nTherefore, if you do not expect multiple claims to be made, we recommend that you set the `remove-message` attribute's value to `true`.\nThe following example show how to use the `remove-message` attribute:\n\n[source,xml]\n----\n<int:claim-check-out id=\"checkout\"\n input-channel=\"checkoutChannel\"\n message-store=\"testMessageStore\"\n output-channel=\"output\"\n remove-message=\"true\"/>\n----\n\n[[a-word-on-message-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/claim-check.adoc", "title": "claim-check", "heading": "Claim Once", "heading_level": 2, "file_order": 191, "section_index": 3, "content_hash": "6819a723464ce3f28950a4b1a302bf222264aa84a9658bfb399469ad74da3d56", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/claim-check.adoc"}}
{"id": "sha256:34c76ce363fccbd4389cab4902480855cbd4a05750bb1ff57dffa648fe49326f", "content": "Although we rarely care about the details of the claim checks (as long as they work), you should know that the current implementation of the actual claim check (the pointer) in Spring Integration uses a UUID to ensure uniqueness.\n\n`org.springframework.integration.store.MessageStore` is a strategy interface for storing and retrieving messages.\nSpring Integration provides two convenient implementations of it:\n\n* `SimpleMessageStore`: An in-memory, `Map`-based implementation (the default, good for testing)\n* `JdbcMessageStore`: An implementation that uses a relational database over JDBC", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/claim-check.adoc", "title": "claim-check", "heading": "A Word on Message Store", "heading_level": 2, "file_order": 191, "section_index": 4, "content_hash": "34c76ce363fccbd4389cab4902480855cbd4a05750bb1ff57dffa648fe49326f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/claim-check.adoc"}}
{"id": "sha256:54caa5bed47081f9909e725ccc25b3d93da34628f6142455cf8d45c3b3cf66bc", "content": "[[cloudevents]]\n\nSpring Integration provides support for the CloudEvents https://github.com/cloudevents/spec[specification].\n\nAdd the following dependency to your project:\n\n[tabs]\n======\nMaven::\n+\n[source,xml,subs=\"normal\",role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-cloudevents</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source,groovy,subs=\"normal\",role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-cloudevents:{project-version}\"\n----\n======\n\n[[to-cloud-event-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "cloudevents", "heading_level": 1, "file_order": 192, "section_index": 0, "content_hash": "54caa5bed47081f9909e725ccc25b3d93da34628f6142455cf8d45c3b3cf66bc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:e454491ef9e9f302de20dc7267346c687a690a7a280c37693e27255ab449bd7d", "content": "Use the `ToCloudEventTransformer` to convert Spring Integration messages into CloudEvents-compliant messages.\nThis transformer supports the CloudEvents specification v1.0 and serializes CloudEvents if an `EventFormat` or `eventFormatContentTypeExpression` is specified.\nWhen you specify an `EventFormat` or `eventFormatContentTypeExpression`, the transformer uses the `EventFormat` to generate the `CloudEvent` in the payload.\nIf neither is specified, the transformer writes the event data message payload as-is and adds attributes as well as extensions to the message headers.\nThe transformer supports defining attributes using expressions and identifies extensions in the message headers via patterns.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "`ToCloudEventTransformer`", "heading_level": 2, "file_order": 192, "section_index": 1, "content_hash": "e454491ef9e9f302de20dc7267346c687a690a7a280c37693e27255ab449bd7d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:508dbbfc6c68265a699216d82bd32a653a66677395cd2b26587a22c8e3d82ff7", "content": "Set the CloudEvents' attributes of `id`, `source`, `type`, `dataSchema`, and `subject` through SpEL expressions.\n\nNOTE: The transformer sets the `time` attribute to the time when it creates the CloudEvent instance.\n\nThe following table lists the attribute names and the values the default expressions return.\n\n|===\n| Attribute Name | Default Value\n\n| `id`\n| The id of the message.\n\n| `source`\n| A prefix of \"/spring/\" followed by the appName, a period, and then the transformer's bean name, e.g., `/spring/myapp.toCloudEventTransformerBean`.\n\n| `type`\n| \"spring.message\"\n\n| `dataContentType`\n| The contentType of the message, defaults to `application/octet-stream`.\nSome other examples include but are not limited to: `application/json`, `application/x-avro`, and `application/xml`.\n\n| `dataSchema`\n| The URI to the specified schema.\nThe default for `dataSchema` is `null`.\n\n| `subject`\n| Identify the subject of the event in the context of the event producer.\nThe default for `subject` is `null`.\n\n| `time`\n| The time the CloudEvent message is created.\nSet internally to the current time.\nNote that you cannot configure this value.\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "Attribute Expressions", "heading_level": 3, "file_order": 192, "section_index": 2, "content_hash": "508dbbfc6c68265a699216d82bd32a653a66677395cd2b26587a22c8e3d82ff7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:f40446f0a6f44d470bf860b882e38b437a2f955a01e2b8e502322d0ea4dd150e", "content": "Use the `extensionPatterns` constructor parameter (a vararg of strings) to specify pattern matching with wildcards (`*`).\nThe transformer includes message headers with keys matching any pattern as CloudEvent extensions.\nUse a `!` prefix to explicitly exclude headers through negation.\nNote that the first matching pattern wins (whether positive or negative).\n\nFor example, configure the patterns `\"trace*\", \"span-id\", \"user-id\"` to:\n- Include headers starting with `trace` (e.g., `trace-id`, `traceparent`) - Include headers with exact keys `span-id` and `user-id`\n- Add all matching headers as extensions to the CloudEvent\n\nTo exclude specific headers, use negated patterns: `\"custom-*\", \"!custom-internal\"` includes all headers starting with `custom-` except `custom-internal`.\n\n[[configuration-with-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "Extension Patterns", "heading_level": 3, "file_order": 192, "section_index": 3, "content_hash": "f40446f0a6f44d470bf860b882e38b437a2f955a01e2b8e502322d0ea4dd150e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:45d4f2d7418dcdba1383692bf8a1b455faac36b74cdca03891ef4f9d06ff9f33", "content": "Use the `CloudEvents` factory to add the `ToCloudEventTransformer` to flows using the xref:dsl.adoc[].\n\n[source,java]\n----\n@Bean\npublic ToCloudEventTransformer cloudEventTransformer() {\n return new ToCloudEventTransformer(\"trace*\", \"correlation-id\");\n}\n\n@Bean\npublic IntegrationFlow cloudEventTransformFlow(ToCloudEventTransformer toCloudEventTransformer) {\n return IntegrationFlows\n .from(\"inputChannel\")\n .transform(CloudEvents.toCloudEventTransformer().get())\n .channel(\"outputChannel\")\n .get();\n}\n----\n\n[[cloudevent-transformer-process]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "Configuration with DSL", "heading_level": 3, "file_order": 192, "section_index": 4, "content_hash": "45d4f2d7418dcdba1383692bf8a1b455faac36b74cdca03891ef4f9d06ff9f33", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:33125bf1f16c1a880ac97bcc8f6434f7c2c6435146c5e2a1848240360d7509c5", "content": "Understand the transformation process:\n\n1. **CloudEvent Building** - Build the CloudEvent attributes.\n2. **Extension Extraction** - Build the CloudEvent extensions using the array of extensionPatterns passed into the constructor.\n3. **Format Conversion** - Apply the specified `EventFormat` or, if not set, handle the conversion via Binary Format Mode.\n\nA basic transformation may have the following pattern:\n\n[source,java]\n----\nMessage<byte[]> inputMessage = MessageBuilder\n .withPayload(\"Hello CloudEvents\".getBytes(StandardCharsets.UTF_8))\n .withHeader(MessageHeaders.CONTENT_TYPE, \"text/plain\")\n .build();\n\nToCloudEventTransformer transformer = new ToCloudEventTransformer();\n\nObject cloudEventMessage = transformer.transform(inputMessage);\n----\n\n[[eventformats]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "CloudEvent Transformer Process", "heading_level": 3, "file_order": 192, "section_index": 5, "content_hash": "33125bf1f16c1a880ac97bcc8f6434f7c2c6435146c5e2a1848240360d7509c5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:e4a52b57ab62cab1cbc89d6b35b0cd85823381454d601f068ed470df41a48917", "content": "The ToCloudEventTransformer uses formatting to serialize the `CloudEvent` into the message's payload when the `EventFormat` is available, or uses Binary Format Mode otherwise.\nSet the `EventFormat` in one of two ways:\n\n1. Set the desired `EventFormat`.\n2. Set the `eventFormatContentTypeExpression` with an expression that resolves to a content type that `EventFormatProvider` can use to provide the required `EventFormat`.\nWhen the `eventFormatContentTypeExpression` is set and the `EventFormatProvider` returns null because it cannot find the `EventFormat` for the content type, the transformer throws a `MessageTransformationException`.\nExamples of content types that the `eventFormatContentTypeExpression` can resolve to that are accepted by the `EventFormatProvider` are:\n- `application/cloudevents+json`\n- `application/cloudevents+xml`\n\nIf the `EventFormat` and the `eventFormatContentTypeExpression` are not set, the transformer adds cloud event attributes and extensions to the message headers with the cloud event prefix (default is `ce-`) and leaves the payload unchanged (Binary Format Mode).\n\nTo utilize a specific `EventFormat`, add the associated dependency.\nFor example, to add the XML `EventFormat`, add the following dependency: `io.cloudevents:cloudevents-xml`.\nSee the https://cloudevents.github.io/sdk-java[CloudEvents Java Reference Documentation] for information on the event formats that are available.\n\nNOTE: Ensure messages to be transformed to CloudEvents have a payload of type `byte[]`.\nThe transformer throws an `IllegalArgumentException` if the payload is not a byte array.\n\n[[from-cloud-event-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "EventFormats", "heading_level": 3, "file_order": 192, "section_index": 6, "content_hash": "e4a52b57ab62cab1cbc89d6b35b0cd85823381454d601f068ed470df41a48917", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:e8557794975bc8028e6f7ae5ab0be65b497c1bb3d7dc3890dd2885337516b43f", "content": "Use the `FromCloudEventTransformer` to convert CloudEvents into Spring Integration messages.\nThis transformer supports the CloudEvents specification v1.0 and processes CloudEvents from two payload types: `CloudEvent` objects or serialized `CloudEvent` byte arrays.\n\nThe transformer extracts `CloudEvent` data from the message payload and maps `CloudEvent` attributes along with `CloudEvent` extensions to message headers with a `ce-` prefix.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "`FromCloudEventTransformer`", "heading_level": 2, "file_order": 192, "section_index": 7, "content_hash": "e8557794975bc8028e6f7ae5ab0be65b497c1bb3d7dc3890dd2885337516b43f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:cf0e788fa0e3fe08c564f798b0eac3ebab26b9bbb5c9de1268f4437c0b68a0d9", "content": "The transformer accepts messages with the following payload types:\n\n[#cloudeventobjectype]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "Supported Payload Types", "heading_level": 3, "file_order": 192, "section_index": 8, "content_hash": "cf0e788fa0e3fe08c564f798b0eac3ebab26b9bbb5c9de1268f4437c0b68a0d9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:293f360bdf2d1600fbade782fb71d098bead07de6250d6110940491486c08f16", "content": "When the message payload is a `CloudEvent` instance, the transformer:\n\n1. Extracts the CloudEvent data and uses it as the message payload.\n2. Maps CloudEvent attributes (`id`, `source`, `type`, `time`, `subject`, `datacontenttype`, `dataschema`) to message headers with a `ce-` prefix.\n3. Maps all CloudEvent extensions to message headers with the `ce-` prefix.\n4. Preserves all original message headers unless a header key matches a `CloudEvent` attribute or extension, in which case the original value is overwritten.\n\nExample:\n\n[source,java]\n----\nString orderJson = ...\n\nCloudEvent cloudEvent = CloudEventBuilder.v1()\n .withId(\"event-123\")\n .withSource(URI.create(\"/myapp/orders\"))\n .withType(\"order.created\")\n .withData(\"application/json\", orderJson.getBytes())\n .withExtension(\"traceid\", \"trace-abc\")\n .build();\n\nMessage<CloudEvent> inputMessage = MessageBuilder\n .withPayload(cloudEvent)\n .build();\n\nFromCloudEventTransformer transformer = new FromCloudEventTransformer();\nMessage<?> outputMessage = transformer.transform(inputMessage);\n----\n\nThe `outputMessage` from the example above produces output similar to the following:\n\n[source,terminaloutput]\n----\nGenericMessage [\n payload = byte[13],\n headers = {\n ce-source = /myapp/orders,\n ce-datacontenttype = application/json,\n ce-type = order.created,\n ce-id = event-123,\n ce-traceid = trace-abc,\n id = 2df76f27-d139-424c-19b6-80b64e4a33b0,\n contentType = application/json,\n timestamp = 1770667476433\n }\n]\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "CloudEvent Object Type", "heading_level": 4, "file_order": 192, "section_index": 9, "content_hash": "293f360bdf2d1600fbade782fb71d098bead07de6250d6110940491486c08f16", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:fde03c1d03c83d8e2a58942443466be099291e8746174e731ca5aed0519ca99a", "content": "When the message payload is a `byte[]` containing a serialized `CloudEvent`, the transformer:\n\n1. Uses the `content-type` header to resolve the appropriate `EventFormat` via `EventFormatProvider`.\n2. Deserializes the payload to a `CloudEvent` object using the resolved format.\n3. Follows the same steps enumerated in the <<cloudeventobjectype>> section.\n\nInformation on supported content types is discussed in the <<eventformats>> section.\n\nNOTE: `FromCloudEventTransformer` allows the user to set an `EventFormat` that will be used when the `EventFormatProvider` fails to find an `EventFormat` for the `contentType` header or if the message does not contain a `contentType` header.\nIf not set and an `EventFormat` is not found by the `EventFormatProvider`, a `MessageTransformationException` will be thrown.\n\nExample:\n\n[source,java]\n----\nbyte[] serializedCloudEvent = \"\"\"\n {\n \"specversion\": \"1.0\",\n \"id\": \"316b0cf3-0c4d-5858-6bd2-863a2042f442\",\n \"source\": \"/spring/testapp.jsonTransformerWithExtensions\",\n \"type\": \"spring.message\",\n \"subject\": \"test.subject\",\n \"datacontenttype\": \"text/plain\",\n \"time\": \"2026-01-30T08:53:06.099486-05:00\",\n \"traceid\": \"trace-123\",\n \"data\": \"Hello, World!\"\n }\n \"\"\";\n\nMessage<byte[]> inputMessage = MessageBuilder\n .withPayload(serializedCloudEvent)\n .setHeader(MessageHeaders.CONTENT_TYPE, \"application/cloudevents+json\")\n .build();\n\nFromCloudEventTransformer transformer = new FromCloudEventTransformer();\nMessage<?> outputMessage = transformer.transform(inputMessage);\n----\n\nThe `outputMessage` from the example above produces output similar to the following:\n\n[source,terminaloutput]\n----\nGenericMessage [\n payload = byte[13],\n headers = {\n ce-source = /spring/testapp.jsonTransformerWithExtensions,\n ce-datacontenttype = text/plain,\n ce-subject = test.subject,\n ce-type = spring.message,\n ce-id = 316b0cf3-0c4d-5858-6bd2-863a2042f442,\n ce-traceid = trace-123,\n ce-time = 2026-01-30T08:53:06.099486-05:00,\n id = 463c0878-a9cb-7269-a503-b4224088cd42,\n contentType = text/plain,\n timestamp = 1770392214225\n }\n]\n----\n\n[#cloudevent-attribute-mapping]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "Serialized CloudEvent Type", "heading_level": 4, "file_order": 192, "section_index": 10, "content_hash": "fde03c1d03c83d8e2a58942443466be099291e8746174e731ca5aed0519ca99a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:37ea061bfd1e61d5607143ed93a45037e74e8cf916e89437c153f9c9af7a9cd6", "content": "The transformer maps `CloudEvent` attributes to message headers using the following `CloudEventHeaders` constants:\n\n|===\n| CloudEvent Attribute | Message Header Key | Required\n\n| `id`\n| `ce-id`\n| Yes\n\n| `source`\n| `ce-source`\n| Yes\n\n| `type`\n| `ce-type`\n| Yes\n\n| `time`\n| `ce-time`\n| No\n\n| `subject`\n| `ce-subject`\n| No\n\n| `datacontenttype`\n| `ce-datacontenttype`\n| No\n\n| `dataschema`\n| `ce-dataschema`\n| No\n\n| extensions\n| `ce-+{extensionName}+`\n| No\n|===\n\nNOTE: The `contentType` header in the output message is always set to the CloudEvent's `datacontenttype` value.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "CloudEvent Attribute Mapping", "heading_level": 3, "file_order": 192, "section_index": 11, "content_hash": "37ea061bfd1e61d5607143ed93a45037e74e8cf916e89437c153f9c9af7a9cd6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:7fdabbda1f1be49905b4f71531dfa81e266ae6e7232d1141756fe5426a131dd5", "content": "Use the `CloudEvents` factory to add the `FromCloudEventTransformer` to flows using the xref:dsl.adoc[].\n\n[source,java]\n----\n@Bean\npublic FromCloudEventTransformer fromCloudEventTransformer() {\n return new FromCloudEventTransformer();\n}\n\n@Bean\npublic IntegrationFlow fromCloudEventFlow(FromCloudEventTransformer fromCloudEventTransformer) {\n return IntegrationFlows\n .from(\"cloudEventInputChannel\")\n .transform(CloudEvents.fromCloudEventTransformer())\n .channel(\"messageOutputChannel\")\n .get();\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/cloudevents.adoc", "title": "cloudevents", "heading": "Configuration with DSL", "heading_level": 3, "file_order": 192, "section_index": 12, "content_hash": "7fdabbda1f1be49905b4f71531dfa81e266ae6e7232d1141756fe5426a131dd5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/cloudevents.adoc"}}
{"id": "sha256:0020e2d4b32176d2ea91331d8b685c6ab209de6e1ce59df60b464f1ac9d21378", "content": "[[codec]]\n\nVersion 4.2 of Spring Integration introduced the `Codec` abstraction.\nCodecs encode and decode objects to and from `byte[]`.\nThey offer an alternative to Java serialization.\nOne advantage is that, typically, objects need not implement `Serializable`.\nWe provide one implementation that uses https://github.com/EsotericSoftware/kryo[Kryo] for serialization, but you can provide your own implementation for use in any of the following components:\n\n* `EncodingPayloadTransformer`\n* `DecodingTransformer`\n* `CodecMessageConverter`\n\n[[encodingpayloadtransformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/codec.adoc", "title": "codec", "heading": "codec", "heading_level": 1, "file_order": 193, "section_index": 0, "content_hash": "0020e2d4b32176d2ea91331d8b685c6ab209de6e1ce59df60b464f1ac9d21378", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/codec.adoc"}}
{"id": "sha256:5a4a67f835586c4ea8823d7616b5a8f514275bc24db0241390c21b8a27558d42", "content": "This transformer encodes the payload to a `byte[]` by using the codec.\nIt does not affect message headers.\n\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/EncodingPayloadTransformer.html[Javadoc] for more information.\n\n[[decodingtransformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/codec.adoc", "title": "codec", "heading": "`EncodingPayloadTransformer`", "heading_level": 2, "file_order": 193, "section_index": 1, "content_hash": "5a4a67f835586c4ea8823d7616b5a8f514275bc24db0241390c21b8a27558d42", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/codec.adoc"}}
{"id": "sha256:d355c63ad6651a1637d500ae2dbc9e55b8738c23397233f4d2c067e017901f95", "content": "This transformer decodes a `byte[]` by using the codec.\nIt needs to be configured with the `Class` to which the object should be decoded (or an expression that resolves to a `Class`).\nIf the resulting object is a `Message<?>`, inbound headers are not retained.\n\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/transformer/DecodingTransformer.html[Javadoc] for more information.\n\n[[codecmessageconverter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/codec.adoc", "title": "codec", "heading": "`DecodingTransformer`", "heading_level": 2, "file_order": 193, "section_index": 2, "content_hash": "d355c63ad6651a1637d500ae2dbc9e55b8738c23397233f4d2c067e017901f95", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/codec.adoc"}}
{"id": "sha256:adfa31a612073a0d901891d18826c0dac1283e138db79555f3372d4dc98960fa", "content": "Certain endpoints (such as TCP and Redis) have no concept of message headers.\nThey support the use of a `MessageConverter`, and the `CodecMessageConverter` can be used to convert a message to or from a `byte[]` for transmission.\n\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/codec/CodecMessageConverter.html[Javadoc] for more information.\n\n[[kryo]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/codec.adoc", "title": "codec", "heading": "`CodecMessageConverter`", "heading_level": 2, "file_order": 193, "section_index": 3, "content_hash": "adfa31a612073a0d901891d18826c0dac1283e138db79555f3372d4dc98960fa", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/codec.adoc"}}
{"id": "sha256:6d449599eb45bcc0dec84b62d55d43f6bdf56253cc3b3cbe5c076c63cb72ac7c", "content": "Currently, this is the only implementation of `Codec`, and it provides three kinds of `Codec`:\n\n* `PojoCodec`: Used in the transformers\n* `MessageCodec`: Used in the `CodecMessageConverter`\n* `CompositeCodec`: Used in transformers\n\nThe framework provides several custom serializers:\n\n* `FileSerializer`\n* `MessageHeadersSerializer`\n* `MutableMessageHeadersSerializer`\n\nThe first can be used with the `PojoCodec` by initializing it with the `FileKryoRegistrar`.\nThe second and third are used with the `MessageCodec`, which is initialized with the `MessageKryoRegistrar`.\n\n[[composite-codec]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/codec.adoc", "title": "codec", "heading": "Kryo", "heading_level": 2, "file_order": 193, "section_index": 4, "content_hash": "6d449599eb45bcc0dec84b62d55d43f6bdf56253cc3b3cbe5c076c63cb72ac7c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/codec.adoc"}}
{"id": "sha256:75f591d18801ede0761213e039ffa53c48c48a681d40612263fb8f4aa9a1fec5", "content": "The `CompositeCodec` is a codec that combines multiple codecs into a single codec, delegating encoding and decoding operations to the appropriate type-specific codec.\nThis implementation associates object types with their appropriate codecs while providing a fallback default codec for unregistered types.\n\nAn example implementation can be seen below:\n[source,java]\n----\nvoid encodeDecodeSample() {\n Codec codec = getFullyQualifiedCodec();\n\n //Encode and Decode a Dog Object\n Dog dog = new Dog(\"Wolfy\", 3, \"woofwoof\");\n dog = codec.decode(\n codec.encode(dog),\n Dog.class);\n System.out.println(dog);\n\n //Encode and Decode a Cat Object\n Cat cat = new Cat(\"Kitty\", 2, 8);\n cat = codec.decode(\n codec.encode(cat),\n Cat.class);\n System.out.println(cat);\n\n //Use the default code if the type being decoded and encoded is not Cat or dog.\n Animal animal = new Animal(\"Badger\", 5);\n Animal animalOut = codec.decode(\n codec.encode(animal),\n Animal.class);\n System.out.println(animalOut);\n}\n\n/**\n * Create and return a {@link CompositeCodec} that associates {@code Dog} and {@code Cat}\n * classes with their respective {@link PojoCodec} instances, while providing a default\n * codec for {@code Animal} types.\n * <p>\n * @return a fully qualified {@link CompositeCodec} for {@code Dog}, {@code Cat},\n * and fallback for {@code Animal}\n */\nstatic Codec getFullyQualifiedCodec() {\n Map<Class<?>, Codec> codecs = new HashMap<Class<?>, Codec>();\n codecs.put(Dog.class, new PojoCodec(new KryoClassListRegistrar(Dog.class)));\n codecs.put(Cat.class, new PojoCodec(new KryoClassListRegistrar(Cat.class)));\n return new CompositeCodec(codecs, new PojoCodec(\n new KryoClassListRegistrar(Animal.class)));\n}\n\nrecord Dog(String name, int age, String tag) {}\nrecord Cat(String name, int age, int lives) {}\nrecord Animal(String name, int age){}\n----\n\nIn some cases a single type of object may return multiple codecs.\nIn these cases an `IllegalStateException` is thrown.\n\nNOTE: This class uses `ClassUtils.findClosestMatch` to select the appropriate codec for a given object type.\nWhen multiple codecs match an object type, `ClassUtils.findClosestMatch` offers the `failOnTie` option.\nIf `failOnTie` is `false`, it will return any one of the matching codecs.\nIf `failOnTie` is `true` and multiple codecs match, it will throw an `IllegalStateException`.\n`CompositeCodec` sets `failOnTie` to `true`, so if multiple codecs match, an `IllegalStateException` is thrown.\n\n[[customizing-kryo]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/codec.adoc", "title": "codec", "heading": "CompositeCodec", "heading_level": 3, "file_order": 193, "section_index": 5, "content_hash": "75f591d18801ede0761213e039ffa53c48c48a681d40612263fb8f4aa9a1fec5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/codec.adoc"}}
{"id": "sha256:3d21f872d1d12dc0668ce85e53b1c53d12bc5743e9fdece82cbcf270c0cb7d28", "content": "By default, Kryo delegates unknown Java types to its `FieldSerializer`.\nKryo also registers default serializers for each primitive type, along with `String`, `Collection`, and `Map`.\n`FieldSerializer` uses reflection to navigate the object graph.\nA more efficient approach is to implement a custom serializer that is aware of the object's structure and can directly serialize selected primitive fields.\nThe following example shows such a serializer:\n\n[source,java]\n----\npublic class AddressSerializer extends Serializer<Address> {\n\n @Override\n public void write(Kryo kryo, Output output, Address address) {\n output.writeString(address.getStreet());\n output.writeString(address.getCity());\n output.writeString(address.getCountry());\n }\n\n @Override\n public Address read(Kryo kryo, Input input, Class<Address> type) {\n return new Address(input.readString(), input.readString(), input.readString());\n }\n}\n----\n\nThe `Serializer` interface exposes `Kryo`, `Input`, and `Output`, which provide complete control over which fields are included and other internal settings, as described in the https://github.com/EsotericSoftware/kryo[Kryo documentation].\n\nNOTE: When registering your custom serializer, you need a registration ID.\nThe registration IDs are arbitrary.\nHowever, in our case, the IDs must be explicitly defined because each Kryo instance across the distributed application must use the same IDs.\nKryo recommends small positive integers and reserves a little ids (value < 10).\nSpring Integration currently defaults to using 40, 41, and 42 (for the file and message header serializers mentioned earlier).\nWe recommend you start at 60, to allow for expansion in the framework.\nYou can override these framework defaults by configuring the registrars mentioned earlier.\n\n[[using-a-custom-kryo-serializer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/codec.adoc", "title": "codec", "heading": "Customizing Kryo", "heading_level": 3, "file_order": 193, "section_index": 6, "content_hash": "3d21f872d1d12dc0668ce85e53b1c53d12bc5743e9fdece82cbcf270c0cb7d28", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/codec.adoc"}}
{"id": "sha256:6a09103952ffe91df493473e82772e2017a7a656e2b589b11423d3bdd4f9bd42", "content": "If you need custom serialization, see the https://github.com/EsotericSoftware/kryo[Kryo] documentation because you need to use the native API to do the customization.\nFor an example, see the `org.springframework.integration.codec.kryo.MessageCodec` implementation.\n\n[[implementing-kryoserializable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/codec.adoc", "title": "codec", "heading": "Using a Custom Kryo Serializer", "heading_level": 4, "file_order": 193, "section_index": 7, "content_hash": "6a09103952ffe91df493473e82772e2017a7a656e2b589b11423d3bdd4f9bd42", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/codec.adoc"}}
{"id": "sha256:6d6731a842be4c82ad544d9c53069e2e43228fc4b2ac1764d9e82492135d5aa9", "content": "If you have `write` access to the domain object source code, you can implement `KryoSerializable` as described https://github.com/EsotericSoftware/kryo#kryoserializable[here].\nIn this case, the class provides the serialization methods itself and no further configuration is required.\nHowever, benchmarks have shown this is not quite as efficient as registering a custom serializer explicitly.\nThe following example shows a custom Kryo serializer:\n\n[source,java]\n----\npublic class Address implements KryoSerializable {\n\n @Override\n public void write(Kryo kryo, Output output) {\n output.writeString(this.street);\n output.writeString(this.city);\n output.writeString(this.country);\n }\n\n @Override\n public void read(Kryo kryo, Input input) {\n this.street = input.readString();\n this.city = input.readString();\n this.country = input.readString();\n }\n}\n----\n\nYou can also use this technique to wrap a serialization library other than Kryo.\n\n[[using-the-defaultserializer-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/codec.adoc", "title": "codec", "heading": "Implementing KryoSerializable", "heading_level": 4, "file_order": 193, "section_index": 8, "content_hash": "6d6731a842be4c82ad544d9c53069e2e43228fc4b2ac1764d9e82492135d5aa9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/codec.adoc"}}
{"id": "sha256:e2eb20cc9d330d03ba637ef5277494bb67a271207c79f4af1f4543c1d1035643", "content": "Kryo also provides a `@DefaultSerializer` annotation, as described https://github.com/EsotericSoftware/kryo#default-serializers[here].\n\n[source,java]\n----\n@DefaultSerializer(SomeClassSerializer.class)\npublic class SomeClass {\n // ...\n}\n----\n\nIf you have `write` access to the domain object, this may be a simpler way to specify a custom serializer.\nNote that this does not register the class with an ID, which may make the technique unhelpful for certain situations.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/codec.adoc", "title": "codec", "heading": "Using the `@DefaultSerializer` Annotation", "heading_level": 4, "file_order": 193, "section_index": 9, "content_hash": "e2eb20cc9d330d03ba637ef5277494bb67a271207c79f4af1f4543c1d1035643", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/codec.adoc"}}
{"id": "sha256:a06c75461422b63bf156df6eed66bf27990ee377613f9a4f5f214bb4aa1f15a8", "content": "[[configuration]]\n\nSpring Integration offers a number of configuration options.\nWhich option you choose depends upon your particular needs and at what level you prefer to work.\nAs with the Spring framework in general, you can mix and match the various techniques to suit the problem at hand.\nFor example, you can choose the XSD-based namespace for the majority of configuration and combine it with a handful of objects that you configure with annotations.\nAs much as possible, the two provide consistent naming.\nThe XML elements defined by the XSD schema match the names of the annotations, and the attributes of those XML elements match the names of annotation properties.\nYou can also use the API directly, but we expect most developers to choose one of the higher-level options or a combination of the namespace-based and annotation-driven configuration.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/configuration.adoc", "title": "configuration", "heading": "configuration", "heading_level": 1, "file_order": 194, "section_index": 0, "content_hash": "a06c75461422b63bf156df6eed66bf27990ee377613f9a4f5f214bb4aa1f15a8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/configuration.adoc"}}
{"id": "sha256:e9d6bf1a6863ee50be13fc0491189654a122e07cb85c666e3e97b3be1eed0b3c", "content": "[[content-enricher]]\n\nAt times, you may have a requirement to enhance a request with more information than was provided by the target system.\nThe https://www.enterpriseintegrationpatterns.com/DataEnricher.html[data enricher] pattern describes various scenarios as well as the component (Enricher) that lets you address such requirements.\n\nThe Spring Integration `Core` module includes two enrichers:\n\n* xref:content-enrichment.adoc#header-enricher[Header Enricher]\n* xref:content-enrichment.adoc#payload-enricher[Payload Enricher]\n\nIt also includes three adapter-specific header enrichers:\n\n* xref:xml/xpath-header-enricher.adoc[XPath Header Enricher (XML Module)]\n* xref:mail.adoc#mail-namespace[Mail Header Enricher (Mail Module)]\n* xref:xmpp.adoc#xmpp-message-outbound-channel-adapter[XMPP Header Enricher (XMPP Module)]\n\nSee the adapter-specific sections of this reference manual to learn more about those adapters.\n\nFor more information regarding expression support, see xref:spel.adoc[Spring Expression Language (SpEL)].\n\n[[header-enricher]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "content-enrichment", "heading_level": 1, "file_order": 195, "section_index": 0, "content_hash": "e9d6bf1a6863ee50be13fc0491189654a122e07cb85c666e3e97b3be1eed0b3c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:1311217b48f6334c76179988dec4ef3d7d56d92e8b7e88d458500842a44ffae4", "content": "If you need to do nothing more than add headers to a message and the headers are not dynamically determined by the message content, referencing a custom implementation of a transformer may be overkill.\nFor that reason, Spring Integration provides support for the header enricher pattern.\nIt is exposed through the `<header-enricher>` element.\nThe following example shows how to use it:\n\n[source,xml]\n----\n<int:header-enricher input-channel=\"in\" output-channel=\"out\">\n <int:header name=\"foo\" value=\"123\"/>\n <int:header name=\"bar\" ref=\"someBean\"/>\n</int:header-enricher>\n----\n\nThe header enricher also provides helpful sub-elements to set well-known header names, as the following example shows:\n\n[source,xml]\n----\n<int:header-enricher input-channel=\"in\" output-channel=\"out\">\n <int:error-channel ref=\"applicationErrorChannel\"/>\n <int:reply-channel ref=\"quoteReplyChannel\"/>\n <int:correlation-id value=\"123\"/>\n <int:priority value=\"HIGHEST\"/>\n <routing-slip value=\"channel1; routingSlipRoutingStrategy; request.headers[myRoutingSlipChannel]\"/>\n <int:header name=\"bar\" ref=\"someBean\"/>\n</int:header-enricher>\n----\n\nThe preceding configuration shows that, for well-known headers (such as `errorChannel`, `correlationId`, `priority`, `replyChannel`, `routing-slip`, and others), instead of using generic `<header>` sub-elements where you would have to provide both header 'name' and 'value', you can use convenient sub-elements to set those values directly.\n\nStarting with version 4.1, the header enricher provides a `routing-slip` sub-element.\nSee xref:router/routing-slip.adoc[Routing Slip] for more information.\n\n[[pojo-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "Header Enricher", "heading_level": 2, "file_order": 195, "section_index": 1, "content_hash": "1311217b48f6334c76179988dec4ef3d7d56d92e8b7e88d458500842a44ffae4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:da989f5ad4cd31d79a8b9c08f2904fc920c34e10aa89a5825e46d005668fdacf", "content": "Often, a header value cannot be defined statically and has to be determined dynamically based on some content in the message.\nThat is why the header enricher lets you also specify a bean reference by using the `ref` and `method` attributes.\nThe specified method calculates the header value.\nConsider the following configuration and a bean with a method that modifies a `String`:\n\n[source,xml]\n----\n<int:header-enricher input-channel=\"in\" output-channel=\"out\">\n <int:header name=\"something\" method=\"computeValue\" ref=\"myBean\"/>\n</int:header-enricher>\n\n<bean id=\"myBean\" class=\"thing1.thing2.MyBean\"/>\n----\n\n[source,java]\n----\npublic class MyBean {\n\n public String computeValue(String payload){\n return payload.toUpperCase() + \"_US\";\n }\n}\n----\n\nYou can also configure your POJO as an inner bean, as the following example shows:\n\n[source,xml]\n----\n<int:header-enricher input-channel=\"inputChannel\" output-channel=\"outputChannel\">\n <int:header name=\"some_header\">\n <bean class=\"org.MyEnricher\"/>\n </int:header>\n</int:header-enricher>\n----\n\nYou can similarly point to a Groovy script, as the following example shows:\n\n[source,xml]\n----\n<int:header-enricher input-channel=\"inputChannel\" output-channel=\"outputChannel\">\n <int:header name=\"some_header\">\n <int-groovy:script location=\"org/SampleGroovyHeaderEnricher.groovy\"/>\n </int:header>\n</int:header-enricher>\n----\n\n[[spel-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "POJO Support", "heading_level": 3, "file_order": 195, "section_index": 2, "content_hash": "da989f5ad4cd31d79a8b9c08f2904fc920c34e10aa89a5825e46d005668fdacf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:3c90dd29032090f2a8260d9fc295f08d0307766dad0cdbd6dce378fee4b89fbd", "content": "In Spring Integration 2.0, we introduced the convenience of the https://docs.spring.io/spring-framework/reference/core/expressions.html[Spring Expression Language (SpEL)] to help configure many different components.\nThe header enricher is one of them.\nLook again at the POJO example shown earlier.\nYou can see that the computation logic to determine the header value is pretty simple.\nA natural question would be: \"Is there an even simpler way to accomplish this?\".\nThat is where SpEL shows its true power.\nConsider the following example:\n\n[source,xml]\n----\n<int:header-enricher input-channel=\"in\" output-channel=\"out\">\n <int:header name=\"foo\" expression=\"payload.toUpperCase() + '_US'\"/>\n</int:header-enricher>\n----\n\nBy using SpEL for such simple cases, you no longer have to provide a separate class and configure it in the application context.\nAll you need do is configured the `expression` attribute with a valid SpEL expression.\nThe 'payload' and 'headers' variables are bound to the SpEL evaluation context, giving you full access to the incoming message.\n\n[[configuring-a-header-enricher-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "SpEL Support", "heading_level": 3, "file_order": 195, "section_index": 3, "content_hash": "3c90dd29032090f2a8260d9fc295f08d0307766dad0cdbd6dce378fee4b89fbd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:5f916554592e6f82329d13fbf84d7921a0033612e17ba6a0d4dc816187fd32ad", "content": "The following two examples show how to use Java Configuration for header enrichers:\n\n[source, java]\n----\n@Bean\n@Transformer(inputChannel = \"enrichHeadersChannel\", outputChannel = \"emailChannel\")\npublic HeaderEnricher enrichHeaders() {\n Map<String, ? extends HeaderValueMessageProcessor<?>> headersToAdd =\n Collections.singletonMap(\"emailUrl\",\n new StaticHeaderValueMessageProcessor<>(this.imapUrl));\n HeaderEnricher enricher = new HeaderEnricher(headersToAdd);\n return enricher;\n}\n\n@Bean\n@Transformer(inputChannel=\"enrichHeadersChannel\", outputChannel=\"emailChannel\")\npublic HeaderEnricher enrichHeaders() {\n Map<String, HeaderValueMessageProcessor<?>> headersToAdd = new HashMap<>();\n headersToAdd.put(\"emailUrl\", new StaticHeaderValueMessageProcessor<String>(this.imapUrl));\n Expression expression = new SpelExpressionParser().parseExpression(\"payload.from[0].toString()\");\n headersToAdd.put(\"from\",\n new ExpressionEvaluatingHeaderValueMessageProcessor<>(expression, String.class));\n HeaderEnricher enricher = new HeaderEnricher(headersToAdd);\n return enricher;\n}\n----\n\nThe first example adds a single literal header.\nThe second example adds two headers, a literal header and one based on a SpEL expression.\n\n[[configuring-a-header-enricher-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "Configuring a Header Enricher with Java Configuration", "heading_level": 3, "file_order": 195, "section_index": 4, "content_hash": "5f916554592e6f82329d13fbf84d7921a0033612e17ba6a0d4dc816187fd32ad", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:1fc82d4ddfaee5fbbd78f1a0e399d0ccf96877546b0efa994a3e93801e24ffcd", "content": "The following example shows Java DSL Configuration for a header enricher:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow enrichHeadersInFlow() {\n return f -> f\n ...\n .enrichHeaders(h -> h.header(\"emailUrl\", this.emailUrl)\n .headerExpression(\"from\", \"payload.from[0].toString()\"))\n .handle(...);\n}\n----\n\n[[header-channel-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "Configuring a Header Enricher with the Java DSL", "heading_level": 3, "file_order": 195, "section_index": 5, "content_hash": "1fc82d4ddfaee5fbbd78f1a0e399d0ccf96877546b0efa994a3e93801e24ffcd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:4972ca7ce4b325bff05ae42ab2e121abb604e7e0a293d1ae254dd9771f7e5a9e", "content": "Starting with Spring Integration 3.0, a new sub-element `<int:header-channels-to-string/>` is available.\nIt has no attributes.\nThis new subelement converts existing `replyChannel` and `errorChannel` headers (when they are a `MessageChannel`) to a `String` and stores the channels in a registry for later resolution, when it is time to send a reply or handle an error.\nThis is useful for cases where the headers might be lost -- for example, when serializing a message into a message store or when transporting the message over JMS.\nIf the header does not already exist, or it is not a `MessageChannel`, no changes are made.\n\nUsing this functionality requires the presence of a `HeaderChannelRegistry` bean.\nBy default, the framework creates a `DefaultHeaderChannelRegistry` with the default expiry (60 seconds).\nChannels are removed from the registry after this time.\nTo change this behavior, define a bean with an `id` of `integrationHeaderChannelRegistry` and configure the required default delay by using a constructor argument (in milliseconds).\n\nSince version 4.1, you can set a property called `removeOnGet` to `true` on the `<bean/>` definition, and the mapping entry is removed immediately on first use.\nThis might be useful in a high-volume environment and when the channel is only used once, rather than waiting for the reaper to remove it.\n\nThe `HeaderChannelRegistry` has a `size()` method to determine the current size of the registry.\nThe `runReaper()` method cancels the current scheduled task and runs the reaper immediately.\nThe task is then scheduled to run again based on the current delay.\nThese methods can be invoked directly by getting a reference to the registry, or you can send a message with, for example, the following content to a control bus:\n\n[source]\n----\n\"integrationHeaderChannelRegistry.runReaper\"\n----\n\nThis subelement is a convenience and is the equivalent of specifying the following configuration:\n\n[source,xml]\n----\n<int:reply-channel\n expression=\"@integrationHeaderChannelRegistry.channelToChannelName(headers.replyChannel)\"\n overwrite=\"true\" />\n<int:error-channel\n expression=\"@integrationHeaderChannelRegistry.channelToChannelName(headers.errorChannel)\"\n overwrite=\"true\" />\n----\n\nStarting with version 4.1, you can now override the registry's configured reaper delay so that the channel mapping is retained for at least the specified time, regardless of the reaper delay.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<int:header-enricher input-channel=\"inputTtl\" output-channel=\"next\">\n <int:header-channels-to-string time-to-live-expression=\"120000\" />\n</int:header-enricher>\n\n<int:header-enricher input-channel=\"inputCustomTtl\" output-channel=\"next\">\n <int:header-channels-to-string\n time-to-live-expression=\"headers['channelTTL'] ?: 120000\" />\n</int:header-enricher>\n----\n\nIn the first case, the time to live for every header channel mapping will be two minutes.\nIn the second case, the time to live is specified in the message header and uses an Elvis operator to use two minutes if there is no header.\n\n[[payload-enricher]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "Header Channel Registry", "heading_level": 3, "file_order": 195, "section_index": 6, "content_hash": "4972ca7ce4b325bff05ae42ab2e121abb604e7e0a293d1ae254dd9771f7e5a9e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:79c5891dcf465bf2e725b83ff89a96faf0e0e992e85547ad9f2f679801bc847f", "content": "In certain situations, the header enricher, as discussed earlier, may not be sufficient and payloads themselves may have to be enriched with additional information.\nFor example, order messages that enter the Spring Integration messaging system have to look up the order's customer based on the provided customer number and then enrich the original payload with that information.\n\nSpring Integration 2.1 introduced the payload enricher.\nThe payload enricher defines an endpoint that passes a `Message` to the exposed request channel and then expects a reply message.\nThe reply message then becomes the root object for evaluation of expressions to enrich the target payload.\n\nThe payload enricher provides full XML namespace support through the `enricher` element.\nIn order to send request messages, the payload enricher has a `request-channel` attribute that lets you dispatch messages to a request channel.\n\nBasically, by defining the request channel, the payload enricher acts as a gateway, waiting for the message sent to the request channel to return.\nThe enricher then augments the message's payload with the data provided by the reply message.\n\nWhen sending messages to the request channel, you also have the option to send only a subset of the original payload by using the `request-payload-expression` attribute.\n\nThe enriching of payloads is configured through SpEL expressions, providing a maximum degree of flexibility.\nTherefore, you can not only enrich payloads with direct values from the reply channel's `Message`, but you can use SpEL expressions to extract a subset from that message or to apply additional inline transformations, letting you further manipulate the data.\n\nIf you need only to enrich payloads with static values, you need not provide the `request-channel` attribute.\n\nNOTE: Enrichers are a variant of transformers.\nIn many cases, you could use a payload enricher or a generic transformer implementation to add additional data to your message payloads.\nYou should familiarize yourself with all transformation-capable components that are provided by Spring Integration and carefully select the implementation that semantically fits your business case best.\n\n[[payload-enricher-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "Payload Enricher", "heading_level": 2, "file_order": 195, "section_index": 7, "content_hash": "79c5891dcf465bf2e725b83ff89a96faf0e0e992e85547ad9f2f679801bc847f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:3a18eba50fe162705f998049f74210a86762d9adf5a47e0577c26bc12c66ce57", "content": "The following example shows all available configuration options for the payload enricher:\n\n[source,xml]\n----\n<int:enricher request-channel=\"\" <1>\n auto-startup=\"true\" <2>\n id=\"\" <3>\n order=\"\" <4>\n output-channel=\"\" <5>\n request-payload-expression=\"\" <6>\n reply-channel=\"\" <7>\n error-channel=\"\" <8>\n send-timeout=\"\" <9>\n should-clone-payload=\"false\"> <10>\n <int:poller></int:poller> <11>\n <int:property name=\"\" expression=\"\" null-result-expression=\"'Could not determine the name'\"/> <12>\n <int:property name=\"\" value=\"23\" type=\"java.lang.Integer\" null-result-expression=\"'0'\"/>\n <int:header name=\"\" expression=\"\" null-result-expression=\"\"/> <13>\n <int:header name=\"\" value=\"\" overwrite=\"\" type=\"\" null-result-expression=\"\"/>\n</int:enricher>\n----\n\n<1> Channel to which a message is sent to get the data to use for enrichment.\nOptional.\n<2> Lifecycle attribute signaling whether this component should be started during the application context startup.\nDefaults to true.\nOptional.\n<3> ID of the underlying bean definition, which is either an `EventDrivenConsumer` or a `PollingConsumer`.\nOptional.\n<4> Specifies the order for invocation when this endpoint is connected as a subscriber to a channel.\nThis is particularly relevant when that channel is using a \"`failover`\" dispatching strategy.\nIt has no effect when this endpoint is itself a polling consumer for a channel with a queue.\nOptional.\n<5> Identifies the message channel where a message is sent after it is being processed by this endpoint.\nOptional.\n<6> By default, the original message's payload is used as payload that is sent to the `request-channel`.\nBy specifying a SpEL expression as the value for the `request-payload-expression` attribute, you can use a subset of the original payload, a header value, or any other resolvable SpEL expression as the basis for the payload that is sent to the request-channel.\nFor the expression evaluation, the full message is available as the 'root object'.\nFor instance, the following SpEL expressions (among others) are possible: `payload.something`, `headers.something`, `new java.util.Date()`, `'thing1' + 'thing2'`\n<7> Channel where a reply message is expected.\nThis is optional.\nTypically, the auto-generated temporary reply channel suffices.\nOptional.\n<8> The channel to which an `ErrorMessage` is sent if an `Exception` occurs downstream of the `request-channel`.\nThis enables you to return an alternative object to use for enrichment.\nIf it is not set, an `Exception` is thrown to the caller.\nOptional.\n\n<9> Maximum amount of time in milliseconds to wait when sending a message to the channel, if the channel might block.\nFor example, a queue channel can block until space is available, if its maximum capacity has been reached.\nInternally, the `send()` timeout is set on the `MessagingTemplate` and ultimately applied when invoking the send operation on the `MessageChannel`.\nBy default, the `send()` timeout is set to '30'.\nOptional.\n<10> Boolean value indicating whether any payload that implements `Cloneable` should be cloned prior to sending the message to the request channel for acquiring the enriching data.\nThe cloned version would be used as the target payload for the ultimate reply.\nThe default is `false`.\nOptional.\n<11> Lets you configure a message poller if this endpoint is a polling consumer.\nOptional.\n<12> Each `property` sub-element provides the name of a property (through the mandatory `name` attribute).\nThat property should be a settable on the target payload instance.\nExactly one of the `value` or `expression` attributes must be provided as well -- the former for a literal value to set and the latter for a SpEL expression to be evaluated.\nThe root object of the evaluation context is the message that was returned from the flow initiated by this enricher -- the input message if there is no request channel or the application context (using the `@<beanName>.<beanProperty>` SpEL syntax).\nStarting with version 4.0, when specifying a `value` attribute, you can also specify an optional `type` attribute.\nWhen the destination is a typed setter method, the framework coerces the value appropriately (as long as a `PropertyEditor`) exists to handle the conversion.\nIf, however, the target payload is a `Map`, the entry is populated with the value without conversion.\nThe `type` attribute lets you, for example, convert a `String` containing a number to an `Integer` value in the target payload.\nStarting with version 4.1, you can also specify an optional `null-result-expression` attribute.\nWhen the `enricher` returns null, it is evaluated, and the output of the evaluation is returned instead.\n<13> Each `header` sub-element provides the name of a message header (through the mandatory `name` attribute).\nExactly one of the `value` or `expression` attributes must also be provided -- the former for a literal value to set and the latter for a SpEL expression to be evaluated.\nThe root object of the evaluation context is the message that was returned from the flow initiated by this enricher -- the input message if there is no request channel or the application context (using the '@<beanName>.<beanProperty>' SpEL syntax).\nNote that, similarly to the `<header-enricher>`, the `<enricher>` element's `header` element has `type` and `overwrite` attributes.\nHowever, a key difference is that, with the `<enricher>`, the `overwrite` attribute is `true` by default, to be consistent with the `<enricher>` element's `<property>` sub-element.\nStarting with version 4.1, you can also specify an optional `null-result-expression` attribute.\nWhen the `enricher` returns null, it is evaluated, and the output of the evaluation is returned instead.\n\n[[payload-enricher-examples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "Configuration", "heading_level": 3, "file_order": 195, "section_index": 8, "content_hash": "3a18eba50fe162705f998049f74210a86762d9adf5a47e0577c26bc12c66ce57", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:fa5e3c69014393d2ddf0eba8abcf70ce4f3e07e5cc26c903678c4c3e21342f66", "content": "This section contains several examples of using a payload enricher in various situations.\n\nTIP: The code samples shown here are part of the Spring Integration Samples project.\nSee xref:samples.adoc#samples-impl[Spring Integration Samples].\n\nIn the following example, a `User` object is passed as the payload of the `Message`:\n\n[source,xml]\n----\n<int:enricher id=\"findUserEnricher\"\n input-channel=\"findUserEnricherChannel\"\n request-channel=\"findUserServiceChannel\">\n <int:property name=\"email\" expression=\"payload.email\"/>\n <int:property name=\"password\" expression=\"payload.password\"/>\n</int:enricher>\n----\n\nThe `User` has several properties, but only the `username` is set initially.\nThe enricher's `request-channel` attribute is configured to pass the `User` to the `findUserServiceChannel`.\n\nThrough the implicitly set `reply-channel`, a `User` object is returned and, by using the `property` sub-element, properties from the reply are extracted and used to enrich the original payload.\n\n[[how-do-i-pass-only-a-subset-of-data-to-the-request-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "Examples", "heading_level": 3, "file_order": 195, "section_index": 9, "content_hash": "fa5e3c69014393d2ddf0eba8abcf70ce4f3e07e5cc26c903678c4c3e21342f66", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:be287c11234bb9950555d97feb3652b6393ec73dd6a19525b19c0fa00324d7bd", "content": "When using a `request-payload-expression` attribute, a single property of the payload instead of the full message can be passed on to the request channel.\nIn the following example, the username property is passed on to the request channel:\n\n[source,xml]\n----\n<int:enricher id=\"findUserByUsernameEnricher\"\n input-channel=\"findUserByUsernameEnricherChannel\"\n request-channel=\"findUserByUsernameServiceChannel\"\n request-payload-expression=\"payload.username\">\n <int:property name=\"email\" expression=\"payload.email\"/>\n <int:property name=\"password\" expression=\"payload.password\"/>\n</int:enricher>\n----\n\nKeep in mind that, although only the username is passed, the resulting message to the request channel contains the full set of `MessageHeaders`.\n\n[[how-can-i-enrich-payloads-that-consist-of-collection-data]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "How Do I Pass Only a Subset of Data to the Request Channel?", "heading_level": 3, "file_order": 195, "section_index": 10, "content_hash": "be287c11234bb9950555d97feb3652b6393ec73dd6a19525b19c0fa00324d7bd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:c3293c6f1e6bab8d5d8773141a5ef1ca13a11b5db3ced7eb2d23ee44e8cca6c0", "content": "In the following example, instead of a `User` object, a `Map` is passed in:\n\n[source,xml]\n----\n<int:enricher id=\"findUserWithMapEnricher\"\n input-channel=\"findUserWithMapEnricherChannel\"\n request-channel=\"findUserByUsernameServiceChannel\"\n request-payload-expression=\"payload.username\">\n <int:property name=\"user\" expression=\"payload\"/>\n</int:enricher>\n----\n\nThe `Map` contains the username under the `username` map key.\nOnly the `username` is passed on to the request channel.\nThe reply contains a full `User` object, which is ultimately added to the `Map` under the `user` key.\n\n[[how-can-i-enrich-payloads-with-static-information-without-using-a-request-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "How Can I Enrich Payloads that Consist of Collection Data?", "heading_level": 4, "file_order": 195, "section_index": 11, "content_hash": "c3293c6f1e6bab8d5d8773141a5ef1ca13a11b5db3ced7eb2d23ee44e8cca6c0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:836db6e1087d93681493c486ae0ac6a910850cf5aa62c2f03f30725c10cf68c6", "content": "The following example does not use a request channel at all but solely enriches the message's payload with static values:\n\n[source,xml]\n----\n<int:enricher id=\"userEnricher\"\n input-channel=\"input\">\n <int:property name=\"user.updateDate\" expression=\"new java.util.Date()\"/>\n <int:property name=\"user.firstName\" value=\"William\"/>\n <int:property name=\"user.lastName\" value=\"Shakespeare\"/>\n <int:property name=\"user.age\" value=\"42\"/>\n</int:enricher>\n----\n\nNote that the word, 'static', is used loosely here.\nYou can still use SpEL expressions for setting those values.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/content-enrichment.adoc", "title": "content-enrichment", "heading": "How Can I Enrich Payloads with Static Information without Using a Request Channel?", "heading_level": 3, "file_order": 195, "section_index": 12, "content_hash": "836db6e1087d93681493c486ae0ac6a910850cf5aa62c2f03f30725c10cf68c6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/content-enrichment.adoc"}}
{"id": "sha256:e4a56e67c82b4e4ed28946f59bd0f85c3e4e10dacdeee6da42f686a5fec776cd", "content": "[[control-bus]]\n\nAs described in the https://www.enterpriseintegrationpatterns.com/[_Enterprise Integration Patterns_] (EIP) book, the idea behind the control bus is that the same messaging system can be used for monitoring and managing the components within the framework as is used for \"`application-level`\" messaging.\nIn Spring Integration, we build upon the adapters described above so that you can send messages as a means of invoking exposed operations.\n\nIMPORTANT: Since Control Bus is powerful enough to make changes into the system state, it is recommended to secure its message reception (see `SecurityContextChannelInterceptor`) and expose a Control Bus management (message source) only into DMZ.\n\nThe following example shows how to configure a control bus with XML:\n\n[source,xml]\n----\n<int:control-bus input-channel=\"operationChannel\"/>\n----\n\nThe control bus has an input channel that can be accessed for invoking operations on the beans in the application context.\nIt also has all the common properties of a service activating endpoint.\nFor example, you can specify an output channel if the result of the operation has a return value that you want to send on to a downstream channel.\n\nThe control bus runs messages on the input channel as a managed operation in a simple string format like `beanName.methodName`.\nThe arguments for the target method parameters must be supplied as a list in the `IntegrationMessageHeaderAccessor.CONTROL_BUS_ARGUMENTS` header.\nThe bean and the method to call is resolved from the `ControlBusCommandRegistry` infrastructure bean.\nBy default, the `ControlBusCommandRegistry` registers commands on demand: its `eagerInitialization` flag can be turned on via `@EnableIntegrationManagement(loadControlBusCommands = \"true\")`.\n\nThe functionality of Control Bus is similar to JMX, therefore, method eligibility for command must honor these requirements:\n\n- The method that has been annotated with `@ManagedAttribute` or `@ManagedOperation`;\n- Spring's `Lifecycle` interface (and its `Pausable` extension since version 5.2);\n- The methods that are used to configure several of Spring's `TaskExecutor` and `TaskScheduler` implementations.\n\nThe simplest way to ensure that your own methods are available to the control bus is to use the `@ManagedAttribute` or `@ManagedOperation` annotations.\nSince those annotations are also used for exposing methods to a JMX MBean registry, they offer a convenient by-product: often, the same types of operations you want to expose to the control bus are reasonable for exposing through JMX).\nSee more information in the `ControlBusCommandRegistry` and `ControlBusMethodFilter` Javadocs.\n\nTo execute a method on a Spring Bean, a client could send a message to the operation channel as follows:\n\n[source,java]\n----\nMessage<?> operation = MessageBuilder.withPayload(\"myServiceBean.shutdown\").build();\noperationChannel.send(operation);\n----\n\nIf target method to call has arguments (e.g. `ThreadPoolTaskExecutor.setMaxPoolSize(int maxPoolSize)`), those values has to be provided as `IntegrationMessageHeaderAccessor.CONTROL_BUS_ARGUMENTS` header:\n\n[source,java]\n----\nMessage<?> operation =\n MessageBuilder.withPayload(\"myTaskExecutor.setMaxPoolSize\")\n .setHeader(IntegrationMessageHeaderAccessor.CONTROL_BUS_ARGUMENTS, List.of(10))\n .build();\noperationChannel.send(operation);\n----\n\nYou can think about these commands as `PreparedStatement` instances in JDBC with parameter binding.\nThe types of arguments must match types of method parameters.\nThey are used as additional criteria to select a method to call according to Java method overloading feature.\nFor example the component:\n\n[source,java]\n----\n@ManagedResource\nclass TestManagementComponent {\n\n @ManagedOperation\n public void operation() {\n\n }\n\n @ManagedOperation(description = \"The overloaded operation with int argument\")\n public void operation(int input) {\n\n }\n\n @ManagedOperation(description = \"The overloaded operation with two arguments\")\n public void operation(int input1, String input2) {\n\n }\n\n @ManagedOperation\n public int operation2() {\n return 123;\n }\n\n}\n----\n\nwill expose 3 commands with `operation` name.\nWhen we call `testManagementComponent.operation` command, we should choose a proper list of values for the `IntegrationMessageHeaderAccessor.CONTROL_BUS_ARGUMENTS` header to let the `ControlBusCommandRegistry` to filter out the target method on the bean.\n\nWith Java annotations, you can configure the control bus as follows:\n\n[source,java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"operationChannel\")\npublic ControlBusFactoryBean controlBus() {\n return new ControlBusFactoryBean();\n}\n----\n\nSimilarly, you can configure Java DSL flow definitions as follows:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow controlBusFlow() {\n return IntegrationFlow.from(\"controlBus\")\n .controlBus()\n .get();\n}\n----\n\nIf you prefer to use lambdas with automatic `DirectChannel` creation, you can create a control bus as follows:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow controlBus() {\n return IntegrationFlowDefinition::controlBus;\n}\n----\n\nIn this case, the channel is named `controlBus.input`.\n\nAlso, see xref:http/control-bus-controller.adoc[Control Bus REST Controller] for exposing Control Bus management over HTTP.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/control-bus.adoc", "title": "control-bus", "heading": "control-bus", "heading_level": 1, "file_order": 196, "section_index": 0, "content_hash": "e4a56e67c82b4e4ed28946f59bd0f85c3e4e10dacdeee6da42f686a5fec776cd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/control-bus.adoc"}}
{"id": "sha256:731d268bb8cf3507882a8056c9dae0c0d3e9416da9cb7a36978ad36f74deb1b2", "content": "[[spring-integration-core-messaging]]\n\n[[spring-integration-core-msg]]\nThis section covers all aspects of the core messaging API in Spring Integration.\nIt covers messages, message channels, and message endpoints.\nIt also covers many of the enterprise integration patterns, such as filter, router, transformer, service activator, splitter, and aggregator.\n\nThis section also contains material about system management, including the control bus and message history support.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/core.adoc", "title": "core", "heading": "core", "heading_level": 1, "file_order": 197, "section_index": 0, "content_hash": "731d268bb8cf3507882a8056c9dae0c0d3e9416da9cb7a36978ad36f74deb1b2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/core.adoc"}}
{"id": "sha256:cffe91a70e66bed09cc16afb8058f6cd5286e6d01dbd9bc309743a618abc1138", "content": "[[debezium]]\n\nhttps://debezium.io/documentation/reference/development/engine.html[Debezium Engine], Change Data Capture (CDC) inbound channel adapter.\nThe `DebeziumMessageProducer` allows capturing database change events, converting them into messages and streaming later to the outbound channels.\n\nYou need to include the spring integration Debezium dependency to your project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-debezium</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-debezium:{project-version}\"\n----\n======\n\nYou also need to include a https://debezium.io/documentation/reference/connectors/index.html[debezium connector] dependency for your input Database.\nFor example, to use Debezium with PostgreSQL, you will need the postgres debezium connector:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, role=\"primary\"]\n----\n<dependency>\n <groupId>io.debezium</groupId>\n <artifactId>debezium-connector-postgres</artifactId>\n <version>${debezium-version}</version>\n</dependency>\n\n----\n\nGradle::\n+\n[source, groovy, role=\"secondary\"]\n----\nimplementation \"io.debezium:debezium-connector-postgres:{debezium-version}\"\n----\n======\n\n[NOTE]\n====\nReplace the `debezium-version` with the version compatible with the `spring-integration-debezium` version being used.\n====\n\n[[debezium-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/debezium.adoc", "title": "debezium", "heading": "debezium", "heading_level": 1, "file_order": 198, "section_index": 0, "content_hash": "cffe91a70e66bed09cc16afb8058f6cd5286e6d01dbd9bc309743a618abc1138", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/debezium.adoc"}}
{"id": "sha256:1a45007e91b021bb2af78bb86b2350c4d103ba52ff07f031a064abdcb6e9b9df", "content": "The Debezium adapter expects a pre-configured `DebeziumEngine.Builder<ChangeEvent<byte[], byte[]>>` instance.\n\n[TIP]\n====\nThe https://github.com/spring-cloud/spring-functions-catalog/tree/main/supplier/spring-debezium-supplier[debezium-supplier] provides an out of the box `DebeziumEngine.Builder` Spring Boot auto-configuration with a handy https://github.com/spring-cloud/spring-functions-catalog/blob/main/common/spring-debezium-autoconfigure/src/main/java/org/springframework/cloud/fn/common/debezium/DebeziumProperties.java[DebeziumProperties] configuration abstraction.\n====\n\n[TIP]\n====\nThe xref:debezium.adoc#debezium-java-dsl[Debezium Java DSL] can create a `DebeziumMessageProducer` instance from a provided `DebeziumEngine.Builder`, as well as from a plain Debezium configuration (e.g. `java.util.Properties`).\nLater can be handy for some common use-cases with opinionated configuration and serialization formats.\n====\n\nAdditionally, the `DebeziumMessageProducer` can be tuned with the following configuration properties:\n\n- `contentType` - allows handling for `JSON` (default), `AVRO` and `PROTOBUF` message contents.\nThe contentType `must` be aligned with the `SerializationFormat` configured for the provided `DebeziumEngine.Builder`.\n- `enableBatch` - when set to `false` (default), the debezium adapter would send new `Message` for every `ChangeEvent` data change event received from the source database.\nIf set to `true` then the adapter sends downstream a single `Message` for each batch of `ChangeEvent` received from the Debezium engine.\nSuch a payload is not serializable and would require a custom serialization/deserialization implementation.\n- `enableEmptyPayload` - Enables support for tombstone (aka delete) messages.\nOn a database row delete, Debezium can send a tombstone change event that has the same key as the deleted row and a value of `Optional.empty`.\nDefaults to `false`.\n- `headerMapper` - custom `HeaderMapper` implementation that allows for selecting and converting the `ChangeEvent` headers into `Message` headers.\nThe default `DefaultDebeziumHeaderMapper` implementation provides a setter for `setHeaderNamesToMap`.\nBy default, all headers are mapped.\n- `taskExecutor` - Set a custom `TaskExecutor` for the Debezium engine.\n\nThe following code snippets demonstrate various configurations for this channel adapter:\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/debezium.adoc", "title": "debezium", "heading": "Inbound Debezium Channel Adapter", "heading_level": 2, "file_order": 198, "section_index": 1, "content_hash": "1a45007e91b021bb2af78bb86b2350c4d103ba52ff07f031a064abdcb6e9b9df", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/debezium.adoc"}}
{"id": "sha256:20f93baafa9c20690d5e903018e6156c008af43838344cfaf2b8d69ef09dd2fd", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with Java configuration:\n\n[source, java]\n----\n@SpringBootApplication\npublic class DebeziumJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(DebeziumJavaApplication.class)\n .web(WebApplicationType.NONE)\n .run(args);\n }\n\n @Bean\n public MessageChannel debeziumInputChannel() {\n return new DirectChannel();\n }\n\n @Bean\n public MessageProducer debeziumMessageProducer(\n DebeziumEngine.Builder<ChangeEvent<byte[], byte[]>> debeziumEngineBuilder,\n MessageChannel debeziumInputChannel) {\n\n DebeziumMessageProducer debeziumMessageProducer =\n new DebeziumMessageProducer(debeziumEngineBuilder);\n debeziumMessageProducer.setOutputChannel(debeziumInputChannel);\n return debeziumMessageProducer;\n }\n\n @ServiceActivator(inputChannel = \"debeziumInputChannel\")\n public void handler(Message<?> message) {\n\n Object destination = message.getHeaders().get(DebeziumHeaders.DESTINATION); # <1>\n\n String key = new String((byte[]) message.getHeaders().get(DebeziumHeaders.KEY)); # <2>\n\n String payload = new String((byte[]) message.getPayload()); # <3>\n\n System.out.println(\"KEY: \" + key + \", DESTINATION: \" + destination + \", PAYLOAD: \" + payload);\n }\n\n}\n----\n<1> A name of the logical destination for which the event is intended.\n Usually the destination is composed of the `topic.prefix` configuration option, the database name and the table name. For example: `my-topic.inventory.orders`.\n<2> Contains the schema for the changed table's key and the changed row's actual key.\n Both the key schema and its corresponding key payload contain a field for each column in the changed table's `PRIMARY KEY` (or unique constraint) at the time the connector created the event.\n<3> Like the key, the payload has a schema section and a payload value section.\n The schema section contains the schema that describes the Envelope structure of the payload value section, including its nested fields.\n Change events for operations that create, update or delete data all have a value payload with an envelope structure.\n\n[TIP]\n====\nThe `key.converter.schemas.enable=false` and/or `value.converter.schemas.enable=false` permit disabling the in-message schema content for key or payload respectively.\n====\n\nSimilarly, we can configure the `DebeziumMessageProducer` to process the incoming change events in batches:\n\n[source, java]\n----\n@Bean\npublic MessageProducer debeziumMessageProducer(\n DebeziumEngine.Builder<ChangeEvent<byte[], byte[]>> debeziumEngineBuilder,\n MessageChannel debeziumInputChannel) {\n\n DebeziumMessageProducer debeziumMessageProducer = new DebeziumMessageProducer(debeziumEngineBuilder);\n\tdebeziumMessageProducer.setEnableBatch(true);\n debeziumMessageProducer.setOutputChannel(debeziumInputChannel);\n return debeziumMessageProducer;\n}\n\n@ServiceActivator(inputChannel = \"debeziumInputChannel\")\npublic void handler(List<ChangeEvent<Object, Object>> payload) {\n System.out.println(payload);\n}\n----\n\n[[debezium-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/debezium.adoc", "title": "debezium", "heading": "Configuring with Java Configuration", "heading_level": 3, "file_order": 198, "section_index": 2, "content_hash": "20f93baafa9c20690d5e903018e6156c008af43838344cfaf2b8d69ef09dd2fd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/debezium.adoc"}}
{"id": "sha256:31bf02f449d5fe2e176741a9351d6c7dccec8a7b72f3a8b99ab7f9a4625f4154", "content": "The `spring-integration-debezium` provides a convenient Java DSL fluent API via the `Debezium` factory and the `DebeziumMessageProducerSpec` implementations.\n\nThe Inbound Channel Adapter for Debezium Java DSL is:\n[source, java]\n----\n DebeziumEngine.Builder<ChangeEvent<byte[], byte[]>> debeziumEngineBuilder = ...\n IntegrationFlow.from(\n Debezium.inboundChannelAdapter(debeziumEngineBuilder)\n .headerNames(\"special*\")\n .contentType(\"application/json\")\n .enableBatch(false))\n .handle(m -> System.out.println(new String((byte[]) m.getPayload())))\n----\n\nOr create an `DebeziumMessageProducerSpec` instance from native debezium configuration properties and default to `JSON` serialization formats.\n\n[source, java]\n----\n Properties debeziumConfig = ...\n IntegrationFlow\n .from(Debezium.inboundChannelAdapter(debeziumConfig))\n .handle(m -> System.out.println(new String((byte[]) m.getPayload())))\n----\n\nThe following Spring Boot application provides an example of configuring the inbound adapter with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class DebeziumJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(DebeziumJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public IntegrationFlow debeziumInbound(\n DebeziumEngine.Builder<ChangeEvent<byte[], byte[]>> debeziumEngineBuilder) {\n\n return IntegrationFlow\n .from(Debezium\n .inboundChannelAdapter(debeziumEngineBuilder)\n .headerNames(\"special*\")\n .contentType(\"application/json\")\n .enableBatch(false))\n .handle(m -> System.out.println(new String((byte[]) m.getPayload())))\n .get();\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/debezium.adoc", "title": "debezium", "heading": "Debezium Java DSL Support", "heading_level": 2, "file_order": 198, "section_index": 3, "content_hash": "31bf02f449d5fe2e176741a9351d6c7dccec8a7b72f3a8b99ab7f9a4625f4154", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/debezium.adoc"}}
{"id": "sha256:7f6c8b743c8d4cf6be8f13eb8c1df60ae1119e177758edffed71978b1531706b", "content": "[[delayer]]\n\nA delayer is a simple endpoint that lets a message flow be delayed by a certain interval.\nWhen a message is delayed, the original sender does not block.\nInstead, the delayed messages are scheduled with an instance of `org.springframework.scheduling.TaskScheduler` to be sent to the output channel after the delay has passed.\nThis approach is scalable even for rather long delays, since it does not result in a large number of blocked sender threads.\nOn the contrary, in the typical case, a thread pool is used for the actual execution of releasing the messages.\nThis section contains several examples of configuring a delayer.\n\n[[delayer-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/delayer.adoc", "title": "delayer", "heading": "delayer", "heading_level": 1, "file_order": 199, "section_index": 0, "content_hash": "7f6c8b743c8d4cf6be8f13eb8c1df60ae1119e177758edffed71978b1531706b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/delayer.adoc"}}
{"id": "sha256:fee0ee99b9fef81b23cfa44d7e72e1a64a73a29003d0c1b66985830b2c0b0e7f", "content": "The `<delayer>` element is used to delay the message flow between two message channels.\nAs with the other endpoints, you can provide the 'input-channel' and 'output-channel' attributes, but the delayer also has 'default-delay' and 'expression' attributes (and the 'expression' element) that determines the number of milliseconds by which each message should be delayed.\nThe following example delays all messages by three seconds:\n\n[source,xml]\n----\n<int:delayer id=\"delayer\" input-channel=\"input\"\n default-delay=\"3000\" output-channel=\"output\"/>\n----\n\nIf you need to determine the delay for each message, you can also provide the SpEL expression by using the 'expression' attribute, as the following expression shows:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow flow() {\n return IntegrationFlow.from(\"input\")\n .delay(d -> d\n .messageGroupId(\"delayer.messageGroupId\")\n .defaultDelay(3_000L)\n .delayExpression(\"headers['delay']\"))\n .channel(\"output\")\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun flow() =\n integrationFlow(\"input\") {\n delay {\n messageGroupId(\"delayer.messageGroupId\")\n defaultDelay(3000L)\n delayExpression(\"headers['delay']\")\n }\n channel(\"output\")\n }\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@ServiceActivator(inputChannel = \"input\")\n@Bean\npublic DelayHandler delayer() {\n DelayHandler handler = new DelayHandler(\"delayer.messageGroupId\");\n handler.setDefaultDelay(3_000L);\n handler.setDelayExpressionString(\"headers['delay']\");\n handler.setOutputChannelName(\"output\");\n return handler;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:delayer id=\"delayer\" input-channel=\"input\" output-channel=\"output\"\n default-delay=\"3000\" expression=\"headers['delay']\"/>\n----\n======\n\nIn the preceding example, the three-second delay applies only when the expression evaluates to null for a given inbound message.\nIf you want to apply a delay only to messages that have a valid result of the expression evaluation, you can use a 'default-delay' of `0` (the default).\nFor any message that has a delay of `0` (or less), the message is sent immediately, on the calling thread.\n\nNOTE: The XML parser uses a message group ID of `<beanName>.messageGroupId`.\n\nTIP: The delay handler supports expression evaluation results that represent an interval in milliseconds (any `Object` whose `toString()` method produces a value that can be parsed into a `Long`) as well as `java.util.Date` instances representing an absolute time.\nIn the first case, the milliseconds are counted from the current time, for example, a value of `5000` would delay the message for at least five seconds from the time it is received by the delayer.\nWith a `Date` instance, the message is not released until the time represented by that `Date` object.\nA value that equates to a non-positive delay or a Date in the past results in no delay.\nInstead, it is sent directly to the output channel on the original sender's thread.\nIf the expression evaluation result is not a `Date` and cannot be parsed as a `Long`, the default delay (if any -- the default is `0`) is applied.\n\nIMPORTANT: The expression evaluation may throw an evaluation exception for various reasons, including an invalid expression or other conditions.\nBy default, such exceptions are ignored (though logged at the DEBUG level), and the delayer falls back to the default delay (if any).\nYou can modify this behavior by setting the `ignore-expression-failures` attribute.\nBy default, this attribute is set to `true` and the delayer behavior is as described earlier.\nHowever, if you wish to not ignore expression evaluation exceptions and throw them to the delayer's caller, set the `ignore-expression-failures` attribute to `false`.\n\n[TIP]\n=====\nIn the preceding example, the delay expression is specified as `headers['delay']`.\nThis is the SpEL `Indexer` syntax to access a `Map` element (`MessageHeaders` implements `Map`).\nIt invokes: `headers.get(\"delay\")`.\nFor simple map element names (that do not contain '.') you can also use the SpEL \"`dot accessor`\" syntax, where the header expression shown earlier can be specified as `headers.delay`.\nHowever, different results are achieved if the header is missing.\nIn the first case, the expression evaluates to `null`.\nThe second results in something similar to the following:\n\n[source,java]\n----\n org.springframework.expression.spel.SpelEvaluationException: EL1008E:(pos 8):\n Field or property 'delay' cannot be found on object of type 'org.springframework.messaging.MessageHeaders'\n----\n\nConsequently, if there is a possibility of the header being omitted, and you want to fall back to the default delay, it is generally more efficient (and recommended) using the indexer syntax instead of dot property accessor syntax, because detecting the null is faster than catching an exception.\n=====\n\nThe delayer delegates to an instance of Spring's `TaskScheduler` abstraction.\nThe default scheduler used by the delayer is the `ThreadPoolTaskScheduler` instance provided by Spring Integration on startup.\nSee xref:configuration/namespace-taskscheduler.adoc[Configuring the Task Scheduler].\nIf you want to delegate to a different scheduler, you can provide a reference through the delayer element's 'scheduler' attribute, as the following example shows:\n\n[source,xml]\n----\n<int:delayer id=\"delayer\" input-channel=\"input\" output-channel=\"output\"\n expression=\"headers.delay\"\n scheduler=\"exampleTaskScheduler\"/>\n\n<task:scheduler id=\"exampleTaskScheduler\" pool-size=\"3\"/>\n----\n\nTIP: If you configure an external `ThreadPoolTaskScheduler`, you can set `waitForTasksToCompleteOnShutdown = true` on this property.\nIt allows successful completion of 'delay' tasks that are already in the execution state (releasing the message) when the application is shutdown.\nBefore Spring Integration 2.2, this property was available on the `<delayer>` element, because `DelayHandler` could create its own scheduler on the background.\nSince 2.2, the delayer requires an external scheduler instance and `waitForTasksToCompleteOnShutdown` was deleted.\nYou should use the scheduler's own configuration.\n\nTIP: `ThreadPoolTaskScheduler` has a property `errorHandler`, which can be injected with some implementation of `org.springframework.util.ErrorHandler`.\nThis handler allows processing an `Exception` from the thread of the scheduled task sending the delayed message.\nBy default, it uses an `org.springframework.scheduling.support.TaskUtils$LoggingErrorHandler`, and you can see a stack trace in the logs.\nYou might want to consider using an `org.springframework.integration.channel.MessagePublishingErrorHandler`, which sends an `ErrorMessage` into an `error-channel`, either from the failed message's header or into the default `error-channel`.\nThis error handling is performed after a transaction rolls back (if present).\nSee xref:delayer.adoc#delayer-release-failures[Release Failures].\n\n[[delayer-message-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/delayer.adoc", "title": "delayer", "heading": "Configuring a Delayer", "heading_level": 2, "file_order": 199, "section_index": 1, "content_hash": "fee0ee99b9fef81b23cfa44d7e72e1a64a73a29003d0c1b66985830b2c0b0e7f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/delayer.adoc"}}
{"id": "sha256:5aeaad5de9f21c54645bbe2b87d3f6629e0c8c31f70ee25ad18d581649c0fc33", "content": "The `DelayHandler` persists delayed messages into the message group in the provided `MessageStore`.\n(The 'groupId' is based on the required 'id' attribute of the `<delayer>` element.\nSee also `DelayHandler.setMessageGroupId(String)`.)\nA delayed message is removed from the `MessageStore` by the scheduled task immediately before the `DelayHandler` sends the message to the `output-channel`.\nIf the provided `MessageStore` is persistent (such as `JdbcMessageStore`), it provides the ability to not lose messages on the application shutdown.\nAfter application startup, the `DelayHandler` reads messages from its message group in the `MessageStore` and reschedules them with a delay based on the original arrival time of the message (if the delay is numeric).\nFor messages where the delay header was a `Date`, that `Date` is used when rescheduling.\nIf a delayed message remains in the `MessageStore` more than its 'delay', it is sent immediately after startup.\nThe `messageGroupId` is required and cannot rely on a `DelayHandler` bean name which can be generated.\nThat way, after application restart, a `DelayHandler` may get a new generated bean name.\nTherefore, delayed messages might be lost from rescheduling since their group is not managed by the application anymore.\n\nThe `<delayer>` can be enriched with either of two mutually exclusive elements: `<transactional>` and `<advice-chain>`.\nThe `List` of these AOP advices is applied to the proxied internal `DelayHandler.ReleaseMessageHandler`, which has the responsibility to release the message, after the delay, on a `Thread` of the scheduled task.\nIt might be used, for example, when the downstream message flow throws an exception and the transaction of the `ReleaseMessageHandler` is rolled back.\nIn this case, the delayed message remains in the persistent `MessageStore`.\nYou can use any custom `org.aopalliance.aop.Advice` implementation within the `<advice-chain>`.\nThe `<transactional>` element defines a simple advice chain that has only the transactional advice.\nThe following example shows an `advice-chain` within a `<delayer>`:\n\n[source,xml]\n----\n<int:delayer id=\"delayer\" input-channel=\"input\" output-channel=\"output\"\n expression=\"headers.delay\"\n message-store=\"jdbcMessageStore\">\n <int:advice-chain>\n <beans:ref bean=\"customAdviceBean\"/>\n <tx:advice>\n <tx:attributes>\n <tx:method name=\"*\" read-only=\"true\"/>\n </tx:attributes>\n </tx:advice>\n </int:advice-chain>\n</int:delayer>\n----\n\nThe `DelayHandler` can be exported as a JMX `MBean` with managed operations (`getDelayedMessageCount` and `reschedulePersistedMessages`), which allows the rescheduling of delayed persisted messages at runtime -- for example, if the `TaskScheduler` has previously been stopped.\nThese operations can be invoked through a `Control Bus` command, as the following example shows:\n\n[source,java]\n----\nMessage<String> delayerReschedulingMessage =\n MessageBuilder.withPayload(\"'delayer.handler'.reschedulePersistedMessages\").build();\ncontrolBusChannel.send(delayerReschedulingMessage);\n----\n\nNOTE: For more information regarding the message store, JMX, and the control bus, see xref:system-management.adoc[System Management].\n\nStarting with version 5.3.7, if a transaction is active when a message is stored into a `MessageStore`, the release task is scheduled in a `TransactionSynchronization.afterCommit()` callback.\nThis is necessary to prevent a race condition, where the scheduled release could run before the transaction has committed, and the message is not found.\nIn this case, the message will be released after the delay, or after the transaction commits, whichever is later.\n\n[[delayer-release-failures]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/delayer.adoc", "title": "delayer", "heading": "Delayer and a Message Store", "heading_level": 2, "file_order": 199, "section_index": 2, "content_hash": "5aeaad5de9f21c54645bbe2b87d3f6629e0c8c31f70ee25ad18d581649c0fc33", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/delayer.adoc"}}
{"id": "sha256:38c7dc44ea37f8fed456758d2c8d5fb451769b53294606b0075b00a5e1ef8534", "content": "Starting with version 5.0.8, there are two new properties on the delayer:\n\n- `maxAttempts` (default 5)\n- `retryDelay` (default 1 second)\n\nWhen a message is released, if the downstream flow fails, the release will be attempted after the `retryDelay`.\nIf the `maxAttempts` is reached, the message is discarded (unless the release is transactional, in which case the message will remain in the store, but will no longer be scheduled for release, until the application is restarted, or the `reschedulePersistedMessages()` method is invoked, as discussed above).\n\nIn addition, you can configure a `delayedMessageErrorChannel`; when a release fails, an `ErrorMessage` is sent to that channel with the exception as the payload and has the `originalMessage` property.\nThe `ErrorMessage` contains a header `IntegrationMessageHeaderAccessor.DELIVERY_ATTEMPT` containing the current count.\n\nIf the error flow consumes the error message and exits normally, no further action is taken; if the release is transactional, the transaction will commit and the message deleted from the store.\nIf the error flow throws an exception, the release will be retried up to `maxAttempts` as discussed above.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/delayer.adoc", "title": "delayer", "heading": "Release Failures", "heading_level": 2, "file_order": 199, "section_index": 3, "content_hash": "38c7dc44ea37f8fed456758d2c8d5fb451769b53294606b0075b00a5e1ef8534", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/delayer.adoc"}}
{"id": "sha256:27477eb285b8fa30ab5c432510dffb7e7572fbd41edc9d809d7433499078433e", "content": "[[distributed-locks]]\n\nIn many situations the action against some context (or even single message) has to be performed in an exclusive manner.\nOne example is an aggregator component where we have to check the message group state for the current message to determine whether we can release the group or just add that message for future consideration.\nFor this purpose Java provides an API with `java.util.concurrent.locks.Lock` implementations.\nHowever, the problem becomes more complex when an application is distributed and/or run in the cluster.\nThe locking in this case is challenging and requires some shared state and its specific approach to achieve the exclusivity requirement.\n\nSpring Integration provides a `LockRegistry` abstraction with an in-memory `DefaultLockRegistry` implementation based on the `ReentrantLock` API.\nThe `obtain(Object)` method of the `LockRegistry` requires a `lock key` for specific context.\nFor example, an aggregator uses a `correlationKey` to lock operations around its group.\nThis way different locks can be used concurrently.\nThis `obtain(Object)` method returns a `java.util.concurrent.locks.Lock` instance (depending on the `LockRegistry` implementation), therefore, the rest of the logic is the same as standard Java Concurrency algorithm.\n\nStarting with version 6.2, the `LockRegistry` provides an `executeLocked()` API (`default` methods in this interface) to perform some task while locked.\nThe behavior of this API is similar to well-known `JdbcTemplate`, `JmsTemplate` or `RestTemplate`.\nThe following example demonstrates the usage of this API:\n\n[source,java]\n----\nLockRegistry registry = new DefaultLockRegistry();\n...\nregistry.executeLocked(\"someLockKey\", () -> someExclusiveResourceCall());\n----\n\nThe method rethrows an exception from the task call, throws an `InterruptedException` if `Lock` is interrupted.\nIn addition, a variant with `Duration` throws a `java.util.concurrent.TimeoutException` when `lock.tryLock()` returns `false`.\n\nSpring Integration provides these `LockRegistry` implementations for distributed locks:\n\n* xref:jdbc/lock-registry.adoc[JDBC]\n* xref:redis.adoc#redis-lock-registry[Redis]\n* xref:zookeeper.adoc#zk-lock-registry[Zookeeper]\n\nThe https://awspring.io[Spring Cloud AWS] also provides a `DynamoDbLockRegistry`.\n\nStarting with version 7.0, the `DistributedLock` interface has been introduced, providing new methods, `lock(Duration ttl`) and `tryLock(long time, TimeUnit unit, Duration ttl)`, to acquire a lock with a custom time-to-live (TTL).\nBoth `JdbcLock` and `RedisLock` implement `DistributedLock` interface to support the feature of customized time-to-live.\nThe `LockRegistry<L extends Lock>` is now a generic interface for types that extend `Lock`.\nThe `RenewableLockRegistry` interface now provides new `renewLock(Object lockKey, Duration ttl)` method, allowing you to renew the lock with a custom time-to-live value.\nBoth `JdbcLockRegistry` and `RedisLockRegistry` implement `LockRegistry` and `RenewableLockRegistry` interfaces with the type parameter `DistributedLock`.\n\nBelow is an example of how to obtain a `DistributedLock` from a registry and acquire it with a specific time-to-live value:\n[source,java]\n----\nDistributedLock lock = registry.obtain(\"foo\");\nDuration timeToLive = Duration.ofMillis(500);\n\nif(lock.tryLock(100, TimeUnit.MILLISECONDS, timeToLive)){\n try {\n // do something\n } catch (Exception e) {\n // handle exception\n } finally{\n lock. unlock();\n }\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/distributed-locks.adoc", "title": "distributed-locks", "heading": "distributed-locks", "heading_level": 1, "file_order": 200, "section_index": 0, "content_hash": "27477eb285b8fa30ab5c432510dffb7e7572fbd41edc9d809d7433499078433e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/distributed-locks.adoc"}}
{"id": "sha256:79d08a66465e1034b381055c6a82aa01a8d458f8d521e12030faaf86a20939f4", "content": "[[java-dsl]]\n\nThe Spring Integration Java configuration and DSL provides a set of convenient builders and a fluent API that lets you configure Spring Integration message flows from Spring `@Configuration` classes.\n\n(See also xref:kotlin-dsl.adoc[Kotlin DSL].)\n\n(See also xref:groovy-dsl.adoc[Groovy DSL].)\n\nThe Java DSL for Spring Integration is essentially a facade for Spring Integration.\nThe DSL provides a simple way to embed Spring Integration Message Flows into your application by using the fluent `Builder` pattern together with existing Java configuration from Spring Framework and Spring Integration.\nWe also use and support lambdas (available with Java 8) to further simplify Java configuration.\n\nThe https://github.com/spring-projects/spring-integration-samples/tree/main/dsl/cafe-dsl[caf] offers a good example of using the DSL.\n\nThe DSL is presented by the `IntegrationFlow` fluent API (see `IntegrationFlowBuilder`).\nThis produces the `IntegrationFlow` component, which should be registered as a Spring bean (by using the `@Bean` annotation).\nThe builder pattern is used to express arbitrarily complex structures as a hierarchy of methods that can accept lambdas as arguments.\n\nThe `IntegrationFlowBuilder` only collects integration components (`MessageChannel` instances, `AbstractEndpoint` instances, and so on) in the `IntegrationFlow` bean for further parsing and registration of concrete beans in the application context by the `IntegrationFlowBeanPostProcessor`.\n\nThe Java DSL uses Spring Integration classes directly and bypasses any XML generation and parsing.\nHowever, the DSL offers more than syntactic sugar on top of XML.\nOne of its most compelling features is the ability to define inline lambdas to implement endpoint logic, eliminating the need for external classes to implement custom logic.\nIn some sense, Spring Integration's support for the Spring Expression Language (SpEL) and inline scripting address this, but lambdas are easier and much more powerful.\n\nThe following example shows how to use Java Configuration for Spring Integration:\n\n[source,java]\n----\n@Configuration\n@EnableIntegration\npublic class MyConfiguration {\n\n @Bean\n public AtomicInteger integerSource() {\n return new AtomicInteger();\n }\n\n @Bean\n public IntegrationFlow myFlow(AtomicInteger integerSource) {\n return IntegrationFlow.fromSupplier(integerSource::getAndIncrement,\n c -> c.poller(Pollers.fixedRate(100)))\n .channel(\"inputChannel\")\n .filter((Integer p) -> p > 0)\n .transform(Object::toString)\n .channel(MessageChannels.queue())\n .get();\n }\n}\n----\n\nThe result of the preceding configuration example is that it creates, after `ApplicationContext` start up, Spring Integration endpoints and message channels.\nJava configuration can be used both to replace and augment XML configuration.\nYou need not replace all of your existing XML configuration to use Java configuration.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/dsl.adoc", "title": "dsl", "heading": "dsl", "heading_level": 1, "file_order": 201, "section_index": 0, "content_hash": "79d08a66465e1034b381055c6a82aa01a8d458f8d521e12030faaf86a20939f4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/dsl.adoc"}}
{"id": "sha256:811f25986005ddedc40da095cc44597c53fa5e93c02ab1a7328b62c5547d92ad", "content": "[[endpoint-roles]]\n\nStarting with version 4.2, endpoints can be assigned to roles.\nRoles let endpoints be started and stopped as a group.\nThis is particularly useful when using leadership election, where a set of endpoints can be started or stopped when leadership is granted or revoked, respectively.\nFor this purpose the framework registers a `SmartLifecycleRoleController` bean in the application context with the name `IntegrationContextUtils.INTEGRATION_LIFECYCLE_ROLE_CONTROLLER`.\nWhenever it is necessary to control lifecycles, this bean can be injected or `@Autowired`:\n\n[source, xml]\n----\n<bean class=\"com.some.project.SomeLifecycleControl\">\n <property name=\"roleController\" ref=\"integrationLifecycleRoleController\"/>\n</bean>\n----\n\nYou can assign endpoints to roles using XML, Java configuration, or programmatically.\nThe following example shows how to configure endpoint roles with XML:\n\n[source, xml]\n----\n<int:inbound-channel-adapter id=\"ica\" channel=\"someChannel\" expression=\"'foo'\" role=\"cluster\"\n auto-startup=\"false\">\n <int:poller fixed-rate=\"60000\" />\n</int:inbound-channel-adapter>\n----\n\nThe following example shows how to configure endpoint roles for a bean created in Java:\n\n[source, java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"sendAsyncChannel\", autoStartup=\"false\")\n@Role(\"cluster\")\npublic MessageHandler sendAsyncHandler() {\n return // some MessageHandler\n}\n----\n\nThe following example shows how to configure endpoint roles on a method in Java:\n\n[source, java]\n----\n@Payload(\"#args[0].toLowerCase()\")\n@Role(\"cluster\")\npublic String handle(String payload) {\n return payload.toUpperCase();\n}\n----\n\nThe following example shows how to configure endpoint roles by using the `SmartLifecycleRoleController` in Java:\n\n[source, java]\n----\n@Autowired\nprivate SmartLifecycleRoleController roleController;\n...\n this.roleController.addSmartLifeCycleToRole(\"cluster\", someEndpoint);\n...\n----\n\nThe following example shows how to configure endpoint roles by using an `IntegrationFlow` in Java:\n\n[source, java]\n----\nIntegrationFlow flow -> flow\n .handle(..., e -> e.role(\"cluster\"));\n----\n\nEach of these adds the endpoint to the `cluster` role.\n\nInvoking `roleController.startLifecyclesInRole(\"cluster\")` and the corresponding `stop...` method starts and stops the endpoints.\n\nNOTE: Any object that implements `SmartLifecycle` can be programmatically added -- not just endpoints.\n\nThe `SmartLifecycleRoleController` implements `ApplicationListener<AbstractLeaderEvent>` and it automatically starts and stops its configured `SmartLifecycle` objects when leadership is granted or revoked (when some bean publishes `OnGrantedEvent` or `OnRevokedEvent`, respectively).\n\nIMPORTANT: When using leadership election to start and stop components, it is important to set the `auto-startup` XML attribute (`autoStartup` bean property) to `false` so that the application context does not start the components during context initialization.\n\nStarting with version 4.3.8, the `SmartLifecycleRoleController` provides several status methods:\n\n[source, java]\n----\npublic Collection<String> getRoles() <1>\n\npublic boolean allEndpointsRunning(String role) <2>\n\npublic boolean noEndpointsRunning(String role) <3>\n\npublic Map<String, Boolean> getEndpointsRunningStatus(String role) <4>\n----\n\n<1> Returns a list of the roles being managed.\n\n<2> Returns `true` if all endpoints in the role are running.\n\n<3> Returns `true` if none of the endpoints in the role are running.\n\n<4> Returns a map of `component name : running status`.\nThe component name is usually the bean name.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint-roles.adoc", "title": "endpoint-roles", "heading": "endpoint-roles", "heading_level": 1, "file_order": 202, "section_index": 0, "content_hash": "811f25986005ddedc40da095cc44597c53fa5e93c02ab1a7328b62c5547d92ad", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint-roles.adoc"}}
{"id": "sha256:42587bf10b790434271136117efc7e33861b34ee14b480219f2ae7383f372d9b", "content": "[[spring-integration-endpoints]]\n\n[[spring-integration-adapters]]\nThis section covers the various channel adapters and messaging gateways provided by Spring Integration to support message-based communication with external systems.\n\nEach system, from AMQP to Zookeeper, has its own integration requirements, and this section covers them.\n\n[[endpoint-summary]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint-summary.adoc", "title": "endpoint-summary", "heading": "endpoint-summary", "heading_level": 1, "file_order": 203, "section_index": 0, "content_hash": "42587bf10b790434271136117efc7e33861b34ee14b480219f2ae7383f372d9b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint-summary.adoc"}}
{"id": "sha256:a8a44e7a6a8135511a80323042b4fed9f46edf43e33fb0136a1e73dbb7210695", "content": "As discussed in the earlier sections, Spring Integration provides a number of endpoints used to interface with external systems, file systems, and others.\n\nFor transparent dependency management, Spring Integration provides a bill-of-materials POM to be imported into the Maven configuration:\n\n[source, xml, subs=\"normal\"]\n----\n<dependencyManagement>\n <dependencies>\n <dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-bom</artifactId>\n <version>{project-version}</version>\n <type>pom</type>\n <scope>import</scope>\n </dependency>\n </dependencies>\n</dependencyManagement>\n----\n\nTo recap:\n\n* Inbound channel adapters are used for one-way integration to bring data into the messaging application.\n* Outbound channel adapters are used for one-way integration to send data out of the messaging application.\n* Inbound gateways are used for a bidirectional integration flow, where some other system invokes the messaging application and receives a reply.\n* Outbound Gateways are used for a bidirectional integration flow, where the messaging application invokes some external service or entity and expects a result.\n\nThe following table summarizes the various endpoints with quick links to the appropriate chapter.\n\n.Endpoint Quick Reference\n[cols=\"1,1,1,1,1\", options=\"header\"]\n|===\n| Module\n| Inbound Adapter\n| Outbound Adapter\n| Inbound Gateway\n| Outbound Gateway\n\n| *AMQP*\n| xref:amqp/inbound-channel-adapter.adoc[Inbound Channel Adapter]\n| xref:amqp/outbound-channel-adapter.adoc[Outbound Channel Adapter]\n| xref:amqp/inbound-gateway.adoc[Inbound Gateway]\n| xref:amqp/outbound-gateway.adoc[Outbound Gateway]\n\n| *Apache Camel*\n| N\n| xref:camel.adoc#camel-channel-adapter[Outbound Channel Adapter]\n| N\n| xref:camel.adoc#camel-channel-adapter[Outbound Gateway]\n\n| *Apache Cassandra*\n| N\n| xref:cassandra.adoc#cassandra-outbound[Outbound Channel Adapter]\n| N\n| xref:cassandra.adoc#cassandra-outbound[Outbound Gateway]\n\n| *Debezium*\n| xref:debezium.adoc#debezium-inbound[Debezium Inbound Channel Adapter]\n| N\n| N\n| N\n\n| *Events*\n| xref:event.adoc#appevent-inbound[Receiving Spring Application Events]\n| xref:event.adoc#appevent-outbound[Sending Spring Application Events]\n| N\n| N\n\n| *Feed*\n| xref:feed.adoc#feed-inbound-channel-adapter[Feed Inbound Channel Adapter]\n| N\n| N\n| N\n\n| *File*\n| xref:file/reading.adoc[Reading Files] and xref:file/reading.adoc#file-tailing['tail'ing Files]\n| xref:file/writing.adoc[Writing files]\n| N\n| xref:file/writing.adoc[Writing files]\n\n| *FTP(S)*\n| xref:ftp/inbound.adoc[FTP Inbound Channel Adapter]\n| xref:ftp/outbound.adoc[FTP Outbound Channel Adapter]\n| N\n| xref:ftp/outbound-gateway.adoc[FTP Outbound Gateway]\n\n| *GraphQL*\n| N\n| N\n| N\n| xref:graphql.adoc#graphql-outbound-gateway[GraphQL Outbound Gateway]\n\n| *Hazelcast*\n| xref:hazelcast.adoc#hazelcast-inbound[Hazelcast Inbound Channel Adapter]\n| xref:hazelcast.adoc#hazelcast-outbound-channel-adapter[Hazelcast Outbound Channel Adapter]\n| N\n| N\n\n| *HTTP*\n| xref:http/namespace.adoc[HTTP Namespace Support]\n| xref:http/namespace.adoc[HTTP Namespace Support]\n| xref:http/inbound.adoc[Http Inbound Components]\n| xref:http/outbound.adoc[HTTP Outbound Components]\n\n| *JDBC*\n| xref:jdbc/inbound-channel-adapter.adoc[Inbound Channel Adapter] and xref:jdbc/stored-procedures.adoc#stored-procedure-inbound-channel-adapter[Stored Procedure Inbound Channel Adapter]\n| xref:jdbc/outbound-channel-adapter.adoc[Outbound Channel Adapter] and xref:jdbc/stored-procedures.adoc#stored-procedure-outbound-channel-adapter[Stored Procedure Outbound Channel Adapter]\n| N\n| xref:jdbc/outbound-gateway.adoc[Outbound Gateway] and xref:jdbc/stored-procedures.adoc#stored-procedure-outbound-gateway[Stored Procedure Outbound Gateway]\n\n| *JMS*\n| xref:jms.adoc#jms-inbound-channel-adapter[Inbound Channel Adapter] and xref:jms.adoc#jms-message-driven-channel-adapter[Message-driven Channel Adapter]\n| xref:jms.adoc#jms-outbound-channel-adapter[Outbound Channel Adapter]\n| xref:jms.adoc#jms-inbound-gateway[Inbound Gateway]\n| xref:jms.adoc#jms-outbound-gateway[Outbound Gateway]\n\n| *JMX*\n| xref:jmx.adoc#jmx-notification-listening-channel-adapter[Notification-listening Channel Adapter] and xref:jmx.adoc#jmx-attribute-polling-channel-adapter[Attribute-polling Channel Adapter] and xref:jmx.adoc#tree-polling-channel-adapter[Tree-polling Channel Adapter]\n| xref:jmx.adoc#jmx-notification-publishing-channel-adapter[Notification-publishing Channel Adapter] and xref:jmx.adoc#jmx-operation-invoking-channel-adapter[Operation-invoking Channel Adapter]\n| N\n| xref:jmx.adoc#jmx-operation-invoking-outbound-gateway[Operation-invoking Outbound Gateway]\n\n| *JPA*\n| xref:jpa/inbound-channel-adapter.adoc[Inbound Channel Adapter]\n| xref:jpa/outbound-channel-adapter.adoc[Outbound Channel Adapter]\n| N\n| xref:jpa/outbound-gateways.adoc#jpa-updating-outbound-gateway[Updating Outbound Gateway] and xref:jpa/outbound-gateways.adoc#jpa-retrieving-outbound-gateway[Retrieving Outbound Gateway]\n\n| *Apache Kafka*\n| xref:kafka.adoc#kafka-inbound[Message Driven Channel Adapter] and xref:kafka.adoc#kafka-inbound-pollable[Inbound Channel Adapter]\n| xref:kafka.adoc#kafka-outbound[Outbound Channel Adapter]\n| xref:kafka.adoc#kafka-inbound-gateway[Inbound Gateway]\n| xref:kafka.adoc#kafka-outbound-gateway[Outbound Gateway]\n\n| *Mail*\n| xref:mail.adoc#mail-inbound[Mail-receiving Channel Adapter]\n| xref:mail.adoc#mail-outbound[Mail-sending Channel Adapter]\n| N\n| N\n\n| *MongoDB*\n| xref:mongodb.adoc#mongodb-inbound-channel-adapter[MongoDB Inbound Channel Adapter]\n| xref:mongodb.adoc#mongodb-outbound-channel-adapter[MongoDB Outbound Channel Adapter]\n| N\n| N\n\n| *MQTT*\n| xref:mqtt.adoc#mqtt-inbound[Inbound (Message-driven) Channel Adapter]\n| xref:mqtt.adoc#mqtt-outbound[Outbound Channel Adapter]\n| N\n| N\n\n| *R2DBC*\n| xref:r2dbc.adoc#r2dbc-inbound-channel-adapter[R2DBC Inbound Channel Adapter]\n| xref:r2dbc.adoc#r2dbc-outbound-channel-adapter[R2DBC Outbound Channel Adapter]\n| N\n| N\n\n| *Redis*\n| xref:redis.adoc#redis-inbound-channel-adapter[Redis Inbound Channel Adapter], xref:redis.adoc#redis-queue-inbound-channel-adapter[Redis Queue Inbound Channel Adapter], xref:redis.adoc#redis-store-inbound-channel-adapter[Redis Store Inbound Channel Adapter], xref:redis.adoc#redis-stream-inbound[Redis Stream Inbound Channel Adapter]\n| xref:redis.adoc#redis-outbound-channel-adapter[Redis Outbound Channel Adapter], xref:redis.adoc#redis-queue-outbound-channel-adapter[Redis Queue Outbound Channel Adapter], xref:redis.adoc#redis-store-outbound-channel-adapter[RedisStore Outbound Channel Adapter], xref:redis.adoc#redis-stream-outbound[Redis Stream Outbound Channel Adapter]\n| xref:redis.adoc#redis-queue-inbound-gateway[Redis Queue Inbound Gateway]\n| xref:redis.adoc#redis-outbound-gateway[Redis Outbound Command Gateway] and xref:redis.adoc#redis-queue-outbound-gateway[Redis Queue Outbound Gateway]\n\n| *Resource*\n| xref:resource.adoc#resource-inbound-channel-adapter[Resource Inbound Channel Adapter]\n| N\n| N\n| N\n\n| *RSocket*\n| N\n| N\n| xref:rsocket.adoc#rsocket-inbound[RSocket Inbound Gateway]\n| xref:rsocket.adoc#rsocket-outbound[RSocket Outbound Gateway]\n\n| *SFTP*\n| xref:sftp/inbound.adoc[SFTP Inbound Channel Adapter]\n| xref:sftp/outbound.adoc[SFTP Outbound Channel Adapter]\n| N\n| xref:sftp/outbound-gateway.adoc[SFTP Outbound Gateway]\n\n| *SMB*\n| xref:smb.adoc#smb-inbound[SMB Inbound Channel Adapter], xref:smb.adoc#smb-streaming-inbound[SMB Streaming Inbound Channel Adapter]\n| xref:smb.adoc#smb-outbound[SMB Outbound Channel Adapter]\n| N\n| xref:smb.adoc#smb-outbound-gateway[SMB Outbound Gateway]\n\n| *STOMP*\n| xref:stomp.adoc#stomp-inbound-adapter[STOMP Inbound Channel Adapter]\n| xref:stomp.adoc#stomp-outbound-adapter[STOMP Outbound Channel Adapter]\n| N\n| N\n\n| *Stream*\n| xref:stream.adoc#stream-reading[Reading from Streams]\n| xref:stream.adoc#stream-writing[Writing to Streams]\n| N\n| N\n\n| *Syslog*\n| xref:syslog.adoc#syslog-inbound-adapter[Syslog Inbound Channel Adapter]\n| N\n| N\n| N\n\n| *TCP*\n| xref:ip/tcp-adapters.adoc[TCP Adapters]\n| xref:ip/tcp-adapters.adoc[TCP Adapters]\n| xref:ip/tcp-gateways.adoc[TCP Gateways]\n| xref:ip/tcp-gateways.adoc[TCP Gateways]\n\n| *UDP*\n| xref:ip/udp-adapters.adoc[UDP Adapters]\n| xref:ip/udp-adapters.adoc[UDP Adapters]\n| N\n| N\n\n| *WebFlux*\n| xref:webflux.adoc#webflux-inbound[WebFlux Inbound Channel Adapter]\n| xref:webflux.adoc#webflux-outbound[WebFlux Outbound Channel Adapter]\n| xref:webflux.adoc#webflux-inbound[Inbound WebFlux Gateway]\n| xref:webflux.adoc#webflux-outbound[Outbound WebFlux Gateway]\n\n| *Web Services*\n| N\n| N\n| xref:ws.adoc#webservices-inbound[Inbound Web Service Gateways]\n| xref:ws.adoc#webservices-outbound[Outbound Web Service Gateways]\n\n| *Web Sockets*\n| xref:web-sockets.adoc#web-socket-inbound-adapter[WebSocket Inbound Channel Adapter]\n| xref:web-sockets.adoc#web-socket-outbound-adapter[WebSocket Outbound Channel Adapter]\n| N\n| N\n\n| *XMPP*\n| xref:xmpp.adoc#xmpp-messages[XMPP Messages] and xref:xmpp.adoc#xmpp-presence[XMPP Presence]\n| xref:xmpp.adoc#xmpp-messages[XMPP Messages] and xref:xmpp.adoc#xmpp-presence[XMPP Presence]\n| N\n| N\n| *ZeroMQ*\n| xref:zeromq.adoc#zeromq-inbound-channel-adapter[ZeroMQ Inbound Channel Adapter]\n| xref:zeromq.adoc#zeromq-outbound-channel-adapter[ZeroMQ outbound Channel Adapter]\n| N\n| N\n|===\n\nIn addition, as discussed in xref:core.adoc[Core Messaging], Spring Integration provides endpoints for interfacing with Plain Old Java Objects (POJOs).\nAs discussed in xref:overview.adoc#overview-endpoints-channeladapter[Channel Adapter], the `<int:inbound-channel-adapter>` element lets you poll a Java method for data.\nThe `<int:outbound-channel-adapter>` element lets you send data to a `void` method.\nAs discussed in xref:gateway.adoc[Messaging Gateways], the `<int:gateway>` element lets any Java program invoke a messaging flow.\nEach of these works without requiring any source-level dependencies on Spring Integration.\nThe equivalent of an outbound gateway in this context is using a service activator (see xref:service-activator.adoc[Service Activator]) to invoke a method that returns an `Object` of some kind.\n\nStarting with version `5.2.2`, all the inbound gateways can be configured with an `errorOnTimeout` boolean flag to throw a `MessageTimeoutException` when the downstream flow doesn't return a reply during the reply timeout.\nThe timer is not started until the thread returns control to the gateway, so usually it is only useful when the downstream flow is asynchronous, or it stops because of a `null` return from some handler, e.g. xref:filter.adoc[filter].\nSuch an exception can be handled on the `errorChannel` flow, e.g. producing a compensation reply for a requesting client.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint-summary.adoc", "title": "endpoint-summary", "heading": "Endpoint Quick Reference Table", "heading_level": 2, "file_order": 203, "section_index": 1, "content_hash": "a8a44e7a6a8135511a80323042b4fed9f46edf43e33fb0136a1e73dbb7210695", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint-summary.adoc"}}
{"id": "sha256:d450d071a2da5ff21a84622cb6515dbe3bc26ddf347e64472580bd056355e4e7", "content": "[[endpoint]]\n\nThe first part of this chapter covers some background theory and reveals quite a bit about the underlying API that drives Spring Integration's various messaging components.\nThis information can be helpful if you want to really understand what goes on behind the scenes.\nHowever, if you want to get up and running with the simplified namespace-based configuration of the various elements, feel free to skip ahead to xref:endpoint.adoc#endpoint-namespace[Endpoint Namespace Support] for now.\n\nAs mentioned in the overview, message endpoints are responsible for connecting the various messaging components to channels.\nOver the next several chapters, we cover a number of different components that consume messages.\nSome of these are also capable of sending reply messages.\nSending messages is quite straightforward.\nAs shown earlier in xref:channel.adoc[Message Channels], you can send a message to a message channel.\nHowever, receiving is a bit more complicated.\nThe main reason is that there are two types of consumers: https://www.enterpriseintegrationpatterns.com/PollingConsumer.html[polling consumers] and https://www.enterpriseintegrationpatterns.com/EventDrivenConsumer.html[event-driven consumers].\n\nOf the two, event-driven consumers are much simpler.\nWithout any need to manage and schedule a separate poller thread, they are essentially listeners with a callback method.\nWhen connecting to one of Spring Integration's subscribable message channels, this simple option works great.\nHowever, when connecting to a buffering, pollable message channel, some component has to schedule and manage the polling threads.\nSpring Integration provides two different endpoint implementations to accommodate these two types of consumers.\nTherefore, the consumers themselves need only implement the callback interface.\nWhen polling is required, the endpoint acts as a container for the consumer instance.\nThe benefit is similar to that of using a container for hosting message-driven beans, but, since these consumers are Spring-managed objects running within an `ApplicationContext`, it more closely resembles Spring's own `MessageListener` containers.\n\n[[endpoint-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "endpoint", "heading_level": 1, "file_order": 204, "section_index": 0, "content_hash": "d450d071a2da5ff21a84622cb6515dbe3bc26ddf347e64472580bd056355e4e7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:4165d2210301c535c5b3b1b92c66010f01ffa77bad5094b7d4d63ab370407bc8", "content": "Spring Integration's `MessageHandler` interface is implemented by many of the components within the framework.\nIn other words, this is not part of the public API, and you would not typically implement `MessageHandler` directly.\nNevertheless, it is used by a message consumer for actually handling the consumed messages, so being aware of this strategy interface does help in terms of understanding the overall role of a consumer.\nThe interface is defined as follows:\n\n[source,java]\n----\npublic interface MessageHandler {\n\n void handleMessage(Message<?> message);\n\n}\n----\n\nDespite its simplicity, this interface provides the foundation for most of the components (routers, transformers, splitters, aggregators, service activators, and others) covered in the following chapters.\nThose components each perform very different functionality with the messages they handle, but the requirements for actually receiving a message are the same, and the choice between polling and event-driven behavior is also the same.\nSpring Integration provides two endpoint implementations that host these callback-based handlers and let them be connected to message channels.\n\n[[endpoint-eventdrivenconsumer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "Message Handler", "heading_level": 2, "file_order": 204, "section_index": 1, "content_hash": "4165d2210301c535c5b3b1b92c66010f01ffa77bad5094b7d4d63ab370407bc8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:a21205f291afb2803e9aaae8513c89c85661e54f3cb9da0aaffcff0a00171c2c", "content": "Because it is the simpler of the two, we cover the event-driven consumer endpoint first.\nYou may recall that the `SubscribableChannel` interface provides a `subscribe()` method and that the method accepts a `MessageHandler` parameter (as shown in xref:channel/interfaces.adoc#channel-interfaces-subscribablechannel[`SubscribableChannel`]).\nThe following listing shows the definition of the `subscribe` method:\n\n[source,java]\n----\nsubscribableChannel.subscribe(messageHandler);\n----\n\nSince a handler that is subscribed to a channel does not have to actively poll that channel, this is an event-driven consumer, and the implementation provided by Spring Integration accepts a `SubscribableChannel` and a `MessageHandler`, as the following example shows:\n\n[source,java]\n----\nSubscribableChannel channel = context.getBean(\"subscribableChannel\", SubscribableChannel.class);\n\nEventDrivenConsumer consumer = new EventDrivenConsumer(channel, exampleHandler);\n----\n\n[[endpoint-pollingconsumer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "Event-driven Consumer", "heading_level": 2, "file_order": 204, "section_index": 2, "content_hash": "a21205f291afb2803e9aaae8513c89c85661e54f3cb9da0aaffcff0a00171c2c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:15fd0e9fcbbba04a803f1657e56eba5d2f18e3afa0ede51fd57080c11e720713", "content": "Spring Integration also provides a `PollingConsumer`, and it can be instantiated in the same way except that the channel must implement `PollableChannel`, as the following example shows:\n\n[source,java]\n----\nPollableChannel channel = context.getBean(\"pollableChannel\", PollableChannel.class);\n\nPollingConsumer consumer = new PollingConsumer(channel, exampleHandler);\n----\n\nNOTE: For more information regarding polling consumers, see xref:overview.adoc#overview-endpoints-channeladapter[Channel Adapter] and xref:channel-adapter.adoc#channel-adapter[Channel Adapter].\n\nThere are many other configuration options for the polling consumer.\nThe following example shows how to set the trigger:\n\n[source,java]\n----\nPollingConsumer consumer = new PollingConsumer(channel, handler);\n\nconsumer.setTrigger(new PeriodicTrigger(Duration.ofSeconds(30)));\n----\n\nThe `PeriodicTrigger` is typically defined with a simple interval (`Duration`) but also supports an `initialDelay` property and a boolean `fixedRate` property (the default is `false` -- that is, no fixed delay).\nThe following example sets both properties:\n\n[source,java]\n----\nPeriodicTrigger trigger = new PeriodicTrigger(Duration.ofSeconds(1));\ntrigger.setInitialDelay(Duration.ofSeconds(5));\ntrigger.setFixedRate(true);\n----\n\nThe result of the three settings in the preceding example is a trigger that waits five seconds and then triggers every second.\n\nThe `CronTrigger` requires a valid cron expression.\nSee the https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/support/CronTrigger.html[Javadoc] for details.\nThe following example sets a new `CronTrigger`:\n\n[source,java]\n----\nCronTrigger trigger = new CronTrigger(\"*/10 * * * * MON-FRI\");\n----\n\nThe result of the trigger defined in the previous example is a trigger that triggers every ten seconds, Monday through Friday.\n\nNOTE: The default trigger for polling endpoint is a `PeriodicTrigger` instance with a 1 second fixed delay period.\n\nIn addition to the trigger, you can specify two other polling-related configuration properties: `maxMessagesPerPoll` and `receiveTimeout`.\nThe following example shows how to set these two properties:\n\n[source,java]\n----\nPollingConsumer consumer = new PollingConsumer(channel, handler);\n\nconsumer.setMaxMessagesPerPoll(10);\nconsumer.setReceiveTimeout(5000);\n----\n\nThe `maxMessagesPerPoll` property specifies the maximum number of messages to receive within a given poll operation.\nThis means that the poller continues calling `receive()` without waiting, until either `null` is returned or the maximum value is reached.\nFor example, if a poller has a ten-second interval trigger and a `maxMessagesPerPoll` setting of `25`, and it is polling a channel that has 100 messages in its queue, all 100 messages can be retrieved within 40 seconds.\nIt grabs 25, waits ten seconds, grabs the next 25, and so on.\nIf `maxMessagesPerPoll` is configured with a negative value, then `MessageSource.receive()` is called within a single polling cycle until it returns `null`.\nStarting with version 5.5, a `0` value has a special meaning - skip the `MessageSource.receive()` call altogether, which may be considered as pausing for this polling endpoint until the `maxMessagesPerPoll` is changed to a non-zero value at a later time, e.g. via a Control Bus.\n\nThe `receiveTimeout` property specifies the amount of time the poller should wait if no messages are available when it invokes the receive operation.\nFor example, consider two options that seem similar on the surface but are actually quite different: The first has an interval trigger of 5 seconds and a receive timeout of 50 milliseconds, while the second has an interval trigger of 50 milliseconds and a receive timeout of 5 seconds.\nThe first one may receive a message up to 4950 milliseconds later than it accepted on the channel (if that message arrived immediately after one of its poll calls returned).\nOn the other hand, the second configuration never misses a message by more than 50 milliseconds.\nThe difference is that the second option requires a thread to wait.\nHowever, as a result, it can respond much more quickly to arriving messages.\nThis technique, known as \"`long polling`\", can be used to emulate event-driven behavior on a polled source.\n\nA polling consumer can also delegate to a Spring `TaskExecutor`, as the following example shows:\n\n[source,java]\n----\nPollingConsumer consumer = new PollingConsumer(channel, handler);\n\nTaskExecutor taskExecutor = context.getBean(\"exampleExecutor\", TaskExecutor.class);\nconsumer.setTaskExecutor(taskExecutor);\n----\n\nFurthermore, a `PollingConsumer` has a property called `adviceChain`.\nThis property lets you specify a `List` of AOP advices for handling additional cross-cutting concerns including transactions.\nThese advices are applied around the `doPoll()` method.\nFor more in-depth information, see the sections on AOP advice chains and transaction support under xref:endpoint.adoc#endpoint-namespace[Endpoint Namespace Support].\nSee also a `@Poller` annotation Javadocs and respective xref:configuration/annotations.adoc[Messaging Annotations Support] section.\nThe Java DSL also provides a xref:dsl/java-pollers.adoc[`.poller()`] endpoint configuration option with its respective `Pollers` factory.\n\nThe earlier examples show dependency lookups.\nHowever, keep in mind that these consumers are most often configured as Spring bean definitions.\nIn fact, Spring Integration also provides a `FactoryBean` called `ConsumerEndpointFactoryBean` that creates the appropriate consumer type based on the type of channel.\nAlso, Spring Integration has full XML namespace support to even further hide those details.\nThe namespace-based configuration is in this guide featured as each component type is introduced.\n\nNOTE: Many of the `MessageHandler` implementations can generate reply messages.\nAs mentioned earlier, sending messages is trivial when compared to receiving messages.\nNevertheless, when and how many reply messages are sent depends on the handler type.\nFor example, an aggregator waits for a number of messages to arrive and is often configured as a downstream consumer for a splitter, which can generate multiple replies for each message it handles.\nWhen using the namespace configuration, you do not strictly need to know all the details.\nHowever, it still might be worth knowing that several of these components share a common base class, the `AbstractReplyProducingMessageHandler`, and that it provides a `setOutputChannel(..)` method.\n\n[[endpoint-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "Polling Consumer", "heading_level": 2, "file_order": 204, "section_index": 3, "content_hash": "15fd0e9fcbbba04a803f1657e56eba5d2f18e3afa0ede51fd57080c11e720713", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:13cf788a81b60830300930095c71ac279b99d3416057fe6c6bdb09e8ad060ebe", "content": "Throughout this reference manual, you can find specific configuration examples for endpoint elements, such as router, transformer, service-activator, and so on.\nMost of these support an `input-channel` attribute and many support an `output-channel` attribute.\nAfter being parsed, these endpoint elements produce an instance of either the `PollingConsumer` or the `EventDrivenConsumer`, depending on the type of the `input-channel` that is referenced: `PollableChannel` or `SubscribableChannel`, respectively.\nWhen the channel is pollable, the polling behavior is based on the endpoint element's `poller` sub-element and its attributes.\n\nThe following lists all available configuration options for a `poller`:\n\n[source,xml]\n----\n<int:poller cron=\"\" <1>\n default=\"false\" <2>\n error-channel=\"\" <3>\n fixed-delay=\"\" <4>\n fixed-rate=\"\" <5>\n initial-delay=\"\" <6>\n id=\"\" <7>\n max-messages-per-poll=\"\" <8>\n receive-timeout=\"\" <9>\n ref=\"\" <10>\n task-executor=\"\" <11>\n time-unit=\"MILLISECONDS\" <12>\n trigger=\"\"> <13>\n <int:advice-chain /> <14>\n <int:transactional /> <15>\n</int:poller>\n----\n\n<1> Provides the ability to configure pollers by using Cron expressions.\nThe underlying implementation uses an `org.springframework.scheduling.support.CronTrigger`.\nIf this attribute is set, none of the following attributes must be specified: `fixed-delay`, `trigger`, `fixed-rate`, and `ref`.\n<2> By setting this attribute to `true`, you can define exactly one global default poller.\nAn exception is raised if more than one default poller is defined in the application context.\nAny endpoints connected to a `PollableChannel` (`PollingConsumer`) or any `SourcePollingChannelAdapter` that does not have an explicitly configured poller then uses the global default poller.\nIt defaults to `false`.\nOptional.\n<3> Identifies the channel to which error messages are sent if a failure occurs in this poller's invocation.\nTo completely suppress exceptions, you can provide a reference to the `nullChannel`.\nOptional.\n<4> The fixed delay trigger uses a `PeriodicTrigger` under the covers.\nThe numeric value is in `time-unit` or can be as a duration format (starting with version 6.2), e.g. `PT10S`, `P1D`.\nIf this attribute is set, none of the following attributes must be specified: `fixed-rate`, `trigger`, `cron`, and `ref`.\n<5> The fixed rate trigger uses a `PeriodicTrigger` under the covers.\nThe numeric value is in `time-unit` or can be as a duration format (starting with version 6.2), e.g. `PT10S`, `P1D`.\nIf this attribute is set, none of the following attributes must be specified: `fixed-delay`, `trigger`, `cron`, and `ref`.\n<6> The initial delay for a `PeriodicTrigger` under the covers(starting with version 6.2).\nThe numeric value is in `time-unit` or can be as a duration format, e.g. `PT10S`, `P1D`.\n<7> The ID referring to the poller's underlying bean-definition, which is of type `org.springframework.integration.scheduling.PollerMetadata`.\nThe `id` attribute is required for a top-level poller element, unless it is the default poller (`default=\"true\"`).\n<8> See xref:channel-adapter.adoc#channel-adapter-namespace-inbound[Configuring An Inbound Channel Adapter] for more information.\nIf not specified, the default value depends on the context.\nIf you use a `PollingConsumer`, this attribute defaults to `-1`.\nHowever, if you use a `SourcePollingChannelAdapter`, the `max-messages-per-poll` attribute defaults to `1`.\nOptional.\n<9> Value is set on the underlying class `PollerMetadata`.\nIf not specified, it defaults to 1000 (milliseconds).\nOptional.\n<10> Bean reference to another top-level poller.\nThe `ref` attribute must not be present on the top-level `poller` element.\nHowever, if this attribute is set, none of the following attributes must be specified: `fixed-rate`, `trigger`, `cron`, and `fixed-delay`.\n<11> Provides the ability to reference a custom task executor.\nSee xref:endpoint.adoc#taskexecutor-support[TaskExecutor Support] for further information.\nOptional.\n<12> This attribute specifies the `java.util.concurrent.TimeUnit` enum value on the underlying `org.springframework.scheduling.support.PeriodicTrigger`.\nTherefore, this attribute can be used only in combination with the `fixed-delay` or `fixed-rate` attributes.\nIf combined with either `cron` or a `trigger` reference attribute, it causes a failure.\nThe minimal supported granularity for a `PeriodicTrigger` is milliseconds.\nTherefore, the only available options are milliseconds and seconds.\nIf this value is not provided, any `fixed-delay` or `fixed-rate` value is interpreted as milliseconds.\nBasically, this enum provides a convenience for seconds-based interval trigger values.\nFor hourly, daily, and monthly settings, we recommend using a `cron` trigger instead.\n<13> Reference to any Spring-configured bean that implements the `org.springframework.scheduling.Trigger` interface.\nHowever, if this attribute is set, none of the following attributes must be specified: `fixed-delay`, `fixed-rate`, `cron`, and `ref`.\nOptional.\n<14> Allows specifying extra AOP advices to handle additional cross-cutting concerns.\nSee xref:jms.adoc#jms-ob-transactions[Transactions] for further information.\nOptional.\n<15> Pollers can be made transactional.\nSee xref:endpoint.adoc#aop-advice-chains[AOP Advice chains] for further information.\nOptional.\n\n[[examples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "Endpoint Namespace Support", "heading_level": 2, "file_order": 204, "section_index": 4, "content_hash": "13cf788a81b60830300930095c71ac279b99d3416057fe6c6bdb09e8ad060ebe", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:76565e3c79060cd11183fd2d7596e389fc52f80cdee2895226c85301e4d69bad", "content": "A simple interval-based poller with a 1-second interval can be configured as follows:\n\n[source,xml]\n----\n<int:transformer input-channel=\"pollable\"\n ref=\"transformer\"\n output-channel=\"output\">\n <int:poller fixed-rate=\"1000\"/>\n</int:transformer>\n----\n\nAs an alternative to using the `fixed-rate` attribute, you can also use the `fixed-delay` attribute.\n\nFor a poller based on a Cron expression, use the `cron` attribute instead, as the following example shows:\n\n[source,xml]\n----\n<int:transformer input-channel=\"pollable\"\n ref=\"transformer\"\n output-channel=\"output\">\n <int:poller cron=\"*/10 * * * * MON-FRI\"/>\n</int:transformer>\n----\n\nIf the input channel is a `PollableChannel`, the poller configuration is required.\nSpecifically, as mentioned earlier, the `trigger` is a required property of the `PollingConsumer` class.\nTherefore, if you omit the `poller` sub-element for a polling consumer endpoint's configuration, an exception may be thrown.\nThe exception may also be thrown if you attempt to configure a poller on the element that is connected to a non-pollable channel.\n\nIt is also possible to create top-level pollers, in which case only a `ref` attribute is required, as the following example shows:\n\n[source,xml]\n----\n<int:poller id=\"weekdayPoller\" cron=\"*/10 * * * * MON-FRI\"/>\n\n<int:transformer input-channel=\"pollable\"\n ref=\"transformer\"\n output-channel=\"output\">\n <int:poller ref=\"weekdayPoller\"/>\n</int:transformer>\n----\n\nNOTE: The `ref` attribute is allowed only on the inner poller definitions.\nDefining this attribute on a top-level poller results in a configuration exception being thrown during initialization of the application context.\n\n[[global-default-poller]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "Examples", "heading_level": 3, "file_order": 204, "section_index": 5, "content_hash": "76565e3c79060cd11183fd2d7596e389fc52f80cdee2895226c85301e4d69bad", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:0f64d23a6588f92919affddb58e8692cf21b25fb15bc3330ced877a63e2b19da", "content": "To simplify the configuration even further, you can define a global default poller.\nA single top-level poller component in XML DSL may have the `default` attribute set to `true`.\nFor Java configuration a `PollerMetadata` bean with the `PollerMetadata.DEFAULT_POLLER` name must be declared in this case.\nIn that case, any endpoint with a `PollableChannel` for its input channel, that is defined within the same `ApplicationContext`, and has no explicitly configured `poller` uses that default.\nThe following example shows such a poller and a transformer that uses it:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean(name = PollerMetadata.DEFAULT_POLLER)\npublic PollerMetadata defaultPoller() {\n PollerMetadata pollerMetadata = new PollerMetadata();\n pollerMetadata.setMaxMessagesPerPoll(5);\n pollerMetadata.setTrigger(new PeriodicTrigger(3000));\n return pollerMetadata;\n}\n\n@Bean\npublic IntegrationFlow transformFlow(MyTransformer transformer) {\n return IntegrationFlow.from(MessageChannels.queue(\"pollable\"))\n .transform(transformer) // No 'poller' attribute because there is a default global poller\n .channel(\"output\")\n .get();\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean(PollerMetadata.DEFAULT_POLLER)\npublic PollerMetadata defaultPoller() {\n PollerMetadata pollerMetadata = new PollerMetadata();\n pollerMetadata.setMaxMessagesPerPoll(5);\n pollerMetadata.setTrigger(new PeriodicTrigger(3000));\n return pollerMetadata;\n}\n\n@Bean\npublic QueueChannel pollable() {\n return new QueueChannel();\n}\n@Transformer(inputChannel = \"pollable\", outputChannel = \"output\")\npublic Object transform(Object payload) {\n ...\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean(PollerMetadata.DEFAULT_POLLER)\nfun defaultPoller() =\n PollerMetadata()\n .also {\n it.maxMessagesPerPoll = 5\n it.trigger = PeriodicTrigger(3000)\n }\n\n@Bean\nfun convertFlow() =\n integrationFlow(MessageChannels.queue(\"pollable\")) {\n transform(transformer) // No 'poller' attribute because there is a default global poller\n channel(\"output\")\n }\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:poller id=\"defaultPoller\" default=\"true\" max-messages-per-poll=\"5\" fixed-delay=\"3000\"/>\n\n<!-- No <poller/> sub-element is necessary, because there is a default -->\n<int:transformer input-channel=\"pollable\"\n ref=\"transformer\"\n output-channel=\"output\"/>\n----\n======\n\n[[transaction-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "Global Default Poller", "heading_level": 4, "file_order": 204, "section_index": 6, "content_hash": "0f64d23a6588f92919affddb58e8692cf21b25fb15bc3330ced877a63e2b19da", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:2b7040f3a599bc57db4019a672cafd8e1d0bb5e46ed631b4c1cd17f411a6bea6", "content": "Spring Integration also provides transaction support for the pollers so that each receive-and-forward operation can be performed as an atomic unit of work.\nTo configure transactions for a poller, add the `<transactional/>` sub-element.\nThe following example shows the available attributes:\n\n[source,xml]\n----\n<int:poller fixed-delay=\"1000\">\n <int:transactional transaction-manager=\"txManager\"\n propagation=\"REQUIRED\"\n isolation=\"REPEATABLE_READ\"\n timeout=\"10000\"\n read-only=\"false\"/>\n</int:poller>\n----\n\nFor more information, see xref:transactions.adoc#transaction-poller[Poller Transaction Support].\n\n[[aop-advice-chains]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "Transaction Support", "heading_level": 4, "file_order": 204, "section_index": 7, "content_hash": "2b7040f3a599bc57db4019a672cafd8e1d0bb5e46ed631b4c1cd17f411a6bea6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:648f59ba7c6d2fddc576b22a4302facc332599414761408a5291587b5d328218", "content": "Since Spring transaction support depends on the proxy mechanism with `TransactionInterceptor` (AOP Advice) handling transactional behavior of the message flow initiated by the poller, you must sometimes provide extra advices to handle other cross cutting behavior associated with the poller.\nFor that, the `poller` defines an `advice-chain` element that lets you add more advices in a class that implements the `MethodInterceptor` interface.\nThe following example shows how to define an `advice-chain` for a `poller`:\n\n[source,xml]\n----\n<int:service-activator id=\"advicedSa\" input-channel=\"goodInputWithAdvice\" ref=\"testBean\"\n method=\"good\" output-channel=\"output\">\n\t<int:poller max-messages-per-poll=\"1\" fixed-rate=\"10000\">\n <int:advice-chain>\n <ref bean=\"adviceA\" />\n <beans:bean class=\"org.something.SampleAdvice\" />\n <ref bean=\"txAdvice\" />\n </int:advice-chain>\n\t</int:poller>\n</int:service-activator>\n----\n\nFor more information on how to implement the `MethodInterceptor` interface, see the https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-api[AOP sections of the Spring Framework Reference Guide].\nAn advice chain can also be applied on a poller that does not have any transaction configuration, letting you enhance the behavior of the message flow initiated by the poller.\n\nIMPORTANT: When using an advice chain, the `<transactional/>` child element cannot be specified.\nInstead, declare a `<tx:advice/>` bean and add it to the `<advice-chain/>`.\nSee xref:transactions.adoc#transaction-poller[Poller Transaction Support] for complete configuration details.\n\n[[taskexecutor-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "AOP Advice chains", "heading_level": 3, "file_order": 204, "section_index": 8, "content_hash": "648f59ba7c6d2fddc576b22a4302facc332599414761408a5291587b5d328218", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:b6792d7bbecb6f8c59e653dbe6541f00e7f9020438e44565b338be2ab4f2c70f", "content": "The polling threads may be executed by any instance of Spring's `TaskExecutor` abstraction.\nThis enables concurrency for an endpoint or group of endpoints.\nAs of Spring 3.0, the core Spring Framework has a `task` namespace, and its `<executor/>` element supports the creation of a simple thread pool executor.\nThat element accepts attributes for common concurrency settings, such as pool-size and queue-capacity.\nConfiguring a thread-pooling executor can make a substantial difference in how the endpoint performs under load.\nThese settings are available for each endpoint, since the performance of an endpoint is one of the major factors to consider (the other major factor being the expected volume on the channel to which the endpoint subscribes).\nTo enable concurrency for a polling endpoint that is configured with the XML namespace support, provide the `task-executor` reference on its `<poller/>` element and then provide one or more of the properties shown in the following example:\n\n[source,xml]\n----\n<int:poller task-executor=\"pool\" fixed-rate=\"1000\"/>\n\n<task:executor id=\"pool\"\n pool-size=\"5-25\"\n queue-capacity=\"20\"\n keep-alive=\"120\"/>\n----\n\nIf you do not provide a task-executor, the consumer's handler is invoked in the caller's thread.\nNote that the caller is usually the default `TaskScheduler` (see xref:configuration/namespace-taskscheduler.adoc[Configuring the Task Scheduler]).\nYou should also keep in mind that the `task-executor` attribute can provide a reference to any implementation of Spring's `TaskExecutor` interface by specifying the bean name.\nThe `executor` element shown earlier is provided for convenience.\n\nAs mentioned earlier in the xref:endpoint.adoc#endpoint-pollingconsumer[background section for polling consumers], you can also configure a polling consumer in such a way as to emulate event-driven behavior.\nWith the long receive timeout and a short interval in the trigger, you can ensure a very timely reaction to arriving messages even on a polled message source.\nNote that this applies only to sources that have a blocking wait call with a timeout.\nFor example, the file poller does not block.\nEach `receive()` call returns immediately and either contains new files or not.\nTherefore, even if a poller contains a long `receive-timeout`, that value would never be used in such a scenario.\nOn the other hand, when using Spring Integration's own queue-based channels, the timeout value does have a chance to participate.\nThe following example shows how a polling consumer can receive messages nearly instantaneously:\n\n[source,xml]\n----\n<int:service-activator input-channel=\"someQueueChannel\"\n output-channel=\"output\">\n <int:poller receive-timeout=\"30000\" fixed-rate=\"10\"/>\n\n</int:service-activator>\n----\n\nUsing this approach does not carry much overhead, since, internally, it is nothing more than a timed-wait thread, which does not require nearly as much CPU resource usage as, for example, a thrashing, infinite while loop.\n\n[[polling-consumer-change-polling-rate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "TaskExecutor Support", "heading_level": 4, "file_order": 204, "section_index": 9, "content_hash": "b6792d7bbecb6f8c59e653dbe6541f00e7f9020438e44565b338be2ab4f2c70f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:e4b94a5b78605022dc3be386e952436c974267f79cab787b5c753e1a6a39d80c", "content": "When configuring a poller with a `fixed-delay` or a `fixed-rate` attribute, the default implementation uses a `PeriodicTrigger` instance.\nThe `PeriodicTrigger` is part of the core Spring Framework.\nIt accepts the interval only as a constructor argument.\nTherefore, it cannot be changed at runtime.\n\nHowever, you can define your own implementation of the `org.springframework.scheduling.Trigger` interface.\nYou could even use the `PeriodicTrigger` as a starting point.\nThen you can add a setter for the interval (period), or you can even embed your own throttling logic within the trigger itself.\nThe `period` property is used with each call to `nextExecutionTime` to schedule the next poll.\nTo use this custom trigger within pollers, declare the bean definition of the custom trigger in your application context and inject the dependency into your poller configuration by using the `trigger` attribute, which references the custom trigger bean instance.\nYou can now obtain a reference to the trigger bean and change the polling interval between polls.\n\nFor an example, see the https://github.com/SpringSource/spring-integration-samples/tree/main/intermediate[Spring Integration Samples] project.\nIt contains a sample called `dynamic-poller`, which uses a custom trigger and demonstrates the ability to change the polling interval at runtime.\n\nThe sample provides a custom trigger that implements the https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/Trigger.html[`org.springframework.scheduling.Trigger`] interface.\nThe sample's trigger is based on Spring's https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/support/PeriodicTrigger.html[`PeriodicTrigger`] implementation.\nHowever, the fields of the custom trigger are not final, and the properties have explicit getters and setters, letting you dynamically change the polling period at runtime.\n\nNOTE: It is important to note, though, that because the Trigger method is `nextExecutionTime()`, any changes to a dynamic trigger do not take effect until the next poll, based on the existing configuration.\nIt is not possible to force a trigger to fire before its currently configured next execution time.\n\n[[payload-type-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "Changing Polling Rate at Runtime", "heading_level": 2, "file_order": 204, "section_index": 10, "content_hash": "e4b94a5b78605022dc3be386e952436c974267f79cab787b5c753e1a6a39d80c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:f5c526d6e698c78f64aa6218fb4a61bc08eb1288a2c6e2ea56fd0a0d516d8d1c", "content": "Throughout this reference manual, you can also see specific configuration and implementation examples of various endpoints that accept a message or any arbitrary `Object` as an input parameter.\nIn the case of an `Object`, such a parameter is mapped to a message payload or part of the payload or header (when using the Spring Expression Language).\nHowever, the type of input parameter of the endpoint method sometimes does not match the type of the payload or its part.\nIn this scenario, we need to perform type conversion.\nSpring Integration provides a convenient way for registering type converters (by using the Spring `ConversionService`) within its own instance of a conversion service bean named `integrationConversionService`.\nThat bean is automatically created as soon as the first converter is defined by using the Spring Integration infrastructure.\nTo register a converter, you can implement `org.springframework.core.convert.converter.Converter`, `org.springframework.core.convert.converter.GenericConverter`, or `org.springframework.core.convert.converter.ConverterFactory`.\n\nThe `Converter` implementation is the simplest and converts from a single type to another.\nFor more sophistication, such as converting to a class hierarchy, you can implement a `GenericConverter` and possibly a `ConditionalConverter`.\nThese give you complete access to the `from` and `to` type descriptors, enabling complex conversions.\nFor example, if you have an abstract class called `Something` that is the target of your conversion (parameter type, channel data type, and so on), you have two concrete implementations called `Thing1` and `Thing`, and you wish to convert to one or the other based on the input type, the `GenericConverter` would be a good fit.\nFor more information, see the Javadoc for these interfaces:\n\n* https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/Converter.html[org.springframework.core.convert.converter.Converter]\n* https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/convert/converter/package-summary.html[org.springframework.core.convert.converter.GenericConverter]\n* https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/convert/converter/ConverterFactory.html[org.springframework.core.convert.converter.ConverterFactory]\n\nWhen you have implemented your converter, you can register it with convenient namespace support, as the following example shows:\n\n[source,xml]\n----\n<int:converter ref=\"sampleConverter\"/>\n\n<bean id=\"sampleConverter\" class=\"foo.bar.TestConverter\"/>\n----\n\nAlternately, you can use an inner bean, as the following example shows:\n\n[source,xml]\n----\n<int:converter>\n <bean class=\"o.s.i.config.xml.ConverterParserTests$TestConverter3\"/>\n</int:converter>\n----\n\nStarting with Spring Integration 4.0, you can use annotations to create the preceding configuration, as the following example shows:\n\n[source,java]\n----\n@Component\n@IntegrationConverter\npublic class TestConverter implements Converter<Boolean, Number> {\n\n\tpublic Number convert(Boolean source) {\n return source ? 1 : 0;\n\t}\n\n}\n----\n\nAlternately, you can use the `@Configuration` annotation, as the following example shows:\n\n[source,java]\n----\n@Configuration\n@EnableIntegration\npublic class ContextConfiguration {\n\n\t@Bean\n\t@IntegrationConverter\n\tpublic SerializingConverter serializingConverter() {\n return new SerializingConverter();\n\t}\n\n}\n----\n\n[IMPORTANT]\n=====\nWhen configuring an application context, the Spring Framework lets you add a `conversionService` bean (see https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#core-convert-Spring-config[Configuring a ConversionService] chapter).\nThis service is used, when needed, to perform appropriate conversions during bean creation and configuration.\n\nIn contrast, the `integrationConversionService` is used for runtime conversions.\nThese uses are quite different.\nConverters that are intended for use when wiring bean constructor arguments and properties may produce unintended results if used at runtime for Spring Integration expression evaluation against messages within data type channels, payload type transformers, and so on.\n\nHowever, if you do want to use the Spring `conversionService` as the Spring Integration `integrationConversionService`, you can configure an alias in the application context, as the following example shows:\n\n[source,xml]\n----\n<alias name=\"conversionService\" alias=\"integrationConversionService\"/>\n----\n\nIn this case, the converters provided by the `conversionService` are available for Spring Integration runtime conversion.\n=====\n\n[[content-type-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "Payload Type Conversion", "heading_level": 2, "file_order": 204, "section_index": 11, "content_hash": "f5c526d6e698c78f64aa6218fb4a61bc08eb1288a2c6e2ea56fd0a0d516d8d1c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:58db0d6b1eae8b5dafbd83ef7c1c39c00641ee8687cb3f5038119d690dfe41bf", "content": "Starting with version 5.0, by default, the method invocation mechanism is based on the `org.springframework.messaging.handler.invocation.InvocableHandlerMethod` infrastructure.\nIts `HandlerMethodArgumentResolver` implementations (such as `PayloadArgumentResolver` and `MessageMethodArgumentResolver`) can use the `MessageConverter` abstraction to convert an incoming `payload` to the target method argument type.\nThe conversion can be based on the `contentType` message header.\nFor this purpose, Spring Integration provides the `ConfigurableCompositeMessageConverter`, which delegates to a list of registered converters to be invoked until one of them returns a non-null result.\nBy default, this converter provides (in strict order):\n\n. https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jms/support/converter/MappingJackson2MessageConverter.html[`MappingJackson2MessageConverter`] if the Jackson processor is present on the classpath\n. https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/converter/ByteArrayMessageConverter.html[`ByteArrayMessageConverter`]\n. https://docs.spring.io/spring-integration/docs/current/api//org/springframework/integration/support/converter/ObjectStringMessageConverter.html[`ObjectStringMessageConverter`]\n. https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/converter/GenericMessageConverter.html[`GenericMessageConverter`]\n\nSee the Javadoc (linked in the preceding list) for more information about their purpose and appropriate `contentType` values for conversion.\nThe `ConfigurableCompositeMessageConverter` is used because it can be supplied with any other `MessageConverter` implementations, including or excluding the previously mentioned default converters.\nIt can also be registered as an appropriate bean in the application context, overriding the default converter, as the following example shows:\n\n[source,java]\n----\n@Bean(name = IntegrationContextUtils.ARGUMENT_RESOLVER_MESSAGE_CONVERTER_BEAN_NAME)\npublic ConfigurableCompositeMessageConverter compositeMessageConverter() {\n List<MessageConverter> converters =\n Arrays.asList(new MarshallingMessageConverter(jaxb2Marshaller()),\n new JavaSerializationMessageConverter());\n return new ConfigurableCompositeMessageConverter(converters);\n}\n----\n\nThose two new converters are registered in the composite before the defaults.\nYou can also not use a `ConfigurableCompositeMessageConverter` but provide your own `MessageConverter` by registering a bean with the name, `integrationArgumentResolverMessageConverter` (by setting the `IntegrationContextUtils.ARGUMENT_RESOLVER_MESSAGE_CONVERTER_BEAN_NAME` property).\n\nNOTE: The `MessageConverter`-based (including `contentType` header) conversion is not available when using SpEL method invocation.\nIn this case, only the regular class-to-class conversion mentioned above in the xref:endpoint.adoc#payload-type-conversion[Payload Type Conversion] is available.\n\n[[async-polling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "Content Type Conversion", "heading_level": 2, "file_order": 204, "section_index": 12, "content_hash": "58db0d6b1eae8b5dafbd83ef7c1c39c00641ee8687cb3f5038119d690dfe41bf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:6ed9fee50a54a1210766b9493afce318aaf7d95a805fbf12e8f4bbb5f2b29bc1", "content": "If you want the polling to be asynchronous, a poller can optionally specify a `task-executor` attribute that points to an existing instance of any `TaskExecutor` bean (Spring 3.0 provides a convenient namespace configuration through the `task` namespace).\nHowever, there are certain things you must understand when configuring a poller with a `TaskExecutor`.\n\nThe problem is that there are two configurations in place, the poller and the `TaskExecutor`.\nThey must be in tune with each other.\nOtherwise, you might end up creating an artificial memory leak.\n\nConsider the following configuration:\n\n[source,xml]\n----\n<int:channel id=\"publishChannel\">\n <int:queue />\n</int:channel>\n\n<int:service-activator input-channel=\"publishChannel\" ref=\"myService\">\n\t<int:poller receive-timeout=\"5000\" task-executor=\"taskExecutor\" fixed-rate=\"50\" />\n</int:service-activator>\n\n<task:executor id=\"taskExecutor\" pool-size=\"20\" />\n----\n\nThe preceding configuration demonstrates an out-of-tune configuration.\n\nBy default, the task executor has an unbounded task queue.\nThe poller keeps scheduling new tasks even though all the threads are blocked, waiting for either a new message to arrive or the timeout to expire.\nGiven that there are 20 threads executing tasks with a five-second timeout, they are executed at a rate of 4 per second.\nHowever, new tasks are being scheduled at a rate of 20 per second, so the internal queue in the task executor grows at a rate of 16 per second (while the process is idle), so we have a memory leak.\n\nOne of the ways to handle this is to set the `queue-capacity` attribute of the task executor.\nEven 0 is a reasonable value.\nYou can also manage it by specifying what to do with messages that cannot be queued by setting the `rejection-policy` attribute of the Task Executor, for example, to `DISCARD`.\nIn other words, there are certain details you must understand when configuring `TaskExecutor`.\nSee https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling[\"`Task Execution and Scheduling`\"] in the Spring reference manual for more detail on the subject.\n\n[[endpoint-inner]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "Asynchronous Polling", "heading_level": 2, "file_order": 204, "section_index": 13, "content_hash": "6ed9fee50a54a1210766b9493afce318aaf7d95a805fbf12e8f4bbb5f2b29bc1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:f47cb87bbc779a96b60d7e4c701be6a52f7d954af29b7ebf61dbbec57f85dc04", "content": "Many endpoints are composite beans.\nThis includes all consumers and all polled inbound channel adapters.\nConsumers (polled or event-driven) delegate to a `MessageHandler`.\nPolled adapters obtain messages by delegating to a `MessageSource`.\nOften, it is useful to obtain a reference to the delegate bean, perhaps to change configuration at runtime or for testing.\nThese beans can be obtained from the `ApplicationContext` with well known names.\n`MessageHandler` instances are registered with the application context with bean IDs similar to `someConsumer.handler` (where 'consumer' is the value of the endpoint's `id` attribute).\n`MessageSource` instances are registered with bean IDs similar to `somePolledAdapter.source`, where 'somePolledAdapter' is the ID of the adapter.\n\nThe preceding only applies to the framework component itself.\nYou can instead use an inner bean definition, as the following example shows:\n\n[source,xml]\n----\n<int:service-activator id=\"exampleServiceActivator\" input-channel=\"inChannel\"\n output-channel = \"outChannel\" method=\"foo\">\n <beans:bean class=\"org.foo.ExampleServiceActivator\"/>\n</int:service-activator>\n----\n\nThe bean is treated like any inner bean declared and is not registered with the application context.\nIf you wish to access this bean in some other manner, declare it at the top level with an `id` and use the `ref` attribute instead.\nSee the https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-inner-beans[Spring Documentation] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/endpoint.adoc", "title": "endpoint", "heading": "Endpoint Inner Beans", "heading_level": 2, "file_order": 204, "section_index": 14, "content_hash": "f47cb87bbc779a96b60d7e4c701be6a52f7d954af29b7ebf61dbbec57f85dc04", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/endpoint.adoc"}}
{"id": "sha256:b4637d6a25407dba5e91a95e2b8fad1f9468864dd14882be3c32f0159cd58123", "content": "[[error-handling]]\n\nAs described in the xref:overview.adoc#overview[overview] at the very beginning of this manual, one of the main motivations behind a message-oriented framework such as Spring Integration is to promote loose coupling between components.\nThe message channel plays an important role, in that producers and consumers do not have to know about each other.\nHowever, the advantages also have some drawbacks.\nSome things become more complicated in a loosely coupled environment, and one example is error handling.\n\nWhen sending a message to a channel, the component that ultimately handles that message may or may not be operating within the same thread as the sender.\nIf using a simple default `DirectChannel` (when the `<channel>` element that has no `<queue>` child element and no 'task-executor' attribute), the message handling occurs in the same thread that sends the initial message.\nIn that case, if an `Exception` is thrown, it can be caught by the sender, or it may propagate past the sender if it is an uncaught `RuntimeException`.\nThis is the same behavior as an exception-throwing operation in a normal Java call stack.\n\nA message flow that runs on a caller thread might be invoked through a messaging gateway (see xref:gateway.adoc[Messaging Gateways]) or a `MessagingTemplate` (see xref:channel/template.adoc[`MessagingTemplate`]).\nIn either case, the default behavior is to throw any exceptions to the caller.\nFor the messaging gateway, see xref:gateway.adoc#gateway-error-handling[Error Handling] for details about how the exception is thrown and how to configure the gateway to route the errors to an error channel instead.\nWhen using a `MessagingTemplate` or sending to a `MessageChannel` directly, exceptions are always thrown to the caller.\n\nWhen adding asynchronous processing, things become rather more complicated.\nFor instance, if the 'channel' element does provide a 'queue' child element (`QueueChannel` in Java & Annotations Configuration), the component that handles the message operates in a different thread than the sender.\nThe same is true when an `ExecutorChannel` is used.\nThe sender may have dropped the `Message` into the channel and moved on to other things.\nThere is no way for the `Exception` to be thrown directly back to that sender by using standard `Exception` throwing techniques.\nInstead, handling errors for asynchronous processes requires that the error-handling mechanism also be asynchronous.\n\nSpring Integration supports error handling for its components by publishing errors to a message channel.\nSpecifically, the `Exception` becomes the payload of a Spring Integration `ErrorMessage`.\nThat `Message` is then sent to a message channel that is resolved in a way that is similar to the 'replyChannel' resolution.\nFirst, if the request `Message` being handled at the time the `Exception` occurred contains an 'errorChannel' header (the header name is defined in the `MessageHeaders.ERROR_CHANNEL` constant), the `ErrorMessage` is sent to that channel.\nOtherwise, the error handler sends to a \"`global`\" channel whose bean name is `errorChannel` (this is also defined as a constant: `IntegrationContextUtils.ERROR_CHANNEL_BEAN_NAME`).\n\nA default `errorChannel` bean is created internally by the Framework.\nHowever, you can define your own if you want to control the settings.\nThe following example shows how to define an error channel in XML configuration backed by a queue with a capacity of `500`:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\nQueueChannel errorChannel() {\n return new QueueChannel(500);\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"errorChannel\">\n <int:queue capacity=\"500\"/>\n</int:channel>\n----\n======\n\nNOTE: The default error channel is a `PublishSubscribeChannel`.\nBy default, it has a `LoggingHandler` as a subscriber with an `ERROR` logging level and subscription order as `Ordered.LOWEST_PRECEDENCE - 100`.\nIf you subscribe additional consuming endpoints, that might throw an exception, and you don't want to preempt the logging, ensure that the additional handlers have a higher order.\n\nThe most important thing to understand here is that the messaging-based error handling applies only to exceptions that are thrown by a Spring Integration task that is executing within a `TaskExecutor`.\nThis does not apply to exceptions thrown by a handler that operates within the same thread as the sender, (for example, through a `DirectChannel` as described earlier in this section).\n\nNOTE: When exceptions occur in a scheduled poller task's execution, those exceptions are wrapped in `ErrorMessage` instances and sent to the 'errorChannel' as well.\nThis is done via a `MessagePublishingErrorHandler` injected into the global `taskScheduler` bean.\nIt is recommended to use that `MessagePublishingErrorHandler` for any custom `taskScheduler` if the error handling still has to be done using standard 'errorChannel' integration flow logic.\nA registered `integrationMessagePublishingErrorHandler` bean can be used in this case.\n\nTo enable global error handling, register a handler on that channel.\nFor example, you can configure Spring Integration's `ErrorMessageExceptionTypeRouter` as the handler of an endpoint that is subscribed to the `errorChannel`.\nThat router can then spread the error messages across multiple channels, based on the `Exception` type.\n\nStarting with version 4.3.10, Spring Integration provides the `ErrorMessagePublisher` and the `ErrorMessageStrategy`.\nYou can use them as a general mechanism for publishing `ErrorMessage` instances.\nYou can call or extend them in any error handling scenarios.\nThe `ErrorMessageSendingRecoverer` extends this class as a `RecoveryCallback` implementation that can be used with retry, such as the\nxref:handler-advice/classes.adoc#retry-advice[`RequestHandlerRetryAdvice`].\nThe `ErrorMessageStrategy` is used to build an `ErrorMessage` based on the provided exception and an `AttributeAccessor` context.\nIt can be injected into any `MessageProducerSupport` or `MessagingGatewaySupport`.\nThe `requestMessage` is stored under `ErrorMessageUtils.INPUT_MESSAGE_CONTEXT_KEY` in the `AttributeAccessor` context.\nThe `ErrorMessageStrategy` can use that `requestMessage` as the `originalMessage` property of the `ErrorMessage` it creates.\nThe `DefaultErrorMessageStrategy` does exactly that.\n\nStarting with version 5.2, all the `MessageHandlingException` instances thrown by the framework components, includes a component `BeanDefinition` resource and source to determine a configuration point form the exception.\nIn case of XML configuration, a resource is an XML file path and source an XML tag with its `id` attribute.\nWith Java & Annotation configuration, a resource is a `@Configuration` class and source is a `@Bean` method.\nIn most cases the target integration flow solution is based on the out-of-the-box components and their configuration options.\nWhen an exception happens at runtime, there is no any end-user code involved in stack trace because an execution is against beans, not their configuration.\nIncluding a resource and source of the bean definition helps to determine possible configuration mistakes and provides better developer experience.\n\nStarting with version 5.4.3, the default error channel is configured with the property `requireSubscribers = true` to not silently ignore messages when there are no subscribers on this channel (e.g. when application context is stopped).\nIn this case a `MessageDispatchingException` is thrown which may lend on the client callback of the inbound channel adapter to negatively acknowledge (or roll back) an original message in the source system for redelivery or other future consideration.\nTo restore the previous behavior (ignore non-dispatched error messages), the global integration property `spring.integration.channels.error.requireSubscribers` must be set to `false`.\nSee xref:configuration/global-properties.adoc[Global Properties] and xref:channel/configuration.adoc#channel-configuration-pubsubchannel[`PublishSubscribeChannel` Configuration] (if you configure a global `errorChannel` manually) for more information.\n\nSee also https://github.com/spring-projects/spring-integration-samples/tree/main/intermediate/errorhandling[Error Handling Sample] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/error-handling.adoc", "title": "error-handling", "heading": "error-handling", "heading_level": 1, "file_order": 205, "section_index": 0, "content_hash": "b4637d6a25407dba5e91a95e2b8fad1f9468864dd14882be3c32f0159cd58123", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/error-handling.adoc"}}
{"id": "sha256:dac1d455bb19602462e18c305de0da1c9286e976103477d8671b1378be480018", "content": "[[applicationevent]]\n\nSpring Integration provides support for inbound and outbound `ApplicationEvents`, as defined by the underlying Spring Framework.\nFor more information about Spring's support for events and listeners, see the https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-functionality-events[Spring Reference Manual].\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-event</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-event:{project-version}\"\n----\n======\n\n[[appevent-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/event.adoc", "title": "event", "heading": "event", "heading_level": 1, "file_order": 206, "section_index": 0, "content_hash": "dac1d455bb19602462e18c305de0da1c9286e976103477d8671b1378be480018", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/event.adoc"}}
{"id": "sha256:b855f950a207eb86e07044ccb16f9e4946ac63e57a9b9778d2bd1a4d8a244dd6", "content": "To receive events and send them to a channel, you can define an instance of Spring Integration's `ApplicationEventListeningMessageProducer`.\nThis class is an implementation of Spring's `ApplicationListener` interface.\nBy default, it passes all received events as Spring Integration messages.\nTo limit based on the type of event, you can use the 'eventTypes' property to configure the list of event types that you want to receive.\nIf a received event has a `Message` instance as its 'source', that `Message` is passed as-is.\nOtherwise, if a SpEL-based `payloadExpression` has been provided, that is evaluated against the `ApplicationEvent` instance.\nIf the event's source is not a `Message` instance and no `payloadExpression` has been provided, the `ApplicationEvent` itself is passed as the payload.\n\nStarting with version 4.2, the `ApplicationEventListeningMessageProducer` implements `GenericApplicationListener` and can be configured to accept not only `ApplicationEvent` types but any type for treating payload events (which are also supported since Spring Framework 4.2).\nWhen the accepted event is an instance of `PayloadApplicationEvent`, its `payload` is used for the message to send.\n\nFor convenience, namespace support is provided to configure an `ApplicationEventListeningMessageProducer` with the `inbound-channel-adapter` element, as the following example shows:\n\n[source,xml]\n----\n<int-event:inbound-channel-adapter channel=\"eventChannel\"\n error-channel=\"eventErrorChannel\"\n event-types=\"example.FooEvent, example.BarEvent, java.util.Date\"/>\n\n<int:publish-subscribe-channel id=\"eventChannel\"/>\n----\n\nIn the preceding example, all application context events that match one of the types specified by the 'event-types' (optional) attribute are delivered as Spring Integration messages to the message channel named 'eventChannel'.\nIf a downstream component throws an exception, a `MessagingException` that contains the failed message and exception is sent to the channel named 'eventErrorChannel'.\nIf no `error-channel` is specified and the downstream channels are synchronous, the exception is propagated to the caller.\n\nUsing Java to configure the same adapter:\n\n[source, java]\n----\n@Bean\npublic ApplicationEventListeningMessageProducer eventsAdapter(\n MessageChannel eventChannel, MessageChannel eventErrorChannel) {\n\n ApplicationEventListeningMessageProducer producer =\n new ApplicationEventListeningMessageProducer();\n producer.setEventTypes(example.FooEvent.class, example.BarEvent.class, java.util.Date.class);\n producer.setOutputChannel(eventChannel);\n producer.setErrorChannel(eventErrorChannel);\n return producer;\n}\n----\n\nWith the Java DSL:\n\n[source, java]\n----\n@Bean\npublic ApplicationEventListeningMessageProducer eventsAdapter() {\n\n ApplicationEventListeningMessageProducer producer =\n new ApplicationEventListeningMessageProducer();\n producer.setEventTypes(example.FooEvent.class, example.BarEvent.class, java.util.Date.class);\n return producer;\n}\n\n@Bean\npublic IntegrationFlow eventFlow(ApplicationEventListeningMessageProducer eventsAdapter,\n MessageChannel eventErrorChannel) {\n\n return IntegrationFlow.from(eventsAdapter, e -> e.errorChannel(eventErrorChannel))\n .handle(...)\n ...\n .get();\n}\n----\n\n[[appevent-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/event.adoc", "title": "event", "heading": "Receiving Spring Application Events", "heading_level": 2, "file_order": 206, "section_index": 1, "content_hash": "b855f950a207eb86e07044ccb16f9e4946ac63e57a9b9778d2bd1a4d8a244dd6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/event.adoc"}}
{"id": "sha256:1fdf27b0a25020635b1d3315803c0434eb906a0cc2064c12e8d4a50f08419447", "content": "To send Spring `ApplicationEvents`, create an instance of the `ApplicationEventPublishingMessageHandler` and register it within an endpoint.\nThis implementation of the `MessageHandler` interface also implements Spring's `ApplicationEventPublisherAware` interface and consequently acts as a bridge between Spring Integration messages and `ApplicationEvents`.\n\nFor convenience, namespace support is provided to configure an `ApplicationEventPublishingMessageHandler` with the `outbound-channel-adapter` element, as the following example shows:\n\n[source,xml]\n----\n<int:channel id=\"eventChannel\"/>\n\n<int-event:outbound-channel-adapter channel=\"eventChannel\"/>\n----\n\nIf you use a `PollableChannel` (such as a `QueueChannel`), you can also provide a `poller` child element of the `outbound-channel-adapter` element.\nYou can also optionally provide a `task-executor` reference for that poller.\nThe following example demonstrates both:\n\n[source,xml]\n----\n<int:channel id=\"eventChannel\">\n <int:queue/>\n</int:channel>\n\n<int-event:outbound-channel-adapter channel=\"eventChannel\">\n <int:poller max-messages-per-poll=\"1\" task-executor=\"executor\" fixed-rate=\"100\"/>\n</int-event:outbound-channel-adapter>\n\n<task:executor id=\"executor\" pool-size=\"5\"/>\n----\n\nIn the preceding example, all messages sent to the 'eventChannel' channel are published as `ApplicationEvent` instances to any relevant `ApplicationListener` instances that are registered within the same Spring `ApplicationContext`.\nIf the payload of the message is an `ApplicationEvent`, it is passed as-is.\nOtherwise, the message itself is wrapped in a `MessagingEvent` instance.\n\nStarting with version 4.2, you can configure the `ApplicationEventPublishingMessageHandler` (`<int-event:outbound-channel-adapter>`) with the `publish-payload` boolean attribute to publish to the application context `payload` as is, instead of wrapping it to a `MessagingEvent` instance.\n\nTo configure the adapter using Java configuration:\n\n[source, java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"eventChannel\")\npublic ApplicationEventPublishingMessageHandler eventHandler() {\n ApplicationEventPublishingMessageHandler handler =\n new ApplicationEventPublishingMessageHandler();\n handler.setPublishPayload(true);\n return handler;\n}\n----\n\nWith the Java DSL:\n\n[source, java]\n----\n@Bean\npublic ApplicationEventPublishingMessageHandler eventHandler() {\n ApplicationEventPublishingMessageHandler handler =\n new ApplicationEventPublishingMessageHandler();\n handler.setPublishPayload(true);\n return handler;\n}\n\n@Bean\npublic IntegrationFlow eventsOutFlow(ApplicationEventPublishingMessageHandler eventHandler) {\n return f -> f.handle(eventHandler);\n}\n----\n\nThe `@Publisher` annotation also can be used in combination with an `@EventListener`:\n\n[source, java]\n----\n@Configuration\n@EnableIntegration\n@EnablePublisher\npublic static class ContextConfiguration {\n\n @Bean\n QueueChannel eventFromPublisher() {\n return new QueueChannel();\n }\n\n @EventListener\n @Publisher(\"eventFromPublisher\")\n public String publishEventToChannel(TestApplicationEvent3 testApplicationEvent3) {\n return testApplicationEvent3.getSource().toString();\n }\n\n}\n----\n\nIn this case a return value of the event listener method is used as a payload for a `Message` to be published to that `eventFromPublisher` channel.\nSee more information about the `@Publisher` in the xref:message-publishing.adoc#publisher-annotation[Annotation-driven Configuration] section.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/event.adoc", "title": "event", "heading": "Sending Spring Application Events", "heading_level": 2, "file_order": 206, "section_index": 2, "content_hash": "1fdf27b0a25020635b1d3315803c0434eb906a0cc2064c12e8d4a50f08419447", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/event.adoc"}}
{"id": "sha256:b5563cf9356cd998907edb496a7a8b857969992c86039dd44fdf51376a7e442a", "content": "[[feed]]\n\nSpring Integration provides support for syndication through feed adapters.\nThe implementation is based on the https://rometools.github.io/rome/[ROME Framework].\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-feed</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-feed:{project-version}\"\n----\n======\n\nWeb syndication is a way to publish material such as news stories, press releases, blog posts, and other items typically available on a website but also made available in a feed format such as RSS or ATOM.\n\nSpring integration provides support for web syndication through its 'feed' adapter and provides convenient namespace-based configuration for it.\nTo configure the 'feed' namespace, include the following elements within the headers of your XML configuration file:\n\n[source,xml]\n----\nxmlns:int-feed=\"http://www.springframework.org/schema/integration/feed\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/integration/feed\n\thttps://www.springframework.org/schema/integration/feed/spring-integration-feed.xsd\"\n----\n\n[[feed-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/feed.adoc", "title": "feed", "heading": "feed", "heading_level": 1, "file_order": 207, "section_index": 0, "content_hash": "b5563cf9356cd998907edb496a7a8b857969992c86039dd44fdf51376a7e442a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/feed.adoc"}}
{"id": "sha256:7207e630bf786540e0cd6785851156f4fd5762d4c0f76fbb629e6a1481a45a97", "content": "The only adapter you really need to provide support for retrieving feeds is an inbound channel adapter.\nIt lets you subscribe to a particular URL.\nThe following example shows a possible configuration:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Configuration\n@EnableIntegration\npublic class ContextConfiguration {\n\n @Value(\"org/springframework/integration/feed/sample.rss\")\n private Resource feedResource;\n\n @Bean\n public IntegrationFlow feedFlow() {\n return IntegrationFlow\n .from(Feed.inboundAdapter(this.feedResource, \"feedTest\")\n .preserveWireFeed(true),\n e -> e.poller(p -> p.fixedDelay(100)))\n .channel(c -> c.queue(\"entries\"))\n .get();\n }\n\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\n@InboundChannelAdapter(inputChannel = \"fromFeed\")\npublic FeedEntryMessageSource feedEntrySource() {\n return new FeedEntryMessageSource(\"https://feeds.bbci.co.uk/news/rss.xml\", \"metadataKey\");\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-feed:inbound-channel-adapter id=\"feedAdapter\"\n channel=\"feedChannel\"\n url=\"https://feeds.bbci.co.uk/news/rss.xml\">\n <int:poller fixed-rate=\"10000\" max-messages-per-poll=\"100\" />\n</int-feed:inbound-channel-adapter>\n----\n======\n\nIn the preceding configuration, we are subscribing to a URL identified by the `url` attribute.\n\nAs news items are retrieved, they are converted to messages and sent to a channel identified by the `channel` attribute.\nThe payload of each message is a `com.rometools.rome.feed.synd.SyndEntry` instance.\nEach one encapsulates various data about a news item (content, dates, authors, and other details).\n\nThe inbound feed channel adapter is a polling consumer.\nThat means that you must provide a poller configuration.\nHowever, one important thing you must understand with regard to a feed is that its inner workings are slightly different, then most other polling consumers.\nWhen an inbound feed adapter is started, it does the first poll and receives a `com.rometools.rome.feed.synd.SyndFeed` instance.\nThat object contains multiple `SyndEntry` objects.\nEach entry is stored in the local entry queue and is released based on the value in the `max-messages-per-poll` attribute, such that each message contains a single entry.\nIf, during retrieval of the entries from the entry queue, the queue has become empty, the adapter attempts to update the feed, thereby populating the queue with more entries (`SyndEntry` instances), if any are available.\nOtherwise, the next attempt to poll for a feed is determined by the trigger of the poller (every ten seconds in the preceding configuration).\n\n[[duplicate-entries]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/feed.adoc", "title": "feed", "heading": "Feed Inbound Channel Adapter", "heading_level": 2, "file_order": 207, "section_index": 1, "content_hash": "7207e630bf786540e0cd6785851156f4fd5762d4c0f76fbb629e6a1481a45a97", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/feed.adoc"}}
{"id": "sha256:9c299e5450f72995870e9a851cd00d8c4535c9a5bebc2e005db3819909581939", "content": "Polling for a feed can result in entries that have already been processed (\"`I already read that news item, why are you showing it to me again?`\").\nSpring Integration provides a convenient mechanism to eliminate the need to worry about duplicate entries.\nEach feed entry has a \"`published date`\" field.\nEvery time a new `Message` is generated and sent, Spring Integration stores the value of the latest published date in an instance of the `MetadataStore` strategy (see xref:meta-data-store.adoc[Metadata Store]).\nThe `metadataKey` is used to persist the latest published date.\n\n[[other-options]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/feed.adoc", "title": "feed", "heading": "Duplicate Entries", "heading_level": 2, "file_order": 207, "section_index": 2, "content_hash": "9c299e5450f72995870e9a851cd00d8c4535c9a5bebc2e005db3819909581939", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/feed.adoc"}}
{"id": "sha256:0fdf834ab737f9f384390000dc515ccd99fdf9e4868e58319bfd03780afcc28b", "content": "Starting with version 5.0, the deprecated `com.rometools.fetcher.FeedFetcher` option has been removed and an overloaded `FeedEntryMessageSource` constructor for an `org.springframework.core.io.Resource` is provided.\nThis is useful when the feed source is not an HTTP endpoint but is any other resource (such as local or remote on FTP).\nIn the `FeedEntryMessageSource` logic, such a resource (or provided `URL`) is parsed by the `SyndFeedInput` to the `SyndFeed` object for the processing mentioned earlier.\nYou can also inject a customized `SyndFeedInput` (for example, with the `allowDoctypes` option) instance into the `FeedEntryMessageSource`.\n\n[NOTE]\n====\nIf the connection to the feed needs some customization, e.g. connection and read timeouts, the `org.springframework.core.io.UrlResource` extension with its `customizeConnection(HttpURLConnection)` override has to be used instead of plain `URL` injection into the `FeedEntryMessageSource`.\nFor example:\n\n[source, java]\n----\n@Bean\n@InboundChannelAdapter(\"feedChannel\")\nFeedEntryMessageSource feedEntrySource() {\n UrlResource urlResource =\n new UrlResource(url) {\n\n @Override\n protected void customizeConnection(HttpURLConnection connection) throws IOException {\n super.customizeConnection(connection);\n connection.setConnectTimeout(10000);\n connection.setReadTimeout(5000);\n }\n };\n return new FeedEntryMessageSource(urlResource, \"myKey\");\n}\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/feed.adoc", "title": "feed", "heading": "Other Options", "heading_level": 2, "file_order": 207, "section_index": 3, "content_hash": "0fdf834ab737f9f384390000dc515ccd99fdf9e4868e58319bfd03780afcc28b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/feed.adoc"}}
{"id": "sha256:5d9ba38595f85ed7f897fc552e30ef7729171a92e4f7bd8b771aac27dfde3ae6", "content": "[[files]]\n\nSpring Integration's file support extends the Spring Integration core with a dedicated vocabulary to deal with reading, writing, and transforming files.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-file</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-file:{project-version}\"\n----\n======\n\nIt provides a namespace that enables elements defining channel adapters dedicated to files and support for transformers that can read file contents into strings or byte arrays.\n\nThis section explains the workings of `FileReadingMessageSource` and `FileWritingMessageHandler` and how to configure them as beans.\nIt also discusses the support for dealing with files through file-specific implementations of `Transformer`.\nFinally, it explains the file-specific namespace.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/file.adoc", "title": "file", "heading": "file", "heading_level": 1, "file_order": 208, "section_index": 0, "content_hash": "5d9ba38595f85ed7f897fc552e30ef7729171a92e4f7bd8b771aac27dfde3ae6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/file.adoc"}}
{"id": "sha256:2abe6253f7a9a679c42cf4635212e06877c84cef358899c41102cb3cb5d5045d", "content": "[[filter]]\n\nMessage filters are used to decide whether a `Message` should be passed along or dropped based on some criteria, such as a message header value or message content itself.\nTherefore, a message filter is similar to a router, except that, for each message received from the filter's input channel, that same message may or may not be sent to the filter's output channel.\nUnlike the router, it makes no decision regarding which message channel to send the message to but decides only whether to send the message at all.\n\nNOTE: As we describe later in this section, the filter also supports a discard channel.\nIn certain cases, it can play the role of a very simple router (or \"`switch`\"), based on a boolean condition.\n\nIn Spring Integration, you can configure a message filter as a message endpoint that delegates to an implementation of the `MessageSelector` interface.\nThat interface is itself quite simple, as the following listing shows:\n\n[source,java]\n----\npublic interface MessageSelector {\n\n boolean accept(Message<?> message);\n\n}\n----\n\nThe `MessageFilter` constructor accepts a selector instance, as the following example shows:\n\n[source,java]\n----\nMessageFilter filter = new MessageFilter(someSelector);\n----\n\n[[filter-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/filter.adoc", "title": "filter", "heading": "filter", "heading_level": 1, "file_order": 209, "section_index": 0, "content_hash": "2abe6253f7a9a679c42cf4635212e06877c84cef358899c41102cb3cb5d5045d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/filter.adoc"}}
{"id": "sha256:e2d60d96862cc57bf513d8e0369d403aea444398ed43046323b0548a3382f085", "content": "The `IntegrationFlowBuilder` provided by the Java DSL, which is also used as a base for the Groovy and Kotlin DSLs, provides a number of overloaded methods for the `filter()` operator.\nThe `MessageSelector` abstraction mentioned above can be used as a Lambda in a `filter()` definition:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return f -> f\n .<String>filter((payload) -> !\"junk\".equals(payload));\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun someFlow() =\n integrationFlow {\n filter<String> { it != \"junk\" }\n }\n----\n\nGroovy DSL::\n+\n[source, groovy, role=\"secondary\"]\n----\n@Bean\nsomeFlow() {\n integrationFlow {\n filter String, { it != 'junk' }\n }\n}\n----\n======\n\nSee more information about DSLs in the respective chapters:\n\n* xref:dsl.adoc#java-dsl[Java DSL]\n* xref:kotlin-dsl.adoc[Kotlin DSL]\n* xref:groovy-dsl.adoc[Groovy DSL]\n\n[[filter-xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/filter.adoc", "title": "filter", "heading": "Configuring a Filter with Java, Groovy and Kotlin DSLs", "heading_level": 2, "file_order": 209, "section_index": 1, "content_hash": "e2d60d96862cc57bf513d8e0369d403aea444398ed43046323b0548a3382f085", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/filter.adoc"}}
{"id": "sha256:cc59ba3d405b88fa68022a070d0dec4211033234b93e1f142903de61775e8c93", "content": "In combination with the namespace and SpEL, you can configure powerful filters with very little Java code.\n\nYou can use the `<filter>` element is used to create a message-selecting endpoint.\nIn addition to `input-channel` and `output-channel` attributes, it requires a `ref` attribute.\nThe `ref` can point to a `MessageSelector` implementation, as the following example shows:\n\n[source,xml]\n----\n<int:filter input-channel=\"input\" ref=\"selector\" output-channel=\"output\"/>\n\n<bean id=\"selector\" class=\"example.MessageSelectorImpl\"/>\n----\n\nAlternatively, you can add the `method` attribute.\nIn that case, the `ref` attribute may refer to any object.\nThe referenced method may expect either the `Message` type or the payload type of inbound messages.\nThe method must return a boolean value.\nIf the method returns 'true', the message is sent to the output channel.\nThe following example shows how to configure a filter that uses the `method` attribute:\n\n[source,xml]\n----\n<int:filter input-channel=\"input\" output-channel=\"output\"\n ref=\"exampleObject\" method=\"someBooleanReturningMethod\"/>\n\n<bean id=\"exampleObject\" class=\"example.SomeObject\"/>\n----\n\nIf the selector or adapted POJO method returns `false`, a few settings control the handling of the rejected message.\nBy default, if configured as in the preceding example, rejected messages are silently dropped.\nIf rejection should instead result in an error condition, set the `throw-exception-on-rejection` attribute to `true`, as the following example shows:\n\n[source,xml]\n----\n<int:filter input-channel=\"input\" ref=\"selector\"\n output-channel=\"output\" throw-exception-on-rejection=\"true\"/>\n----\n\nIf you want rejected messages to be routed to a specific channel, provide that reference as the `discard-channel`, as the following example shows:\n\n[source,xml]\n----\n<int:filter input-channel=\"input\" ref=\"selector\"\n output-channel=\"output\" discard-channel=\"rejectedMessages\"/>\n----\n\nIf the `throwExceptionOnRejection == false` and no `discardChannel` is provided, the message is silently dropped and an `o.s.i.filter.MessageFilter` instance just emits a warning log message (starting with version 6.1) about this discarded message.\nTo drop the message with no warning in the logs, a `NullChannel` can be configured as the `discardChannel` on the filter.\nThe goal of the framework is to not be completely silent, by default, requiring an explicit option to be set, if that is the desired behavior.\n\nSee also xref:handler-advice/advising-filters.adoc[Advising Filters].\n\nNOTE: Message filters are commonly used in conjunction with a publish-subscribe channel.\nMany filter endpoints may be subscribed to the same channel, and they decide whether to pass the message to the next endpoint, which could be any of the supported types (such as a service activator).\nThis provides a reactive alternative to the more proactive approach of using a message router with a single point-to-point input channel and multiple output channels.\n\nWe recommend using a `ref` attribute if the custom filter implementation is referenced in other `<filter>` definitions.\nHowever, if the custom filter implementation is scoped to a single `<filter>` element, you should provide an inner bean definition, as the following example shows:\n\n[source,xml]\n----\n<int:filter method=\"someMethod\" input-channel=\"inChannel\" output-channel=\"outChannel\">\n <beans:bean class=\"org.foo.MyCustomFilter\"/>\n</filter>\n----\n\nNOTE: Using both the `ref` attribute and an inner handler definition in the same `<filter>` configuration is not allowed, as it creates an ambiguous condition and throws an exception.\n\nIMPORTANT: If the `ref` attribute references a bean that extends `MessageFilter` (such as filters provided by the framework itself), the configuration is optimized by injecting the output channel into the filter bean directly.\nIn this case, each `ref` must be to a separate bean instance (or a `prototype`-scoped bean) or use the inner `<bean/>` configuration type.\nHowever, this optimization applies only if you do not provide any filter-specific attributes in the filter XML definition.\nIf you inadvertently reference the same message handler from multiple beans, you get a configuration exception.\n\nWith the introduction of SpEL support, Spring Integration added the `expression` attribute to the filter element.\nIt can be used to avoid Java entirely for simple filters, as the following example shows:\n\n[source,xml]\n----\n<int:filter input-channel=\"input\" expression=\"payload.equals('nonsense')\"/>\n----\n\nThe string passed as the value of the expression attribute is evaluated as a SpEL expression with the message available in the evaluation context.\nIf you must include the result of an expression in the scope of the application context, you can use the `#{}` notation, as defined in the https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions-beandef[SpEL reference documentation], as the following example shows:\n\n[source,xml]\n----\n<int:filter input-channel=\"input\"\n expression=\"payload.matches(#{filterPatterns.nonsensePattern})\"/>\n----\n\nIf the expression itself needs to be dynamic, you can use an 'expression' subelement.\nThat provides a level of indirection for resolving the expression by its key from an `ExpressionSource`.\nThat is a strategy interface that you can implement directly, or you can rely upon a version available in Spring Integration that loads expressions from a \"`resource bundle`\" and can check for modifications after a given number of seconds.\nAll of this is demonstrated in the following configuration example, where the expression could be reloaded within one minute if the underlying file had been modified:\n\n[source,xml]\n----\n<int:filter input-channel=\"input\" output-channel=\"output\">\n <int:expression key=\"filterPatterns.example\" source=\"myExpressions\"/>\n</int:filter>\n\n<beans:bean id=\"myExpressions\"\n class=\"o.s.i.expression.ReloadableResourceBundleExpressionSource\">\n <beans:property name=\"basename\" value=\"config/integration/expressions\"/>\n <beans:property name=\"cacheSeconds\" value=\"60\"/>\n</beans:bean>\n----\n\nIf the `ExpressionSource` bean is named `expressionSource`, you need not provide the `source` attribute on the `<expression>` element.\nHowever, in the preceding example, we show it for completeness.\n\nThe 'config/integration/expressions.properties' file (or any more-specific version with a locale extension to be resolved in the typical way that resource-bundles are loaded) can contain a key/value pair, as the following example shows:\n\n[source]\n----\nfilterPatterns.example=payload > 100\n----\n\nNOTE: All of these examples that use `expression` as an attribute or subelement can also be applied within transformer, router, splitter, service-activator, and header-enricher elements.\nThe semantics and role of the given component type would affect the interpretation of the evaluation result in the same way that the return value of a method-invocation would be interpreted.\nFor example, an expression can return strings that are to be treated as message channel names by a router component.\nHowever, the underlying functionality of evaluating the expression against the message as the root object and resolving bean names if prefixed with '@' is consistent across all of the core EIP components within Spring Integration.\n\n[[filter-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/filter.adoc", "title": "filter", "heading": "Configuring a Filter with XML", "heading_level": 2, "file_order": 209, "section_index": 2, "content_hash": "cc59ba3d405b88fa68022a070d0dec4211033234b93e1f142903de61775e8c93", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/filter.adoc"}}
{"id": "sha256:59d352307659c2b67e033de5d40a7c29fe17b8b21ce2b20a69f1f95297908852", "content": "The following example shows how to configure a filter by using annotations:\n\n[source,java]\n----\npublic class PetFilter {\n ...\n @Filter <1>\n public boolean dogsOnly(String input) {\n ...\n }\n}\n----\n\n<1> An annotation indicating that this method is to be used as a filter.\nIt must be specified if this class is to be used as a filter.\n\nAll the configuration options provided by the XML element are also available for the `@Filter` annotation.\n\nThe filter can be either referenced explicitly from XML or, if the `@MessageEndpoint` annotation is defined on the class, detected automatically through classpath scanning.\n\nSee also xref:handler-advice/advising-with-annotations.adoc[Advising Endpoints Using Annotations].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/filter.adoc", "title": "filter", "heading": "Configuring a Filter with Annotations", "heading_level": 2, "file_order": 209, "section_index": 3, "content_hash": "59d352307659c2b67e033de5d40a7c29fe17b8b21ce2b20a69f1f95297908852", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/filter.adoc"}}
{"id": "sha256:1e9e7ee3e213729e2d29c55dca11a5e27dc712a39089219c8468878916d8878e", "content": "[[ftp]]\n\nSpring Integration provides support for file transfer operations with FTP and FTPS.\n\nThe File Transfer Protocol (FTP) is a simple network protocol that lets you transfer files between two computers on the Internet.\nFTPS stands for \"`FTP over SSL`\".\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-ftp</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-ftp:{project-version}\"\n----\n======\n\nThere are two actors when it comes to FTP communication: client and server.\nTo transfer files with FTP or FTPS, you use a client that initiates a connection to a remote computer that is running an FTP server.\nAfter the connection is established, the client can choose to send or receive copies of files.\n\nSpring Integration supports sending and receiving files over FTP or FTPS by providing three client-side endpoints: inbound channel adapter, outbound channel adapter, and outbound gateway.\nIt also provides convenient namespace-based configuration options for defining these client components.\n\nTo use the FTP namespace, add the following to the header of your XML file:\n\n[source,xml]\n----\nxmlns:int-ftp=\"http://www.springframework.org/schema/integration/ftp\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/integration/ftp\n https://www.springframework.org/schema/integration/ftp/spring-integration-ftp.xsd\"\n\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ftp.adoc", "title": "ftp", "heading": "ftp", "heading_level": 1, "file_order": 210, "section_index": 0, "content_hash": "1e9e7ee3e213729e2d29c55dca11a5e27dc712a39089219c8468878916d8878e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ftp.adoc"}}
{"id": "sha256:f901dc9ce3d0a68bcef146975836972f9deb1e2846921c30415da38be8e86455", "content": "[[functions-support]]\n\nStarting with version 5.1, Spring Integration provides direct support for interfaces in the `java.util.function` package.\nAll messaging endpoints, (Service Activator, Transformer, Filter, etc.) can now refer to `Function` (or `Consumer`) beans.\nThe xref:configuration/annotations.adoc[Messaging Annotations] can be applied directly on these beans similar to regular `MessageHandler` definitions.\nFor example, if you have this `Function` bean definition:\n\n[source, java]\n----\n@Configuration\npublic class FunctionConfiguration {\n\n @Bean\n public Function<String, String> functionAsService() {\n return String::toUpperCase;\n }\n\n}\n----\n\nYou can use it as a simple reference in an XML configuration file:\n\n[source, xml]\n----\n<service-activator input-channel=\"processorViaFunctionChannel\" ref=\"functionAsService\"/>\n----\n\nWhen we configure our flow with Messaging Annotations, the code is straightforward:\n\n[source, java]\n----\n@Bean\n@Transformer(inputChannel = \"functionServiceChannel\")\npublic Function<String, String> functionAsService() {\n return String::toUpperCase;\n}\n----\n\nWhen the function returns an array, `Collection` (essentially, any `Iterable`), `Stream` or Reactor `Flux`, `@Splitter` can be used on such a bean to perform iteration over the result content.\n\nThe `java.util.function.Consumer` interface can be used for an `<int:outbound-channel-adapter>` or, together with the `@ServiceActivator` annotation, to perform the final step of a flow:\n\n[source, java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"messageConsumerServiceChannel\")\npublic Consumer<Message<?>> messageConsumerAsService() {\n // Has to be an anonymous class for proper type inference\n return new Consumer<Message<?>>() {\n\n @Override\n public void accept(Message<?> e) {\n collector().add(e);\n }\n\n };\n}\n----\n\nAlso, pay attention to the comment in the code snippet above: if you would like to deal with the whole message in your `Function`/`Consumer` you cannot use a lambda definition.\nBecause of Java type erasure we cannot determine the target type for the `apply()/accept()` method call.\n\nThe `java.util.function.Supplier` interface can simply be used together with the `@InboundChannelAdapter` annotation, or as a `ref` in an `<int:inbound-channel-adapter>`:\n\n[source, java]\n----\n@Bean\n@InboundChannelAdapter(value = \"inputChannel\", poller = @Poller(fixedDelay = \"1000\"))\npublic Supplier<String> pojoSupplier() {\n return () -> \"foo\";\n}\n----\n\nWith the Java DSL we just need to use a reference to the function bean in the endpoint definitions.\nMeanwhile, an implementation of the `Supplier` interface can be used as regular `MessageSource` definition:\n\n[source, java]\n----\n@Bean\npublic Function<String, String> toUpperCaseFunction() {\n return String::toUpperCase;\n}\n\n@Bean\npublic Supplier<String> stringSupplier() {\n return () -> \"foo\";\n}\n\n@Bean\npublic IntegrationFlow supplierFlow() {\n return IntegrationFlow.from(stringSupplier())\n .transform(toUpperCaseFunction())\n .channel(\"suppliedChannel\")\n .get();\n}\n----\n\nThis function support is useful when used together with the https://cloud.spring.io/spring-cloud-function/[Spring Cloud Function] framework, where we have a function catalog and can refer to its member functions from an integration flow definition.\n\nAlso, many Spring Integration channel adapters and patterns are implemented as function autoconfiguration in the https://github.com/spring-cloud/spring-functions-catalog[Spring Functions Catalog] project.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/functions-support.adoc", "title": "functions-support", "heading": "functions-support", "heading_level": 1, "file_order": 211, "section_index": 0, "content_hash": "f901dc9ce3d0a68bcef146975836972f9deb1e2846921c30415da38be8e86455", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/functions-support.adoc"}}
{"id": "sha256:0bacc3813e36de80e1ea6cae693c9cd0880cbccb7afa9c0a69cb0a1aa23b5723", "content": "[[gateway]]\n\nA gateway hides the messaging API provided by Spring Integration.\nIt lets your application's business logic be unaware of the Spring Integration API.\nBy using a generic Gateway, your code interacts with only a simple interface.\n\n[[gateway-proxy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "gateway", "heading_level": 1, "file_order": 212, "section_index": 0, "content_hash": "0bacc3813e36de80e1ea6cae693c9cd0880cbccb7afa9c0a69cb0a1aa23b5723", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:7295bb2727dc7db031a40c084fcf4562692a054b3e0b112b613dfa57d3e0fbf8", "content": "As mentioned earlier, it would be great to have no dependency on the Spring Integration API -- including the gateway class.\nFor that reason, Spring Integration provides the `GatewayProxyFactoryBean`, which generates a proxy for any interface and internally invokes the gateway methods shown below.\nBy using dependency injection, you can then expose the interface to your business methods.\n\nThe following example shows an interface that can be used to interact with Spring Integration:\n\n[source,java]\n----\npackage org.cafeteria;\n\npublic interface Cafe {\n\n void placeOrder(Order order);\n\n}\n----\n\n[[gateway-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Enter the `GatewayProxyFactoryBean`", "heading_level": 2, "file_order": 212, "section_index": 1, "content_hash": "7295bb2727dc7db031a40c084fcf4562692a054b3e0b112b613dfa57d3e0fbf8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:6158e83a5bc71fd8cf638ae1b49845690a8689eaf362b6020924ea08fa44e497", "content": "Namespace support is also provided.\nIt lets you configure an interface as a service, as the following example shows:\n\n[source,xml]\n----\n<int:gateway id=\"cafeService\"\n service-interface=\"org.cafeteria.Cafe\"\n default-request-channel=\"requestChannel\"\n default-reply-timeout=\"10000\"\n default-reply-channel=\"replyChannel\"/>\n----\n\nWith this configuration defined, the `cafeService` can now be injected into other beans, and the code that invokes the methods on that proxied instance of the `Cafe` interface has no awareness of the Spring Integration API.\nSee the xref:samples.adoc#samples-impl[\"`Samples`\"] Appendix for an example that uses the `gateway` element (in the Caf demo).\n\nThe defaults in the preceding configuration are applied to all methods on the gateway interface.\nIf a reply timeout is not specified, the calling thread waits for a reply for 30 seconds.\nSee xref:gateway.adoc#gateway-no-response[Gateway Behavior When No response Arrives].\n\nThe defaults can be overridden for individual methods.\nSee xref:gateway.adoc#gateway-configuration-annotations[Gateway Configuration with Annotations and XML].\n\n[[gateway-default-reply-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Gateway XML Namespace Support", "heading_level": 2, "file_order": 212, "section_index": 2, "content_hash": "6158e83a5bc71fd8cf638ae1b49845690a8689eaf362b6020924ea08fa44e497", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:147de40f580204bb18a8bc9c3adceb2da62748c7db04aa9a48812f372271c100", "content": "Typically, you need not specify the `default-reply-channel`, since a Gateway auto-creates a temporary, anonymous reply channel, where it listens for the reply.\nHowever, some cases may prompt you to define a `default-reply-channel` (or `reply-channel` with adapter gateways, such as HTTP, JMS, and others).\n\nFor some background, we briefly discuss some inner workings of the gateway.\nA gateway creates a temporary point-to-point reply channel.\nIt is anonymous and is added to the message headers with the name, `replyChannel`.\nWhen providing an explicit `default-reply-channel` (`reply-channel` with remote adapter gateways), you can point to a publish-subscribe channel, which is so named because you can add more than one subscriber to it.\nInternally, Spring Integration creates a bridge between the temporary `replyChannel` and the explicitly defined `default-reply-channel`.\n\nSuppose you want your reply to go not only to the gateway but also to some other consumer.\nIn this case, you want two things:\n\n* A named channel to which you can subscribe\n* That channel to be a publish-subscribe-channel\n\nThe default strategy used by the gateway does not satisfy those needs because the reply channel added to the header is anonymous and point-to-point.\nThis means that no other subscriber can get a handle on it and, even if it could, the channel has point-to-point behavior such that only one subscriber would get the message.\nBy defining a `default-reply-channel` you can point to a channel of your choosing.\nIn this case, that is a `publish-subscribe-channel`.\nThe gateway creates a bridge from it to the temporary, anonymous reply channel that is stored in the header.\n\nYou might also want to explicitly provide a reply channel for monitoring or auditing through an interceptor (for example, xref:channel/configuration.adoc#channel-wiretap[wiretap]).\nTo configure a channel interceptor, you need a named channel.\n\nNOTE: Starting with version 5.4, when gateway method return type is `void`, the framework populates a `replyChannel` header as a `nullChannel` bean reference if such a header is not provided explicitly.\nThis allows any possible reply from the downstream flow to be discarded, meeting the one-way gateway contract.\n\n[[gateway-configuration-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Setting the Default Reply Channel", "heading_level": 2, "file_order": 212, "section_index": 3, "content_hash": "147de40f580204bb18a8bc9c3adceb2da62748c7db04aa9a48812f372271c100", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:db9a6b93cb8d9315f0fe5ed194f684b06ab98d7277f26c5a6148e5ee7fa97d4d", "content": "Consider the following example, which expands on the previous `Cafe` interface example by adding a `@Gateway` annotation:\n\n[source,java]\n----\npublic interface Cafe {\n\n @Gateway(requestChannel=\"orders\")\n void placeOrder(Order order);\n\n}\n----\n\nThe `@Header` annotation lets you add values that are interpreted as message headers, as the following example shows:\n\n[source,java]\n----\npublic interface FileWriter {\n\n @Gateway(requestChannel=\"filesOut\")\n void write(byte[] content, @Header(FileHeaders.FILENAME) String filename);\n\n}\n----\n\nIf you prefer the XML approach to configuring gateway methods, you can add `method` elements to the gateway configuration, as the following example shows:\n\n[source,xml]\n----\n<int:gateway id=\"myGateway\" service-interface=\"org.foo.bar.TestGateway\"\n default-request-channel=\"inputC\">\n <int:default-header name=\"calledMethod\" expression=\"#gatewayMethod.name\"/>\n <int:method name=\"echo\" request-channel=\"inputA\" reply-timeout=\"2\" request-timeout=\"200\"/>\n <int:method name=\"echoUpperCase\" request-channel=\"inputB\"/>\n <int:method name=\"echoViaDefault\"/>\n</int:gateway>\n----\n\nYou can also use XML to provide individual headers for each method invocation.\nThis could be useful if the headers you want to set are static in nature, and you do not want to embed them in the gateway's method signature by using `@Header` annotations.\nFor example, in the loan broker example, we want to influence how aggregation of the loan quotes is done, based on what type of request was initiated (single quote or all quotes).\nDetermining the type of the request by evaluating which gateway method was invoked, although possible, would violate the separation of concerns paradigm (the method is a Java artifact).\nHowever, expressing your intention (meta-information) in message headers is natural in a messaging architecture.\nThe following example shows how to add a different message header for each of two methods:\n\n[source,xml]\n----\n<int:gateway id=\"loanBrokerGateway\"\n service-interface=\"org.springframework.integration.loanbroker.LoanBrokerGateway\">\n <int:method name=\"getLoanQuote\" request-channel=\"loanBrokerPreProcessingChannel\">\n <int:header name=\"RESPONSE_TYPE\" value=\"BEST\"/>\n </int:method>\n <int:method name=\"getAllLoanQuotes\" request-channel=\"loanBrokerPreProcessingChannel\">\n <int:header name=\"RESPONSE_TYPE\" value=\"ALL\"/>\n </int:method>\n</int:gateway>\n----\n\nIn the preceding example a different value is set for the 'RESPONSE_TYPE' header, based on the gateway's method.\n\nIMPORTANT: If you specify, for example, the `requestChannel` in `<int:method/>` as well as in a `@Gateway` annotation, the annotation value wins.\n\nNOTE: If a no-argument gateway is specified in XML, and the interface method has both a `@Payload` and `@Gateway` annotation (with a `payloadExpression` or a `payload-expression` in an `<int:method/>` element), the `@Payload` value is ignored.\n\n[[gateway-expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Gateway Configuration with Annotations and XML", "heading_level": 2, "file_order": 212, "section_index": 4, "content_hash": "db9a6b93cb8d9315f0fe5ed194f684b06ab98d7277f26c5a6148e5ee7fa97d4d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:c1c3700b76d68e93223289b69c38cf759a405197f8e8d87117a9f035bd6aef5b", "content": "The `<header/>` element supports `expression` as an alternative to `value`.\nThe SpEL expression is evaluated to determine the value of the header.\nStarting with version 5.2, the `#root` object of the evaluation context is a `MethodArgsHolder` with `getMethod()` and `getArgs()` accessors.\nFor example, if you wish to route on the simple method name, you might add a header with the following expression: `method.name`.\n\nNOTE: The `java.reflect.Method` is not serializable.\nA header with an expression of `method` is lost if you later serialize the message.\nConsequently, you may wish to use `method.name` or `method.toString()` in those cases.\nThe `toString()` method provides a `String` representation of the method, including parameter and return types.\n\nSince version 3.0, `<default-header/>` elements can be defined to add headers to all the messages produced by the gateway, regardless of the method invoked.\nSpecific headers defined for a method take precedence over default headers.\nSpecific headers defined for a method here override any `@Header` annotations in the service interface.\nHowever, default headers do NOT override any `@Header` annotations in the service interface.\n\nThe gateway now also supports a `default-payload-expression`, which is applied for all methods (unless overridden).\n\n[[gateway-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Expressions and \"`Global`\" Headers", "heading_level": 3, "file_order": 212, "section_index": 5, "content_hash": "c1c3700b76d68e93223289b69c38cf759a405197f8e8d87117a9f035bd6aef5b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:68ed1e8aa2c5b305da6f258cf5e6aa72e63c65bc64faf0412b3e026c1e3a062b", "content": "Using the configuration techniques in the previous section allows control of how method arguments are mapped to message elements (payload and headers).\nWhen no explicit configuration is used, certain conventions are used to perform the mapping.\nIn some cases, these conventions cannot determine which argument is the payload and which should be mapped to headers.\nConsider the following example:\n\n[source,java]\n----\npublic String send1(Object thing1, Map thing2);\n\npublic String send2(Map thing1, Map thing2);\n----\n\nIn the first case, the convention is to map the first argument to the payload (as long as it is not a `Map`) and the contents of the second argument become headers.\n\nIn the second case (or the first when the argument for parameter `thing1` is a `Map`), the framework cannot determine which argument should be the payload.\nConsequently, mapping fails.\nThis can generally be resolved using a `payload-expression`, a `@Payload` annotation, or a `@Headers` annotation.\n\nAlternatively (and whenever the conventions break down), you can take the entire responsibility for mapping the method calls to messages.\nTo do so, implement an `MethodArgsMessageMapper` and provide it to the `<gateway/>` by using the `mapper` attribute.\nThe mapper maps a `MethodArgsHolder`, which is a simple class that wraps the `java.reflect.Method` instance and an `Object[]` containing the arguments.\nWhen providing a custom mapper, the `default-payload-expression` attribute and `<default-header/>` elements are not allowed on the gateway.\nSimilarly, the `payload-expression` attribute and `<header/>` elements are not allowed on any `<method/>` elements.\n\n[[mapping-method-arguments]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Mapping Method Arguments to a Message", "heading_level": 2, "file_order": 212, "section_index": 6, "content_hash": "68ed1e8aa2c5b305da6f258cf5e6aa72e63c65bc64faf0412b3e026c1e3a062b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:fa1dbf1512ec261a3880f8b0745cc0728b5004ef455da1979ec5f20a9a7fd48e", "content": "The following examples show how method arguments can be mapped to the message and shows some examples of invalid configuration:\n\n[source,java]\n----\npublic interface MyGateway {\n\n void payloadAndHeaderMapWithoutAnnotations(String s, Map<String, Object> map);\n\n void payloadAndHeaderMapWithAnnotations(@Payload String s, @Headers Map<String, Object> map);\n\n void headerValuesAndPayloadWithAnnotations(@Header(\"k1\") String x, @Payload String s, @Header(\"k2\") String y);\n\n void mapOnly(Map<String, Object> map); // the payload is the map and no custom headers are added\n\n void twoMapsAndOneAnnotatedWithPayload(@Payload Map<String, Object> payload, Map<String, Object> headers);\n\n @Payload(\"args[0] + args[1] + '!'\")\n void payloadAnnotationAtMethodLevel(String a, String b);\n\n @Payload(\"@someBean.exclaim(args[0])\")\n void payloadAnnotationAtMethodLevelUsingBeanResolver(String s);\n\n void payloadAnnotationWithExpression(@Payload(\"toUpperCase()\") String s);\n\n void payloadAnnotationWithExpressionUsingBeanResolver(@Payload(\"@someBean.sum(#this)\") String s); // <1>\n\n // invalid\n void twoMapsWithoutAnnotations(Map<String, Object> m1, Map<String, Object> m2);\n\n // invalid\n void twoPayloads(@Payload String s1, @Payload String s2);\n\n // invalid\n void payloadAndHeaderAnnotationsOnSameParameter(@Payload @Header(\"x\") String s);\n\n // invalid\n void payloadAndHeadersAnnotationsOnSameParameter(@Payload @Headers Map<String, Object> map);\n\n}\n----\n\n<1> Note that, in this example, the SpEL variable, `#this`, refers to the argument -- in this case, the value of `s`.\n\nThe XML equivalent looks a little different, since there is no `#this` context for the method argument.\nHowever, expressions can refer to method arguments by using the `args` property for the `MethodArgsHolder` root object (see xref:gateway.adoc#gateway-expressions[Expressions and \"`Global`\" Headers] for more information), as the following example shows:\n\n[source,xml]\n----\n<int:gateway id=\"myGateway\" service-interface=\"org.something.MyGateway\">\n <int:method name=\"send1\" payload-expression=\"args[0] + 'thing2'\"/>\n <int:method name=\"send2\" payload-expression=\"@someBean.sum(args[0])\"/>\n <int:method name=\"send3\" payload-expression=\"method\"/>\n <int:method name=\"send4\">\n <int:header name=\"thing1\" expression=\"args[2].toUpperCase()\"/>\n </int:method>\n</int:gateway>\n----\n\n[[messaging-gateway-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Mapping Method Arguments", "heading_level": 3, "file_order": 212, "section_index": 7, "content_hash": "fa1dbf1512ec261a3880f8b0745cc0728b5004ef455da1979ec5f20a9a7fd48e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:1f84bd1ce0b0fab6b844a0a97db1ab5de1eb558052ab39dd3f612f8011a483ee", "content": "Starting with version 4.0, gateway service interfaces can be marked with a `@MessagingGateway` annotation instead of requiring the definition of a `<gateway />` xml element for configuration.\nThe following pair of examples compares the two approaches for configuring the same gateway:\n\n[source,xml]\n----\n<int:gateway id=\"myGateway\" service-interface=\"org.something.TestGateway\"\n default-request-channel=\"inputC\">\n <int:default-header name=\"calledMethod\" expression=\"#gatewayMethod.name\"/>\n <int:method name=\"echo\" request-channel=\"inputA\" reply-timeout=\"2\" request-timeout=\"200\"/>\n <int:method name=\"echoUpperCase\" request-channel=\"inputB\">\n <int:header name=\"thing1\" value=\"thing2\"/>\n </int:method>\n <int:method name=\"echoViaDefault\"/>\n</int:gateway>\n----\n\n[source,java]\n----\n@MessagingGateway(name = \"myGateway\", defaultRequestChannel = \"inputC\",\n defaultHeaders = @GatewayHeader(name = \"calledMethod\",\n expression=\"#gatewayMethod.name\"))\npublic interface TestGateway {\n\n @Gateway(requestChannel = \"inputA\", replyTimeout = 2, requestTimeout = 200)\n String echo(String payload);\n\n @Gateway(requestChannel = \"inputB\", headers = @GatewayHeader(name = \"thing1\", value=\"thing2\"))\n String echoUpperCase(String payload);\n\n String echoViaDefault(String payload);\n\n}\n----\n\nIMPORTANT: Similarly to the XML version, when Spring Integration discovers these annotations during a component scan, it creates the `proxy` implementation with its messaging infrastructure.\nTo perform this scan and register the `BeanDefinition` in the application context, add the `@IntegrationComponentScan` annotation to a `@Configuration` class.\nThe standard `@ComponentScan` infrastructure does not deal with interfaces.\nConsequently, we introduced the custom `@IntegrationComponentScan` logic to find the `@MessagingGateway` annotation on the interfaces and register `GatewayProxyFactoryBean` instances for them.\nSee also xref:configuration/annotations.adoc[Annotation Support].\n\nAlong with the `@MessagingGateway` annotation you can mark a service interface with the `@Profile` annotation to avoid the bean creation, if such a profile is not active.\n\nStarting with version 6.0, an interface with the `@MessagingGateway` can also be marked with a `@Primary` annotation for respective configuration logic as its possible with any Spring `@Component` definition.\n\nStarting with version 6.0, `@MessagingGateway` interfaces can be used in the standard Spring `@Import` configuration.\nThis may be used as an alternative to the `@IntegrationComponentScan` or manual `AnnotationGatewayProxyFactoryBean` bean definitions.\n\nThe `@MessagingGateway` is meta-annotated with a `@MessageEndpoint` since version `6.0` and the `name()` attribute is, essentially, aliased to the `@Component.value()`.\nThis way the bean names generating strategy for gateway proxies is realigned with the standard Spring annotation configuration for scanned and imported components.\nThe default `AnnotationBeanNameGenerator` can be overridden globally via an `AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR` or as a `@IntegrationComponentScan.nameGenerator()` attribute.\n\nNOTE: If you have no XML configuration, the `@EnableIntegration` annotation is required on at least one `@Configuration` class.\nSee xref:overview.adoc#configuration-enable-integration[Configuration and `@EnableIntegration`] for more information.\n\n[[gateway-calling-no-argument-methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "`@MessagingGateway` Annotation", "heading_level": 2, "file_order": 212, "section_index": 8, "content_hash": "1f84bd1ce0b0fab6b844a0a97db1ab5de1eb558052ab39dd3f612f8011a483ee", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:657667f8c66c3f0f4044972cb7a34f5e9511dadd09c08374834b3f64ba520d10", "content": "When invoking methods on a Gateway interface that do not have any arguments, the default behavior is to receive a `Message` from a `PollableChannel`.\n\nSometimes, however, you may want to trigger no-argument methods so that you can interact with other components downstream that do not require user-provided parameters, such as triggering no-argument SQL calls or stored procedures.\n\nTo achieve send-and-receive semantics, you must provide a payload.\nTo generate a payload, method parameters on the interface are not necessary.\nYou can either use the `@Payload` annotation or the `payload-expression` attribute in XML on the `method` element.\nThe following list includes a few examples of what the payloads could be:\n\n* a literal string\n* #gatewayMethod.name\n* new java.util.Date()\n* @someBean.someMethod()'s return value\n\nThe following example shows how to use the `@Payload` annotation:\n\n[source,xml]\n----\npublic interface Cafe {\n\n @Payload(\"new java.util.Date()\")\n List<Order> retrieveOpenOrders();\n\n}\n----\n\nYou can also use the `@Gateway` annotation.\n\n[source,xml]\n----\npublic interface Cafe {\n\n @Gateway(payloadExpression = \"new java.util.Date()\")\n List<Order> retrieveOpenOrders();\n\n}\n----\n\nNOTE: If both annotations are present (and the `payloadExpression` is provided), `@Gateway` wins.\n\nAlso see xref:gateway.adoc#gateway-configuration-annotations[Gateway Configuration with Annotations and XML].\n\nIf a method has no argument and no return value but does contain a payload expression, it is treated as a send-only operation.\n\n[[gateway-calling-default-methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Invoking No-Argument Methods", "heading_level": 2, "file_order": 212, "section_index": 9, "content_hash": "657667f8c66c3f0f4044972cb7a34f5e9511dadd09c08374834b3f64ba520d10", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:01936c09317e41d377d92eea08bfc73500473edb8c333dfcf032780c15dd7416", "content": "An interface for gateway proxy may have `default` methods as well and starting with version 5.3, the framework injects a `DefaultMethodInvokingMethodInterceptor` into a proxy for calling `default` methods using a `java.lang.invoke.MethodHandle` approach instead of proxying.\nThe interfaces from JDK, such as `java.util.function.Function`, still can be used for gateway proxy, but their `default` methods cannot be called because of internal Java security reasons for a `MethodHandles.Lookup` instantiation against JDK classes.\nThese methods also can be proxied (losing their implementation logic and, at the same time, restoring previous gateway proxy behavior) using an explicit `@Gateway` annotation on the method, or `proxyDefaultMethods` on the `@MessagingGateway` annotation or `<gateway>` XML component.\n\n[[gateway-error-handling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Invoking `default` Methods", "heading_level": 2, "file_order": 212, "section_index": 10, "content_hash": "01936c09317e41d377d92eea08bfc73500473edb8c333dfcf032780c15dd7416", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:93c7400a7cc3b8fe6b4afbbdb865bc7b46ee8585e4e4ca78d6cde8dfcb3a3cc7", "content": "The gateway invocation can result in errors.\nBy default, any error that occurs downstream is re-thrown \"`as is`\" upon the gateway's method invocation.\nFor example, consider the following simple flow:\n\n[source]\n----\ngateway -> service-activator\n----\n\nIf the service invoked by the service activator throws a `MyException` (for example), the framework wraps it in a `MessagingException` and attaches the message passed to the service activator in the `failedMessage` property.\nConsequently, any logging performed by the framework has full the context of the failure.\nBy default, when the exception is caught by the gateway, the `MyException` is unwrapped and thrown to the caller.\nYou can configure a `throws` clause on the gateway method declaration to match the particular exception type in the cause chain.\nFor example, if you want to catch a whole `MessagingException` with all the messaging information of the reason of downstream error, you should have a gateway method similar to the following:\n\n[source, java]\n----\npublic interface MyGateway {\n\n void performProcess() throws MessagingException;\n\n}\n----\n\nSince we encourage POJO programming, you may not want to expose the caller to messaging infrastructure.\n\nIf your gateway method does not have a `throws` clause, the gateway traverses the cause tree, looking for a `RuntimeException` that is not a `MessagingException`.\nIf none is found, the framework throws the `MessagingException`.\nIf the `MyException` in the preceding discussion has a cause of `SomeOtherException` and your method `throws SomeOtherException`, the gateway further unwraps that and throws it to the caller.\n\nWhen a gateway is declared with no `service-interface`, an internal framework interface `RequestReplyExchanger` is used.\n\nConsider the following example:\n\n[source, java]\n----\npublic interface RequestReplyExchanger {\n\n\tMessage<?> exchange(Message<?> request) throws MessagingException;\n\n}\n----\n\nBefore version 5.0, this `exchange` method did not have a `throws` clause and, as a result, the exception was unwrapped.\nIf you use this interface and want to restore the previous unwrap behavior, use a custom `service-interface` instead or access the `cause` of the `MessagingException` yourself.\n\nHowever, you may want to log the error rather than propagating it, or you may want to treat an exception as a valid reply (by mapping it to a message that conforms to some \"error message\" contract that the caller understands).\nTo accomplish this, the gateway provides support for a message channel dedicated to the errors by including support for the `error-channel` attribute.\nIn the following example, a 'transformer' creates a reply `Message` from the `Exception`:\n\n[source,xml]\n----\n<int:gateway id=\"sampleGateway\"\n default-request-channel=\"gatewayChannel\"\n service-interface=\"foo.bar.SimpleGateway\"\n error-channel=\"exceptionTransformationChannel\"/>\n\n<int:transformer input-channel=\"exceptionTransformationChannel\"\n ref=\"exceptionTransformer\" method=\"createErrorResponse\"/>\n\n----\n\nThe `exceptionTransformer` could be a simple POJO that knows how to create the expected error response objects.\nThat becomes the payload that is sent back to the caller.\nYou could do many more elaborate things in such an \"`error flow`\", if necessary.\nIt might involve routers (including Spring Integration's `ErrorMessageExceptionTypeRouter`), filters, and so on.\nMost of the time, a simple 'transformer' should be sufficient, however.\n\nAlternatively, you might want to only log the exception (or send it somewhere asynchronously).\nIf you provide a one-way flow, nothing would be sent back to the caller.\nIf you want to completely suppress exceptions, you can provide a reference to the global `nullChannel` (essentially a `/dev/null` approach).\nFinally, as mentioned above, if no `error-channel` is defined, then the exceptions propagate as usual.\n\nWhen you use the `@MessagingGateway` annotation (see `xref:gateway.adoc#messaging-gateway-annotation[`@MessagingGateway` Annotation]`), you can use an `errorChannel` attribute.\n\nStarting with version 5.0, when you use a gateway method with a `void` return type (one-way flow), the `error-channel` reference (if provided) is populated in the standard `errorChannel` header of each sent message.\nThis feature allows a downstream asynchronous flow, based on the standard `ExecutorChannel` configuration (or a `QueueChannel`), to override a default global `errorChannel` exceptions sending behavior.\nPreviously you had to manually specify an `errorChannel` header with the `@GatewayHeader` annotation or the `<header>` element.\nThe `error-channel` property was ignored for `void` methods with an asynchronous flow.\nInstead, error messages were sent to the default `errorChannel`.\n\nIMPORTANT: Exposing the messaging system through simple POJI Gateways provides benefits, but \"`hiding`\" the reality of the underlying messaging system does come at a price, so there are certain things you should consider.\nWe want our Java method to return as quickly as possible and not hang for an indefinite amount of time while the caller is waiting on it to return (whether void, a return value, or a thrown Exception).\nWhen regular methods are used as a proxies in front of the messaging system, we have to take into account the potentially asynchronous nature of the underlying messaging.\nThis means that there might be a chance that a message that was initiated by a gateway could be dropped by a filter and never reach a component that is responsible for producing a reply.\nSome service activator method might result in an exception, thus providing no reply (as we do not generate null messages).\nIn other words, multiple scenarios can cause a reply message to never come.\nThat is perfectly natural in messaging systems.\nHowever, think about the implication on the gateway method.\nThe gateway's method input arguments were incorporated into a message and sent downstream.\nThe reply message would be converted to a return value of the gateway's method.\nSo you might want to ensure that, for each gateway call, there is always a reply message.\nOtherwise, your gateway method might never return and hang indefinitely if `reply-timeout` is set to negative value.\nOne way to handle this situation is by using an asynchronous gateway (explained later in this section).\nAnother way of handling it is to rely on a default `reply-timeout` as a `30` seconds.\nThat way, the gateway does not hang any longer than the time specified by the `reply-timeout` and returns 'null' if that timeout does elapse.\nFinally, you might want to consider setting downstream flags, such as 'requires-reply', on a service-activator or 'throw-exceptions-on-rejection' on a filter.\nThese options are discussed in more detail in the final section of this chapter.\n\nNOTE: If the downstream flow returns an `ErrorMessage`, its `payload` (a `Throwable`) is treated as a regular downstream error.\nIf there is an `error-channel` configured, it is sent to the error flow.\nOtherwise, the payload is thrown to the caller of the gateway.\nSimilarly, if the error flow on the `error-channel` returns an `ErrorMessage`, its payload is thrown to the caller.\nThe same applies to any message with a `Throwable` payload.\nThis can be useful in asynchronous situations when you need to propagate an `Exception` directly to the caller.\nTo do so, you can either return an `Exception` (as the `reply` from some service) or throw it.\nGenerally, even with an asynchronous flow, the framework takes care of propagating an exception thrown by the downstream flow back to the gateway.\nThe https://github.com/spring-projects/spring-integration-samples/tree/main/intermediate/tcp-client-server-multiplex[TCP Client-Server Multiplex] sample demonstrates both techniques to return the exception to the caller.\nIt emulates a socket IO error to the waiting thread by using an `aggregator` with `group-timeout` (see xref:aggregator.adoc#agg-and-group-to[Aggregator and Group Timeout]) and a `MessagingTimeoutException` reply on the discard flow.\n\n[[gateway-timeouts]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Error Handling", "heading_level": 2, "file_order": 212, "section_index": 11, "content_hash": "93c7400a7cc3b8fe6b4afbbdb865bc7b46ee8585e4e4ca78d6cde8dfcb3a3cc7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:727fed231c78b7f7d06089c9dc43990f084c1f401e6aca4872eebc97a0f9e354", "content": "Gateways have two timeout properties: `requestTimeout` and `replyTimeout`.\nThe request timeout applies only if the channel can block, for example, a bounded `QueueChannel` that is full.\nThe `replyTimeout` value is how long the gateway waits for a reply or returns `null`.\nIt defaults to infinity.\n\nThe timeouts can be set as defaults for all methods on the gateway (`defaultRequestTimeout` and `defaultReplyTimeout`) or on the `MessagingGateway` interface annotation.\nIndividual methods can override these defaults (in `<method/>` child elements) or on the `@Gateway` annotation.\n\nStarting with version 5.0, the timeouts can be defined as expressions, as the following example shows:\n\n[source, java]\n----\n@Gateway(payloadExpression = \"args[0]\", requestChannel = \"someChannel\",\n requestTimeoutExpression = \"args[1]\", replyTimeoutExpression = \"args[2]\")\nString lateReply(String payload, long requestTimeout, long replyTimeout);\n----\n\nThe evaluation context has a `BeanResolver` (use `@someBean` to reference other beans), and the `args` array property from the `#root` object is available.\nSee xref:gateway.adoc#gateway-expressions[Expressions and \"`Global`\" Headers] for more information about this root object.\nWhen configuring with XML, the timeout attributes can be a long value or a SpEL expression, as the following example shows:\n\n[source, xml]\n----\n<method name=\"someMethod\" request-channel=\"someRequestChannel\"\n payload-expression=\"args[0]\"\n request-timeout=\"1000\"\n reply-timeout=\"args[1]\">\n</method>\n----\n\n[[async-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Gateway Timeouts", "heading_level": 2, "file_order": 212, "section_index": 12, "content_hash": "727fed231c78b7f7d06089c9dc43990f084c1f401e6aca4872eebc97a0f9e354", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:b0661ca5d91e88bdc705aefc8fb42a916ad58ee399175a4826220e70a162f688", "content": "As a pattern, the messaging gateway offers a nice way to hide messaging-specific code while still exposing the full capabilities of the messaging system.\nAs xref:gateway.adoc#gateway-proxy[described earlier], the `GatewayProxyFactoryBean` provides a convenient way to expose a proxy over a service-interface giving you POJO-based access to a messaging system (based on objects in your own domain, primitives/Strings, or other objects).\nHowever, when a gateway is exposed through simple POJO methods that return values, it implies that, for each request message (generated when the method is invoked), there must be a reply message (generated when the method has returned).\nSince messaging systems are naturally asynchronous, you may not always be able to guarantee the contract where \"`for each request, there will always be a reply`\". Spring Integration 2.0 introduced support for an asynchronous gateway, which offers a convenient way to initiate flows when you may not know if a reply is expected or how long it takes for replies to arrive.\n\nTo handle these types of scenarios, Spring Integration uses `java.util.concurrent.Future` instances to support an asynchronous gateway.\n\nFrom the XML configuration, nothing changes, and you still define asynchronous gateway the same way as you define a regular gateway, as the following example shows:\n\n[source,xml]\n----\n<int:gateway id=\"mathService\"\n service-interface=\"org.springframework.integration.sample.gateway.futures.MathServiceGateway\"\n default-request-channel=\"requestChannel\"/>\n----\n\nHowever, the gateway interface (a service interface) is a little different, as follows:\n\n[source,java]\n----\npublic interface MathServiceGateway {\n\n Future<Integer> multiplyByTwo(int i);\n\n}\n----\n\nAs the preceding example shows, the return type for the gateway method is a `Future`.\nWhen `GatewayProxyFactoryBean` sees that the return type of the gateway method is a `Future`, it immediately switches to the asynchronous mode by using an `AsyncTaskExecutor`.\nThat is the extent of the differences.\nThe call to such a method always returns immediately with a `Future` instance.\nThen you can interact with the `Future` at your own pace to get the result, cancel, and so on.\nAlso, as with any other use of `Future` instances, calling `get()` may reveal a timeout, an execution exception, and so on.\nThe following example shows how to use a `Future` that returns from an asynchronous gateway:\n\n[source,java]\n----\nMathServiceGateway mathService = ac.getBean(\"mathService\", MathServiceGateway.class);\nFuture<Integer> result = mathService.multiplyByTwo(number);\nint finalResult = result.get(1000, TimeUnit.SECONDS);\n----\n\nFor a more detailed example, see the https://github.com/spring-projects/spring-integration-samples/tree/main/intermediate/async-gateway[async-gateway] sample in the Spring Integration samples.\n\nAlso, starting with version 6.5, the Java DSL `gateway()` operator fully supports an `async(true)` behaviour.\nInternally, an `AsyncRequestReplyExchanger` service interface is provided for the `GatewayProxyFactoryBean`.\nAnd since `AsyncRequestReplyExchanger` contract is a `CompletableFuture<Message<?>>`, the whole request-reply is executed in an asynchronous manner.\nThis behavior is useful, for example, in the case of a splitter-aggregator scenario when another flow has to be called for each item.\nHowever, the order is not important - only their group gathering on the aggregator after all processing.\n\n[[gateway-asynctaskexecutor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Asynchronous Gateway", "heading_level": 2, "file_order": 212, "section_index": 13, "content_hash": "b0661ca5d91e88bdc705aefc8fb42a916ad58ee399175a4826220e70a162f688", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:5bc0f86f7ad26b6d9aae57059d38d8f4ddd27c5f7a6e6e841984289eace5a7af", "content": "By default, the `GatewayProxyFactoryBean` uses `org.springframework.core.task.SimpleAsyncTaskExecutor` when submitting internal `AsyncInvocationTask` instances for any gateway method whose return type is a `Future`.\nHowever, the `async-executor` attribute in the `<gateway/>` element's configuration lets you provide a reference to any implementation of `java.util.concurrent.Executor` available within the Spring application context.\n\nThe (default) `SimpleAsyncTaskExecutor` supports both `Future` and `CompletableFuture` return types.\nSee xref:gateway.adoc#gw-completable-future[`CompletableFuture`].\nEven though there is a default executor, it is often useful to provide an external one so that you can identify its threads in logs (when using XML, the thread name is based on the executor's bean name), as the following example shows:\n\n[source,java]\n----\n@Bean\npublic AsyncTaskExecutor exec() {\n SimpleAsyncTaskExecutor simpleAsyncTaskExecutor = new SimpleAsyncTaskExecutor();\n simpleAsyncTaskExecutor.setThreadNamePrefix(\"exec-\");\n return simpleAsyncTaskExecutor;\n}\n\n@MessagingGateway(asyncExecutor = \"exec\")\npublic interface ExecGateway {\n\n @Gateway(requestChannel = \"gatewayChannel\")\n Future<?> doAsync(String foo);\n\n}\n----\n\nIf you wish to return a different `Future` implementation, you can provide a custom executor or disable the executor altogether and return the `Future` in the reply message payload from the downstream flow.\nTo disable the executor, set it to `null` in the `GatewayProxyFactoryBean` (by using `setAsyncTaskExecutor(null)`).\nWhen configuring the gateway with XML, use `async-executor=\"\"`.\nWhen configuring by using the `@MessagingGateway` annotation, use code similar to the following:\n\n[source,java]\n----\n@MessagingGateway(asyncExecutor = AnnotationConstants.NULL)\npublic interface NoExecGateway {\n\n @Gateway(requestChannel = \"gatewayChannel\")\n Future<?> doAsync(String foo);\n\n}\n----\n\nIMPORTANT: If the return type is a specific concrete `Future` implementation or some other sub-interface that is not supported by the configured executor, the flow runs on the caller's thread and the flow must return the required type in the reply message payload.\n\n[[gw-completable-future]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "`AsyncTaskExecutor`", "heading_level": 3, "file_order": 212, "section_index": 14, "content_hash": "5bc0f86f7ad26b6d9aae57059d38d8f4ddd27c5f7a6e6e841984289eace5a7af", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:55d1906b47b4ffc3a240cbf6b2bc963c87edcc4f8e087fcb65fa3820af40e055", "content": "Starting with version 4.2, gateway methods can now return `CompletableFuture<?>`.\nThere are two modes of operation when returning this type:\n\n* When an async executor is provided and the return type is exactly `CompletableFuture` (not a subclass), the framework runs the task on the executor and immediately returns a `CompletableFuture` to the caller.\n`CompletableFuture.supplyAsync(Supplier<U> supplier, Executor executor)` is used to create the future.\n\n* When the async executor is explicitly set to `null` and the return type is `CompletableFuture` or the return type is a subclass of `CompletableFuture`, the flow is invoked on the caller's thread.\nIn this scenario, the downstream flow is expected to return a `CompletableFuture` of the appropriate type.\n\n[[usage-scenarios]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "`CompletableFuture`", "heading_level": 3, "file_order": 212, "section_index": 15, "content_hash": "55d1906b47b4ffc3a240cbf6b2bc963c87edcc4f8e087fcb65fa3820af40e055", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:060b457adb38c95ae5ac0619365e709d175f6b11888986b38d5930b41108d904", "content": "In the following scenario, the caller thread returns immediately with a `CompletableFuture<Invoice>`, which is completed when the downstream flow replies to the gateway (with an `Invoice` object).\n\n[source, java]\n----\nCompletableFuture<Invoice> order(Order order);\n----\n\n[source, xml]\n----\n<int:gateway service-interface=\"something.Service\" default-request-channel=\"orders\" />\n----\n\nIn the following scenario, the caller thread returns with a `CompletableFuture<Invoice>` when the downstream flow provides it as the payload of the reply to the gateway.\nSome other process must be completed in the future when the invoice is ready.\n\n[source, java]\n----\nCompletableFuture<Invoice> order(Order order);\n----\n\n[source, xml]\n----\n<int:gateway service-interface=\"foo.Service\" default-request-channel=\"orders\"\n async-executor=\"\" />\n----\n\nIn the following scenario, the caller thread returns with a `CompletableFuture<Invoice>` when the downstream flow provides it as the payload of the reply to the gateway.\nSome other process must be completed in the future when the invoice is ready.\nIf `DEBUG` logging is enabled, a log entry is emitted, indicating that the async executor cannot be used for this scenario.\n\n[source, java]\n----\nMyCompletableFuture<Invoice> order(Order order);\n----\n\n[source, xml]\n----\n<int:gateway service-interface=\"foo.Service\" default-request-channel=\"orders\" />\n----\n\n`CompletableFuture` instances can be used to perform additional manipulation on the reply, as the following example shows:\n\n[source, java]\n----\nCompletableFuture<String> process(String data);\n\n...\n\nCompletableFuture result = process(\"foo\")\n .thenApply(t -> t.toUpperCase());\n\n...\n\nString out = result.get(10, TimeUnit.SECONDS);\n----\n\n[[reactor-mono]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Usage Scenarios", "heading_level": 4, "file_order": 212, "section_index": 16, "content_hash": "060b457adb38c95ae5ac0619365e709d175f6b11888986b38d5930b41108d904", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:9d5da418c1c7435b89fabfab04b80e7db769eb3c8b29ff0fed13469392ef982f", "content": "Starting with version 5.0, the `GatewayProxyFactoryBean` allows the use of https://projectreactor.io/[Project Reactor] with gateway interface methods, using a https://github.com/reactor/reactor-core[`Mono<T>`] return type.\nThe internal `AsyncInvocationTask` is wrapped in a `Mono.fromCallable()`.\n\nA `Mono` can be used to retrieve the result later (similarly to a `Future<?>`), or you can consume from it with the dispatcher by invoking your `Consumer` when the result is returned to the gateway.\n\nIMPORTANT: The `Mono` is not immediately flushed by the framework.\nConsequently, the underlying message flow is not started before the gateway method returns (as it is with a `Future<?>` `Executor` task).\nThe flow starts when the `Mono` is subscribed to.\nAlternatively, the `Mono` (being a \"`Composable`\") might be a part of Reactor stream, when the `subscribe()` is related to the entire `Flux`.\nThe following example shows how to create a gateway with Project Reactor:\n\n[source,java]\n----\n@MessagingGateway\npublic interface TestGateway {\n\n @Gateway(requestChannel = \"multiplyChannel\")\n Mono<Integer> multiply(Integer value);\n\n}\n\n@ServiceActivator(inputChannel = \"multiplyChannel\")\npublic Integer multiply(Integer value) {\n return value * 2;\n}\n----\n\nwhere such a gateway can be used in some service that deals with the `Flux` of data:\n\n[source,java]\n----\n@Autowired\nTestGateway testGateway;\n\npublic void handleFlux() {\n Flux.just(\"1\", \"2\", \"3\", \"4\", \"5\")\n .map(Integer::parseInt)\n .flatMap(this.testGateway::multiply)\n .collectList()\n .subscribe(System.out::println);\n}\n----\n\nAnother example that uses Project Reactor is a simple callback scenario, as the following example shows:\n\n[source,java]\n----\nMono<Invoice> mono = service.process(myOrder);\n\nmono.subscribe(invoice -> handleInvoice(invoice));\n----\n\nThe calling thread continues, with `handleInvoice()` being called when the flow completes.\n\nAlso see xref:kotlin-functions.adoc#kotlin-coroutines[Kotlin Coroutines] for more information.\n\n[[downstream-flows-returning-an-asynchronous-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Reactor `Mono`", "heading_level": 3, "file_order": 212, "section_index": 17, "content_hash": "9d5da418c1c7435b89fabfab04b80e7db769eb3c8b29ff0fed13469392ef982f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:6de54501418b3e26fe6e52fc806b33d401d6193264a45c7d404a0d43df1f763b", "content": "As mentioned in the xref:gateway.adoc#gateway-asynctaskexecutor[`AsyncTaskExecutor`] section above, if you wish some downstream component to return a message with an async payload (`Future`, `Mono`, and others), you must explicitly set the async executor to `null` (or `\"\"` when using XML configuration).\nThe flow is then invoked on the caller thread, and the result can be retrieved later.\n\n[[asynchronous-void-return-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Downstream Flows Returning an Asynchronous Type", "heading_level": 3, "file_order": 212, "section_index": 18, "content_hash": "6de54501418b3e26fe6e52fc806b33d401d6193264a45c7d404a0d43df1f763b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:e4f007694255354fe0a47c0dc073f2df674927b017dbaa3545a1106d02023f76", "content": "The messaging gateway method can be declared like this:\n\n[source, java]\n----\n@MessagingGateway\npublic interface MyGateway {\n\n @Gateway(requestChannel = \"sendAsyncChannel\")\n @Async\n void sendAsync(String payload);\n\n}\n----\n\nBut downstream exceptions are not going to be propagated back to the caller.\nTo ensure asynchronous behavior for downstream flow invocation and exception propagation to the caller, starting with version 6.0, the framework provides support for the `Future<Void>` and `Mono<Void>` return types.\nThe use-case is similar to send-and-forget behavior described before for plain `void` return type, but with a difference that flow execution happens asynchronously and returned `Future` (or `Mono`) is complete with a `null` or exceptionally according to the `send` operation result.\n\nNOTE: If the `Future<Void>` is exact downstream flow reply, then an `asyncExecutor` option of the gateway must be set to null (`AnnotationConstants.NULL` for a `@MessagingGateway` configuration) and the `send` part is performed on a producer thread.\nThe reply one depends on the downstream flow configuration.\nThis way it is up target application to produce a `Future<Void>` reply correctly.\nThe `Mono` use-case is already out of the framework threading control, so setting `asyncExecutor` to null won't make sense.\nThere `Mono<Void>` as a result of the request-reply gateway operation must be configured as a `Mono<?>` return type of the gateway method.\n\n[[gateway-no-response]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Asynchronous `void` Return Type", "heading_level": 3, "file_order": 212, "section_index": 19, "content_hash": "e4f007694255354fe0a47c0dc073f2df674927b017dbaa3545a1106d02023f76", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:8902f0ac2f0c5fa52bd0cc52e5b037f9fbd700515562cfbab242585525510bac", "content": "As xref:gateway.adoc#gateway-proxy[explained earlier], the gateway provides a convenient way of interacting with a messaging system through POJO method invocations.\nHowever, a typical method invocation, which is generally expected to always return (even with an Exception), might not always map one-to-one to message exchanges (for example, a reply message might not arrive -- the equivalent to a method not returning).\n\nThe rest of this section covers various scenarios and how to make the gateway behave more predictably.\nCertain attributes can be configured to make synchronous gateway behavior more predictable, but some of them might not always work as you might expect.\nOne of them is `reply-timeout` (at the method level or `default-reply-timeout` at the gateway level).\nWe examine the `reply-timeout` attribute to see how it can and cannot influence the behavior of the synchronous gateway in various scenarios.\nWe examine a single-threaded scenario (all components downstream are connected through a direct channel) and multithreaded scenarios, (for example, somewhere downstream you may have a pollable or executor channel that breaks the single-thread boundary).\n\n[[long-running-process-downstream]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Gateway Behavior When No response Arrives", "heading_level": 2, "file_order": 212, "section_index": 20, "content_hash": "8902f0ac2f0c5fa52bd0cc52e5b037f9fbd700515562cfbab242585525510bac", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:449feb1aa76408bc659378261bab7dd4b0bf9de69510a29933700ea535296e18", "content": "Sync Gateway, single-threaded::\nIf a component downstream is still running (perhaps because of an infinite loop or a slow service), setting a `reply-timeout` has no effect, and the gateway method call does not return until the downstream service exits (by returning or throwing an exception).\nSync Gateway, multithreaded::\nIf a component downstream is still running (perhaps because of an infinite loop or a slow service) in a multithreaded message flow, setting the `reply-timeout` has an effect by allowing gateway method invocation to return once the timeout has been reached, because the `GatewayProxyFactoryBean` polls on the reply channel, waiting for a message until the timeout expires.\nHowever, if the timeout has been reached before the actual reply was produced, it could result in a 'null' return from the gateway method.\nYou should understand that the reply message, if produced, is sent to a reply channel after the gateway method invocation might have returned, so you must be aware of that and design your flow with it in mind.\n\nAlso see the `errorOnTimeout` property to throw a `MessageTimeoutException` instead of returning `null`, when a timeout occurs.\n\n[[downstream-component-returns-null-]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Long-running Process Downstream", "heading_level": 3, "file_order": 212, "section_index": 21, "content_hash": "449feb1aa76408bc659378261bab7dd4b0bf9de69510a29933700ea535296e18", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:5d26e2b296e808c44aa01edbdcefa1951d839b726f8819d137f091822a74375e", "content": "Sync Gateway -- single-threaded::\nIf a component downstream returns 'null' and the `reply-timeout` has been configured to negative value, the gateway method call hangs indefinitely, unless the `requires-reply` attribute has been set on the downstream component (for example, a service activator) that might return 'null'.\nIn this case, an exception would be thrown and propagated to the gateway.\nSync Gateway -- multithreaded::\nThe behavior is the same as the previous case.\n\n[[downstream-component-return-signature-is-void-while-gateway-method-signature-is-non-void]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Downstream Component Returns 'null'", "heading_level": 3, "file_order": 212, "section_index": 22, "content_hash": "5d26e2b296e808c44aa01edbdcefa1951d839b726f8819d137f091822a74375e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:c233baa21f95a655e96d805ac71c89a47e4019ff49de1c7edefd89d7348bac7c", "content": "Sync Gateway -- single-threaded::\nIf a component downstream returns 'void' and the `reply-timeout` has been configured to negative value, the gateway method call hangs indefinitely.\nSync Gateway -- multithreaded::\nThe behavior is the same as the previous case.\n\n[[downstream-component-results-in-runtime-exception]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Downstream Component Return Signature is 'void' While Gateway Method Signature Is Non-void", "heading_level": 3, "file_order": 212, "section_index": 23, "content_hash": "c233baa21f95a655e96d805ac71c89a47e4019ff49de1c7edefd89d7348bac7c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:20b14da3bf0a722999fd5d4ff64e82116c57d199cd866490262b515d4b57d513", "content": "Sync Gateway -- single-threaded::\nIf a component downstream throws a runtime exception, the exception is propagated through an error message back to the gateway and re-thrown.\nSync Gateway -- multithreaded::\nThe behavior is the same as the previous case.\n\nIMPORTANT: You should understand that, by default, `reply-timeout` is unbounded.\nConsequently, if you set the `reply-timeout` to negative value, your gateway method invocation might hang indefinitely.\nSo, to make sure you analyze your flow and if there is even a remote possibility of one of these scenarios to occur, you should set the `reply-timeout` attribute to a \"'safe'\" value.\nIt is `30` seconds by default.\nEven better, you can set the `requires-reply` attribute of the downstream component to 'true' to ensure a timely response, as produced by the throwing of an exception as soon as that downstream component returns null internally.\nHowever, you should also realize that there are some scenarios (see xref:gateway.adoc#long-running-process-downstream[the first one]) where `reply-timeout` does not help.\nThat means it is also important to analyze your message flow and decide when to use a synchronous gateway rather than an asynchronous gateway.\nAs xref:jms.adoc#jms-async-gateway[described earlier], the latter case is a matter of defining gateway methods that return `Future` instances.\nThen you are guaranteed to receive that return value, and you have more granular control over the results of the invocation.\nAlso, when dealing with a router, you should remember that setting the `resolution-required` attribute to 'true' results in an exception thrown by the router if it cannot resolve a particular channel.\nLikewise, when dealing with a Filter, you can set the `throw-exception-on-rejection` attribute.\nIn both of these cases, the resulting flow behaves like it contains a service activator with the 'requires-reply' attribute.\nIn other words, it helps to ensure a timely response from the gateway method invocation.\n\nIMPORTANT: You should understand that the timer starts when the thread returns to the gateway -- that is, when the flow completes or a message is handed off to another thread.\nAt that time, the calling thread starts waiting for the reply.\nIf the flow was completely synchronous, the reply is immediately available.\nFor asynchronous flows, the thread waits for up to this time.\n\nStarting with version 6.2, the `errorOnTimeout` property of the internal `MethodInvocationGateway` extension of the `MessagingGatewaySupport` is exposed on the `@MessagingGateway` and `GatewayEndpointSpec`.\nThis option has exactly the same meaning as for any inbound gateway explained at the end of the xref:endpoint-summary.adoc#endpoint-summary[Endpoint Summary] chapter.\nIn other words, setting this option to `true`, would lead to the `MessageTimeoutException` being thrown from a send-and-receive gateway operation instead of returning `null` when the receive timeout is exhausted.\n\nSee xref:dsl/integration-flow-as-gateway.adoc[`IntegrationFlow` as Gateway] in the Java DSL chapter for options to define gateways through `IntegrationFlow`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/gateway.adoc", "title": "gateway", "heading": "Downstream Component Results in Runtime Exception", "heading_level": 3, "file_order": 212, "section_index": 24, "content_hash": "20b14da3bf0a722999fd5d4ff64e82116c57d199cd866490262b515d4b57d513", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/gateway.adoc"}}
{"id": "sha256:12f4ad37102c4c32de7363624d6212b3f3f4153ad5ac6ed61da253cfcda0ddc3", "content": "[[integration-graph]]\n\nStarting with version 4.3, Spring Integration provides access to an application's runtime object model, which can, optionally, include component metrics.\nIt is exposed as a graph, which may be used to visualize the current state of the integration application.\nThe `o.s.i.support.management.graph` package contains all the required classes to collect, build, and render the runtime state of Spring Integration components as a single tree-like `Graph` object.\nThe `IntegrationGraphServer` should be declared as a bean to build, retrieve, and refresh the `Graph` object.\nThe resulting `Graph` object can be serialized to any format, although JSON is flexible and convenient to parse and represent on the client side.\nA Spring Integration application with only the default components would expose a graph as follows:\n\n[source,json,subs=\"normal\"]\n----\n{\n \"contentDescriptor\" : {\n \"providerVersion\" : \"{project-version}\",\n \"providerFormatVersion\" : 1.2,\n \"provider\" : \"spring-integration\",\n \"name\" : \"myAppName:1.0\"\n },\n \"nodes\" : [ {\n \"nodeId\" : 1,\n \"componentType\" : \"null-channel\",\n \"integrationPatternType\" : \"null_channel\",\n \"integrationPatternCategory\" : \"messaging_channel\",\n \"properties\" : { },\n \"sendTimers\" : {\n \"successes\" : {\n \"count\" : 1,\n \"mean\" : 0.0,\n \"max\" : 0.0\n },\n \"failures\" : {\n \"count\" : 0,\n \"mean\" : 0.0,\n \"max\" : 0.0\n }\n },\n \"receiveCounters\" : {\n \"successes\" : 0,\n \"failures\" : 0\n },\n \"name\" : \"nullChannel\"\n }, {\n \"nodeId\" : 2,\n \"componentType\" : \"publish-subscribe-channel\",\n \"integrationPatternType\" : \"publish_subscribe_channel\",\n \"integrationPatternCategory\" : \"messaging_channel\",\n \"properties\" : { },\n \"sendTimers\" : {\n \"successes\" : {\n \"count\" : 1,\n \"mean\" : 7.807002,\n \"max\" : 7.807002\n },\n \"failures\" : {\n \"count\" : 0,\n \"mean\" : 0.0,\n \"max\" : 0.0\n }\n },\n \"name\" : \"errorChannel\"\n }, {\n \"nodeId\" : 3,\n \"componentType\" : \"logging-channel-adapter\",\n \"integrationPatternType\" : \"outbound_channel_adapter\",\n \"integrationPatternCategory\" : \"messaging_endpoint\",\n \"properties\" : { },\n \"output\" : null,\n \"input\" : \"errorChannel\",\n \"sendTimers\" : {\n \"successes\" : {\n \"count\" : 1,\n \"mean\" : 6.742722,\n \"max\" : 6.742722\n },\n \"failures\" : {\n \"count\" : 0,\n \"mean\" : 0.0,\n \"max\" : 0.0\n }\n },\n \"name\" : \"errorLogger\"\n } ],\n \"links\" : [ {\n \"from\" : 2,\n \"to\" : 3,\n \"type\" : \"input\"\n } ]\n}\n----\n\nNOTE: Version 5.2 deprecated the legacy metrics in favor of Micrometer meters as discussed xref:metrics.adoc[Metrics Management].\nThe legacy metrics were removed in Version 5.4 and will no longer appear in the graph.\n\nIn the preceding example, the graph consists of three top-level elements.\n\nThe `contentDescriptor` graph element contains general information about the application providing the data.\nThe `name` can be customized on the `IntegrationGraphServer` bean or in the `spring.application.name` application context environment property.\nOther properties are provided by the framework and let you distinguish a similar model from other sources.\n\nThe `links` graph element represents connections between nodes from the `nodes` graph element and, therefore, between integration components in the source Spring Integration application.\nFor example, from a `MessageChannel` to an `EventDrivenConsumer` with some `MessageHandler` or from an `AbstractReplyProducingMessageHandler` to a `MessageChannel`.\nFor convenience and to let you determine a link's purpose, the model includes the `type` attribute.\nThe possible types are:\n\n* `input`: Identifies the direction from `MessageChannel` to the endpoint, `inputChannel`, or `requestChannel` property\n* `output`: The direction from the `MessageHandler`, `MessageProducer`, or `SourcePollingChannelAdapter` to the `MessageChannel` through an `outputChannel` or `replyChannel` property\n* `error`: From `MessageHandler` on `PollingConsumer` or `MessageProducer` or `SourcePollingChannelAdapter` to the `MessageChannel` through an `errorChannel` property;\n* `discard`: From `DiscardingMessageHandler` (such as `MessageFilter`) to the `MessageChannel` through an `errorChannel` property.\n* `route`: From `AbstractMappingMessageRouter` (such as `HeaderValueRouter`) to the `MessageChannel`.\nSimilar to `output` but determined at run-time.\nMaybe a configured channel mapping or a dynamically resolved channel.\nRouters typically retain only up to 100 dynamic routes for this purpose, but you can modify this value by setting the `dynamicChannelLimit` property.\n\nThe information from this element can be used by a visualization tool to render connections between nodes from the `nodes` graph element, where the `from` and `to` numbers represent the value from the `nodeId` property of the linked nodes.\nFor example, the `link` element can be used to determine the proper `port` on the target node.\n\nThe following \"`text image`\" shows the relationships between the types:\n\n----\n +---(discard)\n |\n +----o----+\n | |\n | |\n | |\n(input)--o o---(output)\n | |\n | |\n | |\n +----o----+\n |\n +---(error)\n----\n\nThe `nodes` graph element is perhaps the most interesting, because its elements contain not only the runtime components with their `componentType` instances and `name` values but can also optionally contain metrics exposed by the component.\nNode elements contain various properties that are generally self-explanatory.\nFor example, expression-based components include the `expression` property that contains the primary expression string for the component.\nTo enable the metrics, add an `@EnableIntegrationManagement` to a `@Configuration` class or add an `<int:management/>` element to your XML configuration.\nSee xref:metrics.adoc[Metrics and Management] for complete information.\n\nThe `nodeId` represents a unique incremental identifier to let you distinguish one component from another.\nIt is also used in the `links` element to represent a relationship (connection) of this component to others, if any.\nThe `input` and `output` attributes are for the `inputChannel` and `outputChannel` properties of the `AbstractEndpoint`, `MessageHandler`, `SourcePollingChannelAdapter`, or `MessageProducerSupport`.\nSee the next section for more information.\n\nStarting with version 5.1, the `IntegrationGraphServer` accepts a `Function<NamedComponent, Map<String, Object>> additionalPropertiesCallback` for population of additional properties on the `IntegrationNode` for a particular `NamedComponent`.\nFor example, you can expose the `SmartLifecycle` `autoStartup` and `running` properties into the target graph:\n\n[source,java]\n----\nserver.setAdditionalPropertiesCallback(namedComponent -> {\n Map<String, Object> properties = null;\n if (namedComponent instanceof SmartLifecycle) {\n SmartLifecycle smartLifecycle = (SmartLifecycle) namedComponent;\n properties = new HashMap<>();\n properties.put(\"auto-startup\", smartLifecycle.isAutoStartup());\n properties.put(\"running\", smartLifecycle.isRunning());\n }\n return properties;\n });\n----\n\n[[graph-runtime-model]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/graph.adoc", "title": "graph", "heading": "graph", "heading_level": 1, "file_order": 213, "section_index": 0, "content_hash": "12f4ad37102c4c32de7363624d6212b3f3f4153ad5ac6ed61da253cfcda0ddc3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/graph.adoc"}}
{"id": "sha256:622e6a6276454e72a67292d8ea419dfb250d9ca2badfc4893fc621671ea90643", "content": "Spring Integration components have various levels of complexity.\nFor example, any polled `MessageSource` also has a `SourcePollingChannelAdapter` and a `MessageChannel` to which to periodically send messages from the source data.\nOther components might be middleware request-reply components (such as `JmsOutboundGateway`) with a consuming `AbstractEndpoint` to subscribe to (or poll) the `requestChannel` (`input`) for messages, and a `replyChannel` (`output`) to produce a reply message to send downstream.\nMeanwhile, any `MessageProducerSupport` implementation (such as `ApplicationEventListeningMessageProducer`) wraps some source protocol listening logic and sends messages to the `outputChannel`.\n\nWithin the graph, Spring Integration components are represented by using the `IntegrationNode` class hierarchy, which you can find in the `o.s.i.support.management.graph` package.\nFor example, you can use the `ErrorCapableDiscardingMessageHandlerNode` for the `AggregatingMessageHandler` (because it has a `discardChannel` option) and can produce errors when consuming from a `PollableChannel` by using a `PollingConsumer`.\nAnother example is `CompositeMessageHandlerNode` -- for a `MessageHandlerChain` when subscribed to a `SubscribableChannel` by using an `EventDrivenConsumer`.\n\nNOTE: The `@MessagingGateway` (see xref:gateway.adoc[Messaging Gateways]) provides nodes for each of its method, where the `name` attribute is based on the gateway's bean name and the short method signature.\nConsider the following example of a gateway:\n\n[source,java]\n----\n@MessagingGateway(defaultRequestChannel = \"four\")\npublic interface Gate {\n\n\tvoid foo(String foo);\n\n\tvoid foo(Integer foo);\n\n\tvoid bar(String bar);\n\n}\n----\n\nThe preceding gateway produces nodes similar to the following:\n\n[source,json]\n----\n{\n \"nodeId\" : 10,\n \"name\" : \"gate.bar(class java.lang.String)\",\n \"stats\" : null,\n \"componentType\" : \"gateway\",\n \"integrationPatternType\" : \"gateway\",\n \"integrationPatternCategory\" : \"messaging_endpoint\",\n \"output\" : \"four\",\n \"errors\" : null\n},\n{\n \"nodeId\" : 11,\n \"name\" : \"gate.foo(class java.lang.String)\",\n \"stats\" : null,\n \"componentType\" : \"gateway\",\n \"integrationPatternType\" : \"gateway\",\n \"integrationPatternCategory\" : \"messaging_endpoint\",\n \"output\" : \"four\",\n \"errors\" : null\n},\n{\n \"nodeId\" : 12,\n \"name\" : \"gate.foo(class java.lang.Integer)\",\n \"stats\" : null,\n \"componentType\" : \"gateway\",\n \"integrationPatternType\" : \"gateway\",\n \"integrationPatternCategory\" : \"messaging_endpoint\",\n \"output\" : \"four\",\n \"errors\" : null\n}\n----\n\nYou can use this `IntegrationNode` hierarchy for parsing the graph model on the client side as well as to understand the general Spring Integration runtime behavior.\nSee also xref:overview.adoc#programming-tips[Programming Tips and Tricks] for more information.\n\nVersion 5.3 introduced an `IntegrationPattern` abstraction and all out-of-the-box components, which represent an Enterprise Integration Pattern (EIP), implement this abstraction and provide an `IntegrationPatternType` enum value.\nThis information can be useful for some categorizing logic in the target application or, being exposed into the graph node, it can be used by a UI to determine how to draw the component.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/graph.adoc", "title": "graph", "heading": "Graph Runtime Model", "heading_level": 2, "file_order": 213, "section_index": 1, "content_hash": "622e6a6276454e72a67292d8ea419dfb250d9ca2badfc4893fc621671ea90643", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/graph.adoc"}}
{"id": "sha256:990b2f0980f93ff5f8953215a05898a4dd2fe76d63b2470e9f2303b6ab8d22b1", "content": "[[graphql]]\n\nSpring Integration provides channel adapters for interaction with https://graphql.org/[GraphQL] protocol.\nThe implementation is based on the https://spring.io/projects/spring-graphql[Spring for GraphQL].\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-graphql</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-graphql:{project-version}\"\n----\n======\n\n[[graphql-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/graphql.adoc", "title": "graphql", "heading": "graphql", "heading_level": 1, "file_order": 214, "section_index": 0, "content_hash": "990b2f0980f93ff5f8953215a05898a4dd2fe76d63b2470e9f2303b6ab8d22b1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/graphql.adoc"}}
{"id": "sha256:02b65e90639808757996ad1ad7169eb70f98923a3b7636d8812bf9c121a8995f", "content": "The `GraphQlMessageHandler` is an `AbstractReplyProducingMessageHandler` extension representing an outbound gateway contract to perform GraphQL `query`, `mutation` or `subscription` operation and produce their result.\nIt requires a `org.springframework.graphql.ExecutionGraphQlService` for execution of an `operation`, which can be configured statically or via SpEL expression against a request message.\nThe `operationName` is optional and also can be configured statically or via SpEL expression.\nThe `variablesExpression` is also optional and used for parametrized operations.\nThe `locale` is optional and used for operation execution context in the https://www.graphql-java.com/[GraphQL Java] library.\nThe `executionId` can be configured via SpEL expression and defaults to `id` header of the request message.\n\nIf the payload of the request message is an instance of `ExecutionGraphQlRequest`, then no setup actions are performed in the `GraphQlMessageHandler` and such an input is used as is for the `ExecutionGraphQlService.execute()`.\nOtherwise, the `operation`, `operationName`, `variables` and `executionId` are determined against a request message using SpEL expressions mentioned above.\n\nThe `GraphQlMessageHandler` is a reactive streams component and produces a `Mono<ExecutionGraphQlResponse>` reply as a result of the `ExecutionGraphQlService.execute(ExecutionGraphQlRequest)`.\nSuch a `Mono` is subscribed by the framework in the `ReactiveStreamsSubscribableChannel` output channel or in the `AbstractMessageProducingHandler` asynchronously when the output channel is not reactive.\nSee documentation for the `ExecutionGraphQlResponse` how to process the GraphQL operation result.\n\n[source, java]\n----\n@Bean\nGraphQlMessageHandlerSpec graphQlMessageHandlerSpec(ExecutionGraphQlService graphQlService) {\n return GraphQl.gateway(graphQlService)\n .operation(\"\"\"\n query HeroNameAndFriends($episode: Episode) {\n hero(episode: $episode) {\n name\n friends {\n name\n }\n }\n }\"\"\")\n .variablesExpression(\"{episode:'JEDI'}\");\n}\n\n@Bean\nIntegrationFlow graphqlQueryMessageHandlerFlow(GraphQlMessageHandler handler) {\n return IntegrationFlow.from(MessageChannels.flux(\"inputChannel\"))\n .handle(handler)\n .channel(c -> c.flux(\"resultChannel\"))\n .get();\n}\n\n@Bean\nExecutionGraphQlService graphQlService(GraphQlSource graphQlSource) {\n return new DefaultExecutionGraphQlService(graphQlSource);\n}\n\n@Bean\nGraphQlSource graphQlSource(AnnotatedControllerConfigurer annotatedDataFetcherConfigurer) {\n return GraphQlSource.builder()\n .schemaResources(new ClassPathResource(\"graphql/test-schema.graphqls\"))\n .configureRuntimeWiring(annotatedDataFetcherConfigurer)\n .build();\n}\n\n@Bean\nAnnotatedControllerConfigurer annotatedDataFetcherConfigurer() {\n return new AnnotatedControllerConfigurer();\n}\n----\n\nThe special treatment should be applied for the result of a subscription operation.\nIn this case the `ExecutionGraphQlResponse.getData()` returns a `SubscriptionPublisher` which has to be subscribed and processed manually.\nOr it can be flat-mapped via plain service activator to the reply for the `FluxMessageChannel`:\n\n[source, java]\n----\n@ServiceActivator(inputChannel = \"graphQlResultChannel\", outputChannel=\"graphQlSubscriptionChannel\")\npublic SubscriptionPublisher obtainSubscriptionResult(ExecutionGraphQlResponse graphQlResponse) {\n\treturn graphQlResponse.getData();\n}\n----\n\nSuch an outbound gateway can be used not only for GraphQL request via HTTP, but from any upstream endpoint that produces or carries a GraphQL operation or its arguments in the message.\nThe result of the `GraphQlMessageHandler` handling can be produced as a reply to the upstream request or sent downstream for further processing in the integration flow.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/graphql.adoc", "title": "graphql", "heading": "GraphQL Outbound Gateway", "heading_level": 2, "file_order": 214, "section_index": 1, "content_hash": "02b65e90639808757996ad1ad7169eb70f98923a3b7636d8812bf9c121a8995f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/graphql.adoc"}}
{"id": "sha256:0ab3b6a12d1cbe0d4d946c9cd6238de6cb4b13027a40c457e74ed81817d48946", "content": "[[groovy-dsl]]\n\nThe Groovy DSL is a wrapper and extension to xref:dsl.adoc#java-dsl[Java DSL].\nThe main goal we pursue here is to make Spring Integration development on Groovy as smooth and straightforward as it is possible with interoperability with the existing Java DSL and some Groovy extensions or language-specific structures.\nThe implementation is a part of the xref:groovy.adoc[Groovy Support] module.\n\nAll you need to get started is just an import for `import static org.springframework.integration.groovy.dsl.IntegrationGroovyDsl.integrationFlow` - a class containing overloaded factory methods for the Groovy DSL.\n\nFor `IntegrationFlow` definitions as lambdas we typically don't need anything else from Groovy and just declare a bean like this:\n\n[source, groovy]\n----\n@Bean\nIntegrationFlow oddFlow() {\n { IntegrationFlowDefinition flow ->\n flow.handle(Object, { p, h -> 'odd' })\n }\n}\n----\n\nIn this case Groovy understands that the closure should be translated into an `IntegrationFlow` anonymous instance and the target Java DSL processor parses this construction properly into Java objects.\n\nAs an alternative to the construction above and for consistency with use-cases explained below, the `spring-integration-groovy` module provides a Groovy-specific DSL for declaring integration flows in a *builder* pattern style:\n\n[source, groovy]\n----\n@Bean\nflowLambda() {\n integrationFlow {\n filter String, { it == 'test' }, { id 'filterEndpoint' }\n wireTap integrationFlow {\n channel { queue 'wireTapChannel' }\n }\n delay {\n messageGroupId 'delayGroup'\n defaultDelay 100\n }\n transform {\n transformer { it.toUpperCase() }\n expectedType String\n }\n }\n}\n----\n\nSuch a global `integrationFlow()` function expects a closure in the builder style for a `GroovyIntegrationFlowDefinition` (a Groovy wrapper for the `IntegrationFlowDefinition`) and produces a regular `IntegrationFlow` lambda implementation.\nSee more overloaded `integrationFlow()` variants below.\n\nMany other scenarios require an `IntegrationFlow` to be started from the source of data (e.g. `JdbcPollingChannelAdapter`, `JmsInboundGateway` or just an existing `MessageChannel`).\nFor this purpose, Spring Integration Java DSL provides an `IntegrationFlow` factory with a number of overloaded `from()` methods.\nThis factory can be used in groovy as well:\n\n[source, groovy]\n----\n@Bean\nflowFromSupplier() {\n IntegrationFlow.fromSupplier({ 'bar' }) { e -> e.poller { p -> p.fixedDelay(10).maxMessagesPerPoll(1) } }\n .channel({ c -> c.queue('fromSupplierQueue') } as Function)\n .get()\n}\n----\n\nBut unfortunately not all `from()` methods are compatible with Groovy structures.\nTo solve this, Spring Integration provides a Groovy DSL factory around the `IntegrationFlow` factory.\nIt is implemented as a set of overloaded `integrationFlow()` functions.\nWith a consumer for a `GroovyIntegrationFlowDefinition` to declare the remainder of the flow as an `IntegrationFlow` closure to reuse the mentioned above experience and also avoid the need for a `get()` call in the end.\nFor example:\n\n[source, groovy]\n----\n@Bean\nfunctionFlow() {\n integrationFlow Function<byte[], String>,\n { beanName 'functionGateway' },\n {\n transform {\n transformer Transformers.objectToString()\n id 'objectToStringTransformer'\n }\n transform {\n transformer { it.toUpperCase() }\n expectedType String\n }\n splitWith {\n expectedType Message<?>\n function { it.payload }\n }\n splitWith {\n expectedType Object\n id 'splitterEndpoint'\n function { it }\n }\n resequence()\n aggregate {\n id 'aggregator'\n outputProcessor { it.one }\n }\n }\n}\n\n@Bean\nsomeFlow() {\n integrationFlow ({ 'test' },\n {\n poller { it.trigger new OnlyOnceTrigger() }\n id 'pollingSource'\n })\n {\n log LoggingHandler.Level.WARN, 'test.category'\n channel { queue 'pollerResultChannel' }\n }\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/groovy-dsl.adoc", "title": "groovy-dsl", "heading": "groovy-dsl", "heading_level": 1, "file_order": 215, "section_index": 0, "content_hash": "0ab3b6a12d1cbe0d4d946c9cd6238de6cb4b13027a40c457e74ed81817d48946", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/groovy-dsl.adoc"}}
{"id": "sha256:83ac3a7da520e17405276b68bfa815b5f2fe59c8e66e9138d2e4250cb4f7fa0b", "content": "[[groovy]]\n\nIn Spring Integration 2.0, we added Groovy support, letting you use the Groovy scripting language to provide the logic for various integration components -- similar to the way the Spring Expression Language (SpEL) is supported for routing, transformation, and other integration concerns.\nFor more information about Groovy, see the Groovy documentation, which you can find on the https://groovy-lang.org/[project website].\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-groovy</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-groovy:{project-version}\"\n----\n======\n\nIn addition, starting with version 6.0, a xref:groovy-dsl.adoc[Groovy DSL] for integration flow configurations is provided.\n\n[[groovy-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/groovy.adoc", "title": "groovy", "heading": "groovy", "heading_level": 1, "file_order": 216, "section_index": 0, "content_hash": "83ac3a7da520e17405276b68bfa815b5f2fe59c8e66e9138d2e4250cb4f7fa0b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/groovy.adoc"}}
{"id": "sha256:1e267ec30c0a0ca31bda18756258158ce0309d0926f723314731ca55b45342ba", "content": "With Spring Integration 2.1, the configuration namespace for the Groovy support is an extension of Spring Integration's scripting support and shares the core configuration and behavior described in detail in the xref:scripting.adoc[Scripting Support] section.\nEven though Groovy scripts are well-supported by generic scripting support, the Groovy support provides the `Groovy` configuration namespace, which is backed by the Spring Framework's `org.springframework.scripting.groovy.GroovyScriptFactory` and related components, offering extended capabilities for using Groovy.\nThe following listing shows two sample configurations:\n\n.Filter\n[source,xml]\n----\n<int:filter input-channel=\"referencedScriptInput\">\n <int-groovy:script location=\"some/path/to/groovy/file/GroovyFilterTests.groovy\"/>\n</int:filter>\n\n<int:filter input-channel=\"inlineScriptInput\">\n <int-groovy:script><![CDATA[\n return payload == 'good'\n ]]></int-groovy:script>\n</int:filter>\n----\n\nAs the preceding examples show, the configuration looks identical to the general scripting support configuration.\nThe only difference is the use of the Groovy namespace, as indicated by the `int-groovy` namespace prefix.\nAlso note that the `lang` attribute on the `<script>` tag is not valid in this namespace.\n\n[[groovy-object-customization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/groovy.adoc", "title": "groovy", "heading": "Groovy Configuration", "heading_level": 2, "file_order": 216, "section_index": 1, "content_hash": "1e267ec30c0a0ca31bda18756258158ce0309d0926f723314731ca55b45342ba", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/groovy.adoc"}}
{"id": "sha256:ce2cc9ee46ce1cd9d8e4664f2094cfbca02a054d7d939ee2b657942fce1cc533", "content": "If you need to customize the Groovy object itself (beyond setting variables), you can reference a bean that implements `GroovyObjectCustomizer` by using the `customizer` attribute.\nFor example, this might be useful if you want to implement a domain-specific language (DSL) by modifying the `MetaClass` and registering functions to be available within the script.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<int:service-activator input-channel=\"groovyChannel\">\n <int-groovy:script location=\"somewhere/SomeScript.groovy\" customizer=\"groovyCustomizer\"/>\n</int:service-activator>\n\n<beans:bean id=\"groovyCustomizer\" class=\"org.something.MyGroovyObjectCustomizer\"/>\n----\n\nSetting a custom `GroovyObjectCustomizer` is not mutually exclusive with `<variable>` elements or the `script-variable-generator` attribute.\nIt can also be provided when defining an inline script.\n\nSpring Integration 3.0 introduced the `variables` attribute, which works in conjunction with the `variable` element.\nAlso, groovy scripts have the ability to resolve a variable to a bean in the `BeanFactory`, if a binding variable was not provided with the name.\nThe following example shows how to use a variable (`entityManager`):\n\n[source,xml]\n----\n<int-groovy:script>\n <![CDATA[\n entityManager.persist(payload)\n payload\n ]]>\n</int-groovy:script>\n----\n\n`entityManager` must be an appropriate bean in the application context.\n\nFor more information regarding the `<variable>` element, the `variables` attribute, and the `script-variable-generator` attribute, see xref:scripting.adoc#scripting-script-variable-bindings[Script Variable Bindings].\n\n[[groovy-script-compiler-customization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/groovy.adoc", "title": "groovy", "heading": "Groovy Object Customization", "heading_level": 2, "file_order": 216, "section_index": 2, "content_hash": "ce2cc9ee46ce1cd9d8e4664f2094cfbca02a054d7d939ee2b657942fce1cc533", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/groovy.adoc"}}
{"id": "sha256:07aeefb1f2faa48567b322857bfed930c4bb092eed40087db12705089f424995", "content": "The `@CompileStatic` hint is the most popular Groovy compiler customization option.\nIt can be used on the class or method level.\nFor more information, see the Groovy https://groovy-lang.org/metaprogramming.html#section-typechecked[Reference Manual] and, specifically, https://groovy-lang.org/metaprogramming.html#xform-CompileStatic[@CompileStatic].\nTo utilize this feature for short scripts (in integration scenarios), we are forced to change simple scripts to more Java-like code.\nConsider the following `<filter>` script:\n\n[source,groovy]\n----\nheaders.type == 'good'\n----\n\nThe preceding script becomes the following method in Spring Integration:\n\n[source,groovy]\n----\n@groovy.transform.CompileStatic\nString filter(Map headers) {\n\theaders.type == 'good'\n}\n\nfilter(headers)\n----\n\nWith that, the `filter()` method is transformed and compiled to static Java code, bypassing the Groovy\ndynamic phases of invocation, such as `getProperty()` factories and `CallSite` proxies.\n\nStarting with version 4.3, you can configure the Spring Integration Groovy components with the `compile-static` `boolean` option, specifying that `ASTTransformationCustomizer` for `@CompileStatic` should be added to the internal `CompilerConfiguration`.\nWith that in place, you can omit the method declaration with `@CompileStatic` in our script code and still get compiled plain Java code.\nIn this case, the preceding script can be short but still needs to be a little more verbose than interpreted script, as the following example shows:\n\n[source,groovy]\n----\nbinding.variables.headers.type == 'good'\n----\n\nYou must access the `headers` and `payload` (or any other) variables through the `groovy.lang.Script` `binding` property because, with `@CompileStatic`, we do not have the dynamic `GroovyObject.getProperty()` capability.\n\nIn addition, we introduced the `compiler-configuration` bean reference.\nWith this attribute, you can provide any other required Groovy compiler customizations, such as `ImportCustomizer`.\nFor more information about this feature, see the Groovy Documentation for https://melix.github.io/blog/2011/05/12/customizing_groovy_compilation_process.html[advanced compiler configuration].\n\nNOTE: Using `compilerConfiguration` does not automatically add an `ASTTransformationCustomizer` for the `@CompileStatic` annotation, and it overrides the `compileStatic` option.\nIf you still need `CompileStatic`, you should manually add a `new ASTTransformationCustomizer(CompileStatic.class)` into the `CompilationCustomizers` of that custom `compilerConfiguration`.\n\nNOTE: The Groovy compiler customization does not have any effect on the `refresh-check-delay` option, and reloadable scripts can be statically compiled, too.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/groovy.adoc", "title": "groovy", "heading": "Groovy Script Compiler Customization", "heading_level": 2, "file_order": 216, "section_index": 3, "content_hash": "07aeefb1f2faa48567b322857bfed930c4bb092eed40087db12705089f424995", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/groovy.adoc"}}
{"id": "sha256:62cd0202b744183968b77a6d9f3084dea9938482d77ef1599939878afc8d9f60", "content": "[[grpc]]\n\nStarting with version 7.1, Spring Integration provides inbound and outbound gateways to communicate via https://grpc.io[gRPC] protocol.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-grpc</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-grpc:{project-version}\"\n----\n======\n\nSpring Integration components for gRPC are not generated from Protocol buffers, and they are not type-safe as typical gRPC service and stub implementations.\nThis is mostly due to the generic nature of the Spring Integration framework itself, where the unit of work is a `Message` abstraction and the payload type of this message is usually out of integration component internal logic scope.\nTherefore, gRPC messages for service calls are sent and received as is without conversion assumptions.\nFor example, if gRPC service methods are like this:\n\n[source,protobuf]\n----\nservice TestHelloWorld {\n\n // Sends a greeting\n rpc SayHello(HelloRequest) returns (HelloReply) {}\n\n // Sends a greeting and something else\n rpc StreamSayHello(HelloRequest) returns (stream HelloReply) {}\n\n // Sends a greeting to everyone present\n rpc HelloToEveryOne(stream HelloRequest) returns (HelloReply) {}\n\n // Streams requests and replies\n rpc BidiStreamHello(stream HelloRequest) returns (stream HelloReply) {}\n\n}\n----\n\nThe `HelloRequest` will be a request message payload on the inbound gateway (server) side, and has to be on the outbound gateway (client) side request.\nTherefore, the `HelloReply` has to be a reply message payload on the inbound gateway, and will be received on the outbound gateway.\n\nThe `GrpcHeaders` class contains convenient constants for header names used (and populated) in messages before and after gRPC gateways.\nFor example, the `GrpcHeaders.METHOD_TYPE` header contains a `io.grpc.MethodDescriptor.MethodType` enum value on the server side (inbound gateway) for easier downstream routing.\nAnother useful header is a `GrpcHeaders.SERVICE_METHOD` which indicates what gRPC service method was called on the server, or what gRPC service method to call from the client stub.\n\nNOTE: The `GrpcHeaders.SERVICE_METHOD` header on the inbound gateway has a value of the gRPC service method name exactly as it is declared in the Protobuf (see `.proto` example above) and how it is stored into the `io.grpc.MethodDescriptor` of the service definition.\n\n[[grpc-inbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/grpc.adoc", "title": "grpc", "heading": "grpc", "heading_level": 1, "file_order": 217, "section_index": 0, "content_hash": "62cd0202b744183968b77a6d9f3084dea9938482d77ef1599939878afc8d9f60", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/grpc.adoc"}}
{"id": "sha256:d6e1431d6e23950b755a0b47d340a5facc967754618453566f33c5cef7a0ad59", "content": "The `GrpcInboundGateway` is a `MessagingGatewaySupport` implementation to receive gRPC requests, send messages to the downstream flow, and produce gRPC responses.\nFor initialization, the instance of this gateway requires only an abstract gRPC service class implementing `BindableService`, usually generated from Protobuf and comes with a `*ImplBase` class name.\n\nWARNING: Only standard gRPC services are supported: a generated `AsyncService` contract is what `GrpcInboundGateway` logic is based on.\nThe Reactor and Kotlin-based service generation don't make sense in Spring Integration logic since those types are not exposed from the gateway definition.\n\nThe gateway uses the mentioned `AsyncService` interface to create a proxy and intercept gRPC service methods.\n\nThe following example demonstrates how to configure a `GrpcInboundGateway`:\n\n[source, java]\n----\n@Bean\nGrpcInboundGateway helloWorldService() {\n return new GrpcInboundGateway(TestHelloWorldGrpc.TestHelloWorldImplBase.class);\n}\n----\n\nThe `GrpcInboundGateway` implements a `BindableService` and exposes a `ServerServiceDefinition` based on the mentioned proxy for an `AsyncService` contract of the gRPC service.\nTherefore, an instance of this gateway has to be registered into a `ServerBuilder` and there is no need for any other `*ImplBase` implementations in the application.\n\nIMPORTANT: With https://spring.io/projects/spring-grpc[Spring gRPC] and its auto-discovery for `BindableService` implementations, the `GrpcInboundGateway` has to be declared as a top-level bean.\nTherefore, Java DSL API like `IntegrationFlow.from(new GrpcInboundGateway(TestHelloWorldGrpc.TestHelloWorldImplBase.class))` is not recommended because such a `BindableService` implementation won't make it visible for respective Spring gRPC infrastructure.\n\nThe `GrpcInboundGateway` uses a `sendAndReceiveMessageReactive()` API to interact with the downstream flow and adapts a `Mono` reply to the gRPC `StreamObserver`.\nAs mentioned before, the request message payload is exactly a gRPC request message, and it expects a reply in the form of a gRPC response message.\nThe downstream logic can be type-safe and deal with gRPC messages in a similar way as if `*ImplBase` would be implemented manually.\n\nThe `MethodDescriptor.MethodType.UNARY` and `MethodDescriptor.MethodType.BIDI_STREAMING` are the same from the downstream handling logic perspective.\nIn other words, the `BIDI_STREAMING` is handled as a loop on request items and the gateway produces a response item immediately into the response `StreamObserver`.\nFor different `BIDI_STREAMING` logic, the regular gRPC service implementation is recommended.\n\nThe `MethodDescriptor.MethodType.CLIENT_STREAMING` mode produces a message with a `Flux` as a payload of gRPC request items.\n\nFor the `MethodDescriptor.MethodType.SERVER_STREAMING` mode, a reply payload can be a single gRPC response message or a `Flux` of them.\n\nThe following example demonstrates an `IntegrationFlow` implementation for the mentioned `TestHelloWorldGrpc.TestHelloWorldImplBase` service:\n\n[source, java]\n----\n@Bean\nIntegrationFlow grpcIntegrationFlow(GrpcInboundGateway helloWorldService) {\n return IntegrationFlow.from(helloWorldService)\n .route(Message.class, message ->\n message.getHeaders().get(GrpcHeaders.SERVICE_METHOD, String.class),\n router -> router\n\n .subFlowMapping(\"SayHello\", flow -> flow\n .transform(this::requestReply))\n\n .subFlowMapping(\"StreamSayHello\", flow -> flow\n .transform(this::streamReply))\n\n .subFlowMapping(\"HelloToEveryOne\", flow -> flow\n .transformWith(transformSpec -> transformSpec\n .transformer(this::streamRequest)\n .async(true)))\n\n .subFlowMapping(\"BidiStreamHello\", flow -> flow\n .transform(this::requestReply))\n )\n .get();\n}\n\nprivate HelloReply requestReply(HelloRequest helloRequest) {\n return newHelloReply(\"Hello \" + helloRequest.getName());\n}\n\nprivate Flux<HelloReply> streamReply(HelloRequest helloRequest) {\n return Flux.just(\n newHelloReply(\"Hello \" + helloRequest.getName()),\n newHelloReply(\"Hello again!\"));\n}\n\nprivate Mono<HelloReply> streamRequest(Flux<HelloRequest> request) {\n return request\n .map(HelloRequest::getName)\n .collectList()\n .map(names -> StringUtils.collectionToDelimitedString(names, \", \"))\n .map(\"Hello \"::concat)\n .map(TestConfig::newHelloReply);\n}\n\nprivate static HelloReply newHelloReply(String message) {\n return HelloReply.newBuilder().setMessage(message).build();\n}\n----\n\nThe routing is done on the `GrpcHeaders.SERVICE_METHOD` header populated by the `GrpcInboundGateway`.\nAll the downstream transformer business methods are type-safe in regard to gRPC messages for the `TestHelloWorldGrpc.TestHelloWorldImplBase` service.\n\n[[configuration-grpc-inbound-gateway-with-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/grpc.adoc", "title": "grpc", "heading": "Inbound Gateway for gRPC", "heading_level": 2, "file_order": 217, "section_index": 1, "content_hash": "d6e1431d6e23950b755a0b47d340a5facc967754618453566f33c5cef7a0ad59", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/grpc.adoc"}}
{"id": "sha256:482427c29d4dac820a0ab843030d353afb9856840b638c05f3107733fe25704b", "content": "Use the `Grpc` factory to add the `GrpcInboundGateway` to flows using the xref:dsl.adoc[].\n[source,java]\n----\n@Bean\nIntegrationFlow grpcInboundFlow() {\n return IntegrationFlow.from(\n Grpc.inboundGateway(TestSingleHelloWorldGrpc.TestSingleHelloWorldImplBase.class)\n .requestTimeout(3000L))\n .transform(this::requestReply)\n .get();\n}\n\nprivate HelloReply requestReply(HelloRequest helloRequest) {\n return HelloReply.newBuilder().setMessage(\"Hello \" + helloRequest.getName()).build();\n}\n\n----\n\n[[grpc-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/grpc.adoc", "title": "grpc", "heading": "Configuration with DSL", "heading_level": 3, "file_order": 217, "section_index": 2, "content_hash": "482427c29d4dac820a0ab843030d353afb9856840b638c05f3107733fe25704b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/grpc.adoc"}}
{"id": "sha256:5987f77b99d6c67a6be932277226d98ccac80ec9aef80f02f8df58149bdb1952", "content": "The `GrpcOutboundGateway` is an `AbstractReplyProducingMessageHandler` implementation to send gRPC requests to a remote gRPC server and receive responses acting as a gRPC stub.\nFor initialization, the instance of this gateway requires a gRPC `Channel` and the gRPC service class (e.g., `TestHelloWorldGrpc.class`).\n\nThe gateway dynamically invokes gRPC methods obtained from the service's `ServiceDescriptor`.\nIt supports the following gRPC communication patterns:\n\n* **Unary**: Single request -> if `async` is true then `Mono` is returned else it is the response object\n* **Server streaming**: Single request -> `Flux` of multiple responses\n* **Client streaming**: Multiple requests -> `Mono` with single response\n* **Bidirectional streaming**: Multiple requests -> `Flux` of multiple responses\n\nNOTE: The `GrpcOutboundGateway` is asynchronous by default.\nCan be turned off by `setAsync(false)` at the gateway configuration.\nSee more information in the xref:service-activator.adoc#async-service-activator[Asynchronous Service Activator].\n\n[[grpc-outbound-method-name-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/grpc.adoc", "title": "grpc", "heading": "Outbound Gateway for gRPC", "heading_level": 2, "file_order": 217, "section_index": 3, "content_hash": "5987f77b99d6c67a6be932277226d98ccac80ec9aef80f02f8df58149bdb1952", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/grpc.adoc"}}
{"id": "sha256:fda6138a56ca61a708cde771b514e76f008af208e2d92469a06421c0cd960ae5", "content": "The method name to invoke can be configured in four ways:\n\n1. **Auto-detection** for services with a single method:\n+\n[source, java]\n----\n@Bean\npublic GrpcOutboundGateway grpcOutboundGateway(ManagedChannel channel) {\n // When TestSingleMethodGrpc has only one method, it will be auto-detected\n return new GrpcOutboundGateway(channel, TestSingleMethodGrpc.class);\n}\n----\n2. **Explicit method name** using `setMethodName()`:\n+\n[source, java]\n----\n@Bean\npublic GrpcOutboundGateway grpcOutboundGateway(ManagedChannel channel) {\n GrpcOutboundGateway gateway = new GrpcOutboundGateway(channel, TestHelloWorldGrpc.class);\n gateway.setMethodName(\"SayHello\");\n return gateway;\n}\n----\n\n3. **Dynamic resolution** via `setMethodNameExpression()`:\n+\n[source, java]\n----\n@Bean\npublic GrpcOutboundGateway dynamicMethodGateway(ManagedChannel channel) {\n GrpcOutboundGateway gateway = new GrpcOutboundGateway(channel, TestHelloWorldGrpc.class);\n gateway.setMethodNameExpression(new SpelExpressionParser().parseExpression(\"payload.class.simpleName\"));\n return gateway;\n}\n----\n+\n4. **Default method resolution** if neither a method name nor a method name expression is configured, and the service offers multiple methods, the gateway will look for the `GrpcHeaders.SERVICE_METHOD` header in the input message to determine which method to invoke.\nIf the `GrpcHeaders.SERVICE_METHOD` header is missing, an `IllegalStateException` is thrown.\n+\n[source, java]\n----\n@Bean\npublic GrpcOutboundGateway dynamicMethodGateway(ManagedChannel channel) {\n // Looks for GrpcHeaders.SERVICE_METHOD header in the input message\n return new GrpcOutboundGateway(channel, TestHelloWorldGrpc.class);\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/grpc.adoc", "title": "grpc", "heading": "Method Name Configuration", "heading_level": 3, "file_order": 217, "section_index": 4, "content_hash": "fda6138a56ca61a708cde771b514e76f008af208e2d92469a06421c0cd960ae5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/grpc.adoc"}}
{"id": "sha256:deb9bf120f4e4c1c8609335277e2d3c2698d35526e9c599aa07f249867c45a63", "content": "The `GrpcOutboundGateway` automatically detects the method type from the `MethodDescriptor` and handles the invocation appropriately:\n\n* **Unary** methods accept a single gRPC request message, returning a `Mono<ResponseType>` in the async mode (by default).\nIf `async` is set to `false`, then the response object is returned into a reply message payload as is.\n\n* **Server streaming** methods accept a single gRPC request message and return a `Flux<ResponseType>`.\n\n* **Client streaming** and **Bidirectional streaming** methods accept flexible input types:\n** `Flux<RequestType>`\n** `Mono<RequestType>`\n** `Stream<RequestType>`\n** `Collection<RequestType>`\n** `RequestTypes[]`\n** Single `RequestType` object\n\nClient streaming methods return a `Mono<ResponseType>`, while bidirectional streaming methods return a `Flux<ResponseType>` containing the response.\n\n[[configuration-grpc-outbound-gateway-with-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/grpc.adoc", "title": "grpc", "heading": "Request Payload Handling", "heading_level": 3, "file_order": 217, "section_index": 5, "content_hash": "deb9bf120f4e4c1c8609335277e2d3c2698d35526e9c599aa07f249867c45a63", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/grpc.adoc"}}
{"id": "sha256:f49a9b56d198de35b1feda495d04dbe9ab52c41bb2590c027631c1f190f4fd7b", "content": "Use the `Grpc` factory to add the `GrpcOutboundGateway` to flows using the xref:dsl.adoc[].\nThe simplest configuration for a service with a single method:\n\n[source,java]\n----\n@Bean\nIntegrationFlow grpcOutboundFlow(ManagedChannel channel) {\n\treturn f -> f\n .handle(Grpc.outboundGateway(channel, TestSingleHelloWorldGrpc.class))\n .transform(this::upperCase);\n}\n\nprivate HelloReply upperCase(HelloReply helloReply) {\n return HelloReply.newBuilder().setMessage(helloReply.getMessage().toUpperCase()).build();\n}\n----\n\nWhen the gRPC service has only one method, it will be auto-detected.\n\nFor services with multiple methods, use the DSL's `.methodName()`,`.methodNameExpression()`, or `.methodNameFunction()` methods.\nSee <<grpc-outbound-method-name-configuration>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/grpc.adoc", "title": "grpc", "heading": "Configuration with DSL", "heading_level": 3, "file_order": 217, "section_index": 6, "content_hash": "f49a9b56d198de35b1feda495d04dbe9ab52c41bb2590c027631c1f190f4fd7b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/grpc.adoc"}}
{"id": "sha256:d19ca7d67c0f6ebc393e16df3e859c21a2d31d4f9c1143b7a98c9c00136d64a4", "content": "[[message-handler-advice-chain]]\n\nPrior to Spring Integration 2.2, you could add behavior to an entire Integration flow by adding an AOP Advice to a poller's `<advice-chain/>` element.\nHowever, suppose you want to retry, say, just a REST Web Service call, and not any downstream endpoints.\n\nFor example, consider the following flow:\n\n[source]\ninbound-adapter->poller->http-gateway1->http-gateway2->jdbc-outbound-adapter\n\nIf you configure some retry-logic into an advice chain on the poller and the call to `http-gateway2` failed because of a network glitch, the retry causes both `http-gateway1` and `http-gateway2` to be called a second time.\nSimilarly, after a transient failure in the jdbc-outbound-adapter, both HTTP gateways are called a second time before again calling the `jdbc-outbound-adapter`.\n\nSpring Integration 2.2 adds the ability to add behavior to individual endpoints.\nThis is achieved by the addition of the `<request-handler-advice-chain/>` element to many endpoints.\nThe following example shows how to the `<request-handler-advice-chain/>` element within an `outbound-gateway`:\n\n[source,xml]\n----\n<int-http:outbound-gateway id=\"withAdvice\"\n url-expression=\"'http://localhost/test1'\"\n request-channel=\"requests\"\n reply-channel=\"nextChannel\">\n <int-http:request-handler-advice-chain>\n <ref bean=\"myRetryAdvice\" />\n </int-http:request-handler-advice-chain>\n</int-http:outbound-gateway>\n----\n\nIn this case, `myRetryAdvice` is applied only locally to this gateway and does not apply to further actions taken downstream after the reply is sent to `nextChannel`.\nThe scope of the advice is limited to the endpoint itself.\n\n[IMPORTANT]\n=====\nAt this time, you cannot advise an entire `<chain/>` of endpoints.\nThe schema does not allow a `<request-handler-advice-chain>` as a child element of the chain itself.\n\nHowever, a `<request-handler-advice-chain>` can be added to individual reply-producing endpoints within a `<chain>` element.\nAn exception is that, in a chain that produces no reply, because the last element in the chain is an `outbound-channel-adapter`, that last element cannot be advised.\nIf you need to advise such an element, it must be moved outside the chain (with the `output-channel` of the chain being the `input-channel` of the adapter).\nThe adapter can then be advised as usual.\nFor chains that produce a reply, every child element can be advised.\n=====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/handler-advice.adoc", "title": "handler-advice", "heading": "handler-advice", "heading_level": 1, "file_order": 218, "section_index": 0, "content_hash": "d19ca7d67c0f6ebc393e16df3e859c21a2d31d4f9c1143b7a98c9c00136d64a4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/handler-advice.adoc"}}
{"id": "sha256:09b0cd1e1532192a6d418706e19859e015716e91fb19b3153a8fda5ba484c2cf", "content": "[[hazelcast]]\n\nSpring Integration provides channel adapters and other utility components to interact with an in-memory data grid https://hazelcast.com[Hazelcast].\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-hazelcast</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-hazelcast:{project-version}\"\n----\n======\n\nThe XML namespace and schemaLocation definitions for Hazelcast components are:\n\n[source,xml]\n----\nxmlns:int-hazelcast=\"http://www.springframework.org/schema/integration/hazelcast\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/integration/hazelcast\n https://www.springframework.org/schema/integration/hazelcast/spring-integration-hazelcast.xsd\"\n----\n\n[[hazelcast-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/hazelcast.adoc", "title": "hazelcast", "heading": "hazelcast", "heading_level": 1, "file_order": 219, "section_index": 0, "content_hash": "09b0cd1e1532192a6d418706e19859e015716e91fb19b3153a8fda5ba484c2cf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/hazelcast.adoc"}}
{"id": "sha256:805b397f0357fe94123a342ef1c54bf113cd01dc41a7e14a5905c248a6c71492", "content": "Hazelcast provides distributed data structures such as:\n\n* `com.hazelcast.map.IMap`\n* `com.hazelcast.multimap.MultiMap`\n* `com.hazelcast.collection.IList`\n* `com.hazelcast.collection.ISet`\n* `com.hazelcast.collection.IQueue`\n* `com.hazelcast.topic.ITopic`\n* `com.hazelcast.replicatedmap.ReplicatedMap`\n\nIt also provides event listeners in order to listen to modifications made to these data structures.\n\n* `com.hazelcast.core.EntryListener<K, V>`\n* `com.hazelcast.collection.ItemListener`\n* `com.hazelcast.topic.MessageListener`\n\nThe Hazelcast Event-Driven Inbound Channel Adapter listens to related cache events and sends event messages to the defined channel.\nIt supports both XML and JavaConfig driven configurations.\n\n[[xml-configuration-:]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/hazelcast.adoc", "title": "hazelcast", "heading": "Hazelcast Event-driven Inbound Channel Adapter", "heading_level": 2, "file_order": 219, "section_index": 1, "content_hash": "805b397f0357fe94123a342ef1c54bf113cd01dc41a7e14a5905c248a6c71492", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/hazelcast.adoc"}}
{"id": "sha256:6ecced01c302796d052f5e30e426322e0ce6358f54f4ef95952eaa6a9d403dc2", "content": "[source,xml]\n----\n<int-hazelcast:inbound-channel-adapter channel=\"mapChannel\"\n cache=\"map\"\n cache-events=\"UPDATED, REMOVED\"\n cache-listening-policy=\"SINGLE\" />\n----\n\nThe Hazelcast Event-Driven Inbound Channel Adapter requires the following attributes:\n\n* `channel`: Specifies the channel to which messages are sent;\n* `cache`: Specifies the distributed Object reference which is listened to.\nIt is a mandatory attribute;\n* `cache-events`: Specifies cache events which are listened for.\nIt is an optional attribute and its default value is `ADDED`.\nIts supported values are as follows :\n\n* Supported cache event types for `IMap` and `MultiMap`: `ADDED`, `REMOVED`, `UPDATED`, `EVICTED`, `EVICT_ALL` and `CLEAR_ALL`;\n* Supported cache event types for `ReplicatedMap`: `ADDED`, `REMOVED`, `UPDATED`, `EVICTED`;\n* Supported cache event types for `IList`, `ISet` and `IQueue`: `ADDED`, `REMOVED`.\nThere are no cache event types for `ITopic`.\n\n* `cache-listening-policy`: Specifies the cache listening policy as `SINGLE` or `ALL`.\nIt is an optional attribute and its default value is `SINGLE`.\nEach Hazelcast inbound channel adapter listening to the same cache object with the same cache-events attribute can receive a single event message or all event messages.\nIf it is `ALL`, all Hazelcast inbound channel adapters listening to the same cache object with the same cache-events attribute will receive all event messages.\nIf it is `SINGLE`, they will receive unique event messages.\n\nSome configuration samples:\n\n[source,xml]\n.Distributed Map\n----\n<int:channel id=\"mapChannel\"/>\n\n<int-hazelcast:inbound-channel-adapter channel=\"mapChannel\"\n cache=\"map\"\n cache-events=\"UPDATED, REMOVED\" />\n\n<bean id=\"map\" factory-bean=\"instance\" factory-method=\"getMap\">\n <constructor-arg value=\"map\"/>\n</bean>\n\n<bean id=\"instance\" class=\"com.hazelcast.core.Hazelcast\"\n factory-method=\"newHazelcastInstance\">\n <constructor-arg>\n <bean class=\"com.hazelcast.config.Config\" />\n </constructor-arg>\n</bean>\n----\n\n[source,xml]\n.Distributed MultiMap\n----\n<int-hazelcast:inbound-channel-adapter channel=\"multiMapChannel\"\n cache=\"multiMap\"\n cache-events=\"ADDED, REMOVED, CLEAR_ALL\" />\n\n<bean id=\"multiMap\" factory-bean=\"instance\" factory-method=\"getMultiMap\">\n <constructor-arg value=\"multiMap\"/>\n</bean>\n----\n\n[source,xml]\n.Distributed List\n----\n<int-hazelcast:inbound-channel-adapter channel=\"listChannel\"\n cache=\"list\"\n cache-events=\"ADDED, REMOVED\"\n cache-listening-policy=\"ALL\" />\n\n<bean id=\"list\" factory-bean=\"instance\" factory-method=\"getList\">\n <constructor-arg value=\"list\"/>\n</bean>\n----\n\n[source,xml]\n.Distributed Set\n----\n<int-hazelcast:inbound-channel-adapter channel=\"setChannel\" cache=\"set\" />\n\n<bean id=\"set\" factory-bean=\"instance\" factory-method=\"getSet\">\n <constructor-arg value=\"set\"/>\n</bean>\n----\n\n[source,xml]\n.Distributed Queue\n----\n<int-hazelcast:inbound-channel-adapter channel=\"queueChannel\"\n cache=\"queue\"\n cache-events=\"REMOVED\"\n cache-listening-policy=\"ALL\" />\n\n<bean id=\"queue\" factory-bean=\"instance\" factory-method=\"getQueue\">\n <constructor-arg value=\"queue\"/>\n</bean>\n----\n\n[source,xml]\n.Distributed Topic\n----\n<int-hazelcast:inbound-channel-adapter channel=\"topicChannel\" cache=\"topic\" />\n\n<bean id=\"topic\" factory-bean=\"instance\" factory-method=\"getTopic\">\n <constructor-arg value=\"topic\"/>\n</bean>\n----\n\n[source,xml]\n.Replicated Map\n----\n<int-hazelcast:inbound-channel-adapter channel=\"replicatedMapChannel\"\n cache=\"replicatedMap\"\n cache-events=\"ADDED, UPDATED, REMOVED\"\n cache-listening-policy=\"SINGLE\" />\n\n<bean id=\"replicatedMap\" factory-bean=\"instance\" factory-method=\"getReplicatedMap\">\n <constructor-arg value=\"replicatedMap\"/>\n</bean>\n----\n\n[[java-configuration-sample:]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/hazelcast.adoc", "title": "hazelcast", "heading": "XML Configuration :", "heading_level": 3, "file_order": 219, "section_index": 2, "content_hash": "6ecced01c302796d052f5e30e426322e0ce6358f54f4ef95952eaa6a9d403dc2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/hazelcast.adoc"}}
{"id": "sha256:c4a52096c28ca58c74ae9d676a92df265e82918ca57f10bc38de11a4bbae9bcb", "content": "The following sample shows a `DistributedMap` configuration.\nThe same configuration can be used for other distributed data structures(`IMap`, `MultiMap`, `ReplicatedMap`, `IList`, `ISet`, `IQueue` and `ITopic`):\n\n[source,java]\n----\n@Bean\npublic PollableChannel distributedMapChannel() {\n return new QueueChannel();\n}\n\n@Bean\npublic IMap<Integer, String> distributedMap() {\n return hazelcastInstance().getMap(\"Distributed_Map\");\n}\n\n@Bean\npublic HazelcastInstance hazelcastInstance() {\n return Hazelcast.newHazelcastInstance();\n}\n\n@Bean\npublic HazelcastEventDrivenMessageProducer hazelcastEventDrivenMessageProducer() {\n final HazelcastEventDrivenMessageProducer producer = new HazelcastEventDrivenMessageProducer(distributedMap());\n producer.setOutputChannel(distributedMapChannel());\n producer.setCacheEventTypes(\"ADDED,REMOVED,UPDATED,CLEAR_ALL\");\n producer.setCacheListeningPolicy(CacheListeningPolicyType.SINGLE);\n\n return producer;\n}\n----\n\n[[hazelcast-continuous-query]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/hazelcast.adoc", "title": "hazelcast", "heading": "Java Configuration Sample:", "heading_level": 3, "file_order": 219, "section_index": 3, "content_hash": "c4a52096c28ca58c74ae9d676a92df265e82918ca57f10bc38de11a4bbae9bcb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/hazelcast.adoc"}}
{"id": "sha256:af3d75f31406b6ace4f4bca25e2dd7c8a628ce1b4e874511633fa62b55fbb92c", "content": "Hazelcast Continuous Query enables listening to modifications performed on specific map entries.\nThe Hazelcast Continuous Query Inbound Channel Adapter is an event-driven channel adapter that listens to the related distributed map events in the light of the defined predicate.\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic PollableChannel cqDistributedMapChannel() {\n return new QueueChannel();\n}\n\n@Bean\npublic IMap<Integer, String> cqDistributedMap() {\n return hazelcastInstance().getMap(\"CQ_Distributed_Map\");\n}\n\n@Bean\npublic HazelcastInstance hazelcastInstance() {\n return Hazelcast.newHazelcastInstance();\n}\n\n@Bean\npublic HazelcastContinuousQueryMessageProducer hazelcastContinuousQueryMessageProducer() {\n final HazelcastContinuousQueryMessageProducer producer =\n new HazelcastContinuousQueryMessageProducer(cqDistributedMap(), \"surname=TestSurname\");\n producer.setOutputChannel(cqDistributedMapChannel());\n producer.setCacheEventTypes(\"UPDATED\");\n producer.setIncludeValue(false);\n\n return producer;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"cqMapChannel\"/>\n\n<int-hazelcast:cq-inbound-channel-adapter\n channel=\"cqMapChannel\"\n cache=\"cqMap\"\n cache-events=\"UPDATED, REMOVED\"\n predicate=\"name=TestName AND surname=TestSurname\"\n include-value=\"true\"\n cache-listening-policy=\"SINGLE\"/>\n\n<bean id=\"cqMap\" factory-bean=\"instance\" factory-method=\"getMap\">\n <constructor-arg value=\"cqMap\"/>\n</bean>\n\n<bean id=\"instance\" class=\"com.hazelcast.core.Hazelcast\"\n factory-method=\"newHazelcastInstance\">\n <constructor-arg>\n <bean class=\"com.hazelcast.config.Config\" />\n </constructor-arg>\n</bean>\n----\n======\n\nIt supports six attributes as follows:\n\n* `channel`: Specifies the channel to which messages are sent;\n* `cache`: Specifies the distributed Map reference which is listened to.\nMandatory;\n* `cache-events`: Specifies cache events which are listened for.\nOptional attribute with `ADDED` being its default value.\nSupported values are `ADDED`, `REMOVED`, `UPDATED`, `EVICTED`, `EVICT_ALL` and `CLEAR_ALL`;\n* `predicate`: Specifies a predicate to listen to the modifications performed on specific map entries.\nMandatory;\n* `include-value`: Specifies including the value and oldValue in a continuous query result.\nOptional with `true` being the default;\n* `cache-listening-policy`: Specifies the cache listening policy as `SINGLE` or `ALL`.\nOptional with the default value being `SINGLE`.\nEach Hazelcast CQ inbound channel adapter listening to the same cache object with the same cache-events attribute can receive a single event message or all event messages.\nIf it is `ALL`, all Hazelcast CQ inbound channel adapters listening to the same cache object with the same cache-events attribute will receive all event messages.\nIf it is `SINGLE`, they will receive unique event messages.\n\n[[hazelcast-cluster-monitor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/hazelcast.adoc", "title": "hazelcast", "heading": "Hazelcast Continuous Query Inbound Channel Adapter", "heading_level": 2, "file_order": 219, "section_index": 4, "content_hash": "af3d75f31406b6ace4f4bca25e2dd7c8a628ce1b4e874511633fa62b55fbb92c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/hazelcast.adoc"}}
{"id": "sha256:e1ee9dab766fc717d4d1a890f22208f5c9b104aab9c306c3c2cf0298f7c22c10", "content": "A Hazelcast Cluster Monitor supports listening to modifications performed on the cluster.\nThe Hazelcast Cluster Monitor Inbound Channel Adapter is an event-driven channel adapter and listens to related Membership, Distributed Object, Migration, Lifecycle and Client events:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic PollableChannel eventChannel() {\n return new QueueChannel();\n}\n\n@Bean\npublic HazelcastInstance hazelcastInstance() {\n return Hazelcast.newHazelcastInstance();\n}\n\n@Bean\npublic HazelcastClusterMonitorMessageProducer hazelcastClusterMonitorMessageProducer() {\n HazelcastClusterMonitorMessageProducer producer = new HazelcastClusterMonitorMessageProducer(hazelcastInstance());\n producer.setOutputChannel(eventChannel());\n producer.setMonitorEventTypes(\"DISTRIBUTED_OBJECT\");\n\n return producer;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"monitorChannel\"/>\n\n<int-hazelcast:cm-inbound-channel-adapter\n channel=\"monitorChannel\"\n hazelcast-instance=\"instance\"\n monitor-types=\"MEMBERSHIP, DISTRIBUTED_OBJECT\" />\n\n<bean id=\"instance\" class=\"com.hazelcast.core.Hazelcast\"\n factory-method=\"newHazelcastInstance\">\n <constructor-arg>\n <bean class=\"com.hazelcast.config.Config\" />\n </constructor-arg>\n</bean>\n----\n======\n\nIt supports three attributes as follows :\n\n* `channel`: Specifies the channel to which messages are sent;\n* `hazelcast-instance`: Specifies the Hazelcast Instance reference to listen for cluster events.\nIt is a mandatory attribute;\n* `monitor-types`: Specifies the monitor types which are listened for.\nIt is an optional attribute with `MEMBERSHIP` being the default value.\nSupported values are `MEMBERSHIP`, `DISTRIBUTED_OBJECT`, `MIGRATION`, `LIFECYCLE`, `CLIENT`.\n\n[[hazelcast-distributed-sql]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/hazelcast.adoc", "title": "hazelcast", "heading": "Hazelcast Cluster Monitor Inbound Channel Adapter", "heading_level": 2, "file_order": 219, "section_index": 5, "content_hash": "e1ee9dab766fc717d4d1a890f22208f5c9b104aab9c306c3c2cf0298f7c22c10", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/hazelcast.adoc"}}
{"id": "sha256:a1bfe5e1da8d0fc18e18531a2c59182eec0ebb9823afadc4252b5f26045437fc", "content": "Hazelcast allows running distributed queries on the distributed map.\nThe Hazelcast Distributed SQL Inbound Channel Adapter is a polling inbound channel adapter.\nIt runs the defined distributed-sql command and returns results depending on the iteration type.\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic PollableChannel dsDistributedMapChannel() {\n return new QueueChannel();\n}\n\n@Bean\npublic IMap<Integer, String> dsDistributedMap() {\n return hazelcastInstance().getMap(\"DS_Distributed_Map\");\n}\n\n@Bean\npublic HazelcastInstance hazelcastInstance() {\n return Hazelcast.newHazelcastInstance();\n}\n\n@Bean\n@InboundChannelAdapter(value = \"dsDistributedMapChannel\", poller = @Poller(maxMessagesPerPoll = \"1\"))\npublic HazelcastDistributedSQLMessageSource hazelcastDistributedSQLMessageSource() {\n final HazelcastDistributedSQLMessageSource messageSource =\n new HazelcastDistributedSQLMessageSource(dsDistributedMap(),\n \"name='TestName' AND surname='TestSurname'\");\n messageSource.setIterationType(DistributedSQLIterationType.ENTRY);\n\n return messageSource;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:channel id=\"dsMapChannel\"/>\n\n<int-hazelcast:ds-inbound-channel-adapter\n channel=\"dsMapChannel\"\n cache=\"dsMap\"\n iteration-type=\"ENTRY\"\n distributed-sql=\"active=false OR age >= 25 OR name = 'TestName'\">\n <int:poller fixed-delay=\"100\"/>\n</int-hazelcast:ds-inbound-channel-adapter>\n\n<bean id=\"dsMap\" factory-bean=\"instance\" factory-method=\"getMap\">\n <constructor-arg value=\"dsMap\"/>\n</bean>\n\n<bean id=\"instance\" class=\"com.hazelcast.core.Hazelcast\"\n factory-method=\"newHazelcastInstance\">\n <constructor-arg>\n <bean class=\"com.hazelcast.config.Config\" />\n </constructor-arg>\n</bean>\n----\n======\n\nIt requires a poller and supports four attributes:\n\n* `channel`: Specifies the channel to which messages are sent.\nIt is a mandatory attribute;\n* `cache`: Specifies the distributed `IMap` reference which is queried.\nIt is a mandatory attribute;\n* `iteration-type`: Specifies a result type.\nDistributed SQL can be run on `EntrySet`, `KeySet`, `LocalKeySet` or `Values`.\nIt is an optional attribute with `VALUE` being the default.\nSupported values are `ENTRY`, `KEY`, `LOCAL_KEY` and `VALUE`;\n* `distributed-sql`: Specifies the where clause of the SQL statement.\nIt is a mandatory attribute.\n\n[[hazelcast-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/hazelcast.adoc", "title": "hazelcast", "heading": "Hazelcast Distributed SQL Inbound Channel Adapter", "heading_level": 2, "file_order": 219, "section_index": 6, "content_hash": "a1bfe5e1da8d0fc18e18531a2c59182eec0ebb9823afadc4252b5f26045437fc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/hazelcast.adoc"}}
{"id": "sha256:035e21bddf1ea1ffd3028a028c2c5559850205126c93b3e83f9e73e4771959e9", "content": "The Hazelcast Outbound Channel Adapter listens to its defined channel and writes incoming messages to a related distributed cache.\nIt expects one of `cache`, `cache-expression` or `HazelcastHeaders.CACHE_NAME` for distributed object definition.\nSupported Distributed Objects are: `IMap`, `MultiMap`, `ReplicatedMap`, `IList`, `ISet`, `IQueue` and `ITopic`.\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic MessageChannel distributedMapChannel() {\n return new DirectChannel();\n}\n\n@Bean\npublic IMap<Integer, String> distributedMap() {\n return hzInstance().getMap(\"Distributed_Map\");\n}\n\n@Bean\npublic HazelcastInstance hzInstance() {\n return Hazelcast.newHazelcastInstance();\n}\n\n@Bean\n@ServiceActivator(inputChannel = \"distributedMapChannel\")\npublic HazelcastCacheWritingMessageHandler hazelcastCacheWritingMessageHandler() {\n HazelcastCacheWritingMessageHandler handler = new HazelcastCacheWritingMessageHandler();\n handler.setDistributedObject(distributedMap());\n handler.setKeyExpression(new SpelExpressionParser().parseExpression(\"payload.id\"));\n handler.setExtractPayload(true);\n return handler;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-hazelcast:outbound-channel-adapter channel=\"mapChannel\"\n cache-expression=\"headers['CACHE_HEADER']\"\n key-expression=\"payload.key\"\n extract-payload=\"true\"/>\n----\n======\n\nIt requires the following attributes :\n\n* `channel`: Specifies the channel to which messages are sent;\n* `cache`: Specifies the distributed object reference.\nOptional;\n* `cache-expression`: Specifies the distributed object via Spring Expression Language (SpEL).\nOptional;\n* `key-expression`: Specifies the key of a key-value pair via Spring Expression Language (SpEL).\nOptional and required for only for `IMap`, `MultiMap` and `ReplicatedMap` distributed data structures.\n* `extract-payload`: Specifies whether to send the whole message or just the payload.\nOptional attribute with `true` being the default.\nIf it is true, just the payload will be written to the distributed object.\nOtherwise, the whole message will be written by converting both message headers and payload.\n\nBy setting the distributed object name in the header, messages can be written to different distributed objects via the same channel.\nIf `cache` or `cache-expression` attributes are not defined, a `HazelcastHeaders.CACHE_NAME` header has to be set in a request `Message`.\n\n[[hazelcast-message-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/hazelcast.adoc", "title": "hazelcast", "heading": "Hazelcast Outbound Channel Adapter", "heading_level": 2, "file_order": 219, "section_index": 7, "content_hash": "035e21bddf1ea1ffd3028a028c2c5559850205126c93b3e83f9e73e4771959e9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/hazelcast.adoc"}}
{"id": "sha256:b35bff814f293b6f188b28a76cfaaefca333c79ccc7de79f3ca6137498c36856", "content": "For distributed messaging state management, for example for a persistent `QueueChannel` or tracking `Aggregator` message groups, the `HazelcastMessageStore` implementation is provided:\n\n[source,java]\n----\n@Bean\npublic HazelcastInstance hazelcastInstance() {\n return Hazelcast.newHazelcastInstance();\n}\n\n@Bean\npublic MessageGroupStore messageStore() {\n return new HazelcastMessageStore(hazelcastInstance());\n}\n----\n\nBy default, the `SPRING_INTEGRATION_MESSAGE_STORE` `IMap` is used to store messages and groups as a key/value.\nAny custom `IMap` can be provided to the `HazelcastMessageStore`.\n\n[[hazelcast-metadata-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/hazelcast.adoc", "title": "hazelcast", "heading": "Hazelcast Message Store", "heading_level": 2, "file_order": 219, "section_index": 8, "content_hash": "b35bff814f293b6f188b28a76cfaaefca333c79ccc7de79f3ca6137498c36856", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/hazelcast.adoc"}}
{"id": "sha256:97cdfb3a60bbff60d652bb0eb2ef0c2d04dee5d3e1703caf5c40fb4e0adc2ed9", "content": "An implementation of a `ListenableMetadataStore` is available using a backing Hazelcast `IMap`.\nThe default map is created with a name `SPRING_INTEGRATION_METADATA_STORE` which can be customized.\n\n[source,java]\n----\n@Bean\npublic HazelcastInstance hazelcastInstance() {\n return Hazelcast.newHazelcastInstance();\n}\n\n@Bean\npublic MetadataStore metadataStore() {\n return new HazelcastMetadataStore(hazelcastInstance());\n}\n----\n\nThe `HazelcastMetadataStore` implements `ListenableMetadataStore` which allows you to register your own listeners of type `MetadataStoreListener` to listen for events via `addListener(MetadataStoreListener callback)`.\n\n[[hazelcast-message-channels]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/hazelcast.adoc", "title": "hazelcast", "heading": "Hazelcast Metadata Store", "heading_level": 2, "file_order": 219, "section_index": 9, "content_hash": "97cdfb3a60bbff60d652bb0eb2ef0c2d04dee5d3e1703caf5c40fb4e0adc2ed9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/hazelcast.adoc"}}
{"id": "sha256:7a924b60cd881cd6f6c1df22504b5df07a2a2265fed320750581ea8219d2a037", "content": "The Hazelcast `IQueue` and `ITopic` distributed objects are, essentially, messaging primitives and can be used with Spring Integration core components without extra implementations in this Hazelcast module.\n\nThe xref:channel/implementations.adoc#channel-implementations-queuechannel[`QueueChannel`] can be supplied by any `java.util.Queue`, including the mentioned Hazelcast distributed `IQueue`:\n\n[source,java]\n----\n@Bean\nPollableChannel hazelcastQueueChannel(HazelcastInstance hazelcastInstance) {\n return new QueueChannel(hazelcastInstance.getQueue(\"springIntegrationQueue\"));\n}\n----\n\nPlacing this config on several nodes in Hazelcast cluster of the application will make the `QueueChannel` as distributed and only one node will be able to poll a single `Message` from that `IQueue`.\nThis works similar to xref:jms.adoc#jms-channel[`PollableJmsChannel`], xref:kafka.adoc#kafka-channels[`PollableKafkaChannel`] or xref:amqp/channels.adoc[`PollableAmqpChannel`].\n\nIf the producer side is not a Spring Integration application, there is no way to configure a `QueueChannel`, and therefore the plain Hazelcast `IQueue` API is used to produce the data.\nIn this case, the `QueueChannel` approach is wrong on the consumer side: an xref:channel-adapter.adoc#channel-adapter-namespace-inbound[Inbound Channel Adapter] solution must be used instead:\n\n[source,java]\n----\n@Bean\npublic IQueue<String> myStringHzQueue(HazelcastInstance hazelcastInstance) {\n return hazelcastInstance.getQueue(\"springIntegrationQueue\");\n}\n\n@Bean\n@InboundChannelAdapter(channel = \"stringValuesFromHzQueueChannel\")\nSupplier<String> fromHzIQueueSource(IQueue<String> myStringHzQueue) {\n return myStringHzQueue::poll;\n}\n----\n\nThe `ITopic` abstraction in Hazelcast has similar semantics to a `Topic` in JMS: all subscribers receive published messages.\nWith a pair of simple `MessageChannel` beans this mechanism is supported as an out-of-the-box feature:\n\n[source,java]\n----\n@Bean\npublic ITopic<Message<?>> springIntegrationTopic(HazelcastInstance hazelcastInstance,\n MessageChannel fromHazelcastTopicChannel) {\n\n ITopic<Message<?>> topic = hazelcastInstance.getTopic(\"springIntegrationTopic\");\n\ttopic.addMessageListener(m -> fromHazelcastTopicChannel.send(m.getMessageObject()));\n\treturn topic;\n}\n\n@Bean\npublic MessageChannel publishToHazelcastTopicChannel(ITopic<Message<?>> springIntegrationTopic) {\n return new FixedSubscriberChannel(springIntegrationTopic::publish);\n}\n\n@Bean\npublic MessageChannel fromHazelcastTopicChannel() {\n return new DirectChannel();\n}\n----\n\nThe `FixedSubscriberChannel` is an optimized variant of `DirectChannel`, which requires a `MessageHandler` on initialization.\nSince the `MessageHandler` is a functional interface a simple lambda for the `handleMessage` method can be provided.\nWhen a message is sent to the `publishToHazelcastTopicChannel` it is just published onto the Hazelcast `ITopic`.\nThe `com.hazelcast.topic.MessageListener` is a functional interface, too, hence a lambda to the `ITopic#addMessageListener` can be provided.\nSo, a subscriber to the `fromHazelcastTopicChannel` will consume all messages sent to the mentioned `ITopic`.\n\nAn `ExecutorChannel` can be supplied with an `IExecutorService`.\nFor example, with the respective configuration a cluster-wide singleton can be achieved:\n\n[source,java]\n----\n@Bean\npublic HazelcastInstance hazelcastInstance() {\n return Hazelcast.newHazelcastInstance(\n new Config()\n .addExecutorConfig(new ExecutorConfig()\n .setName(\"singletonExecutor\")\n .setPoolSize(1)));\n}\n\n@Bean\npublic MessageChannel hazelcastSingletonExecutorChannel(HazelcastInstance hazelcastInstance) {\n return new ExecutorChannel(hazelcastInstance.getExecutorService(\"singletonExecutor\"));\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/hazelcast.adoc", "title": "hazelcast", "heading": "Message Channels with Hazelcast", "heading_level": 2, "file_order": 219, "section_index": 10, "content_hash": "7a924b60cd881cd6f6c1df22504b5df07a2a2265fed320750581ea8219d2a037", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/hazelcast.adoc"}}
{"id": "sha256:a58ed05060d827b5aa4c0e0a51fef5d91f5577155716c5c7e4122da732fa63cd", "content": "[[history]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/history.adoc", "title": "history", "heading": "history", "heading_level": 1, "file_order": 220, "section_index": 0, "content_hash": "a58ed05060d827b5aa4c0e0a51fef5d91f5577155716c5c7e4122da732fa63cd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/history.adoc"}}
{"id": "sha256:9345804227241517ef14cb800d5e82f68ac2891d4af5a2895275e736e15fef1a", "content": "[[http]]\n\nSpring Integration's HTTP support allows for the running of HTTP requests and the processing of inbound HTTP requests.\nThe HTTP support consists of the following gateway implementations: `HttpInboundEndpoint` and `HttpRequestExecutingMessageHandler`.\nSee also xref:webflux.adoc[WebFlux Support].\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-http</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-http:{project-version}\"\n----\n======\n\nThe `jakarta.servlet:jakarta.servlet-api` dependency must be provided on the target Servlet container.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/http.adoc", "title": "http", "heading": "http", "heading_level": 1, "file_order": 221, "section_index": 0, "content_hash": "9345804227241517ef14cb800d5e82f68ac2891d4af5a2895275e736e15fef1a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/http.adoc"}}
{"id": "sha256:e5c876eddc4e834aea0d5a6c5782c38097c5052a70207d505007e46565531f8c", "content": "Welcome to the Spring Integration reference documentation!\n\n[horizontal]\nxref:preface.adoc#preface[Preface] :: General project info, conventions\nxref:whats-new.adoc#whats-new-part[What's New] :: Features and changes made in the current version\nxref:overview.adoc[Overview] :: Introduction to EIP and its implementation in the project\nxref:core.adoc[Core Messaging] :: Main project abstractions and components\nxref:overview.adoc#overview-components-message[Message] :: Details about the message abstraction implementations\nxref:message-routing.adoc[Message Routing] :: main EIP components: router, splitter, aggregator, filter etc.\nxref:message-transformation.adoc[Message Transformation] :: Transformer, content enricher, claim check, codec\nxref:messaging-endpoints.adoc[Messaging Endpoints] :: Consumer endpoints, service activator, gateway, scripting, AOP aspects etc.\nxref:dsl.adoc#java-dsl[Java DSL] :: Details about Java DSL for EIP\nxref:groovy-dsl.adoc[Groovy DSL] :: Details about Groovy DSL for EIP\nxref:kotlin-dsl.adoc[Kotlin DSL] :: Details about Kotlin DSL for EIP\nxref:system-management.adoc[System Management] :: Message store, control bus, integration graph, metrics, JMX\nxref:reactive-streams.adoc[Reactive Streams Support] :: Details about Reactive Streams support: message channels, channel adapters etc.\nxref:native-aot.adoc[Native Images Support] :: GraalVM native images and Spring AOT support\n\n[horizontal]\n**Integration Endpoints** ::\n\n[horizontal]\nxref:endpoint-summary.adoc[Integration Endpoint Summary] :: Protocol-specific channel adapters and gateways summary\nxref:amqp.adoc[AMQP Support] :: AMQP channels, adapters and gateways\nxref:camel.adoc[Apache Camel Support] :: Apache Camel channel adapters and gateways\nxref:cassandra.adoc[Apache Cassandra Support] :: Apache Cassandra channel adapters\nxref:debezium.adoc[Debezium CDC Support] :: Debezium channel adapters\nxref:event.adoc[Spring `ApplicationEvent` Support] :: Handling and consuming Spring application events with channel adapters\nxref:feed.adoc[Feed Adapter] :: RSS and Atom channel adapters\nxref:file.adoc[File Support] :: Channel adapters and gateways for file system support\nxref:ftp.adoc[FTP/FTPS Adapters] :: Channel adapters and gateways for FTP protocol\nxref:graphql.adoc[GraphQL Support] :: Channel adapters for GraphQL\nxref:hazelcast.adoc[Hazelcast Support] :: Channel adapters, gateways and utilities for Hazelcast\nxref:http.adoc[HTTP Support] :: Channel adapters and gateways for HTTP communication\nxref:jdbc.adoc[JDBC Support] :: Channel adapters and gateways for JDBC, message and metadata stores\nxref:jpa.adoc[JPA Support] :: Channel adapters and gateways for JPA API\nxref:jms.adoc[JMS Support] :: Channel adapters and gateways for JMS API\nxref:jmx.adoc[JMX Support] :: Channel adapters for JMX interaction, integration-specific MBean exporter\nxref:kafka.adoc[Apache Kafka Support] :: Channels, adapters and gateways for Apache Kafka\nxref:mail.adoc[Mail Support] :: Channel adapters for Java Mail API\nxref:mongodb.adoc[MongoDb Support] :: Channels, adapters, gateways and message store for MongoDb\nxref:mqtt.adoc[MQTT Support] :: Channel adapters for MQTT protocol\nxref:r2dbc.adoc[R2DBC Support] :: Channel adapters for R2DBC API\nxref:redis.adoc[Redis Support] :: Channels, adapters, gateways and message store for Redis\nxref:resource.adoc[Resource Support] :: Spring resource channel adapters\nxref:rsocket.adoc[RSocket Support] :: Channel adapters for RSocket protocol\nxref:sftp.adoc[SFTP Adapters] :: Channel adapters and gateways for FTP protocol\nxref:smb.adoc[SMB Support] :: Channel adapters and gateways for SMB protocol\nxref:stomp.adoc[STOMP Support] :: Channel adapters and gateways for STOMP protocol\nxref:stream.adoc[Stream Support] :: Channel adapters for Java IO stream API\nxref:syslog.adoc[Syslog Support] :: Channel adapters for Syslog protocol\nxref:ip.adoc[TCP and UDP Support] :: Channel adapters and gateways for TCP and UDP protocols\nxref:webflux.adoc[WebFlux Support] :: Channel adapters and gateways for WebFlux API\nxref:web-sockets.adoc[WebSockets Support] :: Channel adapters for WebSockets protocol\nxref:ws.adoc[Web Services Support] :: Channel adapters for SOAP protocol\nxref:xml.adoc[XML Support - Dealing with XML Payloads] :: Channel adapters and transformers for XML API, xPath\nxref:xmpp.adoc[XMPP Support] :: Channel adapters for XMPP protocol\nxref:zeromq.adoc[ZeroMQ Support] :: Channels and adapters for ZeroMQ protocol\nxref:zookeeper.adoc[Zookeeper Support] :: Channel adapters for Zookeeper and Curator API\n\n[horizontal]\n**Appendices** ::\n\n[horizontal]\nxref:scatter-gather.adoc#scatter-gather-error-handling[Error Handling] :: Overview of error handling approaches in Spring Integration\nxref:spel.adoc[Spring Expression Language (SpEL)] :: Details about SpEL support\nxref:message-publishing.adoc[Message Publishing] :: The Publisher annotation etc.\nxref:jms.adoc#jms-ob-transactions[Transaction Support] :: Overview of transactions support in Spring Integration\nxref:security.adoc[Security in Spring Integration] :: Securing Spring Integration flows\nxref:kafka.adoc#kafka-inbound-gateway-configuration[Configuration] :: Messaging annotations, task scheduler, global properties, message mapping\nxref:testing.adoc[Testing support] :: Test utilities, Integration mocks and testing framework\nxref:samples.adoc#samples-impl[Spring Integration Samples] :: The samples dedicated project\nxref:resources.adoc[Additional Resources] :: Other resources related to project\nxref:history.adoc[Change History] :: The changes made in the project over time\nxref:null-safety.adoc[Null Safety] :: Null safety build-time enforcement", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/index.adoc", "title": "Spring Integration", "heading": "Spring Integration", "heading_level": 1, "file_order": 222, "section_index": 0, "content_hash": "e5c876eddc4e834aea0d5a6c5782c38097c5052a70207d505007e46565531f8c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:bf64074cf17894e5aecfc49db5bf9c2cf6e701d72cd3495ca96f6d2d8d60ca5f", "content": "[[integration-graph-controller]]\n\nIf your application is web-based (or built on top of Spring Boot with an embedded web container) and the Spring Integration HTTP or WebFlux module (see xref:http.adoc[HTTP Support] and xref:webflux.adoc[WebFlux Support], respectively) is present on the classpath, you can use a `IntegrationGraphController` to expose the `IntegrationGraphServer` functionality as a REST service.\nFor this purpose, the `@EnableIntegrationGraphController` and `@Configuration` class annotations and the `<int-http:graph-controller/>` XML element are available in the HTTP module.\nTogether with the `@EnableWebMvc` annotation (or `<mvc:annotation-driven/>` for XML definitions), this configuration registers an `IntegrationGraphController` `@RestController` where its `@RequestMapping.path` can be configured on the `@EnableIntegrationGraphController` annotation or `<int-http:graph-controller/>` element.\nThe default path is `/integration`.\n\nThe `IntegrationGraphController` `@RestController` provides the following services:\n\n* `@GetMapping(name = \"getGraph\")`: To retrieve the state of the Spring Integration components since the last `IntegrationGraphServer` refresh.\nThe `o.s.i.support.management.graph.Graph` is returned as a `@ResponseBody` of the REST service.\n* `@GetMapping(path = \"/refresh\", name = \"refreshGraph\")`: To refresh the current `Graph` for the actual runtime state and return it as a REST response.\nIt is not necessary to refresh the graph for metrics.\nThey are provided in real-time when the graph is retrieved.\nRefresh can be called if the application context has been modified since the graph was last retrieved.\nIn that case, the graph is completely rebuilt.\n\nYou can set security and cross-origin restrictions for the `IntegrationGraphController` with the standard configuration options and components provided by the Spring Security and Spring MVC projects.\nThe following example achieves those goals:\n\n[source,xml]\n----\n<mvc:annotation-driven />\n\n<mvc:cors>\n\t<mvc:mapping path=\"/myIntegration/**\"\n allowed-origins=\"http://localhost:9090\"\n allowed-methods=\"GET\" />\n</mvc:cors>\n\n<security:http>\n <security:intercept-url pattern=\"/myIntegration/**\" access=\"ROLE_ADMIN\" />\n</security:http>\n\n<int-http:graph-controller path=\"/myIntegration\" />\n----\n\nThe following example shows how to do the same thing with Java configuration:\n\n[source,java]\n----\n@Configuration\n@EnableWebMvc // or @EnableWebFlux\n@EnableWebSecurity // or @EnableWebFluxSecurity\n@EnableIntegration\n@EnableIntegrationGraphController(path = \"/testIntegration\", allowedOrigins=\"http://localhost:9090\")\npublic class IntegrationConfiguration extends WebSecurityConfigurerAdapter {\n\n @Override\n protected void configure(HttpSecurity http) throws Exception {\n http\n .authorizeRequests()\n .antMatchers(\"/testIntegration/**\").hasRole(\"ADMIN\")\n // ...\n .formLogin();\n }\n\n //...\n\n}\n----\n\nNote that, for convenience, the `@EnableIntegrationGraphController` annotation provides an `allowedOrigins` attribute.\nThis provides `GET` access to the `path`.\nFor more sophistication, you can configure the CORS mappings by using standard Spring MVC mechanisms.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/integration-graph-controller.adoc", "title": "integration-graph-controller", "heading": "integration-graph-controller", "heading_level": 1, "file_order": 223, "section_index": 0, "content_hash": "bf64074cf17894e5aecfc49db5bf9c2cf6e701d72cd3495ca96f6d2d8d60ca5f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/integration-graph-controller.adoc"}}
{"id": "sha256:412ac168599b36b121b4d71f7202dd0f5fba01a461c8d6501fd3c7696e31847b", "content": "[[ip]]\n\nSpring Integration provides channel adapters for receiving and sending messages over internet protocols.\nBoth UDP (User Datagram Protocol) and TCP (Transmission Control Protocol) adapters are provided.\nEach adapter provides for one-way communication over the underlying protocol.\nIn addition, Spring Integration provides simple inbound and outbound TCP gateways.\nThese are used when two-way communication is needed.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-ip</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-ip:{project-version}\"\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ip.adoc", "title": "ip", "heading": "ip", "heading_level": 1, "file_order": 224, "section_index": 0, "content_hash": "412ac168599b36b121b4d71f7202dd0f5fba01a461c8d6501fd3c7696e31847b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ip.adoc"}}
{"id": "sha256:15b3ff91f1b00b583591aa53f5aeded8aadae10d1bd80e1b802347d0c1ebb9dc", "content": "[[jdbc]]\n\nSpring Integration provides channel adapters for receiving and sending messages by using database queries.\nThrough those adapters, Spring Integration supports not only plain JDBC SQL queries but also stored procedure and stored function calls.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-jdbc</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-jdbc:{project-version}\"\n----\n======\n\nBy default, the following JDBC components are available:\n\n* xref:jdbc/inbound-channel-adapter.adoc[Inbound Channel Adapter]\n* xref:jdbc/outbound-channel-adapter.adoc[Outbound Channel Adapter]\n* xref:jdbc/outbound-gateway.adoc[Outbound Gateway]\n* xref:jdbc/stored-procedures.adoc#stored-procedure-inbound-channel-adapter[Stored Procedure Inbound Channel Adapter]\n* xref:jdbc/stored-procedures.adoc#stored-procedure-outbound-channel-adapter[Stored Procedure Outbound Channel Adapter]\n* xref:jdbc/stored-procedures.adoc#stored-procedure-outbound-gateway[Stored Procedure Outbound Gateway]\n\nThe Spring Integration JDBC Module also provides a xref:jdbc/message-store.adoc[JDBC Message Store].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jdbc.adoc", "title": "jdbc", "heading": "jdbc", "heading_level": 1, "file_order": 225, "section_index": 0, "content_hash": "15b3ff91f1b00b583591aa53f5aeded8aadae10d1bd80e1b802347d0c1ebb9dc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jdbc.adoc"}}
{"id": "sha256:dd56dd06222122d7aa3669d2397ec354d908693cadb26af45b54b63981fc48bf", "content": "[[jms]]\n\nSpring Integration provides channel adapters for receiving and sending JMS messages.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-jms</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-jms:{project-version}\"\n----\n======\n\nThe `jakarta.jms:jakarta.jms-api` must be added explicitly via some JMS vendor-specific implementation, e.g. Apache ActiveMQ.\n\nThere are actually two JMS-based inbound Channel Adapters.\nThe first uses Spring's `JmsTemplate` to receive based on a polling period.\nThe second is \"`message-driven`\" and relies on a Spring `MessageListener` container.\nThe outbound channel adapter uses the `JmsTemplate` to convert and send a JMS message on demand.\n\nBy using `JmsTemplate` and the `MessageListener` container, Spring Integration relies on Spring's JMS support.\nThis is important to understand, since most of the attributes exposed on these adapters configure the underlying `JmsTemplate` and `MessageListener` container.\nFor more details about `JmsTemplate` and the `MessageListener` container, see the https://docs.spring.io/spring-framework/reference/integration/jms.html[Spring JMS documentation].\n\nWhereas the JMS channel adapters are intended for unidirectional messaging (send-only or receive-only), Spring Integration also provides inbound and outbound JMS Gateways for request and reply operations.\nThe inbound gateway relies on one of Spring's `MessageListener` container implementations for message-driven reception.\nIt is also capable of sending a return value to the `reply-to` destination, as provided by the received message.\nThe outbound gateway sends a JMS message to a `request-destination` (or `request-destination-name` or `request-destination-expression`) and then receives a reply message.\nYou can explicitly configure the `reply-destination` reference (or `reply-destination-name` or `reply-destination-expression`).\nOtherwise, the outbound gateway uses a JMS https://javadoc.io/doc/jakarta.jms/jakarta.jms-api/latest/jakarta/jms/TemporaryQueue.html[TemporaryQueue].\n\nPrior to Spring Integration 2.2, if necessary, a `TemporaryQueue` was created (and removed) for each request or reply.\nBeginning with Spring Integration 2.2, you can configure the outbound gateway to use a `MessageListener` container to receive replies instead of directly using a new (or cached) `Consumer` to receive the reply for each request.\nWhen so configured, and no explicit reply destination is provided, a single `TemporaryQueue` is used for each gateway instead of one for each request.\n\nStarting with version 6.0, the outbound gateway creates a `TemporaryTopic` instead of `TemporaryQueue` if `replyPubSubDomain` option is set to `true`.\nSome JMS vendors handle these destinations differently.\n\n[[jms-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "jms", "heading_level": 1, "file_order": 226, "section_index": 0, "content_hash": "dd56dd06222122d7aa3669d2397ec354d908693cadb26af45b54b63981fc48bf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:b115a86c012304591baefa7e5e6d149c1bac496b0c13b1bba9af424e67f7155b", "content": "The inbound channel adapter requires a reference to either a single `JmsTemplate` instance or both a `ConnectionFactory` and a `Destination` (you can provide a 'destinationName' in place of the 'destination' reference).\nThe following example defines an inbound channel adapter with a `Destination` reference:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow jmsInbound(ConnectionFactory connectionFactory) {\n return IntegrationFlow.from(\n Jms.inboundAdapter(connectionFactory)\n .destination(\"inQueue\"),\n e -> e.poller(poller -> poller.fixedRate(30000)))\n .handle(m -> System.out.println(m.getPayload()))\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun jmsInbound(connectionFactory: ConnectionFactory) =\n integrationFlow(\n Jms.inboundAdapter(connectionFactory).destination(\"inQueue\"),\n { poller { Pollers.fixedRate(30000) } })\n {\n handle { m -> println(m.payload) }\n }\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\n@InboundChannelAdapter(value = \"exampleChannel\", poller = @Poller(fixedRate = \"30000\"))\npublic MessageSource<Object> jmsIn(ConnectionFactory connectionFactory) {\n JmsDestinationPollingSource source = new JmsDestinationPollingSource(new JmsTemplate(connectionFactory));\n source.setDestinationName(\"inQueue\");\n return source;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-jms:inbound-channel-adapter id=\"jmsIn\" destination=\"inQueue\" channel=\"exampleChannel\">\n <int:poller fixed-rate=\"30000\"/>\n</int-jms:inbound-channel-adapter>\n----\n======\n\nTIP: Notice from the preceding configuration that the `inbound-channel-adapter` is a polling consumer.\nThat means that it invokes `receive()` when triggered.\nYou should use this should only in situations where polling is done relatively infrequently and timeliness is not important.\nFor all other situations (a vast majority of JMS-based use-cases), the `message-driven-channel-adapter` (xref:changes-2.2-3.0.adoc#x3.0-jms-mdca-te[described later]) is a better option.\n\nNOTE: By default, all JMS adapters that require a reference to the `ConnectionFactory` automatically look for a bean named `jmsConnectionFactory`.\nThat is why you do not see a `connection-factory` attribute in many of the examples.\nHowever, if your JMS `ConnectionFactory` has a different bean name, you need to provide that attribute.\n\nIf `extract-payload` is set to `true` (the default), the received JMS Message is passed through the `MessageConverter`.\nWhen relying on the default `SimpleMessageConverter`, this means that the resulting Spring Integration Message has the JMS message's body as its payload.\nA JMS `TextMessage` produces a string-based payload, a JMS `BytesMessage` produces a byte array payload, and the serializable instance of a JMS `ObjectMessage` becomes the Spring Integration message's payload.\nIf you prefer to have the raw JMS message as the Spring Integration message's payload, set the `extractPayload` option to `false`.\n\nStarting with version 5.0.8, a default value of the `receive-timeout` is `-1` (no wait) for the `org.springframework.jms.connection.CachingConnectionFactory` and `cacheConsumers`, otherwise it is 1 second.\nThe JMS Inbound Channel Adapter crates a `DynamicJmsTemplate` based on the provided `ConnectionFactory` and options.\nIf an external `JmsTemplate` is required (e.g. in Spring Boot environment), or `ConnectionFactory` is not caching, or no `cacheConsumers`, it is recommended to set `jmsTemplate.receiveTimeout(-1)` if a non-blocking consumption is expected:\n\n[source,java]\n----\nJms.inboundAdapter(connectionFactory)\n .destination(queueName)\n .configureJmsTemplate(template -> template.receiveTimeout(-1))\n----\n\n[[jms-ib-transactions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Inbound Channel Adapter", "heading_level": 2, "file_order": 226, "section_index": 1, "content_hash": "b115a86c012304591baefa7e5e6d149c1bac496b0c13b1bba9af424e67f7155b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:da3faf834beab3b8ee3f21a73e1f4d57d2c4ae2eb23773af3c1ee08b509974aa", "content": "Starting with version 4.0, the inbound channel adapter supports the `session-transacted` attribute.\nIn earlier versions, you had to inject a `JmsTemplate` with `sessionTransacted` set to `true`.\n(The adapter did let you set the `acknowledge` attribute to `transacted`, but this was incorrect and did not work).\n\nNote, however, that setting `session-transacted` to `true` has little value, because the transaction is committed\nimmediately after the `receive()` operation and before the message is sent to the `channel`.\n\nIf you want the entire flow to be transactional, (for example, if there is a downstream outbound channel adapter), you must use a `transactional` poller with a `JmsTransactionManager`.\nAlternatively, consider using a `jms-message-driven-channel-adapter` with `acknowledge` set to `transacted` (the default).\n\n[[jms-message-driven-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Transactions", "heading_level": 3, "file_order": 226, "section_index": 2, "content_hash": "da3faf834beab3b8ee3f21a73e1f4d57d2c4ae2eb23773af3c1ee08b509974aa", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:9ca997fbf43294c3ace1cb9c86830857b19f057a4c047524807dd45c0188f938", "content": "The `message-driven-channel-adapter` requires a reference to either an instance of a Spring `MessageListener` container (any subclass of `AbstractMessageListenerContainer`) or both `ConnectionFactory` and `Destination` (a 'destinationName' can be provided in place of the 'destination' reference).\nThe following example defines a message-driven channel adapter with a `Destination` reference:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow jmsMessageDrivenRedeliveryFlow() {\n return IntegrationFlow\n .from(Jms.messageDrivenChannelAdapter(jmsConnectionFactory())\n .destination(\"inQueue\"))\n .channel(\"exampleChannel\")\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun jmsMessageDrivenFlowWithContainer() =\n integrationFlow(\n Jms.messageDrivenChannelAdapter(jmsConnectionFactory())\n .destination(\"inQueue\")) {\n channel(\"exampleChannel\")\n }\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\npublic JmsMessageDrivenEndpoint jmsIn() {\n JmsMessageDrivenEndpoint endpoint = new JmsMessageDrivenEndpoint(container(), listener());\n return endpoint;\n}\n@Bean\npublic AbstractMessageListenerContainer container() {\n DefaultMessageListenerContainer container = new DefaultMessageListenerContainer();\n container.setConnectionFactory(cf());\n container.setDestinationName(\"inQueue\");\n return container;\n}\n\n@Bean\npublic ChannelPublishingJmsMessageListener listener() {\n ChannelPublishingJmsMessageListener listener = new ChannelPublishingJmsMessageListener();\n listener.setRequestChannelName(\"exampleChannel\");\n return listener;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-jms:message-driven-channel-adapter id=\"jmsIn\" destination=\"inQueue\" channel=\"exampleChannel\"/>\n----\n======\n\n[NOTE]\n=====\nThe message-driven adapter also accepts several properties that pertain to the `MessageListener` container.\nThese values are considered only if you do not provide a `container` reference.\nIn that case, an instance of `DefaultMessageListenerContainer` is created and configured based on these properties.\nFor example, you can specify the `transaction-manager` reference, the `concurrent-consumers` value, and several other property references and values.\nSee the https://docs.spring.io/spring-integration/api/index.html[Javadoc] and Spring Integration's JMS schema (`spring-integration-jms.xsd`) for more details.\n\nIf you have a custom listener container implementation (usually a subclass of `DefaultMessageListenerContainer`), you can either provide a reference to an instance of it by using the `container` attribute or provide its fully qualified class name by using the `container-class` attribute.\nIn that case, the attributes on the adapter are transferred to an instance of your custom container.\n=====\n\n[NOTE]\n=====\nYou can't use the Spring JMS namespace element `<jms:listener-container/>` to configure a container reference for the `<int-jms:message-driven-channel-adapter>` since that element doesn't actually reference a container.\nEach `<jms:listener/>` sub-element gets its own `DefaultMessageListenerContainer` (with shared attributes defined on the parent `<jms:listener-container/>` element).\nYou can give each listener subelement an `id`, and use that to inject into the channel adapter, however, the `<jms:/>` namespace requires a real listener.\n\nIt is recommended to configure a regular `<bean>` for the `DefaultMessageListenerContainer` and use it as a reference in the channel adapter.\n=====\n\nIMPORTANT: Starting with version 4.2, the default `acknowledge` mode is `transacted`, unless you provide an external container.\nIn that case, you should configure the container as needed.\nWe recommend using `transacted` with the `DefaultMessageListenerContainer` to avoid message loss.\n\nThe 'extract-payload' property has the same effect, and its default value is 'true'.\nThe `poller` element is not applicable for a message-driven channel adapter, as it is actively invoked.\nFor most scenarios, the message-driven approach is better, since the messages are passed along to the `MessageChannel` as soon as they are received from the underlying JMS consumer.\n\nFinally, the `<message-driven-channel-adapter>` element also accepts the 'error-channel' attribute.\nThis provides the same basic functionality, as described in xref:gateway.adoc#gateway-proxy[Enter the `GatewayProxyFactoryBean`].\nThe following example shows how to set an error channel on a message-driven channel adapter:\n\n[source,xml]\n----\n<int-jms:message-driven-channel-adapter id=\"jmsIn\" destination=\"inQueue\"\n channel=\"exampleChannel\"\n error-channel=\"exampleErrorChannel\"/>\n----\n\nWhen comparing the preceding example to the generic gateway configuration or the JMS 'inbound-gateway' that we discuss later, the key difference is that we are in a one-way flow, since this is a 'channel-adapter', not a gateway.\nTherefore, the flow downstream from the 'error-channel' should also be one-way.\nFor example, it could send to a logging handler, or it could connect to a different JMS `<outbound-channel-adapter>` element.\n\nWhen consuming from topics, set the `pub-sub-domain` attribute to true.\nSet `subscription-durable` to `true` for a durable subscription or `subscription-shared` for a shared subscription (which requires a JMS 2.0 broker and has been available since version 4.2).\nUse `subscription-name` to name the subscription.\n\nStarting with version 5.1, when the endpoint is stopped while the application remains running, the underlying listener container is shut down, closing its shared connection and consumers.\nPreviously, the connection and consumers remained open.\nTo revert to the previous behavior, set the `shutdownContainerOnStop` on the `JmsMessageDrivenEndpoint` to `false`.\n\nStarting with version 6.3, the `ChannelPublishingJmsMessageListener` can now be supplied with a `RetryTemplate` and `RecoveryCallback<Message<?>>` for retries on the downstream send and send-and-receive operations.\nThese options are also exposed into a `JmsMessageDrivenChannelAdapterSpec` for Java DSL.\n\n[[jms-md-conversion-errors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Message Driven Channel Adapter", "heading_level": 2, "file_order": 226, "section_index": 3, "content_hash": "9ca997fbf43294c3ace1cb9c86830857b19f057a4c047524807dd45c0188f938", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:36af1e1fec8235a3bab9093774f8b1b516ebd1ef78a02560a55879ca2d3612d6", "content": "Starting with version 4.2, the 'error-channel' is used for the conversion errors, too.\nPreviously, if a JMS `<message-driven-channel-adapter/>` or `<inbound-gateway/>` could not deliver a message due to a conversion error, an exception would be thrown back to the container.\nIf the container is configured to use transactions, the message is rolled back and redelivered repeatedly.\nThe conversion process occurs before and during message construction so that such errors are not sent to the 'error-channel'.\nNow such conversion exceptions result in an `ErrorMessage` being sent to the 'error-channel', with the exception as the `payload`.\nIf you wish the transaction to roll back, and you have an 'error-channel' defined, the integration flow on the 'error-channel' must re-throw the exception (or another exception).\nIf the error flow does not throw an exception, the transaction is committed and the message is removed.\nIf no 'error-channel' is defined, the exception is thrown back to the container, as before.\n\n[[jms-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Inbound Conversion Errors", "heading_level": 3, "file_order": 226, "section_index": 4, "content_hash": "36af1e1fec8235a3bab9093774f8b1b516ebd1ef78a02560a55879ca2d3612d6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:0729ca00eeafca95c627dad54f0d5b71ece43a84a1d3f32a8bf021092ea77e55", "content": "The `JmsSendingMessageHandler` implements the `MessageHandler` interface and is capable of converting Spring Integration `Messages` to JMS messages and then sending to a JMS destination.\nIt requires either a `jmsTemplate` reference or both `jmsConnectionFactory` and `destination` references (`destinationName` may be provided in place of `destination`).\nAs with the inbound channel adapter, the easiest way to configure this adapter is with the namespace support.\nThe following configuration produces an adapter that receives Spring Integration messages from the `exampleChannel`, converts those into JMS messages, and sends them to the JMS destination reference whose bean name is `outQueue`:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow jmsOutboundFlow() {\n return IntegrationFlow.from(\"exampleChannel\")\n .handle(Jms.outboundAdapter(cachingConnectionFactory())\n .destinationExpression(\"headers.\" + SimpMessageHeaderAccessor.DESTINATION_HEADER)\n .configureJmsTemplate(t -> t.id(\"jmsOutboundFlowTemplate\")))\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun jmsOutboundFlow() =\n integrationFlow(\"exampleChannel\") {\n handle(Jms.outboundAdapter(jmsConnectionFactory())\n .apply {\n destinationExpression(\"headers.\" + SimpMessageHeaderAccessor.DESTINATION_HEADER)\n deliveryModeFunction<Any> { DeliveryMode.NON_PERSISTENT }\n timeToLiveExpression(\"10000\")\n configureJmsTemplate { it.explicitQosEnabled(true) }\n }\n )\n }\n----\n\nGroovy DSL::\n+\n[source, groovy, role=\"secondary\"]\n----\n@Bean\njmsOutboundFlow() {\n integrationFlow('exampleChannel') {\n handle(Jms.outboundAdapter(new ActiveMQConnectionFactory())\n .with {\n destinationExpression 'headers.' + SimpMessageHeaderAccessor.DESTINATION_HEADER\n deliveryModeFunction { DeliveryMode.NON_PERSISTENT }\n timeToLiveExpression '10000'\n configureJmsTemplate {\n it.explicitQosEnabled true\n }\n }\n )\n }\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\n@ServiceActivator(inputChannel = \"exampleChannel\")\npublic MessageHandler jmsOut() {\n JmsSendingMessageHandler handler = new JmsSendingMessageHandler(new JmsTemplate(connectionFactory));\n handler.setDestinationName(\"outQueue\");\n return handler;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-jms:outbound-channel-adapter id=\"jmsOut\" destination=\"outQueue\" channel=\"exampleChannel\"/>\n----\n======\n\nAs with the inbound channel adapters, there is an 'extract-payload' property.\nHowever, the meaning is reversed for the outbound adapter.\nRather than applying to the JMS message, the boolean property applies to the Spring Integration message payload.\nIn other words, the decision is whether to pass the Spring Integration message itself as the JMS message body or to pass the Spring Integration message payload as the JMS message body.\nThe default value is 'true'.\nTherefore, if you pass a Spring Integration message whose payload is a `String`, a JMS `TextMessage` is created.\nIf, on the other hand, you want to send the actual Spring Integration message to another system over JMS, set it to 'false'.\n\nNOTE: Regardless of the boolean value for payload extraction, the Spring Integration `MessageHeaders` map to JMS properties, as long as you rely on the default converter or provide a reference to another instance of `MessageConverter`.\n(The same holds true for 'inbound' adapters, except that, in those cases, the JMS properties map to Spring Integration `MessageHeaders`).\n\nStarting with version 5.1, the `<int-jms:outbound-channel-adapter>` (`JmsSendingMessageHandler`) can be configured with the `deliveryModeExpression` and `timeToLiveExpression` properties to evaluate an appropriate QoS values for JMS message to send at runtime against request Spring `Message`.\nThe new `setMapInboundDeliveryMode(true)` and `setMapInboundExpiration(true)` options of the `DefaultJmsHeaderMapper` may facilitate as a source of the information for the dynamic `deliveryMode` and `timeToLive` from message headers:\n\n[source,xml]\n----\n<int-jms:outbound-channel-adapter delivery-mode-expression=\"headers.jms_deliveryMode\"\n time-to-live-expression=\"headers.jms_expiration - T(System).currentTimeMillis()\"/>\n----\n\n[[jms-ob-transactions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Outbound Channel Adapter", "heading_level": 2, "file_order": 226, "section_index": 5, "content_hash": "0729ca00eeafca95c627dad54f0d5b71ece43a84a1d3f32a8bf021092ea77e55", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:f7ee658c7a2a359d968f86c3067e77b2debc4cf6513e5fe2b54f3ace4420a105", "content": "Starting with version 4.0, the outbound channel adapter supports the `session-transacted` attribute.\nIn earlier versions, you had to inject a `JmsTemplate` with `sessionTransacted` set to `true`.\nThe attribute now sets the property on the built-in default `JmsTemplate`.\nIf a transaction exists (perhaps from an upstream `message-driven-channel-adapter`), the send operation is performed within the same transaction.\nOtherwise, a new transaction is started.\n\n[[jms-inbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Transactions", "heading_level": 3, "file_order": 226, "section_index": 6, "content_hash": "f7ee658c7a2a359d968f86c3067e77b2debc4cf6513e5fe2b54f3ace4420a105", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:d3f17b2a05e511704163b817fd871dc624408849bcc2a2a7c3338a1f1bbce9c0", "content": "Spring Integration's message-driven JMS inbound-gateway delegates to a `MessageListener` container, supports dynamically adjusting concurrent consumers, and can also handle replies.\nThe inbound gateway requires references to a `ConnectionFactory` and a request `Destination` (or 'requestDestinationName').\nThe following example defines a JMS `inbound-gateway` that receives from the JMS queue referenced by the bean id, `inQueue`, and sends to the Spring Integration channel named `exampleChannel`:\n\n[source,xml]\n----\n<int-jms:inbound-gateway id=\"jmsInGateway\"\n request-destination=\"inQueue\"\n request-channel=\"exampleChannel\"/>\n----\n\nSince the gateways provide request-reply behavior instead of unidirectional send or receive behavior, they also have two distinct properties for \"`payload extraction`\" (as xref:changes-3.0-4.0.adoc#x4.0-jms-ib[discussed earlier] for the channel adapters' 'extract-payload' setting).\nFor an inbound gateway, the 'extract-request-payload' property determines whether the received JMS Message body is extracted.\nIf 'false', the JMS message itself becomes the Spring Integration message payload.\nThe default is 'true'.\n\nSimilarly, for an inbound-gateway, the 'extract-reply-payload' property applies to the Spring Integration message that is to be converted into a reply JMS Message.\nIf you want to pass the whole Spring Integration message (as the body of a JMS ObjectMessage), set value this to 'false'.\nBy default, it is also 'true' that the Spring Integration message payload is converted into a JMS Message, (for example, a `String` payload becomes a JMS TextMessage).\n\nAs with anything else, gateway invocation might result in error.\nBy default, a producer is not notified of the errors that might have occurred on the consumer side and times out waiting for the reply.\nHowever, there might be times when you want to communicate an error condition back to the consumer (in other words, you might want to treat the exception as a valid reply by mapping it to a message).\nTo accomplish this, JMS inbound gateway provides support for a message channel to which errors can be sent for processing, potentially resulting in a reply message payload that conforms to some contract that defines what a caller may expect as an \"`error`\" reply.\nYou can use the error-channel attribute to configure such a channel, as the following example shows:\n\n[source,xml]\n----\n<int-jms:inbound-gateway request-destination=\"requestQueue\"\n request-channel=\"jmsInputChannel\"\n error-channel=\"errorTransformationChannel\"/>\n\n<int:transformer input-channel=\"exceptionTransformationChannel\"\n ref=\"exceptionTransformer\" method=\"createErrorResponse\"/>\n\n----\n\nYou might notice that this example looks very similar to that included within xref:gateway.adoc#gateway-proxy[Enter the `GatewayProxyFactoryBean`].\nThe same idea applies here: The `exceptionTransformer` could be a POJO that creates error-response objects, you could reference the `nullChannel` to suppress the errors, or you could leave 'error-channel' out to let the exception propagate.\n\nSee xref:jms.adoc#jms-md-conversion-errors[Inbound Conversion Errors].\n\nWhen consuming from topics, set the `pub-sub-domain` attribute to true.\nSet `subscription-durable` to `true` for a durable subscription or `subscription-shared` for a shared subscription (requires a JMS 2.0 broker and has been available since version 4.2).\nUse `subscription-name` to name the subscription.\n\nIMPORTANT: Starting with version 4.2, the default `acknowledge` mode is `transacted`, unless an external container is provided.\nIn that case, you should configure the container as needed.\nWe recommend that you use `transacted` with the `DefaultMessageListenerContainer` to avoid message loss.\n\nStarting with version 5.1, when the endpoint is stopped while the application remains running, the underlying listener container is shut down, closing its shared connection and consumers.\nPreviously, the connection and consumers remained open.\nTo revert to the previous behavior, set the `shutdownContainerOnStop` on the `JmsInboundGateway` to `false`.\n\nBy default, the `JmsInboundGateway` looks for a `jakarta.jms.Message.getJMSReplyTo()` property in the received message to determine where to send a reply.\nOtherwise, it can be configured with a static `defaultReplyDestination`, or `defaultReplyQueueName` or `defaultReplyTopicName`.\nIn addition, starting with version 6.1, a `replyToExpression` can be configured on a provided `ChannelPublishingJmsMessageListener` to determine the reply destination dynamically, if the standard `JMSReplyTo` property is `null` on the request.\nThe received `jakarta.jms.Message` is used the root evaluation context object.\nThe following example demonstrates how to use Java DSL API to configure an inbound JMS gateway with a custom reply destination resolved from the request message:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow jmsInboundGatewayFlow(ConnectionFactory connectionFactory) {\n return IntegrationFlow.from(\n Jms.inboundGateway(connectionFactory)\n .requestDestination(\"requestDestination\")\n .replyToFunction(message -> message.getStringProperty(\"myReplyTo\")))\n .<String, String>transform(String::toUpperCase)\n .get();\n}\n----\n\nStarting with version 6.3, the `Jms.inboundGateway()` API exposes a `retryTemplate()` and `recoveryCallback()` options for retrying internal send-and-receive operations.\n\n[[jms-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Inbound Gateway", "heading_level": 2, "file_order": 226, "section_index": 7, "content_hash": "d3f17b2a05e511704163b817fd871dc624408849bcc2a2a7c3338a1f1bbce9c0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:c8dc8843734f59bf86d92a2a38aec297201b2e8fe963f81858018925b7d741d5", "content": "The outbound gateway creates JMS messages from Spring Integration messages and sends them to a `request-destination`.\nIt then handles the JMS reply message either by using a selector to receive from the `reply-destination` that you configure or, if no `reply-destination` is provided, by creating JMS `TemporaryQueue` (or `TemporaryTopic` if `replyPubSubDomain= true`) instances.\n\n[[jms-outbound-gateway-memory-caution]]\n[CAUTION]\n=====\nUsing a `reply-destination` (or `reply-destination-name`) together with a `CachingConnectionFactory` that has cacheConsumers set to `true` can cause out-of-memory conditions.\nThis is because each request gets a new consumer with a new selector (selecting on the `correlation-key` value or when there is no `correlation-key`, on the sent JMSMessageID).\nGiven that these selectors are unique, they remain in the cache (unused) after the current request completes.\n\nIf you specify a reply destination, you are advised to not use cached consumers.\nAlternatively, consider using a `<reply-listener/>` as xref:jms.adoc#jms-outbound-gateway-reply-listener[described below].\n=====\n\nThe following example shows how to configure an outbound gateway:\n\n[source,xml]\n----\n<int-jms:outbound-gateway id=\"jmsOutGateway\"\n request-destination=\"outQueue\"\n request-channel=\"outboundJmsRequests\"\n reply-channel=\"jmsReplies\"/>\n----\n\nThe 'outbound-gateway' payload extraction properties are inversely related to those of the 'inbound-gateway' (see the xref:changes-2.2-3.0.adoc#x3.0-jms-mdca-te[earlier discussion]).\nThat means that the 'extract-request-payload' property value applies to the Spring Integration message being converted into a JMS message to be sent as a request.\nThe 'extract-reply-payload' property value applies to the JMS message received as a reply and is then converted into a Spring Integration message to be subsequently sent to the 'reply-channel', as shown in the preceding configuration example.\n\n[[jms-outbound-gateway-reply-listener]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Outbound Gateway", "heading_level": 2, "file_order": 226, "section_index": 8, "content_hash": "c8dc8843734f59bf86d92a2a38aec297201b2e8fe963f81858018925b7d741d5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:1987a4624c25da8aa649c4eef36df2debb66ebeeaf96a4bf09bd5131f6c419bc", "content": "Spring Integration 2.2 introduced an alternative technique for handling replies.\nIf you add a `<reply-listener/>` child element to the gateway instead of creating a consumer for each reply, a `MessageListener` container is used to receive the replies and hand them over to the requesting thread.\nThis provides a number of performance benefits as well as alleviating the cached consumer memory utilization problem described in the xref:jms.adoc#jms-outbound-gateway-memory-caution[earlier caution].\n\nWhen using a `<reply-listener/>` with an outbound gateway that has no `reply-destination`, instead of creating a `TemporaryQueue` for each request, a single `TemporaryQueue` is used.\n(The gateway creates an additional `TemporaryQueue`, as necessary, if the connection to the broker is lost and recovered).\nIf `replyPubSubDomain` is set to `true`, starting with version 6.0, a `TemporaryTopic` is created instead.\n\nWhen using a `correlation-key`, multiple gateways can share the same reply destination, because the listener container uses a selector that is unique to each gateway.\n\n[CAUTION]\n====\nIf you specify a reply listener and specify a reply destination (or reply destination name) but provide no correlation key, the gateway logs a warning and falls back to pre-version 2.2 behavior.\nThis is because there is no way to configure a selector in this case.\nThus, there is no way to avoid a reply going to a different gateway that might be configured with the same reply destination.\n\nNote that, in this situation, a new consumer is used for each request, and consumers can build up in memory as described in the caution above; therefore, cached consumers should not be used in this case.\n====\n\nThe following example shows a reply listener with default attributes:\n\n[source,xml]\n----\n<int-jms:outbound-gateway id=\"jmsOutGateway\"\n request-destination=\"outQueue\"\n request-channel=\"outboundJmsRequests\"\n reply-channel=\"jmsReplies\">\n <int-jms:reply-listener />\n</int-jms-outbound-gateway>\n----\n\nThe listener is very lightweight, and we anticipate that, in most cases, you need only a single consumer.\nHowever, you can add attributes such as `concurrent-consumers`, `max-concurrent-consumers`, and others.\nSee the schema for a complete list of supported attributes, together with the https://docs.spring.io/spring/docs/current/spring-framework-reference/html/jms.html[Spring JMS documentation] for their meanings.\n\n[[idle-reply-listeners]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Using a `<reply-listener/>`", "heading_level": 3, "file_order": 226, "section_index": 9, "content_hash": "1987a4624c25da8aa649c4eef36df2debb66ebeeaf96a4bf09bd5131f6c419bc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:b30561b741075e45b8536be3061b980d9b02f2f42d66086223a9da1e19cab2ee", "content": "Starting with version 4.2, you can start the reply listener as needed (and stop it after an idle time) instead of running for the duration of the gateway's lifecycle.\nThis can be useful if you have many gateways in the application context where they are mostly idle.\nOne such situation is a context with many (inactive) partitioned https://spring.io/projects/spring-batch[Spring Batch] jobs using Spring Integration and JMS for partition distribution.\nIf all the reply listeners are active, the JMS broker has an active consumer for each gateway.\nBy enabling the idle timeout, each consumer exists only while the corresponding batch job is running (and for a short time after it finishes).\n\nSee `idle-reply-listener-timeout` in xref:jms.adoc#jms-og-attributes[Attribute Reference].\n\n[[gateway-reply-correlation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Idle Reply Listeners", "heading_level": 3, "file_order": 226, "section_index": 10, "content_hash": "b30561b741075e45b8536be3061b980d9b02f2f42d66086223a9da1e19cab2ee", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:74fbf39d12e8bfa2c3c14821ae6f31bf8299147326ed7078659679b530e99893", "content": "This section describes the mechanisms used for reply correlation (ensuring the originating gateway receives replies to only its requests), depending on how the gateway is configured.\nSee xref:jms.adoc#jms-og-attributes[Attribute Reference] for a complete description of the attributes discussed here.\n\nThe following list describes the various scenarios (the numbers are for identification -- order does not matter):\n\n. No `reply-destination*` properties and no `<reply-listener>`\n+\nA `TemporaryQueue` is created for each request and deleted when the request is complete (successfully or otherwise).\n`correlation-key` is irrelevant.\n\n. A `reply-destination*` property is provided and neither a `<reply-listener/>` nor a `correlation-key` is provided\n+\nThe `JMSCorrelationID` equal to the outgoing message is used as a message selector for the consumer:\n+\n`messageSelector = \"JMSCorrelationID = '\" + messageId + \"'\"`\n+\nThe responding system is expected to return the inbound `JMSMessageID` in the reply `JMSCorrelationID`.\nThis is a common pattern and is implemented by the Spring Integration inbound gateway as well as Spring's `MessageListenerAdapter` for message-driven POJOs.\n+\nNOTE: When you use this configuration, you should not use a topic for replies.\nThe reply may be lost.\n\n. A `reply-destination*` property is provided, no `<reply-listener/>` is provided, and `correlation-key=\"JMSCorrelationID\"`\n+\nThe gateway generates a unique correlation IS and inserts it in the `JMSCorrelationID` header.\nThe message selector is:\n+\n`messageSelector = \"JMSCorrelationID = '\" + uniqueId + \"'\"`\n+\nThe responding system is expected to return the inbound `JMSCorrelationID` in the reply `JMSCorrelationID`.\nThis is a common pattern and is implemented by the Spring Integration inbound gateway as well as Spring's `MessageListenerAdapter` for message-driven POJOs.\n\n. A `reply-destination*` property is provided, no `<reply-listener/>` is provided, and `correlation-key=\"myCorrelationHeader\"`\n+\nThe gateway generates a unique correlation ID and inserts it in the `myCorrelationHeader` message property.\nThe `correlation-key` can be any user-defined value.\nThe message selector is:\n+\n`messageSelector = \"myCorrelationHeader = '\" + uniqueId + \"'\"`\n+\nThe responding system is expected to return the inbound `myCorrelationHeader` in the reply `myCorrelationHeader`.\n\n. A `reply-destination*` property is provided, no `<reply-listener/>` is provided, and `correlation-key=\"JMSCorrelationID*\"`\n(Note the `*` in the correlation key.)\n+\nThe gateway uses the value in the `jms_correlationId` header (if present) from the request message and inserts it in the `JMSCorrelationID` header.\nThe message selector is:\n+\n`messageSelector = \"JMSCorrelationID = '\" + headers['jms_correlationId'] + \"'\"`\n+\nThe user must ensure this value is unique.\n+\nIf the header does not exist, the gateway behaves as in `3`.\n+\nThe responding system is expected to return the inbound `JMSCorrelationID` in the reply `JMSCorrelationID`.\nThis is a common pattern and is implemented by the Spring Integration inbound gateway as well as Spring's `MessageListenerAdapter` for message-driven POJOs.\n\n. No `reply-destination*` properties is provided, and a `<reply-listener>` is provided\n+\nA temporary queue is created and used for all replies from this gateway instance.\nNo correlation data is needed in the message, but the outgoing `JMSMessageID` is used internally in the gateway to direct the reply to the correct requesting thread.\n\n. A `reply-destination*` property is provided, a `<reply-listener>` is provided, and no `correlation-key` is provided\n+\nNot allowed.\n+\nThe `<reply-listener/>` configuration is ignored, and the gateway behaves as in `2`.\nA warning log message is written to indicate this situation.\n\n. A `reply-destination*` property is provided, a `<reply-listener>` is provided, and `correlation-key=\"JMSCorrelationID\"`\n+\nThe gateway has a unique correlation ID and inserts it, together with an incrementing value in the `JMSCorrelationID` header (`gatewayId + \"_\" + ++seq`).\nThe message selector is:\n+\n`messageSelector = \"JMSCorrelationID LIKE '\" + gatewayId%'\"`\n+\nThe responding system is expected to return the inbound `JMSCorrelationID` in the reply `JMSCorrelationID`.\nThis is a common pattern and is implemented by the Spring Integration inbound gateway as well as Spring's `MessageListenerAdapter` for message-driven POJOs.\nSince each gateway has a unique ID, each instance gets only its own replies.\nThe complete correlation data is used to route the reply to the correct requesting thread.\n\n. A `reply-destination*` property is provided a `<reply-listener/>` is provided, and `correlation-key=\"myCorrelationHeader\"`\n+\nThe gateway has a unique correlation ID and inserts it, together with an incrementing value in the `myCorrelationHeader` property (`gatewayId + \"_\" + ++seq`).\nThe `correlation-key` can be any user-defined value.\nThe message selector is:\n+\n`messageSelector = \"myCorrelationHeader LIKE '\" + gatewayId%'\"`\n+\nThe responding system is expected to return the inbound `myCorrelationHeader` in the reply `myCorrelationHeader`.\nSince each gateway has a unique ID, each instance only gets its own replies.\nThe complete correlation data is used to route the reply to the correct requesting thread.\n\n. A `reply-destination*` property is provided, a `<reply-listener/>` is provided, and `correlation-key=\"JMSCorrelationID*\"`\n+\n(Note the `*` in the correlation key)\n+\nNot allowed.\n+\nUser-supplied correlation IDs are not permitted with a reply listener.\nThe gateway does not initialize with this configuration.\n\n[[jms-async-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Gateway Reply Correlation", "heading_level": 3, "file_order": 226, "section_index": 11, "content_hash": "74fbf39d12e8bfa2c3c14821ae6f31bf8299147326ed7078659679b530e99893", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:06de847d6b663e14e42887451cc1037578b7e53ed69c0393aea58daac8b615e0", "content": "Starting with version 4.3, you can now specify `async=\"true\"` (or `setAsync(true)` in Java) when configuring the outbound gateway.\n\nBy default, when a request is sent to the gateway, the requesting thread is suspended until the reply is received.\nThe flow then continues on that thread.\nIf `async` is `true`, the requesting thread is released immediately after the `send()` completes, and the reply is returned (and the flow continues) on the listener container thread.\nThis can be useful when the gateway is invoked on a poller thread.\nThe thread is released and is available for other tasks within the framework.\n\nThee `async` requires a `<reply-listener/>` (or `setUseReplyContainer(true)` when using Java configuration).\nIt also requires a `correlationKey` (usually `JMSCorrelationID`) to be specified.\nIf either of these conditions are not met, `async` is ignored.\n\n[[jms-og-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Async Gateway", "heading_level": 3, "file_order": 226, "section_index": 12, "content_hash": "06de847d6b663e14e42887451cc1037578b7e53ed69c0393aea58daac8b615e0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:c049ac75839be13e9d85ab7611239b5913c5fc88a9888dcffbf37488554e82db", "content": "The following listing shows all the available attributes for an `outbound-gateway`:\n\n[source,xml]\n----\n<int-jms:outbound-gateway\n connection-factory=\"connectionFactory\" <1>\n correlation-key=\"\" <2>\n delivery-persistent=\"\" <3>\n destination-resolver=\"\" <4>\n explicit-qos-enabled=\"\" <5>\n extract-reply-payload=\"true\" <6>\n extract-request-payload=\"true\" <7>\n header-mapper=\"\" <8>\n message-converter=\"\" <9>\n priority=\"\" <10>\n receive-timeout=\"\" <11>\n reply-channel=\"\" <12>\n reply-destination=\"\" <13>\n reply-destination-expression=\"\" <14>\n reply-destination-name=\"\" <15>\n reply-pub-sub-domain=\"\" <16>\n reply-timeout=\"\" <17>\n request-channel=\"\" <18>\n request-destination=\"\" <19>\n request-destination-expression=\"\" <20>\n request-destination-name=\"\" <21>\n request-pub-sub-domain=\"\" <22>\n time-to-live=\"\" <23>\n requires-reply=\"\" <24>\n idle-reply-listener-timeout=\"\" <25>\n async=\"\"> <26>\n <int-jms:reply-listener /> <27>\n</int-jms:outbound-gateway>\n----\n\n<1> Reference to a `jakarta.jms.ConnectionFactory`.\nThe default `jmsConnectionFactory`.\n<2> The name of a property that contains correlation data to correlate responses with replies.\nIf omitted, the gateway expects the responding system to return the value of the outbound `JMSMessageID` header in the `JMSCorrelationID` header.\nIf specified, the gateway generates a correlation ID and populates the specified property with it.\nThe responding system must echo back that value in the same property.\nIt can be set to `JMSCorrelationID`, in which case the standard header is used instead of a `String` property to hold the correlation data.\nWhen you use a `<reply-container/>`, you must specify the `correlation-key` if you provide an explicit `reply-destination`.\nStarting with version 4.0.1, this attribute also supports the value `JMSCorrelationID*`, which means that if the outbound message already has a `JMSCorrelationID` (mapped from the `jms_correlationId`) header, it is used instead of generating a new one.\nNote, the `JMSCorrelationID*` key is not allowed when you use a `<reply-container/>`, because the container needs to set up a message selector during initialization.\n+\nIMPORTANT: You should understand that the gateway has no way to ensure uniqueness, and unexpected side effects can occur if the provided correlation ID is not unique.\n<3> A boolean value indicating whether the delivery mode should be `DeliveryMode.PERSISTENT` (`true`) or `DeliveryMode.NON_PERSISTENT` (`false`).\nThis setting takes effect only if `explicit-qos-enabled` is `true`.\n<4> A `DestinationResolver`.\nThe default is a `SimpleDestinationResolver`, which maps the destination name to a queue or topic of that name and caches a destination.\n<5> When set to `true`, it enables the use of quality of service attributes: `priority`, `delivery-mode`, and `time-to-live`.\n<6> When set to `true` (the default), the payload of the Spring Integration reply message is created from the JMS Reply message's body (by using the `MessageConverter`).\nWhen set to `false`, the entire JMS message becomes the payload of the Spring Integration message.\n<7> When set to `true` (the default), the payload of the Spring Integration message is converted to a `JMSMessage` (by using the `MessageConverter`).\nWhen set to `false`, the entire Spring Integration Message is converted to the `JMSMessage`.\nIn both cases, the Spring Integration message headers are mapped to JMS headers and properties by using the `HeaderMapper`.\n<8> A `HeaderMapper` used to map Spring Integration message headers to and from JMS message headers and properties.\n<9> A reference to a `MessageConverter` for converting between JMS messages and the Spring Integration message payloads (or messages if `extract-request-payload` is `false`).\nThe default is a `SimpleMessageConverter`.\n<10> The default priority of request messages.\nOverridden by the message priority header, if present.\nIts range is `0` to `9`.\nThis setting takes effect only if `explicit-qos-enabled` is `true`.\n<11> The time (in milliseconds) to wait for a reply.\nThe default is `5000` (five seconds).\n<12> The channel to which the reply message is sent.\n<13> A reference to a `Destination`, which is set as the `JMSReplyTo` header.\nAt most, only one of `reply-destination`, `reply-destination-expression`, or `reply-destination-name` is allowed.\nIf none is provided, a `TemporaryQueue` is used for replies to this gateway.\n<14> A SpEL expression evaluating to a `Destination`, which will be set as the `JMSReplyTo` header.\nThe expression can result in a `Destination` object or a `String`.\nIt is used by the `DestinationResolver` to resolve the actual `Destination`.\nAt most, only one of `reply-destination`, `reply-destination-expression`, or `reply-destination-name` is allowed.\nIf none is provided, a `TemporaryQueue` is used for replies to this gateway.\n<15> The name of the destination that is set as the JMSReplyTo header.\nIt is used by the `DestinationResolver` to resolve the actual `Destination`.\nAt most, only one of `reply-destination`, `reply-destination-expression`, or `reply-destination-name` is allowed.\nIf none is provided, a `TemporaryQueue` is used for replies to this gateway.\n<16> When set to `true`, it indicates that any reply `Destination` resolved by the `DestinationResolver` should be a `Topic` rather then a `Queue`.\n<17> The time the gateway waits when sending the reply message to the `reply-channel`.\nThis only has an effect if the `reply-channel` can block -- such as a `QueueChannel` with a capacity limit that is currently full.\nThe default is infinity.\n<18> The channel on which this gateway receives request messages.\n<19> A reference to a `Destination` to which request messages are sent.\nOne of `reply-destination`, `reply-destination-expression`, or `reply-destination-name` is required.\nYou can use only one of those three attributes.\n<20> A SpEL expression evaluating to a `Destination` to which request messages are sent.\nThe expression can result in a `Destination` object or a `String`.\nIt is used by the `DestinationResolver` to resolve the actual `Destination`.\nOne of the `reply-destination`, `reply-destination-expression`, or `reply-destination-name` is required.\nYou can use only one of those three attributes.\n<21> The name of the destination to which request messages are sent.\nIt is used by the `DestinationResolver` to resolve the actual `Destination`.\nOne of `reply-destination`, `reply-destination-expression`, or `reply-destination-name` is required.\nYou can use only one of those three attributes.\n<22> When set to `true`, it indicates that any request `Destination` resolved by the `DestinationResolver` should be a `Topic` rather then a `Queue`.\n<23> Specifies the message time to live.\nThis setting takes effect only if `explicit-qos-enabled` is `true`.\n<24> Specifies whether this outbound gateway must return a non-null value.\nBy default, this value is `true`, and a `MessageTimeoutException` is thrown when the underlying service does not return a value after the `receive-timeout`.\nNote that, if the service is never expected to return a reply, it would be better to use a `<int-jms:outbound-channel-adapter/>` instead of a `<int-jms:outbound-gateway/>` with `requires-reply=\"false\"`.\nWith the latter, the sending thread is blocked, waiting for a reply for the `receive-timeout` period.\n<25> When you use a `<reply-listener />`, its lifecycle (start and stop) matches that of the gateway by default.\nWhen this value is greater than `0`, the container is started on demand (when a request is sent).\nThe container continues to run until at least this time elapses with no requests being received (and until no replies are outstanding).\nThe container is started again on the next request.\nThe stop time is a minimum and may actually be up to 1.5x this value.\n<26> See xref:jms.adoc#jms-async-gateway[Async Gateway].\n<27> When this element is included, replies are received by an asynchronous `MessageListenerContainer` rather than creating a consumer for each reply.\nThis can be more efficient in many cases.\n\n[[jms-header-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Attribute Reference", "heading_level": 3, "file_order": 226, "section_index": 13, "content_hash": "c049ac75839be13e9d85ab7611239b5913c5fc88a9888dcffbf37488554e82db", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:e12e5ac3781a16f6f1358eef1af7d4905d21cb43ca75a14aa57b800578648a3b", "content": "JMS messages can contain meta-information such as JMS API headers and simple properties.\nYou can map those to and from Spring Integration message headers by using `JmsHeaderMapper`.\nThe JMS API headers are passed to the appropriate setter methods (such as `setJMSReplyTo`), whereas other headers are copied to the general properties of the JMS Message.\nJMS outbound gateway is bootstrapped with the default implementation of `JmsHeaderMapper`, which will map standard JMS API Headers as well as primitive or `String` message headers.\nYou could also provide a custom header mapper by using the `header-mapper` attribute of inbound and outbound gateways.\n\nIMPORTANT: Many JMS vendor-specific clients don't allow setting the `deliveryMode`, `priority` and `timeToLive` properties directly on an already created JMS message.\nThey are considered to be QoS properties and therefore have to be propagated to the target `MessageProducer.send(message, deliveryMode, priority, timeToLive)` API.\nFor this reason the `DefaultJmsHeaderMapper` doesn't map appropriate Spring Integration headers (or expression results) into the mentioned JMS message properties.\nInstead, a `DynamicJmsTemplate` is used by the `JmsSendingMessageHandler` to propagate header values from the request message into the `MessageProducer.send()` API.\nTo enable this feature, you must configure the outbound endpoint with a `DynamicJmsTemplate` with its `explicitQosEnabled` property set to true.\nThe Spring Integration Java DSL configures a `DynamicJmsTemplate` by default, but you must still set the `explicitQosEnabled` property.\n\nIMPORTANT: Since version 4.0, the `JMSPriority` header is mapped to the standard `priority` header for inbound messages.\nPreviously, the `priority` header was only used for outbound messages.\nTo revert to the previous behavior (that is, to not map the inbound priority), set the `mapInboundPriority` property of `DefaultJmsHeaderMapper` to `false`.\n\nIMPORTANT: Since version 4.3, the `DefaultJmsHeaderMapper` maps the standard `correlationId` header as a message property by invoking its `toString()` method (`correlationId` is often a `UUID`, which is not supported by JMS).\nOn the inbound side, it is mapped as a `String`.\nThis is independent of the `jms_correlationId` header, which is mapped to and from the `JMSCorrelationID` header.\nThe `JMSCorrelationID` is generally used to correlate requests and replies, whereas the `correlationId` is often used to combine related messages into a group (such as with an aggregator or a resequencer).\n\nStarting with version 5.1, the `DefaultJmsHeaderMapper` can be configured for mapping inbound `JMSDeliveryMode` and `JMSExpiration` properties:\n\n[source,java]\n----\n@Bean\npublic DefaultJmsHeaderMapper jmsHeaderMapper() {\n DefaultJmsHeaderMapper mapper = new DefaultJmsHeaderMapper();\n mapper.setMapInboundDeliveryMode(true)\n mapper.setMapInboundExpiration(true)\n return mapper;\n}\n----\n\nThese JMS properties are mapped to the `JmsHeaders.DELIVERY_MODE` and `JmsHeaders.EXPIRATION` Spring Message headers respectively.\n\n[[jms-conversion-and-marshalling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Mapping Message Headers to and from JMS Message", "heading_level": 2, "file_order": 226, "section_index": 14, "content_hash": "e12e5ac3781a16f6f1358eef1af7d4905d21cb43ca75a14aa57b800578648a3b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:a645878bbf0f3604ecc651e360c888b1ab2485f3241c8e48b765b0c1f815fc73", "content": "If you need to convert the message, all JMS adapters and gateways let you provide a `MessageConverter` by setting the `message-converter` attribute.\nTo do so, provide the bean name of an instance of `MessageConverter` that is available within the same ApplicationContext.\nAlso, to provide some consistency with marshaller and unmarshaller interfaces, Spring provides `MarshallingMessageConverter`, which you can configure with your own custom marshallers and unmarshallers.\nThe following example shows how to do so\n\n[source,xml]\n----\n<int-jms:inbound-gateway request-destination=\"requestQueue\"\n request-channel=\"inbound-gateway-channel\"\n message-converter=\"marshallingMessageConverter\"/>\n\n<bean id=\"marshallingMessageConverter\"\n class=\"org.springframework.jms.support.converter.MarshallingMessageConverter\">\n <constructor-arg>\n <bean class=\"org.bar.SampleMarshaller\"/>\n </constructor-arg>\n <constructor-arg>\n <bean class=\"org.bar.SampleUnmarshaller\"/>\n </constructor-arg>\n</bean>\n----\n\nNOTE: When you provide your own `MessageConverter` instance, it is still wrapped within the `HeaderMappingMessageConverter`.\nThis means that the 'extract-request-payload' and 'extract-reply-payload' properties can affect the actual objects passed to your converter.\nThe `HeaderMappingMessageConverter` itself delegates to a target `MessageConverter` while also mapping the Spring Integration `MessageHeaders` to JMS message properties and back again.\n\n[[jms-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Message Conversion, Marshalling, and Unmarshalling", "heading_level": 2, "file_order": 226, "section_index": 15, "content_hash": "a645878bbf0f3604ecc651e360c888b1ab2485f3241c8e48b765b0c1f815fc73", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:818b2d4d15e33ecce876da5c57d61e43f6bfa315f189980b91e6181d3479b154", "content": "The channel adapters and gateways featured earlier are all intended for applications that integrate with other external systems.\nThe inbound options assume that some other system is sending JMS messages to the JMS destination, and the outbound options assume that some other system is receiving from the destination.\nThe other system may or may not be a Spring Integration application.\nOf course, when sending a Spring Integration message instance as the body of the JMS message itself (with 'extract-payload' value set to `false`), it is assumed that the other system is based on Spring Integration.\nHowever, that is by no means a requirement.\nThat flexibility is one of the benefits of using a message-based integration option with the abstraction of \"`channels`\"( or destinations in the case of JMS).\n\nSometimes, both the producer and consumer for a given JMS Destination are intended to be part of the same application, running within the same process.\nYou can accomplish this by using a pair of inbound and outbound channel adapters.\nThe problem with that approach is that you need two adapters, even though, conceptually, the goal is to have a single message channel.\nA better option is supported as of Spring Integration version 2.0.\nNow it is possible to define a single \"`channel`\" when using the JMS namespace, as the following example shows:\n\n[source,xml]\n----\n<int-jms:channel id=\"jmsChannel\" queue=\"exampleQueue\"/>\n----\n\nThe channel in the preceding example behaves much like a normal `<channel/>` element from the main Spring Integration namespace.\nIt can be referenced by both the `input-channel` and `output-channel` attributes of any endpoint.\nThe difference is that this channel is backed by a JMS Queue instance named `exampleQueue`.\nThis means that asynchronous messaging is possible between the producing and consuming endpoints.\nHowever, unlike the simpler asynchronous message channels created by adding a `<queue/>` element within a non-JMS `<channel/>` element, the messages are not stored in an in-memory queue.\nInstead, those messages are passed within a JMS message body, and the full power of the underlying JMS provider is then available for that channel.\nProbably the most common rationale for using this alternative is to take advantage of the persistence made available by the store-and-forward approach of JMS messaging.\n\nIf configured properly, the JMS-backed message channel also supports transactions.\nIn other words, a producer would not actually write to a transactional JMS-backed channel if its send operation is part of a transaction that rolls back.\nLikewise, a consumer would not physically remove a JMS message from the channel if the reception of that message is part of a transaction that rolls back.\nNote that the producer and consumer transactions are separate in such a scenario.\nThis is significantly different from the propagation of a transactional context across a simple, synchronous `<channel/>` element that has no `<queue/>` child element.\n\nSince the preceding example above references a JMS Queue instance, it acts as a point-to-point channel.\nIf, on the other hand, you need publish-subscribe behavior, you can use a separate element and reference a JMS Topic instead.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<int-jms:publish-subscribe-channel id=\"jmsChannel\" topic=\"exampleTopic\"/>\n----\n\nFor either type of JMS-backed channel, the name of the destination may be provided instead of a reference, as the following example shows:\n\n[source,xml]\n----\n<int-jms:channel id=\"jmsQueueChannel\" queue-name=\"exampleQueueName\"/>\n\n<jms:publish-subscribe-channel id=\"jmsTopicChannel\" topic-name=\"exampleTopicName\"/>\n----\n\nIn the preceding examples, the destination names are resolved by Spring's default `SimpleDestinationResolver` implementation, but you could provide any implementation of the `DestinationResolver` interface.\nAlso, the JMS `ConnectionFactory` is a required property of the channel, but, by default, the expected bean name would be `jmsConnectionFactory`.\nThe following example provides both a custom instance for resolution of the JMS destination names and a different name for the `ConnectionFactory`:\n\n[source,xml]\n----\n<int-jms:channel id=\"jmsChannel\" queue-name=\"exampleQueueName\"\n destination-resolver=\"customDestinationResolver\"\n connection-factory=\"customConnectionFactory\"/>\n----\n\nFor the `<publish-subscribe-channel />`, set the `durable` attribute to `true` for a durable subscription or `subscription-shared` for a shared subscription (requires a JMS 2.0 broker and has been available since version 4.2).\nUse `subscription` to name the subscription.\n\n[[jms-selectors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "JMS-backed Message Channels", "heading_level": 2, "file_order": 226, "section_index": 16, "content_hash": "818b2d4d15e33ecce876da5c57d61e43f6bfa315f189980b91e6181d3479b154", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:d7917fdc2170b2343e3c91a9949a8ed68cd9897aeb41afdf66d2769192f334e3", "content": "With JMS message selectors, you can filter https://javadoc.io/doc/jakarta.jms/jakarta.jms-api/latest/jakarta/jms/Message.html[JMS Messages] based on JMS headers as well as JMS properties.\nFor example, if you want to listen to messages whose custom JMS header property, `myHeaderProperty`, equals `something`, you can specify the following expression:\n\n[source,xml]\n----\nmyHeaderProperty = 'something'\n----\n\nMessage selector expressions are a subset of the https://en.wikipedia.org/wiki/SQL-92[SQL-92] conditional expression syntax and are defined as part of the https://docs.oracle.com/cd/E19798-01/821-1841/bncer/index.html[Java Message Service] specification.\nYou can specify the JMS message `selector` attribute by using XML namespace configuration for the following Spring Integration JMS components:\n\n* JMS Channel\n* JMS Publish Subscribe Channel\n* JMS Inbound Channel Adapter\n* JMS Inbound Gateway\n* JMS Message-driven Channel Adapter\n\nIMPORTANT: You cannot reference message body values by using JMS Message selectors.\n\n[[jms-samples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "Using JMS Message Selectors", "heading_level": 2, "file_order": 226, "section_index": 17, "content_hash": "d7917fdc2170b2343e3c91a9949a8ed68cd9897aeb41afdf66d2769192f334e3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:2636017fea6a91e75ccafb44e3ee4c461012a4c05710e75e6a601af965e94c42", "content": "To experiment with these JMS adapters, check out the JMS samples available in the Spring Integration Samples Git repository at https://github.com/SpringSource/spring-integration-samples/tree/main/basic/jms[https://github.com/spring-projects/spring-integration-samples/tree/master/basic/jms].\n\nThat repository includes two samples.\nOne provides inbound and outbound channel adapters, and the other provides inbound and outbound gateways.\nThey are configured to run with an embedded https://activemq.apache.org/[ActiveMQ] process, but you can modify the https://github.com/spring-projects/spring-integration-samples/blob/main/basic/jms/src/main/resources/META-INF/spring/integration/common.xml[common.xml] Spring application context file of each sample to support either a different JMS provider or a standalone ActiveMQ process.\n\nIn other words, you can split the configuration so that the inbound and outbound adapters run in separate JVMs.\nIf you have ActiveMQ installed, modify the `brokerURL` property within the `common.xml` file to use `tcp://localhost:61616` (instead of `vm://localhost`).\nBoth of the samples accept input from stdin and echo back to stdout.\nLook at the configuration to see how these messages are routed over JMS.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jms.adoc", "title": "jms", "heading": "JMS Samples", "heading_level": 2, "file_order": 226, "section_index": 18, "content_hash": "2636017fea6a91e75ccafb44e3ee4c461012a4c05710e75e6a601af965e94c42", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jms.adoc"}}
{"id": "sha256:c662dbe2b9bfa266c07aeb38ef9d1d1571530dc9306563947352b99c9d52ea79", "content": "[[jmx]]\n\nSpring Integration provides channel Adapters for receiving and publishing JMX Notifications.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-jmx</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-jmx:{project-version}\"\n----\n======\n\nAn inbound channel adapter allows for polling JMX MBean attribute values, and an outbound channel adapter allows for invoking JMX MBean operations.\n\n[[jmx-notification-listening-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jmx.adoc", "title": "jmx", "heading": "jmx", "heading_level": 1, "file_order": 227, "section_index": 0, "content_hash": "c662dbe2b9bfa266c07aeb38ef9d1d1571530dc9306563947352b99c9d52ea79", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jmx.adoc"}}
{"id": "sha256:5d61915ec60f447e126794bcce3d8ce14ac80bc9903c6340e7d96b7df8a677ea", "content": "The notification-listening channel adapter requires a JMX `ObjectName` for the MBean that publishes notifications to which this listener should be registered.\nA very simple configuration might resemble the following:\n\n[source,xml]\n----\n<int-jmx:notification-listening-channel-adapter id=\"adapter\"\n channel=\"channel\"\n object-name=\"example.domain:name=publisher\"/>\n----\n\nTIP: The `notification-listening-channel-adapter` registers with an `MBeanServer` at startup, and the default bean name is `mbeanServer`, which happens to be the same bean name generated when using Spring's `<context:mbean-server/>` element.\nIf you need to use a different name, be sure to include the `mbean-server` attribute.\n\nThe adapter can also accept a reference to a `NotificationFilter` and a \"`handback`\" object to provide some context that is passed back with each notification.\nBoth of those attributes are optional.\nExtending the preceding example to include those attributes as well as an explicit `MBeanServer` bean name produces the following example:\n\n[source,xml]\n----\n<int-jmx:notification-listening-channel-adapter id=\"adapter\"\n channel=\"channel\"\n mbean-server=\"someServer\"\n object-name=\"example.domain:name=somePublisher\"\n notification-filter=\"notificationFilter\"\n handback=\"myHandback\"/>\n----\n\nThe _Notification-listening channel adapter is event-driven and registered with the `MBeanServer` directly.\nIt does not require any poller configuration.\n\n[NOTE]\n====\nFor this component only, the `object-name` attribute can contain an object name pattern, for example, `org.something:type=MyType,name=*`.\nIn that case, the adapter receives notifications from all MBeans with object names that match the pattern.\nIn addition, the `object-name` attribute can contain a SpEL reference to a `<util:list>` of object name patterns, as the following example shows:\n\n[source,xml]\n----\n<jmx:notification-listening-channel-adapter id=\"manyNotificationsAdapter\"\n channel=\"manyNotificationsChannel\"\n object-name=\"#{patterns}\"/>\n\n<util:list id=\"patterns\">\n <value>org.foo:type=Foo,name=*</value>\n <value>org.foo:type=Bar,name=*</value>\n</util:list>\n----\n\nThe names of the located MBean(s) are logged when DEBUG level logging is enabled.\n====\n\n[[jmx-notification-publishing-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jmx.adoc", "title": "jmx", "heading": "Notification-listening Channel Adapter", "heading_level": 2, "file_order": 227, "section_index": 1, "content_hash": "5d61915ec60f447e126794bcce3d8ce14ac80bc9903c6340e7d96b7df8a677ea", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jmx.adoc"}}
{"id": "sha256:0d6bcd34b7147befeb4663b38303967ca431398b6e42965035ef1832933bb586", "content": "The notification-publishing channel adapter is relatively simple.\nIt requires only a JMX object name in its configuration, as the following example shows:\n\n[source,xml]\n----\n<context:mbean-export/>\n\n<int-jmx:notification-publishing-channel-adapter id=\"adapter\"\n channel=\"channel\"\n object-name=\"example.domain:name=publisher\"/>\n----\n\nIt also requires that an `MBeanExporter` be present in the context.\nThat is why the `<context:mbean-export/>` element is also shown in the preceding example.\n\nWhen messages are sent to the channel for this adapter, the notification is created from the message content.\nIf the payload is a `String`, it is passed as the `message` text for the notification.\nAny other payload type is passed as the `userData` of the notification.\n\nJMX notifications also have a `type`, and it should be a dot-delimited `String`.\nThere are two ways to provide the `type`.\nPrecedence is always given to a message header value associated with the `JmxHeaders.NOTIFICATION_TYPE` key.\nAlternatively, you can provide a fallback `default-notification-type` attribute in the configuration, as the following example shows:\n\n[source,xml]\n----\n<context:mbean-export/>\n\n<int-jmx:notification-publishing-channel-adapter id=\"adapter\"\n channel=\"channel\"\n object-name=\"example.domain:name=publisher\"\n default-notification-type=\"some.default.type\"/>\n----\n\n[[jmx-attribute-polling-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jmx.adoc", "title": "jmx", "heading": "Notification-publishing Channel Adapter", "heading_level": 2, "file_order": 227, "section_index": 2, "content_hash": "0d6bcd34b7147befeb4663b38303967ca431398b6e42965035ef1832933bb586", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jmx.adoc"}}
{"id": "sha256:dafe88a5a733c16b9262a0cebf68ccccbf963bc966c4911a272466939687afe8", "content": "The attribute-polling channel adapter is useful when you need to periodically check on some value that is available through an MBean as a managed attribute.\nYou can configure the poller in the same way as any other polling adapter in Spring Integration, or you can rely on the default poller.\nThe `object-name` and the `attribute-name` are required.\nAn MBeanServer reference is also required.\nHowever, by default, it automatically checks for a bean named `mbeanServer`, same as the notification-listening channel adapter xref:jmx.adoc#jmx-notification-listening-channel-adapter[described earlier].\nThe following example shows how to configure an attribute-polling channel adapter with XML:\n\n[source,xml]\n----\n<int-jmx:attribute-polling-channel-adapter id=\"adapter\"\n channel=\"channel\"\n object-name=\"example.domain:name=someService\"\n attribute-name=\"InvocationCount\">\n <int:poller max-messages-per-poll=\"1\" fixed-rate=\"5000\"/>\n</int-jmx:attribute-polling-channel-adapter>\n----\n\n[[tree-polling-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jmx.adoc", "title": "jmx", "heading": "Attribute-polling Channel Adapter", "heading_level": 2, "file_order": 227, "section_index": 3, "content_hash": "dafe88a5a733c16b9262a0cebf68ccccbf963bc966c4911a272466939687afe8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jmx.adoc"}}
{"id": "sha256:851c4c8ef91d1377e3037552dc964337e14a684a9c01064513bd4ef3baf99fe1", "content": "The tree-polling channel adapter queries the JMX MBean tree and sends a message with a payload that is the graph of objects that matches the query.\nBy default, the MBeans are mapped to primitives and simple objects, such as `Map`, `List`, and arrays.\nDoing so permits a simple transformation to, for example, JSON.\nAn MBeanServer reference is also required.\nHowever, by default, it automatically checks for a bean named `mbeanServer`, same as the notification-listening channel adapter xref:jmx.adoc#jmx-notification-listening-channel-adapter[described earlier].\nThe following example shows how to configure a tree-polling channel adapter with XML:\n\n[source,xml]\n----\n<int-jmx:tree-polling-channel-adapter id=\"adapter\"\n channel=\"channel\"\n query-name=\"example.domain:type=*\">\n <int:poller max-messages-per-poll=\"1\" fixed-rate=\"5000\"/>\n</int-jmx:tree-polling-channel-adapter>\n----\n\nThe preceding example includes all the attributes on the selected MBeans.\nYou can filter the attributes by providing an `MBeanObjectConverter` that has an appropriate filter configured.\nYou can provide the converter as a reference to a bean definition by using the `converter` attribute, or you can use an inner `<bean/>` definition.\nSpring Integration provides a `DefaultMBeanObjectConverter` that can take a `MBeanAttributeFilter` in its constructor argument.\n\nSpring Integration provides two standard filters.\nThe `NamedFieldsMBeanAttributeFilter` lets you specify a list of attributes to include.\nThe `NotNamedFieldsMBeanAttributeFilter` lets you specify a list of attributes to exclude.\nYou can also implement your own filter.\n\n[[jmx-operation-invoking-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jmx.adoc", "title": "jmx", "heading": "Tree-polling Channel Adapter", "heading_level": 2, "file_order": 227, "section_index": 4, "content_hash": "851c4c8ef91d1377e3037552dc964337e14a684a9c01064513bd4ef3baf99fe1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jmx.adoc"}}
{"id": "sha256:f12bc75defd12f72535c2de67968db2def31551c45dd00eac08902b72848059b", "content": "The operation-invoking channel adapter enables message-driven invocation of any managed operation exposed by an MBean.\nEach invocation requires the operation name to be invoked and the object name of the target MBean.\nBoth of these must be explicitly provided by adapter configuration or via `JmxHeaders.OBJECT_NAME` and `JmxHeaders.OPERATION_NAME` message headers, respectively:\n\n[source,xml]\n----\n<int-jmx:operation-invoking-channel-adapter id=\"adapter\"\n object-name=\"example.domain:name=TestBean\"\n operation-name=\"ping\"/>\n----\n\nThen the adapter only needs to be able to discover the `mbeanServer` bean.\nIf a different bean name is required, then provide the `mbean-server` attribute with a reference.\n\nThe payload of the message is mapped to the parameters of the operation, if any.\nA `Map`-typed payload with `String` keys is treated as name/value pairs, whereas a `List` or array is passed as a simple argument list (with no explicit parameter names).\nIf the operation requires a single parameter value, the payload can represent that single value.\nAlso, if the operation requires no parameters, the payload would be ignored.\n\nIf you want to expose a channel for a single common operation to be invoked by messages that need not contain headers, that last option works well.\n\n[[jmx-operation-invoking-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jmx.adoc", "title": "jmx", "heading": "Operation-invoking Channel Adapter", "heading_level": 2, "file_order": 227, "section_index": 5, "content_hash": "f12bc75defd12f72535c2de67968db2def31551c45dd00eac08902b72848059b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jmx.adoc"}}
{"id": "sha256:cd74a55f246b762d335b3dcb22fde93318c255e78e6d3cf65a28fbe2a5843b8b", "content": "Similarly to the operation-invoking channel adapter, Spring Integration also provides an operation-invoking outbound gateway, which you can use when dealing with non-void operations when a return value is required.\nThe return value is sent as the message payload to the `reply-channel` specified by the gateway.\nThe following example shows how to configure an operation-invoking outbound gateway with XML:\n\n[source,xml]\n----\n<int-jmx:operation-invoking-outbound-gateway request-channel=\"requestChannel\"\n reply-channel=\"replyChannel\"\n object-name=\"o.s.i.jmx.config:type=TestBean,name=testBeanGateway\"\n operation-name=\"testWithReturn\"/>\n----\n\nIf you do not provide the `reply-channel` attribute, the reply message is sent to the channel identified by the `MessageHeaders.REPLY_CHANNEL` header.\nThat header is typically auto-created by the entry point into a message flow, such as any gateway component.\nHowever, if the message flow was started by manually creating a Spring Integration message and sending it directly to a channel, you must specify the message header explicitly or use the `reply-channel` attribute.\n\n[[jmx-mbean-exporter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jmx.adoc", "title": "jmx", "heading": "Operation-invoking Outbound Gateway", "heading_level": 2, "file_order": 227, "section_index": 6, "content_hash": "cd74a55f246b762d335b3dcb22fde93318c255e78e6d3cf65a28fbe2a5843b8b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jmx.adoc"}}
{"id": "sha256:cbb9e090a5478d5ad5e2e51fbfe10a44999f4523ebdc695223b89987b92d7f26", "content": "Spring Integration components may themselves be exposed as MBeans when the `IntegrationMBeanExporter` is configured.\nTo create an instance of the `IntegrationMBeanExporter`, define a bean and provide a reference to an `MBeanServer` and a domain name (if desired).\nYou can leave out the domain, in which case the default domain is `org.springframework.integration`.\nThe following example shows how to declare an instance of an `IntegrationMBeanExporter` and an associated `MBeanServer` instance:\n\n[source,xml]\n----\n<int-jmx:mbean-export id=\"integrationMBeanExporter\"\n default-domain=\"my.company.domain\" server=\"mbeanServer\"/>\n\n<bean id=\"mbeanServer\" class=\"org.springframework.jmx.support.MBeanServerFactoryBean\">\n <property name=\"locateExistingServerIfPossible\" value=\"true\"/>\n</bean>\n----\n\n[IMPORTANT]\n=====\nThe MBean exporter is orthogonal to the one provided in Spring core.\nIt registers message channels and message handlers but does not register itself.\nYou can expose the exporter itself (and certain other components in Spring Integration) by using the standard `<context:mbean-export/>` tag.\nThe exporter has some metrics attached to it -- for instance, a count of the number of handlers and the number of queued messages.\n\nIt also has a useful operation, as discussed in xref:jmx.adoc#jmx-mbean-shutdown[Orderly Shutdown Managed Operation].\n=====\n\nSpring Integration 4.0 introduced the `@EnableIntegrationMBeanExport` annotation to allow for convenient configuration of a default `integrationMbeanExporter` bean of type `IntegrationMBeanExporter` with several useful options at the `@Configuration` class level.\nThe following example shows how to configure this bean:\n\n[source,java]\n----\n@Configuration\n@EnableIntegration\n@EnableIntegrationMBeanExport(server = \"mbeanServer\", managedComponents = \"input\")\npublic class ContextConfiguration {\n\n\t@Bean\n\tpublic MBeanServerFactoryBean mbeanServer() {\n return new MBeanServerFactoryBean();\n\t}\n}\n----\n\nIf you need to provide more options or have several `IntegrationMBeanExporter` beans (such as for different MBean Servers or to avoid conflicts with the standard Spring `MBeanExporter` -- such as through `@EnableMBeanExport`), you can configure an `IntegrationMBeanExporter` as a generic bean.\n\n[[jmx-mbean-features]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jmx.adoc", "title": "jmx", "heading": "MBean Exporter", "heading_level": 2, "file_order": 227, "section_index": 7, "content_hash": "cbb9e090a5478d5ad5e2e51fbfe10a44999f4523ebdc695223b89987b92d7f26", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jmx.adoc"}}
{"id": "sha256:08d65ba0dd4fee936e8a7e6ac199def1321a572fccb64c3bbcf74b9550f24881", "content": "All the `MessageChannel`, `MessageHandler`, and `MessageSource` instances in the application are wrapped by the MBean exporter to provide management and monitoring features.\nThe generated JMX object names for each component type are listed in the following table:\n\n.MBean Object Names\n[cols=\"1,3l\", options=\"header\"]\n|===\n| Component Type\n| Object Name\n\n| MessageChannel\n| `o.s.i:type=MessageChannel,name=<channelName>`\n\n| MessageSource\n| `o.s.i:type=MessageSource,name=<channelName>,bean=<source>`\n\n| MessageHandler\n| `o.s.i:type=MessageSource,name=<channelName>,bean=<source>`\n|===\n\nThe `bean` attribute in the object names for sources and handlers takes one of the values in the following table:\n\n.bean ObjectName Part\n[cols=\"1,3\", options=\"header\"]\n|===\n| Bean Value\n| Description\n\n| endpoint\n| The bean name of the enclosing endpoint (for example `<service-activator>`), if there is one\n\n| anonymous\n| An indication that the enclosing endpoint did not have a user-specified bean name, so the JMX name is the input channel name.\n\n| internal\n| For well-known Spring Integration default components\n\n| handler/source\n| None of the above.\nFall back to the `toString()` method of the object being monitored (handler or source)\n\n|===\n\nYou can append custom elements to the object name by providing a reference to a `Properties` object in the `object-name-static-properties` attribute.\n\nAlso, since Spring Integration 3.0, you can use a custom https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jmx/export/naming/ObjectNamingStrategy.html[`ObjectNamingStrategy`] by setting the `object-naming-strategy` attribute.\nDoing so permits greater control over the naming of the MBeans, such as grouping all integration MBeans under an 'Integration' type.\nThe following example shows one possible custom naming strategy implementation:\n\n[source,java]\n----\npublic class Namer implements ObjectNamingStrategy {\n\n\tprivate final ObjectNamingStrategy realNamer = new KeyNamingStrategy();\n\t@Override\n\tpublic ObjectName getObjectName(Object managedBean, String beanKey) throws MalformedObjectNameException {\n String actualBeanKey = beanKey.replace(\"type=\", \"type=Integration,componentType=\");\n return realNamer.getObjectName(managedBean, actualBeanKey);\n\t}\n\n}\n----\n\nThe `beanKey` argument is a `String` that contain the standard object name, beginning with the `default-domain` and including any additional static properties.\nThe preceding example moves the standard `type` part to `componentType` and sets the `type` to 'Integration', enabling selection of all Integration MBeans in one query:`my.domain:type=Integration,*`.\nDoing so also groups the beans under one tree entry under the domain in such tools as VisualVM.\n\nNOTE: The default naming strategy is a https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jmx/export/naming/MetadataNamingStrategy.html[`MetadataNamingStrategy`].\nThe exporter propagates the `default-domain` to that object to let it generate a fallback object name if parsing of the bean key fails.\nIf your custom naming strategy is a `MetadataNamingStrategy` (or a subclass of it), the exporter does not propagate the `default-domain`.\nYou must configure it on your strategy bean.\n\nStarting with version 5.1, any bean names (represented by the `name` key in the object name) will be quoted if they contain any characters that are not allowed in a Java identifier (or period `.`).\n\n[[jmx-42-improvements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jmx.adoc", "title": "jmx", "heading": "MBean Object Names", "heading_level": 3, "file_order": 227, "section_index": 8, "content_hash": "08d65ba0dd4fee936e8a7e6ac199def1321a572fccb64c3bbcf74b9550f24881", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jmx.adoc"}}
{"id": "sha256:95f367364a97972832e4f889ef0fcea2c8ef1a9cd2873221048095cf4ce0f653", "content": "Version 4.2 introduced some important improvements, representing a fairly major overhaul to the JMX support in the framework.\nThese resulted in a significant performance improvement of the JMX statistics collection and much more control thereof.\nHowever, it has some implications for user code in a few specific (uncommon) situations.\nThese changes are detailed below, with caution where necessary.\n\n@IntegrationManagedResource::\nSimilar to the `@ManagedResource` annotation, the `@IntegrationManagedResource` marks a class as being eligible to be exported as an MBean.\nHowever, it is exported only if the application context has an `IntegrationMBeanExporter`.\n+\nCertain Spring Integration classes (in the `org.springframework.integration`) package) that were previously annotated with `@ManagedResource` are now annotated with both `@ManagedResource` and `@IntegrationManagedResource`.\nThis is for backwards compatibility (see the next item).\nSuch MBeans are exported by any context `MBeanServer` or by an `IntegrationMBeanExporter` (but not both -- if both exporters are present, the bean is exported by the integration exporter if the bean matches a `managed-components` pattern).\n\nMBean Exporter Bean Name Patterns::\nPreviously, the `managed-components` patterns were inclusive only.\nIf a bean name matched one of the patterns, it would be included.\nNow, the pattern can be negated by prefixing it with `!`.\nFor example, `!thing*, things` matches all bean names that do not start with `thing` except `things`.\nPatterns are evaluated left to right.\nThe first match (positive or negative) wins, and then no further patterns are applied.\n+\nWARNING: The addition of this syntax to the pattern causes one possible (although perhaps unlikely) problem.\nIf you have a bean named `\"!thing\"` and you included a pattern of `!thing` in your MBean exporter's `managed-components` patterns, it no longer matches; the pattern now matches all beans not named `thing`.\nIn this case, you can escape the `!` in the pattern with `\\`.\nThe `\\!thing` pattern matches a bean named `!thing`.\n\nIntegrationMBeanExporter changes::\nThe `IntegrationMBeanExporter` no longer implements `SmartLifecycle`.\nThis means that `start()` and `stop()` operations are no longer available to register and unregister MBeans.\nThe MBeans are now registered during context initialization and unregistered when the context is destroyed.\n\n[[jmx-mbean-shutdown]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jmx.adoc", "title": "jmx", "heading": "JMX Improvements", "heading_level": 3, "file_order": 227, "section_index": 9, "content_hash": "95f367364a97972832e4f889ef0fcea2c8ef1a9cd2873221048095cf4ce0f653", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jmx.adoc"}}
{"id": "sha256:a4f72b4505337a0334247d09b70361e53dce34432a33cb78cd9d0e43c2732948", "content": "The MBean exporter lets a JMX operation shut down the application in an orderly manner.\nIt is intended for use before stopping the JVM.\nIts use and operation are described in xref:shutdown.adoc[Orderly Shutdown].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jmx.adoc", "title": "jmx", "heading": "Orderly Shutdown Managed Operation", "heading_level": 3, "file_order": 227, "section_index": 10, "content_hash": "a4f72b4505337a0334247d09b70361e53dce34432a33cb78cd9d0e43c2732948", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jmx.adoc"}}
{"id": "sha256:d6a5a1519128c0365caedc16b5eaa70f7c566f995fdc232dd236ae7bce399a96", "content": "[[jpa]]\n\nSpring Integration's JPA (Java Persistence API) module provides components for performing various database operations using JPA.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-jpa</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-jpa:{project-version}\"\n----\n======\n\nThe JPA API must be included via some vendor-specific implementation, e.g. Hibernate ORM Framework.\n\nThe following components are provided:\n\n* xref:jpa/inbound-channel-adapter.adoc[Inbound channel adapter]\n* xref:jpa/outbound-channel-adapter.adoc[Outbound channel adapter]\n* xref:jpa/outbound-gateways.adoc#jpa-updating-outbound-gateway[Updating outbound gateway]\n* xref:jpa/outbound-gateways.adoc#jpa-retrieving-outbound-gateway[Retrieving outbound gateway]\n\nThese components can be used to perform `select`, `create`, `update`, and `delete` operations on the target databases by sending and receiving messages to them.\n\nThe JPA inbound channel adapter lets you poll and retrieve (`select`) data from the database by using JPA, whereas the JPA outbound channel adapter lets you create, update, and delete entities.\n\nYou can use outbound gateways for JPA to persist entities to the database, letting you continue the flow and execute further components downstream.\nSimilarly, you can use an outbound gateway to retrieve entities from the database.\n\nFor example, you may use the outbound gateway, which receives a `Message` with a `userId` as payload on its request channel, to query the database, retrieve the user entity, and pass it downstream for further processing.\n\nRecognizing these semantic differences, Spring Integration provides two separate JPA outbound gateways:\n\n* Retrieving outbound gateway\n* Updating outbound gateway", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/jpa.adoc", "title": "jpa", "heading": "jpa", "heading_level": 1, "file_order": 228, "section_index": 0, "content_hash": "d6a5a1519128c0365caedc16b5eaa70f7c566f995fdc232dd236ae7bce399a96", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/jpa.adoc"}}
{"id": "sha256:2bab40f055cffc64b3061c794be30958fb2bbc721238f8cfe1ff695846be35be", "content": "[[kafka]]\n\n[[overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "kafka", "heading_level": 1, "file_order": 229, "section_index": 0, "content_hash": "2bab40f055cffc64b3061c794be30958fb2bbc721238f8cfe1ff695846be35be", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:3df9e642440b8974c49438dd52cea0a6189a334c89939e063ae2bbc95ef2c039", "content": "Spring Integration for Apache Kafka is based on the https://projects.spring.io/spring-kafka/[Spring for Apache Kafka project].\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-kafka</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-kafka:{project-version}\"\n----\n======\n\nIt provides the following components:\n\n* xref:kafka.adoc#kafka-outbound[Outbound Channel Adapter]\n* xref:kafka.adoc#kafka-inbound[Message-driven Channel Adapter]\n* xref:kafka.adoc#kafka-inbound-pollable[Inbound Channel Adapter]\n* xref:kafka.adoc#kafka-outbound-gateway[Outbound Gateway]\n* xref:kafka.adoc#kafka-inbound-gateway[Inbound Gateway]\n* xref:kafka.adoc#kafka-channels[Channels Backed by Apache Kafka Topics]\n\n[[kafka-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Overview", "heading_level": 2, "file_order": 229, "section_index": 1, "content_hash": "3df9e642440b8974c49438dd52cea0a6189a334c89939e063ae2bbc95ef2c039", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:b4fc0f1deb66b88ad40eca39c66d12191997f96242de72881ce9ab0f3706eb08", "content": "The Outbound channel adapter is used to publish messages from a Spring Integration channel to Apache Kafka topics.\nThe channel is defined in the application context and then wired into the application that sends messages to Apache Kafka.\nSender applications can publish to Apache Kafka by using Spring Integration messages, which are internally converted to Kafka records by the outbound channel adapter, as follows:\n\n* The payload of the Spring Integration message is used to populate the payload of the Kafka record.\n* By default, the `kafka_messageKey` header of the Spring Integration message is used to populate the key of the Kafka record.\n\nYou can customize the target topic and partition for publishing the message through the `kafka_topic` and `kafka_partitionId` headers, respectively.\n\nIn addition, the `<int-kafka:outbound-channel-adapter>` provides the ability to extract the key, target topic, and target partition by applying SpEL expressions on the outbound message.\nTo that end, it supports three mutually exclusive pairs of attributes:\n\n* `topic` and `topic-expression`\n* `message-key` and `message-key-expression`\n* `partition-id` and `partition-id-expression`\n\nThese let you specify `topic`, `message-key`, and `partition-id`, respectively, as static values on the adapter or to dynamically evaluate their values at runtime against the request message.\n\nIMPORTANT: The `KafkaHeaders` interface (provided by `spring-kafka`) contains constants used for interacting with\nheaders.\nThe `messageKey` and `topic` default headers now require a `kafka_` prefix.\nWhen migrating from an earlier version that used the old headers, you need to specify `message-key-expression=\"headers['messageKey']\"` and `topic-expression=\"headers['topic']\"` on the `<int-kafka:outbound-channel-adapter>`.\nAlternatively, you can change the headers upstream to the new headers from `KafkaHeaders` by using a `<header-enricher>` or a `MessageBuilder`.\nIf you use constant values, you can also configure them on the adapter by using `topic` and `message-key`.\n\nNOTE : If the adapter is configured with a topic or message key (either with a constant or expression), those are used and the corresponding header is ignored.\nIf you wish the header to override the configuration, you need to configure it in an expression, such as the following:\n\n[source,java]\n----\ntopic-expression=\"headers['topic'] != null ? headers['topic'] : 'myTopic'\"\n----\n\nThe adapter requires a `KafkaTemplate`, which, in turn, requires a suitably configured `KafkaProducerFactory`.\n\nIf a `send-failure-channel` (`sendFailureChannel`) is provided and a `send()` failure (sync or async) is received, an `ErrorMessage` is sent to the channel.\nThe payload is a `KafkaSendFailureException` with `failedMessage`, `record` (the `ProducerRecord`) and `cause` properties.\nYou can override the `DefaultErrorMessageStrategy` by setting the `error-message-strategy` property.\n\nIf a `send-success-channel` (`sendSuccessChannel`) is provided, a message with a payload of type `org.apache.kafka.clients.producer.RecordMetadata` is sent after a successful sending.\n\nIMPORTANT: If your application uses transactions and the same channel adapter is used to publish messages where the transaction is started by a listener container, as well as publishing where there is no existing transaction, you must configure a `transactionIdPrefix` on the `KafkaTemplate` to override the prefix used by the container or transaction manager.\nThe prefix used by container-initiated transactions (the producer factory or transaction manager property) must be the same on all application instances.\nThe prefix used for producer-only transactions must be unique on all application instances.\n\nYou can configure a `flushExpression` which must resolve to a boolean value.\nFlushing after sending several messages might be useful if you are using the `linger.ms` and `batch.size` Kafka producer properties; the expression should evaluate to `Boolean.TRUE` on the last message and an incomplete batch will be sent immediately.\nBy default, the expression looks for a `Boolean` value in the `KafkaIntegrationHeaders.FLUSH` header (`kafka_flush`).\nThe flush will occur if the value is `true` and not if it is `false` or the header is absent.\n\nThe `KafkaProducerMessageHandler.sendTimeoutExpression` default has changed from 10 seconds to the `delivery.timeout.ms` Kafka producer property `+ 5000` so that the actual Kafka error after a timeout is propagated to the application, instead of a timeout generated by this framework.\nThis has been changed for consistency because you may get unexpected behavior (Spring may timeout the send, while it is actually, eventually, successful).\nIMPORTANT: That timeout is 120 seconds by default so you may wish to reduce it to get more timely failures.\n\n[[kakfa-outbound-adapter-coniguration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Outbound Channel Adapter", "heading_level": 2, "file_order": 229, "section_index": 2, "content_hash": "b4fc0f1deb66b88ad40eca39c66d12191997f96242de72881ce9ab0f3706eb08", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:b22fe208e48002063d40d70b921fae1826c1284e9cd16a98e7336ea8fa648604", "content": "The following example shows how to configure the outbound channel adapter for Apache Kafka:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic ProducerFactory<Integer, String> producerFactory() {\n return new DefaultKafkaProducerFactory<>(KafkaTestUtils.producerProps(embeddedKafka));\n}\n\n@Bean\npublic IntegrationFlow sendToKafkaFlow() {\n return f -> f\n .splitWith(s -> s.<String>function(p -> Stream.generate(() -> p).limit(101).iterator()))\n .publishSubscribeChannel(c -> c\n .subscribe(sf -> sf.handle(\n kafkaMessageHandler(producerFactory(), TEST_TOPIC1)\n .timestampExpression(\"T(Long).valueOf('1487694048633')\"),\n e -> e.id(\"kafkaProducer1\")))\n .subscribe(sf -> sf.handle(\n kafkaMessageHandler(producerFactory(), TEST_TOPIC2)\n .timestamp(m -> 1487694048644L),\n e -> e.id(\"kafkaProducer2\")))\n );\n}\n\n@Bean\npublic DefaultKafkaHeaderMapper mapper() {\n return new DefaultKafkaHeaderMapper();\n}\n\nprivate KafkaProducerMessageHandlerSpec<Integer, String, ?> kafkaMessageHandler(\n ProducerFactory<Integer, String> producerFactory, String topic) {\n return Kafka\n .outboundChannelAdapter(producerFactory)\n .messageKey(m -> m\n .getHeaders()\n .get(IntegrationMessageHeaderAccessor.SEQUENCE_NUMBER))\n .headerMapper(mapper())\n .partitionId(m -> 10)\n .topicExpression(\"headers[kafka_topic] ?: '\" + topic + \"'\")\n .configureKafkaTemplate(t -> t.id(\"kafkaTemplate:\" + topic));\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\n@ServiceActivator(inputChannel = \"toKafka\")\npublic MessageHandler handler() throws Exception {\n KafkaProducerMessageHandler<String, String> handler =\n new KafkaProducerMessageHandler<>(kafkaTemplate());\n handler.setTopicExpression(new LiteralExpression(\"someTopic\"));\n handler.setMessageKeyExpression(new LiteralExpression(\"someKey\"));\n handler.setSuccessChannel(successes());\n handler.setFailureChannel(failures());\n return handler;\n}\n\n@Bean\npublic KafkaTemplate<String, String> kafkaTemplate() {\n return new KafkaTemplate<>(producerFactory());\n}\n\n@Bean\npublic ProducerFactory<String, String> producerFactory() {\n Map<String, Object> props = new HashMap<>();\n props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, this.brokerAddress);\n // set more properties\n return new DefaultKafkaProducerFactory<>(props);\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-kafka:outbound-channel-adapter id=\"kafkaOutboundChannelAdapter\"\n kafka-template=\"template\"\n auto-startup=\"false\"\n channel=\"inputToKafka\"\n topic=\"foo\"\n sync=\"false\"\n message-key-expression=\"'bar'\"\n send-failure-channel=\"failures\"\n send-success-channel=\"successes\"\n error-message-strategy=\"ems\"\n partition-id-expression=\"2\">\n</int-kafka:outbound-channel-adapter>\n\n<bean id=\"template\" class=\"org.springframework.kafka.core.KafkaTemplate\">\n <constructor-arg>\n <bean class=\"org.springframework.kafka.core.DefaultKafkaProducerFactory\">\n <constructor-arg>\n <map>\n <entry key=\"bootstrap.servers\" value=\"localhost:9092\" />\n ... <!-- more producer properties -->\n </map>\n </constructor-arg>\n </bean>\n </constructor-arg>\n</bean>\n----\n======\n\n[[kafka-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Configuration", "heading_level": 3, "file_order": 229, "section_index": 3, "content_hash": "b22fe208e48002063d40d70b921fae1826c1284e9cd16a98e7336ea8fa648604", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:60bab2bc08aa2a3c66558a3188b7c547afd0fa100db488e448115e0cf004725b", "content": "The `KafkaMessageDrivenChannelAdapter` (`<int-kafka:message-driven-channel-adapter>`) uses a `spring-kafka` `KafkaMessageListenerContainer` or `ConcurrentListenerContainer`.\n\nAlso, the `mode` attribute is available.\nIt can accept values of `record` or `batch` (default: `record`).\nFor `record` mode, each message payload is converted from a single `ConsumerRecord`.\nFor `batch` mode, the payload is a list of objects that are converted from all the `ConsumerRecord` instances returned by the consumer poll.\nAs with the batched `@KafkaListener`, the `KafkaHeaders.RECEIVED_KEY`, `KafkaHeaders.RECEIVED_PARTITION`, `KafkaHeaders.RECEIVED_TOPIC`, and `KafkaHeaders.OFFSET` headers are also lists, with positions corresponding to the position in the payload.\n\nReceived messages have certain headers populated.\nSee the https://docs.spring.io/spring-kafka/api/org/springframework/kafka/support/KafkaHeaders.html[`KafkaHeaders` class] for more information.\n\nIMPORTANT: The `Consumer` object (in the `kafka_consumer` header) is not thread-safe.\nYou must invoke its methods only on the thread that calls the listener within the adapter.\nIf you hand off the message to another thread, you must not call its methods.\n\nWhen a `retry-template` is provided, delivery failures are retried according to its retry policy.\nIf an `error-channel` is also supplied, a default `ErrorMessageSendingRecoverer` will be used as the recovery callback after retries are exhausted.\nYou can also use the `recovery-callback` to specify some other action to take in that case, or set it to `null` to throw the final exception to the listener container so it is handled there.\n\nWhen building an `ErrorMessage` (for use in the `error-channel` or `recovery-callback`), you can customize the error message by setting the `error-message-strategy` property.\nBy default, a `RawRecordHeaderErrorMessageStrategy` is used, to provide access to the converted message as well as the raw `ConsumerRecord`.\n\nIMPORTANT: This form of retry is blocking and could cause a rebalance if the aggregate retry delays across all polled records might exceed the `max.poll.interval.ms` consumer property.\nInstead, consider adding a `DefaultErrorHandler` to the listener container, configured with a `KafkaErrorSendingMessageRecoverer`.\n\n[[kafka-inbound-adapter-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Message-driven Channel Adapter", "heading_level": 2, "file_order": 229, "section_index": 4, "content_hash": "60bab2bc08aa2a3c66558a3188b7c547afd0fa100db488e448115e0cf004725b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:31916db451027816cf49d685c31aac544238706a35e1b5f0810f04ae832f6c95", "content": "The following example shows how to configure a message-driven channel adapter:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow topic1ListenerFromKafkaFlow() {\n return IntegrationFlow\n .from(Kafka.messageDrivenChannelAdapter(consumerFactory(),\n KafkaMessageDrivenChannelAdapter.ListenerMode.record, TEST_TOPIC1)\n .configureListenerContainer(c ->\n c.ackMode(AbstractMessageListenerContainer.AckMode.MANUAL)\n .id(\"topic1ListenerContainer\"))\n .recoveryCallback(new ErrorMessageSendingRecoverer(errorChannel(),\n new RawRecordHeaderErrorMessageStrategy()))\n .retryTemplate(new RetryTemplate())\n .filterInRetry(true))\n .filter(Message.class, m ->\n m.getHeaders().get(KafkaHeaders.RECEIVED_MESSAGE_KEY, Integer.class) < 101,\n f -> f.throwExceptionOnRejection(true))\n .<String, String>transform(String::toUpperCase)\n .channel(c -> c.queue(\"listeningFromKafkaResults1\"))\n .get();\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\npublic KafkaMessageDrivenChannelAdapter<String, String>\n adapter(KafkaMessageListenerContainer<String, String> container) {\n KafkaMessageDrivenChannelAdapter<String, String> kafkaMessageDrivenChannelAdapter =\n new KafkaMessageDrivenChannelAdapter<>(container, ListenerMode.record);\n kafkaMessageDrivenChannelAdapter.setOutputChannel(received());\n return kafkaMessageDrivenChannelAdapter;\n}\n\n@Bean\npublic KafkaMessageListenerContainer<String, String> container() throws Exception {\n ContainerProperties properties = new ContainerProperties(this.topic);\n // set more properties\n return new KafkaMessageListenerContainer<>(consumerFactory(), properties);\n}\n\n@Bean\npublic ConsumerFactory<String, String> consumerFactory() {\n Map<String, Object> props = new HashMap<>();\n props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, this.brokerAddress);\n // set more properties\n return new DefaultKafkaConsumerFactory<>(props);\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-kafka:message-driven-channel-adapter\n id=\"kafkaListener\"\n listener-container=\"container1\"\n auto-startup=\"false\"\n phase=\"100\"\n send-timeout=\"5000\"\n mode=\"record\"\n retry-template=\"template\"\n recovery-callback=\"callback\"\n error-message-strategy=\"ems\"\n channel=\"someChannel\"\n error-channel=\"errorChannel\" />\n\n<bean id=\"container1\" class=\"org.springframework.kafka.listener.KafkaMessageListenerContainer\">\n <constructor-arg>\n <bean class=\"org.springframework.kafka.core.DefaultKafkaConsumerFactory\">\n <constructor-arg>\n <map>\n <entry key=\"bootstrap.servers\" value=\"localhost:9092\" />\n ...\n </map>\n </constructor-arg>\n </bean>\n </constructor-arg>\n <constructor-arg>\n <bean class=\"org.springframework.kafka.listener.config.ContainerProperties\">\n <constructor-arg name=\"topics\" value=\"foo\" />\n </bean>\n </constructor-arg>\n\n</bean>\n----\n======\n\nYou can also use the container factory that is used for `@KafkaListener` annotations to create `ConcurrentMessageListenerContainer` instances for other purposes.\nSee https://docs.spring.io/spring-kafka/docs/current/reference/html/[the Spring for Apache Kafka documentation] for an example.\n\nWith the Java DSL, the container does not have to be configured as a `@Bean`, because the DSL registers the container as a bean.\nThe following example shows how to do so:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow topic2ListenerFromKafkaFlow() {\n return IntegrationFlow\n .from(Kafka.messageDrivenChannelAdapter(kafkaListenerContainerFactory().createContainer(TEST_TOPIC2),\n KafkaMessageDrivenChannelAdapter.ListenerMode.record)\n .id(\"topic2Adapter\"))\n ...\n get();\n}\n----\n\nNotice that, in this case, the adapter is given an `id` (`topic2Adapter`).\nThe container is registered in the application context with a name of `topic2Adapter.container`.\nIf the adapter does not have an `id` property, the container's bean name is the container's fully qualified class name plus `#n`, where `n` is incremented for each container.\n\n[[kafka-inbound-pollable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Configuration", "heading_level": 3, "file_order": 229, "section_index": 5, "content_hash": "31916db451027816cf49d685c31aac544238706a35e1b5f0810f04ae832f6c95", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:91de342582bd765caf884793d567d0376a65f59bcf46e73b447b9034a268567d", "content": "The `KafkaMessageSource` provides a pollable channel adapter implementation.\n\n[[kafka-message-source-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Inbound Channel Adapter", "heading_level": 2, "file_order": 229, "section_index": 6, "content_hash": "91de342582bd765caf884793d567d0376a65f59bcf46e73b447b9034a268567d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:c7abe78dcf6091ddd8dd7ceeb90ec468d8c4d884bfa34500610d26a22746314c", "content": "[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow flow(ConsumerFactory<String, String> cf) {\n return IntegrationFlow.from(Kafka.inboundChannelAdapter(cf, new ConsumerProperties(\"myTopic\")),\n e -> e.poller(Pollers.fixedDelay(5000)))\n .handle(System.out::println)\n .get();\n}\n----\n\nKotlin::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun sourceFlow(cf: ConsumerFactory<String, String>) =\n integrationFlow(Kafka.inboundChannelAdapter(cf,\n ConsumerProperties(TEST_TOPIC3).also {\n it.groupId = \"kotlinMessageSourceGroup\"\n }),\n { poller(Pollers.fixedDelay(100)) }) {\n handle { m ->\n\n }\n }\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@InboundChannelAdapter(channel = \"fromKafka\", poller = @Poller(fixedDelay = \"5000\"))\n@Bean\npublic KafkaMessageSource<String, String> source(ConsumerFactory<String, String> cf) {\n ConsumerProperties consumerProperties = new ConsumerProperties(\"myTopic\");\n\tconsumerProperties.setGroupId(\"myGroupId\");\n\tconsumerProperties.setClientId(\"myClientId\");\n retunr new KafkaMessageSource<>(cf, consumerProperties);\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-kafka:inbound-channel-adapter\n id=\"adapter1\"\n consumer-factory=\"consumerFactory\"\n consumer-properties=\"consumerProperties1\"\n ack-factory=\"ackFactory\"\n channel=\"inbound\"\n message-converter=\"converter\"\n payload-type=\"java.lang.String\"\n raw-header=\"true\"\n auto-startup=\"false\">\n <int:poller fixed-delay=\"5000\"/>\n</int-kafka:inbound-channel-adapter>\n\n<bean id=\"consumerFactory\" class=\"org.springframework.kafka.core.DefaultKafkaConsumerFactory\">\n <constructor-arg>\n <map>\n <entry key=\"max.poll.records\" value=\"1\"/>\n </map>\n </constructor-arg>\n</bean>\n\n<bean id=\"consumerProperties1\" class=\"org.springframework.kafka.listener.ConsumerProperties\">\n <constructor-arg name=\"topics\" value=\"topic1\"/>\n <property name=\"groupId\" value=\"group\"/>\n <property name=\"clientId\" value=\"client\"/>\n</bean>\n----\n======\n\nRefer to the Javadocs for available properties.\n\n[[max-poll-records]]\nBy default, `max.poll.records` must be either explicitly set in the consumer factory, or it will be forced to 1 if the consumer factory is a `DefaultKafkaConsumerFactory`.\nYou can set the property `allowMultiFetch` to `true` to override this behavior.\n\nIMPORTANT: You must poll the consumer within `max.poll.interval.ms` to avoid a rebalance.\nIf you set `allowMultiFetch` to `true` you must process all the retrieved records, and poll again, within `max.poll.interval.ms`.\n\nMessages emitted by this adapter contain a header `kafka_remainingRecords` with a count of records remaining from the previous poll.\n\nStarting with version `6.2`, the `KafkaMessageSource` supports an `ErrorHandlingDeserializer` provided in the consumer properties.\nA `DeserializationException` is extracted from record headers and thrown to the called.\nWith a `SourcePollingChannelAdapter` this exception is wrapped into an `ErrorMessage` and published to its `errorChannel`.\nSee https://docs.spring.io/spring-kafka/reference/html/#error-handling-deserializer[`ErrorHandlingDeserializer`] documentation for more information.\n\n[[kafka-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Configuration", "heading_level": 3, "file_order": 229, "section_index": 7, "content_hash": "c7abe78dcf6091ddd8dd7ceeb90ec468d8c4d884bfa34500610d26a22746314c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:3254f35c031721ca5d34f5442032481b7df890fe7a77e218d3a82bfe7dee9c84", "content": "The outbound gateway is for request/reply operations.\nIt differs from most Spring Integration gateways in that the sending thread does not block in the gateway, and the reply is processed on the reply listener container thread.\nIf your code invokes the gateway behind a synchronous https://docs.spring.io/spring-integration/reference/html/messaging-endpoints-chapter.html#gateway[Messaging Gateway], the user thread blocks there until the reply is received (or a timeout occurs).\n\nThe `KafkaProducerMessageHandler` `sendTimeoutExpression` default is `delivery.timeout.ms` Kafka producer property `+ 5000` so that the actual Kafka error after a timeout is propagated to the application, instead of a timeout generated by this framework.\nThis has been changed for consistency because you may get unexpected behavior (Spring may time out the `send()`, while it is actually, eventually, successful).\nIMPORTANT: That timeout is 120 seconds by default, so you may wish to reduce it to get more timely failures.\n\n[[kafka-outbound-gateway-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Outbound Gateway", "heading_level": 2, "file_order": 229, "section_index": 8, "content_hash": "3254f35c031721ca5d34f5442032481b7df890fe7a77e218d3a82bfe7dee9c84", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:0d7bcb4e8716d8319d0013b3e422e897742f971635f02d5525ac8f6b7d0dbe88", "content": "The following example shows how to configure a gateway:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow outboundGateFlow(\n ReplyingKafkaTemplate<String, String, String> kafkaTemplate) {\n\n return IntegrationFlow.from(\"kafkaRequests\")\n .handle(Kafka.outboundGateway(kafkaTemplate))\n .channel(\"kafkaReplies\")\n .get();\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\n@ServiceActivator(inputChannel = \"kafkaRequests\", outputChannel = \"kafkaReplies\")\npublic KafkaProducerMessageHandler<String, String> outGateway(\n ReplyingKafkaTemplate<String, String, String> kafkaTemplate) {\n return new KafkaProducerMessageHandler<>(kafkaTemplate);\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-kafka:outbound-gateway\n id=\"allProps\"\n error-message-strategy=\"ems\"\n kafka-template=\"template\"\n message-key-expression=\"'key'\"\n order=\"23\"\n partition-id-expression=\"2\"\n reply-channel=\"replies\"\n reply-timeout=\"43\"\n request-channel=\"requests\"\n requires-reply=\"false\"\n send-success-channel=\"successes\"\n send-failure-channel=\"failures\"\n send-timeout-expression=\"44\"\n sync=\"true\"\n timestamp-expression=\"T(System).currentTimeMillis()\"\n topic-expression=\"'topic'\"/>\n----\n======\n\nRefer to the Javadocs for available properties.\n\nNotice that the same class as the xref:kafka.adoc#kafka-outbound[outbound channel adapter] is used, the only difference being that the `KafkaTemplate` passed into the constructor is a `ReplyingKafkaTemplate`.\nSee https://docs.spring.io/spring-kafka/docs/current/reference/html/[the Spring for Apache Kafka documentation] for more information.\n\nThe outbound topic, partition, key, and so on are determined in the same way as the outbound adapter.\nThe reply topic is determined as follows:\n\n. A message header named `KafkaHeaders.REPLY_TOPIC` (if present, it must have a `String` or `byte[]` value) is validated against the template's reply container's subscribed topics.\n. If the template's `replyContainer` is subscribed to only one topic, it is used.\n\nYou can also specify a `KafkaHeaders.REPLY_PARTITION` header to determine a specific partition to be used for replies.\nAgain, this is validated against the template's reply container's subscriptions.\n\nAlternatively, you can also use a configuration similar to the following bean:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow outboundGateFlow() {\n return IntegrationFlow.from(\"kafkaRequests\")\n .handle(Kafka.outboundGateway(producerFactory(), replyContainer())\n .configureKafkaTemplate(t -> t.replyTimeout(30_000)))\n .channel(\"kafkaReplies\")\n .get();\n}\n----\n\n[[kafka-inbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Configuration", "heading_level": 3, "file_order": 229, "section_index": 9, "content_hash": "0d7bcb4e8716d8319d0013b3e422e897742f971635f02d5525ac8f6b7d0dbe88", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:9a006856a80a0c1a555dddaa9b3ee6e05146dcf7b24b7747c8a81c6f2a41f6bf", "content": "The inbound gateway is for request/reply operations.\n\n[[kafka-inbound-gateway-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Inbound Gateway", "heading_level": 2, "file_order": 229, "section_index": 10, "content_hash": "9a006856a80a0c1a555dddaa9b3ee6e05146dcf7b24b7747c8a81c6f2a41f6bf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:eed7e7975c56c7e60f7f792af76af405decce1d9d11751ea08261d29849725d6", "content": "The following example shows how to configure an inbound gateway:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow serverGateway(\n ConcurrentMessageListenerContainer<Integer, String> container,\n KafkaTemplate<Integer, String> replyTemplate) {\n return IntegrationFlow\n .from(Kafka.inboundGateway(container, replyTemplate)\n .replyTimeout(30_000))\n .<String, String>transform(String::toUpperCase)\n .get();\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\npublic KafkaInboundGateway<Integer, String, String> inboundGateway(\n AbstractMessageListenerContainer<Integer, String>container,\n KafkaTemplate<Integer, String> replyTemplate) {\n\n KafkaInboundGateway<Integer, String, String> gateway =\n new KafkaInboundGateway<>(container, replyTemplate);\n gateway.setRequestChannel(requests);\n gateway.setReplyChannel(replies);\n gateway.setReplyTimeout(30_000);\n return gateway;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-kafka:inbound-gateway\n id=\"gateway1\"\n listener-container=\"container1\"\n kafka-template=\"template\"\n auto-startup=\"false\"\n phase=\"100\"\n request-timeout=\"5000\"\n request-channel=\"nullChannel\"\n reply-channel=\"errorChannel\"\n reply-timeout=\"43\"\n message-converter=\"messageConverter\"\n payload-type=\"java.lang.String\"\n error-message-strategy=\"ems\"\n retry-template=\"retryTemplate\"\n recovery-callback=\"recoveryCallback\"/>\n----\n======\n\nRefer to the Javadocs for available properties.\n\nWhen a `RetryTemplate` is provided, delivery failures are retried according to its retry policy.\nIf an `error-channel` is also supplied, a default `ErrorMessageSendingRecoverer` will be used as the recovery callback after retries are exhausted.\nYou can also use the `recovery-callback` to specify some other action to take in that case, or set it to `null` to throw the final exception to the listener container so it is handled there.\n\nWhen building an `ErrorMessage` (for use in the `error-channel` or `recovery-callback`), you can customize the error message by setting the `error-message-strategy` property.\nBy default, a `RawRecordHeaderErrorMessageStrategy` is used, to provide access to the converted message as well as the raw `ConsumerRecord`.\n\nIMPORTANT: This form of retry is blocking and could cause a rebalance if the aggregate retry delays across all polled records might exceed the `max.poll.interval.ms` consumer property.\nInstead, consider adding a `DefaultErrorHandler` to the listener container, configured with a `KafkaErrorSendingMessageRecoverer`.\n\nThe following example shows how to configure a simple upper case converter with the Java DSL:\n\nAlternatively, you could configure an upper-case converter by using code similar to the following:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow serverGateway() {\n return IntegrationFlow\n .from(Kafka.inboundGateway(consumerFactory(), containerProperties(),\n producerFactory())\n .replyTimeout(30_000))\n .<String, String>transform(String::toUpperCase)\n .get();\n}\n----\n\nYou can also use the container factory that is used for `@KafkaListener` annotations to create `ConcurrentMessageListenerContainer` instances for other purposes.\nSee https://docs.spring.io/spring-kafka/docs/current/reference/html/[the Spring for Apache Kafka documentation] and xref:kafka.adoc#kafka-inbound[Message-driven Channel Adapter] for examples.\n\n[[kafka-channels]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Configuration", "heading_level": 3, "file_order": 229, "section_index": 11, "content_hash": "eed7e7975c56c7e60f7f792af76af405decce1d9d11751ea08261d29849725d6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:686b9af2646bff26e0c7b26d10127bc904cc30590d684f9da330325c18669a8b", "content": "Spring Integration has `MessageChannel` implementations backed by an Apache Kafka topic for persistence.\n\nEach channel requires a `KafkaTemplate` for the sending side and either a listener container factory (for subscribable channels) or a `KafkaMessageSource` for a pollable channel.\n\n[[java-dsl-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Channels Backed by Apache Kafka Topics", "heading_level": 2, "file_order": 229, "section_index": 12, "content_hash": "686b9af2646bff26e0c7b26d10127bc904cc30590d684f9da330325c18669a8b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:a9a10dff8b14d139a5a1f5f960770d1e7aea54aa5a22687461fe7506f2eba07d", "content": "[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow flowWithSubscribable(KafkaTemplate<Integer, String> template,\n ConcurrentKafkaListenerContainerFactory<Integer, String> containerFactory) {\n\n return IntegrationFlow.from(...)\n ...\n .channel(Kafka.channel(template, containerFactory, \"someTopic1\").groupId(\"group1\"))\n ...\n .get();\n}\n\n@Bean\npublic IntegrationFlow flowWithPubSub(KafkaTemplate<Integer, String> template,\n ConcurrentKafkaListenerContainerFactory<Integer, String> containerFactory) {\n\n return IntegrationFlow.from(...)\n ...\n .publishSubscribeChannel(pubSub(template, containerFactory),\n pubsub -> pubsub\n .subscribe(subflow -> ...)\n .subscribe(subflow -> ...))\n .get();\n}\n\n@Bean\npublic BroadcastCapableChannel pubSub(KafkaTemplate<Integer, String> template,\n ConcurrentKafkaListenerContainerFactory<Integer, String> containerFactory) {\n\n return Kafka.publishSubscribeChannel(template, containerFactory, \"someTopic2\")\n .groupId(\"group2\")\n .get();\n}\n\n@Bean\npublic IntegrationFlow flowWithPollable(KafkaTemplate<Integer, String> template,\n KafkaMessageSource<Integer, String> source) {\n\n return IntegrationFlow.from(...)\n ...\n .channel(Kafka.pollableChannel(template, source, \"someTopic3\").groupId(\"group3\"))\n .handle(..., e -> e.poller(...))\n ...\n .get();\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n/**\n * Channel for a single subscriber.\n **/\n@Bean\nSubscribableKafkaChannel pointToPoint(KafkaTemplate<String, String> template,\n KafkaListenerContainerFactory<String, String> factory)\n\n SubscribableKafkaChannel channel =\n new SubscribableKafkaChannel(template, factory, \"topicA\");\n channel.setGroupId(\"group1\");\n return channel;\n}\n\n/**\n * Channel for multiple subscribers.\n **/\n@Bean\nSubscribableKafkaChannel pubsub(KafkaTemplate<String, String> template,\n KafkaListenerContainerFactory<String, String> factory)\n\n SubscribableKafkaChannel channel =\n new SubscribableKafkaChannel(template, factory, \"topicB\", true);\n channel.setGroupId(\"group2\");\n return channel;\n}\n\n/**\n * Pollable channel (topic is configured on the source)\n **/\n@Bean\nPollableKafkaChannel pollable(KafkaTemplate<String, String> template,\n KafkaMessageSource<String, String> source)\n\n PollableKafkaChannel channel =\n new PollableKafkaChannel(template, source);\n channel.setGroupId(\"group3\");\n return channel;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-kafka:channel kafka-template=\"template\" id=\"ptp\" topic=\"ptpTopic\" group-id=\"ptpGroup\"\n container-factory=\"containerFactory\" />\n\n<int-kafka:pollable-channel kafka-template=\"template\" id=\"pollable\" message-source=\"source\"\n group-id = \"pollableGroup\"/>\n\n<int-kafka:publish-subscribe-channel kafka-template=\"template\" id=\"pubSub\" topic=\"pubSubTopic\"\n group-id=\"pubSubGroup\" container-factory=\"containerFactory\" />\n----\n======\n\n[[message-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Java DSL Configuration", "heading_level": 3, "file_order": 229, "section_index": 13, "content_hash": "a9a10dff8b14d139a5a1f5f960770d1e7aea54aa5a22687461fe7506f2eba07d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:3d56a8f2186e226b2d7ff1eb646967cdd55ccc6d878b6ca4fbd3ba95b583558f", "content": "A `StringJsonMessageConverter` is provided.\nSee https://docs.spring.io/spring-kafka/docs/current/reference/html/[the Spring for Apache Kafka documentation] for more information.\n\nWhen using this converter with a message-driven channel adapter, you can specify the type to which you want the incoming payload to be converted.\nThis is achieved by setting the `payload-type` attribute (`payloadType` property) on the adapter.\nThe following example shows how to do so in XML configuration:\n\n[source, xml]\n----\n<int-kafka:message-driven-channel-adapter\n id=\"kafkaListener\"\n listener-container=\"container1\"\n auto-startup=\"false\"\n phase=\"100\"\n send-timeout=\"5000\"\n channel=\"nullChannel\"\n message-converter=\"messageConverter\"\n payload-type=\"com.example.Thing\"\n error-channel=\"errorChannel\" />\n\n<bean id=\"messageConverter\"\n class=\"org.springframework.kafka.support.converter.MessagingMessageConverter\"/>\n\n----\n\nThe following example shows how to set the `payload-type` attribute (`payloadType` property) on the adapter in Java configuration:\n\n[source, java]\n----\n@Bean\npublic KafkaMessageDrivenChannelAdapter<String, String>\n adapter(KafkaMessageListenerContainer<String, String> container) {\n KafkaMessageDrivenChannelAdapter<String, String> kafkaMessageDrivenChannelAdapter =\n new KafkaMessageDrivenChannelAdapter<>(container, ListenerMode.record);\n kafkaMessageDrivenChannelAdapter.setOutputChannel(received());\n kafkaMessageDrivenChannelAdapter.setMessageConverter(converter());\n kafkaMessageDrivenChannelAdapter.setPayloadType(Thing.class);\n return kafkaMessageDrivenChannelAdapter;\n}\n----\n\n[[kafka-tombstones]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Message Conversion", "heading_level": 2, "file_order": 229, "section_index": 14, "content_hash": "3d56a8f2186e226b2d7ff1eb646967cdd55ccc6d878b6ca4fbd3ba95b583558f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:9f331dedd0a2dd40a94b4c9ee4ace9810385615af73adc46b05d1cb524a86820", "content": "Spring Messaging `Message<?>` objects cannot have `null` payloads.\nWhen you use the endpoints for Apache Kafka, `null` payloads (also known as tombstone records) are represented by a payload of type `KafkaNull`.\nSee https://docs.spring.io/spring-kafka/docs/current/reference/html/[the Spring for Apache Kafka documentation] for more information.\n\nThe POJO methods for Spring Integration endpoints can use a true `null` value instead of `KafkaNull`.\nTo do so, mark the parameter with `@Payload(required = false)`.\nThe following example shows how to do so:\n\n[source, java]\n----\n@ServiceActivator(inputChannel = \"fromSomeKafkaInboundEndpoint\")\npublic void in(@Header(KafkaHeaders.RECEIVED_KEY) String key,\n @Payload(required = false) Customer customer) {\n // customer is null if a tombstone record\n ...\n}\n----\n\n[[streams-integration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Null Payloads and Log Compaction 'Tombstone' Records", "heading_level": 2, "file_order": 229, "section_index": 15, "content_hash": "9f331dedd0a2dd40a94b4c9ee4ace9810385615af73adc46b05d1cb524a86820", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:07aaf4d1f99a88145917d5e94e7d56436cbf04cc658eff183ef5a4a31548a7c1", "content": "You can use a `MessagingTransformer` to invoke an integration flow from a `KStream`:\n\n[source, java]\n----\n@Bean\npublic KStream<byte[], byte[]> kStream(StreamsBuilder kStreamBuilder,\n MessagingTransformer<byte[], byte[], byte[]> transformer) transformer) {\n KStream<byte[], byte[]> stream = kStreamBuilder.stream(STREAMING_TOPIC1);\n stream.mapValues((ValueMapper<byte[], byte[]>) String::toUpperCase)\n ...\n .transform(() -> transformer)\n .to(streamingTopic2);\n\n stream.print(Printed.toSysOut());\n\n return stream;\n}\n\n@Bean\n@DependsOn(\"flow\")\npublic MessagingTransformer<byte[], byte[], String> transformer(\n MessagingFunction function) {\n\n MessagingMessageConverter converter = new MessagingMessageConverter();\n converter.setHeaderMapper(new SimpleKafkaHeaderMapper(\"*\"));\n return new MessagingTransformer<>(function, converter);\n}\n\n@Bean\npublic IntegrationFlow flow() {\n return IntegrationFlow.from(MessagingFunction.class)\n ...\n .get();\n}\n----\n\nWhen an integration flow starts with an interface, the proxy that is created has the name of the flow bean, appended with \".gateway\" so this bean name can be used a `@Qualifier` if needed.\n\n[[read-process-write]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Calling a Spring Integration flow from a `KStream`", "heading_level": 2, "file_order": 229, "section_index": 16, "content_hash": "07aaf4d1f99a88145917d5e94e7d56436cbf04cc658eff183ef5a4a31548a7c1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:5f70c36f0724b3cb599d2b51479282166371f48853190ab63624685c54246665", "content": "Many applications consume from a topic, perform some processing, and write to another topic.\nIn most, cases, if the `write` fails, the application would want to throw an exception so the incoming request can be retried and/or sent to a dead letter topic.\nThis functionality is supported by the underlying message listener container, together with a suitably configured error handler.\nHowever, in order to support this, we need to block the listener thread until the success (or failure) of the write operation so that any exceptions can be thrown to the container.\nWhen consuming single records, this is achieved by setting the `sync` property on the outbound adapter.\nHowever, when consuming batches, using `sync` causes a significant performance degradation because the application would wait for the result of each sending before producing the next message.\nYou also can perform multiple sends and then wait for the results of those sending afterward.\nThis is achieved by adding a `futuresChannel` to the message handler.\nTo enable the feature add `KafkaIntegrationHeaders.FUTURE_TOKEN` to the outbound messages; this can then be used to correlate a `Future` to a particular sent message.\nHere is an example of how you might use this feature:\n\n[source, java]\n----\n@SpringBootApplication\npublic class FuturesChannelApplication {\n\n public static void main(String[] args) {\n SpringApplication.run(FuturesChannelApplication.class, args);\n }\n\n @Bean\n IntegrationFlow inbound(ConsumerFactory<String, String> consumerFactory, Handler handler) {\n return IntegrationFlow.from(Kafka.messageDrivenChannelAdapter(consumerFactory,\n ListenerMode.batch, \"inTopic\"))\n .handle(handler)\n .get();\n }\n\n @Bean\n IntegrationFlow outbound(KafkaTemplate<String, String> kafkaTemplate) {\n return IntegrationFlow.from(Gate.class)\n .enrichHeaders(h -> h\n .header(KafkaHeaders.TOPIC, \"outTopic\")\n .headerExpression(KafkaIntegrationHeaders.FUTURE_TOKEN, \"headers[id]\"))\n .handle(Kafka.outboundChannelAdapter(kafkaTemplate)\n .futuresChannel(\"futures\"))\n .get();\n }\n\n @Bean\n PollableChannel futures() {\n return new QueueChannel();\n }\n\n}\n\n@Component\n@DependsOn(\"outbound\")\nclass Handler {\n\n @Autowired\n Gate gate;\n\n @Autowired\n PollableChannel futures;\n\n public void handle(List<String> input) throws Exception {\n System.out.println(input);\n input.forEach(str -> this.gate.send(str.toUpperCase()));\n for (int i = 0; i < input.size(); i++) {\n Message<?> future = this.futures.receive(10000);\n ((Future<?>) future.getPayload()).get(10, TimeUnit.SECONDS);\n }\n }\n\n}\n\ninterface Gate {\n\n void send(String out);\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kafka.adoc", "title": "kafka", "heading": "Performance Considerations for read/process/write Scenarios", "heading_level": 2, "file_order": 229, "section_index": 17, "content_hash": "5f70c36f0724b3cb599d2b51479282166371f48853190ab63624685c54246665", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kafka.adoc"}}
{"id": "sha256:d0c950a447c52f3963c3fd713a026220e7d38053a588b9bd7635ded8fa048093", "content": "[[kotlin-dsl]]\n\nThe Kotlin DSL is a wrapper and extension to xref:dsl.adoc#java-dsl[Java DSL] and aimed to make Spring Integration development on Kotlin as smooth and straightforward as possible with interoperability with the existing Java API and Kotlin language-specific structures.\n\nAll you need to get started is just an import for `org.springframework.integration.dsl.integrationFlow` - an overloaded global function for Kotlin DSL.\n\nFor `IntegrationFlow` definitions as lambdas we typically don't need anything else from Kotlin and just declare a bean like this:\n\n[source, kotlin]\n----\n@Bean\nfun oddFlow() =\nIntegrationFlow { flow ->\n flow.handle<Any> { _, _ -> \"odd\" }\n}\n----\n\nIn this case Kotlin understands that the lambda should be translated into `IntegrationFlow` anonymous instance and target Java DSL processor parses this construction properly into Java objects.\n\nAs an alternative to the construction above and for consistency with use-cases explained below, a Kotlin-specific DSL should be used for declaring integration flows in the *builder* pattern style:\n\n[source, kotlin]\n----\n@Bean\nfun flowLambda() =\n integrationFlow {\n filter<String> { it === \"test\" }\n wireTap {\n handle { println(it.payload) }\n }\n transform<String> { it.toUpperCase() }\n }\n----\n\nSuch a global `integrationFlow()` function expects a lambda in builder style for a `KotlinIntegrationFlowDefinition` (a Kotlin wrapper for the `IntegrationFlowDefinition`) and produces a regular `IntegrationFlow` lambda implementation.\nSee more overloaded `integrationFlow()` variants below.\n\nMany other scenarios require an `IntegrationFlow` to be started from source of data (e.g. `JdbcPollingChannelAdapter`, `JmsInboundGateway` or just an existing `MessageChannel`).\nFor this purpose, the Spring Integration Java DSL provides an `IntegrationFlow` fluent API with its large number of overloaded `from()` methods.\nThis API can be used in Kotlin as well:\n\n[source, kotlin]\n----\n@Bean\nfun flowFromSupplier() =\n IntegrationFlow.fromSupplier({ \"bar\" }) { e -> e.poller { p -> p.fixedDelay(10).maxMessagesPerPoll(1) } }\n .channel { c -> c.queue(\"fromSupplierQueue\") }\n .get()\n----\n\nBut unfortunately not all `from()` methods are compatible with Kotlin structures.\nTo fix the gap, this project provides a Kotlin DSL around an `IntegrationFlow` fluent API.\nIt is implemented as a set of overloaded `integrationFlow()` functions.\nWith a consumer for a `KotlinIntegrationFlowDefinition` to declare the rest of the flow as an `IntegrationFlow` lambda to reuse the mentioned above experience and also avoid `get()` call in the end.\nFor example:\n\n[source, kotlin]\n----\n@Bean\nfun functionFlow() =\n integrationFlow<Function<String, String>>({ beanName(\"functionGateway\") }) {\n transform<String> { it.toUpperCase() }\n }\n\n@Bean\nfun messageSourceFlow() =\n integrationFlow({ \"testSource\" },\n { poller { it.fixedDelay(10).maxMessagesPerPoll(1) } }) {\n channel { queue(\"fromSupplierQueue\") }\n }\n----\n\nIn addition, Kotlin extensions are provided for the Java DSL API, which needs some refinement for Kotlin structures.\nFor example `IntegrationFlowDefinition<*>` requires a reifying for many methods with `Class<P>` argument:\n\n[source, kotlin]\n----\n@Bean\nfun convertFlow() =\n integrationFlow(\"convertFlowInput\") {\n convert<TestPojo>()\n }\n----\n\nNOTE: The reified type can be a whole `Message<*>` if there need access to headers as well in the lambda of the operator.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kotlin-dsl.adoc", "title": "kotlin-dsl", "heading": "kotlin-dsl", "heading_level": 1, "file_order": 230, "section_index": 0, "content_hash": "d0c950a447c52f3963c3fd713a026220e7d38053a588b9bd7635ded8fa048093", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kotlin-dsl.adoc"}}
{"id": "sha256:e8e222d7e471bc2a01c1caa7025d3846b737ebc7499498f7eca4e870a580243f", "content": "[[kotlin-functions-support]]\n\nThe Framework also has been improved to support Kotlin lambdas for functions, so now you can use a combination of the Kotlin language and Spring Integration flow definitions:\n\n[source, kotlin]\n----\n@Bean\n@Transformer(inputChannel = \"functionServiceChannel\")\nfun kotlinFunction(): (String) -> String {\n return { it.toUpperCase() }\n}\n\n@Bean\n@ServiceActivator(inputChannel = \"messageConsumerServiceChannel\")\nfun kotlinConsumer(): (Message<Any>) -> Unit {\n return { print(it) }\n}\n\n@Bean\n@InboundChannelAdapter(value = \"counterChannel\",\n poller = Poller(fixedRate = \"10\", maxMessagesPerPoll = \"1\"))\nfun kotlinSupplier(): () -> String {\n return { \"baz\" }\n}\n----\n\n[[kotlin-coroutines]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kotlin-functions.adoc", "title": "kotlin-functions", "heading": "kotlin-functions", "heading_level": 1, "file_order": 231, "section_index": 0, "content_hash": "e8e222d7e471bc2a01c1caa7025d3846b737ebc7499498f7eca4e870a580243f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kotlin-functions.adoc"}}
{"id": "sha256:defa530c332306c0feb27f14bbbb8511b12183b48fdf6a25f726ba28f70782b5", "content": "Starting with version 6.0, Spring Integration provides support for https://kotlinlang.org/docs/coroutines-guide.html[Kotlin Coroutines].\nNow `suspend` functions and `kotlinx.coroutines.Deferred` & `kotlinx.coroutines.flow.Flow` return types can be used for service methods:\n\n[source, kotlin]\n----\n@ServiceActivator(inputChannel = \"suspendServiceChannel\", outputChannel = \"resultChannel\")\nsuspend fun suspendServiceFunction(payload: String) = payload.uppercase()\n\n@ServiceActivator(inputChannel = \"flowServiceChannel\", outputChannel = \"resultChannel\", async = \"true\")\nfun flowServiceFunction(payload: String) =\n flow {\n for (i in 1..3) {\n emit(\"$payload #$i\")\n }\n }\n----\n\nThe framework treats them as Reactive Streams interactions and uses `ReactiveAdapterRegistry` to convert to respective `Mono` and `Flux` reactor types.\nSuch a function reply is processed then in the reply channel, if it is a `ReactiveStreamsSubscribableChannel`, or as a result of `CompletableFuture` in the respective callback.\n\nNOTE: The functions with `Flow` result are not `async` by default on the `@ServiceActivator`, so `Flow` instance is produced as a reply message payload.\nIt is the target application's responsibility to process this object as a coroutine or convert it to `Flux`, respectively.\n\nThe `@MessagingGateway` interface methods also can be marked with a `suspend` modifier when declared in Kotlin.\nThe framework utilizes the `Mono` internally to perform request-reply using the downstream flow.\nSuch a `Mono` result is processed by the `MonoKt.awaitSingleOrNull()` API internally to fulfil a `kotlin.coroutines.Continuation` argument to the called `suspend` function of the gateway:\n\n[source, kotlin]\n----\n@MessagingGateway(defaultRequestChannel = \"suspendRequestChannel\")\ninterface SuspendFunGateway {\n\n suspend fun suspendGateway(payload: String): String\n\n}\n----\n\nThis method has to be called as a coroutine according to Kotlin language requirements:\n\n[source, kotlin]\n----\n@Autowired\nprivate lateinit var suspendFunGateway: SuspendFunGateway\n\nfun someServiceMethod() {\n runBlocking {\n val reply = suspendFunGateway.suspendGateway(\"test suspend gateway\")\n }\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/kotlin-functions.adoc", "title": "kotlin-functions", "heading": "Kotlin Coroutines", "heading_level": 2, "file_order": 231, "section_index": 1, "content_hash": "defa530c332306c0feb27f14bbbb8511b12183b48fdf6a25f726ba28f70782b5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/kotlin-functions.adoc"}}
{"id": "sha256:7e9abfb8947c1bece6cdb589e153041c72474ece9370e92342d84c1cb739f867", "content": "[[leadership-event-handling]]\n\nGroups of endpoints can be started and stopped based on leadership being granted or revoked, respectively.\nThis is useful in clustered scenarios where shared resources must be consumed by only a single instance.\nAn example of this is a file inbound channel adapter that is polling a shared directory.\n(See xref:file/reading.adoc[Reading Files]).\n\nTo participate in a leader election and be notified when elected leader, when leadership is revoked, or on failure to acquire the resources to become leader, an application creates a component in the application context called a \"`leader initiator`\".\nNormally, a leader initiator is a `SmartLifecycle`, so it starts (optionally) when the context starts and then publishes notifications when leadership changes.\nYou can also receive failure notifications by setting the `publishFailedEvents` to `true` (starting with version 5.0), for cases when you want to take a specific action if a failure occurs.\nBy convention, you should provide a `Candidate` that receives the callbacks.\nYou can also revoke the leadership through a `Context` object provided by the framework.\nYour code can also listen for `o.s.i.leader.event.AbstractLeaderEvent` instances (the super class of `OnGrantedEvent` and `OnRevokedEvent`) and respond accordingly (for instance, by using a `SmartLifecycleRoleController`).\nThe events contain a reference to the `Context` object.\nThe following listing shows the definition of the `Context` interface:\n\n[source, java]\n----\npublic interface Context {\n\n\tboolean isLeader();\n\n\tvoid yield();\n\n\tString getRole();\n\n}\n----\n\nStarting with version 5.0.6, the context provides a reference to the candidate's role.\n\nSpring Integration provides a basic implementation of a leader initiator that is based on the `LockRegistry` abstraction.\nTo use it, you need to create an instance as a bean, as the following example shows:\n\n[source, java]\n----\n@Bean\npublic LockRegistryLeaderInitiator leaderInitiator(LockRegistry locks) {\n return new LockRegistryLeaderInitiator(locks);\n}\n----\n\nIf the lock registry is implemented correctly, there is only ever at most one leader.\nIf the lock registry also provides locks that throw exceptions (ideally, `InterruptedException`) when they expire or are broken, the duration of the leaderless periods can be as short as is allowed by the inherent latency in the lock implementation.\nBy default, the `busyWaitMillis` property adds some additional latency to prevent CPU starvation in the (more usual) case that the locks are imperfect, and you only know they expired when you try to obtain one again.\n\nSee xref:zookeeper.adoc#zk-leadership[Zookeeper Leadership Event Handling] for more information about leadership election and events that use Zookeeper.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/leadership-event-handling.adoc", "title": "leadership-event-handling", "heading": "leadership-event-handling", "heading_level": 1, "file_order": 232, "section_index": 0, "content_hash": "7e9abfb8947c1bece6cdb589e153041c72474ece9370e92342d84c1cb739f867", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/leadership-event-handling.adoc"}}
{"id": "sha256:8c58d46015f2e20b5cc7af2c94abd326c132a3205245261c00013d5f2d59f26d", "content": "[[logging-channel-adapter]]\n\nThe `<logging-channel-adapter>` is often used in conjunction with a wire tap, as discussed in xref:channel/configuration.adoc#channel-wiretap[Wire Tap].\nHowever, it can also be used as the ultimate consumer of any flow.\nFor example, consider a flow that ends with a `<service-activator>` that returns a result, but you wish to discard that result.\nTo do that, you could send the result to `NullChannel`.\nAlternatively, you can route it to an `INFO` level `<logging-channel-adapter>`.\nThat way, you can see the discarded message when logging at `INFO` level but not see it when logging at, for example, the `WARN` level.\nWith a `NullChannel`, you would see only the discarded message when logging at the `DEBUG` level.\nThe following listing shows all the possible attributes for the `logging-channel-adapter` element:\n\n[source, xml]\n----\n\n<int:logging-channel-adapter\n channel=\"\" <1>\n level=\"INFO\" <2>\n expression=\"\" <3>\n log-full-message=\"false\" <4>\n logger-name=\"\" /> <5>\n\n----\n\n<1> The channel connecting the logging adapter to an upstream component.\n<2> The logging level at which messages are sent to this adapter will be logged.\nDefault: `INFO`.\n<3> A SpEL expression representing exactly what parts of the message are logged.\nDefault: `payload` -- only the payload is logged.\nif `log-full-message` is specified, this attribute cannot be specified.\n<4> When `true`, the entire message (including headers) is logged.\nDefault: `false` -- only the payload is logged.\nThis attribute cannot be specified if `expression` is specified.\n<5> Specifies the `name` of the logger (known as `category` in `log4j`).\nUsed to identify log messages created by this adapter.\nThis enables setting the log name (in the logging subsystem) for individual adapters.\nBy default, all adapters log under the following name: `org.springframework.integration.handler.LoggingHandler`.\n\n[[using-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/logging-adapter.adoc", "title": "logging-adapter", "heading": "logging-adapter", "heading_level": 1, "file_order": 233, "section_index": 0, "content_hash": "8c58d46015f2e20b5cc7af2c94abd326c132a3205245261c00013d5f2d59f26d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/logging-adapter.adoc"}}
{"id": "sha256:e2feb3aa21a6030bfd344789f23643cd6eb892bd3bf1acdddb56a95469518d5f", "content": "The following Spring Boot application shows an example of configuring the `LoggingHandler` by using Java configuration:\n\n[source, java]\n----\n@SpringBootApplication\npublic class LoggingJavaApplication {\n\n public static void main(String[] args) {\n ConfigurableApplicationContext context =\n new SpringApplicationBuilder(LoggingJavaApplication.class)\n .web(false)\n .run(args);\n MyGateway gateway = context.getBean(MyGateway.class);\n gateway.sendToLogger(\"foo\");\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"logChannel\")\n public LoggingHandler logging() {\n LoggingHandler adapter = new LoggingHandler(LoggingHandler.Level.DEBUG);\n adapter.setLoggerName(\"TEST_LOGGER\");\n adapter.setLogExpressionString(\"headers.id + ': ' + payload\");\n return adapter;\n }\n\n @MessagingGateway(defaultRequestChannel = \"logChannel\")\n public interface MyGateway {\n\n void sendToLogger(String data);\n\n }\n\n}\n----\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/logging-adapter.adoc", "title": "logging-adapter", "heading": "Using Java Configuration", "heading_level": 2, "file_order": 233, "section_index": 1, "content_hash": "e2feb3aa21a6030bfd344789f23643cd6eb892bd3bf1acdddb56a95469518d5f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/logging-adapter.adoc"}}
{"id": "sha256:8f482abeeb25b2ba5c4f930ebd73ee9b72d234198277af6de5a08f4d119d3f34", "content": "The following Spring Boot application shows an example of configuring the logging channel adapter by using the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class LoggingJavaApplication {\n\n public static void main(String[] args) {\n ConfigurableApplicationContext context =\n new SpringApplicationBuilder(LoggingJavaApplication.class)\n .web(false)\n .run(args);\n MyGateway gateway = context.getBean(MyGateway.class);\n gateway.sendToLogger(\"foo\");\n }\n\n @Bean\n public IntegrationFlow loggingFlow() {\n return IntegrationFlow.from(MyGateway.class)\n .log(LoggingHandler.Level.DEBUG, \"TEST_LOGGER\",\n m -> m.getHeaders().getId() + \": \" + m.getPayload());\n }\n\n @MessagingGateway\n public interface MyGateway {\n\n void sendToLogger(String data);\n\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/logging-adapter.adoc", "title": "logging-adapter", "heading": "Configuring with the Java DSL", "heading_level": 2, "file_order": 233, "section_index": 2, "content_hash": "8f482abeeb25b2ba5c4f930ebd73ee9b72d234198277af6de5a08f4d119d3f34", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/logging-adapter.adoc"}}
{"id": "sha256:d3fd5b1a0c06fe2d5b422dc586d298d7b468a4ba8d799c6481aa36aa3421226c", "content": "[[mail]]\n\nThis section describes how to work with mail messages in Spring Integration.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-mail</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-mail:{project-version}\"\n----\n======\n\nThe `jakarta.mail:jakarta.mail-api` must be included via vendor-specific implementation.\n\n[[mail-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mail.adoc", "title": "mail", "heading": "mail", "heading_level": 1, "file_order": 234, "section_index": 0, "content_hash": "d3fd5b1a0c06fe2d5b422dc586d298d7b468a4ba8d799c6481aa36aa3421226c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mail.adoc"}}
{"id": "sha256:ddca7baa6e6d5d7397d8668f1b75ab9478d388e282a025c390d386317fa0cafc", "content": "Spring Integration provides support for outbound email with the `MailSendingMessageHandler`.\nIt delegates to a configured instance of Spring's `JavaMailSender`, as the following example shows:\n\n[source,java]\n----\n JavaMailSender mailSender = context.getBean(\"mailSender\", JavaMailSender.class);\n\n MailSendingMessageHandler mailSendingHandler = new MailSendingMessageHandler(mailSender);\n----\n\n`MailSendingMessageHandler` has various mapping strategies that use Spring's `MailMessage` abstraction.\nIf the received message's payload is already a `MailMessage` instance, it is sent directly.\nTherefore, it is generally recommended that this consumer be preceded with a transformer for non-trivial `MailMessage` construction requirements.\nHowever, Spring Integration supports a few simple message mapping strategies.\nFor example, if the message payload is a byte array, that is mapped to an attachment.\nFor simple text-based emails, a string-based message payload can be provided.\nIn that case, a `MailMessage` is created with that `String` as the text content.\nIf working with a message payload type whose `toString()` method returns appropriate mail text content, consider adding Spring Integration's `ObjectToStringTransformer` prior to the outbound mail adapter (see the example in xref:transformer.adoc#transformer-namespace[Configuring a Transformer with XML] for more detail).\n\nAnother option is to configure the outbound `MailMessage` with certain values from `MessageHeaders`.\nIf available, values are mapped to the outbound mail's properties, such as the recipients (To, Cc, and BCc), the `from`, the `reply-to`, and the `subject`.\nThe header names are defined by the following constants:\n\n[source,java]\n----\n MailHeaders.SUBJECT\n MailHeaders.TO\n MailHeaders.CC\n MailHeaders.BCC\n MailHeaders.FROM\n MailHeaders.REPLY_TO\n----\n\nNOTE: `MailHeaders` also overrides corresponding `MailMessage` values.\nFor example, if `MailMessage.to` is set to 'thing1@things.com' and the `MailHeaders.TO` message header is provided, it takes precedence and overrides the corresponding value in `MailMessage`.\n\n[[mail-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mail.adoc", "title": "mail", "heading": "Mail-sending Channel Adapter", "heading_level": 2, "file_order": 234, "section_index": 1, "content_hash": "ddca7baa6e6d5d7397d8668f1b75ab9478d388e282a025c390d386317fa0cafc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mail.adoc"}}
{"id": "sha256:ddf24bf0e6f8145c237f9a8798aa52e47304979f13fdd86531d26794c6b24702", "content": "Spring Integration also provides support for inbound email with the `MailReceivingMessageSource`.\nIt delegates to a configured instance of Spring Integration's own `MailReceiver` interface.\nThere are two implementations: `Pop3MailReceiver` and `ImapMailReceiver`.\nThe easiest way to instantiate either of these is to pass the 'uri' for a mail store to the receiver's constructor, as the following example shows:\n\n[source,java]\n----\nMailReceiver receiver = new Pop3MailReceiver(\"pop3://usr:pwd@localhost/INBOX\");\n----\n\nAnother option for receiving mail is the IMAP `idle` command (if supported by the mail server).\nSpring Integration provides the `ImapIdleChannelAdapter`, which is itself a message-producing endpoint.\nIt delegates to an instance of the `ImapMailReceiver`.\nThe next section has examples of configuring both types of inbound channel adapter with Spring Integration's namespace support in the 'mail' schema.\n\n[[imap-format-important]]\n[IMPORTANT]\n====\nNormally, when the `IMAPMessage.getContent()` method is called, certain headers as well as the body are rendered (for a simple text email), as the following example shows:\n\n[source]\n----\nTo: thing1@things.com\nFrom: thing2@morethings.com\nSubject: Test Email\n\nsomething\n----\nWith a simple `MimeMessage`, `getContent()` returns the mail body (`something` in the preceding example).\n====\n\nStarting with version 2.2, the framework eagerly fetches IMAP messages and exposes them as an internal subclass of `MimeMessage`.\nThis had the undesired side effect of changing the `getContent()` behavior.\nThis inconsistency was further exacerbated by the xref:mail.adoc#mail-mapping[Mail Mapping] enhancement introduced in version 4.3, because, when a header mapper was provided, the payload was rendered by the `IMAPMessage.getContent()` method.\nThis meant that the IMAP content differed, depending on whether a header mapper was provided.\n\nStarting with version 5.0, messages originating from an IMAP source render the content in accordance with `IMAPMessage.getContent()` behavior, regardless of whether a header mapper is provided.\nIf not using a header mapper, and wishing to revert to the previous behavior of rendering only the body, set the `simpleContent` boolean property on the mail receiver to `true`.\nThis property now controls the rendering regardless of whether a header mapper is used.\nIt now allows body-only rendering when a header mapper is provided.\n\nStarting with version 5.2, the `autoCloseFolder` option is provided on the mail receiver.\nSetting it to `false` doesn't close the folder automatically after a fetch, but instead an `IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE` header (see xref:message.adoc#message-header-accessor[`MessageHeaderAccessor` API] for more information) is populated into every message produced from the channel adapter.\nThis does not work with `Pop3MailReceiver` as it relies on opening and closing the folder to get new messages.\nIt is the target application's responsibility to call the `close()` on this header whenever it is necessary in the downstream flow:\n\n[source,java]\n----\nCloseable closeableResource = StaticMessageHeaderAccessor.getCloseableResource(mailMessage);\nif (closeableResource != null) {\n closeableResource.close();\n}\n----\n\nKeeping the folder open is useful in cases where communication with the server is needed during parsing multipart content of the email with attachments.\nThe `close()` on the `IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE` header delegates to the `AbstractMailReceiver` to close the folder with `expunge` option if `shouldDeleteMessages` is configured respectively on the `AbstractMailReceiver`.\n\nStarting with version 5.4, it is possible now to return a `MimeMessage` as is without any conversion or eager content loading.\nThis functionality is enabled with this combination of options: no `headerMapper` provided, the `simpleContent` property is `false` and the `autoCloseFolder` property is `false`.\nThe `MimeMessage` is present as the payload of the Spring message produced.\nIn this case, the only header populated is the mentioned above `IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE` for the folder which must be closed when processing of the `MimeMessage` is complete.\n\nStarting with version 5.5.11, the folder is closed automatically after `AbstractMailReceiver.receive()` if no messages received or all of them are filtered out independently of the `autoCloseFolder` flag.\nIn this case there is nothing to produce downstream for possible logic around `IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE` header.\n\nStarting with version 6.0.5, the `ImapIdleChannelAdapter` no longer performs asynchronous message publishing.\nThis is necessary to block the idle listener loop for message processing downstream (e.g., with big attachments) because the mail folder must remain open.\nIf an async hand-off is required, an `ExecutorChannel` can be used as the output channel of this channel adapter.\n\n[[mail-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mail.adoc", "title": "mail", "heading": "Mail-receiving Channel Adapter", "heading_level": 2, "file_order": 234, "section_index": 2, "content_hash": "ddf24bf0e6f8145c237f9a8798aa52e47304979f13fdd86531d26794c6b24702", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mail.adoc"}}
{"id": "sha256:a0d350081b120c15cef8ed031bd5b7bc15474df071109e714eed4b7becdabecf", "content": "By default, the payload of messages produced by the inbound adapters is the raw `MimeMessage`.\nOptionally, that object can be used to interrogate the headers and content.\nStarting with version 4.3, a `HeaderMapper<MimeMessage>` can be provided to map the headers to `MessageHeaders`.\nFor convenience, Spring Integration provides a `DefaultMailHeaderMapper` for this purpose.\nIt maps the following headers:\n\n* `mail_from`: A `String` representation of the `from` address.\n* `mail_bcc`: A `String` array containing the `bcc` addresses.\n* `mail_cc`: A `String` array containing the `cc` addresses.\n* `mail_to`: A `String` array containing the `to` addresses.\n* `mail_replyTo`: A `String` representation of the `replyTo` address.\n* `mail_subject`: The mail subject.\n* `mail_lineCount`: A line count (if available).\n* `mail_receivedDate`: The received date (if available).\n* `mail_size`: The mail size (if available).\n* `mail_expunged`: A boolean indicating if the message is expunged.\n* `mail_raw`: A `MultiValueMap` containing all the mail headers and their values.\n* `mail_contentType`: The content type of the original mail message.\n* `contentType`: The payload content type.\n\nWhen message mapping is enabled, the payload depends on the mail message and its implementation.\nEmail contents are usually rendered by a `DataHandler` within the `MimeMessage`.\n\nFor a `text/*` email, the payload is a `String` and the `contentType` header is the same as `mail_contentType`.\n\nFor a message with embedded `jakarta.mail.Part` instances, the `DataHandler` usually renders a `Part` object.\nThese objects are not `Serializable` and are not suitable for serialization with alternative technologies such as `Kryo`.\nFor this reason, by default, when mapping is enabled, such payloads are rendered as a raw `byte[]` containing the `Part` data.\nExamples of `Part` are `Message` and `Multipart`.\nThe `contentType` header is `application/octet-stream` in this case.\nTo change this behavior and receive a `Multipart` object payload, set `embeddedPartsAsBytes` to `false` on `MailReceiver`.\nFor content types that are unknown to the `DataHandler`, the contents are rendered as a `byte[]` with a `contentType` header of `application/octet-stream`.\n\nWhen a header mapper is not provided, the message payload is the `MimeMessage` presented by `jakarta.mail`.\nThe framework provides a `MailToStringTransformer` that can be used to convert the message by using a strategy to convert the mail contents to a `String`:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\n@Transformer(inputChannel=\"...\", outputChannel=\"...\")\npublic Transformer transformer() {\n return new MailToStringTransformer();\n}\n----\n\nJava DSL::\n+\n[source, java, role=\"secondary\"]\n----\n ...\n .transform(Mail.toStringTransformer())\n ...\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n ...\n transform(Mail.toStringTransformer())\n ...\n----\n\nGroovy DSL::\n+\n[source, groovy, role=\"secondary\"]\n----\n ...\n transform(Mail.toStringTransformer())\n ...\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-mail:mail-to-string-transformer ... >\n----\n======\n\nStarting with version 4.3, the transformer handles embedded `Part` instances (as well as `Multipart` instances, which were handled previously).\nThe transformer is a subclass of `AbstractMailTransformer` that maps the address and subject headers from the preceding list.\nWhen performing some other transformation on the message, consider subclassing `AbstractMailTransformer`.\n\nStarting with version 5.4, when no `headerMapper` is provided, `autoCloseFolder` is `false` and `simpleContent` is `false`, the `MimeMessage` is returned as-is in the payload of the Spring message produced.\nThis way, the content of the `MimeMessage` is loaded on demand when referenced, later in the flow.\nAll the mentioned above transformations are still valid.\n\n[[mail-xml-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mail.adoc", "title": "mail", "heading": "Inbound Mail Message Mapping", "heading_level": 2, "file_order": 234, "section_index": 3, "content_hash": "a0d350081b120c15cef8ed031bd5b7bc15474df071109e714eed4b7becdabecf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mail.adoc"}}
{"id": "sha256:f4a3d7bf9ccf9796c95f417bab940507f9be9320933097f295602f0552e9fe0e", "content": "Spring Integration provides a namespace for mail-related configuration.\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int-mail=\"http://www.springframework.org/schema/integration/mail\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration/mail\n https://www.springframework.org/schema/integration/mail/spring-integration-mail.xsd\">\n----\n\n[[configuring-outbound-channel-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mail.adoc", "title": "mail", "heading": "Mail Xml Namespace", "heading_level": 2, "file_order": 234, "section_index": 4, "content_hash": "f4a3d7bf9ccf9796c95f417bab940507f9be9320933097f295602f0552e9fe0e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mail.adoc"}}
{"id": "sha256:911d166fb7d5d65afae21be237d257e2b2b835219ffdd97ab95a33bc9f878233", "content": "To configure an outbound channel adapter, provide the channel from which to receive and the `MailSender`, as the following example shows:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JavaMailSender mailSender() {\n JavaMailSenderImpl mailSender = new JavaMailSenderImpl();\n mailSender.setHost(\"somehost\");\n mailSender.setUsername(\"someuser\");\n mailSender.setPassword(\"somepassword\");\n Properties javaMailProperties = new Properties();\n javaMailProperties.put(\"mail.smtp.starttls.enable\", \"true\");\n mailSender.setJavaMailProperties(javaMailProperties);\n return mailSender;\n}\n\n@Bean\n@ServiceActivator(inputChannel = \"outboundMail\")\npublic MessageHandler outboundMailMessageHandler(JavaMailSender mailSender) {\n return new MailSendingMessageHandler(mailSender);\n}\n----\nJava DSL::\n+\n[source,java,role=\"secondary\"]\n----\n@Bean\npublic JavaMailSender mailSender() {\n JavaMailSenderImpl mailSender = new JavaMailSenderImpl();\n mailSender.setHost(\"somehost\");\n mailSender.setUsername(\"someuser\");\n mailSender.setPassword(\"somepassword\");\n Properties javaMailProperties = new Properties();\n javaMailProperties.put(\"mail.smtp.starttls.enable\", \"true\");\n mailSender.setJavaMailProperties(javaMailProperties);\n return mailSender;\n}\n\n@Bean\npublic IntegrationFlow mailOutboundFlow(MessageChannel outboundMail, JavaMailSender mailSender) {\n return IntegrationFlow.from(outboundMail)\n .handle(Mail.outboundAdapter(mailSender))\n .get();\n}\n----\nKotlin DSL::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun mailSender(): JavaMailSender =\n JavaMailSenderImpl().apply {\n host = \"somehost\"\n username = \"someuser\"\n password = \"somepassword\"\n javaMailProperties = Properties().apply {\n put(\"mail.smtp.starttls.enable\", \"true\")\n }\n}\n\n@Bean\nfun mailOutboundFlow(outboundMail: MessageChannel, mailSender: JavaMailSender) =\n integrationFlow(outboundMail) {\n handle(Mail.outboundAdapter(mailSender))\n }\n----\nGroovy DSL::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\nmailSender() {\n new JavaMailSenderImpl().with {\n host = \"somehost\"\n username = \"someuser\"\n password = \"somepassword\"\n javaMailProperties = ['mail.smtp.starttls.enable': 'true']\n it\n }\n}\n\n@Bean\nmailOutboundFlow(MessageChannel outboundMail, JavaMailSender mailSender) {\n integrationFlow(outboundMail) {\n handle(Mail.outboundAdapter(mailSender))\n }\n}\n----\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<bean id=\"mailSender\" class=\"org.springframework.mail.javamail.JavaMailSenderImpl\">\n <property name=\"host\" value=\"somehost\"/>\n <property name=\"username\" value=\"someuser\"/>\n <property name=\"password\" value=\"somepassword\"/>\n <property name=\"javaMailProperties\">\n <props>\n <prop key=\"mail.smtp.starttls.enable\">true</prop>\n </props>\n </property>\n </bean>\n<int-mail:outbound-channel-adapter channel=\"outboundMail\"\n mail-sender=\"mailSender\"/>\n----\n======\n\nAlternatively, the mail sender can be configured directly with host credentials:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic JavaMailSender mailSender() {\n JavaMailSenderImpl mailSender = new JavaMailSenderImpl();\n mailSender.setHost(\"somehost\");\n mailSender.setUsername(\"someuser\");\n mailSender.setPassword(\"somepassword\");\n return mailSender;\n}\n\n@Bean\n@ServiceActivator(inputChannel = \"outboundMail\")\npublic MessageHandler outboundMailMessageHandler(JavaMailSender mailSender) {\n return new MailSendingMessageHandler(mailSender);\n}\n----\nJava DSL::\n+\n[source,java,role=\"secondary\"]\n----\n@Bean\npublic IntegrationFlow mailOutboundFlow(MessageChannel outboundMail) {\n return IntegrationFlow.from(outboundMail)\n .handle(Mail.outboundAdapter(\"somehost\")\n .credentials(\"someuser\", \"somepassword\")\n .javaMailProperties(p -> p.put(\"mail.smtp.starttls.enable\", \"true\")))\n .get();\n}\n----\nKotlin DSL::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun mailOutboundFlow(outboundMail: MessageChannel) = integrationFlow(outboundMail) {\n handle(Mail.outboundAdapter(\"somehost\")\n .credentials(\"someuser\", \"somepassword\")\n .javaMailProperties { p -> p.put(\"mail.smtp.starttls.enable\", \"true\") })\n}\n----\nGroovy DSL::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\nmailOutboundFlow(MessageChannel outboundMail) {\n integrationFlow(outboundMail) {\n handle(Mail.outboundAdapter(\"somehost\").with {\n credentials(\"someuser\", \"somepassword\")\n javaMailProperties { p -> p.put('mail.smtp.starttls.enable', 'true') }\n })\n }\n}\n----\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<int-mail:outbound-channel-adapter channel=\"outboundMail\"\n host=\"somehost\" username=\"someuser\" password=\"somepassword\"/>\n----\n======\n\nStarting with version 5.1.3, the `host`, `username` and `mail-sender` can be omitted, if `java-mail-properties` is provided.\nHowever, the `host` and `username` have to be configured with appropriate Java mail properties, e.g., for SMTP:\n\n[source]\n----\nmail.user=someuser@gmail.com\nmail.smtp.host=smtp.gmail.com\nmail.smtp.port=587\n----\n\nNOTE: As with any outbound Channel Adapter, if the referenced channel is a `PollableChannel`, provide a `<poller>` element (see xref:endpoint.adoc#endpoint-namespace[Endpoint Namespace Support]).\n\nOptionally a `header-enricher` message transformer can be used.\nDoing so simplifies the application of the headers mentioned earlier to any message prior to sending to the mail outbound channel adapter.\n\nThe following example assumes the payload is a Java bean with appropriate getters for the specified properties; optionally any SpEL expression can be used:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\n@Transformer(inputChannel = \"expressionsInput\", outputChannel = \"outboundMail\")\npublic Transformer headerEnricher() {\n Map<String, ExpressionEvaluatingHeaderValueMessageProcessor<String>> headerMap = new HashMap<>();\n ExpressionParser parser = new SpelExpressionParser();\n\n headerMap.put(MailHeaders.TO, new ExpressionEvaluatingHeaderValueMessageProcessor<>(\n parser.parseExpression(\"payload.to\"), String.class));\n headerMap.put(MailHeaders.CC, new ExpressionEvaluatingHeaderValueMessageProcessor<>(\n parser.parseExpression(\"payload.cc\"), String.class));\n headerMap.put(MailHeaders.BCC, new ExpressionEvaluatingHeaderValueMessageProcessor<>(\n parser.parseExpression(\"payload.bcc\"), String.class));\n headerMap.put(MailHeaders.REPLY_TO, new ExpressionEvaluatingHeaderValueMessageProcessor<>(\n parser.parseExpression(\"payload.replyTo\"), String.class));\n headerMap.put(MailHeaders.FROM, new ExpressionEvaluatingHeaderValueMessageProcessor<>(\n parser.parseExpression(\"payload.from\"), String.class));\n headerMap.put(MailHeaders.SUBJECT, new ExpressionEvaluatingHeaderValueMessageProcessor<>(\n parser.parseExpression(\"payload.subject\"), String.class));\n\n return new HeaderEnricher(headerMap);\n}\n----\nJava DSL::\n+\n[source,java,role=\"secondary\"]\n----\n@Bean\npublic IntegrationFlow mailOutboundFlow(MessageChannel outboundMail) {\n return IntegrationFlow.from(outboundMail)\n .enrichHeaders(h -> h.headerExpression(MailHeaders.TO, \"payload.to\")\n .headerExpression(MailHeaders.CC, \"payload.cc\")\n .headerExpression(MailHeaders.BCC, \"payload.bcc\")\n .headerExpression(MailHeaders.REPLY_TO, \"payload.replyTo\")\n .headerExpression(MailHeaders.FROM, \"payload.from\")\n .headerExpression(MailHeaders.SUBJECT, \"payload.subject\"))\n .get();\n}\n----\nKotlin DSL::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun mailOutboundFlow(outboundMail: MessageChannel) = integrationFlow(outboundMail) {\n enrichHeaders {\n headerExpression(MailHeaders.TO, \"payload.to\")\n headerExpression(MailHeaders.CC, \"payload.cc\")\n headerExpression(MailHeaders.BCC, \"payload.bcc\")\n headerExpression(MailHeaders.REPLY_TO, \"payload.replyTo\")\n headerExpression(MailHeaders.FROM, \"payload.from\")\n headerExpression(MailHeaders.SUBJECT, \"payload.subject\")\n }\n}\n----\nGroovy DSL::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\nmailOutboundFlow(MessageChannel outboundMail) {\n integrationFlow(outboundMail) {\n enrichHeaders {\n headerExpression(MailHeaders.TO, 'payload.to')\n headerExpression(MailHeaders.CC, 'payload.cc')\n headerExpression(MailHeaders.BCC, 'payload.bcc')\n headerExpression(MailHeaders.REPLY_TO, 'payload.replyTo')\n headerExpression(MailHeaders.FROM, 'payload.from')\n headerExpression(MailHeaders.SUBJECT, 'payload.subject')\n }\n }\n}\n----\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<int-mail:header-enricher input-channel=\"expressionsInput\" default-overwrite=\"false\">\n\t<int-mail:to expression=\"payload.to\"/>\n\t<int-mail:cc expression=\"payload.cc\"/>\n\t<int-mail:bcc expression=\"payload.bcc\"/>\n\t<int-mail:from expression=\"payload.from\"/>\n\t<int-mail:reply-to expression=\"payload.replyTo\"/>\n\t<int-mail:subject expression=\"payload.subject\" overwrite=\"true\"/>\n</int-mail:header-enricher>\n----\n======\n\nAlternatively, a `value` attribute can be used to specify a literal.\nAnother option is to specify `default-overwrite` and individual `overwrite` attributes to control the behavior with existing headers.\n\n[[configuring-inbound-channel-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mail.adoc", "title": "mail", "heading": "Configuring Outbound Channel Adapters", "heading_level": 2, "file_order": 234, "section_index": 5, "content_hash": "911d166fb7d5d65afae21be237d257e2b2b835219ffdd97ab95a33bc9f878233", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mail.adoc"}}
{"id": "sha256:6585fcee7506e8b3eee53f1a1e1557ef6387e9e9159fd0754598e722ac900f72", "content": "When configuring an inbound channel adapter, choose between polling or event-driven (assuming the mail server supports IMAP `idle` -- if not, then polling is the only option).\nA polling channel adapter requires the store URI and the channel to which to send inbound messages.\nThe URI may begin with `pop3` or `imap`.\nThe following example uses an `imap` URI:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\n@InboundChannelAdapter(value = \"receiveChannel\", poller = @Poller(fixedDelay = \"5000\"))\npublic MailReceivingMessageSource mailMessageSource(ImapMailReceiver imapMailReceiver) {\n return new MailReceivingMessageSource(imapMailReceiver);\n}\n\n@Bean\npublic ImapMailReceiver imapMailReceiver(Properties javaMailProperties) {\n ImapMailReceiver receiver = new ImapMailReceiver(\"imaps://[username]:[password]@imap.gmail.com/INBOX\");\n receiver.setShouldDeleteMessages(true);\n receiver.setShouldMarkMessagesAsRead(true);\n receiver.setMaxFetchSize(1);\n receiver.setJavaMailProperties(javaMailProperties);\n\n return receiver;\n}\n\n----\nJava DSL::\n+\n[source,java,role=\"secondary\"]\n----\n@Bean\npublic IntegrationFlow imapMailInboundFlow(Properties javaMailProperties, MessageChannel receiveChannel) {\n return IntegrationFlow\n .from(Mail.imapInboundAdapter(\"imaps://[username]:[password]@imap.gmail.com/INBOX\")\n .shouldDeleteMessages(true)\n .shouldMarkMessagesAsRead(true)\n .javaMailProperties(javaMailProperties)\n .maxFetchSize(1),\n e -> e.poller(Pollers.fixedRate(5000)))\n .channel(receiveChannel)\n .get();\n}\n----\nKotlin DSL::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun imapMailInboundFlow(javaMailProperties: Properties, receiveChannel: MessageChannel) =\n integrationFlow(\n Mail.imapInboundAdapter(\"imaps://[username]:[password]@imap.gmail.com/INBOX\")\n .shouldDeleteMessages(true)\n .shouldMarkMessagesAsRead(true)\n .javaMailProperties(javaMailProperties)\n .maxFetchSize(1),\n { poller { it.fixedRate(5000) } }\n ) {\n channel(receiveChannel)\n }\n----\nGroovy DSL::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\nimapMailInboundFlow(Properties javaMailProps, MessageChannel receiveChannel) {\n integrationFlow(\n Mail.imapInboundAdapter(\"imaps://[username]:[password]@imap.gmail.com/INBOX\").with {\n shouldMarkMessagesAsRead true\n shouldDeleteMessages true\n id 'groovyImapIdleAdapter'\n javaMailProperties javaMailProps\n maxFetchSize 1\n }, { e -> e.poller(Pollers.fixedRate(5000)) }\n ) {\n channel receiveChannel\n }\n}\n----\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<int-mail:inbound-channel-adapter id=\"imapAdapter\"\n store-uri=\"imaps://[username]:[password]@imap.gmail.com/INBOX\"\n java-mail-properties=\"javaMailProperties\"\n channel=\"receiveChannel\"\n should-delete-messages=\"true\"\n should-mark-messages-as-read=\"true\"\n auto-startup=\"true\">\n <int:poller max-messages-per-poll=\"1\" fixed-rate=\"5000\"/>\n</int-mail:inbound-channel-adapter>\n----\n======\n\nIf there is IMAP `idle` support, optionally configure the `imap-idle-channel-adapter` element instead.\nSince the `idle` command enables event-driven notifications, no poller is necessary for this adapter.\nIt sends a message to the specified channel as soon as it receives the notification that new mail is available.\nThe following example configures an IMAP `idle` mail channel:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ImapMailReceiver imapMailReceiver(Properties javaMailProperties) {\n ImapMailReceiver receiver = new ImapMailReceiver(\"imaps://[username]:[password]@imap.gmail.com/INBOX\");\n receiver.setShouldDeleteMessages(false);\n receiver.setShouldMarkMessagesAsRead(true);\n receiver.setJavaMailProperties(javaMailProperties);\n return receiver;\n}\n@Bean\npublic ImapIdleChannelAdapter imapIdleChannelAdapter(ImapMailReceiver imapMailReceiver, MessageChannel receiveChannel) {\n ImapIdleChannelAdapter adapter = new ImapIdleChannelAdapter(imapMailReceiver);\n adapter.setOutputChannel(receiveChannel);\n adapter.setAutoStartup(true);\n adapter.setPhase(Integer.MAX_VALUE);\n return adapter;\n}\n----\nJava DSL::\n+\n[source,java,role=\"secondary\"]\n----\n@Bean\npublic IntegrationFlow imapIdleFlow(MessageChannel receiveChannel, MailMessageHandler mailMessageHandler,\n Properties javaMailProperties) {\n\n\treturn IntegrationFlow\n .from(Mail.imapIdleAdapter(\"imaps://[username]:[password]@imap.gmail.com/INBOX\")\n .shouldDeleteMessages(false)\n .shouldMarkMessagesAsRead(true)\n .javaMailProperties(javaMailProperties)\n .autoStartup(true)\n .id(\"imapIdleAdapter\"))\n .channel(receiveChannel)\n .get();\n}\n\n----\nKotlin DSL::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun imapIdleFlow(receiveChannel: MessageChannel, javaMailProperties: Properties) =\n\n integrationFlow(\n Mail.imapIdleAdapter(\"imaps://[username]:[password]@imap.gmail.com/INBOX\").apply {\n shouldDeleteMessages(false)\n shouldMarkMessagesAsRead(true)\n javaMailProperties(javaMailProperties)\n autoStartup(true)\n id(\"kotlinImapIdleAdapter\")\n }\n ) {\n channel(receiveChannel)\n }\n----\nGroovy DSL::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\nimapIdleFlow(MessageChannel receiveChannel, Properties javaMailProps) {\n\n integrationFlow(\n Mail.imapIdleAdapter(\"imaps://[username]:[password]@imap.gmail.com/INBOX\").with {\n shouldMarkMessagesAsRead false\n shouldDeleteMessages true\n javaMailProperties javaMailProps\n autoStartup true\n id 'groovyImapIdleAdapter'\n }\n ) {\n channel receiveChannel\n }\n}\n----\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<int-mail:imap-idle-channel-adapter id=\"customAdapter\"\n store-uri=\"imaps://[username]:[password]@imap.gmail.com/INBOX\"\n channel=\"receiveChannel\"\n auto-startup=\"true\"\n should-delete-messages=\"false\"\n should-mark-messages-as-read=\"true\"\n java-mail-properties=\"javaMailProperties\"/>\n----\n======\n\n`javaMailProperties` can be provided by creating and populating a regular `java.util.Properties` object -- for example, by using the `util` namespace provided by Spring.\n\nIMPORTANT: If a username contains the `@` character, use `%40` instead of `@` to avoid parsing errors from the underlying JavaMail API.\n\nThe following example shows how to configure a `java.util.Properties` object:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic Properties javaMailProperties() {\n Properties props = new Properties();\n props.setProperty(\"mail.imaps.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\");\n props.setProperty(\"mail.imaps.socketFactory.fallback\", \"false\");\n props.setProperty(\"mail.store.protocol\", \"imaps\");\n return props;\n}\n\n----\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun javaMailProperties(): Properties = Properties().apply {\n this[\"mail.imaps.socketFactory.class\"] = \"javax.net.ssl.SSLSocketFactory\"\n this[\"mail.imaps.socketFactory.fallback\"] = \"false\"\n this[\"mail.store.protocol\"] = \"imaps\"\n}\n----\nGroovy::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\njavaMailProperties() {\n new Properties([\n 'mail.imaps.socketFactory.class' : 'javax.net.ssl.SSLSocketFactory',\n 'mail.imaps.socketFactory.fallback': 'false',\n 'mail.store.protocol' : 'imaps'\n ])\n}\n----\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<util:properties id=\"javaMailProperties\">\n <prop key=\"mail.imap.socketFactory.class\">javax.net.ssl.SSLSocketFactory</prop>\n <prop key=\"mail.imap.socketFactory.fallback\">false</prop>\n <prop key=\"mail.store.protocol\">imaps</prop>\n <prop key=\"mail.debug\">false</prop>\n</util:properties>\n----\n======\n\n[[search-term]]\nBy default, the `ImapMailReceiver` searches for messages based on the default `SearchTerm`, which is all mail messages that:\n\n* Are RECENT (if supported)\n* Are NOT ANSWERED\n* Are NOT DELETED\n* Are NOT SEEN\n* Have not been processed by this mail receiver (enabled by the use of the custom USER flag or simply NOT FLAGGED if not supported)\n\nThe custom user flag is `spring-integration-mail-adapter`, but is configurable.\nSince version 2.2, the `SearchTerm` used by the `ImapMailReceiver` is fully configurable with `SearchTermStrategy`, which can be injected by using the `search-term-strategy` attribute.\nA `SearchTermStrategy` is a strategy interface with a single method that creates an instance of the `SearchTerm` used by the `ImapMailReceiver`.\nThe following listing shows the `SearchTermStrategy` interface:\n\n[source,java]\n----\npublic interface SearchTermStrategy {\n\n SearchTerm generateSearchTerm(Flags supportedFlags, Folder folder);\n\n}\n----\n\nThe following example relies on `TestSearchTermStrategy` rather than the default `SearchTermStrategy`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ImapMailReceiver imapMailReceiver(SearchTermStrategy searchTermStrategy) {\n ImapMailReceiver receiver = new ImapMailReceiver(\"imap:something\");\n // ...\n receiver.setSearchTermStrategy(searchTermStrategy);\n return receiver;\n}\n\n@Bean\nSearchTermStrategy searchTermStrategy() {\n return new TestSearchTermStrategy();\n}\n----\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun imapIdleFlow(searchTermStrategy: SearchTermStrategy) =\n integrationFlow(\n Mail.imapIdleAdapter(\"imap:something\").apply {\n // ...\n searchTermStrategy(searchTermStrategy)\n // ...\n }\n )\n\n@Bean fun searchTermStrategy(): SearchTermStrategy {\n return TestSearchTermStrategy()\n}\n----\nGroovy::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\nimapIdleFlow(SearchTermStrategy searchStrategy) {\n integrationFlow(\n Mail.imapIdleAdapter(\"imap:something\").with {\n // ...\n searchTermStrategy searchStrategy\n // ...\n }\n )\n}\n\n@Bean\nSearchTermStrategy searchTermStrategy() {\n new TestSearchTermStrategy()\n}\n----\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<mail:imap-idle-channel-adapter id=\"customAdapter\"\n store-uri=\"imap:something\"\n \n search-term-strategy=\"searchTermStrategy\"/>\n\n<bean id=\"searchTermStrategy\"\n class=\"o.s.i.mail.config.ImapIdleChannelAdapterParserTests.TestSearchTermStrategy\"/>\n----\n======\nSee xref:mail.adoc#imap-seen[Marking IMAP Messages When `Recent` Is Not Supported] for information about message flagging.\n\n[[imap-peek]]\n[IMPORTANT]\n.Important: IMAP PEEK\n=====\nStarting with version 4.1.1, the IMAP mail receiver uses the `mail.imap.peek` or `mail.imaps.peek` JavaMail property, if specified.\nPreviously, the receiver ignored the property and always set the `PEEK` flag.\nExplicitly setting this property to `false`, the message is marked as `\\Seen` regardless of the setting of `shouldMarkMessagesRead`.\nIf not specified, the previous behavior is retained (peek is `true`).\n=====\n\n[[imap-idle-and-lost-connections]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mail.adoc", "title": "mail", "heading": "Configuring Inbound Channel Adapters", "heading_level": 2, "file_order": 234, "section_index": 6, "content_hash": "6585fcee7506e8b3eee53f1a1e1557ef6387e9e9159fd0754598e722ac900f72", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mail.adoc"}}
{"id": "sha256:c99e9c0725672fc4ac0e97d86cde8eddc0afd445ffb85db0c0f7b01d7b6e2177", "content": "When using an IMAP `idle` channel adapter, connections to the server may be lost, (for example, through network failure), it is important to understand the JavaMail API and how to deal with them when configuring IMAP `idle` adapters.\nSpring Integration mail adapters were tested with JavaMail 2.0.2.\nPay special attention to some JavaMail properties that need to be set with regard to auto-reconnect.\n\nIMPORTANT: In both configurations, `channel` and `should-delete-messages` are required attributes.\nUnderstand why `should-delete-messages` is a requirement.\nThe issue is with the POP3 protocol, which does not have any knowledge of messages that were read.\nIt can only know what has been read within a single session.\nThis means that, when the POP3 mail adapter runs, emails are successfully consumed as they become available during each poll and no single email message is delivered more than once.\nHowever, as soon as the adapter is restarted and begins a new session, all the email messages that might have been retrieved in the previous session are retrieved again.\nThat is the nature of POP3.\nSome might argue that `should-delete-messages` should be `true` by default.\nIn other words, there are two valid and mutually exclusive uses that make it hard to pick the single best default.\nWhen configuring the adapter as the only email receiver, restart it without fear that previously delivered messages are not delivered again.\nIn this case, setting `should-delete-messages` to `true` would make the most sense.\nHowever, another use case is to have multiple adapters monitor email servers and their content.\nIn other words, 'peek but not touch'.\nThen setting `should-delete-messages` to `false` is much more appropriate.\nSo since it is hard to choose what should be the right default value for the `should-delete-messages` attribute, it is a required attribute to be set.\nThis approach reduces the likelihood of unintended behavior.\n\nNOTE: When configuring a polling email adapter's `should-mark-messages-as-read` attribute, be aware of the protocol that is being configured to retrieve messages.\nFor example, POP3 does not support this flag, which means setting it to either value has no effect, as messages are not marked as read.\n\nIn the case of a silently dropped connection, an idle cancel task is run in the background periodically (a new IDLE will usually immediately be processed).\nTo control this interval, a `cancelIdleInterval` option is provided; default 120 (2 minutes).\nRFC 2177 recommends an interval no larger than 29 minutes.\n\n[IMPORTANT]\n=====\nUnderstand that these actions (marking messages read and deleting messages) are performed after the messages are received but before they are processed.\nThis can cause messages to be lost.\n\nAlso consider using transaction synchronization instead.\nSee xref:mail.adoc#mail-tx-sync[Transaction Synchronization].\n=====\n\nThe `<imap-idle-channel-adapter/>` also accepts the 'error-channel' attribute.\nIf a downstream exception is thrown and an 'error-channel' is specified, a `MessagingException` message containing the failed message and the original exception is sent to this channel.\nOtherwise, if the downstream channels are synchronous, any such exception is logged as a warning by the channel adapter.\n\nNOTE: Beginning with the 3.0 release, the IMAP `idle` adapter emits application events (specifically `ImapIdleExceptionEvent` instances) when exceptions occur.\nThis allows applications to detect and act on those exceptions.\nEvents can be obtained by using an `<int-event:inbound-channel-adapter>` or any `ApplicationListener` configured to receive an `ImapIdleExceptionEvent` or one of its super classes.\n\n[[imap-seen]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mail.adoc", "title": "mail", "heading": "IMAP `idle` and Lost Connections", "heading_level": 3, "file_order": 234, "section_index": 7, "content_hash": "c99e9c0725672fc4ac0e97d86cde8eddc0afd445ffb85db0c0f7b01d7b6e2177", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mail.adoc"}}
{"id": "sha256:ac5586858db73c47ef3b1f8c1f488df59bcbf99d3f0c2ccc0ea23cbf27ad69c2", "content": "If `shouldMarkMessagesAsRead` is true, the IMAP adapters set the `\\Seen` flag.\n\nIn addition, when an email server does not support the `\\Recent` flag, the IMAP adapters mark messages with a user flag (by default, `spring-integration-mail-adapter`), as long as the server supports user flags.\nIf not, `Flag.FLAGGED` is set to `true`.\nThese flags are applied regardless of the `shouldMarkMessagesRead` setting.\nHowever, starting with version 6.4, the `\\Flagged` can be disabled, too.\nThe `AbstractMailReceiver` exposes a `setFlaggedAsFallback(boolean flaggedAsFallback)` option to skip setting `\\Flagged`.\nIn some scenarios such a flag on the message in mailbox is not desirable, regardless `\\Recent` or a user flag is not supported as well.\n\nAs discussed in xref:mail.adoc#search-term[`SearchTerm`], the default `SearchTermStrategy` ignores messages that are so flagged.\n\nStarting with version 4.2.2, the name of the user flag can be set by using `setUserFlag` on the `MailReceiver`.\nDoing so lets multiple receivers use a different flag (as long as the mail server supports user flags).\nThe `user-flag` attribute is available when configuring the adapter with the namespace.\n\n[[mail-filtering]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mail.adoc", "title": "mail", "heading": "Marking IMAP Messages When `\\Recent` Is Not Supported", "heading_level": 2, "file_order": 234, "section_index": 8, "content_hash": "ac5586858db73c47ef3b1f8c1f488df59bcbf99d3f0c2ccc0ea23cbf27ad69c2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mail.adoc"}}
{"id": "sha256:92aef1c761312d6f12acfa92727b0931990576432cee0c4767d19eaaa65b84ee", "content": "When encountering a requirement to filter incoming messages, (for example, a requirement to read emails only that have 'Spring Integration' in the `Subject` line).\nThis can be accomplished by connecting an inbound mail adapter with an expression-based `Filter`.\nAlthough it would work, there is a downside to this approach.\nSince messages would be filtered after going through the inbound mail adapter, all such messages would be marked as read (`SEEN`) or unread (depending on the value of `should-mark-messages-as-read` attribute).\nHowever, in reality, it is more useful to mark messages as `SEEN` only if they pass the filtering criteria.\nThis is similar to looking at the email client while scrolling through all the messages in the preview pane, but only flagging messages that were actually opened and read as `SEEN`.\n\nSpring Integration 2.0.4 introduced the `mail-filter-expression` attribute on `inbound-channel-adapter` and `imap-idle-channel-adapter`.\nThis attribute accepts an expression that is a combination of SpEL and a regular expression.\nFor example, to read-only emails that contain 'Spring Integration' in the subject line, configure the `mail-filter-expression` attribute like as follows: `mail-filter-expression=\"subject matches '(?i).\\*Spring Integration.*\"`.\n\nWith `jakarta.mail.internet.MimeMessage` as the root context of the SpEL evaluation context, any value available through `MimeMessage` can be filtered on, including the actual body of the message.\nThis one is particularly important, since reading the body of the message typically results in such messages being marked as `SEEN` by default.\nHowever, since the `PEEK` flag is now set for every incoming message to 'true', only messages that were explicitly marked as `SEEN` are marked as read.\n\nSo, in the following example, only messages that match the filter expression are output by this adapter and only those messages are marked as read:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\npublic ImapMailReceiver imapMailReceiver(Properties javaMailProps) {\n ImapMailReceiver receiver = new ImapMailReceiver(\"imaps://some_google_address:${password}@imap.gmail.com/INBOX\");\n receiver.setShouldDeleteMessages(false);\n receiver.setShouldMarkMessagesAsRead(true);\n ExpressionParser parser = new SpelExpressionParser();\n receiver.setSelectorExpression(parser.parseExpression(\"subject matches '(?i).*Spring Integration.*'\"));\n\treceiver.setJavaMailProperties(javaMailProps);\n return receiver;\n}\n----\nKotlin::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun imapMailReceiver(javaMailProps: Properties) =\n ImapMailReceiver(\"imaps://[username]:[password]@imap.gmail.com/INBOX\").apply {\n setShouldDeleteMessages(false)\n setShouldMarkMessagesAsRead(true)\n setJavaMailProperties(javaMailProps)\n setSelectorExpression(SpelExpressionParser().parseExpression(\"subject matches '(?i).*Spring Integration.*'\"))\n }\n----\nGroovy::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\nimapMailReceiver(Properties javaMailProps) {\n new ImapMailReceiver(\"imaps://[username]:[password]@imap.gmail.com/INBOX\").with {\n shouldDeleteMessages = false\n shouldMarkMessagesAsRead = true\n javaMailProperties = javaMailProps\n selectorExpression = new SpelExpressionParser().parseExpression(\"subject matches '(?i).*Spring Integration.*'\")\n }\n}\n----\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<int-mail:imap-idle-channel-adapter id=\"customAdapter\"\n\tstore-uri=\"imaps://some_google_address:${password}@imap.gmail.com/INBOX\"\n\tchannel=\"receiveChannel\"\n\tshould-mark-messages-as-read=\"true\"\n\tjava-mail-properties=\"javaMailProperties\"\n\tmail-filter-expression=\"subject matches '(?i).*Spring Integration.*'\"/>\n----\n======\n\nIn the preceding example, thanks to the `mail-filter-expression` attribute, only messages that contain 'Spring Integration' in the subject line are produced by this adapter.\n\nAnother reasonable question is what happens on the next poll or idle event or what happens when such an adapter is restarted.\nCan there be duplication of messages to be filtered? In other words, if, on the last retrieval where there were five new messages and only one passed the filter, what happens with the other four?\nWould they go through the filtering logic again on the next poll or idle?\nAfter all, they were not marked as `SEEN`.\nThe answer is no.\nThey would not be subject to duplicate processing due to another flag (`RECENT`) that is set by the email server and is used by the Spring Integration mail search filter.\nFolder implementations set this flag to indicate that this message is new to this folder.\nThat is, it has arrived since the last time this folder was opened.\nIn other words, while our adapter may peek at the email, it also lets the email server know that such email was touched and should therefore be marked as `RECENT` by the email server.\n\n[[mail-tx-sync]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mail.adoc", "title": "mail", "heading": "Email Message Filtering", "heading_level": 2, "file_order": 234, "section_index": 9, "content_hash": "92aef1c761312d6f12acfa92727b0931990576432cee0c4767d19eaaa65b84ee", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mail.adoc"}}
{"id": "sha256:b6e17fc629a4fb0a4429a00a88a78786a40cb73823df8213be2789dd885ced16", "content": "Transaction synchronization for inbound adapters enables different actions after a transaction commits or rolls back.\nTransaction synchronization is enabled by adding a `<transactional/>` element to the poller for the polled `<inbound-adapter/>` or to the `<imap-idle-inbound-adapter/>` when using XML schema.\nEven if there is no 'real' transaction involved, this feature can still be enabled by using a `PseudoTransactionManager` with the `<transactional/>` element.\nWhen using Java configuration, the transaction synchronization can be established by using the `transactionSynchronizationFactory(transactionSynchronizationFactory)` method on the `PollerMetadata` or via the DSL.\nFor more information, see xref:transactions.adoc#transaction-synchronization[Transaction Synchronization].\n\nBecause of the different mail servers and specifically the limitations that some have, at this time a strategy is provided for these transaction synchronizations.\nMessages can be sent to other Spring Integration components, or a custom bean can be invoked to perform some action.\nFor example, to move an IMAP message to a different folder after the transaction commits, an option could be to use something similar to the following:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=\"primary\"]\n----\n@Bean\nTransactionSynchronizationFactory transactionSynchronizationFactory() {\n SpelExpressionParser parser = new SpelExpressionParser();\n ExpressionEvaluatingTransactionSynchronizationProcessor expressionEvaluatingTransactionSynchronizationProcessor =\n new ExpressionEvaluatingTransactionSynchronizationProcessor();\n expressionEvaluatingTransactionSynchronizationProcessor.setAfterCommitExpression(parser.parseExpression(\"@syncProcessor.process(payload)\"));\n return new DefaultTransactionSynchronizationFactory(expressionEvaluatingTransactionSynchronizationProcessor);\n}\n\n@Bean\npublic ImapIdleChannelAdapter imapIdleChannelAdapter(ImapMailReceiver imapMailReceiver, MessageChannel receiveChannel,\nTransactionSynchronizationFactory transactionSynchronizationFactory) {\n\n ImapIdleChannelAdapter adapter = new ImapIdleChannelAdapter(imapMailReceiver);\n adapter.setOutputChannel(receiveChannel);\n adapter.setAutoStartup(true);\n adapter.setTransactionSynchronizationFactory(transactionSynchronizationFactory);\n return adapter;\n}\n\n@Bean\npublic Mover syncProcessor() {\n return new Mover();\n}\n----\nJava DSL::\n+\n[source,java,role=\"secondary\"]\n----\n\n@Bean\nTransactionSynchronizationFactory transactionSynchronizationFactory() {\n SpelExpressionParser parser = new SpelExpressionParser();\n ExpressionEvaluatingTransactionSynchronizationProcessor expressionEvaluatingTransactionSynchronizationProcessor =\n new ExpressionEvaluatingTransactionSynchronizationProcessor();\n expressionEvaluatingTransactionSynchronizationProcessor.setAfterCommitExpression(parser.parseExpression(\"@syncProcessor.process(payload)\"));\n return new DefaultTransactionSynchronizationFactory(expressionEvaluatingTransactionSynchronizationProcessor);\n}\n\n@Bean\npublic IntegrationFlow imapIdleFlow(ImapMailReceiver imapMailReceiver, MessageChannel receiveChannel,\n TransactionSynchronizationFactory transactionSynchronizationFactory) {\n\treturn IntegrationFlow\n .from(Mail.imapIdleAdapter(imapMailReceiver)\n .shouldDeleteMessages(false)\n .autoStartup(true)\n .id(\"imapIdleAdapter\")\n .transactionSynchronizationFactory(transactionSynchronizationFactory))\n .channel(receiveChannel)\n .get();\n}\n\n@Bean\npublic Mover syncProcessor() {\n return new Mover();\n}\n----\nKotlin DSL::\n+\n[source,kotlin,role=\"secondary\"]\n----\n@Bean\nfun transactionSynchronizationFactory() =\n DefaultTransactionSynchronizationFactory(ExpressionEvaluatingTransactionSynchronizationProcessor().apply {\n setAfterCommitExpression(SpelExpressionParser().parseExpression(\"@syncProcessor.process(payload)\"))\n })\n\n@Bean\nfun imapIdleFlow(receiveChannel: MessageChannel, javaMailProperties: Properties,\n transactionSynchronizationFactory: TransactionSynchronizationFactory) =\n integrationFlow(\n Mail.imapIdleAdapter(\"imaps://[username]:[password]@imap.gmail.com/INBOX\").apply {\n shouldDeleteMessages(false)\n javaMailProperties(javaMailProperties)\n autoStartup(true)\n id(\"kotlinImapIdleAdapter\")\n transactionSynchronizationFactory(transactionSynchronizationFactory)\n }\n ) {\n channel(receiveChannel)\n }\n\n@Bean\nfun syncProcessor() =\n Mover()\n----\nGroovy DSL::\n+\n[source,groovy,role=\"secondary\"]\n----\n@Bean\ntransactionSynchronizationFactory() {\n new DefaultTransactionSynchronizationFactory(\n new ExpressionEvaluatingTransactionSynchronizationProcessor().with {\n afterCommitExpression = new SpelExpressionParser().parseExpression(\"@syncProcessor.process(payload)\")\n it\n }\n )\n}\n\n@Bean\nimapIdleFlow(MessageChannel receiveChannel, TransactionSynchronizationFactory tranSyncFactory,\n Properties javaMailProps) {\n integrationFlow(\n Mail.imapIdleAdapter(\"imaps://[username]:[password]@imap.gmail.com/INBOX\").with {\n shouldDeleteMessages false\n javaMailProperties javaMailProps\n autoStartup true\n id 'groovyImapIdleAdapter'\n transactionSynchronizationFactory tranSyncFactory\n }\n ) {\n channel receiveChannel\n }\n}\n\n@Bean\nsyncProcessor() {\n Mover()\n}\n----\nXML::\n+\n[source,xml,role=\"secondary\"]\n----\n<int-mail:imap-idle-channel-adapter id=\"customAdapter\"\n store-uri=\"imaps://something.com:password@imap.something.com/INBOX\"\n channel=\"receiveChannel\"\n auto-startup=\"true\"\n should-delete-messages=\"false\"\n java-mail-properties=\"javaMailProperties\">\n <int:transactional synchronization-factory=\"syncFactory\"/>\n</int-mail:imap-idle-channel-adapter>\n\n<int:transaction-synchronization-factory id=\"syncFactory\">\n <int:after-commit expression=\"@syncProcessor.process(payload)\"/>\n</int:transaction-synchronization-factory>\n\n<bean id=\"syncProcessor\" class=\"thing1.thing2.Mover\"/>\n----\n======\nThe following example shows what the `Mover` class might look like:\n\n[source,java]\n----\npublic class Mover {\n\n public void process(MimeMessage message) throws Exception {\n Folder folder = message.getFolder();\n folder.open(Folder.READ_WRITE);\n String messageId = message.getMessageID();\n Message[] messages = folder.getMessages();\n FetchProfile contentsProfile = new FetchProfile();\n contentsProfile.add(FetchProfile.Item.ENVELOPE);\n contentsProfile.add(FetchProfile.Item.CONTENT_INFO);\n contentsProfile.add(FetchProfile.Item.FLAGS);\n folder.fetch(messages, contentsProfile);\n // find this message and mark for deletion\n for (int i = 0; i < messages.length; i++) {\n if (((MimeMessage) messages[i]).getMessageID().equals(messageId)) {\n messages[i].setFlag(Flags.Flag.DELETED, true);\n break;\n }\n }\n\n Folder somethingFolder = store.getFolder(\"SOMETHING\");\n somethingFolder.appendMessages(new MimeMessage[]{message});\n folder.expunge();\n folder.close(true);\n somethingFolder.close(false);\n }\n}\n----\n\nIMPORTANT: For the message to be still available for manipulation after the transaction, _should-delete-messages_ must be set to 'false'.\n\n[[mail-java-dsl-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mail.adoc", "title": "mail", "heading": "Transaction Synchronization", "heading_level": 2, "file_order": 234, "section_index": 10, "content_hash": "b6e17fc629a4fb0a4429a00a88a78786a40cb73823df8213be2789dd885ced16", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mail.adoc"}}
{"id": "sha256:81446a87a1f220c10bd2c7b8ad865e967b19b9ab8c8dc2a125c625ae45c9f884", "content": "To configure a mail component in Java DSL, the framework provides a `o.s.i.mail.dsl.Mail` factory, which can be used like this:\n\n[source, java]\n----\n@SpringBootApplication\npublic class MailApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(MailApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public IntegrationFlow imapMailFlow() {\n return IntegrationFlow\n .from(Mail.imapInboundAdapter(\"imap://user:pw@host:port/INBOX\")\n .searchTermStrategy(this::fromAndNotSeenTerm)\n .userFlag(\"testSIUserFlag\")\n .simpleContent(true)\n .javaMailProperties(p -> p.put(\"mail.debug\", \"false\")),\n e -> e.autoStartup(true)\n .poller(p -> p.fixedDelay(1000)))\n .channel(MessageChannels.queue(\"imapChannel\"))\n .get();\n }\n\n @Bean\n public IntegrationFlow sendMailFlow() {\n return IntegrationFlow.from(\"sendMailChannel\")\n .enrichHeaders(Mail.headers()\n .subjectFunction(m -> \"foo\")\n .from(\"foo@bar\")\n .toFunction(m -> new String[] { \"bar@baz\" }))\n .handle(Mail.outboundAdapter(\"gmail\")\n .port(smtpServer.getPort())\n .credentials(\"user\", \"pw\")\n .protocol(\"smtp\"),\n e -> e.id(\"sendMailEndpoint\"))\n .get();\n }\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mail.adoc", "title": "mail", "heading": "Configuring channel adapters with the Java DSL", "heading_level": 2, "file_order": 234, "section_index": 11, "content_hash": "81446a87a1f220c10bd2c7b8ad865e967b19b9ab8c8dc2a125c625ae45c9f884", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mail.adoc"}}
{"id": "sha256:11cc397fae627df0c0a5d140120ec6eb2a413e9891899acd32819c056fe95cf1", "content": "[[message-history]]\n\nThe key benefit of a messaging architecture is loose coupling such that participating components do not maintain any awareness about one another.\nThis fact alone makes an application extremely flexible, letting you change components without affecting the rest of the flow, change messaging routes, change message consuming styles (polling versus event driven), and so on.\nHowever, this unassuming style of architecture could prove to be difficult when things go wrong.\nWhen debugging, you probably want as much information (its origin, the channels it has traversed, and other details) about the message as you can get.\n\nMessage history is one of those patterns that helps by giving you an option to maintain some level of awareness of a message path either for debugging purposes or for maintaining an audit trail.\nSpring integration provides a simple way to configure your message flows to maintain the message history by adding a header to the message and updating that header every time a message passes through a tracked component.\n\n[[message-history-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-history.adoc", "title": "message-history", "heading": "message-history", "heading_level": 1, "file_order": 235, "section_index": 0, "content_hash": "11cc397fae627df0c0a5d140120ec6eb2a413e9891899acd32819c056fe95cf1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-history.adoc"}}
{"id": "sha256:c47b78f3c7c170b732eef358760e26c080a35dc9991ca785295c14241306d5b7", "content": "To enable message history, you need only define the `message-history` element (or `@EnableMessageHistory`) in your configuration, as shown in the following example:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Configuration\n@EnableIntegration\n@EnableMessageHistory\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:message-history/>\n----\n======\n\nNow every named component (that has an 'id' defined) is tracked.\nThe framework sets the 'history' header in your message.\nIts value a `List<Properties>`.\n\nConsider the following configuration example:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@MessagingGateway(defaultRequestChannel = \"bridgeInChannel\")\npublic interface SampleGateway {\n ...\n}\n\n@Bean\n@Transformer(inputChannel = \"enricherChannel\", outputChannel=\"filterChannel\")\nHeaderEnricher sampleEnricher() {\n HeaderEnricher enricher =\n new HeaderEnricher(Collections.singletonMap(\"baz\", new StaticHeaderValueMessageProcessor(\"baz\")));\n return enricher;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:gateway id=\"sampleGateway\"\n service-interface=\"org.springframework.integration.history.sample.SampleGateway\"\n default-request-channel=\"bridgeInChannel\"/>\n\n<int:header-enricher id=\"sampleEnricher\" input-channel=\"enricherChannel\" output-channel=\"filterChannel\">\n <int:header name=\"baz\" value=\"baz\"/>\n</int:header-enricher>\n----\n======\n\nThe preceding configuration produces a simple message history structure, with output similar to the following:\n\n[source]\n----\n[{name=sampleGateway, type=gateway, timestamp=1283281668091},\n {name=sampleEnricher, type=header-enricher, timestamp=1283281668094}]\n----\n\nTo get access to message history, you need only access the `MessageHistory` header.\nThe following example shows how to do so:\n\n[source,java]\n----\nIterator<Properties> historyIterator =\n message.getHeaders().get(MessageHistory.HEADER_NAME, MessageHistory.class).iterator();\nassertTrue(historyIterator.hasNext());\nProperties gatewayHistory = historyIterator.next();\nassertEquals(\"sampleGateway\", gatewayHistory.get(\"name\"));\nassertTrue(historyIterator.hasNext());\nProperties chainHistory = historyIterator.next();\nassertEquals(\"sampleChain\", chainHistory.get(\"name\"));\n----\n\nYou might not want to track all the components.\nTo limit the history to certain components based on their names, you can provide the `tracked-components` attribute and specify a comma-delimited list of component names and patterns that match the components you want to track.\nThe following example shows how to do so:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Configuration\n@EnableIntegration\n@EnableMessageHistory(\"*Gateway\", \"sample*\", \"aName\")\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:message-history tracked-components=\"*Gateway, sample*, aName\"/>\n----\n======\n\nIn the preceding example, message history is maintained only for the components that end with 'Gateway', start with 'sample', or match the name, 'aName', exactly.\n\nIn addition, the `MessageHistoryConfigurer` bean is now exposed as a JMX MBean by the `IntegrationMBeanExporter` (see xref:jmx.adoc#jmx-mbean-exporter[MBean Exporter]), letting you change the patterns at runtime.\nNote, however, that the bean must be stopped (turning off message history) in order to change the patterns.\nThis feature might be useful to temporarily turn on history to analyze a system.\nThe MBean's object name is `<domain>:name=messageHistoryConfigurer,type=MessageHistoryConfigurer`.\n\nIMPORTANT: Only one `@EnableMessageHistory` (or `<message-history/>`) must be declared in the application context as a single source for components tracking configuration.\nDo not use a generic bean definition for the `MessageHistoryConfigurer`.\n\nNOTE: Prior to version 6.3, the message history header was immutable (you cannot re-write history): every single track created not only new instance of the `MessageHistory`, but a fully new message copy.\nNow it works in append-only mode: the first track creates a new message with a new `MessageHistory` container.\nAll the rest `MessageHistory.write()` calls add new entries to existing header - and no new message created.\nThis significantly improves the application performance.\nAll the components in the framework, where the same message can be sent to several consumers (`PublishSubscribeChannel`, `AbstractMessageRouter`, `WireTap` etc.), or splitter produces several outputs based on the input message, are now cloning an existing `MessageHistory` header into those new messages.\nFor any other multi-producing use-cases, outside the framework scope, the `AbstractIntegrationMessageBuilder.cloneMessageHistoryIfAny()` API is recommended to ensure that parallel downstream sub-flows contribute their own message history traces.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-history.adoc", "title": "message-history", "heading": "Message History Configuration", "heading_level": 2, "file_order": 235, "section_index": 1, "content_hash": "c47b78f3c7c170b732eef358760e26c080a35dc9991ca785295c14241306d5b7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-history.adoc"}}
{"id": "sha256:1e75302f428f5da19596fabd833ad0ebb5105dee6184b0332f9dd5f98d1c20d4", "content": "[[message-publishing]]\n\nThe (Aspect-oriented Programming) AOP message publishing feature lets you construct and send a message as a by-product of a method invocation.\nFor example, imagine you have a component and, every time the state of this component changes, you want to be notified by a message.\nThe easiest way to send such notifications is to send a message to a dedicated channel, but how would you connect the method invocation that changes the state of the object to a message sending process, and how should the notification message be structured?\nThe AOP message publishing feature handles these responsibilities with a configuration-driven approach.\n\n[[message-publishing-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-publishing.adoc", "title": "message-publishing", "heading": "message-publishing", "heading_level": 1, "file_order": 236, "section_index": 0, "content_hash": "1e75302f428f5da19596fabd833ad0ebb5105dee6184b0332f9dd5f98d1c20d4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-publishing.adoc"}}
{"id": "sha256:ef5d6a4cbdae177aff788254fe5cc52bc53c13624928f9976af3c11c431eb3ef", "content": "Spring Integration provides two approaches: XML configuration and annotation-driven (Java) configuration.\n\n[[publisher-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-publishing.adoc", "title": "message-publishing", "heading": "Message Publishing Configuration", "heading_level": 2, "file_order": 236, "section_index": 1, "content_hash": "ef5d6a4cbdae177aff788254fe5cc52bc53c13624928f9976af3c11c431eb3ef", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-publishing.adoc"}}
{"id": "sha256:3a13a5a5e45c24b80bc54c5e4b706ee6cb360d0a0a8e55f9c505db5a454f1b4a", "content": "The annotation-driven approach lets you annotate any method with the `@Publisher` annotation to specify a 'channel' attribute.\nStarting with version 5.1, to switch this functionality on, you must use the `@EnablePublisher` annotation on some `@Configuration` class.\nSee xref:overview.adoc#configuration-enable-integration[Configuration and `@EnableIntegration`] for more information.\nThe message is constructed from the return value of the method invocation and sent to the channel specified by the 'channel' attribute.\nTo further manage message structure, you can also use a combination of both `@Payload` and `@Header` annotations.\n\nInternally, this message publishing feature of Spring Integration uses both Spring AOP by defining `PublisherAnnotationAdvisor` and the Spring Expression Language (SpEL), giving you considerable flexibility and control over the structure of the `Message` it publishes.\n\nThe `PublisherAnnotationAdvisor` defines and binds the following variables:\n\n* `#return`: Binds to a return value, letting you reference it or its attributes (for example, `#return.something`, where 'something' is an attribute of the object bound to `#return`)\n* `#exception`: Binds to an exception if one is thrown by the method invocation\n* `#args`: Binds to method arguments so that you can extract individual arguments by name (for example, `#args.fname`)\n\nConsider the following example:\n\n[source,java]\n----\n@Publisher\npublic String defaultPayload(String fname, String lname) {\n return fname + \" \" + lname;\n}\n----\n\nIn the preceding example, the message is constructed with the following structure:\n\n* The message payload is the return type and value of the method.\nThis is the default.\n* A newly constructed message is sent to a default publisher channel that is configured with an annotation post processor (covered later in this section).\n\nThe following example is the same as the preceding example, except that it does not use a default publishing channel:\n\n[source,java]\n----\n@Publisher(channel=\"testChannel\")\npublic String defaultPayload(String fname, @Header(\"last\") String lname) {\n return fname + \" \" + lname;\n}\n----\n\nInstead of using a default publishing channel, we specify the publishing channel by setting the 'channel' attribute of the `@Publisher` annotation.\nWe also add a `@Header` annotation, which results in the message header named 'last' having the same value as the 'lname' method parameter.\nThat header is added to the newly constructed message.\n\nThe following example is almost identical to the preceding example:\n\n[source,java]\n----\n@Publisher(channel=\"testChannel\")\n@Payload\npublic String defaultPayloadButExplicitAnnotation(String fname, @Header String lname) {\n return fname + \" \" + lname;\n}\n----\n\nThe only difference is that we use a `@Payload` annotation on the method to explicitly specify that the return value of the method should be used as the payload of the message.\n\nThe following example expands on the previous configuration by using the Spring Expression Language in the `@Payload` annotation to further instruct the framework about how the message should be constructed:\n\n[source,java]\n----\n@Publisher(channel=\"testChannel\")\n@Payload(\"#return + #args.lname\")\npublic String setName(String fname, String lname, @Header(\"x\") int num) {\n return fname + \" \" + lname;\n}\n----\n\nIn the preceding example, the message is a concatenation of the return value of the method invocation and the 'lname' input argument.\nThe Message header named 'x' has its value determined by the 'num' input argument.\nThat header is added to the newly constructed message.\n\n[source,java]\n----\n@Publisher(channel=\"testChannel\")\npublic String argumentAsPayload(@Payload String fname, @Header String lname) {\n return fname + \" \" + lname;\n}\n----\n\nIn the preceding example, you see another usage of the `@Payload` annotation.\nHere, we annotate a method argument that becomes the payload of the newly constructed message.\n\nAs with most other annotation-driven features in Spring, you need to register a post-processor (`PublisherAnnotationBeanPostProcessor`).\nThe following example shows how to do so:\n\n[source,xml]\n----\n<bean class=\"org.springframework.integration.aop.PublisherAnnotationBeanPostProcessor\"/>\n----\n\nFor a more concise configuration, you can instead use namespace support, as the following example shows:\n\n[source,xml]\n----\n<int:annotation-config>\n <int:enable-publisher default-publisher-channel=\"defaultChannel\"/>\n</int:annotation-config>\n----\n\nFor Java configuration, you must use the `@EnablePublisher` annotation, as the following example shows:\n\n[source,java]\n----\n@Configuration\n@EnableIntegration\n@EnablePublisher(\"defaultChannel\")\npublic class IntegrationConfiguration {\n ...\n}\n----\n\nStarting with version 5.1.3, the `<int:enable-publisher>` component, as well as the `@EnablePublisher` annotation have the `proxy-target-class` and `order` attributes for tuning the `ProxyFactory` configuration.\n\nSimilar to other Spring annotations (`@Component`, `@Scheduled`, and so on), you can also use `@Publisher` as a meta-annotation.\nThis means that you can define your own annotations that are treated in the same way as the `@Publisher` itself.\nThe following example shows how to do so:\n\n[source,java]\n----\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Publisher(channel=\"auditChannel\")\npublic @interface Audit {\n...\n}\n----\n\nIn the preceding example, we define the `@Audit` annotation, which is itself annotated with `@Publisher`.\nAlso note that you can define a `channel` attribute on the meta-annotation to encapsulate where messages are sent inside of this annotation.\nNow you can annotate any method with the `@Audit` annotation, as the following example shows:\n\n[source,java]\n----\n@Audit\npublic String test() {\n return \"Hello\";\n}\n----\n\nIn the preceding example, every invocation of the `test()` method results in a message with a payload created from its return value.\nEach message is sent to the channel named `auditChannel`.\nOne of the benefits of this technique is that you can avoid the duplication of the same channel name across multiple annotations.\nYou also can provide a level of indirection between your own, potentially domain-specific, annotations and those provided by the framework.\n\nYou can also annotate the class, which lets you apply the properties of this annotation on every public method of that class, as the following example shows:\n\n[source,java]\n----\n@Audit\nstatic class BankingOperationsImpl implements BankingOperations {\n\n public String debit(String amount) {\n . . .\n\n }\n\n public String credit(String amount) {\n . . .\n }\n\n}\n----\n\n[[aop-based-interceptor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-publishing.adoc", "title": "message-publishing", "heading": "Annotation-driven Configuration with the `@Publisher` Annotation", "heading_level": 3, "file_order": 236, "section_index": 2, "content_hash": "3a13a5a5e45c24b80bc54c5e4b706ee6cb360d0a0a8e55f9c505db5a454f1b4a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-publishing.adoc"}}
{"id": "sha256:a234217d7645c9b6b29a017b1c381a74c050a4e27c9285dddb43cf6342e58ffd", "content": "The XML-based approach lets you configure the same AOP-based message publishing functionality as a namespace-based configuration of a `MessagePublishingInterceptor`.\nIt certainly has some benefits over the annotation-driven approach, since it lets you use AOP pointcut expressions, thus possibly intercepting multiple methods at once or intercepting and publishing methods to which you do not have the source code.\n\nTo configure message publishing with XML, you need only do the following two things:\n\n* Provide configuration for `MessagePublishingInterceptor` by using the `<publishing-interceptor>` XML element.\n* Provide AOP configuration to apply the `MessagePublishingInterceptor` to managed objects.\n\nThe following example shows how to configure a `publishing-interceptor` element:\n\n[source,xml]\n----\n<aop:config>\n <aop:advisor advice-ref=\"interceptor\" pointcut=\"bean(testBean)\" />\n</aop:config>\n<publishing-interceptor id=\"interceptor\" default-channel=\"defaultChannel\">\n <method pattern=\"echo\" payload=\"'Echoing: ' + #return\" channel=\"echoChannel\">\n <header name=\"things\" value=\"something\"/>\n </method>\n <method pattern=\"repl*\" payload=\"'Echoing: ' + #return\" channel=\"echoChannel\">\n <header name=\"things\" expression=\"'something'.toUpperCase()\"/>\n </method>\n <method pattern=\"echoDef*\" payload=\"#return\"/>\n</publishing-interceptor>\n----\n\nThe `<publishing-interceptor>` configuration looks rather similar to the annotation-based approach, and it also uses the power of the Spring Expression Language.\n\nIn the preceding example, the execution of the `echo` method of a `testBean` renders a `Message` with the following structure:\n\n* The `Message` payload is of type `String` with the following content: `Echoing: [value]`, where `value` is the value returned by an executed method.\n* The `Message` has a header with a name of `things` and a value of `something`.\n* The `Message` is sent to `echoChannel`.\n\nThe second method is very similar to the first.\nHere, every method that begins with 'repl' renders a `Message` with the following structure:\n\n* The `Message` payload is the same as in the preceding sample.\n* The `Message` has a header named `things` whose value is the result of the SpEL expression `'something'.toUpperCase()`.\n* The `Message` is sent to `echoChannel`.\n\nThe second method, mapping the execution of any method that begins with `echoDef`, produces a `Message` with the following structure:\n\n* The `Message` payload is the value returned by an executed method.\n* Since the `channel` attribute is not provided, the `Message` is sent to the `defaultChannel` defined by the `publisher`.\n\nFor simple mapping rules you can rely on the `publisher` defaults, as the following example shows:\n\n[source,xml]\n----\n\n<publishing-interceptor id=\"anotherInterceptor\"/>\n\n----\n\nThe preceding example maps the return value of every method that matches the pointcut expression to a payload and is sent to a `default-channel`.\nIf you do not specify the `defaultChannel` (as the preceding example does not do), the messages are sent to the global `nullChannel` (the equivalent of `/dev/null`).\n\n[[asynchronous-publishing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-publishing.adoc", "title": "message-publishing", "heading": "XML-based Approach with the `<publishing-interceptor>` element", "heading_level": 3, "file_order": 236, "section_index": 3, "content_hash": "a234217d7645c9b6b29a017b1c381a74c050a4e27c9285dddb43cf6342e58ffd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-publishing.adoc"}}
{"id": "sha256:edc88898499460caef4bb3107da5e045b87d832cc20eb445105b751d08624a59", "content": "Publishing occurs in the same thread as your component's execution.\nSo, by default, it is synchronous.\nThis means that the entire message flow has to wait until the publisher's flow completes.\nHowever, developers often want the complete opposite: to use this message-publishing feature to initiate asynchronous flows.\nFor example, you might host a service (HTTP, WS, and so on) which receives a remote request.\nYou may want to send this request internally into a process that might take a while.\nHowever, you may also want to reply to the user right away.\nSo, instead of sending inbound requests for processing to the output channel (the conventional way), you can use 'output-channel' or a 'replyChannel' header to send a simple acknowledgment-like reply back to the caller while using the message-publisher feature to initiate a complex flow.\n\nThe service in the following example receives a complex payload (which needs to be sent further for processing), but it also needs to reply to the caller with a simple acknowledgment:\n\n[source,java]\n----\npublic String echo(Object complexPayload) {\n return \"ACK\";\n}\n----\n\nSo, instead of hooking up the complex flow to the output channel, we use the message-publishing feature instead.\nWe configure it to create a new message by using the input argument of the service method (shown in the preceding example) and send that to the 'localProcessChannel'.\nTo make sure this flow is asynchronous, all we need to do is send it to any type of asynchronous channel (`ExecutorChannel` in the next example).\nThe following example shows how to an asynchronous `publishing-interceptor`:\n\n[source,xml]\n----\n<int:service-activator input-channel=\"inputChannel\" output-channel=\"outputChannel\" ref=\"sampleservice\"/>\n\n<bean id=\"sampleService\" class=\"test.SampleService\"/>\n\n<aop:config>\n <aop:advisor advice-ref=\"interceptor\" pointcut=\"bean(sampleService)\" />\n</aop:config>\n\n<int:publishing-interceptor id=\"interceptor\" >\n <int:method pattern=\"echo\" payload=\"#args[0]\" channel=\"localProcessChannel\">\n <int:header name=\"sample_header\" expression=\"'some sample value'\"/>\n </int:method>\n</int:publishing-interceptor>\n\n<int:channel id=\"localProcessChannel\">\n <int:dispatcher task-executor=\"executor\"/>\n</int:channel>\n\n<task:executor id=\"executor\" pool-size=\"5\"/>\n----\n\nAnother way of handling this type of scenario is with a wire-tap.\nSee xref:channel/configuration.adoc#channel-wiretap[Wire Tap].\n\n[[scheduled-producer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-publishing.adoc", "title": "message-publishing", "heading": "Asynchronous Publishing", "heading_level": 4, "file_order": 236, "section_index": 4, "content_hash": "edc88898499460caef4bb3107da5e045b87d832cc20eb445105b751d08624a59", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-publishing.adoc"}}
{"id": "sha256:e024e2c9b3e18715aa4bacacd80776d132a79f5060ae25c9e81e365086b74d73", "content": "In the preceding sections, we looked at the message-publishing feature, which constructs and publishes messages as by-products of method invocations.\nHowever, in those cases, you are still responsible for invoking the method.\nSpring Integration 2.0 added support for scheduled message producers and publishers with the new `expression` attribute on the 'inbound-channel-adapter' element.\nYou can schedule based on several triggers, any one of which can be configured on the 'poller' element.\nCurrently, we support `cron`, `fixed-rate`, `fixed-delay` and any custom trigger implemented by you and referenced by the 'trigger' attribute value.\n\nAs mentioned earlier, support for scheduled producers and publishers is provided via the `<inbound-channel-adapter>` XML element.\nConsider the following example:\n\n[source,xml]\n----\n<int:inbound-channel-adapter id=\"fixedDelayProducer\"\n expression=\"'fixedDelayTest'\"\n channel=\"fixedDelayChannel\">\n <int:poller fixed-delay=\"1000\"/>\n</int:inbound-channel-adapter>\n----\n\nThe preceding example creates an inbound channel adapter that constructs a `Message`, with its payload being the result of the expression defined in the `expression` attribute.\nSuch messages are created and sent every time the delay specified by the `fixed-delay` attribute occurs.\n\nThe following example is similar to the preceding example, except that it uses the `fixed-rate` attribute:\n\n[source,xml]\n----\n<int:inbound-channel-adapter id=\"fixedRateProducer\"\n expression=\"'fixedRateTest'\"\n channel=\"fixedRateChannel\">\n <int:poller fixed-rate=\"1000\"/>\n</int:inbound-channel-adapter>\n----\n\nThe `fixed-rate` attribute lets you send messages at a fixed rate (measuring from the start time of each task).\n\nThe following example shows how you can apply a Cron trigger with a value specified in the `cron` attribute:\n\n[source,xml]\n----\n<int:inbound-channel-adapter id=\"cronProducer\"\n expression=\"'cronTest'\"\n channel=\"cronChannel\">\n <int:poller cron=\"7 6 5 4 3 ?\"/>\n</int:inbound-channel-adapter>\n----\n\nThe following example shows how to insert additional headers into the message:\n\n[source,xml]\n----\n<int:inbound-channel-adapter id=\"headerExpressionsProducer\"\n expression=\"'headerExpressionsTest'\"\n channel=\"headerExpressionsChannel\"\n auto-startup=\"false\">\n <int:poller fixed-delay=\"5000\"/>\n <int:header name=\"foo\" expression=\"6 * 7\"/>\n <int:header name=\"bar\" value=\"x\"/>\n</int:inbound-channel-adapter>\n----\n\nThe additional message headers can take scalar values or the results of evaluating Spring expressions.\n\nIf you need to implement your own custom trigger, you can use the `trigger` attribute to provide a reference to any spring configured bean that implements the `org.springframework.scheduling.Trigger` interface.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<int:inbound-channel-adapter id=\"triggerRefProducer\"\n expression=\"'triggerRefTest'\" channel=\"triggerRefChannel\">\n <int:poller trigger=\"customTrigger\"/>\n</int:inbound-channel-adapter>\n\n<beans:bean id=\"customTrigger\" class=\"o.s.scheduling.support.PeriodicTrigger\">\n <beans:constructor-arg value=\"9999\"/>\n</beans:bean>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-publishing.adoc", "title": "message-publishing", "heading": "Producing and Publishing Messages Based on a Scheduled Trigger", "heading_level": 3, "file_order": 236, "section_index": 5, "content_hash": "e024e2c9b3e18715aa4bacacd80776d132a79f5060ae25c9e81e365086b74d73", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-publishing.adoc"}}
{"id": "sha256:6eb1d38cab8ca11e14bb73d646a7f52aadebb80a334d2f44f7edef8a8daa86db", "content": "[[messaging-routing-chapter]]\n\nThis chapter covers the details of using Spring Integration to route messages.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-routing.adoc", "title": "message-routing", "heading": "message-routing", "heading_level": 1, "file_order": 237, "section_index": 0, "content_hash": "6eb1d38cab8ca11e14bb73d646a7f52aadebb80a334d2f44f7edef8a8daa86db", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-routing.adoc"}}
{"id": "sha256:614ad8808846a10e61d57a90deea14f1abb6af39e722aa00ab7a5da62b577932", "content": "[[message-store]]\n\nThe https://www.enterpriseintegrationpatterns.com/[_Enterprise Integration Patterns_] (EIP) book identifies several patterns that have the ability to buffer messages.\nFor example, an aggregator buffers messages until they can be released, and a `QueueChannel` buffers messages until consumers explicitly receive those messages from that channel.\nBecause of the failures that can occur at any point within your message flow, EIP components that buffer messages also introduce a point where messages could be lost.\n\nTo mitigate the risk of losing messages, EIP defines the https://www.enterpriseintegrationpatterns.com/MessageStore.html[message store] pattern, which lets EIP components store messages, typically in some type of persistent store (such as an RDBMS).\n\nSpring Integration provides support for the message store pattern by:\n\n* Defining an `org.springframework.integration.store.MessageStore` strategy interface\n* Providing several implementations of this interface\n* Exposing a `message-store` attribute on all components that have the capability to buffer messages so that you can inject any instance that implements the `MessageStore` interface.\n\nDetails on how to configure a specific message store implementation and how to inject a `MessageStore` implementation into a specific buffering component are described throughout the manual (see the specific component, such as xref:channel/configuration.adoc#channel-configuration-queuechannel[QueueChannel], xref:overview.adoc#overview-endpoints-aggregator[Aggregator], xref:delayer.adoc[Delayer], and others).\nThe following pair of examples show how to add a reference to a message store for a `QueueChannel` and for an aggregator:\n\n.QueueChannel\n[source,xml]\n----\n<int:channel id=\"myQueueChannel\">\n <int:queue message-store=\"refToMessageStore\"/>\n<int:channel>\n----\n\n.Aggregator\n[source,xml]\n----\n<int:aggregator message-store=\"refToMessageStore\"/>\n----\n\nBy default, messages are stored in-memory by using `o.s.i.store.SimpleMessageStore`, an implementation of `MessageStore`.\nThat might be fine for development or simple low-volume environments where the potential loss of non-persistent messages is not a concern.\nHowever, the typical production application needs a more robust option, not only to mitigate the risk of message loss but also to avoid potential out-of-memory errors.\nTherefore, we also provide `MessageStore` implementations for a variety of data-stores.\nThe following is a complete list of supported implementations:\n\n* xref:hazelcast.adoc#hazelcast-message-store[Hazelcast Message Store]: Uses a Hazelcast distributed cache to store messages\n* xref:jdbc/message-store.adoc[JDBC Message Store]: Uses an RDBMS to store messages\n* xref:redis.adoc#redis-message-store[Redis Message Store]: Uses a Redis key/value datastore to store messages\n* xref:mongodb.adoc#mongodb-message-store[MongoDB Message Store]: Uses a MongoDB document store to store messages\n\n[IMPORTANT]\n=====\nHowever, be aware of some limitations while using persistent implementations of the `MessageStore`.\n\nThe Message data (payload and headers) is serialized and deserialized by using different serialization strategies, depending on the implementation of the `MessageStore`.\nFor example, when using `JdbcMessageStore`, only `Serializable` data is persisted by default.\nIn this case, non-Serializable headers are removed before serialization occurs.\nAlso, be aware of the protocol-specific headers that are injected by transport adapters (such as FTP, HTTP, JMS, and others).\nFor example, `<http:inbound-channel-adapter/>` maps HTTP headers into message headers, and one of them is an `ArrayList` of non-serializable `org.springframework.http.MediaType` instances.\nHowever, you can inject your own implementation of the `Serializer` and `Deserializer` strategy interfaces into some `MessageStore` implementations (such as `JdbcMessageStore`) to change the behavior of serialization and deserialization.\n\nPay special attention to the headers that represent certain types of data.\nFor example, if one of the headers contains an instance of some Spring bean, upon deserialization, you may end up with a different instance of that bean, which directly affects some of the implicit headers created by the framework (such as `REPLY_CHANNEL` or `ERROR_CHANNEL`).\nCurrently, they are not serializable, but, even if they were, the deserialized channel would not represent the expected instance.\n\nBeginning with Spring Integration version 3.0, you can resolve this issue with a header enricher configured to replace these headers with a name after registering the channel with the `HeaderChannelRegistry`.\n\nAlso, consider what happens when you configure a message-flow as follows: `gateway -> queue-channel (backed by a persistent Message Store) -> service-activator`.\nThat gateway creates a temporary reply channel, which is lost by the time the service-activator's poller reads from the queue.\nAgain, you can use the header enricher to replace the headers with a `String` representation.\n\nFor more information, see xref:content-enrichment.adoc#header-enricher[Header Enricher].\n=====\n\nSpring Integration 4.0 introduced two new interfaces:\n\n* `ChannelMessageStore`: To implement operations specific for `QueueChannel` instances\n* `PriorityCapableChannelMessageStore`: To mark `MessageStore` implementations to be used for `PriorityChannel` instances and to provide priority order for persisted messages.\n\nThe real behavior depends on the implementation.\nThe framework provides the following implementations, which can be used as a persistent `MessageStore` for `QueueChannel` and `PriorityChannel`:\n\n* xref:redis.adoc#redis-cms[Redis Channel Message Stores]\n* xref:mongodb.adoc#mongodb-priority-channel-message-store[MongoDB Channel Message Store]\n* xref:jdbc/message-store.adoc#jdbc-message-store-channels[Backing Message Channels]\n\n[[sms-caution]]\n[WARNING]\n.Caution about `SimpleMessageStore`\n=====\nStarting with version 4.1, the `SimpleMessageStore` no longer copies the message group when calling `getMessageGroup()`.\nFor large message groups, this was a significant performance problem.\n4.0.1 introduced a boolean `copyOnGet` property that lets you control this behavior.\nWhen used internally by the aggregator, this property was set to `false` to improve performance.\nIt is now `false` by default.\n\nUsers accessing the group store outside of components such as aggregators now get a direct reference to the group being used by the aggregator instead of a copy.\nManipulation of the group outside the aggregator may cause unpredictable results.\n\nFor this reason, you should either not perform such manipulation or set the `copyOnGet` property to `true`.\n=====\n\n[[message-group-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-store.adoc", "title": "message-store", "heading": "message-store", "heading_level": 1, "file_order": 238, "section_index": 0, "content_hash": "614ad8808846a10e61d57a90deea14f1abb6af39e722aa00ab7a5da62b577932", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-store.adoc"}}
{"id": "sha256:b4db99914d59cfa28704d369f1ba85c4f78508640bd11d4722938c5c001e049e", "content": "Starting with version 4.3, some `MessageGroupStore` implementations can be injected with a custom `MessageGroupFactory` strategy to create and customize the `MessageGroup` instances used by the `MessageGroupStore`.\nThis defaults to a `SimpleMessageGroupFactory`, which produces `SimpleMessageGroup` instances based on the `GroupType.HASH_SET` (`LinkedHashSet`) internal collection.\nOther possible options are `SYNCHRONISED_SET` and `BLOCKING_QUEUE`, where the last one can be used to reinstate the previous `SimpleMessageGroup` behavior.\nAlso, the `PERSISTENT` option is available.\nSee the next section for more information.\nStarting with version 5.0.1, the `LIST` option is also available for when the order and uniqueness of messages in the group does not matter.\n\n[[lazy-load-message-group]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-store.adoc", "title": "message-store", "heading": "Using `MessageGroupFactory`", "heading_level": 2, "file_order": 238, "section_index": 1, "content_hash": "b4db99914d59cfa28704d369f1ba85c4f78508640bd11d4722938c5c001e049e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-store.adoc"}}
{"id": "sha256:04e5fe780d28f3d82d65cf4f3ee3231744a71bcdbf01904f41292c8b441e9710", "content": "Starting with version 4.3, all persistent `MessageGroupStore` instances retrieve `MessageGroup` instances and their `messages` from the store in the lazy-load manner.\nIn most cases, it is useful for the correlation `MessageHandler` instances (see xref:overview.adoc#overview-endpoints-aggregator[Aggregator] and xref:resequencer.adoc[Resequencer]), when it would add overhead to load entire the `MessageGroup` from the store on each correlation operation.\n\nYou can use the `AbstractMessageGroupStore.setLazyLoadMessageGroups(false)` option to switch off the lazy-load behavior from the configuration.\n\nOur performance tests for lazy-load on MongoDB `MessageStore` (xref:mongodb.adoc#mongodb-message-store[MongoDB Message Store]) and `<aggregator>` (xref:overview.adoc#overview-endpoints-aggregator[Aggregator]) use a custom `release-strategy` similar to the following:\n\n[source,xml]\n----\n<int:aggregator input-channel=\"inputChannel\"\n output-channel=\"outputChannel\"\n message-store=\"mongoStore\"\n release-strategy-expression=\"size() == 1000\"/>\n----\n\nIt produces results similar to the following for 1000 simple messages:\n\n[source]\n----\n...\nStopWatch 'Lazy-Load Performance': running time (millis) = 38918\n-----------------------------------------\nms % Task name\n-----------------------------------------\n02652 007% Lazy-Load\n36266 093% Eager\n...\n----\n\nHowever, starting with version 5.5, all the persistent `MessageGroupStore` implementations provide a `streamMessagesForGroup(Object groupId)` contract based on the target database streaming API.\nThis improves resource utilization when groups are very big in the store.\nInternally in the framework this new API is used in the xref:delayer.adoc[Delayer], for example, when it reschedules persisted messages on startup.\nA returned `Stream<Message<?>>` must be closed at the end of processing, e.g. via auto-close by the `try-with-resources`.\nWhenever a `PersistentMessageGroup` is used, its `streamMessages()` delegates to the `MessageGroupStore.streamMessagesForGroup()`.\n\n[[message-group-condition]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-store.adoc", "title": "message-store", "heading": "Persistent `MessageGroupStore` and Lazy-load", "heading_level": 2, "file_order": 238, "section_index": 2, "content_hash": "04e5fe780d28f3d82d65cf4f3ee3231744a71bcdbf01904f41292c8b441e9710", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-store.adoc"}}
{"id": "sha256:bbed077f2bfc09143c1fc35b979c01be1c2c0ccf20118b5136383d19cebe5788", "content": "Starting with version 5.5, the `MessageGroup` abstraction provides a `condition` string option.\nThe value of this option can be anything that could be parsed later on for any reason to make a decision for the group.\nFor example, a `ReleaseStrategy` from a xref:aggregator.adoc#aggregator-api[correlation message handler] may consult this property from the group instead of iterating all the messages in the group.\nThe `MessageGroupStore` exposes a `setGroupCondition(Object groupId, String condition)` API.\nFor this purpose a `setGroupConditionSupplier(BiFunction<Message<?>, String, String>)` option has been added to the `AbstractCorrelatingMessageHandler`.\nThis function is evaluated against each message after it has been added to the group as well as the existing condition of the group.\nThe implementation may decide to return a new value, the existing value, or reset the target condition to `null`.\nThe value for a `condition` can be a JSON, SpEL expression, number, or anything what can be serialized as a string and parsed afterward.\nFor example, the `FileMarkerReleaseStrategy` from the xref:file/aggregator.adoc[File Aggregator] component, populates a condition into a group from the `FileHeaders.LINE_COUNT` header of the `FileSplitter.FileMarker.Mark.END` message and consults with it from its `canRelease()` comparing a group size with the value in this condition.\nThis way it doesn't iterate all the messages in a group to find a `FileSplitter.FileMarker.Mark.END` message with the `FileHeaders.LINE_COUNT` header.\nIt also allows the end marker to arrive at the aggregator before all the other records; for example, when processing a file in a multithreaded environment.\n\nIn addition, for configuration convenience, a `GroupConditionProvider` contract has been introduced.\nThe `AbstractCorrelatingMessageHandler` checks if the provided `ReleaseStrategy` implements this interface and extracts a `conditionSupplier` for group condition evaluation logic.\n\n[[use-lock-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-store.adoc", "title": "message-store", "heading": "Message Group Condition", "heading_level": 2, "file_order": 238, "section_index": 3, "content_hash": "bbed077f2bfc09143c1fc35b979c01be1c2c0ccf20118b5136383d19cebe5788", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-store.adoc"}}
{"id": "sha256:f15997937153d910fb7c1d5d0e72ad54450f7cb2e7a494b445d9ec545b7ecbef", "content": "Starting with version 6.5, the `AbstractMessageGroupStore` abstraction operates a metadata of a message group with a lock.\nThis lock acquires the groupId and generated by `LockRegister`.\nIts purpose is to operate on the atomicity of messages and message groups.\nIn multiple threads, adding or removing messages or updating metadata at the same time, some implementations may have message group errors if the lock is missing.\nBy default, the `DefaultLockRegistry` is used, any `LockRegister` can be injected via `AbstractMessageGroupStore.setLockRegistry()`, usually an implementation for the same persistent store.\nSee more xref:distributed-locks.adoc[Distributed Locks] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-store.adoc", "title": "message-store", "heading": "Use `LockRegistry`", "heading_level": 2, "file_order": 238, "section_index": 4, "content_hash": "f15997937153d910fb7c1d5d0e72ad54450f7cb2e7a494b445d9ec545b7ecbef", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-store.adoc"}}
{"id": "sha256:58cc0fb8052a39c138aa0e85d2eaff03ca79d983bdcd489d0d7e9b4064a6c8fd", "content": "[[messaging-transformation-chapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message-transformation.adoc", "title": "message-transformation", "heading": "message-transformation", "heading_level": 1, "file_order": 239, "section_index": 0, "content_hash": "58cc0fb8052a39c138aa0e85d2eaff03ca79d983bdcd489d0d7e9b4064a6c8fd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message-transformation.adoc"}}
{"id": "sha256:f59788561b73d4478330c8b879c062531635b6820910b8ed04024a57be64e019", "content": "[[message]]\n\nThe Spring Integration `Message` is a generic container for data.\nAny object can be provided as the payload, and each `Message` instance includes headers containing user-extensible properties as key-value pairs.\n\n[[message-interface]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message.adoc", "title": "message", "heading": "message", "heading_level": 1, "file_order": 240, "section_index": 0, "content_hash": "f59788561b73d4478330c8b879c062531635b6820910b8ed04024a57be64e019", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message.adoc"}}
{"id": "sha256:05ade71fe32835ccda28a31245c4e9b7999e785c540b4a94e26e44c121e275ce", "content": "The following listing shows the definition of the `Message` interface:\n\n[source,java]\n----\npublic interface Message<T> {\n\n T getPayload();\n\n MessageHeaders getHeaders();\n\n}\n----\n\nThe `Message` interface is a core part of the API.\nBy encapsulating the data in a generic wrapper, the messaging system can pass it around without any knowledge of the data's type.\nAs an application evolves to support new types or when the types themselves are modified or extended, the messaging system is not affected.\nOn the other hand, when some component in the messaging system does require access to information about the `Message`, such metadata can typically be stored to and retrieved from the metadata in the message headers.\n\n[[message-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message.adoc", "title": "message", "heading": "The `Message` Interface", "heading_level": 2, "file_order": 240, "section_index": 1, "content_hash": "05ade71fe32835ccda28a31245c4e9b7999e785c540b4a94e26e44c121e275ce", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message.adoc"}}
{"id": "sha256:ab13d1fdea190e1272638153e536639473a3ca345884e810bc756216b5956e38", "content": "Just as Spring Integration lets any `Object` be used as the payload of a `Message`, it also supports any `Object` types as header values.\nIn fact, the `MessageHeaders` class implements the `java.util.Map interface`, as the following class definition shows:\n\n[source,java]\n----\npublic final class MessageHeaders implements Map<String, Object>, Serializable {\n ...\n}\n----\n\nNOTE: Even though the `MessageHeaders` class implements `Map`, it is effectively a read-only implementation.\nAny attempt to `put` a value in the Map results in an `UnsupportedOperationException`.\nThe same applies for `remove` and `clear`.\nSince messages may be passed to multiple consumers, the structure of the `Map` cannot be modified.\nLikewise, the message's payload `Object` can not be `set` after the initial creation.\nHowever, the mutability of the header values themselves (or the payload Object) is intentionally left as a decision for the framework user.\n\nAs an implementation of `Map`, the headers can be retrieved by calling `get(..)` with the name of the header.\nAlternatively, you can provide the expected `Class` as an additional parameter.\nEven better, when retrieving one of the pre-defined values, convenient getters are available.\nThe following example shows each of these three options:\n\n[source,java]\n----\nObject someValue = message.getHeaders().get(\"someKey\");\n\nCustomerId customerId = message.getHeaders().get(\"customerId\", CustomerId.class);\n\nLong timestamp = message.getHeaders().getTimestamp();\n----\n\nThe following table describes the pre-defined message headers:\n\n.Pre-defined Message Headers\n[cols=\"2l,2l,5\", options=\"header\"]\n|===\n| Header Name\n| Header Type\n| Usage\n\n| MessageHeaders.ID\n| java.util.UUID\n| An identifier for this message instance.\nChanges each time a message is mutated.\n\n| MessageHeaders.\nTIMESTAMP\n| java.lang.Long\n| The time the message was created.\nChanges each time a message is mutated.\n\n| MessageHeaders.\nREPLY_CHANNEL\n| java.lang.Object\n(String or\nMessageChannel)\n| A channel to which a reply (if any) is sent when no explicit output channel is configured and there is no `ROUTING_SLIP` or the `ROUTING_SLIP` is exhausted.\nIf the value is a `String`, it must represent a bean name or have been generated by a `ChannelRegistry.`\n\n| MessageHeaders.\nERROR_CHANNEL\n| java.lang.Object\n(String or\nMessageChannel)\n| A channel to which errors are sent.\nIf the value is a `String`, it must represent a bean name or have been generated by a `ChannelRegistry.`\n|===\n\nMany inbound and outbound adapter implementations also provide or expect certain headers, and you can configure additional user-defined headers.\nConstants for these headers can be found in those modules where such headers exist -- for example.\n`AmqpHeaders`, `JmsHeaders`, and so on.\n\n[[message-header-accessor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message.adoc", "title": "message", "heading": "Message Headers", "heading_level": 2, "file_order": 240, "section_index": 2, "content_hash": "ab13d1fdea190e1272638153e536639473a3ca345884e810bc756216b5956e38", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message.adoc"}}
{"id": "sha256:2a2d38cf3d43dfafa5c370a597032bac0ea5ef675d14e8bb7befad7ec1efd46d", "content": "Starting with Spring Framework 4.0 and Spring Integration 4.0, the core messaging abstraction has been moved to the `spring-messaging` module, and the `MessageHeaderAccessor` API has been introduced to provide additional abstraction over messaging implementations.\nAll (`core`) Spring Integration-specific message headers constants are now declared in the `IntegrationMessageHeaderAccessor` class.\nThe following table describes the pre-defined message headers:\n\n.Pre-defined Message Headers\n[cols=\"5l,3l,5\", options=\"header\"]\n|===\n| Header Name\n| Header Type\n| Usage\n\n| IntegrationMessageHeaderAccessor.\nCORRELATION_ID\n| java.lang.Object\n| Used to correlate two or more messages.\n\n| IntegrationMessageHeaderAccessor.\nSEQUENCE_NUMBER\n| java.lang.Integer\n| Usually a sequence number with a group of messages with a `SEQUENCE_SIZE` but can also be used in a `<resequencer/>` to resequence an unbounded group of messages.\n\n| IntegrationMessageHeaderAccessor.\nSEQUENCE_SIZE\n| java.lang.Integer\n| The number of messages within a group of correlated messages.\n\n| IntegrationMessageHeaderAccessor.\nEXPIRATION_DATE\n| java.lang.Long\n| Indicates when a message is expired.\nNot used by the framework directly but can be set with a header enricher and used in a `<filter/>` that is configured with an `UnexpiredMessageSelector`.\n\n| IntegrationMessageHeaderAccessor.\nPRIORITY\n| java.lang.Integer\n| Message priority -- for example, within a `PriorityChannel`.\n\n| IntegrationMessageHeaderAccessor.\nDUPLICATE_MESSAGE\n| java.lang.Boolean\n| True if a message was detected as a duplicate by an idempotent receiver interceptor.\nSee xref:handler-advice/idempotent-receiver.adoc[Idempotent Receiver Enterprise Integration Pattern].\n\n| IntegrationMessageHeaderAccessor.\nCLOSEABLE_RESOURCE\n| java.io.Closeable\n| This header is present if the message is associated with a `Closeable` that should be closed when message processing is complete.\nAn example is the `Session` associated with a streamed file transfer using FTP, SFTP, and so on.\n\n| IntegrationMessageHeaderAccessor.\nDELIVERY_ATTEMPT\n| java.lang.\nAtomicInteger\n| If a message-driven channel adapter supports the configuration of a `RetryTemplate`, this header contains the current delivery attempt.\n\n| IntegrationMessageHeaderAccessor.\nACKNOWLEDGMENT_CALLBACK\n| o.s.i.support.\nAcknowledgment\nCallback\n| If an inbound endpoint supports it, a call back to accept, reject, or requeue a message.\nSee xref:polling-consumer.adoc#deferred-acks-message-source[Deferred Acknowledgment Pollable Message Source] and xref:mqtt.adoc#mqtt-ack-mode[MQTT Manual Acks].\n|===\n\nConvenient typed getters for some of these headers are provided on the `IntegrationMessageHeaderAccessor` class, as the following example shows:\n\n[source,java]\n----\nIntegrationMessageHeaderAccessor accessor = new IntegrationMessageHeaderAccessor(message);\nint sequenceNumber = accessor.getSequenceNumber();\nObject correlationId = accessor.getCorrelationId();\n...\n----\n\nThe following table describes headers that also appear in the `IntegrationMessageHeaderAccessor` but are generally not used by user code (that is, they are generally used by internal parts of Spring Integration -- their inclusion here is for completeness):\n\n.Pre-defined Message Headers\n[cols=\"5l,3l,5\", options=\"header\"]\n|===\n| Header Name\n| Header Type\n| Usage\n\n| IntegrationMessageHeaderAccessor.\nSEQUENCE_DETAILS\n| java.util.\nList<List<Object>>\n| A stack of correlation data used when nested correlation is needed (for example,\n`splitter->...->splitter->...->aggregator->...->aggregator`).\n\n| IntegrationMessageHeaderAccessor.\nROUTING_SLIP\n| java.util.\nMap<List<Object>, Integer>\n| See xref:router/routing-slip.adoc[Routing Slip].\n|===\n\n[[message-id-generation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message.adoc", "title": "message", "heading": "`MessageHeaderAccessor` API", "heading_level": 3, "file_order": 240, "section_index": 3, "content_hash": "2a2d38cf3d43dfafa5c370a597032bac0ea5ef675d14e8bb7befad7ec1efd46d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message.adoc"}}
{"id": "sha256:c4dfe8bce4f55290f26ab22d9a574ea5230d6239d6706504bfb76a18a0c09b35", "content": "When a message transitions through an application, each time it is mutated, (for example, by a transformer), a new message ID is assigned.\nThe message ID is a `UUID`.\nBeginning with Spring Integration 3.0, the default strategy used for IS generation is more efficient than the previous `java.util.UUID.randomUUID()` implementation.\nIt uses simple random numbers based on a secure random seed instead of creating a secure random number each time.\n\nA different UUID generation strategy can be selected by declaring a bean that implements `org.springframework.util.IdGenerator` in the application context.\n\nIMPORTANT: Only one UUID generation strategy can be used in a classloader.\nThis means that if two or more application contexts run in the same classloader, they share the same strategy.\nIf one of the contexts changes the strategy, it is used by all contexts.\nIf two or more contexts in the same classloader declare a bean of type `org.springframework.util.IdGenerator`, they must all be an instance of the same class.\nOtherwise, the context attempting to replace a custom strategy fails to initialize.\nIf the strategy is the same, but parameterized, the strategy in the first context to be initialized is used.\n\nIn addition to the default strategy, two additional `IdGenerators` are provided.\n`org.springframework.util.JdkIdGenerator` uses the previous `UUID.randomUUID()` mechanism.\nYou can use `o.s.i.support.IdGenerators.SimpleIncrementingIdGenerator` when a UUID is not really needed and a simple incrementing value is sufficient.\n\n[[read-only-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message.adoc", "title": "message", "heading": "Message ID Generation", "heading_level": 3, "file_order": 240, "section_index": 4, "content_hash": "c4dfe8bce4f55290f26ab22d9a574ea5230d6239d6706504bfb76a18a0c09b35", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message.adoc"}}
{"id": "sha256:ce3e62991600c10454760a128748b76b4f7a1d4d29ca368a6e717b9b8b0134c7", "content": "The `MessageHeaders.ID` and `MessageHeaders.TIMESTAMP` are read-only headers and cannot be overridden.\n\nSince version 4.3.2, the `MessageBuilder` provides the `readOnlyHeaders(String... readOnlyHeaders)` API to customize a list of headers that should not be copied from an upstream `Message`.\nOnly the `MessageHeaders.ID` and `MessageHeaders.TIMESTAMP` are read-only by default.\nThe global `spring.integration.readOnly.headers` property (see xref:configuration/global-properties.adoc[Global Properties]) is provided to customize `DefaultMessageBuilderFactory` for framework components.\nThis can be useful when you would like to not populate some out-of-the-box headers, such as `contentType` by the `ObjectToJsonTransformer` (see xref:transformer.adoc#json-transformers[JSON Transformers]).\n\nWhen you try to build a new message using `MessageBuilder`, this kind of header is ignored and a particular `INFO` message is emitted to logs.\n\nStarting with version 5.0, xref:gateway.adoc[Messaging Gateway], xref:content-enrichment.adoc#header-enricher[Header Enricher], xref:content-enrichment.adoc#payload-enricher[Content Enricher,] and xref:transformer.adoc#header-filter[Header Filter] do not let you configure the `MessageHeaders.ID` and `MessageHeaders.TIMESTAMP` header names when `DefaultMessageBuilderFactory` is used, and they throw `BeanInitializationException`.\n\n[[header-propagation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message.adoc", "title": "message", "heading": "Read-only Headers", "heading_level": 3, "file_order": 240, "section_index": 5, "content_hash": "ce3e62991600c10454760a128748b76b4f7a1d4d29ca368a6e717b9b8b0134c7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message.adoc"}}
{"id": "sha256:8b8c1ec17bcff96d27b1c2fbdebbc78d21eced678df44e1fd896ed0f1e602e84", "content": "When messages are processed (and modified) by message-producing endpoints (such as a xref:service-activator.adoc[service activator]), in general, inbound headers are propagated to the outbound message.\nOne exception to this is a xref:transformer.adoc[transformer], when a complete message is returned to the framework.\nIn that case, the user code is responsible for the entire outbound message.\nWhen a transformer just returns the payload, the inbound headers are propagated.\nAlso, a header is only propagated if it does not already exist in the outbound message, letting you change header values as needed.\n\nStarting with version 4.3.10, you can configure message handlers (that modify messages and produce output) to suppress the propagation of specific headers.\nTo configure the headers, you do not want to be copied, call the `setNotPropagatedHeaders()` or `addNotPropagatedHeaders()` methods on the `MessageProducingMessageHandler` abstract class.\n\nYou can also globally suppress propagation of specific message headers by setting the `readOnlyHeaders` property in `META-INF/spring.integration.properties` to a comma-delimited list of headers.\n\nStarting with version 5.0, the `setNotPropagatedHeaders()` implementation on the `AbstractMessageProducingHandler` applies simple patterns (`xxx*`, `\\*xxx`, `*xxx*`, or `xxx*yyy`) to allow filtering headers with a common suffix or prefix.\nSee https://docs.spring.io/spring-integration/api/org/springframework/integration/util/PatternMatchUtils.html[`PatternMatchUtils` Javadoc] for more information.\nWhen one of the patterns is `*` (asterisk), no headers are propagated.\nAll other patterns are ignored.\nIn that case, the service activator behaves the same way as a transformer and any required headers must be supplied in the `Message` returned from the service method.\nThe `notPropagatedHeaders()` option is available in the `ConsumerEndpointSpec` for the Java DSL\nIt is also available for XML configuration of the `<service-activator>` component as a `not-propagated-headers` attribute.\n\nIMPORTANT: Header propagation suppression does not apply to those endpoints that do not modify the message, such as xref:bridge.adoc[bridges] and xref:router.adoc[routers].\n\n[[message-implementations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message.adoc", "title": "message", "heading": "Header Propagation", "heading_level": 3, "file_order": 240, "section_index": 6, "content_hash": "8b8c1ec17bcff96d27b1c2fbdebbc78d21eced678df44e1fd896ed0f1e602e84", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message.adoc"}}
{"id": "sha256:77d175fba5c690e49f1cd6f785de5183a1d1026b3c25a20670a03031a2daf381", "content": "The base implementation of the `Message` interface is `GenericMessage<T>`, and it provides two constructors, shown in the following listing:\n\n[source,java]\n----\nnew GenericMessage<T>(T payload);\n\nnew GenericMessage<T>(T payload, Map<String, Object> headers)\n----\n\nWhen a `Message` is created, a random unique ID is generated.\nThe constructor that accepts a `Map` of headers copies the provided headers to the newly created `Message`.\n\nThere is also a convenient implementation of `Message` designed to communicate error conditions.\nThis implementation takes a `Throwable` object as its payload, as the following example shows:\n\n[source,java]\n----\nErrorMessage message = new ErrorMessage(someThrowable);\n\nThrowable t = message.getPayload();\n----\n\nNote that this implementation takes advantage of the fact that the `GenericMessage` base class is parameterized.\nTherefore, as shown in both examples, no casting is necessary when retrieving the `Message` payload `Object`.\n\nThe mentioned `Message` class implementations are immutable.\nIn some cases, when mutability is not a concern and the logic of application is well-designed to avoid concurrent modifications, a `MutableMessage` can be used.\n\n[[message-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message.adoc", "title": "message", "heading": "Message Implementations", "heading_level": 2, "file_order": 240, "section_index": 7, "content_hash": "77d175fba5c690e49f1cd6f785de5183a1d1026b3c25a20670a03031a2daf381", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message.adoc"}}
{"id": "sha256:48c514ec9dbe11867ac11595bd2d67edfc82ecafedda6df098884da9215c05a6", "content": "You may notice that the `Message` interface defines retrieval methods for its payload and headers but provides no setters.\nThe reason for this is that a `Message` cannot be modified after its initial creation.\nTherefore, when a `Message` instance is sent to multiple consumers, (for example, through a publish-subscribe Channel), if one of those consumers needs to send a reply with a different payload type, it must create a new `Message`.\nAs a result, the other consumers are not affected by those changes.\nKeep in mind that multiple consumers may access the same payload instance or header value, and whether such an instance is itself immutable is a decision left to you.\nIn other words, the contract for `Message` instances is similar to that of an unmodifiable `Collection`, and the `MessageHeaders` map further exemplifies that.\nEven though the `MessageHeaders` class implements `java.util.Map`, any attempt to invoke a `put` operation (or 'remove' or 'clear') on a `MessageHeaders` instance results in an `UnsupportedOperationException`.\n\nRather than requiring the creation and population of a Map to pass into the GenericMessage constructor, Spring Integration does provide a far more convenient way to construct Messages: `MessageBuilder`.\nThe `MessageBuilder` provides two factory methods for creating `Message` instances from either an existing `Message` or with a payload `Object`.\nWhen building from an existing `Message`, the headers and payload of that `Message` are copied to the new `Message`, as the following example shows:\n\n[source,java]\n----\nMessage<String> message1 = MessageBuilder.withPayload(\"test\")\n .setHeader(\"foo\", \"bar\")\n .build();\n\nMessage<String> message2 = MessageBuilder.fromMessage(message1).build();\n\nassertEquals(\"test\", message2.getPayload());\nassertEquals(\"bar\", message2.getHeaders().get(\"foo\"));\n----\n\nIf you need to create a `Message` with a new payload but still want to copy the headers from an existing `Message`, you can use one of the 'copy' methods, as the following example shows:\n\n[source,java]\n----\nMessage<String> message3 = MessageBuilder.withPayload(\"test3\")\n .copyHeaders(message1.getHeaders())\n .build();\n\nMessage<String> message4 = MessageBuilder.withPayload(\"test4\")\n .setHeader(\"foo\", 123)\n .copyHeadersIfAbsent(message1.getHeaders())\n .build();\n\nassertEquals(\"bar\", message3.getHeaders().get(\"foo\"));\nassertEquals(123, message4.getHeaders().get(\"foo\"));\n----\n\nNote that the `copyHeadersIfAbsent` method does not overwrite existing values.\nAlso, in the preceding example, you can see how to set any user-defined header with `setHeader`.\nFinally, there are `set` methods available for the predefined headers as well as a non-destructive method for setting any header (`MessageHeaders` also defines constants for the pre-defined header names).\n\nYou can also use `MessageBuilder` to set the priority of messages, as the following example shows:\n\n[source,java]\n----\nMessage<Integer> importantMessage = MessageBuilder.withPayload(99)\n .setPriority(5)\n .build();\n\nassertEquals(5, importantMessage.getHeaders().getPriority());\n\nMessage<Integer> lessImportantMessage = MessageBuilder.fromMessage(importantMessage)\n .setHeaderIfAbsent(IntegrationMessageHeaderAccessor.PRIORITY, 2)\n .build();\n\nassertEquals(2, lessImportantMessage.getHeaders().getPriority());\n\n----\n\nThe `priority` header is considered only when using a `PriorityChannel` (as described in the next chapter).\nIt is defined as a `java.lang.Integer`.\n\nThe `MutableMessageBuilder` is provided to deal with `MutableMessage` instances.\nThe logic of this class is to create a `MutableMessage` or leave it as is and mutate its content via builder methods.\nThis way there is a slight performance gain in the running application when immutability is not a concern of message exchanges.\n\nNOTE: Starting with version 6.4, a `BaseMessageBuilder` class is extracted from the `MessageBuilder` to simplify an extension for the default message building logic.\nFor example, together with a custom `MessageBuilderFactory`, a custom `BaseMessageBuilder` implementation could be used globally in the application context to provide custom `Message` instances.\nIn particular, the `GenericMessage.toString()` method can be overridden to hide sensitive information from payload and headers when such a message is logged.\n\n[[message-builder-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message.adoc", "title": "message", "heading": "The `MessageBuilder` Helper Class", "heading_level": 2, "file_order": 240, "section_index": 8, "content_hash": "48c514ec9dbe11867ac11595bd2d67edfc82ecafedda6df098884da9215c05a6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message.adoc"}}
{"id": "sha256:52764146f0076d976add49fbfcfca8316e402395ceb9aa677bcd878e66cc089e", "content": "The `MessageBuilderFactory` bean with `IntegrationUtils.INTEGRATION_MESSAGE_BUILDER_FACTORY_BEAN_NAME` is registered globally into an application context and used everywhere in the framework to create `Message` instances.\nBy default, it is an instance of `DefaultMessageBuilderFactory`.\nOut of the box, the framework also provides a `MutableMessageBuilderFactory` to create `MutableMessage` instances in the framework components instead.\nTo customize `Message` instances creation, a `MessageBuilderFactory` bean with `IntegrationUtils.INTEGRATION_MESSAGE_BUILDER_FACTORY_BEAN_NAME` has to be provided in the target application context to override a default one.\nFor example, a custom `MessageBuilderFactory` could be registered for an implementation of the `BaseMessageBuilder` where we would like to provide a `GenericMessage` extension with overridden `toString()` to hide sensitive information from payload and headers when such a message is logged.\n\nSome quick implementation of these classes to demonstrate personal identifiable information mitigation can be like this:\n[source,java]\n----\nclass PiiMessageBuilderFactory implements MessageBuilderFactory {\n\n\t@Override\n\tpublic <T> PiiMessageBuilder<T> fromMessage(Message<T> message) {\n return new PiiMessageBuilder<>(message.getPayload(), message);\n\t}\n\n\t@Override\n\tpublic <T> PiiMessageBuilder<T> withPayload(T payload) {\n return new PiiMessageBuilder<>(payload, null);\n\t}\n\n}\n\nclass PiiMessageBuilder<P> extends BaseMessageBuilder<P, PiiMessageBuilder<P>> {\n\n public PiiMessageBuilder(P payload, @Nullable Message<P> originalMessage) {\n super(payload, originalMessage);\n }\n\n @Override\n public Message<P> build() {\n return new PiiMessage<>(getPayload(), getHeaders());\n }\n\n}\n\nclass PiiMessage<P> extends GenericMessage<P> {\n\n @Serial\n private static final long serialVersionUID = -354503673433669578L;\n\n public PiiMessage(P payload, Map<String, Object> headers) {\n super(payload, headers);\n }\n\n @Override\n public String toString() {\n return \"PiiMessage [payload=\" + getPayload() + \", headers=\" + maskHeaders(getHeaders()) + ']';\n }\n\n private static Map<String, Object> maskHeaders(Map<String, Object> headers) {\n return headers.entrySet()\n .stream()\n .map((entry) -> entry.getKey().equals(\"password\") ? Map.entry(entry.getKey(), \"******\") : entry)\n .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n }\n\n}\n----\n\nThen this `PiiMessageBuilderFactory` could be registered as a bean, and whenever the framework logs the message (e.g. in case of `errorChannel`), the `password` header will be masked.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/message.adoc", "title": "message", "heading": "The `MessageBuilderFactory` abstraction", "heading_level": 2, "file_order": 240, "section_index": 9, "content_hash": "52764146f0076d976add49fbfcfca8316e402395ceb9aa677bcd878e66cc089e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/message.adoc"}}
{"id": "sha256:0d8a002de3a7f7e4cc60c64020a22f5705fb5352ca9150a33ca516af067f0b58", "content": "[[messaging-endpoints-chapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/messaging-endpoints.adoc", "title": "messaging-endpoints", "heading": "messaging-endpoints", "heading_level": 1, "file_order": 241, "section_index": 0, "content_hash": "0d8a002de3a7f7e4cc60c64020a22f5705fb5352ca9150a33ca516af067f0b58", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/messaging-endpoints.adoc"}}
{"id": "sha256:85aeb3ef75507017839a5c1786f44094e756a84fc2e3d2154307b12429cc4a4e", "content": "[[metadata-store]]\n\nMany external systems, services, or resources are not transactional (Twitter, RSS, file systems, and so on), and there is not any ability to mark the data as read.\nAlso, sometimes, you may need to implement the Enterprise Integration Pattern https://www.enterpriseintegrationpatterns.com/IdempotentReceiver.html[idempotent receiver] in some integration solutions.\nTo achieve this goal and store some previous state of the endpoint before the next interaction with an external system or to deal with the next message, Spring Integration provides the metadata store component as an implementation of the `org.springframework.integration.metadata.MetadataStore` interface with a general key-value contract.\n\nThe metadata store is designed to store various types of generic metadata, (for example, the published date of the last feed entry that has been processed) to help components such as the feed adapter deal with duplicates.\nIf a component is not directly provided with a reference to a `MetadataStore`, the algorithm for locating a metadata store is as follows: First, look for a bean with a `metadataStore` ID in the application context.\nIf one is found, use it.\nOtherwise, create a new instance of `SimpleMetadataStore`, which is an in-memory implementation that persists only metadata within the lifecycle of the currently running application context.\nThis means that, upon restart, you may end up with duplicate entries.\n\nIf you need to persist metadata between application context restarts, the framework provides the following persistent `MetadataStores`:\n\n* `PropertiesPersistingMetadataStore`\n* xref:hazelcast.adoc#hazelcast-metadata-store[Hazelcast Metadata Store]\n* xref:jdbc/metadata-store.adoc[JDBC Metadata Store]\n* xref:mongodb.adoc#mongodb-metadata-store[MongoDB Metadata Store]\n* xref:redis.adoc#redis-metadata-store[Redis Metadata Store]\n* xref:zookeeper.adoc#zk-metadata-store[Zookeeper Metadata Store]\n\nThe https://awspring.io[Spring Cloud AWS] also provides a `DynamoDbMetadataStore`.\n\nThe `PropertiesPersistingMetadataStore` is backed by a properties file and a https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/PropertiesPersister.html[`PropertiesPersister`].\n\nBy default, it persists only in the state when the application context is closed normally.\nIt implements `Flushable` so that you can persist the state at will, by invoking `flush()`.\nThe following example shows how to configure a 'PropertiesPersistingMetadataStore' with XML:\n\n[source,xml]\n----\n<bean id=\"metadataStore\"\n class=\"org.springframework.integration.metadata.PropertiesPersistingMetadataStore\"/>\n----\n\nAlternatively, you can provide your own implementation of the `MetadataStore` interface (for example, `JdbcMetadataStore`) and configure it as a bean in the application context.\n\nStarting with version 4.0, `SimpleMetadataStore`, `PropertiesPersistingMetadataStore`, and `RedisMetadataStore` implement `ConcurrentMetadataStore`.\nThese provide for atomic updates and can be used across multiple component or application instances.\n\n[[idempotent-receiver-pattern]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/meta-data-store.adoc", "title": "meta-data-store", "heading": "meta-data-store", "heading_level": 1, "file_order": 242, "section_index": 0, "content_hash": "85aeb3ef75507017839a5c1786f44094e756a84fc2e3d2154307b12429cc4a4e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/meta-data-store.adoc"}}
{"id": "sha256:ea2a093faf012fd0fd89111d1dc199eb356be6e39f595cae41ed854d5fc46dab", "content": "The metadata store is useful for implementing the EIP https://www.enterpriseintegrationpatterns.com/IdempotentReceiver.html[idempotent receiver] pattern when there is a need to filter an incoming message if it has already been processed and you can discard it or perform some other logic on discarding.\nThe following configuration shows an example of how to do so:\n\n[source,xml]\n----\n<int:filter input-channel=\"serviceChannel\"\n output-channel=\"idempotentServiceChannel\"\n discard-channel=\"discardChannel\"\n expression=\"@metadataStore.get(headers.businessKey) == null\"/>\n\n<int:publish-subscribe-channel id=\"idempotentServiceChannel\"/>\n\n<int:outbound-channel-adapter channel=\"idempotentServiceChannel\"\n expression=\"@metadataStore.put(headers.businessKey, '')\"/>\n\n<int:service-activator input-channel=\"idempotentServiceChannel\" ref=\"service\"/>\n----\n\nThe `value` of the idempotent entry may be an expiration date, after which that entry should be removed from metadata store by some scheduled reaper.\n\nSee also xref:handler-advice/idempotent-receiver.adoc[Idempotent Receiver Enterprise Integration Pattern].\n\n[[metadatastore-listener]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/meta-data-store.adoc", "title": "meta-data-store", "heading": "Idempotent Receiver and Metadata Store", "heading_level": 2, "file_order": 242, "section_index": 1, "content_hash": "ea2a093faf012fd0fd89111d1dc199eb356be6e39f595cae41ed854d5fc46dab", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/meta-data-store.adoc"}}
{"id": "sha256:f9a5b6d3dc7d4d7661e703dc61631ebe4191c1f441b249bc0fb63c56b881f261", "content": "Some metadata stores (currently only zookeeper) support registering a listener to receive events when items change, as the following example shows:\n\n[source, java]\n----\npublic interface MetadataStoreListener {\n\n\tvoid onAdd(String key, String value);\n\n\tvoid onRemove(String key, String oldValue);\n\n\tvoid onUpdate(String key, String newValue);\n}\n----\n\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/metadata/MetadataStoreListenerAdapter.html[Javadoc] for more information.\nThe `MetadataStoreListenerAdapter` can be subclassed if you are interested only in a subset of events.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/meta-data-store.adoc", "title": "meta-data-store", "heading": "`MetadataStoreListener`", "heading_level": 2, "file_order": 242, "section_index": 2, "content_hash": "f9a5b6d3dc7d4d7661e703dc61631ebe4191c1f441b249bc0fb63c56b881f261", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/meta-data-store.adoc"}}
{"id": "sha256:f7e1ab15156aec70261141ee070a3d1028c8b4ac5aa945d5de215d54a3df460b", "content": "[[metrics-management]]\n\nThis section describes how to capture metrics for Spring Integration.\nIn recent versions, we have relied more on https://micrometer.io/[Micrometer], and we plan to use Micrometer even more in future releases.\n\n[[disabling-logging-in-high-volume-environments]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/metrics.adoc", "title": "metrics", "heading": "metrics", "heading_level": 1, "file_order": 243, "section_index": 0, "content_hash": "f7e1ab15156aec70261141ee070a3d1028c8b4ac5aa945d5de215d54a3df460b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/metrics.adoc"}}
{"id": "sha256:f988e90584298874bde09a4b8cca64bbb7fc118e8e1a5235330a9d9b6eeec885", "content": "You can control debug logging in the main message flow.\nIn very high-volume applications, calls to `isDebugEnabled()` can be quite expensive with some logging subsystems.\nYou can disable all such logging to avoid this overhead.\nException logging (debug or otherwise) is not affected by this setting.\n\nThe following listing shows the available options for controlling logging:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Configuration\n@EnableIntegration\n@EnableIntegrationManagement(\n defaultLoggingEnabled = \"true\" <1>)\n\npublic static class ContextConfiguration {\n...\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:management default-logging-enabled=\"true\"/> <1>\n----\n======\n<1> Set to `false` to disable all logging in the main message flow, regardless of the log system category settings.\nSet to 'true' to enable debug logging (if also enabled by the logging subsystem).\nOnly applied if you have not explicitly configured the setting in a bean definition.\nThe default is `true`.\n\nIMPORTANT: `defaultLoggingEnabled` is applied only if you have not explicitly configured the corresponding setting in a bean definition.\n\n[[micrometer-integration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/metrics.adoc", "title": "metrics", "heading": "Disabling Logging in High Volume Environments", "heading_level": 2, "file_order": 243, "section_index": 1, "content_hash": "f988e90584298874bde09a4b8cca64bbb7fc118e8e1a5235330a9d9b6eeec885", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/metrics.adoc"}}
{"id": "sha256:166f3fbbae0cae6489b3b13a8d778cdd9388360d4d7c30d6a1654d6cf01ef757", "content": "[[overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/metrics.adoc", "title": "metrics", "heading": "Micrometer Integration", "heading_level": 2, "file_order": 243, "section_index": 2, "content_hash": "166f3fbbae0cae6489b3b13a8d778cdd9388360d4d7c30d6a1654d6cf01ef757", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/metrics.adoc"}}
{"id": "sha256:9af0704c44884f1af126e3bdcb440b7d62b3e58177d7f2e990015f43de9668c4", "content": "Starting with version 5.0.3, the presence of a https://micrometer.io/[Micrometer] `MeterRegistry` in the application context triggers support for Micrometer metrics.\n\nTo use Micrometer, add one of the `MeterRegistry` beans to the application context.\n\nFor each `MessageHandler` and `MessageChannel`, timers are registered.\nFor each `MessageSource`, a counter is registered.\n\nThis only applies to objects that extend `AbstractMessageHandler`, `AbstractMessageChannel`, and `AbstractMessageSource` (which is the case for most framework components).\n\nThe `Timer` Meters for send operations on message channels have the following names or tags:\n\n* `name`: `spring.integration.send`\n* `tag`: `type:channel`\n* `tag`: `name:<componentName>`\n* `tag`: `result:(success|failure)`\n* `tag`: `exception:(none|exception simple class name)`\n* `description`: `Send processing time`\n\n(A `failure` result with a `none` exception means the channel's `send()` operation returned `false`.)\n\nThe `Counter` Meters for receive operations on pollable message channels have the following names or tags:\n\n* `name`: `spring.integration.receive`\n* `tag`: `type:channel`\n* `tag`: `name:<componentName>`\n* `tag`: `result:(success|failure)`\n* `tag`: `exception:(none|exception simple class name)`\n* `description`: `Messages received`\n\nThe `Timer` Meters for operations on message handlers have the following names or tags:\n\n* `name`: `spring.integration.send`\n* `tag`: `type:handler`\n* `tag`: `name:<componentName>`\n* `tag`: `result:(success|failure)`\n* `tag`: `exception:(none|exception simple class name)`\n* `description`: `Send processing time`\n\nThe `Counter` meters for message sources have the following names/tags:\n\n* `name`: `spring.integration.receive`\n* `tag`: `type:source`\n* `tag`: `name:<componentName>`\n* `tag`: `result:success`\n* `tag`: `exception:none`\n* `description`: `Messages received`\n\nIn addition, there are three `Gauge` Meters:\n\n* `spring.integration.channels`: The number of `MessageChannels` in the application.\n* `spring.integration.handlers`: The number of `MessageHandlers` in the application.\n* `spring.integration.sources`: The number of `MessageSources` in the application.\n\nIt is possible to customize the names and tags of `Meters` created by integration components by providing a subclass of `MicrometerMetricsCaptor`.\nThe https://github.com/spring-projects/spring-integration/blob/main/spring-integration-core/src/test/java/org/springframework/integration/support/management/micrometer/MicrometerCustomMetricsTests.java[MicrometerCustomMetricsTests] test case shows a simple example of how to do that.\nYou can also further customize the meters by overloading the `build()` methods on builder subclasses.\n\nStarting with version 5.1.13, the `QueueChannel` exposes Micrometer gauges for queue size and remaining capacity:\n\n* `name`: `spring.integration.channel.queue.size`\n* `tag`: `type:channel`\n* `tag`: `name:<componentName>`\n* `description`: `The size of the queue channel`\n\nand\n\n* `name`: `spring.integration.channel.queue.remaining.capacity`\n* `tag`: `type:channel`\n* `tag`: `name:<componentName>`\n* `description`: `The remaining capacity of the queue channel`\n\n[[disabling-meters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/metrics.adoc", "title": "metrics", "heading": "Overview", "heading_level": 3, "file_order": 243, "section_index": 3, "content_hash": "9af0704c44884f1af126e3bdcb440b7d62b3e58177d7f2e990015f43de9668c4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/metrics.adoc"}}
{"id": "sha256:2cd525b5d74cf4c9b28110e114656c83d45dfea0540be83b2115e5aca06391a3", "content": "By default, all meters are registered when first used.\nNow, with Micrometer, you can add `MeterFilter` s to the `MeterRegistry` to prevent some or all from being registered.\nYou can filter out (deny) meters by any of the properties provided, `name`, `tag`, etc.\nSee https://micrometer.io/docs/concepts#_meter_filters[Meter Filters] in the Micrometer documentation for more information.\n\nFor example, given:\n\n[source, java]\n----\n@Bean\npublic QueueChannel noMeters() {\n return new QueueChannel(10);\n}\n----\n\nYou can suppress registration of meters for just this channel with:\n\n[source, java]\n----\nregistry.config().meterFilter(MeterFilter.deny(id ->\n \"channel\".equals(id.getTag(\"type\")) &&\n \"noMeters\".equals(id.getTag(\"name\"))));\n----\n\n[[micrometer-observation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/metrics.adoc", "title": "metrics", "heading": "Disabling Meters", "heading_level": 3, "file_order": 243, "section_index": 4, "content_hash": "2cd525b5d74cf4c9b28110e114656c83d45dfea0540be83b2115e5aca06391a3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/metrics.adoc"}}
{"id": "sha256:02b1b65e9ed9cbed751e3fc240deb55919472c71e3da86623f24a8fb490a7641", "content": "Starting with version 6.0, Spring Integration utilizes a Micrometer Observation abstraction which can handle metrics as well as https://micrometer.io/docs/tracing[tracing] via appropriate `ObservationHandler` configuration.\n\nThe observation handling is enabled on the `IntegrationManagement` components whenever an `ObservationRegistry` bean is present in the application context and an `@EnableIntegrationManagement` is configured.\nTo customize what set of components should be instrumented, an `observationPatterns()` attribute is exposed on the `@EnableIntegrationManagement` annotation.\nSee its Javadocs for a pattern matching algorithm.\n\nIMPORTANT: By default, none of the `IntegrationManagement` components are instrumented with an `ObservationRegistry` bean.\nCan be configured as `*` to match all components.\n\nThe meters are not gathered in this case independently, but delegated to an appropriate `ObservationHandler` configured on the provided `ObservationRegistry`.\n\nThe following Spring Integration components are instrumented with observation logic each with a respective convention:\n\n* `MessageProducerSupport`, being an inbound endpoint of the flow, is considered as a `CONSUMER` span type and uses the `IntegrationObservation.HANDLER` API;\n* `MessagingGatewaySupport` is an inbound request-reply endpoint, and is considered as a `SERVER` span type.\nIt uses the `IntegrationObservation.GATEWAY` API;\n* An `AbstractMessageChannel.send()` operation is the only Spring Integration API where it produces messages.\nSo, it is treated as a `PRODUCER` span type and uses the `IntegrationObservation.PRODCUER` API.\nThis makes more sense when a channel is a distributed implementation (e.g. `PublishSubscribeKafkaChannel` or `ZeroMqChannel`) and trace information has to be added to the message.\nSo, the `IntegrationObservation.PRODUCER` observation is based on a `MessageSenderContext` where Spring Integration supplies a `MutableMessage` to allow a subsequent tracing `Propagator` to add headers, so they are available to the consumer;\n* An `AbstractMessageHandler` is a `CONSUMER` span type and uses the `IntegrationObservation.HANDLER` API;\n* The `SourcePollingChannelAdapter` (starting with version 6.5), being an inbound endpoint of the flow, is considered as a `CONSUMER` span type and uses the `IntegrationObservation.HANDLER` API.\n\nAn observation production on the `IntegrationManagement` components can be customized via `ObservationConvention` configuration.\nFor example an `AbstractMessageHandler` expects a `MessageReceiverObservationConvention` via its `setObservationConvention()` API.\n\nThe following are supported metrics, spans, and conventions for Observation API:\n\ninclude::partial$metrics.adoc[]\n\ninclude::partial$spans.adoc[]\n\ninclude::partial$conventions.adoc[]\n\n[[observation-propagation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/metrics.adoc", "title": "metrics", "heading": "Micrometer Observation", "heading_level": 2, "file_order": 243, "section_index": 5, "content_hash": "02b1b65e9ed9cbed751e3fc240deb55919472c71e3da86623f24a8fb490a7641", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/metrics.adoc"}}
{"id": "sha256:fc990206ff3e2d037409e8fa6acf2c36f92587143c2e33cf6d115ad0fae48f90", "content": "To supply a connected chain of spans in one trace, independently of the nature of the messaging flow, even if a `MessageChannel` is persistent and distributed, the observation must be enabled on this channel and on consumers (subscribers) for this channel.\nThis way, the tracing information is stored in the message headers before it is propagated to a consumer thread or persisted into the database.\nThis is done via mentioned above `MessageSenderContext`.\nThe consumer (a `MessageHandler`) side restores tracing information from those headers using a `MessageReceiverContext` and starts a new child `Observation`.\n\n[[spring-integration-jmx-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/metrics.adoc", "title": "metrics", "heading": "Observation Propagation", "heading_level": 2, "file_order": 243, "section_index": 6, "content_hash": "fc990206ff3e2d037409e8fa6acf2c36f92587143c2e33cf6d115ad0fae48f90", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/metrics.adoc"}}
{"id": "sha256:73ff18b4d574a2ced997466fe90ede73bb563faf567eb73b9400cce11a8a65b2", "content": "Also see xref:jmx.adoc[JMX Support].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/metrics.adoc", "title": "metrics", "heading": "Spring Integration JMX Support", "heading_level": 2, "file_order": 243, "section_index": 7, "content_hash": "73ff18b4d574a2ced997466fe90ede73bb563faf567eb73b9400cce11a8a65b2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/metrics.adoc"}}
{"id": "sha256:e93501ba156178e306fd085c33d8db4499aee55c82f15a484dac0f3313eaec1f", "content": "[[mongodb]]\n\nVersion 2.1 introduced support for https://www.mongodb.org/[MongoDB]: a \"`high-performance, open source, document-oriented database`\".\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-mongodb</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-mongodb:{project-version}\"\n----\n======\n\nTo download, install, and run MongoDB, see the https://www.mongodb.org/downloads[MongoDB documentation].\n\n[[mongodb-connection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "mongodb", "heading_level": 1, "file_order": 244, "section_index": 0, "content_hash": "e93501ba156178e306fd085c33d8db4499aee55c82f15a484dac0f3313eaec1f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:224228deb550b307e2cad140816543a564b46772eda3f18c5edc5d2ad35a824f", "content": "[[blocking-or-reactive]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "Connecting to MongoDb", "heading_level": 2, "file_order": 244, "section_index": 1, "content_hash": "224228deb550b307e2cad140816543a564b46772eda3f18c5edc5d2ad35a824f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:8ae5a5bc0541176239d95f49d1e2871a94593587472a9cfb2eb610af096edba1", "content": "Beginning with version 5.3, Spring Integration provides support for reactive MongoDB drivers to enable non-blocking I/O when accessing MongoDB.\nTo enable reactive support, add the MongoDB reactive streams driver to your dependencies:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.mongodb</groupId>\n <artifactId>mongodb-driver-reactivestreams</artifactId>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.mongodb:mongodb-driver-reactivestreams\"\n----\n======\n\nFor a regular synchronous client you need to add its respective driver into dependencies:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.mongodb</groupId>\n <artifactId>mongodb-driver-sync</artifactId>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.mongodb:mongodb-driver-sync\"\n----\n======\n\nBoth of them are `optional` in the framework for better end-user choice support.\n\nTo begin interacting with MongoDB, you first need to connect to it.\nSpring Integration builds on the support provided by another Spring project, https://projects.spring.io/spring-data-mongodb/[Spring Data MongoDB].\nIt provides factory classes called `MongoDatabaseFactory` and `ReactiveMongoDatabaseFactory`, which simplify integration with the MongoDB Client API.\n\nTIP: Spring Data provides the blocking MongoDB driver by default, but you may opt in for reactive usage by including the above dependency.\n\n[[using-mongodatabasefactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "Blocking or Reactive?", "heading_level": 3, "file_order": 244, "section_index": 2, "content_hash": "8ae5a5bc0541176239d95f49d1e2871a94593587472a9cfb2eb610af096edba1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:ee09a2b5d6b9b8a4dd7991dff17159577d8b702324f862797d7782a7c711a1c4", "content": "To connect to MongoDB, you can use an implementation of the `MongoDatabaseFactory` interface.\n\nThe following example shows how to use `SimpleMongoClientDatabaseFactory`:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nMongoDatabaseFactory mongoDbFactory =\n new SimpleMongoClientDatabaseFactory(com.mongodb.client.MongoClients.create(), \"test\");\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<bean id=\"mongoDbFactory\" class=\"o.s.data.mongodb.core.SimpleMongoClientDatabaseFactory\">\n <constructor-arg>\n <bean class=\"com.mongodb.client.MongoClients\" factory-method=\"create\"/>\n </constructor-arg>\n <constructor-arg value=\"test\"/>\n</bean>\n----\n======\n\n`SimpleMongoClientDatabaseFactory` takes two arguments: a `MongoClient` instance and a `String` that specifies the name of the database.\nIf you need to configure properties such as `host`, `port`, and others, you can pass those by using one of the constructors provided by the underlying `MongoClients` class.\nFor more information on how to configure MongoDB, see the https://docs.spring.io/spring-data/data-mongo/docs/current/reference/html/[Spring-Data-MongoDB] reference.\n\n[[using-reactivemongodatabasefactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "Using `MongoDatabaseFactory`", "heading_level": 3, "file_order": 244, "section_index": 3, "content_hash": "ee09a2b5d6b9b8a4dd7991dff17159577d8b702324f862797d7782a7c711a1c4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:201dd61ae1d024dac34631861ada2c35856a1cb8f3d5de3f5d5ddca062710b1a", "content": "To connect to MongoDB with the reactive driver, you can use an implementation of the `ReactiveMongoDatabaseFactory` interface.\n\nThe following example shows how to use `SimpleReactiveMongoDatabaseFactory`:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\nReactiveMongoDatabaseFactory mongoDbFactory =\n new SimpleReactiveMongoDatabaseFactory(com.mongodb.reactivestreams.client.MongoClients.create(), \"test\");\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<bean id=\"mongoDbFactory\" class=\"o.s.data.mongodb.core.SimpleReactiveMongoDatabaseFactory\">\n <constructor-arg>\n <bean class=\"com.mongodb.reactivestreams.client.MongoClients\" factory-method=\"create\"/>\n </constructor-arg>\n <constructor-arg value=\"test\"/>\n</bean>\n----\n======\n\n[[mongodb-message-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "Using `ReactiveMongoDatabaseFactory`", "heading_level": 3, "file_order": 244, "section_index": 4, "content_hash": "201dd61ae1d024dac34631861ada2c35856a1cb8f3d5de3f5d5ddca062710b1a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:962c86631bafb214ce676b122e8ae0e80d2ed6ab38e502e17c92c2dd5ead96a7", "content": "As described in the _Enterprise Integration Patterns_ (EIP) book, a https://www.enterpriseintegrationpatterns.com/MessageStore.html[Message Store] lets you persist messages.\nDoing so can be useful when dealing with components that have the ability to buffer messages (`QueueChannel`, `aggregator`, `resequencer`, and others.) if reliability is a concern.\nIn Spring Integration, the `MessageStore` strategy also provides the foundation for the https://www.enterpriseintegrationpatterns.com/StoreInLibrary.html[claim check] pattern, which is described in EIP as well.\n\nSpring Integration's MongoDB module provides the `MongoDbMessageStore`, which is an implementation of both the `MessageStore` strategy (mainly used by the claim check pattern) and the `MessageGroupStore` strategy (mainly used by the aggregator and resequencer patterns).\n\nThe following example configures a `MongoDbMessageStore` to use a `QueueChannel` and an `aggregator`:\n\n[source,xml]\n----\n<bean id=\"mongoDbMessageStore\" class=\"o.s.i.mongodb.store.MongoDbMessageStore\">\n <constructor-arg ref=\"mongoDbFactory\"/>\n</bean>\n\n<int:channel id=\"somePersistentQueueChannel\">\n <int:queue message-store=\"mongoDbMessageStore\"/>\n<int:channel>\n\n<int:aggregator input-channel=\"inputChannel\" output-channel=\"outputChannel\"\n message-store=\"mongoDbMessageStore\"/>\n----\n\nThe preceding example is a simple bean configuration, and it expects a `MongoDbFactory` as a constructor argument.\n\nThe `MongoDbMessageStore` expands the `Message` as a Mongo document with all nested properties by using the Spring Data Mongo mapping mechanism.\nIt is useful when you need to have access to the `payload` or `headers` for auditing or analytics -- for example, against stored messages.\n\nIMPORTANT: The `MongoDbMessageStore` uses a custom `MappingMongoConverter` implementation to store `Message` instances as MongoDB documents, and there are some limitations for the properties (`payload` and `header` values) of the `Message`.\n\nStarting with version 5.1.6, the `MongoDbMessageStore` can be configured with custom converters which are propagated into an internal `MappingMongoConverter` implementation.\nSee `MongoDbMessageStore.setCustomConverters(Object... customConverters)` JavaDocs for more information.\n\nSpring Integration 3.0 introduced the `ConfigurableMongoDbMessageStore`.\nIt implements both the `MessageStore` and `MessageGroupStore` interfaces.\nThis class can receive, as a constructor argument, a `MongoTemplate`, with which you can, for example, configure a custom `WriteConcern`.\nAnother constructor requires a `MappingMongoConverter` and a `MongoDbFactory`, which lets you provide some custom conversions for `Message` instances and their properties.\nNote that, by default, the `ConfigurableMongoDbMessageStore` uses standard Java serialization to write and read `Message` instances to and from MongoDB (see `MongoDbMessageBytesConverter`) and relies on default values for other properties from `MongoTemplate`.\nIt builds a `MongoTemplate` from the provided `MongoDbFactory` and `MappingMongoConverter`.\nThe default name for the collection stored by the `ConfigurableMongoDbMessageStore` is `configurableStoreMessages`.\nWe recommend using this implementation to create robust and flexible solutions when messages contain complex data types.\n\nStarting with version 6.0.8, the `AbstractConfigurableMongoDbMessageStore` provides a `setCreateIndexes(boolean)` (defaults to `true`) option which can be used to disable the auto indexes creation.\nThe following example shows how to declare a bean and disable the auto indexes creation:\n\n[source, java]\n----\n@Bean\npublic MongoDbChannelMessageStore mongoDbChannelMessageStore(MongoDatabaseFactory databaseFactory) {\n MongoDbChannelMessageStore mongoDbChannelMessageStore = new MongoDbChannelMessageStore(databaseFactory);\n mongoDbChannelMessageStore.setCreateIndexes(false);\n return mongoDbChannelMessageStore;\n}\n----\n\n[[mongodb-priority-channel-message-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "MongoDB Message Store", "heading_level": 2, "file_order": 244, "section_index": 5, "content_hash": "962c86631bafb214ce676b122e8ae0e80d2ed6ab38e502e17c92c2dd5ead96a7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:32c7c130fd7a74b51d2470a061150e13de7006601676575d92fa513cf7a09c41", "content": "Version 4.0 introduced the new `MongoDbChannelMessageStore`.\nIt is an optimized `MessageGroupStore` for use in `QueueChannel` instances.\nWith `priorityEnabled = true`, you can use it in `<int:priority-queue>` instances to achieve priority-order polling for persisted messages.\nThe priority MongoDB document field is populated from the `IntegrationMessageHeaderAccessor.PRIORITY` (`priority`) message header.\n\nIn addition, all MongoDB `MessageStore` instances now have a `sequence` field for `MessageGroup` documents.\nThe `sequence` value is the result of an `$inc` operation for a simple `sequence` document from the same collection, which is created on demand.\nThe `sequence` field is used in `poll` operations to provide first-in-first-out (FIFO) message order (within priority, if configured) when messages are stored within the same millisecond.\n\nNOTE: We do not recommend using the same `MongoDbChannelMessageStore` bean for priority and non-priority, because the `priorityEnabled` option applies to the entire store.\nHowever, the same `collection` can be used for both `MongoDbChannelMessageStore` types, because message polling from the store is sorted and uses indexes.\nTo configure that scenario, you can extend one message store bean from the other, as the following example shows:\n\n[source,xml]\n----\n<bean id=\"channelStore\" class=\"o.s.i.mongodb.store.MongoDbChannelMessageStore\">\n <constructor-arg name=\"mongoDbFactory\" ref=\"mongoDbFactory\"/>\n</bean>\n\n<int:channel id=\"queueChannel\">\n <int:queue message-store=\"store\"/>\n</int:channel>\n\n<bean id=\"priorityStore\" parent=\"channelStore\">\n <property name=\"priorityEnabled\" value=\"true\"/>\n</bean>\n\n<int:channel id=\"priorityChannel\">\n <int:priority-queue message-store=\"priorityStore\"/>\n</int:channel>\n----\n[[abstract-configurable-mongodb-message-store-with-auto-index-creation-disable]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "MongoDB Channel Message Store", "heading_level": 3, "file_order": 244, "section_index": 6, "content_hash": "32c7c130fd7a74b51d2470a061150e13de7006601676575d92fa513cf7a09c41", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:baf8725bb0fa5f07d01ad4ba2d22132d9cd3facd5dbe2b82beac67ed1a865435", "content": "Starting with version 6.0.8, the `AbstractConfigurableMongoDbMessageStore` implements a `setCreateIndex(boolean)` which can be used to disable or enable (default) the auto index creation.\nThe following example shows how to declare a bean and disable the auto index creation:\n\n[source, java]\n----\n@Bean\npublic AbstractConfigurableMongoDbMessageStore mongoDbChannelMessageStore(MongoDatabaseFactory databaseFactory)\n{\n AbstractConfigurableMongoDbMessageStore mongoDbChannelMessageStore = new MongoDbChannelMessageStore(databaseFactory);\n mongoDbChannelMessageStore.setCreateIndex(false);\n\n return mongoDbChannelMessageStore;\n}\n----\n\n[[mongodb-metadata-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "Using AbstractConfigurableMongoDbMessageStore with auto index creation disable", "heading_level": 3, "file_order": 244, "section_index": 7, "content_hash": "baf8725bb0fa5f07d01ad4ba2d22132d9cd3facd5dbe2b82beac67ed1a865435", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:af88bf61b6bd9ae5bfeb6cce835072918adf4572b7d466fab929636a9907b344", "content": "Spring Integration 4.2 introduced a new MongoDB-based `MetadataStore` (see xref:meta-data-store.adoc[Metadata Store]) implementation.\nYou can use the `MongoDbMetadataStore` to maintain metadata state across application restarts.\nYou can use this new `MetadataStore` implementation with adapters such as:\n\n* xref:feed.adoc#feed-inbound-channel-adapter[Feed]\n* xref:file/reading.adoc[File]\n* xref:ftp/inbound.adoc[FTP]\n* xref:sftp/inbound.adoc[SFTP]\n\nTo instruct these adapters to use the new `MongoDbMetadataStore`, declare a Spring bean with a bean name of `metadataStore`.\nThe feed inbound channel adapter automatically picks up and use the declared `MongoDbMetadataStore`.\nThe following example shows how to declare a bean with a name of `metadataStore`:\n\n[source,java]\n----\n@Bean\npublic MetadataStore metadataStore(MongoDbFactory factory) {\n return new MongoDbMetadataStore(factory, \"integrationMetadataStore\");\n}\n----\n\nThe `MongoDbMetadataStore` also implements `ConcurrentMetadataStore`, letting it be reliably shared across multiple application instances, where only one instance is allowed to store or modify a key's value.\nAll these operations are atomic, thanks to MongoDB guarantees.\n\n[[mongodb-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "MongoDB Metadata Store", "heading_level": 3, "file_order": 244, "section_index": 8, "content_hash": "af88bf61b6bd9ae5bfeb6cce835072918adf4572b7d466fab929636a9907b344", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:1aad3c326de38ff6dbbebbc55073bcd49aebbcbf5c49109135f85f02cf1db0ec", "content": "The MongoDB inbound channel adapter is a polling consumer that reads data from MongoDB and sends it as a `Message` payload.\nThe following example shows how to configure a MongoDB inbound channel adapter:\n\n[source,xml]\n----\n<int-mongodb:inbound-channel-adapter id=\"mongoInboundAdapter\"\n channel=\"replyChannel\"\n query=\"{'name' : 'Bob'}\"\n entity-class=\"java.lang.Object\"\n auto-startup=\"false\">\n <int:poller fixed-rate=\"100\"/>\n</int-mongodb:inbound-channel-adapter>\n----\n\nAs the preceding configuration shows, you configure a MongoDb inbound channel adapter by using the `inbound-channel-adapter` element and providing values for various attributes, such as:\n\n* `query`: A JSON query (see https://www.mongodb.org/display/DOCS/Querying[MongoDB Querying])\n* `query-expression`: A SpEL expression that is evaluated to a JSON query string (as the `query` attribute above) or to an instance of `o.s.data.mongodb.core.query.Query`.\nMutually exclusive with the `query` attribute.\n* `entity-class`: The type of the payload object.\nIf not supplied, a `com.mongodb.DBObject` is returned.\n* `collection-name` or `collection-name-expression`: Identifies the name of the MongoDB collection to use.\n* `mongodb-factory`: Reference to an instance of `o.s.data.mongodb.MongoDbFactory`\n* `mongo-template`: Reference to an instance of `o.s.data.mongodb.core.MongoTemplate`\n* Other attributes that are common across all others inbound adapters (such as 'channel').\n\nNOTE: You cannot set both `mongo-template` and `mongodb-factory`.\n\nThe preceding example is relatively simple and static, since it has a literal value for the `query` and uses the default name for a `collection`.\nSometimes, you may need to change those values at runtime, based on some condition.\nTo do so, use their `-expression` equivalents (`query-expression` and `collection-name-expression`), where the provided expression can be any valid SpEL expression.\n\nAlso, you may wish to do some post-processing to the successfully processed data that was read from the MongoDB.\nFor example, you may want to move or remove a document after it has been processed.\nYou can do so by using that transaction synchronization feature Spring Integration 2.2 added, as the following example shows:\n\n[source,xml]\n----\n<int-mongodb:inbound-channel-adapter id=\"mongoInboundAdapter\"\n channel=\"replyChannel\"\n query-expression=\"new BasicQuery('{''name'' : ''Bob''}').limit(100)\"\n entity-class=\"java.lang.Object\"\n auto-startup=\"false\">\n <int:poller fixed-rate=\"200\" max-messages-per-poll=\"1\">\n <int:transactional synchronization-factory=\"syncFactory\"/>\n </int:poller>\n</int-mongodb:inbound-channel-adapter>\n\n<int:transaction-synchronization-factory id=\"syncFactory\">\n <int:after-commit\n expression=\"@documentCleaner.remove(#mongoTemplate, payload, headers.mongo_collectionName)\"\n channel=\"someChannel\"/>\n</int:transaction-synchronization-factory>\n\n<bean id=\"documentCleaner\" class=\"thing1.thing2.DocumentCleaner\"/>\n\n<bean id=\"transactionManager\" class=\"o.s.i.transaction.PseudoTransactionManager\"/>\n----\n\nThe following example shows the `DocumentCleaner` referenced in the preceding example:\n\n[source,java]\n----\npublic class DocumentCleaner {\n public void remove(MongoOperations mongoOperations, Object target, String collectionName) {\n if (target instanceof List<?> documents){\n for (Object document : documents) {\n mongoOperations.remove(new BasicQuery(JSON.serialize(document)), collectionName);\n }\n }\n }\n}\n----\n\nYou can declare your poller to be transactional by using the `transactional` element.\nThis element can reference a real transaction manager, for example, if some other part of your flow invokes JDBC.\nIf you do not have a \"`real`\" transaction, you can use an instance of `o.s.i.transaction.PseudoTransactionManager`, which is an implementation of Spring's `PlatformTransactionManager` and enables the use of the transaction synchronization features of the Mongo adapter when there is no actual transaction.\n\nIMPORTANT: Doing so does not make MongoDB itself transactional.\nIt lets the synchronization of actions be taken before or after success (commit) or after failure (rollback).\n\nOnce your poller is transactional, you can set an instance of the `o.s.i.transaction.TransactionSynchronizationFactory` on the `transactional` element.\nA `TransactionSynchronizationFactory` creates an instance of the `TransactionSynchronization`.\nFor your convenience, we have exposed a default SpEL-based `TransactionSynchronizationFactory` that lets you configure SpEL expressions, with their execution being coordinated (synchronized) with a transaction.\nExpressions for before-commit, after-commit, and after-rollback events are supported, together with a channel for each event where the evaluation results (if any) is sent.\nFor each child element, you can specify `expression` and `channel` attributes.\nIf only the `channel` attribute is present, the received message is sent there as part of the particular synchronization scenario.\nIf only the `expression` attribute is present and the result of an expression is a non-null value, a message with the result as the payload is generated and sent to a default channel (`NullChannel`) and appears in the logs (on the `DEBUG` level).\nIf you want the evaluation result to go to a specific channel, add a `channel` attribute.\nIf the result of an expression is null or void, no message is generated.\n\nFor more information about transaction synchronization, see xref:transactions.adoc#transaction-synchronization[Transaction Synchronization].\n\nStarting with version 5.5, the `MongoDbMessageSource` can be configured with an `updateExpression`, which must evaluate to a `String` with the MongoDb `update` syntax or to an `org.springframework.data.mongodb.core.query.Update` instance.\nIt can be used as an alternative to describe the above post-processing procedure, and it modifies those entities that were fetched from the collection, so they won't be pulled from the collection again on the next polling cycle (assuming the update changes some value used in the query).\nIt is still recommended to use transactions to achieve execution isolation and data consistency, when several instances of the `MongoDbMessageSource` for the same collection are used in the cluster.\n\n[[mongodb-change-stream-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "MongoDB Inbound Channel Adapter", "heading_level": 2, "file_order": 244, "section_index": 9, "content_hash": "1aad3c326de38ff6dbbebbc55073bcd49aebbcbf5c49109135f85f02cf1db0ec", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:72ad1f83e72fd82c018245b7af07bc067e1af54ec3c307d72df65cde398c54fa", "content": "Starting with version 5.3, the `spring-integration-mongodb` module introduces the `MongoDbChangeStreamMessageProducer` - a reactive `MessageProducerSupport` implementation for the Spring Data `ReactiveMongoOperations.changeStream(String, ChangeStreamOptions, Class)` API.\nThis component produces a `Flux` of messages with a `body` of `ChangeStreamEvent` as the payload by default and some change stream-related headers (see `MongoHeaders`).\nIt is recommended that this `MongoDbChangeStreamMessageProducer` is combined with a `FluxMessageChannel` as the `outputChannel` for on-demand subscription and event consumption downstream.\n\nThe Java DSL configuration for this channel adapter may look like this:\n\n[source,java]\n----\n@Bean\nIntegrationFlow changeStreamFlow(ReactiveMongoOperations mongoTemplate) {\n return IntegrationFlow.from(\n MongoDb.changeStreamInboundChannelAdapter(mongoTemplate)\n .domainType(Person.class)\n .collection(\"person\")\n .extractBody(false))\n .channel(MessageChannels.flux())\n .get();\n}\n----\n\nWhen the `MongoDbChangeStreamMessageProducer` is stopped, or the subscription is cancelled downstream, or the MongoDb change stream produces an `OperationType.INVALIDATE`, the `Publisher` is completed.\nThe channel adapter can be started again and a new `Publisher` of source data is created, and it is automatically subscribed in the `MessageProducerSupport.subscribeToPublisher(Publisher<? extends Message<?>>)`.\nThis channel adapter can be reconfigured for new options between starts if there is a requirement to consume change stream events from other places.\n\nSee more information about change stream support in the Spring Data MongoDB https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#change-streams[documentation].\n\n[[mongodb-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "MongoDB Change Stream Inbound Channel Adapter", "heading_level": 2, "file_order": 244, "section_index": 10, "content_hash": "72ad1f83e72fd82c018245b7af07bc067e1af54ec3c307d72df65cde398c54fa", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:da483e1bb0920096ff66307a447b8fb9ae3d669e970727987fca449a31ee7573", "content": "The MongoDB outbound channel adapter lets you write the message payload to a MongoDB document store, as the following example shows:\n\n[source,xml]\n----\n<int-mongodb:outbound-channel-adapter id=\"fullConfigWithCollectionExpression\"\n\tcollection-name=\"myCollection\"\n\tmongo-converter=\"mongoConverter\"\n\tmongodb-factory=\"mongoDbFactory\" />\n----\n\nAs the preceding configuration shows, you can configure a MongoDB outbound channel adapter by using the `outbound-channel-adapter` element, providing values for various attributes, such as:\n\n* `collection-name` or `collection-name-expression`: Identifies the name of the MongoDb collection to use.\n* `mongo-converter`: Reference to an instance of `o.s.data.mongodb.core.convert.MongoConverter` that assists with converting a raw Java object to a JSON document representation.\n* `mongodb-factory`: Reference to an instance of `o.s.data.mongodb.MongoDbFactory`.\n* `mongo-template`: Reference to an instance of `o.s.data.mongodb.core.MongoTemplate`.\nNOTE: you cannot have both `mongo-template` and `mongodb-factory` set.\n* Other attributes that are common across all inbound adapters (such as 'channel').\n\nThe preceding example is relatively simple and static, since it has a literal value for the `collection-name`.\nSometimes, you may need to change this value at runtime, based on some condition.\nTo do that, use `collection-name-expression`, where the provided expression is any valid SpEL expression.\n\n[[mongodb-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "MongoDB Outbound Channel Adapter", "heading_level": 2, "file_order": 244, "section_index": 11, "content_hash": "da483e1bb0920096ff66307a447b8fb9ae3d669e970727987fca449a31ee7573", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:98bff125e17977c01bf77339c76fb8df421df441b768083017bca9489816e3f2", "content": "Version 5.0 introduced the MongoDB outbound gateway.\nIt allows you to query a database by sending a message to its request channel.\nThe gateway then sends the response to the reply channel.\nYou can use the message payload and headers to specify the query and the collection name, as the following example shows:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@SpringBootApplication\npublic class MongoDbJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(MongoDbJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Autowired\n private MongoDbFactory;\n\n @Autowired\n private MongoConverter;\n\n @Bean\n public IntegrationFlow gatewaySingleQueryFlow() {\n return f -> f\n .handle(queryOutboundGateway())\n .channel(c -> c.queue(\"retrieveResults\"));\n }\n\n private MongoDbOutboundGatewaySpec queryOutboundGateway() {\n return MongoDb.outboundGateway(this.mongoDbFactory, this.mongoConverter)\n .query(\"{name : 'Bob'}\")\n .collectionNameFunction(m -> m.getHeaders().get(\"collection\"))\n .expectSingleResult(true)\n .entityClass(Person.class);\n }\n\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\nclass MongoDbKotlinApplication {\n\n fun main(args: Array<String>) = runApplication<MongoDbKotlinApplication>(*args)\n\n @Autowired\n lateinit var mongoDbFactory: MongoDatabaseFactory\n\n @Autowired\n lateinit var mongoConverter: MongoConverter\n\n @Bean\n fun gatewaySingleQueryFlow() =\n integrationFlow {\n handle(queryOutboundGateway())\n channel { queue(\"retrieveResults\") }\n }\n\n private fun queryOutboundGateway(): MongoDbOutboundGatewaySpec {\n return MongoDb.outboundGateway(this.mongoDbFactory, this.mongoConverter)\n .query(\"{name : 'Bob'}\")\n .collectionNameFunction<Any> { m -> m.headers[\"collection\"] as String }\n .expectSingleResult(true)\n .entityClass(Person::class.java)\n }\n\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@SpringBootApplication\npublic class MongoDbJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(MongoDbJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Autowired\n private MongoDbFactory mongoDbFactory;\n\n @Bean\n @ServiceActivator(inputChannel = \"requestChannel\")\n public MessageHandler mongoDbOutboundGateway() {\n MongoDbOutboundGateway gateway = new MongoDbOutboundGateway(this.mongoDbFactory);\n gateway.setCollectionNameExpressionString(\"'myCollection'\");\n gateway.setQueryExpressionString(\"'{''name'' : ''Bob''}'\");\n gateway.setExpectSingleResult(true);\n gateway.setEntityClass(Person.class);\n gateway.setOutputChannelName(\"replyChannel\");\n return gateway;\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"replyChannel\")\n public MessageHandler handler() {\n return message -> System.out.println(message.getPayload());\n }\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-mongodb:outbound-gateway id=\"gatewayQuery\"\n mongodb-factory=\"mongoDbFactory\"\n mongo-converter=\"mongoConverter\"\n query=\"{firstName: 'Bob'}\"\n collection-name=\"myCollection\"\n request-channel=\"in\"\n reply-channel=\"out\"\n entity-class=\"org.springframework.integration.mongodb.test.entity$Person\"/>\n----\n======\n\nYou can use the following attributes with a MongoDB outbound Gateway:\n\n* `collection-name` or `collection-name-expression`: Identifies the name of the MongoDB collection to use.\n* `mongo-converter`: Reference to an instance of `o.s.data.mongodb.core.convert.MongoConverter` that assists with converting a raw Java object to a JSON document representation.\n* `mongodb-factory`: Reference to an instance of `o.s.data.mongodb.MongoDbFactory`.\n* `mongo-template`: Reference to an instance of `o.s.data.mongodb.core.MongoTemplate`.\nNOTE: you can not set both `mongo-template` and `mongodb-factory`.\n* `entity-class`: The fully qualified name of the entity class to be passed to the `find(..)` and `findOne(..)` methods in MongoTemplate.\nIf this attribute is not provided, the default value is `org.bson.Document`.\n* `query` or `query-expression`: Specifies the MongoDB query.\nSee the https://www.mongodb.org/display/DOCS/Querying[MongoDB documentation] for more query samples.\n* `collection-callback`: Reference to an instance of `org.springframework.data.mongodb.core.CollectionCallback`.\nPreferable an instance of `o.s.i.mongodb.outbound.MessageCollectionCallback` since 5.0.11 with the request message context.\nSee its Javadocs for more information.\nNOTE: You cannot have both `collection-callback` and any of the query attributes.\n\nAs an alternate to the `query` and `query-expression` properties, you can specify other database operations by using the `collectionCallback` property as a reference to the `MessageCollectionCallback` functional interface implementation.\nThe following example specifies a count operation:\n\n[source, java]\n----\nprivate MongoDbOutboundGatewaySpec collectionCallbackOutboundGateway() {\n return MongoDb.outboundGateway(this.mongoDbFactory, this.mongoConverter)\n .collectionCallback((collection, requestMessage) -> collection.count())\n .collectionName(\"myCollection\");\n}\n----\n\n[[mongodb-reactive-channel-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "MongoDB Outbound Gateway", "heading_level": 2, "file_order": 244, "section_index": 12, "content_hash": "98bff125e17977c01bf77339c76fb8df421df441b768083017bca9489816e3f2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:779b749957999fbf49601f0b09a6e0aac91290f10556d41986d4bf365415a538", "content": "Starting with version 5.3, the `ReactiveMongoDbStoringMessageHandler` and `ReactiveMongoDbMessageSource` implementations are provided.\nThey are based on the `ReactiveMongoOperations` from Spring Data and requires a `org.mongodb:mongodb-driver-reactivestreams` dependency.\n\nThe `ReactiveMongoDbStoringMessageHandler` is an implementation of the `ReactiveMessageHandler` which is supported natively in the framework when reactive streams composition is involved in the integration flow definition.\nSee more information in the xref:reactive-streams.adoc#reactive-message-handler[ReactiveMessageHandler].\n\nFrom a configuration perspective, there is no difference with many other standard channel adapters.\nFor example, with Java DSL such a channel adapter could be used like:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow reactiveMongoDbFlow(ReactiveMongoDatabaseFactory mongoDbFactory) {\n return f -> f\n .channel(MessageChannels.flux())\n .handle(MongoDb.reactiveOutboundChannelAdapter(mongoDbFactory));\n}\n----\n\nIn this sample we are going to connect to the MongoDb via provided `ReactiveMongoDatabaseFactory` and store a data from request message into a default collection with the `data` name.\nThe real operation is going to be performed on-demand from the reactive stream composition in the internally created `ReactiveStreamsConsumer`.\n\nThe `ReactiveMongoDbMessageSource` is an `AbstractMessageSource` implementation based on the provided `ReactiveMongoDatabaseFactory` or `ReactiveMongoOperations` and MongoDb query (or expression), calls `find()` or `findOne()` operation according an `expectSingleResult` option with an expected `entityClass` type to convert a query result.\nA query execution and result evaluation is performed on demand when `Publisher` (`Flux` or `Mono` according `expectSingleResult` option) in the payload of a produced message is subscribed.\nThe framework can subscribe to such a payload automatically (essentially `flatMap`) when splitter and `FluxMessageChannel` are used downstream.\nOtherwise, it is target application responsibility to subscribe into a polled publisher in downstream endpoints.\n\nWith Java DSL such a channel adapter could be configured like:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow reactiveMongoDbFlow(ReactiveMongoDatabaseFactory mongoDbFactory) {\n return IntegrationFlow\n .from(MongoDb.reactiveInboundChannelAdapter(mongoDbFactory, \"{'name' : 'Name'}\")\n .entityClass(Person.class),\n c -> c.poller(Pollers.fixedDelay(1000)))\n .split()\n .channel(c -> c.flux(\"output\"))\n .get();\n}\n----\n\nStarting with version 5.5, the `ReactiveMongoDbMessageSource` can be configured with an `updateExpression`.\nIt has the same functionality as the blocking `MongoDbMessageSource`.\nSee xref:mongodb.adoc#mongodb-inbound-channel-adapter[MongoDB Inbound Channel Adapter] and `AbstractMongoDbMessageSourceSpec` JavaDocs for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mongodb.adoc", "title": "mongodb", "heading": "MongoDB Reactive Channel Adapters", "heading_level": 2, "file_order": 244, "section_index": 13, "content_hash": "779b749957999fbf49601f0b09a6e0aac91290f10556d41986d4bf365415a538", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mongodb.adoc"}}
{"id": "sha256:81ab184188fa672891255348845d5f33e0db1bfe936c4ff20eafb579f456af3d", "content": "[[mqtt]]\n\nSpring Integration provides inbound and outbound channel adapters to support the Message Queueing Telemetry Transport (MQTT) protocol.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-mqtt</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-mqtt:{project-version}\"\n----\n======\n\nThe current implementation uses the https://www.eclipse.org/paho/[Eclipse Paho MQTT Client] library.\nStarting with version 6.5, the `org.eclipse.paho:org.eclipse.paho.client.mqttv3` dependency is an `optional` dependency, so has to be included explicitly in the target project for MQTT v3 support.\n\nIMPORTANT: The XML configuration and most of this chapter are about MQTT v3.1 protocol support and the respective Paho Client.\nSee xref:mqtt.adoc#mqtt-v5[MQTT v5 Support] paragraph for respective protocol support.\n\nConfiguration of both adapters is achieved using the `DefaultMqttPahoClientFactory`.\nRefer to the Paho documentation for more information about configuration options.\n\nNOTE: We recommend configuring an `MqttConnectOptions` object and injecting it into the factory, instead of setting the (deprecated) options on the factory itself.\n\n[[mqtt-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mqtt.adoc", "title": "mqtt", "heading": "mqtt", "heading_level": 1, "file_order": 245, "section_index": 0, "content_hash": "81ab184188fa672891255348845d5f33e0db1bfe936c4ff20eafb579f456af3d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mqtt.adoc"}}
{"id": "sha256:e775d9b1ad3e561723c389087a3e196aa694214358df1488822fc0c6d3aa84f1", "content": "The inbound channel adapter is implemented by the `MqttPahoMessageDrivenChannelAdapter`.\nFor convenience, you can configure it by using the namespace.\nA minimal configuration might be as follows:\n\n[source,xml]\n----\n<bean id=\"clientFactory\"\n class=\"org.springframework.integration.mqtt.core.DefaultMqttPahoClientFactory\">\n <property name=\"connectionOptions\">\n <bean class=\"org.eclipse.paho.client.mqttv3.MqttConnectOptions\">\n <property name=\"userName\" value=\"${mqtt.username}\"/>\n <property name=\"password\" value=\"${mqtt.password}\"/>\n </bean>\n </property>\n</bean>\n\n<int-mqtt:message-driven-channel-adapter id=\"mqttInbound\"\n client-id=\"${mqtt.default.client.id}.src\"\n url=\"${mqtt.url}\"\n topics=\"sometopic\"\n client-factory=\"clientFactory\"\n channel=\"output\"/>\n----\n\nThe following listing shows the available attributes:\n\n[source,xml]\n----\n<int-mqtt:message-driven-channel-adapter id=\"oneTopicAdapter\"\n client-id=\"foo\" <1>\n url=\"tcp://localhost:1883\" <2>\n topics=\"bar,baz\" <3>\n qos=\"1,2\" <4>\n converter=\"myConverter\" <5>\n client-factory=\"clientFactory\" <6>\n send-timeout=\"123\" <7>\n error-channel=\"errors\" <8>\n recovery-interval=\"10000\" <9>\n manual-acks=\"false\" <10>\n channel=\"out\" />\n----\n\n<1> The client ID.\n<2> The broker URL.\n<3> A comma-separated list of topics from which this adapter receives messages.\n<4> A comma-separated list of QoS values.\nIt can be a single value that is applied to all topics or a value for each topic, in which case, the lists must be the same length.\n<5> An `MqttMessageConverter` (optional).\nBy default, the default `DefaultPahoMessageConverter` produces a message with a `String` payload with the following headers:\n* `mqtt_topic`: The topic from which the message was received\n* `mqtt_duplicate`: `true` if the message is a duplicate\n* `mqtt_qos`: The quality of service\nYou can configure the `DefaultPahoMessageConverter` to return the raw `byte[]` in the payload by declaring it as a `<bean/>` and setting the `payloadAsBytes` property to `true`.\n<6> The client factory.\n<7> The `send()` timeout.\nIt applies only if the channel might block (such as a bounded `QueueChannel` that is currently full).\n<8> The error channel.\nDownstream exceptions are sent to this channel, if supplied, in an `ErrorMessage`.\nThe payload is a `MessagingException` that contains the failed message and cause.\n<9> The recovery interval.\nIt controls the interval at which the adapter attempts to reconnect after a failure.\nIt defaults to `10000ms` (ten seconds).\n<10> The acknowledgment mode; set to true for manual acknowledgment.\n\nNOTE: Starting with version 4.1, you can omit the URL.\nInstead, you can provide the server URIs in the `serverURIs` property of the `DefaultMqttPahoClientFactory`.\nDoing so enables, for example, connection to a highly available (HA) cluster.\n\nStarting with version 4.2.2, an `MqttSubscribedEvent` is published when the adapter successfully subscribes to the topics.\n`MqttConnectionFailedEvent` events are published when the connection or subscription fails.\nThese events can be received by a bean that implements `ApplicationListener`.\n\nAlso, a new property called `recoveryInterval` controls the interval at which the adapter attempts to reconnect after a failure.\nIt defaults to `10000ms` (ten seconds).\n\n[NOTE]\n====\nPrior to version 4.2.3, the client always unsubscribed when the adapter was stopped.\nThis was incorrect because, if the client QOS is greater than 0, we need to keep the subscription active so that messages arriving\nwhile the adapter is stopped are delivered on the next start.\nThis also requires setting the `cleanSession` property on the client factory to `false`.\nIt defaults to `true`.\n\nStarting with version 4.2.3, the adapter does not unsubscribe (by default) if the `cleanSession` property is `false`.\n\nThis behavior can be overridden by setting the `consumerCloseAction` property on the factory.\nIt can have values: `UNSUBSCRIBE_ALWAYS`, `UNSUBSCRIBE_NEVER`, and `UNSUBSCRIBE_CLEAN`.\nThe latter (the default) unsubscribes only if the `cleanSession` property is `true`.\n\nTo revert to the pre-4.2.3 behavior, use `UNSUBSCRIBE_ALWAYS`.\n====\n\n[IMPORTANT]\n====\nStarting with version 5.0, the `topic`, `qos`, and `retained` properties are mapped to `.RECEIVED_...` headers (`MqttHeaders.RECEIVED_TOPIC`, `MqttHeaders.RECEIVED_QOS`, and `MqttHeaders.RECEIVED_RETAINED`), to avoid inadvertent propagation to an outbound message that (by default) uses the `MqttHeaders.TOPIC`, `MqttHeaders.QOS`, and `MqttHeaders.RETAINED` headers.\n====\n\n[[adding-and-removing-topics-at-runtime]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mqtt.adoc", "title": "mqtt", "heading": "Inbound (Message-driven) Channel Adapter", "heading_level": 2, "file_order": 245, "section_index": 1, "content_hash": "e775d9b1ad3e561723c389087a3e196aa694214358df1488822fc0c6d3aa84f1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mqtt.adoc"}}
{"id": "sha256:3a526fa80f036273d45363966fa55d0289dd912a52e887ff2a482fd09186962f", "content": "Starting with version 4.1, you can programmatically change the topics to which the adapter is subscribed.\nSpring Integration provides the `addTopic()` and `removeTopic()` methods.\nWhen adding topics, you can optionally specify the `QoS` (default: 1).\nYou can also modify the topics by sending an appropriate message to a `<control-bus/>` with an appropriate payload -- for example: `\"myMqttAdapter.addTopic('foo', 1)\"`.\n\nStopping and starting the adapter has no effect on the topic list (it does not revert to the original settings in the configuration).\nThe changes are not retained beyond the life cycle of the application context.\nA new application context reverts to the configured settings.\n\nChanging the topics while the adapter is stopped (or disconnected from the broker) takes effect the next time a connection is established.\n\n[[mqtt-ack-mode]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mqtt.adoc", "title": "mqtt", "heading": "Adding and Removing Topics at Runtime", "heading_level": 3, "file_order": 245, "section_index": 2, "content_hash": "3a526fa80f036273d45363966fa55d0289dd912a52e887ff2a482fd09186962f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mqtt.adoc"}}
{"id": "sha256:fc8e0b08406b5e47211491a5599577a977c39e42ccb75699c7278e772face17d", "content": "Starting with version 5.3, you can set the `manualAcks` property to true.\nOften used to asynchronously acknowledge delivery.\nWhen set to `true`, header (`IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK`) is added to the message with the value being a `SimpleAcknowledgment`.\nYou must invoke the `acknowledge()` method to complete the delivery.\nSee the Javadocs for `IMqttClient` `setManualAcks()` and `messageArrivedComplete()` for more information.\nFor convenience a header accessor is provided:\n\n[source, java]\n----\nStaticMessageHeaderAccessor.acknowledgment(someMessage).acknowledge();\n----\n\nStarting with version `5.2.11`, when the message converter throws an exception or returns `null` from the `MqttMessage` conversion, the `MqttPahoMessageDrivenChannelAdapter` sends an `ErrorMessage` into the `errorChannel`, if provided.\nRe-throws this conversion error otherwise into an MQTT client callback.\n\n[[mqtt-ack-mode-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mqtt.adoc", "title": "mqtt", "heading": "Manual Acks", "heading_level": 3, "file_order": 245, "section_index": 3, "content_hash": "fc8e0b08406b5e47211491a5599577a977c39e42ccb75699c7278e772face17d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mqtt.adoc"}}
{"id": "sha256:7713146e18fce50889c3399824b4437872330d1c89bd397cb058af023e79d45f", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with Java configuration:\n\n[source, java]\n----\n@SpringBootApplication\npublic class MqttJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(MqttJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public MessageChannel mqttInputChannel() {\n return new DirectChannel();\n }\n\n @Bean\n public MessageProducer inbound() {\n MqttPahoMessageDrivenChannelAdapter adapter =\n new MqttPahoMessageDrivenChannelAdapter(\"tcp://localhost:1883\", \"testClient\",\n \"topic1\", \"topic2\");\n adapter.setCompletionTimeout(5000);\n adapter.setConverter(new DefaultPahoMessageConverter());\n adapter.setQos(1);\n adapter.setOutputChannel(mqttInputChannel());\n return adapter;\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"mqttInputChannel\")\n public MessageHandler handler() {\n return new MessageHandler() {\n\n @Override\n public void handleMessage(Message<?> message) throws MessagingException {\n System.out.println(message.getPayload());\n }\n\n };\n }\n\n}\n----\n\n[[mqtt-ack-mode-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mqtt.adoc", "title": "mqtt", "heading": "Configuring with Java Configuration", "heading_level": 3, "file_order": 245, "section_index": 4, "content_hash": "7713146e18fce50889c3399824b4437872330d1c89bd397cb058af023e79d45f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mqtt.adoc"}}
{"id": "sha256:6c2129285ad324c2acc490f2f38c55db53939a37bb567388888a171dae0071d3", "content": "The following Spring Boot application provides an example of configuring the inbound adapter with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class MqttJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(MqttJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public IntegrationFlow mqttInbound() {\n return IntegrationFlow.from(\n new MqttPahoMessageDrivenChannelAdapter(\"tcp://localhost:1883\",\n \"testClient\", \"topic1\", \"topic2\"))\n .handle(m -> System.out.println(m.getPayload()))\n .get();\n }\n\n}\n----\n\n[[mqtt-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mqtt.adoc", "title": "mqtt", "heading": "Configuring with the Java DSL", "heading_level": 3, "file_order": 245, "section_index": 5, "content_hash": "6c2129285ad324c2acc490f2f38c55db53939a37bb567388888a171dae0071d3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mqtt.adoc"}}
{"id": "sha256:967a7aeb95f66e8dafe868f87a55db4971144a1cb17a8fd341bca241a68c9e53", "content": "The outbound channel adapter is implemented by the `MqttPahoMessageHandler`, which is wrapped in a `ConsumerEndpoint`.\nFor convenience, you can configure it by using the namespace.\n\nStarting with version 4.1, the adapter supports asynchronous send operations, avoiding blocking until the delivery is confirmed.\nYou can emit application events to enable applications to confirm delivery if desired.\n\nThe following listing shows the attributes available for an outbound channel adapter:\n\n[source,xml]\n----\n<int-mqtt:outbound-channel-adapter id=\"withConverter\"\n client-id=\"foo\" <1>\n url=\"tcp://localhost:1883\" <2>\n converter=\"myConverter\" <3>\n client-factory=\"clientFactory\" <4>\n default-qos=\"1\" <5>\n qos-expression=\"\" <6>\n default-retained=\"true\" <7>\n retained-expression=\"\" <8>\n default-topic=\"bar\" <9>\n topic-expression=\"\" <10>\n async=\"false\" <11>\n async-events=\"false\" <12>\n channel=\"target\" />\n----\n\n<1> The client ID.\n<2> The broker URL.\n<3> An `MqttMessageConverter` (optional).\nThe default `DefaultPahoMessageConverter` recognizes the following headers:\n* `mqtt_topic`: The topic to which the message will be sent\n* `mqtt_retained`: `true` if the message is to be retained\n* `mqtt_qos`: The quality of service\n<4> The client factory.\n<5> The default quality of service.\nIt is used if no `mqtt_qos` header is found or the `qos-expression` returns `null`.\nIt is not used if you supply a custom `converter`.\n<6> An expression to evaluate to determine the qos.\nThe default is `headers[mqtt_qos]`.\n<7> The default value of the retained flag.\nIt is used if no `mqtt_retained` header is found.\nIt is not used if a custom `converter` is supplied.\n<8> An expression to evaluate to determine the retained boolean.\nThe default is `headers[mqtt_retained]`.\n<9> The default topic to which the message is sent (used if no `mqtt_topic` header is found).\n<10> An expression to evaluate to determine the destination topic.\nThe default is `headers['mqtt_topic']`.\n<11> When `true`, the caller does not block.\nRather, it waits for delivery confirmation when a message is sent.\nThe default is `false` (the send blocks until delivery is confirmed).\n<12> When `async` and `async-events` are both `true`, an `MqttMessageSentEvent` is emitted (See xref:mqtt.adoc#mqtt-events[Events]).\nIt contains the message, the topic, the `messageId` generated by the client library, the `clientId`, and the `clientInstance` (incremented each time the client is connected).\nWhen the delivery is confirmed by the client library, an `MqttMessageDeliveredEvent` is emitted.\nIt contains the `messageId`, the `clientId`, and the `clientInstance`, enabling delivery to be correlated with the `send()`.\nAny `ApplicationListener` or an event inbound channel adapter can receive these events.\nNote that it is possible for the `MqttMessageDeliveredEvent` to be received before the `MqttMessageSentEvent`.\nThe default is `false`.\n\nNOTE: Starting with version 4.1, the URL can be omitted.\nInstead, the server URIs can be provided in the `serverURIs` property of the `DefaultMqttPahoClientFactory`.\nThis enables, for example, connection to a highly available (HA) cluster.\n\n[[mqtt-outbound-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mqtt.adoc", "title": "mqtt", "heading": "Outbound Channel Adapter", "heading_level": 2, "file_order": 245, "section_index": 6, "content_hash": "967a7aeb95f66e8dafe868f87a55db4971144a1cb17a8fd341bca241a68c9e53", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mqtt.adoc"}}
{"id": "sha256:b8bed3af003fcc5b5ed9e27e121ed70b708374f43df1fdc83cde2b7dd94a7b2d", "content": "The following Spring Boot application shows an example of how to configure the outbound adapter with Java configuration:\n\n[source, java]\n----\n@SpringBootApplication\n@IntegrationComponentScan\npublic class MqttJavaApplication {\n\n public static void main(String[] args) {\n ConfigurableApplicationContext context =\n new SpringApplicationBuilder(MqttJavaApplication.class)\n .web(false)\n .run(args);\n MyGateway gateway = context.getBean(MyGateway.class);\n gateway.sendToMqtt(\"foo\");\n }\n\n @Bean\n public MqttPahoClientFactory mqttClientFactory() {\n DefaultMqttPahoClientFactory factory = new DefaultMqttPahoClientFactory();\n MqttConnectOptions options = new MqttConnectOptions();\n options.setServerURIs(new String[] { \"tcp://host1:1883\", \"tcp://host2:1883\" });\n options.setUserName(\"username\");\n options.setPassword(\"password\".toCharArray());\n factory.setConnectionOptions(options);\n return factory;\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"mqttOutboundChannel\")\n public MessageHandler mqttOutbound() {\n MqttPahoMessageHandler messageHandler =\n new MqttPahoMessageHandler(\"testClient\", mqttClientFactory());\n messageHandler.setAsync(true);\n messageHandler.setDefaultTopic(\"testTopic\");\n return messageHandler;\n }\n\n @Bean\n public MessageChannel mqttOutboundChannel() {\n return new DirectChannel();\n }\n\n @MessagingGateway(defaultRequestChannel = \"mqttOutboundChannel\")\n public interface MyGateway {\n\n void sendToMqtt(String data);\n\n }\n\n}\n----\n\n[[mqtt-outbound-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mqtt.adoc", "title": "mqtt", "heading": "Configuring with Java Configuration", "heading_level": 3, "file_order": 245, "section_index": 7, "content_hash": "b8bed3af003fcc5b5ed9e27e121ed70b708374f43df1fdc83cde2b7dd94a7b2d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mqtt.adoc"}}
{"id": "sha256:da513196bd8aff8e92508761d2d3a760b0d6c50818d64707f9aecf0324048e79", "content": "The following Spring Boot application provides an example of configuring the outbound adapter with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class MqttJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(MqttJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public IntegrationFlow mqttOutboundFlow() {\n return f -> f.handle(new MqttPahoMessageHandler(\"tcp://host1:1883\", \"someMqttClient\"));\n }\n\n}\n----\n\n[[mqtt-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mqtt.adoc", "title": "mqtt", "heading": "Configuring with the Java DSL", "heading_level": 3, "file_order": 245, "section_index": 8, "content_hash": "da513196bd8aff8e92508761d2d3a760b0d6c50818d64707f9aecf0324048e79", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mqtt.adoc"}}
{"id": "sha256:1e93c6e5507ffb2748d947f829ed589ce7f388d807dffe59915a673ad8560eee", "content": "Certain application events are published by the adapters.\n\n* `MqttConnectionFailedEvent` - published by both adapters if we fail to connect or a connection is subsequently lost.\nFor the MQTT v5 Paho client, this event is also emitted when the server performs a normal disconnection, in which case the `cause` of the lost connection is `null`.\n* `MqttMessageSentEvent` - published by the outbound adapter when a message has been sent, if running in asynchronous mode.\n* `MqttMessageDeliveredEvent` - published by the outbound adapter when the client indicates that a message has been delivered if running in asynchronous mode.\n* `MqttMessageNotDeliveredEvent` - published by the outbound adapter when the client indicates that a message has not been delivered if running in asynchronous mode.\n* `MqttSubscribedEvent` - published by the inbound adapter after subscribing to the topics.\n\nThese events can be received by an `ApplicationListener<MqttIntegrationEvent>` or with an `@EventListener` method.\n\nTo determine the source of an event, use the following; you can check the bean name and/or the connect options (to access the server URIs etc).\n\n[source, java]\n----\nMqttPahoComponent source = event.getSourceAsType();\nString beanName = source.getBeanName();\nMqttConnectOptions options = source.getConnectionInfo();\n----\n\n[[mqtt-v5]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mqtt.adoc", "title": "mqtt", "heading": "Events", "heading_level": 2, "file_order": 245, "section_index": 9, "content_hash": "1e93c6e5507ffb2748d947f829ed589ce7f388d807dffe59915a673ad8560eee", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mqtt.adoc"}}
{"id": "sha256:918db8c1f505665518c88d211f91c64d54c56d296bb86b33c99e7673aae2aaf4", "content": "Starting with version 5.5.5, the `spring-integration-mqtt` module provides channel adapter implementations for the MQTT v5 protocol.\nThe `org.eclipse.paho:org.eclipse.paho.mqttv5.client` is an `optional` dependency, so has to be included explicitly in the target project.\n\nSince the MQTT v5 protocol supports extra arbitrary properties in an MQTT message, the `MqttHeaderMapper` implementation has been introduced to map to/from headers on publish and receive operations.\nBy default, (via the `*` pattern) it maps all the received `PUBLISH` frame properties (including user properties).\nOn the outbound side it maps this subset of headers for `PUBLISH` frame: `contentType`, `mqtt_messageExpiryInterval`, `mqtt_responseTopic`, `mqtt_correlationData`.\n\nThe outbound channel adapter for the MQTT v5 protocol is present as an `Mqttv5PahoMessageHandler`.\nIt requires a `clientId` and MQTT broker URL or `MqttConnectionOptions` reference.\nIt supports a `MqttClientPersistence` option, can be `async` and can emit `MqttIntegrationEvent` objects in that case (see `asyncEvents` option).\nIf a request message payload is an `org.eclipse.paho.mqttv5.common.MqttMessage`, it is published as is via the internal `IMqttAsyncClient`.\nIf the payload is `byte[]` it is used as is for the target `MqttMessage` payload to publish.\nIf the payload is a `String` it is converted to `byte[]` to publish.\nThe remaining use-cases are delegated to the provided `MessageConverter` which is a `IntegrationContextUtils.ARGUMENT_RESOLVER_MESSAGE_CONVERTER_BEAN_NAME` `ConfigurableCompositeMessageConverter` bean from the application context.\nNote: the provided `HeaderMapper<MqttProperties>` is not used when the requested message payload is already an `MqttMessage`.\nThe following Java DSL configuration sample demonstrates how to use this channel adapter in the integration flow:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow mqttOutFlow() {\n Mqttv5PahoMessageHandler messageHandler = new Mqttv5PahoMessageHandler(MQTT_URL, \"mqttv5SIout\");\n MqttHeaderMapper mqttHeaderMapper = new MqttHeaderMapper();\n mqttHeaderMapper.setOutboundHeaderNames(\"some_user_header\", MessageHeaders.CONTENT_TYPE);\n messageHandler.setHeaderMapper(mqttHeaderMapper);\n messageHandler.setAsync(true);\n messageHandler.setAsyncEvents(true);\n messageHandler.setConverter(mqttStringToBytesConverter());\n\n return f -> f.handle(messageHandler);\n}\n----\n\nIMPORTANT: The `org.springframework.integration.mqtt.support.MqttMessageConverter` cannot be used with the `Mqttv5PahoMessageHandler` since its contract is aimed only for the MQTT v3 protocol.\n\nIf connection fails on startup or at runtime, the `Mqttv5PahoMessageHandler` tries to reconnect on the next message produced to this handler.\nIf this manual reconnection fails, the connection is exception is thrown back to the caller.\nIn this case the standard Spring Integration error handling procedure is applied, including request handler advices, e.g. retry or circuit breaker.\n\nSee more information in the `Mqttv5PahoMessageHandler` javadocs and its superclass.\n\nThe inbound channel adapter for the MQTT v5 protocol is present as an `Mqttv5PahoMessageDrivenChannelAdapter`.\nIt requires a `clientId` and MQTT broker URL or `MqttConnectionOptions` reference, plus topics to which to subscribe and consume from.\nIt supports a `MqttClientPersistence` option, which is in-memory by default.\nThe expected `payloadType` (`byte[]` by default) can be configured, and it is propagated to the provided `SmartMessageConverter` for conversion from `byte[]` of the received `MqttMessage`.\nIf the `manualAck` option is set, then an `IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK` header is added to the message to produce as an instance of `SimpleAcknowledgment`.\nThe `HeaderMapper<MqttProperties>` is used to map `PUBLISH` frame properties (including user properties) into the target message headers.\nStandard `MqttMessage` properties, such as `qos`, `id`, `dup`, `retained`, plus received topic are always mapped to headers.\nSee `MqttHeaders` for more information.\n\nStarting with version 6.3, the `Mqttv5PahoMessageDrivenChannelAdapter` provides constructors based on the `MqttSubscription` for fine-grained configuration instead of plain topic names.\nWhen these subscriptions are provided, the `qos` option of the channel adapter cannot be used, since such a `qos` mode is a part of `MqttSubscription` API.\n\nThe following Java DSL configuration sample demonstrates how to use this channel adapter in the integration flow:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow mqttInFlow() {\n Mqttv5PahoMessageDrivenChannelAdapter messageProducer =\n new Mqttv5PahoMessageDrivenChannelAdapter(MQTT_URL, \"mqttv5SIin\", \"siTest\");\n messageProducer.setPayloadType(String.class);\n messageProducer.setMessageConverter(mqttStringToBytesConverter());\n messageProducer.setManualAcks(true);\n\n return IntegrationFlow.from(messageProducer)\n .channel(c -> c.queue(\"fromMqttChannel\"))\n .get();\n}\n----\n\nIMPORTANT: The `org.springframework.integration.mqtt.support.MqttMessageConverter` cannot be used with the `Mqttv5PahoMessageDrivenChannelAdapter` since its contract is aimed only for the MQTT v3 protocol.\n\nSee more information in the `Mqttv5PahoMessageDrivenChannelAdapter` javadocs and its superclass.\n\nIMPORTANT: It is recommended to have the `MqttConnectionOptions#setAutomaticReconnect(boolean)` set to true to let an internal `IMqttAsyncClient` instance to handle reconnects.\nOtherwise, only the manual restart of `Mqttv5PahoMessageDrivenChannelAdapter` can handle reconnecting, e.g. via `MqttConnectionFailedEvent` handling on disconnection.\n\n[[mqtt-shared-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mqtt.adoc", "title": "mqtt", "heading": "MQTT v5 Support", "heading_level": 2, "file_order": 245, "section_index": 10, "content_hash": "918db8c1f505665518c88d211f91c64d54c56d296bb86b33c99e7673aae2aaf4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mqtt.adoc"}}
{"id": "sha256:464ef69b4b6ec874f381c3f773836aca0626e3faeda7f13454b0624c8e53362a", "content": "If a single MQTT ClientID is required for several integrations, multiple MQTT client instances cannot be used because MQTT brokers may have a limitation on a number of connections per ClientID (typically, a single connection is allowed).\nFor having a single client reused for different channel adapters, a `org.springframework.integration.mqtt.core.ClientManager` component may be used and passed to any channel adapter needed.\nIt will manage the MQTT connection lifecycle and do automatic reconnects if needed.\nAlso, a custom connection option and `MqttClientPersistence` may be provided to the client manager just as currently it can be done for channel adapter components.\n\nNote that both MQTT v5 and v3 channel adapters are supported.\n\nThe following Java DSL configuration sample demonstrates how to use this client manager in the integration flow:\n\n[source,java]\n----\n@Bean\npublic ClientManager<IMqttAsyncClient, MqttConnectionOptions> clientManager() {\n MqttConnectionOptions connectionOptions = new MqttConnectionOptions();\n connectionOptions.setServerURIs(new String[]{ \"tcp://localhost:1883\" });\n connectionOptions.setConnectionTimeout(30000);\n connectionOptions.setMaxReconnectDelay(1000);\n connectionOptions.setAutomaticReconnect(true);\n Mqttv5ClientManager clientManager = new Mqttv5ClientManager(connectionOptions, \"client-manager-client-id-v5\");\n clientManager.setPersistence(new MqttDefaultFilePersistence());\n return clientManager;\n}\n\n@Bean\npublic IntegrationFlow mqttInFlowTopic1(\n ClientManager<IMqttAsyncClient, MqttConnectionOptions> clientManager) {\n\n Mqttv5PahoMessageDrivenChannelAdapter messageProducer =\n new Mqttv5PahoMessageDrivenChannelAdapter(clientManager, \"topic1\");\n return IntegrationFlow.from(messageProducer)\n .channel(c -> c.queue(\"fromMqttChannel\"))\n .get();\n}\n\n@Bean\npublic IntegrationFlow mqttInFlowTopic2(\n ClientManager<IMqttAsyncClient, MqttConnectionOptions> clientManager) {\n\n Mqttv5PahoMessageDrivenChannelAdapter messageProducer =\n new Mqttv5PahoMessageDrivenChannelAdapter(clientManager, \"topic2\");\n return IntegrationFlow.from(messageProducer)\n .channel(c -> c.queue(\"fromMqttChannel\"))\n .get();\n}\n\n@Bean\npublic IntegrationFlow mqttOutFlow(\n ClientManager<IMqttAsyncClient, MqttConnectionOptions> clientManager) {\n\n return f -> f.handle(new Mqttv5PahoMessageHandler(clientManager));\n}\n----\n\nNOTE: Starting with version 6.4, multiple instances of `MqttPahoMessageDrivenChannelAdapter` and `Mqttv5PahoMessageDrivenChannelAdapter` can now be added at runtime using corresponding `ClientManager` through `IntegrationFlowContext`\n\n[source,java]\n----\nprivate void addAddRuntimeAdapter(IntegrationFlowContext flowContext, Mqttv5ClientManager clientManager,\n String topic, MessageChannel channel) {\n flowContext\n .registration(\n IntegrationFlow\n .from(new Mqttv5PahoMessageDrivenChannelAdapter(clientManager, topic))\n .channel(channel)\n .get())\n .register();\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/mqtt.adoc", "title": "mqtt", "heading": "Shared MQTT Client Support", "heading_level": 2, "file_order": 245, "section_index": 11, "content_hash": "464ef69b4b6ec874f381c3f773836aca0626e3faeda7f13454b0624c8e53362a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/mqtt.adoc"}}
{"id": "sha256:4d00f10d4d2cbe04d80123f409fc624322c3a171300ec40f739557de54027b88", "content": "[[native-images-support]]\n\nStarting with version 6.0, GraalVM compilation of Spring Integration applications to native images is supported by https://docs.spring.io/spring-framework/reference/core/aot.html[Spring AOT] native hints.\nFor most common use cases, such as endpoint definitions with `@Bean` methods, Java DSL configuration with lambdas and `@MessagingGateway` interface scanning (importing), the framework provides respective reflection, proxy and serialization hints.\nIf configuration uses messaging annotations (`@ServiceActivator`, `@Splitter` etc.) on POJO methods, or POJO methods are used with the `IntegrationFlowBuilder.handle(Object service, String methodName)` API, they have to be also marked with a `@Reflective` annotation since they are invoked by the framework reflectively.\n\nIMPORTANT: XML configuration is not supported for native images.\n\nAs stated before, service interfaces with the `@MessagingGateway` annotation, when they are scanned by the `@IntegrationComponentScan` or used in an `@Import` annotation, are processed by the framework and the respective proxy hint is exposed into the AOT contribution.\nWhen gateways are declared using the `IntegrationFlow.from(Class<?> serviceInterface)` API, the proxy configured for such interfaces have to be exposed manually:\n\n[source,java]\n----\n@Configuration\n@EnableIntegration\n@ImportRuntimeHints(GatewayRuntimeHints.class)\npublic class IntegrationConfiguration {\n\n @Bean\n IntegrationFlow someFlow() {\n return IntegrationFlow.from(SomeGateway)\n // ...\n .get();\n }\n\n public interface SomeGateway {\n\n void doSomething(Object payload);\n\n }\n\n private static class GatewayRuntimeHints implements RuntimeHintsRegistrar {\n\n @Override\n public void registerHints(RuntimeHints hints, ClassLoader classLoader) {\n hints.proxies().registerJdkProxy(\n AopProxyUtils.completeJdkProxyInterfaces(SomeGateway));\n }\n\n }\n\n}\n----\n\nNOTE: The `IntegrationFlow` content is not processed during the AOT processing phase.\nTherefore, some hints, such as the one mentioned above for a gateway proxy, must be provided by the target application.\n\nOf course, configuration is just a piece of an integration solution.\nThe most important part is data transferring over the network as well as persistent storage.\nThat's where serialization comes handy for many use-cases.\nSpring Integration exposes serialization hints into a native image configuration for these types used by the framework internally: `String`, `Number`, `Long`, `Date`, `ArrayList`, `HashMap`, `Properties`, `Hashtable`, `Exception`, `UUID`, `GenericMessage`, `ErrorMessage`, `MessageHeaders`, `AdviceMessage`, `MutableMessage`, `MutableMessageHeaders`, `MessageGroupMetadata`, `MessageHolder`, `MessageMetadata`, `MessageHistory`, `MessageHistory.Entry`, `DelayHandler.DelayedMessageWrapper`.\nFor user-specific data, mostly present as a message payload, the serialization hint must be exposed manually via a `RuntimeHintsRegistrar` implementation, as is shown above for a gateway proxy, and the respective `RuntimeHints.serialization().registerType()` API.\n\nNOTE: It is recommended that native integration applications are developed with Spring Boot, using its respective build tools.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/native-aot.adoc", "title": "native-aot", "heading": "native-aot", "heading_level": 1, "file_order": 246, "section_index": 0, "content_hash": "4d00f10d4d2cbe04d80123f409fc624322c3a171300ec40f739557de54027b88", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/native-aot.adoc"}}
{"id": "sha256:eceb2a3f734b29346dbb8b8db05695f6c5bbf97407bc103e200fe8db748ced10", "content": "[[null-safety]]\n\nThe codebase is annotated with JSpecify annotations to declare the nullability of its APIs, fields, and related type usages, following Spring Framework's efforts to add null safety to the platform.\nReading Spring Framework's https://docs.spring.io/spring-framework/reference/core/null-safety.html#null-safety-guidelines-nullaway[Null-safety reference documentation] is highly recommended to get familiar with these annotations and their semantics.\n\nThe primary goal of this null-safety arrangement is to prevent `NullPointerException` from being thrown at runtime through build-time checks and to use explicit nullability as a way to express the possible absence of a value.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/null-safety.adoc", "title": "null-safety", "heading": "null-safety", "heading_level": 1, "file_order": 247, "section_index": 0, "content_hash": "eceb2a3f734b29346dbb8b8db05695f6c5bbf97407bc103e200fe8db748ced10", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/null-safety.adoc"}}
{"id": "sha256:f3208a45bcb2a316aaef194093f399f7a86558db3283c4be3aa15f23143905c4", "content": "[[spring-integration-introduction]]\n\n[[spring-integration-intro]]\nSpring Integration provides an extension of the Spring programming model to support the well known https://www.enterpriseintegrationpatterns.com/[Enterprise Integration Patterns].\nIt enables lightweight messaging within Spring-based applications and supports integration with external systems through declarative adapters.\nThose adapters provide a higher level of abstraction over Spring's support for remoting, messaging, and scheduling.\n\nSpring Integration's primary goal is to provide a simple model for building enterprise integration solutions while maintaining the separation of concerns that is essential for producing maintainable, testable code.\n\n[[overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "overview", "heading_level": 1, "file_order": 248, "section_index": 0, "content_hash": "f3208a45bcb2a316aaef194093f399f7a86558db3283c4be3aa15f23143905c4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:5acefcd9f7a52ab6515ae99edd631e2a6216c3ba0c0b3a71ebccb052b0759979", "content": "This chapter provides a high-level introduction to Spring Integration's core concepts and components.\nIt includes some programming tips to help you make the most of Spring Integration.\n\n[[overview-background]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Spring Integration Overview", "heading_level": 2, "file_order": 248, "section_index": 1, "content_hash": "5acefcd9f7a52ab6515ae99edd631e2a6216c3ba0c0b3a71ebccb052b0759979", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:a5fb6a009a449e47933c0f7cca442da6a3e974cea0c4306415009833618175b4", "content": "One of the key themes of the Spring Framework is Inversion of Control (IoC).\nIn its broadest sense, this means that the framework handles responsibilities on behalf of the components that are managed within its context.\nThe components themselves are simplified, because they are relieved of those responsibilities.\nFor example, dependency injection relieves the components of the responsibility of locating or creating their dependencies.\nLikewise, aspect-oriented programming relieves business components of generic cross-cutting concerns by modularizing them into reusable aspects.\nIn each case, the end result is a system that is easier to test, understand, maintain, and extend.\n\nFurthermore, the Spring framework and portfolio provide a comprehensive programming model for building enterprise applications.\nDevelopers benefit from the consistency of this model and especially from the fact that it is based upon well established best practices, such as programming to interfaces and favoring composition over inheritance.\nSpring's simplified abstractions and powerful support libraries boost developer productivity while simultaneously increasing the level of testability and portability.\n\nSpring Integration is motivated by these same goals and principles.\nIt extends the Spring programming model into the messaging domain and builds upon Spring's existing enterprise integration support to provide an even higher level of abstraction.\nIt supports message-driven architectures where inversion of control applies to runtime concerns, such as when certain business logic should run and where the response should be sent.\nIt supports routing and transformation of messages so that different transports and different data formats can be integrated without impacting testability.\nIn other words, the messaging and integration concerns are handled by the framework.\nBusiness components are further isolated from the infrastructure, and developers are relieved of complex integration responsibilities.\n\nAs an extension of the Spring programming model, Spring Integration provides a wide variety of configuration options, including annotations, XML with namespace support, XML with generic \"`bean`\" elements, and direct usage of the underlying API.\nThat API is based upon well-defined strategy interfaces and non-invasive, delegating adapters.\nSpring Integration's design is inspired by the recognition of a strong affinity between common patterns within Spring and the well-known patterns described in https://www.enterpriseintegrationpatterns.com/[_Enterprise Integration Patterns_], by Gregor Hohpe and Bobby Woolf (Addison Wesley, 2004).\nDevelopers who have read that book should be immediately comfortable with the Spring Integration concepts and terminology.\n\n[[overview-goalsandprinciples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Background", "heading_level": 3, "file_order": 248, "section_index": 2, "content_hash": "a5fb6a009a449e47933c0f7cca442da6a3e974cea0c4306415009833618175b4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:b19404ddc5784534a3af0ffba87e755b42aee1309a1d7fe3fed17410548a6c2c", "content": "Spring Integration is motivated by the following goals:\n\n* Provide a simple model for implementing complex enterprise integration solutions.\n* Facilitate asynchronous, message-driven behavior within a Spring-based application.\n* Promote intuitive, incremental adoption for existing Spring users.\n\nSpring Integration is guided by the following principles:\n\n* Components should be loosely coupled for modularity and testability.\n* The framework should enforce separation of concerns between business logic and integration logic.\n* Extension points should be abstract in nature (but within well-defined boundaries) to promote reuse and portability.\n\n[[overview-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Goals and Principles", "heading_level": 3, "file_order": 248, "section_index": 3, "content_hash": "b19404ddc5784534a3af0ffba87e755b42aee1309a1d7fe3fed17410548a6c2c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:0cace56e1e796810bbe6d270529e2d11e8c418e61745d73df830fc964d186870", "content": "From a vertical perspective, a layered architecture facilitates separation of concerns, and interface-based contracts between layers promote loose coupling.\nSpring-based applications are typically designed this way, and the Spring framework and portfolio provide a strong foundation for following this best practice for the full stack of an enterprise application.\nMessage-driven architectures add a horizontal perspective, yet these same goals are still relevant.\nJust as \"`layered architecture`\" is an extremely generic and abstract paradigm, messaging systems typically follow the similarly abstract \"`pipes-and-filters`\" model.\nThe \"`filters`\" represent any components capable of producing or consuming messages, and the \"`pipes`\" transport the messages between filters so that the components themselves remain loosely-coupled.\nIt is important to note that these two high-level paradigms are not mutually exclusive.\nThe underlying messaging infrastructure that supports the \"`pipes`\" should still be encapsulated in a layer whose contracts are defined as interfaces.\nLikewise, the \"`filters`\" themselves should be managed within a layer that is logically above the application's service layer, interacting with those services through interfaces in much the same way that a web tier would.\n\n[[overview-components-message]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Main Components", "heading_level": 3, "file_order": 248, "section_index": 4, "content_hash": "0cace56e1e796810bbe6d270529e2d11e8c418e61745d73df830fc964d186870", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:6a761a7aaff44b17d253c705ce518fe11c81272eabd1e22cdc4a8e498343f5da", "content": "In Spring Integration, a message is a generic wrapper for any Java object combined with metadata used by the framework while handling that object.\nIt consists of a payload and headers.\nThe payload can be of any type, and the headers hold commonly required information such as ID, timestamp, correlation ID, and return address.\nHeaders are also used for passing values to and from connected transports.\nFor example, when creating a message from a received file, the file name may be stored in a header to be accessed by downstream components.\nLikewise, if a message's content is ultimately going to be sent by an outbound mail adapter, the various properties (to, from, cc, subject, and others) may be configured as message header values by an upstream component.\nDevelopers can also store any arbitrary key-value pairs in the headers.\n\n.Message\nimage::message.jpg[\"Message\", align=\"center\"]\n\n[[overview-components-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Message", "heading_level": 4, "file_order": 248, "section_index": 5, "content_hash": "6a761a7aaff44b17d253c705ce518fe11c81272eabd1e22cdc4a8e498343f5da", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:fe0e0530f17aa8ceac8ebe44baeac33874d2d3a4cf60ec97b7f25691f268c48b", "content": "A message channel represents the \"`pipe`\" of a pipes-and-filters architecture.\nProducers send messages to a channel, and consumers receive messages from a channel.\nThe message channel therefore decouples the messaging components and also provides a convenient point for interception and monitoring of messages.\n\n.Message Channel\nimage::channel.jpg[\"Message Channel\", align=\"center\"]\n\nA message channel may follow either point-to-point or publish-subscribe semantics.\nWith a point-to-point channel, no more than one consumer can receive each message sent to the channel.\nPublish-subscribe channels, on the other hand, attempt to broadcast each message to all subscribers on the channel.\nSpring Integration supports both of these models.\n\nWhereas \"`point-to-point`\" and \"publish-subscribe\" define the two options for how many consumers ultimately receive each message, there is another important consideration: Should the channel buffer messages?\nIn Spring Integration, pollable channels are capable of buffering Messages within a queue.\nThe advantage of buffering is that it allows for throttling the inbound messages and thereby prevents overloading a consumer.\nHowever, as the name suggests, this also adds some complexity, since a consumer can only receive the messages from such a channel if a poller is configured.\nOn the other hand, a consumer connected to a subscribable channel is simply message-driven.\nxref:channel/implementations.adoc[Message Channel Implementations] has a detailed discussion of the variety of channel implementations available in Spring Integration.\n\n[[overview-components-endpoint]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Message Channel", "heading_level": 4, "file_order": 248, "section_index": 6, "content_hash": "fe0e0530f17aa8ceac8ebe44baeac33874d2d3a4cf60ec97b7f25691f268c48b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:8b3afa4194cda81e58f040520d963b0e45e7b3b0a2c853f6f1696b8c61b670cb", "content": "One of the primary goals of Spring Integration is to simplify the development of enterprise integration solutions through inversion of control.\nThis means that you should not have to implement consumers and producers directly, and you should not even have to build messages and invoke send or receive operations on a message channel.\nInstead, you should be able to focus on your specific domain model with an implementation based on plain objects.\nThen, by providing declarative configuration, you can \"`connect`\" your domain-specific code to the messaging infrastructure provided by Spring Integration.\nThe components responsible for these connections are message endpoints.\nThis does not mean that you should necessarily connect your existing application code directly.\nAny real-world enterprise integration solution requires some amount of code focused upon integration concerns such as routing and transformation.\nThe important thing is to achieve separation of concerns between the integration logic and the business logic.\nIn other words, as with the Model-View-Controller (MVC) paradigm for web applications, the goal should be to provide a thin but dedicated layer that translates inbound requests into service layer invocations and then translates service layer return values into outbound replies.\nThe next section provides an overview of the message endpoint types that handle these responsibilities, and, in upcoming chapters, you can see how Spring Integration's declarative configuration options provide a non-invasive way to use each of these.\n\n[[overview-endpoints]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Message Endpoint", "heading_level": 4, "file_order": 248, "section_index": 7, "content_hash": "8b3afa4194cda81e58f040520d963b0e45e7b3b0a2c853f6f1696b8c61b670cb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:aff7a5d0d1978704db322c3c78afdc37a018beac97ae654c73fc68bb222b3141", "content": "A Message Endpoint represents the \"`filter`\" of a pipes-and-filters architecture.\nAs mentioned earlier, the endpoint's primary role is to connect application code to the messaging framework and to do so in a non-invasive manner.\nIn other words, the application code should ideally have no awareness of the message objects or the message channels.\nThis is similar to the role of a controller in the MVC paradigm.\nJust as a controller handles HTTP requests, the message endpoint handles messages.\nJust as controllers are mapped to URL patterns, message endpoints are mapped to message channels.\nThe goal is the same in both cases: isolate application code from the infrastructure.\nThese concepts and all the patterns that follow are discussed at length in the https://www.enterpriseintegrationpatterns.com/[_Enterprise Integration Patterns_] book.\nHere, we provide only a high-level description of the main endpoint types supported by Spring Integration and the roles associated with those types.\nThe chapters that follow elaborate and provide sample code as well as configuration examples.\n\n[[overview-endpoints-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Message Endpoints", "heading_level": 3, "file_order": 248, "section_index": 8, "content_hash": "aff7a5d0d1978704db322c3c78afdc37a018beac97ae654c73fc68bb222b3141", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:de3afbab2734478c80ed0bea919731f931a827973df9325639350e6dfb610cbd", "content": "A message transformer is responsible for converting a message's content or structure and returning the modified message.\nProbably the most common type of transformer is one that converts the payload of the message from one format to another (such as from XML to `java.lang.String`).\nSimilarly, a transformer can add, remove, or modify the message's header values.\n\n[[overview-endpoints-filter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Message Transformer", "heading_level": 4, "file_order": 248, "section_index": 9, "content_hash": "de3afbab2734478c80ed0bea919731f931a827973df9325639350e6dfb610cbd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:28917bb3d8a3bb4407e90f7ceb70d732a003e0752f9c5dd7a0dd2d6bd42c86c2", "content": "A message filter determines whether a message should be passed to an output channel at all.\nThis simply requires a boolean test method that may check for a particular payload content type, a property value, the presence of a header, or other conditions.\nIf the message is accepted, it is sent to the output channel.\nIf not, it is dropped (or, for a more severe implementation, an `Exception` could be thrown).\nMessage filters are often used in conjunction with a publish-subscribe channel, where multiple consumers may receive the same message and use the criteria of the filter to narrow down the set of messages to be processed.\n\nNOTE: Be careful not to confuse the generic use of \"`filter`\" within the pipes-and-filters architectural pattern with this specific endpoint type that selectively narrows down the messages flowing between two channels.\nThe pipes-and-filters concept of a \"`filter`\" matches more closely with Spring Integration's message endpoint: any component that can be connected to a message channel in order to send or receive messages.\n\n[[overview-endpoints-router]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Message Filter", "heading_level": 4, "file_order": 248, "section_index": 10, "content_hash": "28917bb3d8a3bb4407e90f7ceb70d732a003e0752f9c5dd7a0dd2d6bd42c86c2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:1461ba3466fbab52dbd34f31ff9348e8d66009746c6b7d84080cc8a330e8dff8", "content": "A message router is responsible for deciding what channel or channels (if any) should receive the message next.\nTypically, the decision is based upon the message's content or the metadata available in the message headers.\nA message router is often used as a dynamic alternative to a statically configured output channel on a service activator or other endpoint capable of sending reply messages.\nLikewise, a message router provides a proactive alternative to the reactive message filters used by multiple subscribers, as described earlier.\n\n.Message Router\nimage::router.jpg[\"Router\", align=\"center\"]\n\n[[overview-endpoints-splitter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Message Router", "heading_level": 4, "file_order": 248, "section_index": 11, "content_hash": "1461ba3466fbab52dbd34f31ff9348e8d66009746c6b7d84080cc8a330e8dff8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:8ea0327d7ef0967acf0bb86944c5e5c389ea281a9b6709376d5d75013bdfd067", "content": "A splitter is another type of message endpoint whose responsibility is to accept a message from its input channel, split that message into multiple messages, and send each of those to its output channel.\nThis is typically used for dividing a \"`composite`\" payload object into a group of messages containing the subdivided payloads.\n\n[[overview-endpoints-aggregator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Splitter", "heading_level": 4, "file_order": 248, "section_index": 12, "content_hash": "8ea0327d7ef0967acf0bb86944c5e5c389ea281a9b6709376d5d75013bdfd067", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:4ed46920efcfec76a4964e65ddd5867ceebd5387aac7bfb25776ae16e3ad3b74", "content": "Basically a mirror-image of the splitter, the aggregator is a type of message endpoint that receives multiple messages and combines them into a single message.\nIn fact, aggregators are often downstream consumers in a pipeline that includes a splitter.\nTechnically, the aggregator is more complex than a splitter, because it is required to maintain state (the messages to be aggregated), to decide when the complete group of messages is available, and to timeout if necessary.\nFurthermore, in case of a timeout, the aggregator needs to know whether to send the partial results, discard them, or send them to a separate channel.\nSpring Integration provides a `CorrelationStrategy`, a `ReleaseStrategy`, and configurable settings for timeout, whether\nto send partial results upon timeout, and a discard channel.\n\n[[overview-endpoints-service-activator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Aggregator", "heading_level": 4, "file_order": 248, "section_index": 13, "content_hash": "4ed46920efcfec76a4964e65ddd5867ceebd5387aac7bfb25776ae16e3ad3b74", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:6ff4472b39dc72a394e0acc569352f4469e325c0ac63904cb0498b72689e218a", "content": "A Service Activator is a generic endpoint for connecting a service instance to the messaging system.\nThe input message channel must be configured, and, if the service method to be invoked is capable of returning a value, an output message Channel may also be provided.\n\nNOTE: The output channel is optional, since each message may also provide its own 'Return Address' header.\nThis same rule applies for all consumer endpoints.\n\nThe service activator invokes an operation on some service object to process the request message, extracting the request message's payload and converting (if the method does not expect a message-typed parameter).\nWhenever the service object's method returns a value, that return value is likewise converted to a reply message if necessary (if it is not already a message type).\nThat reply message is sent to the output channel.\nIf no output channel has been configured, the reply is sent to the channel specified in the message's \"`return address`\", if available.\n\nA request-reply service activator endpoint connects a target object's method to input and output Message Channels.\n\n.Service Activator\nimage::handler-endpoint.jpg[align=\"center\", scaledwidth=100%]\n\nNOTE: As discussed earlier, in xref:overview.adoc#overview-components-channel[Message Channel], channels can be pollable or subscribable.\nIn the preceding diagram, this is depicted by the \"`clock`\" symbol and the solid arrow (poll) and the dotted arrow (subscribe).\n\n[[overview-endpoints-channeladapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Service Activator", "heading_level": 4, "file_order": 248, "section_index": 14, "content_hash": "6ff4472b39dc72a394e0acc569352f4469e325c0ac63904cb0498b72689e218a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:42a3861516be060f9d25f742d8ab62449c2d0b5dc671a68cf9f2811be39391d5", "content": "A channel adapter is an endpoint that connects a message channel to some other system or transport.\nChannel adapters may be either inbound or outbound.\nTypically, the channel adapter does some mapping between the message and whatever object or resource is received from or sent to the other system (file, HTTP Request, JMS message, and others).\nDepending on the transport, the channel adapter may also populate or extract message header values.\nSpring Integration provides a number of channel adapters, which are described in upcoming chapters.\n\n.An inbound channel adapter endpoint connects a source system to a `MessageChannel`.\nimage::source-endpoint.jpg[align=\"center\", scaledwidth=100%]\n\nNOTE: Message sources can be pollable, (for example, POP3) or message-driven, (for example, IMAP Idle).\nIn the preceding diagram, this is depicted by the \"`clock`\" symbol and the solid arrow (poll) and the dotted arrow (message-driven).\n\n.An outbound channel adapter endpoint connects a `MessageChannel` to a target system.\nimage::target-endpoint.jpg[align=\"center\", scaledwidth=100%]\n\nNOTE: As discussed earlier in xref:overview.adoc#overview-components-channel[Message Channel], channels can be pollable or subscribable.\nIn the preceding diagram, this is depicted by the \"`clock`\" symbol and the solid arrow (poll) and the dotted arrow (subscribe).\n\n[[endpoint-bean-names]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Channel Adapter", "heading_level": 4, "file_order": 248, "section_index": 15, "content_hash": "42a3861516be060f9d25f742d8ab62449c2d0b5dc671a68cf9f2811be39391d5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:a7008f4a5fd20a6ef3042491d61dd128b25b17aec9d54b385176bd7272a7b63b", "content": "Consuming endpoints (anything with an `inputChannel`) consist of two beans, the consumer and the message handler.\nThe consumer has a reference to the message handler and invokes it as messages arrive.\n\nConsider the following XML example:\n\n[source, xml]\n----\n<int:service-activator id = \"someService\" ... />\n----\n\nGiven the preceding example, the bean names are as follows:\n\n* Consumer: `someService` (the `id`)\n* Handler: `someService.handler`\n\nWhen using Enterprise Integration Pattern (EIP) annotations, the names depend on several factors.\nConsider the following example of an annotated POJO:\n\n[source, java]\n----\n@Component\npublic class SomeComponent {\n\n @ServiceActivator(inputChannel = ...)\n public String someMethod(...) {\n ...\n }\n\n}\n----\n\nGiven the preceding example, the bean names are as follows:\n\n* Consumer: `someComponent.someMethod.serviceActivator`\n* Handler: `someComponent.someMethod.serviceActivator.handler`\n\nStarting with version 5.0.4, you can modify these names by using the `@EndpointId` annotation, as the following example shows:\n\n[source, java]\n----\n@Component\npublic class SomeComponent {\n\n @EndpointId(\"someService\")\n @ServiceActivator(inputChannel = ...)\n public String someMethod(...) {\n ...\n }\n\n}\n----\n\nGiven the preceding example, the bean names are as follows:\n\n* Consumer: `someService`\n* Handler: `someService.handler`\n\nThe `@EndpointId` creates names as created by the `id` attribute with XML configuration.\nConsider the following example of an annotated bean:\n\n[source, java]\n----\n@Configuration\npublic class SomeConfiguration {\n\n @Bean\n @ServiceActivator(inputChannel = ...)\n public MessageHandler someHandler() {\n ...\n }\n\n}\n----\n\nGiven the preceding example, the bean names are as follows:\n\n* Consumer: `someConfiguration.someHandler.serviceActivator`\n* Handler: `someHandler` (the `@Bean` name)\n\nStarting with version 5.0.4, you can modify these names by using the `@EndpointId` annotation, as the following example shows:\n\n[source, java]\n----\n@Configuration\npublic class SomeConfiguration {\n\n @Bean(\"someService.handler\") <1>\n @EndpointId(\"someService\") <2>\n @ServiceActivator(inputChannel = ...)\n public MessageHandler someHandler() {\n ...\n }\n\n}\n----\n\n<1> Handler: `someService.handler` (the bean name)\n<2> Consumer: `someService` (the endpoint ID)\n\nThe `@EndpointId` annotation creates names as created by the `id` attribute with XML configuration, as long as you use the convention of appending `.handler` to the `@Bean` name.\n\nThere is one special case where a third bean is created: For architectural reasons, if a `MessageHandler` `@Bean` does not define an `AbstractReplyProducingMessageHandler`, the framework wraps the provided bean in a `ReplyProducingMessageHandlerWrapper`.\nThis wrapper supports request handler advice handling and emits the normal 'produced no reply' debug log messages.\nIts bean name is the handler bean name plus `.wrapper` (when there is an `@EndpointId` -- otherwise, it is the normal generated handler name).\n\nSimilarly, xref:polling-consumer.adoc#pollable-message-source[Pollable Message Sources] create two beans, a `SourcePollingChannelAdapter` (SPCA) and a `MessageSource`.\n\nConsider the following XML configuration:\n\n[source, xml]\n----\n<int:inbound-channel-adapter id = \"someAdapter\" ... />\n----\n\nGiven the preceding XML configuration, the bean names are as follows:\n\n* SPCA: `someAdapter` (the `id`)\n* Handler: `someAdapter.source`\n\nConsider the following Java configuration of a POJO to define an `@EndpointId`:\n\n[source, java]\n----\n@EndpointId(\"someAdapter\")\n@InboundChannelAdapter(channel = \"channel3\", poller = @Poller(fixedDelay = \"5000\"))\npublic String pojoSource() {\n ...\n}\n----\n\nGiven the preceding Java configuration example, the bean names are as follows:\n\n* SPCA: `someAdapter`\n* Handler: `someAdapter.source`\n\nConsider the following Java configuration of a bean to define an `@EndpointID`:\n\n[source, java]\n----\n@Bean(\"someAdapter.source\")\n@EndpointId(\"someAdapter\")\n@InboundChannelAdapter(channel = \"channel3\", poller = @Poller(fixedDelay = \"5000\"))\npublic MessageSource<?> source() {\n return () -> {\n ...\n };\n}\n----\n\nGiven the preceding example, the bean names are as follows:\n\n* SPCA: `someAdapter`\n* Handler: `someAdapter.source` (as long as you use the convention of appending `.source` to the `@Bean` name)\n\n[[configuration-enable-integration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Endpoint Bean Names", "heading_level": 4, "file_order": 248, "section_index": 16, "content_hash": "a7008f4a5fd20a6ef3042491d61dd128b25b17aec9d54b385176bd7272a7b63b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:26e81d06522d64385a15a59d2d6b7e28a28a4a7fdd3a791cb4d348e853d2be4f", "content": "Throughout this document, you can see references to XML namespace support for declaring elements in a Spring Integration flow.\nThis support is provided by a series of namespace parsers that generate appropriate bean definitions to implement a particular component.\nFor example, many endpoints consist of a `MessageHandler` bean and a `ConsumerEndpointFactoryBean` into which the handler and an input channel name are injected.\n\nThe first time a Spring Integration namespace element is encountered, the framework automatically declares a number of beans (a task scheduler, an implicit channel creator, and others) that are used to support the runtime environment.\n\nIMPORTANT: Version 4.0 introduced the `@EnableIntegration` annotation, to allow the registration of Spring Integration infrastructure beans (see the https://docs.spring.io/spring-integration/docs/latest-ga/api/org/springframework/integration/config/EnableIntegration.html[Javadoc]).\nThis annotation is required when only Java configuration is used -- for example, with Spring Boot or Spring Integration Messaging Annotation support and Spring Integration Java DSL with no XML integration configuration.\n\nThe `@EnableIntegration` annotation is also useful when you have a parent context with no Spring Integration components and two or more child contexts that use Spring Integration.\nIt lets these common components be declared once only, in the parent context.\n\nThe `@EnableIntegration` annotation registers many infrastructure components with the application context.\nIn particular, it:\n\n* Registers some built-in beans, such as `errorChannel` and its `LoggingHandler`, `taskScheduler` for pollers, `jsonPath` SpEL-function, and others.\n* Adds several `BeanFactoryPostProcessor` instances to enhance the `BeanFactory` for global and default integration environment.\n* Adds several `BeanPostProcessor` instances to enhance or convert and wrap particular beans for integration purposes.\n* Adds annotation processors to parse messaging annotations and registers components for them with the application context.\n\nThe `@IntegrationComponentScan` annotation also permits classpath scanning.\nThis annotation plays a similar role as the standard Spring Framework `@ComponentScan` annotation, but it is restricted to components and annotations that are specific to Spring Integration, which the standard Spring Framework component scan mechanism cannot reach.\nFor an example, see xref:gateway.adoc#messaging-gateway-annotation[`@MessagingGateway` Annotation].\n\nThe `@EnablePublisher` annotation registers a `PublisherAnnotationBeanPostProcessor` bean and configures the `default-publisher-channel` for those `@Publisher` annotations that are provided without a `channel` attribute.\nIf more than one `@EnablePublisher` annotation is found, they must all have the same value for the default channel.\nSee xref:message-publishing.adoc#publisher-annotation[Annotation-driven Configuration with the `@Publisher` Annotation] for more information.\n\nThe `@GlobalChannelInterceptor` annotation has been introduced to mark `ChannelInterceptor` beans for global channel interception.\nThis annotation is an analogue of the `<int:channel-interceptor>` XML element (see xref:channel/configuration.adoc#global-channel-configuration-interceptors[Global Channel Interceptor Configuration]).\n`@GlobalChannelInterceptor` annotations can be placed at the class level (with a `@Component` stereotype annotation) or on `@Bean` methods within `@Configuration` classes.\nIn either case, the bean must implement `ChannelInterceptor`.\n\nStarting with version 5.1, global channel interceptors apply to dynamically registered channels -- such as beans that are initialized by using `beanFactory.initializeBean()` or through the `IntegrationFlowContext` when using the Java DSL.\nPreviously, interceptors were not applied when beans were created after the application context was refreshed.\n\nThe `@IntegrationConverter` annotation marks `Converter`, `GenericConverter`, or `ConverterFactory` beans as candidate converters for `integrationConversionService`.\nThis annotation is an analogue of the `<int:converter>` XML element (see xref:endpoint.adoc#payload-type-conversion[Payload Type Conversion]).\nYou can place `@IntegrationConverter` annotations at the class level (with a `@Component` stereotype annotation) or on `@Bean` methods within `@Configuration` classes.\n\nSee xref:configuration/annotations.adoc[Annotation Support] for more information about messaging annotations.\n\n[[programming-considerations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Configuration and `@EnableIntegration`", "heading_level": 3, "file_order": 248, "section_index": 17, "content_hash": "26e81d06522d64385a15a59d2d6b7e28a28a4a7fdd3a791cb4d348e853d2be4f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:0a494f6546339f2aa4d14ee9160403fa388f004c3da96db1be8acee750b0ebc5", "content": "Most classes in Spring Integration, unless stated otherwise, must be declared as beans in the application context and as singletons.\nThat means instances of these classes are thread-safe and their lifecycle and connection with other components are managed by the Spring dependency injection container.\nThe utility and builder classes (`JacksonMessagingUtils`, `MessageBuilder`, `ExpressionEvalMap`, `IntegrationReactiveUtils` etc.) can be used directly in the Java code.\nHowever, Java DSL factories and `IntegrationComponentSpec` implementation results still have to be registered as beans into the application context.\nThe `Session` abstraction, present in many modules, is not thread-safe, typically created by the `Factory` pattern implementation, and used from thread-safe `Template` pattern.\nSee, for example, `SftpRemoteFileTemplate` and its relationship with the `DefaultSftpSessionFactory`.\n\nYou should use plain old java objects (POJOs) whenever possible (for message handling in target logic) and only expose the framework in your code when absolutely necessary.\nSee xref:overview.adoc#pojo-invocation[POJO Method invocation] for more information.\n\nIf you do expose the framework to your classes, there are some considerations that need to be taken into account, especially during application startup:\n\n* If your component is `ApplicationContextAware`, you should generally not use the `ApplicationContext` in the `setApplicationContext()` method.\nInstead, store a reference and defer such uses until later in the context lifecycle.\n\n* If your component is an `InitializingBean` or uses `@PostConstruct` methods, do not send any messages from these initialization methods.\nThe application context is not yet initialized when these methods are called, and sending such messages is likely to fail.\nIf you need to send a messages during startup, implement `ApplicationListener` and wait for the `ContextRefreshedEvent`.\nAlternatively, implement `SmartLifecycle`, put your bean in a late phase, and send the messages from the `start()` method.\n\n[[shaded]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Programming Considerations", "heading_level": 3, "file_order": 248, "section_index": 18, "content_hash": "0a494f6546339f2aa4d14ee9160403fa388f004c3da96db1be8acee750b0ebc5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:40bf3026709b8f7817a93d422af2fd6943fd0dea2d90c0f16a6dcf62a68ca11f", "content": "Spring Integration bootstraps certain features by using Spring Framework's `SpringFactories` mechanism to load several `IntegrationConfigurationInitializer` classes.\nThis includes the `-core` jar as well as certain others, including `-http` and `-jmx`.\nThe information for this process is stored in a `META-INF/spring.factories` file in each jar.\n\nSome developers prefer to repackage their application and all dependencies into a single jar by using well known tools, such as the https://maven.apache.org/plugins/maven-shade-plugin/[Apache Maven Shade Plugin].\n\nBy default, the shade plugin does not merge the `spring.factories` files when producing the shaded jar.\n\nIn addition to `spring.factories`, other `META-INF` files (`spring.handlers` and `spring.schemas`) are used for XML configuration.\nThese files also need to be merged.\n\nIMPORTANT: https://docs.spring.io/spring-boot/docs/current/reference/html/executable-jar.html[Spring Boot's executable jar mechanism] takes a different approach, in that it nests the jars, thus retaining each `spring.factories` file on the class path.\nSo, with a Spring Boot application, nothing more is needed if you use its default executable jar format.\n\nEven if you do not use Spring Boot, you can still use the tooling provided by Boot to enhance the shade plugin by adding transformers for the files mentioned above.\nThe following example shows how to configure the plugin:\n\n.pom.xml\n====\n[source, xml]\n----\n...\n <plugins>\n <plugin>\n <groupId>org.apache.maven.plugins</groupId>\n <artifactId>maven-shade-plugin</artifactId>\n <configuration>\n <keepDependenciesWithProvidedScope>true</keepDependenciesWithProvidedScope>\n <createDependencyReducedPom>true</createDependencyReducedPom>\n </configuration>\n <dependencies>\n <dependency> <1>\n <groupId>org.springframework.boot</groupId>\n <artifactId>spring-boot-maven-plugin</artifactId>\n <version>${spring.boot.version}</version>\n </dependency>\n </dependencies>\n <executions>\n <execution>\n <phase>package</phase>\n <goals>\n <goal>shade</goal>\n </goals>\n <configuration>\n <transformers> <2>\n <transformer\n implementation=\"org.apache.maven.plugins.shade.resource.AppendingTransformer\">\n <resource>META-INF/spring.handlers</resource>\n </transformer>\n <transformer\n implementation=\"org.springframework.boot.maven.PropertiesMergingResourceTransformer\">\n <resource>META-INF/spring.factories</resource>\n </transformer>\n <transformer\n implementation=\"org.apache.maven.plugins.shade.resource.AppendingTransformer\">\n <resource>META-INF/spring.schemas</resource>\n </transformer>\n <transformer\n implementation=\"org.apache.maven.plugins.shade.resource.ServicesResourceTransformer\" />\n </transformers>\n </configuration>\n </execution>\n </executions>\n </plugin>\n </plugins>\n...\n----\n\nSpecifically,\n\n<1> Add the `spring-boot-maven-plugin` as a dependency.\n\n<2> Configure the transformers.\n====\n\nYou can add a property for `${spring.boot.version}` or use an explicit version.\n\n[[programming-tips]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Considerations When Using Packaged (for example, Shaded) Jars", "heading_level": 4, "file_order": 248, "section_index": 19, "content_hash": "40bf3026709b8f7817a93d422af2fd6943fd0dea2d90c0f16a6dcf62a68ca11f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:d8a63f094af162a934bb100fb230ea831e19073023037cf661b0b276d1423e77", "content": "This section documents some ways to get the most from Spring Integration.\n\n[[xml-schemas]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Programming Tips and Tricks", "heading_level": 3, "file_order": 248, "section_index": 20, "content_hash": "d8a63f094af162a934bb100fb230ea831e19073023037cf661b0b276d1423e77", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:a2fef079f7fe37464733836ea826fd2ce6a043679d74f1bcbfefb6cfa68d3249", "content": "When using XML configuration, to avoid getting false schema validation errors, you should use a \"`Spring-aware`\" IDE, such as the Spring Tool Suite (STS), Eclipse with the Spring IDE plugins, or IntelliJ IDEA.\nThese IDEs know how to resolve the correct XML schema from the classpath (by using the `META-INF/spring.schemas` file in the jars).\nWhen using STS or Eclipse with the plugin, you must enable `Spring Project Nature` on the project.\n\nThe schemas hosted on the internet for certain legacy modules (those that existed in version 1.0) are the 1.0 versions for compatibility reasons.\nIf your IDE uses these schemas, you are likely to see false errors.\n\nEach of these online schemas has a warning similar to the following:\n\n[IMPORTANT]\n====\nThis schema is for the 1.0 version of Spring Integration Core.\nWe cannot update it to the current schema because that will break any applications using 1.0.3 or lower.\nFor subsequent versions, the \"unversioned\" schema is resolved from the classpath and obtained from the jar.\nPlease refer to GitHub:\n\nhttps://github.com/spring-projects/spring-integration/tree/main/spring-integration-core/src/main/resources/org/springframework/integration/config\n====\n\nThe affected modules are\n\n* `core` (`spring-integration.xsd`)\n* `file`\n* `http`\n* `jms`\n* `mail`\n* `security`\n* `stream`\n* `ws`\n* `xml`\n\n[[finding-class-names-for-java-and-dsl-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "XML Schemas", "heading_level": 4, "file_order": 248, "section_index": 21, "content_hash": "a2fef079f7fe37464733836ea826fd2ce6a043679d74f1bcbfefb6cfa68d3249", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:435a8590c9208ab67c464da55ee3be8f75d1dc189433cd9c1025da6a32d6f565", "content": "With XML configuration and Spring Integration Namespace support, the XML parsers hide how target beans are declared and wired together.\nFor Java configuration, it is important to understand the Framework API for target end-user applications.\n\nThe first-class citizens for EIP implementation are `Message`, `Channel`, and `Endpoint` (see xref:overview.adoc#overview-components[Main Components], earlier in this chapter).\nTheir implementations (contracts) are:\n\n* `org.springframework.messaging.Message`: See xref:overview.adoc#overview-components-message[Message];\n* `org.springframework.messaging.MessageChannel`: See xref:channel.adoc[Message Channels];\n* `org.springframework.integration.endpoint.AbstractEndpoint`: See xref:polling-consumer.adoc#polling-consumer[Poller].\n\nThe first two are simple enough to understand how to implement, configure, and use.\nThe last one deserves more attention\n\nThe `AbstractEndpoint` is widely used throughout the Spring Framework for different component implementations.\nIts main implementations are:\n\n* `EventDrivenConsumer`, used when we subscribe to a `SubscribableChannel` to listen for messages.\n* `PollingConsumer`, used when we poll for messages from a `PollableChannel`.\n\nWhen you use messaging annotations or the Java DSL, you don't need to worry about these components, because the Framework automatically produces them with appropriate annotations and `BeanPostProcessor` implementations.\nWhen building components manually, you should use the `ConsumerEndpointFactoryBean` to help determine the target `AbstractEndpoint` consumer implementation to create, based on the provided `inputChannel` property.\n\nOn the other hand, the `ConsumerEndpointFactoryBean` delegates to another first-class citizen in the Framework - `org.springframework.messaging.MessageHandler`.\nThe goal of the implementation of this interface is to handle the message consumed by the endpoint from the channel.\nAll EIP components in Spring Integration are `MessageHandler` implementations (for example, `AggregatingMessageHandler`, `MessageTransformingHandler`, `AbstractMessageSplitter`, and others).\nThe target protocol outbound adapters (`FileWritingMessageHandler`, `HttpRequestExecutingMessageHandler`, `AbstractMqttMessageHandler`, and others) are also `MessageHandler` implementations.\nWhen you develop Spring Integration applications with Java configuration, you should look into the Spring Integration module to find an appropriate `MessageHandler` implementation to use for the `@ServiceActivator` configuration.\nFor example, to send an XMPP message (see xref:xmpp.adoc[XMPP Support]) you should configure something like the following:\n\n[source,java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"input\")\npublic MessageHandler sendChatMessageHandler(XMPPConnection xmppConnection) {\n ChatMessageSendingMessageHandler handler = new ChatMessageSendingMessageHandler(xmppConnection);\n\n DefaultXmppHeaderMapper xmppHeaderMapper = new DefaultXmppHeaderMapper();\n xmppHeaderMapper.setRequestHeaderNames(\"*\");\n handler.setHeaderMapper(xmppHeaderMapper);\n\n return handler;\n}\n----\n\nThe `MessageHandler` implementations represent the outbound and processing part of the message flow.\n\nThe inbound message flow side has its own components, which are divided into polling and listening behaviors.\nThe listening (message-driven) components are simple and typically require only one target class implementation to be ready to\nproduce messages.\nListening components can be one-way `MessageProducerSupport` implementations, (such as `AbstractMqttMessageDrivenChannelAdapter` and `ImapIdleChannelAdapter`) or request-reply `MessagingGatewaySupport` implementations (such as `AmqpInboundGateway` and `AbstractWebServiceInboundGateway`).\n\nPolling inbound endpoints are for those protocols that do not provide a listener API or are not intended for\nsuch a behavior, including any file-based protocol (such as FTP), any databases (RDBMS or NoSQL), and others.\n\nThese inbound endpoints consist of two components: the poller configuration, to initiate the polling task periodically,\nand a message source class to read data from the target protocol and produce a message for the downstream integration flow.\nThe first class for the poller configuration is a `SourcePollingChannelAdapter`.\nIt is one more `AbstractEndpoint` implementation, but especially for polling to initiate an integration flow.\nTypically, with the messaging annotations or Java DSL, you should not worry about this class.\nThe Framework produces a bean for it, based on the `@InboundChannelAdapter` configuration or a Java DSL builder spec.\n\nMessage source components are more important for the target application development, and they all implement the `MessageSource` interface (for example, `MongoDbMessageSource` and `AbstractTwitterMessageSource`).\nWith that in mind, our config for reading data from an RDBMS table with JDBC could resemble the following:\n\n[source,java]\n----\n@Bean\n@InboundChannelAdapter(value = \"fooChannel\", poller = @Poller(fixedDelay=\"5000\"))\npublic MessageSource<?> storedProc(DataSource dataSource) {\n return new JdbcPollingChannelAdapter(dataSource, \"SELECT * FROM foo where status = 0\");\n}\n----\n\nYou can find all the required inbound and outbound classes for the target protocols in the particular Spring Integration module (in most cases, in the respective package).\nFor example, the `spring-integration-websocket` adapters are:\n\n* `o.s.i.websocket.inbound.WebSocketInboundChannelAdapter`: Implements `MessageProducerSupport` to listen for frames on the socket and produce a message to the channel.\n* `o.s.i.websocket.outbound.WebSocketOutboundMessageHandler`: The one-way `AbstractMessageHandler` implementation to convert incoming messages to the appropriate frame and send over websocket.\n\nIf you are familiar with Spring Integration XML configuration, starting with version 4.3, we provide information in the\nXSD element definitions about which target classes are used to declare beans for the adapter or gateway, as the following example shows:\n\n[source,xml]\n----\n<xsd:element name=\"outbound-async-gateway\">\n <xsd:annotation>\n <xsd:documentation>\nConfigures a Consumer Endpoint for the 'o.s.i.amqp.outbound.AsyncAmqpOutboundGateway'\nthat will publish an AMQP Message to the provided Exchange and expect a reply Message.\nThe sending thread returns immediately; the reply is sent asynchronously; uses 'AsyncRabbitTemplate.sendAndReceive()'.\n </xsd:documentation>\n\t</xsd:annotation>\n----\n\n[[pojo-invocation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "Finding Class Names for Java and DSL Configuration", "heading_level": 4, "file_order": 248, "section_index": 22, "content_hash": "435a8590c9208ab67c464da55ee3be8f75d1dc189433cd9c1025da6a32d6f565", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:211c959e115fdde9e0de154351104d52aa4be6e8d25c25feb8aca39e92f3c7f5", "content": "As discussed in xref:overview.adoc#programming-considerations[Programming Considerations], we recommend using a POJO programming style, as the following example shows:\n\n[source, java]\n----\n@ServiceActivator\npublic String myService(String payload) { ... }\n----\n\nIn this case, the framework extracts a `String` payload, invokes your method, and wraps the result in a message to send to the next component in the flow (the original headers are copied to the new message).\nIn fact, if you use XML configuration, you do not even need the `@ServiceActivator` annotation, as the following paired examples show:\n\n[source, xml]\n----\n<int:service-activator ... ref=\"myPojo\" method=\"myService\" />\n----\n\n[source, java]\n----\npublic String myService(String payload) { ... }\n----\n\nYou can omit the `method` attribute as long as there is no ambiguity in the public methods on the class.\n\nYou can also obtain header information in your POJO methods, as the following example shows:\n\n[source, java]\n----\n@ServiceActivator\npublic String myService(@Payload String payload, @Header(\"foo\") String fooHeader) { ... }\n----\n\nYou can also dereference properties on the message, as the following example shows:\n\n[source, java]\n----\n@ServiceActivator\npublic String myService(@Payload(\"payload.foo\") String foo, @Header(\"bar.baz\") String barbaz) { ... }\n----\n\nBecause various POJO method invocations are available, versions prior to 5.0 used SpEL (Spring Expression Language) to invoke the POJO methods.\nSpEL (even interpreted) is usually \"`fast enough`\" for these operations, when compared to the actual work usually done in the methods.\nHowever, starting with version 5.0, the `org.springframework.messaging.handler.invocation.InvocableHandlerMethod` is used by default whenever possible.\nThis technique is usually faster to execute than interpreted SpEL and is consistent with other Spring messaging projects.\nThe `InvocableHandlerMethod` is similar to the technique used to invoke controller methods in Spring MVC.\nThere are certain methods that are still always invoked when using SpEL.\nExamples include annotated parameters with dereferenced properties, as discussed earlier.\nThis is because SpEL has the capability to navigate a property path.\n\nThere may be some other corner cases that we have not considered that also do not work with `InvocableHandlerMethod` instances.\nFor this reason, we automatically fall back to using SpEL in those cases.\n\nIf you wish, you can also set up your POJO method such that it always uses SpEL, with the `UseSpelInvoker` annotation, as the following example shows:\n\n[source, java]\n----\n@UseSpelInvoker(compilerMode = \"IMMEDIATE\")\npublic void bar(String bar) { ... }\n----\n\nIf the `compilerMode` property is omitted, the `spring.expression.compiler.mode` system property determines the compiler mode.\nSee https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#expressions-spel-compilation[SpEL compilation] for more information about compiled SpEL.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/overview.adoc", "title": "overview", "heading": "POJO Method invocation", "heading_level": 3, "file_order": 248, "section_index": 23, "content_hash": "211c959e115fdde9e0de154351104d52aa4be6e8d25c25feb8aca39e92f3c7f5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/overview.adoc"}}
{"id": "sha256:a4b7298d1fd78467cfeb62eef2434c221cebfacac249a830ef05a2fef0a0a5e0", "content": "[[polling]]\n\nThis section describes how polling works in Spring Integration.\n\n[[polling-consumer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/polling-consumer.adoc", "title": "polling-consumer", "heading": "polling-consumer", "heading_level": 1, "file_order": 249, "section_index": 0, "content_hash": "a4b7298d1fd78467cfeb62eef2434c221cebfacac249a830ef05a2fef0a0a5e0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/polling-consumer.adoc"}}
{"id": "sha256:9c7eb4599b8607b98444f110c4fd7c162251cb8455751dfdcc615ec0ac6e9e8e", "content": "When Message Endpoints (Channel Adapters) are connected to channels and instantiated, they produce one of the following instances:\n\n* https://docs.spring.io/spring-integration/api/org/springframework/integration/endpoint/PollingConsumer.html[`PollingConsumer`]\n* https://docs.spring.io/spring-integration/api/org/springframework/integration/endpoint/EventDrivenConsumer.html[`EventDrivenConsumer`]\n\nThe actual implementation depends on the type of channel to which these endpoints connect.\nA channel adapter connected to a channel that implements the https://docs.spring.io/spring/docs/current/javadoc-api/index.html?org/springframework/messaging/SubscribableChannel.html[`org.springframework.messaging.SubscribableChannel`] interface produces an instance of `EventDrivenConsumer`.\nOn the other hand, a channel adapter connected to a channel that implements the https://docs.spring.io/spring/docs/current/javadoc-api/index.html?org/springframework/messaging/PollableChannel.html[`org.springframework.messaging.PollableChannel`] interface (such as a `QueueChannel`) produces an instance of `PollingConsumer`.\n\nPolling consumers let Spring Integration components actively poll for Messages rather than process messages in an event-driven manner.\n\nThey represent a critical cross-cutting concern in many messaging scenarios.\nIn Spring Integration, polling consumers are based on the pattern with the same name, which is described in the book _Enterprise Integration Patterns_, by Gregor Hohpe and Bobby Woolf.\nYou can find a description of the pattern on the https://www.enterpriseintegrationpatterns.com/PollingConsumer.html[book's website].\n\nFor more information polling consumer configuration, see xref:endpoint.adoc[Message Endpoints].\n\n[[pollable-message-source]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/polling-consumer.adoc", "title": "polling-consumer", "heading": "Polling Consumer", "heading_level": 2, "file_order": 249, "section_index": 1, "content_hash": "9c7eb4599b8607b98444f110c4fd7c162251cb8455751dfdcc615ec0ac6e9e8e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/polling-consumer.adoc"}}
{"id": "sha256:663f4cd2a94a466e733335722097a62a0e6c699ae6d74f60471a67be8d41e83f", "content": "Spring Integration offers a second variation of the polling consumer pattern.\nWhen inbound channel adapters are used, these adapters are often wrapped by a `SourcePollingChannelAdapter`.\nFor example, when retrieving messages from a remote FTP Server location, the adapter described in xref:ftp/inbound.adoc[FTP Inbound Channel Adapter] is configured with a poller to periodically retrieve messages.\nSo, when components are configured with pollers, the resulting instances are of one of the following types:\n\n* https://docs.spring.io/spring-integration/api/org/springframework/integration/endpoint/PollingConsumer.html[`PollingConsumer`]\n* https://docs.spring.io/spring-integration/api/org/springframework/integration/endpoint/SourcePollingChannelAdapter.html[`SourcePollingChannelAdapter`]\n\nThis means that pollers are used in both inbound and outbound messaging scenarios.\nHere are some use cases in which pollers are used:\n\n* Polling certain external systems, such as FTP Servers, Databases, and Web Services\n* Polling internal (pollable) message channels\n* Polling internal services (such as repeatedly executing methods on a Java class)\n\nNOTE: AOP advice classes can be applied to pollers, in an `advice-chain`, such as a transaction advice to start a transaction.\nStarting with version 4.1, a `PollSkipAdvice` is provided.\nPollers use triggers to determine the time of the next poll.\nThe `PollSkipAdvice` can be used to suppress (skip) a poll, perhaps because there is some downstream condition that would prevent the message being processed.\nTo use this advice, you have to provide it with an implementation of a `PollSkipStrategy`.\nStarting with version 4.2.5, a `SimplePollSkipStrategy` is provided.\nTo use it, you can add an instance as a bean to the application context, inject it into a `PollSkipAdvice`, and add that to the poller's advice chain.\nTo skip polling, call `skipPolls()`.\nTo resume polling, call `reset()`.\nVersion 4.2 added more flexibility in this area.\nSee xref:changes-4.1-4.2.adoc#x4.2-conditional-pollers[Conditional Pollers].\n\nThis chapter is meant to only give a high-level overview of polling consumers and how they fit into the concept of message channels (see xref:channel.adoc[Message Channels]) and channel adapters (see xref:overview.adoc#overview-endpoints-channeladapter[Channel Adapter]).\nFor more information regarding messaging endpoints in general and polling consumers in particular, see xref:endpoint.adoc[Message Endpoints].\n\n[[deferred-acks-message-source]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/polling-consumer.adoc", "title": "polling-consumer", "heading": "Pollable Message Source", "heading_level": 2, "file_order": 249, "section_index": 2, "content_hash": "663f4cd2a94a466e733335722097a62a0e6c699ae6d74f60471a67be8d41e83f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/polling-consumer.adoc"}}
{"id": "sha256:2a8ad556412c60e8de67c4f97bbf0685b98a486abd21660f71eafc23b52d8caa", "content": "Starting with version 5.0.1, certain modules provide `MessageSource` implementations that support deferring acknowledgment until the downstream flow completes (or hands off the message to another thread).\nThis is currently limited to the `AmqpMessageSource` and the `KafkaMessageSource`.\n\nWith these message sources, the `IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK` header (see xref:message.adoc#message-header-accessor[`MessageHeaderAccessor` API]) is added to the message.\nWhen used with pollable message sources, the value of the header is an instance of `AcknowledgmentCallback`, as the following example shows:\n\n[source, java]\n----\n@FunctionalInterface\npublic interface AcknowledgmentCallback extends SimpleAcknowledgment {\n\n void acknowledge(Status status);\n\n @Override\n default void acknowledge() {\n acknowledge(Status.ACCEPT);\n }\n\n default boolean isAcknowledged() {\n return false;\n }\n\n default void noAutoAck() {\n throw new UnsupportedOperationException(\"You cannot disable auto acknowledgment with this implementation\");\n }\n\n default boolean isAutoAck() {\n return true;\n }\n\n enum Status {\n\n /**\n * Mark the message as accepted.\n */\n ACCEPT,\n\n /**\n * Mark the message as rejected.\n */\n REJECT,\n\n /**\n * Reject the message and requeue so that it will be redelivered.\n */\n REQUEUE\n\n }\n\n}\n----\n\nNot all message sources, (for example, a `KafkaMessageSource`) support the `REJECT` status.\nIt is treated the same as `ACCEPT`.\n\nApplications can acknowledge a message at any time, as the following example shows:\n\n[source, java]\n----\nMessage<?> received = source.receive();\n\n...\n\nStaticMessageHeaderAccessor.getAcknowledgmentCallback(received)\n .acknowledge(Status.ACCEPT);\n----\n\nIf the `MessageSource` is wired into a `SourcePollingChannelAdapter`, when the poller thread returns to the adapter after the downstream flow completes, the adapter checks whether the acknowledgment has already been acknowledged and, if not, sets its status to `ACCEPT` it (or `REJECT` if the flow throws an exception).\nThe status values are defined in the https://docs.spring.io/spring-integration/api/org/springframework/integration/support/AcknowledgmentCallback.Status.html[`AcknowledgmentCallback.Status` enumeration].\n\nSpring Integration provides `MessageSourcePollingTemplate` to perform ad-hoc polling of a `MessageSource`.\nThis, too, takes care of setting `ACCEPT` or `REJECT` on the `AcknowledgmentCallback` when the `MessageHandler` callback returns (or throws an exception).\nThe following example shows how to poll with the `MessageSourcePollingTemplate`:\n\n[source, java]\n----\nMessageSourcePollingTemplate template =\n new MessageSourcePollingTemplate(this.source);\ntemplate.poll(h -> {\n ...\n});\n----\n\nIn both cases (`SourcePollingChannelAdapter` and `MessageSourcePollingTemplate`), you can disable auto ack/nack by calling `noAutoAck()` on the callback.\nYou might do this if you hand off the message to another thread and wish to acknowledge later.\nNot all implementations support this, for example, Apache Kafka does not, because the offset commit has to be performed on the same thread.\n\n[[conditional-pollers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/polling-consumer.adoc", "title": "polling-consumer", "heading": "Deferred Acknowledgment Pollable Message Source", "heading_level": 2, "file_order": 249, "section_index": 3, "content_hash": "2a8ad556412c60e8de67c4f97bbf0685b98a486abd21660f71eafc23b52d8caa", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/polling-consumer.adoc"}}
{"id": "sha256:56598bd9d3f243fc07ecee0ee7b4a511a4f3f936ab869e88b85c13179aa4ba27", "content": "This section covers how to use conditional pollers.\n\n[[background]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/polling-consumer.adoc", "title": "polling-consumer", "heading": "Conditional Pollers for Message Sources", "heading_level": 2, "file_order": 249, "section_index": 4, "content_hash": "56598bd9d3f243fc07ecee0ee7b4a511a4f3f936ab869e88b85c13179aa4ba27", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/polling-consumer.adoc"}}
{"id": "sha256:31a268b285973c08d016384589dc9ca4c7c79d8b5da03f68f2accf4f01a32185", "content": "`Advice` objects, in an `advice-chain` on a poller, advise the whole polling task (both message retrieval and processing).\nThese \"`around advice`\" methods do not have access to any context for the poll -- only the poll itself.\nThis is fine for requirements such as making a task transactional or skipping a poll due to some external condition, as discussed earlier.\nWhat if we wish to take some action depending on the result of the `receive` part of the poll or if we want to adjust the poller depending on conditions? For those instances, Spring Integration offers \"`Smart`\" Polling.\n\n[[smart-polling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/polling-consumer.adoc", "title": "polling-consumer", "heading": "Background", "heading_level": 3, "file_order": 249, "section_index": 5, "content_hash": "31a268b285973c08d016384589dc9ca4c7c79d8b5da03f68f2accf4f01a32185", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/polling-consumer.adoc"}}
{"id": "sha256:4f080d6260ade27a85d0de9f1594edf0ee6e45cfa5d46b049e7517f06aa70f46", "content": "Version 5.3 introduced the `ReceiveMessageAdvice` interface.\nAny `Advice` objects in the `advice-chain` that implement this interface are applied only to the `receive()` operation - `MessageSource.receive()` and `PollableChannel.receive(timeout)`.\nTherefore, they can be applied only for the `SourcePollingChannelAdapter` or `PollingConsumer`.\nSuch classes implement the following methods:\n\n* `beforeReceive(Object source)`\nThis method is called before the `Object.receive()` method.\nIt lets you examine and reconfigure the source.\nReturning `false` cancels this poll (similar to the `PollSkipAdvice` mentioned earlier).\n\n* `Message<?> afterReceive(Message<?> result, Object source)`\nThis method is called after the `receive()` method.\nAgain, you can reconfigure the source or take any action (perhaps depending on the result, which can be `null` if there was no message created by the source).\nYou can even return a different message\n\n.Thread safety\n[IMPORTANT]\n====\nIf an `Advice` mutates the source, you should not configure the poller with a `TaskExecutor`.\nIf an `Advice` mutates the source, such mutations are not thread safe and could cause unexpected results, especially with high-frequency pollers.\nIf you need to process poll results concurrently, consider using a downstream `ExecutorChannel` instead of adding an executor to the poller.\n====\n\n.Advice Chain Ordering\n[IMPORTANT]\n=====\nYou should understand how the advice chain is processed during initialization.\n`Advice` objects that do not implement `ReceiveMessageAdvice` are applied to the whole poll process and are all invoked first, in order, before any `ReceiveMessageAdvice`.\nThen `ReceiveMessageAdvice` objects are invoked in order around the source `receive()` method.\nIf you have, for example, `Advice` objects `a, b, c, d`, where `b` and `d` are `ReceiveMessageAdvice`, the objects are applied in the following order: `a, c, b, d`.\nAlso, if a source is already a `Proxy`, the `ReceiveMessageAdvice` is invoked after any existing `Advice` objects.\nIf you wish to change the order, you must wire up the proxy yourself.\n=====\n\n[[simpleactiveidlereceivemessageadvice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/polling-consumer.adoc", "title": "polling-consumer", "heading": "\"`Smart`\" Polling", "heading_level": 3, "file_order": 249, "section_index": 6, "content_hash": "4f080d6260ade27a85d0de9f1594edf0ee6e45cfa5d46b049e7517f06aa70f46", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/polling-consumer.adoc"}}
{"id": "sha256:9ba82352b4e2603093f63f8885aa190bbe84d1ef182ebab8260e3efc48816644", "content": "This advice is a simple implementation of `ReceiveMessageAdvice`.\nWhen used in conjunction with a `DynamicPeriodicTrigger`, it adjusts the polling frequency, depending on whether the previous poll resulted in a message or not.\nThe poller must also have a reference to the same `DynamicPeriodicTrigger`.\n\n.Important: Async Handoff\nIMPORTANT: `SimpleActiveIdleReceiveMessageAdvice` modifies the trigger based on the `receive()` result.\nThis works only if the advice is called on the poller thread.\nIt does not work if the poller has a `task-executor`.\nTo use this advice where you wish to use async operations after the result of a poll, do the async handoff later, perhaps by using an `ExecutorChannel`.\n\n[[compoundtriggeradvice]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/polling-consumer.adoc", "title": "polling-consumer", "heading": "`SimpleActiveIdleReceiveMessageAdvice`", "heading_level": 3, "file_order": 249, "section_index": 7, "content_hash": "9ba82352b4e2603093f63f8885aa190bbe84d1ef182ebab8260e3efc48816644", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/polling-consumer.adoc"}}
{"id": "sha256:8139b3d416061ed2b82caf7ceb4b984691b762a2186e857b8a6394c93b95493f", "content": "This advice allows the selection of one of two triggers based on whether a poll returns a message or not.\nConsider a poller that uses a `CronTrigger`.\n`CronTrigger` instances are immutable, so they cannot be altered once constructed.\nConsider a use case where we want to use a cron expression to trigger a poll once each hour but, if no message is received, poll once per minute and, when a message is retrieved, revert to using the cron expression.\n\nThe advice (and poller) use a `CompoundTrigger` for this purpose.\nThe trigger's `primary` trigger can be a `CronTrigger`.\nWhen the advice detects that no message is received, it adds the secondary trigger to the `CompoundTrigger`.\nWhen the `CompoundTrigger` instance's `nextExecutionTime` method is invoked, it delegates to the secondary trigger, if present.\nOtherwise, it delegates to the primary trigger.\n\nThe poller must also have a reference to the same `CompoundTrigger`.\n\nThe following example shows the configuration for the hourly cron expression with a fallback to every minute:\n\n[source, xml]\n----\n<int:inbound-channel-adapter channel=\"nullChannel\" auto-startup=\"false\">\n <bean class=\"org.springframework.integration.endpoint.PollerAdviceTests.Source\" />\n <int:poller trigger=\"compoundTrigger\">\n <int:advice-chain>\n <bean class=\"org.springframework.integration.aop.CompoundTriggerAdvice\">\n <constructor-arg ref=\"compoundTrigger\"/>\n <constructor-arg ref=\"secondary\"/>\n </bean>\n </int:advice-chain>\n </int:poller>\n</int:inbound-channel-adapter>\n\n<bean id=\"compoundTrigger\" class=\"org.springframework.integration.util.CompoundTrigger\">\n <constructor-arg ref=\"primary\" />\n</bean>\n\n<bean id=\"primary\" class=\"org.springframework.scheduling.support.CronTrigger\">\n <constructor-arg value=\"0 0 * * * *\" /> <!-- top of every hour -->\n</bean>\n\n<bean id=\"secondary\" class=\"org.springframework.scheduling.support.PeriodicTrigger\">\n <constructor-arg value=\"60000\" />\n</bean>\n----\n\n.Important: Async Handoff\nIMPORTANT: `CompoundTriggerAdvice` modifies the trigger based on the `receive()` result.\nThis works only if the advice is called on the poller thread.\nIt does not work if the poller has a `task-executor`.\nTo use this advice where you wish to use async operations after the result of a poll, do the async handoff later, perhaps by using an `ExecutorChannel`.\n\n[[messagesource-only-advices]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/polling-consumer.adoc", "title": "polling-consumer", "heading": "`CompoundTriggerAdvice`", "heading_level": 3, "file_order": 249, "section_index": 8, "content_hash": "8139b3d416061ed2b82caf7ceb4b984691b762a2186e857b8a6394c93b95493f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/polling-consumer.adoc"}}
{"id": "sha256:ce4a0362c7173ba516b26547e83f15c1afce0886cac66d0d2616b1c36cf6ec2e", "content": "Some advices might be applied only for the `MessageSource.receive()` and they don't make sense for `PollableChannel`.\nFor this purpose a `MessageSourceMutator` interface (an extension of the `ReceiveMessageAdvice`) is still present.\nSee xref:ftp/rotating-server-advice.adoc[Inbound Channel Adapters: Polling Multiple Servers and Directories] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/polling-consumer.adoc", "title": "polling-consumer", "heading": "MessageSource-only Advices", "heading_level": 3, "file_order": 249, "section_index": 9, "content_hash": "ce4a0362c7173ba516b26547e83f15c1afce0886cac66d0d2616b1c36cf6ec2e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/polling-consumer.adoc"}}
{"id": "sha256:40d0d2aa9713958494e2032cc619bd82320c10de43fd1a2aef850e4cf50cdc4f", "content": "[[preface]]\n\nThis chapter includes:\n\n* xref:preface.adoc#system-requirements[Requirements]\n* xref:preface.adoc#code-conventions[Code Conventions]\n* xref:preface.adoc#guide-conventions[Conventions in This Guide]\n\n[[system-requirements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/preface.adoc", "title": "preface", "heading": "preface", "heading_level": 1, "file_order": 250, "section_index": 0, "content_hash": "40d0d2aa9713958494e2032cc619bd82320c10de43fd1a2aef850e4cf50cdc4f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/preface.adoc"}}
{"id": "sha256:875d15224b4fe67ae3a632568ca823bc2e75e4932fad0dd76e0909881978d796", "content": "This section details the compatible https://www.oracle.com/technetwork/java/javase/downloads/index.html[Java] and https://spring.io/projects/spring-framework[Spring Framework] versions.\n\n[[supported-java-versions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/preface.adoc", "title": "preface", "heading": "Requirements", "heading_level": 2, "file_order": 250, "section_index": 1, "content_hash": "875d15224b4fe67ae3a632568ca823bc2e75e4932fad0dd76e0909881978d796", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/preface.adoc"}}
{"id": "sha256:2e429a3e4d536b4bba3cc62ec9ae6d5cc5e4e38f69426fb4eb08860003bfb55a", "content": "For Spring Integration 7.1.x, the minimum compatible Java version is Java SE 17.\nOlder versions of Java are not supported.\n\n[[supported-spring-versions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/preface.adoc", "title": "preface", "heading": "Compatible Java Versions", "heading_level": 3, "file_order": 250, "section_index": 2, "content_hash": "2e429a3e4d536b4bba3cc62ec9ae6d5cc5e4e38f69426fb4eb08860003bfb55a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/preface.adoc"}}
{"id": "sha256:c067d82f6065c0e9c325cc9da7d8a968b555a0fcf96307e26e4f3ed2c875c8f5", "content": "Spring Integration 7.1.x requires Spring Framework 7.0 or later.\n\n[[code-conventions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/preface.adoc", "title": "preface", "heading": "Compatible Versions of the Spring Framework", "heading_level": 3, "file_order": 250, "section_index": 3, "content_hash": "c067d82f6065c0e9c325cc9da7d8a968b555a0fcf96307e26e4f3ed2c875c8f5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/preface.adoc"}}
{"id": "sha256:fcba49ac075d27d140d041bcf6437f3a349d3c77f0f9af7d9f1ef91e3a970b1e", "content": "Spring Framework 2.0 introduced support for namespaces, which simplifies the XML configuration of the application context and lets Spring Integration provide broad namespace support.\n\nIn this reference guide, the `int` namespace prefix is used for Spring Integration's core namespace support.\nEach Spring Integration adapter type, (also called a `module`) provides its own namespace, which is configured by using the following convention:\n\nThe following example shows the `int`, `int-event`, and `int-stream` namespaces in use:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int=\"http://www.springframework.org/schema/integration\"\n xmlns:int-webflux=\"http://www.springframework.org/schema/integration/webflux\"\n xmlns:int-stream=\"http://www.springframework.org/schema/integration/stream\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration.xsd\n http://www.springframework.org/schema/integration/webflux\n https://www.springframework.org/schema/integration/webflux/spring-integration-webflux.xsd\n http://www.springframework.org/schema/integration/stream\n https://www.springframework.org/schema/integration/stream/spring-integration-stream.xsd\">\n\n</beans>\n----\n\nFor a detailed explanation regarding Spring Integration's namespace support, see xref:configuration/namespace.adoc[Namespace Support].\n\nNOTE: The namespace prefix can be freely chosen.\nYou may even choose not to use any namespace prefixes at all.\nTherefore, you should apply the convention that best suits your application.\nBe aware, though, that SpringSource Tool Suite (STS) uses the same namespace conventions for Spring Integration as used in this reference guide.\n\n[[guide-conventions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/preface.adoc", "title": "preface", "heading": "Code Conventions", "heading_level": 2, "file_order": 250, "section_index": 4, "content_hash": "fcba49ac075d27d140d041bcf6437f3a349d3c77f0f9af7d9f1ef91e3a970b1e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/preface.adoc"}}
{"id": "sha256:df2e92d28108119a61922913e64aa3c791164ef724eecc930df13659da266f3a", "content": "In some cases, to aid formatting when specifying long fully qualified class names, we shorten `org.springframework` to `o.s` and `org.springframework.integration` to `o.s.i`, such as with `o.s.i.transaction.TransactionSynchronizationFactory`.\n\n[[overview-feedback]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/preface.adoc", "title": "preface", "heading": "Conventions in This Guide", "heading_level": 2, "file_order": 250, "section_index": 5, "content_hash": "df2e92d28108119a61922913e64aa3c791164ef724eecc930df13659da266f3a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/preface.adoc"}}
{"id": "sha256:bb24f428e597b7a6f70a6ba31e99d0e9ee743ecd3259baf732a8b04583ecc3e6", "content": "For how-to questions or diagnosing or debugging issues, we suggest using Stack Overflow.\nClick https://stackoverflow.com/questions/tagged/spring-integration?tab=Newest[here] for a list of the latest questions.\nIf you're fairly certain that there is a problem in the Spring Integration or would like to suggest a feature, please use the https://github.com/spring-projects/spring-integration/issues[GitHub Issues].\n\nIf you have a solution in mind or a suggested fix, you can submit a pull request on https://github.com/spring-projects/spring-integration[GitHub].\nHowever, please keep in mind that, for all but the most trivial issues, we expect a ticket to be filed in the issue tracker, where discussions take place and leave a record for future reference.\n\nFor more details see the guidelines at the https://github.com/spring-projects/spring-integration/blob/main/CONTRIBUTING.adoc[CONTRIBUTING], top-level project page.\n\n[[overview-getting-started]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/preface.adoc", "title": "preface", "heading": "Feedback and Contributions", "heading_level": 2, "file_order": 250, "section_index": 6, "content_hash": "bb24f428e597b7a6f70a6ba31e99d0e9ee743ecd3259baf732a8b04583ecc3e6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/preface.adoc"}}
{"id": "sha256:e0580f92578b8a293bad9c07947af1ee7174cc122a243514468fe6237ad54183", "content": "If you are just getting started with Spring Integration, you may want to begin by creating a https://projects.spring.io/spring-boot/[Spring Boot]-based application.\nSpring Boot provides a quick (and opinionated) way to create a production-ready Spring-based application.\nIt is based on the Spring Framework, favors convention over configuration, and is designed to get you up and running as quickly as possible.\n\nYou can use https://start.spring.io/[start.spring.io] to generate a basic project (add `integration` as dependency) or follow one of the https://spring.io/guides[\"Getting Started\" guides], such as https://spring.io/guides/gs/integration/[Getting Started Building an Integrating Data].\nAs well as being easier to digest, these guides are very task-focused, and most of them are based on Spring Boot.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/preface.adoc", "title": "preface", "heading": "Getting Started", "heading_level": 2, "file_order": 250, "section_index": 7, "content_hash": "e0580f92578b8a293bad9c07947af1ee7174cc122a243514468fe6237ad54183", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/preface.adoc"}}
{"id": "sha256:fb2f5cbf9a6203525088726fb6173fa9852faa2d0247b2736649159d755ea2dc", "content": "[[r2dbc]]\n\nSpring Integration provides channel adapters for receiving and sending messages by using reactive access to databases via https://r2dbc.io/[R2DBC] drivers.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-r2dbc</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-r2dbc:{project-version}\"\n----\n======\n\n[[r2dbc-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/r2dbc.adoc", "title": "r2dbc", "heading": "r2dbc", "heading_level": 1, "file_order": 251, "section_index": 0, "content_hash": "fb2f5cbf9a6203525088726fb6173fa9852faa2d0247b2736649159d755ea2dc", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/r2dbc.adoc"}}
{"id": "sha256:c0e98fe44e6c9f0f5f0185e675b34c061559beda909768b4b33b8fd632256fe2", "content": "The `R2dbcMessageSource` is a pollable `MessageSource` implementation based on the `R2dbcEntityOperations` and produces messages with a `Flux` or `Mono` as a payload for data fetched from a database according an `expectSingleResult` option.\nThe query to `SELECT` can be statically provided or based on a SpEL expression which is evaluated on every `receive()` call.\nThe `R2dbcMessageSource.SelectCreator` is present as a root object for evaluation context to allow using a `StatementMapper.SelectSpec` fluent API.\nBy default, this channel adapter maps records from the select into a `LinkedCaseInsensitiveMap` instances.\nIt can be customized providing a `payloadType` options which is used underneath by the `EntityRowMapper` based on the `this.r2dbcEntityOperations.getConverter()`.\nThe `updateSql` is optional and used to mark read records in the databased for skipping from the subsequent polls.\nThe `UPDATE` operation can be supplied with a `BiFunction<DatabaseClient.GenericExecuteSpec, ?, DatabaseClient.GenericExecuteSpec>` to bind values into an `UPDATE` based on records in the `SELECT` result.\n\nA typical configuration for this channel adapter might look like this:\n\n[source, java]\n----\n@Bean\n@InboundChannelAdapter(\"fromR2dbcChannel\")\npublic R2dbcMessageSource r2dbcMessageSourceSelectMany() {\n R2dbcMessageSource r2dbcMessageSource = new R2dbcMessageSource(this.r2dbcEntityTemplate,\n \"SELECT * FROM person WHERE name='Name'\");\n r2dbcMessageSource.setPayloadType(Person.class);\n r2dbcMessageSource.setUpdateSql(\"UPDATE Person SET name='SomeOtherName' WHERE id = :id\");\n r2dbcMessageSource.setBindFunction(\n (DatabaseClient.GenericExecuteSpec bindSpec, Person o) -> bindSpec.bind(\"id\", o.getId()));}\n return r2dbcMessageSource;\n}\n----\n\nWith Java DSL a configuration for this channel adapter is like this:\n\n[source, java]\n----\n@Bean\nIntegrationFlow r2dbcDslFlow(R2dbcEntityTemplate r2dbcEntityTemplate) {\n return IntegrationFlow\n .from(R2dbc.inboundChannelAdapter(r2dbcEntityTemplate,\n (selectCreator) ->\n selectCreator.createSelect(\"person\")\n .withProjection(\"*\")\n .withCriteria(Criteria.where(\"id\").is(1)))\n .expectSingleResult(true)\n .payloadType(Person.class)\n .updateSql(\"UPDATE Person SET id='2' where id = :id\")\n .bindFunction((DatabaseClient.GenericExecuteSpec bindSpec, Person o) ->\n bindSpec.bind(\"id\", o.getId())),\n e -> e.poller(p -> p.fixedDelay(100)))\n .handle((p, h) -> p)\n .channel(MessageChannels.flux())\n .get();\n}\n----\n\n[[r2dbc-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/r2dbc.adoc", "title": "r2dbc", "heading": "R2DBC Inbound Channel Adapter", "heading_level": 2, "file_order": 251, "section_index": 1, "content_hash": "c0e98fe44e6c9f0f5f0185e675b34c061559beda909768b4b33b8fd632256fe2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/r2dbc.adoc"}}
{"id": "sha256:05779df863befc7e6125117c9bd860359b9d0bbbecb1af197682aef33d7414a8", "content": "The `R2dbcMessageHandler` is a `ReactiveMessageHandler` implementation to perform an `INSERT` (default), `UPDATE` or `DELETE` query in a database using a provided `R2dbcEntityOperations`.\nThe `R2dbcMessageHandler.Type` can be configured statically or via a SpEL expression against request message.\nThe query to execute can be based on the `tableName`, `values` and `criteria` expression options or (if `tableName` is not provided) the whole message payload is treated as an `org.springframework.data.relational.core.mapping.Table` entity to perform SQL against.\nThe package `org.springframework.data.relational.core.query` is registered as an import into a SpEL evaluation context for direct access to the `Criteria` fluent API which is used for `UPDATE` and `DELETE` queries.\nThe `valuesExpression` is used in the `INSERT` and `UPDATE` and must be evaluated to the `Map` for column-value pairs to perform a change in the target table against a request message.\n\nA typical configuration for this channel adapter might look like this:\n\n[source, java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"toR2dbcChannel\")\npublic R2dbcMessageHandler r2dbcMessageHandler(R2dbcEntityTemplate r2dbcEntityTemplate) {\n R2dbcMessageHandler messageHandler = new R2dbcMessageHandler(r2dbcEntityTemplate)\n messageHandler.setValuesExpression(new FunctionExpression<Message<?>>(Message::getPayload));\n messageHandler.setQueryType(R2dbcMessageHandler.Type.UPDATE);\n messageHandler.setCriteriaExpression(\n EXPRESSION_PARSER.parseExpression(\"T(Criteria).where('id).is(headers.personId)));\n return messageHandler;\n}\n----\n\nWith Java DSL a configuration for this channel adapter is like this:\n\n[source, java]\n----\n.handleReactive(R2dbc.outboundChannelAdapter(r2dbcEntityTemplate)\n .queryType(R2dbcMessageHandler.Type.UPDATE)\n .tableNameExpression(\"payload.class.simpleName\")\n .criteria((message) -> Criteria.where(\"id\").is(message.getHeaders().get(\"personId\")))\n .values(\"{age:36}\"))\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/r2dbc.adoc", "title": "r2dbc", "heading": "R2DBC Outbound Channel Adapter", "heading_level": 2, "file_order": 251, "section_index": 2, "content_hash": "05779df863befc7e6125117c9bd860359b9d0bbbecb1af197682aef33d7414a8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/r2dbc.adoc"}}
{"id": "sha256:ef3a58da8b22d64cc71cd7fd3fba73648968027dfa03b0f56c53dfdae639cd69", "content": "[[reactive-streams]]\n\nSpring Integration provides support for https://www.reactive-streams.org/[Reactive Streams] interaction in some places of the framework and from different aspects.\nWe will discuss most of them here with appropriate links to the target chapters for details whenever necessary.\n\n[[preface]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "reactive-streams", "heading_level": 1, "file_order": 252, "section_index": 0, "content_hash": "ef3a58da8b22d64cc71cd7fd3fba73648968027dfa03b0f56c53dfdae639cd69", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:d13bd178b7f7f1106a9da3c8e7c5b099a77f0f2dd8ffebf67c68df8b5e53ade3", "content": "To recap, Spring Integration extends the Spring programming model to support the well-known Enterprise Integration Patterns.\nSpring Integration enables lightweight messaging within Spring-based applications and supports integration with external systems via declarative adapters.\nSpring Integrations primary goal is to provide a simple model for building enterprise integration solutions while maintaining the separation of concerns that is essential for producing maintainable, testable code.\nThis goal is achieved in the target application using first-class citizens like `message`, `channel` and `endpoint`, which allow us to build an integration flow (pipeline), where (in most cases) one endpoint produces messages into a channel to be consumed by another endpoint.\nThis way we distinguish an integration interaction model from the target business logic.\nThe crucial part here is a channel in between: the flow behavior depends on its implementation, leaving endpoints untouched.\n\nOn the other hand, the Reactive Streams is a standard for asynchronous stream processing with non-blocking back pressure.\nThe main goal of Reactive Streams is to govern the exchange of stream data across an asynchronous boundary  like passing elements on to another thread or thread-pool  while ensuring that the receiving side is not forced to buffer arbitrary amounts of data.\nIn other words, back pressure is an integral part of this model in order to allow the queues which mediate between threads to be bounded.\nThe intention of Reactive Streams implementation, such as https://projectreactor.io/[Project Reactor], is to preserve these benefits and characteristics across the whole processing graph of a stream application.\nThe ultimate goal of Reactive Streams libraries is to provide types, set of operators and supporting API for a target application in a transparent and smooth manner as is possible with available programming language structure, but the final solution is not as imperative as it is with a normal function chain invocation.\nIt is divided into to phases: definition and execution, which happens some time later during subscription to the final reactive publisher, and demand for data is pushed from the bottom of the definition to the top applying back-pressure as needed - we request as many events as we can handle at the moment.\nThe reactive application looks like a `\"stream\"` or as we got used to in Spring Integration terms - `\"flow\"`.\nIn fact the Reactive Streams SPI since Java 9 is presented in the `java.util.concurrent.Flow` class.\n\nFrom here it may look like Spring Integration flows are really a good fit for writing Reactive Streams applications when we apply some reactive framework operators on endpoints, but in fact the problems is much broader and we need to keep in mind that not all endpoints (e.g. `JdbcMessageHandler`) can be processed in a reactive stream transparently.\nOf course, the main goal for Reactive Streams support in Spring Integration is to allow the whole process to be fully reactive, on demand initiated and back-pressure ready.\nIt is not going to be possible until the target protocols and systems for channel adapters provide a Reactive Streams interaction model.\nIn the sections below we will describe what components and approaches are provided in Spring Integration for developing reactive application preserving integration flow structures.\n\nNOTE: All the Reactive Streams interaction in Spring Integration implemented with https://projectreactor.io/[Project Reactor] types, such as `Mono` and `Flux`.\n\n[[messaging-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "Preface", "heading_level": 2, "file_order": 252, "section_index": 1, "content_hash": "d13bd178b7f7f1106a9da3c8e7c5b099a77f0f2dd8ffebf67c68df8b5e53ade3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:ef0eca828b33fa9838dad0e1bf360bcbc44dfc3bb43bdccacbe3a6b72fac3587", "content": "The simplest point of interaction with Reactive Streams is a `@MessagingGateway` where we just make a return type of the gateway method as a `Mono<?>` - and the whole integration flow behind a gateway method call is going to be performed when a subscription happens on the returned `Mono` instance.\nSee xref:gateway.adoc#reactor-mono[Reactor `Mono`] for more information.\nA similar `Mono`-reply approach is used in the framework internally for inbound gateways which are fully based on Reactive Streams compatible protocols (see xref:reactive-streams.adoc#reactive-channel-adapters[Reactive Channel Adapters] below for more information).\nThe send-and-receive operation is wrapped into a `Mono.defer()` with chaining a reply evaluation from the `replyChannel` header whenever it is available.\nThis way an inbound component for the particular reactive protocol (e.g. Netty) is going to be as a subscriber and initiator for a reactive flow performed on the Spring Integration.\nIf the request payload is a reactive type, it would be better to handle it within a reactive stream definition deferring a process to the initiator subscription.\nFor this purpose a handler method must return a reactive type as well.\nSee the next section for more information.\n\n[[reactive-reply-payload]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "Messaging Gateway", "heading_level": 2, "file_order": 252, "section_index": 2, "content_hash": "ef0eca828b33fa9838dad0e1bf360bcbc44dfc3bb43bdccacbe3a6b72fac3587", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:dd2c964284893b4e1b8749cef51280ca81a32b160d4ee6a03ddca4dd8b3707f0", "content": "When a reply producing `MessageHandler` returns a reactive type payload for a reply message, it is processed in an asynchronous manner with a regular `MessageChannel` implementation provided for the `outputChannel` (the `async` must be set to `true`) and flattened with on demand subscription when the output channel is a `ReactiveStreamsSubscribableChannel` implementation, e.g. `FluxMessageChannel`.\nWith a standard imperative `MessageChannel` use-case, and if a reply payload is a *multi-value* publisher (see `ReactiveAdapter.isMultiValue()` for more information), it is wrapped into a `Mono.just()`.\nA result of this, the `Mono` has to be subscribed explicitly downstream or flattened by the `FluxMessageChannel` downstream.\nWith a `ReactiveStreamsSubscribableChannel` for the `outputChannel`, there is no need to be concerned about return type and subscription; everything is processed smoothly by the framework internally.\n\nSee xref:service-activator.adoc#async-service-activator[Asynchronous Service Activator] for more information.\n\nAlso see xref:kotlin-functions.adoc#kotlin-coroutines[Kotlin Coroutines] for more information.\n\n[[fluxmessagechannel-and-reactivestreamsconsumer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "Reactive Reply Payload", "heading_level": 2, "file_order": 252, "section_index": 3, "content_hash": "dd2c964284893b4e1b8749cef51280ca81a32b160d4ee6a03ddca4dd8b3707f0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:d354e048872e2e5809fcc323babe08595f662d88f61ca26d5cc551b77807de65", "content": "The `FluxMessageChannel` is a combined implementation of `MessageChannel` and `Publisher<Message<?>>`.\nA `Flux`, as a hot source, is created internally for sinking incoming messages from the `send()` implementation.\nThe `Publisher.subscribe()` implementation is delegated to that internal `Flux`.\nAlso, for on demand upstream consumption, the `FluxMessageChannel` provides an implementation for the `ReactiveStreamsSubscribableChannel` contract.\nAny upstream `Publisher` (see Source Polling Channel Adapter and splitter below, for example) provided for this channel, is auto-subscribed when subscription is ready for this channel.\nEvents from this delegating publisher are sunk into an internal `Flux` mentioned above.\n\nA consumer for the `FluxMessageChannel` must be a `org.reactivestreams.Subscriber` instance for honoring the Reactive Streams contract.\nFortunately, all of the `MessageHandler` implementations in Spring Integration also implement a `CoreSubscriber` from project Reactor.\nAnd thanks to a `ReactiveStreamsConsumer` implementation in between, the whole integration flow configuration is left transparent for target developers.\nIn this case, the flow behavior is changed from an imperative push model to a reactive pull model.\nA `ReactiveStreamsConsumer` can also be used to turn any `MessageChannel` into a reactive source using `IntegrationReactiveUtils`, making an integration flow partially reactive.\n\nSee xref:channel/implementations.adoc#flux-message-channel[`FluxMessageChannel`] for more information.\n\nStarting with version 5.5, the `ConsumerEndpointSpec` introduces a `reactive()` option to make the endpoint in the flow as a `ReactiveStreamsConsumer` independently of the input channel.\nThe optional `Function<? super Flux<Message<?>>, ? extends Publisher<Message<?>>>` can be provided to customise a source `Flux` from the input channel via `Flux.transform()` operation, e.g. with the `publishOn()`, `doOnNext()`, `retry()` etc.\nThis functionality is represented as a `@Reactive` sub-annotation for all the messaging annotation (`@ServiceActivator`, `@Splitter` etc.) via their `reactive()` attribute.\n\n[[source-polling-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "`FluxMessageChannel` and `ReactiveStreamsConsumer`", "heading_level": 2, "file_order": 252, "section_index": 4, "content_hash": "d354e048872e2e5809fcc323babe08595f662d88f61ca26d5cc551b77807de65", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:33f8b6cccc147bc8fbded1c936588be655d9a6188ab7c5eb6ad3ca6c567174d7", "content": "Usually, the `SourcePollingChannelAdapter` relies on the task which is initiated by the `TaskScheduler`.\nA polling trigger is built from the provided options and used for periodic scheduling a task to poll a target source of data or events.\nWhen an `outputChannel` is a `ReactiveStreamsSubscribableChannel`, the same `Trigger` is used to determine the next time for execution, but instead of scheduling tasks, the `SourcePollingChannelAdapter` creates a `Flux<Message<?>>` based on the `Flux.generate()` for the `nextExecutionTime` values and `Mono.delay()` for a duration from the previous step.\nA `Flux.flatMapMany()` is used then to poll `maxMessagesPerPoll` and sink them into an output `Flux`.\nThis generator `Flux` is subscribed by the provided `ReactiveStreamsSubscribableChannel` honoring a back-pressure downstream.\nStarting with version 5.5, when `maxMessagesPerPoll == 0`, the source is not called at all, and `flatMapMany()` is completed immediately via a `Mono.empty()` result until the `maxMessagesPerPoll` is changed to non-zero value at a later time, e.g. via a Control Bus.\nThis way, any `MessageSource` implementation can be turned into a reactive hot source.\n\nSee xref:polling-consumer.adoc#polling-consumer[Polling Consumer] for more information.\n\n[[event-driven-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "Source Polling Channel Adapter", "heading_level": 2, "file_order": 252, "section_index": 5, "content_hash": "33f8b6cccc147bc8fbded1c936588be655d9a6188ab7c5eb6ad3ca6c567174d7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:19c27a6f4010c5855afcccef678a4d69b1f73265eead2973739ef2a8718671d8", "content": "`MessageProducerSupport` is the base class for event-driven channel adapters and, typically, its `sendMessage(Message<?>)` is used as a listener callback in the producing driver API.\nThis callback can also be easily plugged into the `doOnNext()` Reactor operator when a message producer implementation builds a `Flux` of messages instead of listener-based functionality.\nIn fact, this is done in the framework when an `outputChannel` of the message producer is not a `ReactiveStreamsSubscribableChannel`.\nHowever, for improved end-user experience, and to allow more back-pressure ready functionality, the `MessageProducerSupport` provides a `subscribeToPublisher(Publisher<? extends Message<?>>)` API to be used in the target implementation when a `Publisher<Message<?>>>` is the source of data from the target system.\nTypically, it is used from the `doStart()` implementation when target driver API is called for a `Publisher` of source data.\nIt is recommended to combine a reactive `MessageProducerSupport` implementation with a `FluxMessageChannel` as the `outputChannel` for on-demand subscription and event consumption downstream.\nThe channel adapter goes to a stopped state when a subscription to the `Publisher` is cancelled.\nCalling `stop()` on such a channel adapter completes the producing from the source `Publisher`.\nThe channel adapter can be restarted with automatic subscription to a newly created source `Publisher`.\n\n[[message-source-to-reactive-streams]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "Event-Driven Channel Adapter", "heading_level": 2, "file_order": 252, "section_index": 6, "content_hash": "19c27a6f4010c5855afcccef678a4d69b1f73265eead2973739ef2a8718671d8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:a99feaf5208255cd3a75a7d85fccfbfb062b7e4e2c56be2f2be7bfc269144f4f", "content": "Starting with version 5.3, a `ReactiveMessageSourceProducer` is provided.\nIt is a combination of a provided `MessageSource` and event-driven production into the configured `outputChannel`.\nInternally it wraps a `MessageSource` into the repeatedly resubscribed `Mono` producing a `Flux<Message<?>>` to be subscribed in the `subscribeToPublisher(Publisher<? extends Message<?>>)` mentioned above.\nThe subscription for this `Mono` is done using `Schedulers.boundedElastic()` to avoid possible blocking in the target `MessageSource`.\nWhen the message source returns `null` (no data to pull), the `Mono` is turned into a `repeatWhenEmpty()` state with a `delay` for a subsequent re-subscription based on a `IntegrationReactiveUtils.DELAY_WHEN_EMPTY_KEY` `Duration` entry from the subscriber context.\nBy default, it is 1 second.\nIf the `MessageSource` produces messages with a `IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK` information in the headers, it is acknowledged (if necessary) in the `doOnSuccess()` of the original `Mono` and rejected in the `doOnError()` if the downstream flow throws a `MessagingException` with the failed message to reject.\nThis `ReactiveMessageSourceProducer` could be used for any use-case when a polling channel adapter's features should be turned into a reactive, on demand solution for any existing `MessageSource<?>` implementation.\n\n[[splitter-and-aggregator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "Message Source to Reactive Streams", "heading_level": 2, "file_order": 252, "section_index": 7, "content_hash": "a99feaf5208255cd3a75a7d85fccfbfb062b7e4e2c56be2f2be7bfc269144f4f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:f03aa5277f800eac03d1bdf648eacc01693bcadebea24d0440885ebda607ca0a", "content": "When an `AbstractMessageSplitter` gets a `Publisher` for its logic, the process goes naturally over the items in the `Publisher` to map them into messages for sending to the `outputChannel`.\nIf this channel is a `ReactiveStreamsSubscribableChannel`, the `Flux` wrapper for the `Publisher` is subscribed on demand from that channel and this splitter behavior looks more like a `flatMap` Reactor operator, when we map an incoming event into multi-value output `Publisher`.\nIt makes most sense when the whole integration flow is built with a `FluxMessageChannel` before and after the splitter, aligning Spring Integration configuration with a Reactive Streams requirement and its operators for event processing.\nWith a regular channel, a `Publisher` is converted into an `Iterable` for standard iterate-and-produce splitting logic.\n\nA `FluxAggregatorMessageHandler` is another sample of specific Reactive Streams logic implementation which could be treated as a `\"reactive operator\"` in terms of Project Reactor.\nIt is based on the `Flux.groupBy()` and `Flux.window()` (or `buffer()`) operators.\nThe incoming messages are sunk into a `Flux.create()` initiated when a `FluxAggregatorMessageHandler` is created, making it as a hot source.\nThis `Flux` is subscribed to by a `ReactiveStreamsSubscribableChannel` on demand, or directly in the `FluxAggregatorMessageHandler.start()` when the `outputChannel` is not reactive.\nThis `MessageHandler` has its power, when the whole integration flow is built with a `FluxMessageChannel` before and after this component, making the whole logic back-pressure ready.\n\nSee xref:splitter.adoc#split-stream-and-flux[Stream and Flux Splitting] and xref:aggregator.adoc#flux-aggregator[Flux Aggregator] for more information.\n\n[[java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "Splitter and Aggregator", "heading_level": 2, "file_order": 252, "section_index": 8, "content_hash": "f03aa5277f800eac03d1bdf648eacc01693bcadebea24d0440885ebda607ca0a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:5bea28411dcb06c91e0ea0faa02bf285e0c38d07fb7bed9b1b4f8b3c4d60ec54", "content": "An `IntegrationFlow` in Java DSL can start from any `Publisher` instance (see `IntegrationFlow.from(Publisher<Message<T>>)`).\nAlso, with an `IntegrationFlowBuilder.toReactivePublisher()` operator, the `IntegrationFlow` can be turned into a reactive hot source.\nA `FluxMessageChannel` is used internally in both cases; it can subscribe to an inbound `Publisher` according to its `ReactiveStreamsSubscribableChannel` contract, and it is a `Publisher<Message<?>>` by itself for downstream subscribers.\nWith a dynamic `IntegrationFlow` registration we can implement a powerful logic combining Reactive Streams with this integration flow bridging to/from `Publisher`.\n\nStarting with version 5.5.6, a `toReactivePublisher(boolean autoStartOnSubscribe)` operator variant is present to control a lifecycle of the whole `IntegrationFlow` behind the returned `Publisher<Message<?>>`.\nTypically, the subscription and consumption from the reactive publisher happens in the later runtime phase, not during reactive stream composition, or even `ApplicationContext` startup.\nTo avoid boilerplate code for lifecycle management of the `IntegrationFlow` at the `Publisher<Message<?>>` subscription point and for better end-user experience, this new operator with the `autoStartOnSubscribe` flag has been introduced.\nIt marks (if `true`) the `IntegrationFlow` and its components for `autoStartup = false`, so an `ApplicationContext` won't initiate production and consumption of messages in the flow automatically.\nInstead, the `start()` for the `IntegrationFlow` is initiated from the internal `Flux.doOnSubscribe()`.\nIndependently of the `autoStartOnSubscribe` value, the flow is stopped from a `Flux.doOnCancel()` and `Flux.doOnTerminate()` - it does not make sense to produce messages if there is nothing to consume them.\n\nFor the exact opposite use-case, when `IntegrationFlow` should call a reactive stream and continue after completion, a `fluxTransform()` operator is provided in the `IntegrationFlowDefinition`.\nThe flow at this point is turned into a `FluxMessageChannel` which is propagated into a provided `fluxFunction`, performed in the `Flux.transform()` operator.\nA result of the function is wrapped into a `Mono<Message<?>>` for flat-mapping into an output `Flux` which is subscribed by another `FluxMessageChannel` for downstream flow.\n\nSee xref:dsl.adoc#java-dsl[Java DSL Chapter] for more information.\n\n[[reactive-message-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "Java DSL", "heading_level": 2, "file_order": 252, "section_index": 9, "content_hash": "5bea28411dcb06c91e0ea0faa02bf285e0c38d07fb7bed9b1b4f8b3c4d60ec54", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:22b57e481c578678fa7c53e911b53bc12bf1765c721432be68193e69b0c6883e", "content": "Starting with version 5.3, the `ReactiveMessageHandler` is supported natively in the framework.\nThis type of message handler is designed for reactive clients which return a reactive type for on-demand subscription for low-level operation execution and doesn't provide any reply data to continue a reactive stream composition.\nWhen a `ReactiveMessageHandler` is used in the imperative integration flow, the `handleMessage()` result in subscribed immediately after return, just because there is no reactive streams composition in such a flow to honor back-pressure.\nIn this case the framework wraps this `ReactiveMessageHandler` into a `ReactiveMessageHandlerAdapter` - a plain implementation of `MessageHandler`.\nHowever, when a `ReactiveStreamsConsumer` is involved in the flow (e.g. when channel to consume is a `FluxMessageChannel`), such a `ReactiveMessageHandler` is composed to the whole reactive stream with a `flatMap()` Reactor operator to honor back-pressure during consumption.\n\nOne of the out-of-the-box `ReactiveMessageHandler` implementation is a `ReactiveMongoDbStoringMessageHandler` for Outbound Channel Adapter.\nSee xref:mongodb.adoc#mongodb-reactive-channel-adapters[MongoDB Reactive Channel Adapters] for more information.\n\nStarting with version 6.1, the `IntegrationFlowDefinition` exposes a convenient `handleReactive(ReactiveMessageHandler)` terminal operator.\nAny `ReactiveMessageHandler` implementation (even just a plain lambda using the `Mono` API) can be used for this operator.\nThe framework subscribes to the returned `Mono<Void>` automatically.\nHere is a simple sample of a possible configuration for this operator:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow wireTapFlow1() {\n return IntegrationFlow.from(\"tappedChannel1\")\n .wireTap(\"tapChannel\", wt -> wt.selector(m -> m.getPayload().equals(\"foo\")))\n .handleReactive((message) -> Mono.just(message).log().then());\n}\n----\n\nAn overloaded version of this operator accepts a `Consumer<GenericEndpointSpec<ReactiveMessageHandlerAdapter>>` to customize a consumer endpoint around the provided `ReactiveMessageHandler`.\n\nIn addition, a `ReactiveMessageHandlerSpec`-based variants are also provided.\nIn most cases they are used for protocol-specific channel adapter implementations.\nSee the next section following links to the target technologies with respective reactive channel adapters.\n\n[[reactive-channel-adapters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "`ReactiveMessageHandler`", "heading_level": 2, "file_order": 252, "section_index": 10, "content_hash": "22b57e481c578678fa7c53e911b53bc12bf1765c721432be68193e69b0c6883e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:b582c88ce51ba4df21f41ffaf48036a895c9f1921f03ac143a40777472f9adc1", "content": "When the target protocol for integration provides a Reactive Streams solution, it becomes straightforward to implement channel adapters in Spring Integration.\n\nAn inbound, event-driven channel adapter implementation is about wrapping a request (if necessary) into a deferred `Mono` or `Flux` and perform a `send` (and produce reply, if any) only when a protocol component initiates a subscription into a `Mono` returned from the listener method.\nThis way we have a reactive stream solution encapsulated exactly in this component.\nOf course, downstream integration flow subscribed on the output channel should honor Reactive Streams specification and be performed in the on-demand, back-pressure ready manner.\n\nThis is not always available by the nature (or with the current implementation) of `MessageHandler` processor used in the integration flow.\nThis limitation can be handled using thread pools and queues or `FluxMessageChannel` (see above) before and after integration endpoints when there is no reactive implementation.\n\nAn example for a reactive **event-driven** inbound channel adapter:\n\n[source, java]\n----\npublic class CustomReactiveMessageProducer extends MessageProducerSupport {\n\n private final CustomReactiveSource customReactiveSource;\n\n public CustomReactiveMessageProducer(CustomReactiveSource customReactiveSource) {\n Assert.notNull(customReactiveSource, \"'customReactiveSource' must not be null\");\n this.customReactiveSource = customReactiveSource;\n }\n\n @Override\n protected void doStart() {\n Flux<Message<?>> messageFlux =\n this.customReactiveSource\n .map(event - >\n MessageBuilder\n .withPayload(event.getBody())\n .setHeader(MyReactiveHeaders.SOURCE_NAME, event.getSourceName())\n .build());\n\n subscribeToPublisher(messageFlux);\n }\n}\n----\n\nUsage would look like:\n\n[source, java]\n----\npublic class MainFlow {\n @Autowired\n private CustomReactiveMessageProducer customReactiveMessageProducer;\n\n @Bean\n public IntegrationFlow buildFlow() {\n return IntegrationFlow.from(customReactiveMessageProducer)\n .channel(outputChannel)\n .get();\n }\n}\n----\n\nOr in a declarative way:\n\n[source, java]\n----\npublic class MainFlow {\n @Bean\n public IntegrationFlow buildFlow() {\n return IntegrationFlow.from(new CustomReactiveMessageProducer(new CustomReactiveSource()))\n .handle(outputChannel)\n .get();\n }\n}\n----\n\nOr even without a channel adapter, we can always use the Java DSL in the following way:\n\n[source, java]\n----\npublic class MainFlow {\n @Bean\n public IntegrationFlow buildFlow() {\n Flux<Message<?>> myFlux = this.customReactiveSource\n .map(event ->\n MessageBuilder\n .withPayload(event.getBody())\n .setHeader(MyReactiveHeaders.SOURCE_NAME, event.getSourceName())\n .build());\n return IntegrationFlow.from(myFlux)\n .handle(outputChannel)\n .get();\n }\n}\n----\n\nA reactive outbound channel adapter implementation is about the initiation (or continuation) of a reactive stream to interaction with an external system according to the provided reactive API for the target protocol.\nAn inbound payload could be a reactive type per se or as an event of the whole integration flow, which is a part of the reactive stream on top.\nA returned reactive type can be subscribed immediately if we are in a one-way, fire-and-forget scenario, or it is propagated downstream (request-reply scenarios) for further integration flow or an explicit subscription in the target business logic, but still downstream preserving reactive streams semantics.\n\nAn example for a reactive outbound channel adapter:\n\n[source, java]\n----\npublic class CustomReactiveMessageHandler extends AbstractReactiveMessageHandler {\n\n private final CustomEntityOperations customEntityOperations;\n\n public CustomReactiveMessageHandler(CustomEntityOperations customEntityOperations) {\n Assert.notNull(customEntityOperations, \"'customEntityOperations' must not be null\");\n this.customEntityOperations = customEntityOperations;\n }\n\n @Override\n protected Mono<Void> handleMessageInternal(Message<?> message) {\n return Mono.fromSupplier(() -> message.getHeaders().get(\"queryType\", Type.class))\n .flatMap(mode -> {\n switch (mode) {\n case INSERT:\n return handleInsert(message);\n case UPDATE:\n return handleUpdate(message);\n default:\n return Mono.error(new IllegalArgumentException());\n }\n }).then();\n }\n\n private Mono<Void> handleInsert(Message<?> message) {\n return this.customEntityOperations.insert(message.getPayload())\n .then();\n }\n\n private Mono<Void> handleUpdate(Message<?> message) {\n return this.r2dbcEntityOperations.update(message.getPayload())\n .then();\n }\n\n public enum Type {\n INSERT,\n UPDATE,\n }\n}\n----\n\nWe will be able to use both of the channel adapters:\n\n[source, java]\n----\npublic class MainFlow {\n\n @Autowired\n private CustomReactiveMessageProducer customReactiveMessageProducer;\n\n @Autowired\n private CustomReactiveMessageHandler customReactiveMessageHandler;\n\n @Bean\n public IntegrationFlow buildFlow() {\n return IntegrationFlow.from(customReactiveMessageProducer)\n .transform(someOperation)\n .handle(customReactiveMessageHandler)\n .get();\n }\n}\n----\n\nCurrently, Spring Integration provides channel adapter (or gateway) implementations for xref:webflux.adoc[WebFlux], xref:rsocket.adoc[RSocket], xref:mongodb.adoc[MongoDb], xref:r2dbc.adoc[R2DBC], xref:zeromq.adoc[ZeroMQ], xref:graphql.adoc[GraphQL], xref:cassandra.adoc[Apache Cassandra].\nThe xref:redis.adoc#redis-stream-outbound[Redis Stream Channel Adapters] are also reactive and uses `ReactiveStreamOperations` from Spring Data.\nMore reactive channel adapters are coming, for example for Apache Kafka in xref:kafka.adoc[Kafka] based on the `ReactiveKafkaProducerTemplate` and `ReactiveKafkaConsumerTemplate` from https://spring.io/projects/spring-kafka[Spring for Apache Kafka] etc.\nFor many other non-reactive channel adapters thread pools are recommended to avoid blocking during reactive stream processing.\n\n[[context-propagation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "Reactive Channel Adapters", "heading_level": 2, "file_order": 252, "section_index": 11, "content_hash": "b582c88ce51ba4df21f41ffaf48036a895c9f1921f03ac143a40777472f9adc1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:9b6b3aeb4a34d600cc4e2dc2a1fe5e45c709cf7f1a3a243cfb77ff217c96e387", "content": "When the https://github.com/micrometer-metrics/context-propagation[Context Propagation] library is on the classpath, the Project Reactor can take `ThreadLocal` values (e.g. https://micrometer.io/docs/observation[Micrometer Observation] or `SecurityContextHolder`) and store them into a `Subscriber` context.\nThe opposite operation is also possible when we need to populate a logging MDC for tracing or let services we call from the reactive stream to restore an observation from the scope.\nSee more information in Project Reactor https://projectreactor.io/docs/core/release/reference/#context.propagation[documentation] about its special operators for context propagation.\nThe storing and restoring context works smoothly if our whole solution is a single reactive stream composition since a `Subscriber` context is visible from downstream up to the beginning of the composition(`Flux` or `Mono`).\nBut, if the application switches between different `Flux` instances or into imperative processing and back, then the context tied to the `Subscriber` might not be available.\nFor such a use case, Spring Integration provides an additional capability (starting with version `6.0.5`) to store a Reactor `ContextView` into the `IntegrationMessageHeaderAccessor.REACTOR_CONTEXT` message header produced from the reactive stream, e.g. when we perform direct `send()` operation.\nThis header is used then in the `FluxMessageChannel.subscribeTo()` to restore a Reactor context for the `Message` that this channel is going to emit.\nCurrently, this header is populated from the `WebFluxInboundEndpoint` and `RSocketInboundGateway` components, but can be used in any solution where reactive to imperative integration is performed.\nThe logic to populate this header is like this:\n\n[source, java]\n----\nreturn requestMono\n .flatMap((message) ->\n Mono.deferContextual((context) ->\n Mono.just(message)\n .handle((messageToSend, sink) ->\n send(messageWithReactorContextIfAny(messageToSend, context)))));\n...\n\nprivate Message<?> messageWithReactorContextIfAny(Message<?> message, ContextView context) {\n if (!context.isEmpty()) {\n return getMessageBuilderFactory()\n .fromMessage(message)\n .setHeader(IntegrationMessageHeaderAccessor.REACTOR_CONTEXT, context)\n .build();\n }\n return message;\n}\n----\n\nNote that we still need to use a `handle()` operator to make Reactor restore `ThreadLocal` values from the context.\nEven if it is sent as a header, the framework cannot make an assumption if it is going to be to restore onto `ThreadLocal` values downstream.\n\nTo restore the context from a `Message` on the other `Flux` or `Mono` composition, this logic can be performed:\n\n[source, java]\n----\nMono.just(message)\n .handle((messageToHandle, sink) -> ...)\n .contextWrite(StaticMessageHeaderAccessor.getReactorContext(message)));\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/reactive-streams.adoc", "title": "reactive-streams", "heading": "Reactive to Imperative Context Propagation", "heading_level": 2, "file_order": 252, "section_index": 12, "content_hash": "9b6b3aeb4a34d600cc4e2dc2a1fe5e45c709cf7f1a3a243cfb77ff217c96e387", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/reactive-streams.adoc"}}
{"id": "sha256:aa1bb83bd4b9f8efec2de424267e3bc344875110b552a32e14603f2edb678bbf", "content": "[[redis]]\n\nSpring Integration 2.1 introduced support for https://redis.io/[Redis]: \"`an open source advanced key-value store`\".\nThis support comes in the form of a Redis-based `MessageStore` as well as publish-subscribe messaging adapters that are supported by Redis through its https://redis.io/topics/pubsub[`PUBLISH`, `SUBSCRIBE`, and `UNSUBSCRIBE`] commands.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-redis</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-redis:{project-version}\"\n----\n======\n\nThe Redis client dependency must be included, e.g. https://redis.io/docs/latest/develop/clients/lettuce[Lettuce].\n\nTo download, install, and run Redis, see the https://redis.io/download[Redis documentation].\n\n[[redis-connection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "redis", "heading_level": 1, "file_order": 253, "section_index": 0, "content_hash": "aa1bb83bd4b9f8efec2de424267e3bc344875110b552a32e14603f2edb678bbf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:2d0306f63f09d4a8788bee80ec0198e8bd976c0222a0571be068f8f449389eb9", "content": "To begin interacting with Redis, a connection must be obtained first.\nSpring Integration uses support provided by another Spring project, https://github.com/SpringSource/spring-data-redis[Spring Data Redis], which provides typical Spring constructs: `ConnectionFactory` and `Template`.\nThose abstractions simplify integration with several Redis client Java APIs.\nCurrently, Spring Data Redis supports https://github.com/xetorthio/jedis[Jedis] and https://lettuce.io/[Lettuce].\n\n[[using-redisconnectionfactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Connecting to Redis", "heading_level": 2, "file_order": 253, "section_index": 1, "content_hash": "2d0306f63f09d4a8788bee80ec0198e8bd976c0222a0571be068f8f449389eb9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:b63a63239dd80817c7e6f65111943ec752bb7973beb22d79f30372842cdee2ea", "content": "The `RedisConnectionFactory` from Spring Data Redis is a high-level abstraction for managing connections with Redis.\nThe following listing shows the interface definition:\n\n[source,java]\n----\npublic interface RedisConnectionFactory extends PersistenceExceptionTranslator {\n\n /**\n * Provides a suitable connection for interacting with Redis.\n * @return connection for interacting with Redis.\n */\n RedisConnection getConnection();\n}\n----\n\nThe following example shows how to create a `LettuceConnectionFactory` in Java:\n\n[source,java]\n----\nLettuceConnectionFactory cf = new LettuceConnectionFactory();\ncf.afterPropertiesSet();\n----\n\nThe following example shows how to create a `LettuceConnectionFactory` in Spring's XML configuration:\n\n[source,xml]\n----\n<bean id=\"redisConnectionFactory\"\n class=\"o.s.data.redis.connection.lettuce.LettuceConnectionFactory\">\n <property name=\"port\" value=\"7379\" />\n</bean>\n----\n\nThe implementations of `RedisConnectionFactory` provide a set of properties, such as port and host.\nOnce an instance of `RedisConnectionFactory` exists, the `RedisTemplate` can be created.\n\n[[using-redistemplate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Using `RedisConnectionFactory`", "heading_level": 3, "file_order": 253, "section_index": 2, "content_hash": "b63a63239dd80817c7e6f65111943ec752bb7973beb22d79f30372842cdee2ea", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:2297d47c0603a7f5fdad6a1a2f3aaa883237799c4a0bcd5ca4a972122f8e4b45", "content": "As with other template classes in Spring (such as `JdbcTemplate` and `JmsTemplate`) `RedisTemplate` is a helper class that simplifies Redis data access code.\nFor more information about `RedisTemplate` and its variations (such as `StringRedisTemplate`) see the https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/[Spring Data Redis documentation].\n\nThe following example shows how to create an instance of `RedisTemplate` in Java:\n\n[source,java]\n----\nRedisTemplate rt = new RedisTemplate<String, Object>();\nrt.setConnectionFactory(redisConnectionFactory);\n----\n\nThe following example shows how to create an instance of `RedisTemplate` in Spring's XML configuration:\n\n[source,xml]\n----\n<bean id=\"redisTemplate\"\n class=\"org.springframework.data.redis.core.RedisTemplate\">\n <property name=\"connectionFactory\" ref=\"redisConnectionFactory\"/>\n</bean>\n----\n\n[[redis-messages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Using `RedisTemplate`", "heading_level": 3, "file_order": 253, "section_index": 3, "content_hash": "2297d47c0603a7f5fdad6a1a2f3aaa883237799c4a0bcd5ca4a972122f8e4b45", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:7e20611744598909d5c6c9a38b9a556a54c1e60941f4677d960c218d17af7322", "content": "As mentioned in xref:redis.adoc[the introduction], Redis provides support for publish-subscribe messaging through its `PUBLISH`, `SUBSCRIBE`, and `UNSUBSCRIBE` commands.\nAs with JMS and AMQP, Spring Integration provides message channels and adapters for sending and receiving messages through Redis.\n\n[[redis-pub-sub-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Messaging with Redis", "heading_level": 2, "file_order": 253, "section_index": 4, "content_hash": "7e20611744598909d5c6c9a38b9a556a54c1e60941f4677d960c218d17af7322", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:1845f816e5a4d6f6e8798d4c0f561968946ee0bd8d2c722c538dbe845153e37e", "content": "Similarly to JMS, there are cases where both the producer and consumer are intended to be part of the same application, running within the same process.\nThis can be accomplished with a pair of inbound and outbound channel adapters.\nHowever, as with Spring Integration's JMS support, there is a simpler way to address this use case.\nInstead, a publish-subscribe channel can be used, as the following example shows:\n\n[source,xml]\n----\n<int-redis:publish-subscribe-channel id=\"redisChannel\" topic-name=\"si.test.topic\"/>\n----\n\nA `publish-subscribe-channel` behaves much like a normal `<publish-subscribe-channel/>` element from the main Spring Integration namespace.\nIt can be referenced by both the `input-channel` and the `output-channel` attributes of any endpoint.\nThe difference is that this channel is backed by a Redis topic name: a `String` value specified by the `topic-name` attribute.\nHowever, unlike JMS, this topic does not have to be created in advance or even auto-created by Redis.\nIn Redis, topics are simple `String` values that play the role of an address.\nThe producer and consumer can communicate by using the same `String` value as their topic name.\nA simple subscription to this channel means that asynchronous publish-subscribe messaging is possible between the producing and consuming endpoints.\nHowever, unlike the asynchronous message channels created by adding a `<queue/>` element within a simple Spring Integration `<channel/>` element, the messages are not stored in an in-memory queue.\nInstead, those messages are passed through Redis, which lets rely on its support for persistence and clustering as well as its interoperability with other non-Java platforms.\n\n[[redis-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Publish/Subscribe channel", "heading_level": 3, "file_order": 253, "section_index": 5, "content_hash": "1845f816e5a4d6f6e8798d4c0f561968946ee0bd8d2c722c538dbe845153e37e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:101cdbb0c8ffdd7b9716a3da7a007ce2b319bd5b13ce7d727d0967c35bd97fbb", "content": "The Redis inbound channel adapter (`RedisInboundChannelAdapter`) adapts incoming Redis messages into Spring messages in the same way as other inbound adapters.\nIt receives platform-specific messages (Redis in this case) and converts them to Spring messages by using a `MessageConverter` strategy.\nThe following example shows how to configure a Redis inbound channel adapter:\n\n[source,xml]\n----\n<int-redis:inbound-channel-adapter id=\"redisAdapter\"\n topics=\"thing1, thing2\"\n channel=\"receiveChannel\"\n error-channel=\"testErrorChannel\"\n message-converter=\"testConverter\" />\n\n<bean id=\"redisConnectionFactory\"\n class=\"o.s.data.redis.connection.lettuce.LettuceConnectionFactory\">\n <property name=\"port\" value=\"7379\" />\n</bean>\n\n<bean id=\"testConverter\" class=\"things.something.SampleMessageConverter\" />\n----\n\nThe preceding example shows a simple but complete configuration of a Redis inbound channel adapter.\nNote that the preceding configuration relies on the familiar Spring paradigm of auto-discovering certain beans.\nIn this case, the `redisConnectionFactory` is implicitly injected into the adapter.\nAlternatively, a custom `RedisConnectionFactory` can be injected via `connection-factory` attribute.\n\nAlso, note that the preceding configuration injects the adapter with a custom `MessageConverter`.\nThe approach is similar to JMS, where `MessageConverter` instances are used to convert between Redis messages and the Spring Integration message payloads.\nThe default is a `SimpleMessageConverter`.\n\nInbound adapters can subscribe to multiple topic names, hence the comma-separated set of values in the `topics` attribute.\n\nSince version 3.0, the inbound adapter, in addition to the existing `topics` attribute, now has the `topic-patterns` attribute.\nThis attribute contains a comma-separated set of Redis topic patterns.\nFor more information regarding Redis publish-subscribe, see https://redis.io/topics/pubsub[Redis Pub/Sub].\n\nInbound adapters can use a `RedisSerializer` to deserialize the body of Redis messages.\nThe `serializer` attribute of the `<int-redis:inbound-channel-adapter>` can be set to an empty string, which results in a `null` value for the `RedisSerializer` property.\nIn this case, the raw `byte[]` bodies of Redis messages are provided as the message payloads.\n\nSince version 5.0, an `Executor` instance can be injected into the inbound adapter by using the `task-executor` attribute of the `<int-redis:inbound-channel-adapter>`.\nAlso, the received Spring Integration messages now have the `RedisHeaders.MESSAGE_SOURCE` header to indicate the source of the published message: topic or pattern.\nThis can be used downstream for routing logic.\n\n[[redis-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Inbound Channel Adapter", "heading_level": 3, "file_order": 253, "section_index": 6, "content_hash": "101cdbb0c8ffdd7b9716a3da7a007ce2b319bd5b13ce7d727d0967c35bd97fbb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:cf24b11bb544a7b68d7cb10fb58c2fead805c6056cc177e2b6a5c4605c4085d7", "content": "The Redis outbound channel adapter adapts outgoing Spring Integration messages into Redis messages in the same way as other outbound adapters.\nIt receives Spring Integration messages and converts them to platform-specific messages (Redis in this case) by using a `MessageConverter` strategy.\nThe following example shows how to configure a Redis outbound channel adapter:\n\n[source,xml]\n----\n<int-redis:outbound-channel-adapter id=\"outboundAdapter\"\n channel=\"sendChannel\"\n topic=\"thing1\"\n message-converter=\"testConverter\"/>\n\n<bean id=\"redisConnectionFactory\"\n class=\"o.s.data.redis.connection.lettuce.LettuceConnectionFactory\">\n <property name=\"port\" value=\"7379\"/>\n</bean>\n\n<bean id=\"testConverter\" class=\"things.something.SampleMessageConverter\" />\n----\n\nThe configuration parallels the Redis inbound channel adapter.\nThe adapter is implicitly injected with a `RedisConnectionFactory`, which is defined with `redisConnectionFactory` as its bean name.\nThis example also includes the optional (and custom) `MessageConverter` (the `testConverter` bean).\n\nSince Spring Integration 3.0, the `<int-redis:outbound-channel-adapter>` offers an alternative to the `topic` attribute: a `topic-expression` attribute is present to determine the Redis topic for the message at runtime.\nThese attributes are mutually exclusive.\n\n[[redis-queue-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Outbound Channel Adapter", "heading_level": 3, "file_order": 253, "section_index": 7, "content_hash": "cf24b11bb544a7b68d7cb10fb58c2fead805c6056cc177e2b6a5c4605c4085d7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:3caf9d949b98b9c2dea41832a53be94cf5d7aae52ff4b6c018f216a7d05f4e89", "content": "Spring Integration 3.0 introduced a queue inbound channel adapter to \"`pop`\" messages from a Redis list.\nBy default, it uses \"`right pop`\", but can be configured to use \"`left pop`\" instead.\nThe adapter is message-driven.\nIt uses an internal listener thread and does not use a poller.\n\nThe following listing shows all the available attributes for `queue-inbound-channel-adapter`:\n\n[source,xml]\n----\n<int-redis:queue-inbound-channel-adapter id=\"\" <1>\n channel=\"\" <2>\n auto-startup=\"\" <3>\n phase=\"\" <4>\n connection-factory=\"\" <5>\n queue=\"\" <6>\n error-channel=\"\" <7>\n serializer=\"\" <8>\n receive-timeout=\"\" <9>\n recovery-interval=\"\" <10>\n expect-message=\"\" <11>\n task-executor=\"\" <12>\n right-pop=\"\"/> <13>\n\n----\n\n<1> The component bean name.\nIf `channel` attribute not provided, a `DirectChannel` is created and registered in the application context with this `id` attribute as the bean name.\nIn this case, the endpoint itself is registered with the bean name `id` plus `.adapter`.\n(If the bean name were `thing1`, the endpoint is registered as `thing1.adapter`.)\n<2> The `MessageChannel` to which to send `Message` instances from this Endpoint.\n<3> A `SmartLifecycle` attribute to specify whether this endpoint should start automatically after the application context starts or not.\nIt defaults to `true`.\n<4> A `SmartLifecycle` attribute to specify the phase in which this endpoint is started.\nIt defaults to `0`.\n<5> A reference to a `RedisConnectionFactory` bean.\nIt defaults to `redisConnectionFactory`.\n<6> The name of the Redis list on which the queue-based 'pop' operation is performed to get Redis messages.\n<7> The `MessageChannel` to which to send `ErrorMessage` instances when exceptions are received from the listening task of the endpoint.\nBy default, the underlying `MessagePublishingErrorHandler` uses the default `errorChannel` from the application context.\n<8> The `RedisSerializer` bean reference.\nIt can be an empty string, which means 'no serializer'.\nIn this case, the raw `byte[]` from the inbound Redis message is sent to the `channel` as the `Message` payload.\nBy default, it is a `JdkSerializationRedisSerializer`.\n<9> The timeout in milliseconds for 'pop' operation to wait for a Redis message from the queue.\nThe default is 1 second.\n<10> The time in milliseconds for which the listener task should sleep after exceptions on the 'pop' operation, before restarting the listener task.\n<11> Specifies whether this endpoint expects data from the Redis queue to contain entire `Message` instances.\nIf this attribute is set to `true`, the `serializer` cannot be an empty string, because messages require some form of deserialization (JDK serialization by default).\nIts default is `false`.\n<12> A reference to a Spring `TaskExecutor` (or standard JDK 1.5+ `Executor`) bean.\nIt is used for the underlying listening task.\nIt defaults to a `SimpleAsyncTaskExecutor`.\n<13> Specifies whether this endpoint should use \"`right pop`\" (when `true`) or \"`left pop`\" (when `false`) to read messages from the Redis list.\nIf `true`, the Redis List acts as a `FIFO` queue when used with a default Redis queue outbound channel adapter.\nSet it to `false` to use with software that writes to the list with \"`right push`\" or to achieve a stack-like message order.\nIts default is `true`.\nSince version 4.3.\n\nIMPORTANT: The `task-executor` has to be configured with more than one thread for processing; otherwise there is a possible deadlock when the `RedisQueueMessageDrivenEndpoint` tries to restart the listener task after an error.\nThe `errorChannel` can be used to process those errors, to avoid restarts, but it is preferable to not expose the application to the possible deadlock situation.\nSee Spring Framework https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling-task-executor-types[Reference Manual] for possible `TaskExecutor` implementations.\n\n[[redis-queue-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Queue Inbound Channel Adapter", "heading_level": 3, "file_order": 253, "section_index": 8, "content_hash": "3caf9d949b98b9c2dea41832a53be94cf5d7aae52ff4b6c018f216a7d05f4e89", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:36c77b22e957cb8014905a8907cafcec3db3256d51deb1189111e3a522aec06d", "content": "Spring Integration 3.0 introduced a queue outbound channel adapter to \"`push`\" to a Redis list from Spring Integration messages.\nBy default, it uses \"`left push`\", but \"`right push`\" can be configured instead.\nThe following listing shows all the available attributes for a Redis `queue-outbound-channel-adapter`:\n\n[source,xml]\n----\n<int-redis:queue-outbound-channel-adapter id=\"\" <1>\n channel=\"\" <2>\n connection-factory=\"\" <3>\n queue=\"\" <4>\n queue-expression=\"\" <5>\n serializer=\"\" <6>\n extract-payload=\"\" <7>\n left-push=\"\"/> <8>\n\n----\n\n<1> The component bean name.\nIf the `channel` attribute is not provided, a `DirectChannel` is created and registered in the application context with this `id` attribute as the bean name.\nIn this case, the endpoint is registered with a bean name of `id` plus `.adapter`.\n(If the bean name were `thing1`, the endpoint is registered as `thing1.adapter`.)\n<2> The `MessageChannel` from which this endpoint receives `Message` instances.\n<3> A reference to a `RedisConnectionFactory` bean.\nIt defaults to `redisConnectionFactory`.\n<4> The name of the Redis list on which the queue-based 'push' operation is performed to send Redis messages.\nThis attribute is mutually exclusive with `queue-expression`.\n<5> A SpEL `Expression` to determine the name of the Redis list.\nIt uses the incoming `Message` at runtime as the `#root` variable.\nThis attribute is mutually exclusive with `queue`.\n<6> A `RedisSerializer` bean reference.\nIt defaults to a `JdkSerializationRedisSerializer`.\nHowever, for `String` payloads, a `StringRedisSerializer` is used, if a `serializer` reference is not provided.\n<7> Specifies whether this endpoint should send only the payload or the entire `Message` to the Redis queue.\nIt defaults to `true`.\n<8> Specifies whether this endpoint should use \"`left push`\" (when `true`) or \"`right push`\" (when `false`) to write messages to the Redis list.\nIf `true`, the Redis list acts as a `FIFO` queue when used with a default Redis queue inbound channel adapter.\nSet it to `false` to use with software that reads from the list with \"`left pop`\" or to achieve a stack-like message order.\nIt defaults to `true`.\nSince version 4.3.\n\n[[redis-application-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Queue Outbound Channel Adapter", "heading_level": 3, "file_order": 253, "section_index": 9, "content_hash": "36c77b22e957cb8014905a8907cafcec3db3256d51deb1189111e3a522aec06d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:8f684d55f64817ce3477d7c29b5d71fc2d5cdd264f6fd2d9204ea5ea463e5b4f", "content": "Since Spring Integration 3.0, the Redis module has provided an implementation of `IntegrationEvent`, which, in turn, is a `org.springframework.context.ApplicationEvent`.\nThe `RedisExceptionEvent` encapsulates exceptions from Redis operations (with the endpoint being the \"`source`\" of the event).\nFor example, the `<int-redis:queue-inbound-channel-adapter/>` emits those events after catching exceptions from the `BoundListOperations.rightPop` operation.\nThe exception may be any generic `org.springframework.data.redis.RedisSystemException` or a `org.springframework.data.redis.RedisConnectionFailureException`.\nHandling these events with an `<int-event:inbound-channel-adapter/>` can be useful to determine problems with background Redis tasks and to take administrative actions.\n\n[[redis-message-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Application Events", "heading_level": 3, "file_order": 253, "section_index": 10, "content_hash": "8f684d55f64817ce3477d7c29b5d71fc2d5cdd264f6fd2d9204ea5ea463e5b4f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:cc29c6e0222f7bf2f86016241a802b46a196086b5dc039c13bfcd80b76d3631d", "content": "As described in the _Enterprise Integration Patterns_ (EIP) book, a https://www.enterpriseintegrationpatterns.com/MessageStore.html[message store] lets persist messages.\nThis can be useful when dealing with components that have a capability to buffer messages (aggregator, resequencer, and others) when reliability is a concern.\nIn Spring Integration, the `MessageStore` strategy also provides the foundation for the https://www.enterpriseintegrationpatterns.com/StoreInLibrary.html[claim check] pattern, which is described in EIP as well.\n\nSpring Integration's Redis module provides the `RedisMessageStore`.\nThe following example shows how to use it with a aggregator:\n\n[source,xml]\n----\n<bean id=\"redisMessageStore\" class=\"o.s.i.redis.store.RedisMessageStore\">\n <constructor-arg ref=\"redisConnectionFactory\"/>\n</bean>\n\n<int:aggregator input-channel=\"inputChannel\" output-channel=\"outputChannel\"\n message-store=\"redisMessageStore\"/>\n----\n\nThe preceding example is a bean configuration, and it expects a `RedisConnectionFactory` as a constructor argument.\n\nBy default, the `RedisMessageStore` uses Java serialization to serialize the message.\nHowever, if a different serialization technique (such as JSON) is required, a custom serializer can be set into the `valueSerializer` property of the `RedisMessageStore`.\n\nThe Framework provides Jackson serializer and deserializer implementations for `Message` instances and `MessageHeaders` instances -- `MessageJsonDeserializer` and `MessageHeadersJsonSerializer`, respectively.\nThey have to be configured with the `SimpleModule` options for the `ObjectMapper`.\nIn addition, the `enableDefaultTyping` should be set on the `ObjectMapper` to add type information for each serialized complex object.\nThat `type` information is then used during deserialization.\nThe framework provides a utility method called `JacksonMessagingUtils.messagingAwareMapper()`, which is already supplied with all the previously mentioned properties and serializers.\nThis utility method comes with the `trustedPackages` argument to limit Java packages for deserialization to avoid security vulnerabilities.\nThe default trusted packages: `java.util`, `java.lang`, `org.springframework.messaging.support`, `org.springframework.integration.support`, `org.springframework.integration.message`, `org.springframework.integration.store`.\nTo manage JSON serialization in the `RedisMessageStore`, a configuration like following must be applied:\n\n[source,java]\n----\nRedisMessageStore store = new RedisMessageStore(redisConnectionFactory);\nObjectMapper mapper = JacksonMessagingUtils.messagingAwareMapper();\nRedisSerializer<Object> serializer = new GenericJackson3JsonRedisSerializer(mapper);\nstore.setValueSerializer(serializer);\n----\n\nStarting with version 4.3.12, `RedisMessageStore` supports the `prefix` option to allow distinguishing between instances of the store on the same Redis server.\n\n[[redis-cms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Message Store", "heading_level": 2, "file_order": 253, "section_index": 11, "content_hash": "cc29c6e0222f7bf2f86016241a802b46a196086b5dc039c13bfcd80b76d3631d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:f7ac693d3ba052b7ba349c8da17d236b44cdbe5eccc7116dee2349b87633e7f5", "content": "The `RedisMessageStore` xref:redis.adoc#redis-message-store[shown earlier] maintains each group as a value under a single key (the group ID).\nWhile a `QueueChannel` can be used for persistence, a specialized `RedisChannelMessageStore` is provided for that purpose (since version 4.0).\nThis store uses a `LIST` for each channel, `LPUSH` when sending messages, and `RPOP` when receiving messages.\nBy default, this store also uses JDK serialization, but it can be modified for the value serializer, as xref:redis.adoc#redis-message-store[described earlier].\n\nIt is recommended to use a store-backing channel, instead of using the general `RedisMessageStore`.\nThe following example defines a Redis message store and uses it in a channel with a queue:\n\n[source,xml]\n----\n<bean id=\"redisMessageStore\" class=\"o.s.i.redis.store.RedisChannelMessageStore\">\n\t<constructor-arg ref=\"redisConnectionFactory\"/>\n</bean>\n\n<int:channel id=\"somePersistentQueueChannel\">\n <int:queue message-store=\"redisMessageStore\"/>\n<int:channel>\n----\n\nThe keys used to store the data have the form: `<storeBeanName>:<channelId>` (in the preceding example, `redisMessageStore:somePersistentQueueChannel`).\n\nIn addition, a subclass `RedisChannelPriorityMessageStore` is also provided.\nWhen this is used with a `QueueChannel`, the messages are received in (FIFO) priority order.\nIt uses the standard `IntegrationMessageHeaderAccessor.PRIORITY` header and supports priority values (`0 - 9`).\nMessages with other priorities (and messages with no priority) are retrieved in FIFO order after any messages with priority.\n\nIMPORTANT: These stores implement only `BasicMessageGroupStore` and do not implement `MessageGroupStore`.\nThey can be used only for situations such as backing a `QueueChannel`.\n\n[[redis-metadata-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Channel Message Stores", "heading_level": 3, "file_order": 253, "section_index": 12, "content_hash": "f7ac693d3ba052b7ba349c8da17d236b44cdbe5eccc7116dee2349b87633e7f5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:08d6c1622aacfe622ee19899f44383ab7fca568324b3320600c3350179fe56a2", "content": "Spring Integration 3.0 introduced a new Redis-based https://docs.spring.io/spring-integration/docs/latest-ga/api/org/springframework/integration/metadata/MetadataStore.html[`MetadataStore`] (see xref:meta-data-store.adoc[Metadata Store]) implementation.\nThe `RedisMetadataStore` can be used to maintain the state of a `MetadataStore` across application restarts.\nSuch a `MetadataStore` implementation can be used with adapters such as:\n\n* xref:feed.adoc#feed-inbound-channel-adapter[Feed]\n* xref:file/reading.adoc[File]\n* xref:ftp/inbound.adoc[FTP]\n* xref:sftp/inbound.adoc[SFTP]\n\nTo instruct these adapters to use the new `RedisMetadataStore`, declare a Spring bean named `metadataStore`.\nThe Feed inbound channel adapter and the feed inbound channel adapter both automatically pick up and use the declared `RedisMetadataStore`.\nThe following example shows how to declare such a bean:\n\n[source,xml]\n----\n<bean name=\"metadataStore\" class=\"o.s.i.redis.store.metadata.RedisMetadataStore\">\n <constructor-arg name=\"connectionFactory\" ref=\"redisConnectionFactory\"/>\n</bean>\n----\n\nThe `RedisMetadataStore` is backed by https://docs.spring.io/spring-data/data-redis/docs/current/api/org/springframework/data/redis/support/collections/RedisProperties.html[`RedisProperties`].\nInteraction with it uses https://docs.spring.io/spring-data/data-redis/docs/current/api/org/springframework/data/redis/core/BoundHashOperations.html[`BoundHashOperations`], which, in turn, requires a `key` for the entire `Properties` store.\nIn the case of the `MetadataStore`, this `key` plays the role of a region, which is useful in a distributed environment, when several applications use the same Redis server.\nBy default, this `key` has a value of `MetaData`.\n\nStarting with version 4.0, this store implements `ConcurrentMetadataStore`, letting it be reliably shared across multiple application instances where only one instance is allowed to store or modify a key's value.\n\nIMPORTANT: The `RedisMetadataStore.replace()` cannot be used (for example, in the `AbstractPersistentAcceptOnceFileListFilter`) with a Redis cluster, since the `WATCH` command for atomicity is not currently supported.\n\n[[redis-store-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Metadata Store", "heading_level": 2, "file_order": 253, "section_index": 13, "content_hash": "08d6c1622aacfe622ee19899f44383ab7fca568324b3320600c3350179fe56a2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:6cd6e498414a24d9be44cc7c6e4c3fa0f5cd11b7b4f9bb96720487e023282a15", "content": "The Redis store inbound channel adapter is a polling consumer that reads data from a Redis collection and sends it as a `Message` payload.\nThe following example shows how to configure a Redis store inbound channel adapter:\n\n[source,xml]\n----\n<int-redis:store-inbound-channel-adapter id=\"listAdapter\"\n connection-factory=\"redisConnectionFactory\"\n key=\"myCollection\"\n channel=\"redisChannel\"\n collection-type=\"LIST\" >\n <int:poller fixed-rate=\"2000\" max-messages-per-poll=\"10\"/>\n</int-redis:store-inbound-channel-adapter>\n----\n\nThe preceding example shows how to configure a Redis store inbound channel adapter by using the `store-inbound-channel-adapter` element, providing values for various attributes, such as:\n\n* `key` or `key-expression`: The name of the key for the collection being used.\n* `collection-type`: An enumeration of the collection types supported by this adapter.\nThe supported Collections are `LIST`, `SET`, `ZSET`, `PROPERTIES`, and `MAP`.\n* `connection-factory`: Reference to an instance of `o.s.data.redis.connection.RedisConnectionFactory`.\n* `redis-template`: Reference to an instance of `o.s.data.redis.core.RedisTemplate`.\n* Other attributes that are common across all inbound adapters (such as 'channel').\n\nNOTE: The `redis-template` and `connection-factory` are mutually exclusive.\n\n[IMPORTANT]\n=====\nBy default, the adapter uses a `StringRedisTemplate`.\nThis uses `StringRedisSerializer` instances for keys, values, hash keys, and hash values.\nIf Redis store contains objects that are serialized with other techniques, the `RedisTemplate` must be configured with appropriate serializers.\nFor example, if the store is written to using a Redis store outbound adapter that has its `extract-payload-elements` set to `false`, th `RedisTemplate` should be configured as follows:\n\n[source,xml]\n----\n<bean id=\"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\">\n <property name=\"connectionFactory\" ref=\"redisConnectionFactory\"/>\n <property name=\"keySerializer\">\n <bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/>\n </property>\n <property name=\"hashKeySerializer\">\n <bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"/>\n </property>\n</bean>\n----\n\nThe `RedisTemplate` uses `String` serializers for keys and hash keys and the default JDK Serialization serializers for values and hash values.\n=====\n\nBecause it has a literal value for the `key`, the preceding example is relatively simple and static.\nSometimes, the value of the key must be changed at runtime based on some condition.\nTo do so, use `key-expression` instead, where the provided expression can be any valid SpEL expression.\n\nAlso, some post-processing could be done on the successfully processed data that was read from the Redis collection.\nFor example, the value may be moved or removed after it has been processed.\nThe transaction synchronization feature could be used for such a logic.\nThe following example uses `key-expression` and transaction synchronization:\n\n[source,xml]\n----\n<int-redis:store-inbound-channel-adapter id=\"zsetAdapterWithSingleScoreAndSynchronization\"\n connection-factory=\"redisConnectionFactory\"\n key-expression=\"'presidents'\"\n channel=\"otherRedisChannel\"\n auto-startup=\"false\"\n collection-type=\"ZSET\">\n <int:poller fixed-rate=\"1000\" max-messages-per-poll=\"2\">\n <int:transactional synchronization-factory=\"syncFactory\"/>\n </int:poller>\n</int-redis:store-inbound-channel-adapter>\n\n<int:transaction-synchronization-factory id=\"syncFactory\">\n\t<int:after-commit expression=\"payload.removeByScore(18, 18)\"/>\n</int:transaction-synchronization-factory>\n\n<bean id=\"transactionManager\" class=\"o.s.i.transaction.PseudoTransactionManager\"/>\n----\n\nThe poller can be transactional by using a `transactional` element.\nThis element can reference a real transaction manager, for example, if some other part of the flow invokes JDBC.\nIf no \"`real`\" transaction, a `o.s.i.transaction.PseudoTransactionManager` can be used instead, which is an implementation of Spring's `PlatformTransactionManager` and enables the use of the transaction synchronization features of the Redis adapter when there is no actual transaction.\n\nIMPORTANT: This does not make the Redis activities themselves transactional.\nIt lets the synchronization of actions be taken before or after success (commit) or after failure (rollback).\n\nOnce the poller is transactional, an instance of the `o.s.i.transaction.TransactionSynchronizationFactory` can be added on the `transactional` element.\n`TransactionSynchronizationFactory` creates an instance of the `TransactionSynchronization`.\nFor convenience, a default SpEL-based `TransactionSynchronizationFactory` is exposed, which lets configure SpEL expressions, with their execution being coordinated (synchronized) with a transaction.\nExpressions for before-commit, after-commit, and after-rollback are supported, together with channels (one for each kind of event) where the evaluation results (if any) is sent.\nFor each child element, an `expression` and `channel` attributes can be specified.\nIf only the `channel` attribute is present, the received message is sent there as part of the particular synchronization scenario.\nIf only the `expression` attribute is present and the result of an expression is a non-null value, a message with the result as the payload is generated and sent to a default channel (`NullChannel`) and appears in the logs (at the `DEBUG` level).\nIf the result of an expression is null or void, no message is generated.\n\nThe `RedisStoreMessageSource` adds a `store` attribute with a `RedisStore` instance bound to the transaction `IntegrationResourceHolder`, which can be accessed from a `TransactionSynchronizationProcessor` implementation.\n\nFor more information about transaction synchronization, see xref:transactions.adoc#transaction-synchronization[Transaction Synchronization].\n\n[[redis-store-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Store Inbound Channel Adapter", "heading_level": 2, "file_order": 253, "section_index": 14, "content_hash": "6cd6e498414a24d9be44cc7c6e4c3fa0f5cd11b7b4f9bb96720487e023282a15", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:561b5430238fcb03e67aa6617f97ccf04cc589368ce9e2cd31328130b957f299", "content": "The RedisStore outbound channel adapter lets write a message payload to a Redis collection, as the following example shows:\n\n[source,xml]\n----\n<int-redis:store-outbound-channel-adapter id=\"redisListAdapter\"\n collection-type=\"LIST\"\n channel=\"requestChannel\"\n key=\"myCollection\" />\n----\n\nThe preceding configuration a Redis store outbound channel adapter by using the `store-inbound-channel-adapter` element.\nIt provides values for various attributes, such as:\n\n* `key` or `key-expression`: The name of the key for the collection being used.\n* `extract-payload-elements`: If set to `true` (the default) and the payload is an instance of a \"`multi-value`\" object (that is, a `Collection` or a `Map`), it is stored by using \"`addAll`\" and \"`putAll`\" semantics.\nOtherwise, if set to `false`, the payload is stored as a single entry regardless of its type.\nIf the payload is not an instance of a \"`multi-value`\" object, the value of this attribute is ignored and the payload is always stored as a single entry.\n* `collection-type`: An enumeration of the `Collection` types supported by this adapter.\nThe supported Collections are `LIST`, `SET`, `ZSET`, `PROPERTIES`, and `MAP`.\n* `map-key-expression`: SpEL expression that returns the name of the key for the entry being stored.\nIt applies only if the `collection-type` is `MAP` or `PROPERTIES` and 'extract-payload-elements' is false.\n* `connection-factory`: Reference to an instance of `o.s.data.redis.connection.RedisConnectionFactory`.\n* `redis-template`: Reference to an instance of `o.s.data.redis.core.RedisTemplate`.\n* Other attributes that are common across all inbound adapters (such as 'channel').\n\nNOTE: The `redis-template` and `connection-factory` are mutually exclusive.\n\nIMPORTANT: By default, the adapter uses a `StringRedisTemplate`.\nThis uses `StringRedisSerializer` instances for keys, values, hash keys, and hash values.\nHowever, if `extract-payload-elements` is set to `false`, a `RedisTemplate` that has `StringRedisSerializer` instances for keys and hash keys and `JdkSerializationRedisSerializer` instances s for values and hash values will be used.\nWith the JDK serializer, it is important to understand that Java serialization is used for all values, regardless of whether the value is actually a collection or not.\nIn case of more control over the serialization of values, a custom `RedisTemplate` could be provided rather than relying upon these defaults.\n\nBecause it has literal values for the `key` and other attributes, the preceding example is relatively simple and static.\nSometimes, the values may be changed dynamically at runtime based on some condition.\nTo do so, their `-expression` equivalents (`key-expression`, `map-key-expression`, and so on) are provided, where an expression can be any valid SpEL expression.\n\n[[redis-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "RedisStore Outbound Channel Adapter", "heading_level": 2, "file_order": 253, "section_index": 15, "content_hash": "561b5430238fcb03e67aa6617f97ccf04cc589368ce9e2cd31328130b957f299", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:1d3085e3aeb90268a97779dce48cf589d8f574560a929c0978d6f1db29057513", "content": "Spring Integration 4.0 introduced the Redis command gateway to let perform any standard Redis command by using the generic `RedisConnection#execute` method.\nThe following listing shows the available attributes for the Redis outbound gateway:\n\n[source,xml]\n----\n<int-redis:outbound-gateway\n request-channel=\"\" <1>\n reply-channel=\"\" <2>\n requires-reply=\"\" <3>\n reply-timeout=\"\" <4>\n connection-factory=\"\" <5>\n redis-template=\"\" <6>\n arguments-serializer=\"\" <7>\n command-expression=\"\" <8>\n argument-expressions=\"\" <9>\n use-command-variable=\"\" <10>\n arguments-strategy=\"\" /> <11>\n----\n\n<1> The `MessageChannel` from which this endpoint receives `Message` instances.\n<2> The `MessageChannel` where this endpoint sends reply `Message` instances.\n<3> Specifies whether this outbound gateway must return a non-null value.\nIt defaults to `true`.\nA `ReplyRequiredException` is thrown when Redis returns a `null` value.\n<4> The timeout (in milliseconds) to wait until the reply message is sent.\nIt is typically applied for queue-based limited reply-channels.\n<5> A reference to a `RedisConnectionFactory` bean.\nIt defaults to `redisConnectionFactory`.\nIt is mutually exclusive with `redis-template` attribute.\n<6> A reference to a `RedisTemplate` bean.\nIt is mutually exclusive with `connection-factory` attribute.\n<7> A reference to an instance of `org.springframework.data.redis.serializer.RedisSerializer`.\nIt is used to serialize each command argument to `byte[]`, if necessary.\n<8> The SpEL expression that returns the command key.\nIt defaults to the `redis_command` message header.\nIt must not evaluate to `null`.\n<9> Comma-separated SpEL expressions that are evaluated as command arguments.\nMutually exclusive with the `arguments-strategy` attribute.\nIf neither attribute is provided, the `payload` is used as the command arguments.\nThe argument expressions can evaluate to 'null' to support a variable number of arguments.\n<10> A `boolean` flag to specify whether the evaluated Redis command string is made available as the `#cmd` variable in the expression evaluation context in the `o.s.i.redis.outbound.ExpressionArgumentsStrategy` when `argument-expressions` is configured.\nOtherwise, this attribute is ignored.\n<11> Reference to an instance of `o.s.i.redis.outbound.ArgumentsStrategy`.\nIt is mutually exclusive with `argument-expressions` attribute.\nIf neither attribute is provided, the `payload` is used as the command arguments.\n\nThe `<int-redis:outbound-gateway>` can be used as a common component to perform any desired Redis operation.\nThe following example shows how to get incremented values from Redis atomic number:\n\n[source,xml]\n----\n<int-redis:outbound-gateway request-channel=\"requestChannel\"\n reply-channel=\"replyChannel\"\n command-expression=\"'INCR'\"/>\n----\n\nThe `Message` payload should have a name of `redisCounter`, which may be provided by `org.springframework.data.redis.support.atomic.RedisAtomicInteger` bean definition.\n\nThe `RedisConnection#execute` method has a generic `Object` as its return type.\nThe real result depends on the command type.\nFor example, `MGET` returns a `List<byte[]>`.\nFor more information about commands, their arguments, and result type, see https://redis.io/commands[Redis Specification].\n\n[[redis-queue-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Outbound Command Gateway", "heading_level": 2, "file_order": 253, "section_index": 16, "content_hash": "1d3085e3aeb90268a97779dce48cf589d8f574560a929c0978d6f1db29057513", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:19ed398c80bd346f2bbb8656cf87c6e05093f3d7ea8af123f08d0eb86d93c2db", "content": "Spring Integration introduced the Redis queue outbound gateway to perform request and reply scenarios.\nIt pushes a conversation `UUID` to the provided `queue`, pushes the value with that `UUID` as its key to a Redis list, and waits for the reply from a Redis list with a key of `UUID` plus `.reply`.\nA different UUID is used for each interaction.\nThe following listing shows the available attributes for a Redis outbound gateway:\n\n[source,xml]\n----\n<int-redis:queue-outbound-gateway\n request-channel=\"\" <1>\n reply-channel=\"\" <2>\n requires-reply=\"\" <3>\n reply-timeout=\"\" <4>\n connection-factory=\"\" <5>\n queue=\"\" <6>\n order=\"\" <7>\n serializer=\"\" <8>\n extract-payload=\"\"/> <9>\n----\n\n<1> The `MessageChannel` from which this endpoint receives `Message` instances.\n<2> The `MessageChannel` where this endpoint sends reply `Message` instances.\n<3> Specifies whether this outbound gateway must return a non-null value.\nThis value is `false` by default.\nOtherwise, a `ReplyRequiredException` is thrown when Redis returns a `null` value.\n<4> The timeout (in milliseconds) to wait until the reply message is sent.\nIt is typically applied for queue-based limited reply-channels.\n<5> A reference to a `RedisConnectionFactory` bean.\nIt defaults to `redisConnectionFactory`.\nIt is mutually exclusive with the 'redis-template' attribute.\n<6> The name of the Redis list to which the outbound gateway sends a conversation `UUID`.\n<7> The order of this outbound gateway when multiple gateways are registered.\n<8> The `RedisSerializer` bean reference.\nIt can be an empty string, which means \"`no serializer`\".\nIn this case, the raw `byte[]` from the inbound Redis message is sent to the `channel` as the `Message` payload.\nBy default, it is a `JdkSerializationRedisSerializer`.\n<9> Specifies whether this endpoint expects data from the Redis queue to contain entire `Message` instances.\nIf this attribute is set to `true`, the `serializer` cannot be an empty string, because messages require some form of deserialization (JDK serialization by default).\n\n[[redis-queue-inbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Queue Outbound Gateway", "heading_level": 2, "file_order": 253, "section_index": 17, "content_hash": "19ed398c80bd346f2bbb8656cf87c6e05093f3d7ea8af123f08d0eb86d93c2db", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:c0c7f6ba29ea70dde375d620f65c7485f22dbbe3b2cbb0eba0c1031d670c6630", "content": "Spring Integration 4.1 introduced the Redis queue inbound gateway to perform request and reply scenarios.\nIt pops a conversation `UUID` from the provided `queue`, pops the value with that `UUID` as its key from the Redis list, and pushes the reply to the Redis list with a key of `UUID` plus `.reply`.\nThe following listing shows the available attributes for a Redis queue inbound gateway:\n\n[source,xml]\n----\n<int-redis:queue-inbound-gateway\n request-channel=\"\" <1>\n reply-channel=\"\" <2>\n executor=\"\" <3>\n reply-timeout=\"\" <4>\n connection-factory=\"\" <5>\n queue=\"\" <6>\n order=\"\" <7>\n serializer=\"\" <8>\n receive-timeout=\"\" <9>\n expect-message=\"\" <10>\n recovery-interval=\"\"/> <11>\n----\n\n<1> The `MessageChannel` where this endpoint sends `Message` instances created from the Redis data.\n<2> The `MessageChannel` from where this endpoint waits for reply `Message` instances.\nOptional - the `replyChannel` header is still in use.\n<3> A reference to a Spring `TaskExecutor` (or a standard JDK `Executor`) bean.\nIt is used for the underlying listening task.\nIt defaults to a `SimpleAsyncTaskExecutor`.\n<4> The timeout (in milliseconds) to wait until the reply message is sent.\nIt is typically applied for queue-based limited reply-channels.\n<5> A reference to a `RedisConnectionFactory` bean.\nIt defaults to `redisConnectionFactory`.\nIt is mutually exclusive with `redis-template` attribute.\n<6> The name of the Redis list for the conversation `UUID`.\n<7> The order of this inbound gateway when multiple gateways are registered.\n<8> The `RedisSerializer` bean reference.\nIt can be an empty string, which means \"`no serializer`\".\nIn this case, the raw `byte[]` from the inbound Redis message is sent to the `channel` as the `Message` payload.\nIt defaults to a `JdkSerializationRedisSerializer`.\n(Note that, in releases before version 4.3, it was a `StringRedisSerializer` by default.\nTo restore that behavior, provide a reference to a `StringRedisSerializer`).\n<9> The timeout (in milliseconds) to wait until the received message is fetched.\nIt is typically applied for queue-based limited request-channels.\n<10> Specifies whether this endpoint expects data from the Redis queue to contain entire `Message` instances.\nIf this attribute is set to `true`, the `serializer` cannot be an empty string, because messages require some form of deserialization (JDK serialization by default).\n<11> The time (in milliseconds) the listener task should sleep after exceptions on the \"`right pop`\" operation before restarting the listener task.\n\nIMPORTANT: The `task-executor` has to be configured with more than one thread for processing; otherwise there is a possible deadlock when the `RedisQueueMessageDrivenEndpoint` tries to restart the listener task after an error.\nThe `errorChannel` can be used to process those errors, to avoid restarts, but it is preferable to not expose the application to the possible deadlock situation.\nSee Spring Framework https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling-task-executor-types[Reference Manual] for possible `TaskExecutor` implementations.\n\n[[redis-stream-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Queue Inbound Gateway", "heading_level": 2, "file_order": 253, "section_index": 18, "content_hash": "c0c7f6ba29ea70dde375d620f65c7485f22dbbe3b2cbb0eba0c1031d670c6630", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:d09e6993d94d68629e21c195f5c9642be5b7bf3d717eccc19c2d832281780040", "content": "Spring Integration 5.4 introduced Reactive Redis Stream outbound channel adapter to write Message payload into Redis stream.\nOutbound Channel adapter uses `ReactiveStreamOperations.add(...)` to add a `Record` to the stream.\nThe following example shows how to use Java configuration and Service class for Redis Stream Outbound Channel Adapter.\n\n[source,java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"messageChannel\")\npublic ReactiveRedisStreamMessageHandler reactiveValidatorMessageHandler(\n ReactiveRedisConnectionFactory reactiveRedisConnectionFactory) {\n ReactiveRedisStreamMessageHandler reactiveStreamMessageHandler =\n new ReactiveRedisStreamMessageHandler(reactiveRedisConnectionFactory, \"myStreamKey\"); <1>\n reactiveStreamMessageHandler.setSerializationContext(serializationContext); <2>\n reactiveStreamMessageHandler.setHashMapper(hashMapper); <3>\n reactiveStreamMessageHandler.setExtractPayload(true); <4>\n return reactiveStreamMessageHandler;\n}\n----\n<1> Construct an instance of `ReactiveRedisStreamMessageHandler` using `ReactiveRedisConnectionFactory` and stream name to add records.\nAnother constructor variant is based on a SpEL expression to evaluate a stream key against a request message.\n<2> Set a `RedisSerializationContext` used to serialize a record key and value before adding to the stream.\n<3> Set `HashMapper` which provides contract between Java types and Redis hashes/maps.\n<4> If 'true', the channel adapter will extract the payload from a request message for a stream record to add.\nOr use the whole message as a value.\nIt defaults to `true`.\n\nStarting with version 6.5, the `ReactiveRedisStreamMessageHandler` provides a `setAddOptionsFunction(Function<Message<?>, RedisStreamCommands.XAddOptions> addOptionsFunction)` to build `RedisStreamCommands.XAddOptions` based on the request message for the internal `ReactiveStreamOperations.add(Record<K, ?> record, XAddOptions xAddOptions)` call.\n\n[[redis-stream-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Stream Outbound Channel Adapter", "heading_level": 2, "file_order": 253, "section_index": 19, "content_hash": "d09e6993d94d68629e21c195f5c9642be5b7bf3d717eccc19c2d832281780040", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:33f99d787bcc4b05973683e13bb8a543065de46b08194f645427a1f25e0a3359", "content": "Spring Integration 5.4 introduced the Reactive Stream inbound channel adapter for reading messages from a Redis Stream.\nInbound channel adapter uses `StreamReceiver.receive(...)` or `StreamReceiver.receiveAutoAck()` based on an auto acknowledgement flag to read record from Redis stream.\nThe following example shows how to use Java configuration for Redis Stream Inbound Channel Adapter.\n\n[source,java]\n----\n@Bean\npublic ReactiveRedisStreamMessageProducer reactiveRedisStreamProducer(\n ReactiveRedisConnectionFactory reactiveRedisConnectionFactory) {\nReactiveRedisStreamMessageProducer messageProducer =\n new ReactiveRedisStreamMessageProducer(reactiveRedisConnectionFactory, \"myStreamKey\"); <1>\n messageProducer.setStreamReceiverOptions( <2>\n StreamReceiver.StreamReceiverOptions.builder()\n .pollTimeout(Duration.ofMillis(100))\n .build());\n messageProducer.setAutoStartup(true); <3>\n messageProducer.setAutoAck(false); <4>\n messageProducer.setCreateConsumerGroup(true); <5>\n messageProducer.setConsumerGroup(\"my-group\"); <6>\n messageProducer.setConsumerName(\"my-consumer\"); <7>\n messageProducer.setOutputChannel(fromRedisStreamChannel); <8>\n messageProducer.setReadOffset(ReadOffset.latest()); <9>\n messageProducer.extractPayload(true); <10>\n return messageProducer;\n}\n----\n<1> Construct an instance of `ReactiveRedisStreamMessageProducer` using `ReactiveRedisConnectionFactory` and a stream key to read records.\n<2> A `StreamReceiver.StreamReceiverOptions` to consume redis stream using reactive infrastructure.\n<3> A `SmartLifecycle` attribute to specify whether this endpoint should start automatically after the application context starts or not.\nIt defaults to `true`.\nIf `false`, `RedisStreamMessageProducer` should be started manually `messageProducer.start()`.\n<4> If `false`, received messages are not auto acknowledged.\nThe acknowledgement of the message will be deferred to the client-consuming message.\nIt defaults to `true`.\n<5> If `true`, a consumer group will be created.\nDuring creation of consumer group stream will be created (if not exists yet), too.\nConsumer group tracks message delivery and distinguishes between consumers.\nIt defaults to `false`.\n<6> Set the Consumer Group name.\nIt defaults to the defined bean name.\n<7> Set Consumer name.\nReads a message as `my-consumer` from group `my-group`.\n<8> The message channel to which to send messages from this endpoint.\n<9> Define the offset to read a message.\nIt defaults to `ReadOffset.latest()`.\n<10> If 'true', channel adapter will extract payload value from the `Record`.\nOtherwise, the whole `Record` is used as a payload.\nIt defaults to `true`.\n\nIf the `autoAck` is set to `false`, the `Record` in Redis Stream is not acknowledged automatically by the Redis driver, instead an `IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK` header is added into a message to produce with a `SimpleAcknowledgment` instance as a value.\nIt is a target integration flow responsibility to call its `acknowledge()` callback whenever the business logic is done for the message based on such a record.\nSimilar logic is required even when an exception happens during deserialization and `errorChannel` is configured.\nSo, the target error handler must decide to ack or nack such a failed message.\nAlongside with `IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK`, the `ReactiveRedisStreamMessageProducer` also populates these headers into the message to produce: `RedisHeaders.STREAM_KEY`, `RedisHeaders.STREAM_MESSAGE_ID`, `RedisHeaders.CONSUMER_GROUP` and `RedisHeaders.CONSUMER`.\n\nStarting with version 5.5, `StreamReceiver.StreamReceiverOptionsBuilder` options can be configured explicitly on the `ReactiveRedisStreamMessageProducer`, including the newly introduced `onErrorResume` function, which is required if the Redis Stream consumer should continue polling when deserialization errors occur.\nThe default function sends a message to the error channel (if provided) with possible acknowledgement for the failed message as it is described above.\nAll these `StreamReceiver.StreamReceiverOptionsBuilder` are mutually exclusive with an externally provided `StreamReceiver.StreamReceiverOptions`.\n\n[[redis-lock-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Stream Inbound Channel Adapter", "heading_level": 2, "file_order": 253, "section_index": 20, "content_hash": "33f99d787bcc4b05973683e13bb8a543065de46b08194f645427a1f25e0a3359", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:a1976cdbd1ba7bfc5d2c8532acbc2a47fc247186056f782d0b01e582298c85eb", "content": "Spring Integration 4.0 introduced the `RedisLockRegistry`.\nCertain components, (for example, aggregator and resequencer) use a lock obtained from a `LockRegistry` instance to ensure that only one thread manipulates a group at a time.\nThe `DefaultLockRegistry` performs this function within a single component.\nAn external lock registry can be configured on these components.\nWhen it is used with a shared `MessageGroupStore`, the `RedisLockRegistry` can be set to provide this functionality across multiple application instances, such that only one instance can manipulate the group at a time.\n\nWhen a lock is released by a local thread, another local thread can generally acquire the lock immediately.\nIf a lock is released by a thread using a different registry instance, it can take up to 100ms to acquire the lock.\n\nTo avoid \"`hung`\" locks (when a server fails), the locks in this registry are expired after default 60 seconds, but it can be configured on the registry.\nLocks are normally held for a much smaller time.\n\nIMPORTANT: Because the keys can expire, an attempt to unlock an expired lock results in an exception being thrown.\nHowever, the resources protected by such a lock may have been compromised, so such exceptions should be considered to be severe.\nThe expiry should be set at a large enough value to prevent this condition, but set it low enough that the lock can be recovered after a server failure in a reasonable amount of time.\n\nStarting with version 5.0, the `RedisLockRegistry` implements `ExpirableLockRegistry`, which removes locks last acquired more than `age` ago and that are not currently locked.\n\nStarting with version 5.5.6, the `RedisLockRegistry` is support automatically clean up cache for redisLocks in `RedisLockRegistry.locks` via `RedisLockRegistry.setCacheCapacity()`.\nSee its JavaDocs for more information.\n\nStarting with version 5.5.13, the `RedisLockRegistry` exposes a `setRedisLockType(RedisLockType)` option to determine in which mode a Redis lock acquisition should happen:\n\n- `RedisLockType.SPIN_LOCK` - the lock is acquired by periodic loop (100ms) checking whether the lock can be acquired.\nDefault.\n- `RedisLockType.PUB_SUB_LOCK` - The lock is acquired by redis pub-sub subscription.\n\nThe pub-sub is the preferred mode - less network chatter between client Redis server, and more performant - the lock is acquired immediately when subscription is notified about unlocking in the other process.\nHowever, the Redis does not support pub-sub in the Master/Replica connections, (for example, in AWS ElastiCache environment), therefore, a busy-spin mode is chosen as a default to make the registry working in any environment.\n\nStarting with version 6.4, instead of throwing `IllegalStateException`, the `RedisLockRegistry.RedisLock.unlock()` method throws `ConcurrentModificationException` if the ownership of the lock is expired.\n\nStarting with version 6.4, a `RedisLockRegistry.setRenewalTaskScheduler()` is added to configure the scheduler for periodic renewal of locks.\nWhen it is set, the lock will be automatically renewed every `1/3` of the expiration time after the lock is successfully acquired, until unlocked or the redis key is removed.\n\nStarting with version 7.0, the `RedisLock` implements `DistributedLock` interface to support the feature of customized time-to-live (TTL) for the lock status data.\nA `RedisLock` can now be acquired using the `lock(Duration ttl)` or `tryLock(long time, TimeUnit unit, Duration ttl)` method, with a specified time-to-live (TTL) value.\nThe `RedisLockRegistry` now provides new `renewLock(Object lockKey, Duration ttl)` method, allowing to renew the lock with a custom time-to-live value.\n\n[[elasticache-valkey-cluster]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "Redis Lock Registry", "heading_level": 2, "file_order": 253, "section_index": 21, "content_hash": "a1976cdbd1ba7bfc5d2c8532acbc2a47fc247186056f782d0b01e582298c85eb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:713c346b1351677745f6bed5f6f4effe5ec00c1e2030260c0bc1623ba6e4d128", "content": "Starting with version 6.4.9/6.5.4/7.0.0, `RedisLockRegistry` supports AWS Elasticache for Valkey in cluster mode.\nIn this version of valkey (a redis drop-in replacement), all PubSub operations (`PUBLISH`, `SUBSCRIBE`, etc.) use their sharded variants (`SPUBLISH`, `SSUBSCRIBE`, etc.) internally.\nIf there are any errors in the form of:\n\n[source]\n----\nCaused by: io.lettuce.core.RedisCommandExecutionException: ERR Script attempted to access keys that do not hash to the same slot script: b2dedc0ab01c17f9f20e3e6ddb62dcb6afbed0bd, on @user_script:3.\n----\n\n\"in the `unlock` step of the `RedisLockRegistry`, a lock key that includes a hashtag `{...}` must be supplied to ensure all operations in the `unlock` script are hashed to the same cluster slot/shard, e.g.:\n\n[source]\n----\nRedisLockRegistry lockRegistry = new RedisLockRegistry(\"my-lock-key{choose_your_tag}\");\n\nlockRegistry.lock();\n# critical section\nlockRegistry.unlock();\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/redis.adoc", "title": "redis", "heading": "AWS ElastiCache for Valkey Support in cluster mode", "heading_level": 3, "file_order": 253, "section_index": 22, "content_hash": "713c346b1351677745f6bed5f6f4effe5ec00c1e2030260c0bc1623ba6e4d128", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/redis.adoc"}}
{"id": "sha256:78f1abc36ea7ead0c395bd754ff8f1bbabc69bdc2aa95c35495e460053edc608", "content": "[[resequencer]]\n\nThe resequencer is related to the aggregator but serves a different purpose.\nWhile the aggregator combines messages, the resequencer passes messages through without changing them.\n\n[[resequencer-functionality]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/resequencer.adoc", "title": "resequencer", "heading": "resequencer", "heading_level": 1, "file_order": 254, "section_index": 0, "content_hash": "78f1abc36ea7ead0c395bd754ff8f1bbabc69bdc2aa95c35495e460053edc608", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/resequencer.adoc"}}
{"id": "sha256:dd7c02908c896af2ecee2393bffb505e8eb4e0965d3f1366a9ae377b7556ae38", "content": "The resequencer works in a similar way to the aggregator, in the sense that it uses the `CORRELATION_ID` to store messages in groups.\nThe difference is that the Resequencer does not process the messages in any way.\nInstead, it releases them in the order of their `SEQUENCE_NUMBER` header values.\n\nWith respect to that, you can opt to release all messages at once (after the whole sequence, according to the `SEQUENCE_SIZE`, and other possibilities) or as soon as a valid sequence is available.\n(We cover what we mean by \"a valid sequence\" later in this chapter.)\n\nIMPORTANT: The resequencer is intended to resequence relatively short sequences of messages with small gaps.\nIf you have a large number of disjoint sequences with many gaps, you may experience performance issues.\n\n[[configuring-a-resequencer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/resequencer.adoc", "title": "resequencer", "heading": "Functionality", "heading_level": 2, "file_order": 254, "section_index": 1, "content_hash": "dd7c02908c896af2ecee2393bffb505e8eb4e0965d3f1366a9ae377b7556ae38", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/resequencer.adoc"}}
{"id": "sha256:5096d3151326370111ef01b505bb17043af263315272774d2808416e86db2bb4", "content": "See xref:dsl/java-aggregators.adoc[Aggregators and Resequencers] for configuring a resequencer in Java DSL.\n\nConfiguring a resequencer requires only including the appropriate element in XML.\n\nThe following example shows a resequencer configuration:\n\n[source,xml]\n----\n<int:channel id=\"inputChannel\"/>\n\n<int:channel id=\"outputChannel\"/>\n\n<int:resequencer id=\"completelyDefinedResequencer\" <1>\n input-channel=\"inputChannel\" <2>\n output-channel=\"outputChannel\" <3>\n discard-channel=\"discardChannel\" <4>\n release-partial-sequences=\"true\" <5>\n message-store=\"messageStore\" <6>\n send-partial-result-on-expiry=\"true\" <7>\n send-timeout=\"86420000\" <8>\n correlation-strategy=\"correlationStrategyBean\" <9>\n correlation-strategy-method=\"correlate\" <10>\n correlation-strategy-expression=\"headers['something']\" <11>\n release-strategy=\"releaseStrategyBean\" <12>\n release-strategy-method=\"release\" <13>\n release-strategy-expression=\"size() == 10\" <14>\n empty-group-min-timeout=\"60000\" <15>\n\n lock-registry=\"lockRegistry\" <16>\n\n group-timeout=\"60000\" <17>\n group-timeout-expression=\"size() ge 2 ? 100 : -1\" <18>\n scheduler=\"taskScheduler\" /> <19>\n expire-group-upon-timeout=\"false\" /> <20>\n----\n\n<1> The id of the resequencer is optional.\n<2> The input channel of the resequencer.\nRequired.\n<3> The channel to which the resequencer sends the reordered messages.\nOptional.\n<4> The channel to which the resequencer sends the messages that timed out (if `send-partial-result-on-timeout` is set to `false`).\nOptional.\n<5> Whether to send out ordered sequences as soon as they are available or only after the whole message group arrives.\nOptional.\n(The default is `false`.)\n<6> A reference to a `MessageGroupStore` that can be used to store groups of messages under their correlation key until they are complete.\nOptional.\n(The default is a volatile in-memory store.)\n<7> Whether, upon the expiration of the group, the ordered group should be sent out (even if some messages are missing).\nOptional.\n(The default is false.)\nSee xref:aggregator.adoc#reaper[Managing State in an Aggregator: `MessageGroupStore`].\n<8> The timeout interval to wait when sending a reply `Message` to the `output-channel` or `discard-channel`.\nIt is applied only if the output channel has some 'sending' limitations, such as a `QueueChannel` with a fixed 'capacity'.\nIn this case, a `MessageDeliveryException` is thrown.\nThe `send-timeout` is ignored for `AbstractSubscribableChannel` implementations.\nFor `group-timeout(-expression)`, the `MessageDeliveryException` from the scheduled expired task leads this task to be rescheduled.\nOptional.\n<9> A reference to a bean that implements the message correlation (grouping) algorithm.\nThe bean can be an implementation of the `CorrelationStrategy` interface or a POJO.\nIn the latter case, the `correlation-strategy-method` attribute must also be defined.\nOptional.\n(By default, the aggregator uses the `IntegrationMessageHeaderAccessor.CORRELATION_ID` header.)\n<10> A method that is defined on the bean referenced by `correlation-strategy` and that implements the correlation decision algorithm.\nOptional, with restrictions (requires `correlation-strategy` to be present).\n<11> A SpEL expression representing the correlation strategy.\nExample: `\"headers['something']\"`.\nOnly one of `correlation-strategy` or `correlation-strategy-expression` is allowed.\n<12> A reference to a bean that implements the release strategy.\nThe bean can be an implementation of the `ReleaseStrategy` interface or a POJO.\nIn the latter case, the `release-strategy-method` attribute must also be defined.\nOptional (by default, the aggregator will use the `IntegrationMessageHeaderAccessor.SEQUENCE_SIZE` header attribute).\n<13> A method that is defined on the bean referenced by `release-strategy` and that implements the completion decision algorithm.\nOptional, with restrictions (requires `release-strategy` to be present).\n<14> A SpEL expression representing the release strategy.\nThe root object for the expression is a `MessageGroup`.\nExample: `\"size() == 5\"`.\nOnly one of `release-strategy` or `release-strategy-expression` is allowed.\n<15> Only applies if a `MessageGroupStoreReaper` is configured for the `<resequencer>` `MessageStore`.\nBy default, when a `MessageGroupStoreReaper` is configured to expire partial groups, empty groups are also removed.\nEmpty groups exist after a group is released normally.\nThis is to enable the detection and discarding of late-arriving messages.\nIf you wish to expire empty groups on a longer schedule than expiring partial groups, set this property.\nEmpty groups are then not removed from the `MessageStore` until they have not been modified for at least this number of milliseconds.\nNote that the actual time to expire an empty group is also affected by the reaper's timeout property, and it could be as much as this value plus the timeout.\n<16> See xref:aggregator.adoc#aggregator-xml[Configuring an Aggregator with XML].\n<17> See xref:aggregator.adoc#aggregator-xml[Configuring an Aggregator with XML].\n<18> See xref:aggregator.adoc#aggregator-xml[Configuring an Aggregator with XML].\n<19> See xref:aggregator.adoc#aggregator-xml[Configuring an Aggregator with XML].\n<20> By default, when a group is completed due to a timeout (or by a `MessageGroupStoreReaper`), the empty group's metadata is retained.\nLate arriving messages are immediately discarded.\nSet this to `true` to remove the group completely.\nThen, late arriving messages start a new group and are not discarded until the group again times out.\nThe new group is never released normally because of the \"`hole`\" in the sequence range that caused the timeout.\nEmpty groups can be expired (completely removed) later by using a `MessageGroupStoreReaper` together with the `empty-group-min-timeout` attribute.\nStarting with version 5.0, empty groups are also scheduled for removal after the `empty-group-min-timeout` elapses.\nThe default is 'false'.\n\nAlso see xref:aggregator.adoc#aggregator-expiring-groups[Aggregator Expiring Groups] for more information.\n\nNOTE: Since there is no custom behavior to be implemented in Java classes for resequencers, there is no annotation support for it.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/resequencer.adoc", "title": "resequencer", "heading": "Configuring a Resequencer", "heading_level": 2, "file_order": 254, "section_index": 2, "content_hash": "5096d3151326370111ef01b505bb17043af263315272774d2808416e86db2bb4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/resequencer.adoc"}}
{"id": "sha256:c5f66c95c491da07752f7fc10cb881f66182d0bab479f893ed6f39f337a5b4c5", "content": "[[resource]]\n\nThe resource inbound channel adapter builds upon Spring's `Resource` abstraction to support greater flexibility across a variety of actual types of underlying resources, such as a file, a URL, or a class path resource.\nTherefore, it is similar to but more generic than the file inbound channel adapter.\n\n[[resource-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/resource.adoc", "title": "resource", "heading": "resource", "heading_level": 1, "file_order": 255, "section_index": 0, "content_hash": "c5f66c95c491da07752f7fc10cb881f66182d0bab479f893ed6f39f337a5b4c5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/resource.adoc"}}
{"id": "sha256:437ab55d102ae91d91cb876aa358103679e5e2362e424e88470dfddc98df5aa9", "content": "The resource inbound channel adapter is a polling adapter that creates a `Message` whose payload is a collection of `Resource` objects.\n\n`Resource` objects are resolved based on the pattern specified by the `pattern` attribute.\nThe collection of resolved `Resource` objects is then sent as a payload within a `Message` to the adapter's channel.\nThat is one major difference between resource inbound channel adapter and file inbound channel adapter: The latter buffers `File` objects and sends a single `File` object per `Message`.\n\nThe following example shows a simple configuration that finds all files that end with the 'properties' extension in the `things.thing1` package available on the classpath and sends them as the payload of a `Message` to the channel named '`resultChannel`':\n\n[source,xml]\n----\n<int:resource-inbound-channel-adapter id=\"resourceAdapter\"\n channel=\"resultChannel\"\n pattern=\"classpath:things/thing1/*.properties\">\n <int:poller fixed-rate=\"1000\"/>\n</int:resource-inbound-channel-adapter>\n----\n\nThe resource inbound channel adapter relies on the `org.springframework.core.io.support.ResourcePatternResolver` strategy interface to resolve the provided pattern.\nIt defaults to an instance of the current `ApplicationContext`.\nHowever, you can provide a reference to an instance of your own implementation of `ResourcePatternResolver` by setting the `pattern-resolver` attribute, as the following example shows:\n\n[source,xml]\n----\n<int:resource-inbound-channel-adapter id=\"resourceAdapter\"\n channel=\"resultChannel\"\n pattern=\"classpath:things/thing1/*.properties\"\n pattern-resolver=\"myPatternResolver\">\n <int:poller fixed-rate=\"1000\"/>\n</int:resource-inbound-channel-adapter>\n\n<bean id=\"myPatternResolver\" class=\"org.example.MyPatternResolver\"/>\n----\n\nYou may have a use case where you need to further filter the collection of resources resolved by the `ResourcePatternResolver`.\nFor example, you may want to prevent resources that were already resolved from appearing in a collection of resolved resources ever again.\nOn the other hand, your resources might be updated rather often, and you _do_ want them to be picked up again.\nIn other words, both defining an additional filter and disabling filtering altogether are valid use cases.\nYou can provide your own implementation of the `org.springframework.integration.util.CollectionFilter` strategy interface, as the following example shows:\n\n[source,java]\n----\npublic interface CollectionFilter<T> {\n\n Collection<T> filter(Collection<T> unfilteredElements);\n\n}\n----\n\nThe `CollectionFilter` receives a collection of unfiltered elements (which are `Resource` objects in the preceding example), and it returns a collection of filtered elements of that same type.\n\nIf you define the adapter with XML, but you do not specify a filter reference, the resource inbound channel adapter uses a default implementation of `CollectionFilter`.\nThe implementation class of that default filter is `org.springframework.integration.util.AcceptOnceCollectionFilter`.\nIt remembers the elements passed in the previous invocation in order to avoid returning those elements more than once.\n\nTo inject your own implementation of `CollectionFilter` instead, use the `filter` attribute, as the following example shows:\n\n[source,xml]\n----\n<int:resource-inbound-channel-adapter id=\"resourceAdapter\"\n channel=\"resultChannel\"\n pattern=\"classpath:things/thing1/*.properties\"\n filter=\"myFilter\">\n <int:poller fixed-rate=\"1000\"/>\n</int:resource-inbound-channel-adapter>\n\n<bean id=\"myFilter\" class=\"org.example.MyFilter\"/>\n----\n\nIf you do not need any filtering and want to disable even the default `CollectionFilter` strategy, provide an empty value for the filter attribute, for example, `filter=\"\"`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/resource.adoc", "title": "resource", "heading": "Resource Inbound Channel Adapter", "heading_level": 2, "file_order": 255, "section_index": 1, "content_hash": "437ab55d102ae91d91cb876aa358103679e5e2362e424e88470dfddc98df5aa9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/resource.adoc"}}
{"id": "sha256:90394c62f2b9d12689711e7d8784047ae53acb29fc6cd8d2497478dcca6397b3", "content": "[[resources]]\n\nThe definitive source of information about Spring Integration is the https://spring.io/projects/spring-integration[Spring Integration Home] at https://spring.io[https://spring.io].\nThat site serves as a hub of information and is the best place to find up-to-date announcements about the project as well as links to articles, blogs, and new sample applications.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/resources.adoc", "title": "resources", "heading": "resources", "heading_level": 1, "file_order": 256, "section_index": 0, "content_hash": "90394c62f2b9d12689711e7d8784047ae53acb29fc6cd8d2497478dcca6397b3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/resources.adoc"}}
{"id": "sha256:6738a454405ce09690709fc6644e5ed7d4dde5f22fee633b6e4d3a7bca45fdce", "content": "[[router]]\n\nThis section covers how routers work.\nIt includes the following topics:\n\n* xref:router/overview.adoc[Overview]\n* xref:router/common-parameters.adoc[Common Router Parameters]\n* xref:router/implementations.adoc[Router Implementations]\n* xref:router/namespace.adoc[Configuring a Generic Router]\n* xref:router/spel.adoc[Routers and the Spring Expression Language (SpEL)]\n* xref:router/dynamic-routers.adoc[Dynamic Routers]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/router.adoc", "title": "router", "heading": "router", "heading_level": 1, "file_order": 257, "section_index": 0, "content_hash": "6738a454405ce09690709fc6644e5ed7d4dde5f22fee633b6e4d3a7bca45fdce", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/router.adoc"}}
{"id": "sha256:9e245f6ec502bcbbef9e195aa80d1d9d56ad1c5ab803bedd5443bc4c018b94f2", "content": "[[rsocket]]\n\nThe RSocket Spring Integration module (`spring-integration-rsocket`) allows for executions of https://rsocket.io/[RSocket application protocol].\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-rsocket</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-rsocket:{project-version}\"\n----\n======\n\nThis module is available starting with version 5.2 and is based on the Spring Messaging foundation with its RSocket component implementations, such as `RSocketRequester`, `RSocketMessageHandler` and `RSocketStrategies`.\nSee https://docs.spring.io/spring-framework/reference/rsocket.html[Spring Framework RSocket Support] for more information about the RSocket protocol, terminology and components.\n\nBefore starting integration flow processing via channel adapters, we need to establish an RSocket connection between server and client.\nFor this purpose, Spring Integration RSocket support provides the `ServerRSocketConnector` and `ClientRSocketConnector` implementations of the `AbstractRSocketConnector`.\n\nThe `ServerRSocketConnector` exposes a listener on the host and port according to provided `io.rsocket.transport.ServerTransport` for accepting connections from clients.\nAn internal `RSocketServer` instance can be customized with the `setServerConfigurer()`, as well as other options that can be configured, e.g. `RSocketStrategies` and `MimeType` for payload data and headers metadata.\nWhen a `setupRoute` is provided from the client requester (see `ClientRSocketConnector` below), a connected client is stored as a `RSocketRequester` under the key determined by the `clientRSocketKeyStrategy` `BiFunction<Map<String, Object>, DataBuffer, Object>`.\nBy default, connection data is used for the key as a converted value to string with UTF-8 charset.\nSuch an `RSocketRequester` registry can be used in the application logic to determine a particular client connection for interaction with it, or for publishing the same message to all connected clients.\nWhen a connection is established from the client, an `RSocketConnectedEvent` is emitted from the `ServerRSocketConnector`.\nThis is similar to what is provided by the `@ConnectMapping` annotation in Spring Messaging module.\nThe mapping pattern `*` means accept all the client routes.\nThe `RSocketConnectedEvent` can be used to distinguish different routes via `DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER` header.\n\nA typical server configuration might look like this:\n\n[source, java]\n----\n@Bean\npublic RSocketStrategies rsocketStrategies() {\n return RSocketStrategies.builder()\n .decoder(StringDecoder.textPlainOnly())\n .encoder(CharSequenceEncoder.allMimeTypes())\n .dataBufferFactory(new DefaultDataBufferFactory(true))\n .build();\n}\n\n@Bean\npublic ServerRSocketConnector serverRSocketConnector() {\n ServerRSocketConnector serverRSocketConnector = new ServerRSocketConnector(\"localhost\", 0);\n serverRSocketConnector.setRSocketStrategies(rsocketStrategies());\n serverRSocketConnector.setMetadataMimeType(new MimeType(\"message\", \"x.rsocket.routing.v0\"));\n serverRSocketConnector.setServerConfigurer((server) -> server.payloadDecoder(PayloadDecoder.ZERO_COPY));\n serverRSocketConnector.setClientRSocketKeyStrategy((headers, data) -> \"\"\n + headers.get(DestinationPatternsMessageCondition.LOOKUP_DESTINATION_HEADER));\n return serverRSocketConnector;\n}\n\n@EventListener\npublic void onApplicationEvent(RSocketConnectedEvent event) {\n\t...\n}\n----\n\nAll the options, including `RSocketStrategies` bean and `@EventListener` for `RSocketConnectedEvent`, are optional.\nSee `ServerRSocketConnector` JavaDocs for more information.\n\nStarting with version 5.2.1, the `ServerRSocketMessageHandler` is extracted to a public, top-level class for possible connection with an existing RSocket server.\nWhen a `ServerRSocketConnector` is supplied with an external instance of `ServerRSocketMessageHandler`, it doesn't create an RSocket server internally and just delegates all the handling logic to the provided instance.\nIn addition, the `ServerRSocketMessageHandler` can be configured with a `messageMappingCompatible` flag to handle also `@MessageMapping` for an RSocket controller, fully replacing the functionality provided by the standard `RSocketMessageHandler`.\nThis can be useful in mixed configurations, when classic `@MessageMapping` methods are present in the same application along with RSocket channel adapters and an externally configured RSocket server is present in the application.\n\nThe `ClientRSocketConnector` serves as a holder for `RSocketRequester` based on the `RSocket` connected via the provided `ClientTransport`.\nThe `RSocketConnector` can be customized with the provided `RSocketConnectorConfigurer`.\nThe `setupRoute` (with optional templates variables) and `setupData` with metadata can be also configured on this component.\n\nA typical client configuration might look like this:\n\n[source, java]\n----\n@Bean\npublic RSocketStrategies rsocketStrategies() {\n return RSocketStrategies.builder()\n .decoder(StringDecoder.textPlainOnly())\n .encoder(CharSequenceEncoder.allMimeTypes())\n .dataBufferFactory(new DefaultDataBufferFactory(true))\n .build();\n}\n\n@Bean\npublic ClientRSocketConnector clientRSocketConnector() {\n ClientRSocketConnector clientRSocketConnector =\n new ClientRSocketConnector(\"localhost\", serverRSocketConnector().getBoundPort().block());\n clientRSocketConnector.setRSocketStrategies(rsocketStrategies());\n clientRSocketConnector.setSetupRoute(\"clientConnect/{user}\");\n clientRSocketConnector.setSetupRouteVariables(\"myUser\");\n return clientRSocketConnector;\n}\n----\n\nMost of these options (including `RSocketStrategies` bean) are optional.\nNote how we connect to the locally started RSocket server on the arbitrary port.\nSee `ServerRSocketConnector.clientRSocketKeyStrategy` for `setupData` use cases.\nAlso see `ClientRSocketConnector` and its `AbstractRSocketConnector` superclass Javadocs for more information.\n\nBoth `ClientRSocketConnector` and `ServerRSocketConnector` are responsible for mapping inbound channel adapters to their `path` configuration for routing incoming RSocket requests.\nSee the next section for more information.\n\n[[rsocket-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "rsocket", "heading_level": 1, "file_order": 258, "section_index": 0, "content_hash": "9e245f6ec502bcbbef9e195aa80d1d9d56ad1c5ab803bedd5443bc4c018b94f2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:985b68d1d846586dbdac00f2c6c7901408908783935efae0ae5fb01de496ec3f", "content": "The `RSocketInboundGateway` is responsible for receiving RSocket requests and producing responses (if any).\nIt requires an array of `path` mapping which could be as patterns similar to MVC request mapping or `@MessageMapping` semantics.\nIn addition, (since version 5.2.2), a set of interaction models (see `RSocketInteractionModel`) can be configured on the `RSocketInboundGateway` to restrict RSocket requests to this endpoint by the particular frame type.\nBy default, all the interaction models are supported.\nSuch a bean, according its `IntegrationRSocketEndpoint` implementation (extension of a `ReactiveMessageHandler`), is auto detected either by the `ServerRSocketConnector` or `ClientRSocketConnector` for a routing logic in the internal `IntegrationRSocketMessageHandler` for incoming requests.\nAn `AbstractRSocketConnector` can be provided to the `RSocketInboundGateway` for explicit endpoint registration.\nThis way, the auto-detection option is disabled on that `AbstractRSocketConnector`.\nThe `RSocketStrategies` can also be injected into the `RSocketInboundGateway` or they are obtained from the provided `AbstractRSocketConnector` overriding any explicit injection.\nDecoders are used from those `RSocketStrategies` to decode a request payload according to the provided `requestElementType`.\nIf an `RSocketPayloadReturnValueHandler.RESPONSE_HEADER` header is not provided in incoming the `Message`, the `RSocketInboundGateway` treats a request as a `fireAndForget` RSocket interaction model.\nIn this case, an `RSocketInboundGateway` performs a plain `send` operation into the `outputChannel`.\nOtherwise, a `MonoProcessor` value from the `RSocketPayloadReturnValueHandler.RESPONSE_HEADER` header is used for sending a reply to the RSocket.\nFor this purpose, an `RSocketInboundGateway` performs a `sendAndReceiveMessageReactive` operation on the `outputChannel`.\nThe `payload` of the message to send downstream is always a `Flux` according to `MessagingRSocket` logic.\nWhen in a `fireAndForget` RSocket interaction model, the message has a plain converted `payload`.\nThe reply `payload` could be a plain object or a `Publisher` - the `RSocketInboundGateway` converts both of them properly into an RSocket response according to the encoders provided in the `RSocketStrategies`.\n\nStarting with version 5.3, a `decodeFluxAsUnit` option (default `false`) is added to the `RSocketInboundGateway`.\nBy default, incoming `Flux` is transformed the way that each its event is decoded separately.\nThis is an exact behavior present currently with `@MessageMapping` semantics.\nTo restore a previous behavior or decode the whole `Flux` as single unit according application requirements, the `decodeFluxAsUnit` has to be set to `true`.\nHowever, the target decoding logic depends on the `Decoder` selected, e.g. a `StringDecoder` requires a new line separator (by default) to be present in the stream to indicate a byte buffer end.\n\nSee xref:rsocket.adoc#rsocket-java-config[Configuring RSocket Endpoints with Java] for samples how to configure an `RSocketInboundGateway` endpoint and deal with payloads downstream.\n\n[[rsocket-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "RSocket Inbound Gateway", "heading_level": 2, "file_order": 258, "section_index": 1, "content_hash": "985b68d1d846586dbdac00f2c6c7901408908783935efae0ae5fb01de496ec3f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:309b69fd8cb9410deb25d16f6cd11b505cd1d7d3a521c05a85eb61b83159c175", "content": "The `RSocketOutboundGateway` is an `AbstractReplyProducingMessageHandler` to perform requests into RSocket and produce replies based on the RSocket replies (if any).\nA low level RSocket protocol interaction is delegated into an `RSocketRequester` resolved from the provided `ClientRSocketConnector` or from the `RSocketRequesterMethodArgumentResolver.RSOCKET_REQUESTER_HEADER` header in the request message on the server side.\nA target `RSocketRequester` on the server side can be resolved from an `RSocketConnectedEvent` or using `ServerRSocketConnector.getClientRSocketRequester()` API according some business key selected for connect request mappings via `ServerRSocketConnector.setClientRSocketKeyStrategy()`.\nSee `ServerRSocketConnector` JavaDocs for more information.\n\nThe `route` to send request has to be configured explicitly (together with path variables) or via a SpEL expression which is evaluated against request message.\n\nThe RSocket interaction model can be provided via `RSocketInteractionModel` option or respective expression setting.\nBy default, a `requestResponse` is used for common gateway use-cases.\n\nWhen request message payload is a `Publisher`, a `publisherElementType` option can be provided to encode its elements according an `RSocketStrategies` supplied in the target `RSocketRequester`.\nAn expression for this option can evaluate to a `ParameterizedTypeReference`.\nSee the `RSocketRequester.RequestSpec.data()` JavaDocs for more information about data and its type.\n\nAn RSocket request can also be enhanced with a `metadata`.\nFor this purpose a `metadataExpression` against request message can be configured on the `RSocketOutboundGateway`.\nSuch an expression must evaluate to a `Map<Object, MimeType>`.\n\nWhen `interactionModel` is not `fireAndForget`, an `expectedResponseType` must be supplied.\nIt is a `String.class` by default.\nAn expression for this option can evaluate to a `ParameterizedTypeReference`.\nSee the `RSocketRequester.RetrieveSpec.retrieveMono()` and `RSocketRequester.RetrieveSpec.retrieveFlux()` JavaDocs for more information about reply data and its type.\n\nA reply `payload` from the `RSocketOutboundGateway` is a `Mono` (even for a `fireAndForget` interaction model it is `Mono<Void>`) always making this component as `async`.\nSuch a `Mono` is subscribed before producing into the `outputChannel` for regular channels or processed on demand by the `FluxMessageChannel`.\nA `Flux` response for the `requestStream` or `requestChannel` interaction model is also wrapped into a reply `Mono`.\nIt can be flattened downstream by the `FluxMessageChannel` with a passthrough service activator:\n\n[source, java]\n----\n@ServiceActivator(inputChannel = \"rsocketReplyChannel\", outputChannel =\"fluxMessageChannel\")\npublic Flux<?> flattenRSocketResponse(Flux<?> payload) {\n return payload;\n}\n----\n\nOr subscribed explicitly in the target application logic.\n\nThe expected response type can also be configured (or evaluated via expression) to `void` treating this gateway as an outbound channel adapter.\nHowever, the `outputChannel` still has to be configured (even if it just a `NullChannel`) to initiate a subscription to the returned `Mono`.\n\nSee xref:rsocket.adoc#rsocket-java-config[Configuring RSocket Endpoints with Java] for samples how to configure an `RSocketOutboundGateway` endpoint a deal with payloads downstream.\n\n[[rsocket-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "RSocket Outbound Gateway", "heading_level": 2, "file_order": 258, "section_index": 2, "content_hash": "309b69fd8cb9410deb25d16f6cd11b505cd1d7d3a521c05a85eb61b83159c175", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:7e2d7611eac834970d1777fb12394b5a547f85ed4e62aba5afefc0dea0126c04", "content": "Spring Integration provides an `rsocket` namespace and the corresponding schema definition.\nTo include it in your configuration, add the following namespace declaration in your application context configuration file:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int=\"http://www.springframework.org/schema/integration\"\n xmlns:int-rsocket=\"http://www.springframework.org/schema/integration/rsocket\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration.xsd\n http://www.springframework.org/schema/integration/rsocket\n https://www.springframework.org/schema/integration/rsocket/spring-integration-rsocket.xsd\">\n ...\n</beans>\n----\n\n[[inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "RSocket Namespace Support", "heading_level": 2, "file_order": 258, "section_index": 3, "content_hash": "7e2d7611eac834970d1777fb12394b5a547f85ed4e62aba5afefc0dea0126c04", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:9c7ebaebc8c3c16eb23a12133722fb3e5fbb2a3a9c1d10e414a414f9fd14eafb", "content": "To configure Spring Integration RSocket inbound channel adapters with XML, you need to use an appropriate `inbound-gateway` components from the `int-rsocket` namespace.\nThe following example shows how to configure it:\n\n[source, xml]\n----\n<int-rsocket:inbound-gateway id=\"inboundGateway\"\n path=\"testPath\"\n interaction-models=\"requestStream,requestChannel\"\n rsocket-connector=\"clientRSocketConnector\"\n request-channel=\"requestChannel\"\n rsocket-strategies=\"rsocketStrategies\"\n request-element-type=\"byte[]\"/>\n----\n\nA `ClientRSocketConnector` and `ServerRSocketConnector` should be configured as generic `<bean>` definitions.\n\n[[outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Inbound", "heading_level": 3, "file_order": 258, "section_index": 4, "content_hash": "9c7ebaebc8c3c16eb23a12133722fb3e5fbb2a3a9c1d10e414a414f9fd14eafb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:4ac6691c4ab83635da90702bde5aacf22b1d7e3e7382b568db3054496f001b43", "content": "[source, xml]\n----\n<int-rsocket:outbound-gateway id=\"outboundGateway\"\n client-rsocket-connector=\"clientRSocketConnector\"\n auto-startup=\"false\"\n interaction-model=\"fireAndForget\"\n route-expression=\"'testRoute'\"\n request-channel=\"requestChannel\"\n publisher-element-type=\"byte[]\"\n expected-response-type=\"java.util.Date\"\n metadata-expression=\"{'metadata': new org.springframework.util.MimeType('*')}\"/>\n----\n\nSee `spring-integration-rsocket.xsd` for description for all those XML attributes.\n\n[[rsocket-java-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Outbound", "heading_level": 3, "file_order": 258, "section_index": 5, "content_hash": "4ac6691c4ab83635da90702bde5aacf22b1d7e3e7382b568db3054496f001b43", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:1d277c610a68beb732559002fa8c68bbdb78de2243be73b05c93173c8c733c05", "content": "The following example shows how to configure an RSocket inbound endpoint with Java:\n\n[source, java]\n----\n@Bean\npublic RSocketInboundGateway rsocketInboundGatewayRequestReply() {\n RSocketInboundGateway rsocketInboundGateway = new RSocketInboundGateway(\"echo\");\n rsocketInboundGateway.setRequestChannelName(\"requestReplyChannel\");\n return rsocketInboundGateway;\n}\n\n@Transformer(inputChannel = \"requestReplyChannel\")\npublic Mono<String> echoTransformation(Flux<String> payload) {\n return payload.next().map(String::toUpperCase);\n}\n----\n\nA `ClientRSocketConnector` or `ServerRSocketConnector` is assumed in this configuration with meaning for auto-detection of such an endpoint on the \"`echo`\" path.\nPay attention to the `@Transformer` signature with its fully reactive processing of the RSocket requests and producing reactive replies.\n\nThe following example shows how to configure a RSocket inbound gateway with the Java DSL:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow rsocketUpperCaseFlow() {\n return IntegrationFlow\n .from(RSockets.inboundGateway(\"/uppercase\")\n .interactionModels(RSocketInteractionModel.requestChannel))\n .<Flux<String>, Mono<String>>transform((flux) -> flux.next().map(String::toUpperCase))\n .get();\n}\n----\n\nA `ClientRSocketConnector` or `ServerRSocketConnector` is assumed in this configuration with meaning for auto-detection of such an endpoint on the \"`/uppercase`\" path and expected interaction model as \"`a request channel`\".\n\nThe following example shows how to configure a RSocket outbound gateway with Java:\n\n[source, java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"requestChannel\", outputChannel = \"replyChannel\")\npublic RSocketOutboundGateway rsocketOutboundGateway() {\n RSocketOutboundGateway rsocketOutboundGateway =\n new RSocketOutboundGateway(\n new FunctionExpression<Message<?>>((m) ->\n m.getHeaders().get(\"route_header\")));\n rsocketOutboundGateway.setInteractionModelExpression(\n new FunctionExpression<Message<?>>((m) -> m.getHeaders().get(\"rsocket_interaction_model\")));\n rsocketOutboundGateway.setClientRSocketConnector(clientRSocketConnector());\n return rsocketOutboundGateway;\n}\n----\n\nThe `setClientRSocketConnector()` is required only for the client side.\nOn the server side, the `RSocketRequesterMethodArgumentResolver.RSOCKET_REQUESTER_HEADER` header with an `RSocketRequester` value must be supplied in the request message.\n\nThe following example shows how to configure a RSocket outbound gateway with the Java DSL:\n\n[source, java]\n----\n@Bean\npublic IntegrationFlow rsocketUpperCaseRequestFlow(ClientRSocketConnector clientRSocketConnector) {\n return IntegrationFlow\n .from(Function.class)\n .handle(RSockets.outboundGateway(\"/uppercase\")\n .interactionModel(RSocketInteractionModel.requestResponse)\n .expectedResponseType(String.class)\n .clientRSocketConnector(clientRSocketConnector))\n .get();\n}\n----\n\nSee xref:dsl/integration-flow-as-gateway.adoc[`IntegrationFlow` as a Gateway] for more information how to use a mentioned `Function` interface at the beginning of the flow above.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/rsocket.adoc", "title": "rsocket", "heading": "Configuring RSocket Endpoints with Java", "heading_level": 2, "file_order": 258, "section_index": 6, "content_hash": "1d277c610a68beb732559002fa8c68bbdb78de2243be73b05c93173c8c733c05", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/rsocket.adoc"}}
{"id": "sha256:35826246012e125c402fd728e966408d074da26b580e7a51e82220a1054199c9", "content": "[[samples]]\n\nAs of Spring Integration 2.0, the Spring Integration distribution no longer includes the samples.\nInstead, we have switched to a much simpler collaborative model that should promote better community participation and, ideally, more contributions.\nSamples now have a dedicated GitHub repository.\nSample development also has its own lifecycle, which is not dependent on the lifecycle of the framework releases, although the repository is still tagged with each major release for compatibility reasons.\n\nThe great benefit to the community is that we can now add more samples and make them available to you right away without waiting for the next release.\nHaving its own GitHub repository that is not tied to the actual framework is also a great benefit.\nYou now have a dedicated place to suggest samples as well as report issues with existing samples.\nYou can also submit a sample to us as a Pull Request.\nIf we believe your sample adds value, we would be more than glad to add it to the 'samples' repository, properly crediting you as the author.\n\n[[samples-get]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "samples", "heading_level": 1, "file_order": 259, "section_index": 0, "content_hash": "35826246012e125c402fd728e966408d074da26b580e7a51e82220a1054199c9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:264a9f4e1779520118b0e5ed825a55c9ca1f7b35fad868ae45ce3aeb112ef22e", "content": "The Spring Integration Samples project is hosted on https://github.com/spring-projects/spring-integration-samples/[GitHub].\nIn order to check out or clone the samples, you must have a Git client installed on your system.\nThere are several GUI-based products available for many platforms, such as https://eclipse.org/egit/[EGit] for the Eclipse IDE.\nA simple Google search can help you find them.\nYou can also use the command line interface for https://git-scm.com/[Git].\n\nNOTE: If you need more information on how to install or use Git, visit: https://git-scm.com/[https://git-scm.com/].\n\nTo clone (check out) the Spring Integration samples repository by using the Git command line tool, issue the following command:\n\n[source,xml]\n----\n$ git clone https://github.com/spring-projects/spring-integration-samples.git\n----\n\nThe preceding command clones the entire samples repository into a directory named `spring-integration-samples` within the working directory where you issued that `git` command.\nSince the samples repository is a live repository, you might want to perform periodic pulls (updates) to get new samples and updates to the existing samples.\nTo do so, issue the following `git pull` command:\n\n[source,xml]\n----\n$ git pull\n----\n\n[[submitting-samples-or-sample-requests]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "Where to Get Samples", "heading_level": 2, "file_order": 259, "section_index": 1, "content_hash": "264a9f4e1779520118b0e5ed825a55c9ca1f7b35fad868ae45ce3aeb112ef22e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:9f3186ab9037e1ae06eeecab402fa0fa6bf63ffbbc66d2011aec959205d9ce8e", "content": "You can submit both new samples and requests for samples.\nWe greatly appreciate any effort toward improving the samples, including the sharing of good ideas.\n\n[[samples-how-can-i-contribute]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "Submitting Samples or Sample Requests", "heading_level": 2, "file_order": 259, "section_index": 2, "content_hash": "9f3186ab9037e1ae06eeecab402fa0fa6bf63ffbbc66d2011aec959205d9ce8e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:79d5d4064acbd00abdccf7272f6ab39b912a2ae6f36eb5a22e3faea3b89779b5", "content": "GitHub is for social coding: if you want to submit your own code examples to the Spring Integration Samples project, we encourage contributions through https://help.github.com/en/articles/creating-a-pull-request/[pull requests] from https://help.github.com/en/articles/fork-a-repo[forks] of this repository.\nIf you want to contribute code this way, please reference, if possible, a https://github.com/spring-projects/spring-integration-samples/issues[GitHub issue] that provides some details regarding your sample.\n\n[[code-contribution-process]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "How Can I Contribute My Own Samples?", "heading_level": 3, "file_order": 259, "section_index": 3, "content_hash": "79d5d4064acbd00abdccf7272f6ab39b912a2ae6f36eb5a22e3faea3b89779b5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:2b773a2d84a50ef5eca7461817ff3c24ad3f0aa7f3a1f7a17a6a84f34b26e546", "content": "For the actual code contribution process, read the Contributor Guidelines for Spring Integration.\nThey apply for the samples project as well.\nYou can find them at https://github.com/spring-projects/spring-integration/blob/main/CONTRIBUTING.adoc\n\nThis process ensures that every commit gets peer-reviewed.\nAs a matter of fact, the core committers follow the exact same rules.\nWe gratefully look forward to your Spring Integration samples!\n\n[[sample-requests]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "Code Contribution Process", "heading_level": 3, "file_order": 259, "section_index": 4, "content_hash": "2b773a2d84a50ef5eca7461817ff3c24ad3f0aa7f3a1f7a17a6a84f34b26e546", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:8090d32344f408e4a77c73a2b4f2081fe865027534b9483cb5a9795c3ddb6313", "content": "As xref:samples.adoc#samples-how-can-i-contribute[mentioned earlier], the Spring Integration Samples project uses GitHub issue as bug tracking system.\nTo submit new sample requests, visit https://github.com/spring-projects/spring-integration-samples/issues.\n\n[[samples-structure]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "Sample Requests", "heading_level": 3, "file_order": 259, "section_index": 5, "content_hash": "8090d32344f408e4a77c73a2b4f2081fe865027534b9483cb5a9795c3ddb6313", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:11ae150a78f5dfa20b1ccb3bcc3a98329df8cdecd0bba528b35ee71b0a281621", "content": "Starting with Spring Integration 2.0, the structure of the samples has changed.\nWith plans for more samples, we realized that not all samples have the same goals.\nThey all share the common goal of showing you how to apply and work with the Spring Integration framework.\nHowever, they differ in that some samples concentrate on a technical use case, while others focus on a business use case.\nAlso, some samples are about showcasing various techniques that could be applied to address certain scenarios (both technical and business).\nThe new categorization of samples lets us better organize them based on the problem each sample addresses while giving you a simpler way of finding the right sample for your needs.\n\nCurrently, there are four categories.\nWithin the samples repository, each category has its own directory, which is named after the category name:\n\nBasic (`samples/basic`)::\nThis is a good place to get started.\nThe samples here are technically motivated and demonstrate the bare minimum with regard to configuration and code.\nThese should help you to get started quickly by introducing you to the basic concepts, API, and configuration of Spring Integration as well as Enterprise Integration Patterns (EIP).\nFor example, if you are looking for an answer on how to implement and wire a service activator to a message channel, how to use a messaging gateway as a facade to your message exchange, or how to get started with MAIL, TCP/UDP, or other modules, this is the right place to find a good sample.\nThe bottom line is `samples/basic` is a good place to get started.\n\nIntermediate (`samples/intermediate`)::\nThis category targets developers who are already familiar with the Spring Integration framework (beyond getting started) but need some more guidance while resolving the more advanced technical problems they might encounter after switching to a messaging architecture.\nFor example, if you are looking for an answer on how to handle errors in various message exchange scenarios or how to properly configure the aggregator for a situation where some messages do not ever arrive for aggregation, or any other issue that goes beyond a basic implementation and configuration of a particular component and exposes \"`what else`\" types of problems, this is the right place to find these type of samples.\n\nAdvanced (`samples/advanced`)::\nThis category targets developers who are very familiar with the Spring Integration framework but are looking to extend it to address a specific custom need by using Spring Integration's public API.\nFor example, if you are looking for samples showing you how to implement a custom channel or consumer (event-based or polling-based), or you are trying to figure out the most appropriate way to implement a custom bean parser on top of the Spring Integration bean parser hierarchy (perhaps when implementing your own namespace and schema for a custom component), this is the right place to look.\nHere you can also find samples that will help you with adapter development.\nSpring Integration comes with an extensive library of adapters to let you connect remote systems with the Spring Integration messaging framework.\nHowever, you might need to integrate with a system for which the core framework does not provide an adapter.\nIf so, you might decide to implement your own (please consider contributing it).\nThis category would include samples showing you how.\n\nApplications (`samples/applications`)::\nThis category targets developers and architects who have a good understanding of message-driven architecture and EIP and an above-average understanding of Spring and Spring Integration who are looking for samples that address a particular business problem.\nIn other words, the emphasis of the samples in this category is business use cases and how they can be solved with a message-driven architecture and Spring Integration in particular.\nFor example, if you want to see how a loan broker or travel agent process could be implemented and automated with Spring Integration, this is the right place to find these types of samples.\n\nIMPORTANT: Spring Integration is a community-driven framework.\nTherefore, community participation is IMPORTANT.\nThat includes samples.\nIf you cannot find what you are looking for, let us know!\n\n[[samples-impl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "Samples Structure", "heading_level": 2, "file_order": 259, "section_index": 6, "content_hash": "11ae150a78f5dfa20b1ccb3bcc3a98329df8cdecd0bba528b35ee71b0a281621", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:86c2cc249b085c5868db1565233741b08b7c458e1a449fed1beecda525e2de84", "content": "Currently, Spring Integration comes with quite a few samples, and you can only expect more.\nTo help you better navigate through them, each sample comes with its own `readme.txt` file which covers several details about the sample (for example, what EIP patterns it addresses, what problem it is trying to solve, how to run the sample, and other details).\nHowever, certain samples require a more detailed and sometimes graphical explanation.\nIn this section, you can find details on samples that we believe require special attention.\n\n[[samples-loan-broker]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "Samples", "heading_level": 2, "file_order": 259, "section_index": 7, "content_hash": "86c2cc249b085c5868db1565233741b08b7c458e1a449fed1beecda525e2de84", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:571eda3c7cc4687478fd9d9b12c1e8c5ca481684beabcf38a8dc5edd33518022", "content": "This section covers the loan broker sample application that is included in the Spring Integration samples.\nThis sample is inspired by one of the samples featured in Gregor Hohpe and Bobby Woolf's book, https://www.enterpriseintegrationpatterns.com/[_Enterprise Integration Patterns_].\n\nThe following diagram shows the entire process:\n\n.Loan Broker Sample\nimage::loan-broker-eip.png[align=\"center\", scaledwidth=100%]\n\nAt the core of an EIP architecture are the very simple yet powerful concepts of pipes, filters, and, of course: messages.\nEndpoints (filters) are connected with one another via channels (pipes).\nProducing endpoints send messages to the channel, and the consuming endpoint retrieves the messages.\nThis architecture is meant to define various mechanisms that describe how information is exchanged between the endpoints, without any awareness of what those endpoints are or what information they are exchanging.\nThus, it provides for a very loosely coupled and flexible collaboration model while also decoupling integration concerns from business concerns.\nEIP extends this architecture by further defining:\n\n* The types of pipes (point-to-point channel, publish-subscribe channel, channel adapter, and others)\n\n* The core filters and patterns around how filters collaborate with pipes (Message router, splitters and aggregators, various message transformation patterns, and others)\n\n[[samples-loan-broker-requirements]]\nChapter 9 of the EIP book nicely describes the details and variations of this use case, but here is the brief summary: While shopping for the best loan quote, a consumer subscribes to the services of a loan broker, which handles such details as:\n\n* Consumer pre-screening, (for example, obtaining and reviewing the consumer's Credit history)\n\n* Determining the most appropriate banks (for example, based on the consumer's credit history or score)\n\n* Sending a loan quote request to each selected bank\n\n* Collecting responses from each bank\n\n* Filtering responses and determining the best quotes, based on consumer's requirements.\n\n* Pass the Loan quotes back to the consumer.\n\nThe real process of obtaining a loan quote is generally a bit more complex.\nHowever, since our goal is to demonstrate how Enterprise Integration Patterns are realized and implemented within Spring Integration, the use case has been simplified to concentrate only on the integration aspects of the process.\nIt is not an attempt to give you advice in consumer finances.\n\nBy engaging a loan broker, the consumer is isolated from the details of the loan broker's operations, and each loan broker's operations may defer from one another to maintain competitive advantage, so whatever we assemble and implement must be flexible so that any changes could be introduced quickly and painlessly.\n\nNOTE: The loan broker sample does not actually talk to any 'imaginary' Banks or Credit bureaus.\nThose services are stubbed out.\n\nOur goal here is to assemble, orchestrate, and test the integration aspects of the process as a whole.\nOnly then can we start thinking about wiring such processes to the real services.\nAt that time, the assembled process and its configuration do not change regardless of the number of banks with which a particular loan broker deals or the type of communication media (or protocols) used (JMS, WS, TCP, and so on) to communicate with these banks.\n\n[[design]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "Loan Broker", "heading_level": 3, "file_order": 259, "section_index": 8, "content_hash": "571eda3c7cc4687478fd9d9b12c1e8c5ca481684beabcf38a8dc5edd33518022", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:d7764ea89ea447daddd2dbd005d7df584219f3ae62118f71f1d9c391dab81f3e", "content": "As you analyze the xref:samples.adoc#samples-loan-broker-requirements[six requirements] listed earlier, you can see that they are all integration concerns.\nFor example, in the consumer pre-screening step, we need to gather additional information about the consumer and the consumer's desires and enrich the loan request with additional meta-information.\nWe then have to filter such information to select the most appropriate list of banks and so on.\nEnrich, filter, and select are all integration concerns for which EIP defines a solution in the form of patterns.\nSpring Integration provides an implementation of these patterns.\n\nThe following image shows a representation of a messaging gateway:\n\n.Messaging Gateway\nimage::gateway.jpg[align=\"center\"]\n\nThe messaging gateway pattern provides a simple mechanism to access messaging systems, including our loan broker.\nIn Spring Integration, you can define the gateway as a plain old java interface (you need not provide an implementation), configure it with the XML `<gateway>` element or with an annotation in Java, and use it as you would any other Spring bean.\nSpring Integration takes care of delegating and mapping method invocations to the messaging infrastructure by generating a message (the payload is mapped to an input parameter of the method) and sending it to the designated channel.\nThe following example shows how to define such a gateway with XML:\n\n[source,xml]\n----\n<int:gateway id=\"loanBrokerGateway\"\n default-request-channel=\"loanBrokerPreProcessingChannel\"\n service-interface=\"org.springframework.integration.samples.loanbroker.LoanBrokerGateway\">\n <int:method name=\"getBestLoanQuote\">\n <int:header name=\"RESPONSE_TYPE\" value=\"BEST\"/>\n </int:method>\n</int:gateway>\n----\n\nOur current gateway provides two methods that could be invoked.\nOne that returns the best single quote and another one that returns all quotes.\nSomehow, downstream, we need to know what type of reply the caller needs.\nThe best way to achieve this in messaging architecture is to enrich the content of the message with some metadata that describes your intentions.\nContent Enricher is one of the patterns that address this.\nSpring Integration does, as a convenience, provide a separate configuration element to enrich message headers with arbitrary data (described later)\nHowever, since the `gateway` element is responsible for constructing the initial message, it includes the ability to enrich the newly created message with arbitrary message headers.\nIn our example, we add a `RESPONSE_TYPE` header with a value of `BEST` whenever the `getBestQuote()` method is invoked.\nFor other methods, we do not add any header.\nNow we can check downstream for the existence of this header.\nBased on its presence and its value, we can determine what type of reply the caller wants.\n\nBased on the use case, we also know that some pre-screening steps need to be performed, such as getting and evaluating the consumer's credit score, because some premire banks only accept quote requests from consumers that meet a minimum credit score requirement.\nSo it would be nice if the message was enriched with such information before it is forwarded to the banks.\nIt would also be nice if, when several processes need to be completed to provide such meta-information, those processes could be grouped in a single unit.\nIn our use case, we need to determine the credit score and, based on the credit score and some rule, select a list of message channels (bank channels) to which to send quote request.\n\n[[composed-message-processor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "Design", "heading_level": 4, "file_order": 259, "section_index": 9, "content_hash": "d7764ea89ea447daddd2dbd005d7df584219f3ae62118f71f1d9c391dab81f3e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:cf18c312b921f52474be9f7db5a91d03b53ae3d7d738c1b1945fa709de863981", "content": "The composed message processor pattern describes rules around building endpoints that maintain control over message flow, which consists of multiple message processors.\nIn Spring Integration, the composed message processor pattern is implemented by the `<chain>` element.\n\nThe following image shows the chain pattern:\n\n.Chain\nimage::chain.png[align=\"center\"]\n\nThe preceding image shows that we have a chain with an inner header-enricher element that further enriches the content of the message with the `CREDIT_SCORE` header and the value (which is determined by the call to a credit service -- a simple POJO spring bean identified by 'creditBureau' name).\nThen it delegates to the message router.\n\nThe following image shows the message router pattern:\n\n.Message Router\nimage::bank-router.jpg[align=\"center\"]\n\nSpring Integration offers several implementations of the message routing pattern.\nIn this case, we use a router that determines a list of channels based on evaluating an expression (in Spring Expression Language) that looks at the credit score (determined in the previous step) and selects the list of channels from the `Map` bean with an `id` of `banks` whose values are `premier` or `secondary`, based on the value of credit score.\nOnce the list of channels is selected, the message is routed to those channels.\n\nNow, one last thing the loan broker needs to receive the loan quotes form the banks, aggregate them by consumer (we do not want to show quotes from one consumer to another), assemble the response based on the consumer's selection criteria (single best quote or all quotes) and send the reply to the consumer.\n\nThe following image shows the message aggregator pattern:\n\n.Message Aggregator\nimage::quotes-aggregator.jpg[align=\"center\"]\n\nAn aggregator pattern describes an endpoint that groups related messages into a single message.\nCriteria and rules can be provided to determine an aggregation and correlation strategy.\nSpring Integration provides several implementations of the aggregator pattern as well as a convenient namespace-based configuration.\n\nThe following example shows how to define an aggregator:\n\n[source,xml]\n----\n<int:aggregator id=\"quotesAggregator\"\n input-channel=\"quotesAggregationChannel\"\n method=\"aggregateQuotes\">\n <beans:bean class=\"org.springframework.integration.samples.loanbroker.LoanQuoteAggregator\"/>\n</int:aggregator>\n----\n\nOur Loan Broker defines a 'quotesAggregator' bean with the `<aggregator>` element, which provides a default aggregation and correlation strategy.\nThe default correlation strategy correlates messages based on the `correlationId` header (see https://www.enterpriseintegrationpatterns.com/patterns/messaging/CorrelationIdentifier.html[the correlation identifier pattern in the EIP book]).\nNote that we never provided the value for this header.\nIt was automatically set earlier by the router, when it generated a separate message for each bank channel.\n\nOnce the messages are correlated, they are released to the actual aggregator implementation.\nAlthough Spring Integration provides a default aggregator, its strategy (gathers the list of payloads from all messages and constructs a new message with this list as its payload) does not satisfy our requirement.\nHaving all the results in the message is a problem because our consumer might require the single best quote or all quotes.\nTo communicate the consumer's intention, earlier in the process we set the `RESPONSE_TYPE` header.\nNow we have to evaluate this header and return either all the quotes (the default aggregation strategy would work) or the best quote (the default aggregation strategy does not work because we have to determine which loan quote is the best).\n\nIn a more realistic application, selecting the best quote might be based on complex criteria that might influence the complexity of the aggregator implementation and configuration.\nFor now, though, we are making it simple.\nIf the consumer wants the best quote, we select a quote with the lowest interest rate.\nTo accomplish that, the `LoanQuoteAggregator` class sorts all the quotes by interest rate and returns the first one.\nThe `LoanQuote` class implements `Comparable` to compare quotes based on the rate attribute.\nOnce the response message is created, it is sent to the default reply channel of the messaging gateway (and, thus, to the consumer) that started the process.\nOur consumer got the loan quote!\n\nIn conclusion, a rather complex process was assembled based on POJO (that is existing or legacy) logic and a light-weight, embeddable messaging framework (Spring Integration) with a loosely coupled programming model intended to simplify integration of heterogeneous systems without requiring a heavy-weight ESB-like engine or a proprietary development and deployment environment.\nAs a developer, you should not need to port your Swing or console-based application to an ESB-like server or implement proprietary interfaces just because you have an integration concern.\n\nThis sample and the other samples in this section are built on top of Enterprise Integration Patterns.\nYou can consider them to be \"`building blocks`\" for your solution.\nThey are not intended to be complete solutions.\nIntegration concerns exist in all types of application, (whether server-based or not).\nOur goal is to make is so that integrating applications do not require changes in design, testing, and deployment strategy.\n\n[[samples-cafe]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "Composed Message Processor", "heading_level": 4, "file_order": 259, "section_index": 10, "content_hash": "cf18c312b921f52474be9f7db5a91d03b53ae3d7d738c1b1945fa709de863981", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:1be5a1186a774ef9850a61eb64aef14c7a12678a83dbb0f4e24c600f036e04fb", "content": "This section covers the cafe sample application that is included in the Spring Integration samples.\nThis sample is inspired by another sample featured in Gregor Hohpe's https://www.enterpriseintegrationpatterns.com/ramblings.html[Ramblings].\n\nThe domain is that of a cafe, and the following diagram depicts the basic flow:\n\n.Cafe Sample\nimage::cafe-eip.png[align=\"center\", scaledwidth=100%]\n\nThe `Order` object may contain multiple `OrderItems`.\nOnce the order is placed, a splitter breaks the composite order message into a single message for each drink.\nEach of these is then processed by a router that determines whether the drink is hot or cold (by checking the `OrderItem` object's 'isIced' property).\nThe `Barista` prepares each drink, but hot and cold drink preparation is handled by two distinct methods: 'prepareHotDrink' and 'prepareColdDrink'.\nThe prepared drinks are then sent to the `Waiter` where they are aggregated into a `Delivery` object.\n\nThe following listing shows the XML configuration:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans:beans xmlns:int=\"http://www.springframework.org/schema/integration\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:beans=\"http://www.springframework.org/schema/beans\"\n xmlns:int-stream=\"http://www.springframework.org/schema/integration/stream\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration.xsd\n http://www.springframework.org/schema/integration/stream\n https://www.springframework.org/schema/integration/stream/spring-integration-stream.xsd\">\n\n <int:gateway id=\"cafe\" service-interface=\"o.s.i.samples.cafe.Cafe\"/>\n\n <int:channel id=\"orders\"/>\n <int:splitter input-channel=\"orders\" ref=\"orderSplitter\"\n method=\"split\" output-channel=\"drinks\"/>\n\n <int:channel id=\"drinks\"/>\n <int:router input-channel=\"drinks\"\n ref=\"drinkRouter\" method=\"resolveOrderItemChannel\"/>\n\n <int:channel id=\"coldDrinks\"><int:queue capacity=\"10\"/></int:channel>\n <int:service-activator input-channel=\"coldDrinks\" ref=\"barista\"\n method=\"prepareColdDrink\" output-channel=\"preparedDrinks\"/>\n\n <int:channel id=\"hotDrinks\"><int:queue capacity=\"10\"/></int:channel>\n <int:service-activator input-channel=\"hotDrinks\" ref=\"barista\"\n method=\"prepareHotDrink\" output-channel=\"preparedDrinks\"/>\n\n <int:channel id=\"preparedDrinks\"/>\n <int:aggregator input-channel=\"preparedDrinks\" ref=\"waiter\"\n method=\"prepareDelivery\" output-channel=\"deliveries\"/>\n\n <int-stream:stdout-channel-adapter id=\"deliveries\"/>\n\n <beans:bean id=\"orderSplitter\"\n class=\"org.springframework.integration.samples.cafe.xml.OrderSplitter\"/>\n\n <beans:bean id=\"drinkRouter\"\n class=\"org.springframework.integration.samples.cafe.xml.DrinkRouter\"/>\n\n <beans:bean id=\"barista\" class=\"o.s.i.samples.cafe.xml.Barista\"/>\n <beans:bean id=\"waiter\" class=\"o.s.i.samples.cafe.xml.Waiter\"/>\n\n <int:poller id=\"poller\" default=\"true\" fixed-rate=\"1000\"/>\n\n</beans:beans>\n----\n\nEach message endpoint connects to input channels, output channels, or both.\nEach endpoint manages its own lifecycle (by default, endpoints start automatically upon initialization, to prevent that, add the `auto-startup` attribute with a value of `false`).\nMost importantly, notice that the objects are simple POJOs with strongly typed method arguments.\nThe following example shows the Splitter:\n\n[source,java]\n----\npublic class OrderSplitter {\n public List<OrderItem> split(Order order) {\n return order.getItems();\n }\n}\n----\n\nIn the case of the router, the return value does not have to be a `MessageChannel` instance (although, it can be).\nIn this example, a `String` value that holds the channel name is returned instead, as the following listing shows.\n\n[source,java]\n----\npublic class DrinkRouter {\n public String resolveOrderItemChannel(OrderItem orderItem) {\n return (orderItem.isIced()) ? \"coldDrinks\" : \"hotDrinks\";\n }\n}\n----\n\nNow, turning back to the XML, you can see that there are two `<service-activator>` elements.\nEach of these is delegating to the same `Barista` instance but with different methods (`prepareHotDrink` or `prepareColdDrink`), each is corresponding to one of the two channels where order items have been routed.\nThe following listing shows the Barista class (which contains the `prepareHotDrink` and `prepareColdDrink` methods)\n\n[source,java]\n----\npublic class Barista {\n\n private long hotDrinkDelay = 5000;\n private long coldDrinkDelay = 1000;\n\n private AtomicInteger hotDrinkCounter = new AtomicInteger();\n private AtomicInteger coldDrinkCounter = new AtomicInteger();\n\n public void setHotDrinkDelay(long hotDrinkDelay) {\n this.hotDrinkDelay = hotDrinkDelay;\n }\n\n public void setColdDrinkDelay(long coldDrinkDelay) {\n this.coldDrinkDelay = coldDrinkDelay;\n }\n\n public Drink prepareHotDrink(OrderItem orderItem) {\n try {\n Thread.sleep(this.hotDrinkDelay);\n System.out.println(Thread.currentThread().getName()\n + \" prepared hot drink #\" + hotDrinkCounter.incrementAndGet()\n + \" for order #\" + orderItem.getOrder().getNumber()\n + \": \" + orderItem);\n return new Drink(orderItem.getOrder().getNumber(), orderItem.getDrinkType(),\n orderItem.isIced(), orderItem.getShots());\n }\n catch (InterruptedException e) {\n Thread.currentThread().interrupt();\n return null;\n }\n }\n\n public Drink prepareColdDrink(OrderItem orderItem) {\n try {\n Thread.sleep(this.coldDrinkDelay);\n System.out.println(Thread.currentThread().getName()\n + \" prepared cold drink #\" + coldDrinkCounter.incrementAndGet()\n + \" for order #\" + orderItem.getOrder().getNumber() + \": \"\n + orderItem);\n return new Drink(orderItem.getOrder().getNumber(), orderItem.getDrinkType(),\n orderItem.isIced(), orderItem.getShots());\n }\n catch (InterruptedException e) {\n Thread.currentThread().interrupt();\n return null;\n }\n }\n}\n----\n\nAs you can see from the preceding code excerpt, the `Barista` methods have different delays (the hot drinks take five times as long to prepare).\nThis simulates work being completed at different rates.\nWhen the `CafeDemo` 'main' method runs, it loops 100 times and sends a single hot drink and a single cold drink each time.\nIt actually sends the messages by invoking the 'placeOrder' method on the `Cafe` interface.\nIn the earlier XML configuration, you can see that the `<gateway>` element is specified.\nThis triggers the creation of a proxy that implements the given service interface and connects it to a channel.\nThe channel name is provided on the `@Gateway` annotation of the `Cafe` interface, as the following interface definition shows:\n\n[source,java]\n----\npublic interface Cafe {\n\n @Gateway(requestChannel=\"orders\")\n void placeOrder(Order order);\n\n}\n----\n\nFinally, have a look at the `main()` method of the `CafeDemo` itself:\n\n[source,java]\n----\npublic static void main(String[] args) {\n AbstractApplicationContext context = null;\n if (args.length > 0) {\n context = new FileSystemXmlApplicationContext(args);\n }\n else {\n context = new ClassPathXmlApplicationContext(\"cafeDemo.xml\", CafeDemo.class);\n }\n Cafe cafe = context.getBean(\"cafe\", Cafe.class);\n for (int i = 1; i <= 100; i++) {\n Order order = new Order(i);\n order.addItem(DrinkType.LATTE, 2, false);\n order.addItem(DrinkType.MOCHA, 3, true);\n cafe.placeOrder(order);\n }\n}\n----\n\nTIP: To run this sample as well as eight others, refer to the `README.txt` within the `samples` directory of the main distribution (as described at xref:samples.adoc#samples-impl[the beginning of this chapter]).\n\nWhen you run `cafeDemo`, you can see that the cold drinks are initially prepared more quickly than the hot drinks.\nBecause there is an aggregator, the cold drinks are effectively limited by the rate of the hot drink preparation.\nThis is to be expected, based on their respective delays of 1000 and 5000 milliseconds.\nHowever, by configuring a poller with a concurrent task executor, you can dramatically change the results.\nFor example, you could use a thread pool executor with five workers for the hot drink barista while keeping the cold drink barista as it is.\nThe following listing configures such an arrangement:\n\n[source,xml]\n----\n<int:service-activator input-channel=\"hotDrinks\"\n ref=\"barista\"\n method=\"prepareHotDrink\"\n output-channel=\"preparedDrinks\"/>\n\n <int:service-activator input-channel=\"hotDrinks\"\n ref=\"barista\"\n method=\"prepareHotDrink\"\n output-channel=\"preparedDrinks\">\n <int:poller task-executor=\"pool\" fixed-rate=\"1000\"/>\n </int:service-activator>\n\n <task:executor id=\"pool\" pool-size=\"5\"/>\n----\n\nAlso, notice that the worker thread name is displayed with each invocation.\nYou can see that the hot drinks are prepared by the task-executor threads.\nIf you provide a much shorter poller interval (such as 100 milliseconds), you can see that it occasionally throttles the input by forcing the task scheduler (the caller) to invoke the operation.\n\nNOTE: In addition to experimenting with the poller's concurrency settings, you can also add the 'transactional' child element and then refer to any `PlatformTransactionManager` instance within the context.\n\n[[samples-xml-messaging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "The Cafe Sample", "heading_level": 3, "file_order": 259, "section_index": 11, "content_hash": "1be5a1186a774ef9850a61eb64aef14c7a12678a83dbb0f4e24c600f036e04fb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:eb62714ee1e76ed8228b35847f03b94f39f71880bce85342937924b15bf3a738", "content": "The XML messaging sample in `basic/xml` shows how to use some of the provided components that deal with XML payloads.\nThe sample uses the idea of processing an order for books represented as XML.\n\nNOTE: This sample shows that the namespace prefix can be whatever you want.\nWhile we usually use, `int-xml` for integration XML components, the sample uses `si-xml`.\n(`int` is short for \"`Integration`\", and `si` is short for \"`Spring Integration`\".)\n\nFirst, the order is split into a number of messages, each one is representing a single order item from the XPath splitter component.\nThe following listing shows the configuration of the splitter:\n\n[source,xml]\n----\n<si-xml:xpath-splitter id=\"orderItemSplitter\" input-channel=\"ordersChannel\"\n output-channel=\"stockCheckerChannel\" create-documents=\"true\">\n <si-xml:xpath-expression expression=\"/orderNs:order/orderNs:orderItem\"\n namespace-map=\"orderNamespaceMap\" />\n </si-xml:xpath-splitter>\n----\n\nA service activator then passes the message into a stock checker POJO.\nThe order item document is enriched with information from the stock checker about the order item stock level.\nThis enriched order item message is then used to route the message.\nIn the case where the order item is in stock, the message is routed to the warehouse.\nThe following listing configures the `xpath-router` that routes the messages:\n\n[source,xml]\n----\n<si-xml:xpath-router id=\"inStockRouter\" input-channel=\"orderRoutingChannel\" resolution-required=\"true\">\n <si-xml:xpath-expression expression=\"/orderNs:orderItem/@in-stock\" namespace-map=\"orderNamespaceMap\" />\n <si-xml:mapping value=\"true\" channel=\"warehouseDispatchChannel\"/>\n <si-xml:mapping value=\"false\" channel=\"outOfStockChannel\"/>\n</si-xml:xpath-router>\n----\n\nWhen the order item is not in stock, the message is transformed with XSLT into a format suitable for sending to the supplier.\nThe following listing configures the XSLT transformer:\n\n[source,xml]\n----\n<si-xml:xslt-transformer input-channel=\"outOfStockChannel\"\n output-channel=\"resupplyOrderChannel\"\n xsl-resource=\"classpath:org/springframework/integration/samples/xml/bigBooksSupplierTransformer.xsl\"/>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/samples.adoc", "title": "samples", "heading": "The XML Messaging Sample", "heading_level": 3, "file_order": 259, "section_index": 12, "content_hash": "eb62714ee1e76ed8228b35847f03b94f39f71880bce85342937924b15bf3a738", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/samples.adoc"}}
{"id": "sha256:108eca95568d8e7344a52bdec2e67615f39afc066b27a995bebd851f346cfd7d", "content": "[[scatter-gather]]\n\nStarting with version 4.1, Spring Integration provides an implementation of the https://www.enterpriseintegrationpatterns.com/BroadcastAggregate.html[scatter-gather] enterprise integration pattern.\nIt is a compound endpoint for which the goal is to send a message to the recipients and aggregate the results.\nAs noted in https://www.enterpriseintegrationpatterns.com/[_Enterprise Integration Patterns_], it is a component for scenarios such as \"`best quote`\", where we need to request information from several suppliers and decide which one provides us with the best term for the requested item.\n\nPreviously, the pattern could be configured by using discrete components.\nThis enhancement brings more convenient configuration.\n\nThe `ScatterGatherHandler` is a request-reply endpoint that combines a `PublishSubscribeChannel` (or a `RecipientListRouter`) and an `AggregatingMessageHandler`.\nThe request message is sent to the `scatter` channel, and the `ScatterGatherHandler` waits for the reply that the aggregator sends to the `outputChannel`.\n\n[[scatter-gather-functionality]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/scatter-gather.adoc", "title": "scatter-gather", "heading": "scatter-gather", "heading_level": 1, "file_order": 260, "section_index": 0, "content_hash": "108eca95568d8e7344a52bdec2e67615f39afc066b27a995bebd851f346cfd7d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/scatter-gather.adoc"}}
{"id": "sha256:5a21dc333280094ab4bb0959b73aaaca254f79b08cd59242fa36df1b1d46c288", "content": "The `Scatter-Gather` pattern suggests two scenarios: \"`auction`\" and \"`distribution`\".\nIn both cases, the `aggregation` function is the same and provides all the options available for the `AggregatingMessageHandler`.\n(Actually, the `ScatterGatherHandler` requires only an `AggregatingMessageHandler` as a constructor argument.)\nSee xref:overview.adoc#overview-endpoints-aggregator[Aggregator] for more information.\n\n[[auction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/scatter-gather.adoc", "title": "scatter-gather", "heading": "Functionality", "heading_level": 2, "file_order": 260, "section_index": 1, "content_hash": "5a21dc333280094ab4bb0959b73aaaca254f79b08cd59242fa36df1b1d46c288", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/scatter-gather.adoc"}}
{"id": "sha256:34b9fc87310aa19b05d3c8ee9fb9d3f8f0c487f8883b43636b8962375b72980d", "content": "The auction `Scatter-Gather` variant uses \"`publish-subscribe`\" logic for the request message, where the \"`scatter`\" channel is a `PublishSubscribeChannel` with `apply-sequence=\"true\"`.\nHowever, this channel can be any `MessageChannel` implementation (as is the case with the `request-channel` in the `ContentEnricher` -- see xref:content-enrichment.adoc[Content Enricher]).\nHowever, in this case, you should create your own custom `correlationStrategy` for the `aggregation` function.\n\n[[distribution]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/scatter-gather.adoc", "title": "scatter-gather", "heading": "Auction", "heading_level": 3, "file_order": 260, "section_index": 2, "content_hash": "34b9fc87310aa19b05d3c8ee9fb9d3f8f0c487f8883b43636b8962375b72980d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/scatter-gather.adoc"}}
{"id": "sha256:a112b0ba3652e8bf9e58858116ea0dab13a6f0bbcbc557d006e22383363f84ea", "content": "The distribution `Scatter-Gather` variant is based on the `RecipientListRouter` (see xref:router/implementations.adoc#router-implementations-recipientlistrouter[`RecipientListRouter`]) with all available options for the `RecipientListRouter`.\nThis is the second `ScatterGatherHandler` constructor argument.\nIf you want to rely on only the default `correlationStrategy` for the `recipient-list-router` and the `aggregator`, you should specify `apply-sequence=\"true\"`.\nOtherwise, you should supply a custom `correlationStrategy` for the `aggregator`.\nUnlike the `PublishSubscribeChannel` variant (the auction variant), having a `recipient-list-router` `selector` option lets filter target suppliers based on the message.\nWith `apply-sequence=\"true\"`, the default `sequenceSize` is supplied, and the `aggregator` can release the group correctly.\nThe distribution option is mutually exclusive with the auction option.\n\nNOTE: The `applySequence=true` is required only for plain Java configuration based on the `ScatterGatherHandler(MessageHandler scatterer, MessageHandler gatherer)` constructor configuration since the framework cannot mutate externally provided components.\nFor convenience, the XML and Java DSL for `Scatter-Gather` sets `applySequence` to true starting with version 6.0.\n\nFor both the auction and the distribution variants, the request (scatter) message is enriched with the `gatherResultChannel` header to wait for a reply message from the `aggregator`.\n\nBy default, all suppliers should send their result to the `replyChannel` header (usually by omitting the `output-channel` from the ultimate endpoint).\nHowever, the `gatherChannel` option is also provided, letting suppliers send their reply to that channel for the aggregation.\n\n[[scatter-gather-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/scatter-gather.adoc", "title": "scatter-gather", "heading": "Distribution", "heading_level": 3, "file_order": 260, "section_index": 3, "content_hash": "a112b0ba3652e8bf9e58858116ea0dab13a6f0bbcbc557d006e22383363f84ea", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/scatter-gather.adoc"}}
{"id": "sha256:788a2138f23eed8bc6a527220f97c5e02b910ce338576f52351b4f96fd9d1161", "content": "The following example shows Java configuration for the bean definition for `Scatter-Gather`:\n\n[source,java]\n----\n@Bean\npublic MessageHandler distributor() {\n RecipientListRouter router = new RecipientListRouter();\n router.setApplySequence(true);\n router.setChannels(Arrays.asList(distributionChannel1(), distributionChannel2(),\n distributionChannel3()));\n return router;\n}\n\n@Bean\npublic MessageHandler gatherer() {\n\treturn new AggregatingMessageHandler(\n new ExpressionEvaluatingMessageGroupProcessor(\"^[payload gt 5] ?: -1D\"),\n new SimpleMessageStore(),\n new HeaderAttributeCorrelationStrategy(\n IntegrationMessageHeaderAccessor.CORRELATION_ID),\n new ExpressionEvaluatingReleaseStrategy(\"size() == 2\"));\n}\n\n@Bean\n@ServiceActivator(inputChannel = \"distributionChannel\")\npublic MessageHandler scatterGatherDistribution() {\n\tScatterGatherHandler handler = new ScatterGatherHandler(distributor(), gatherer());\n\thandler.setOutputChannel(output());\n\treturn handler;\n}\n----\n\nIn the preceding example, we configure the `RecipientListRouter` `distributor` bean with `applySequence=\"true\"` and the list of recipient channels.\nThe next bean is for an `AggregatingMessageHandler`.\nFinally, we inject both those beans into the `ScatterGatherHandler` bean definition and mark it as a `@ServiceActivator` to wire the scatter-gather component into the integration flow.\n\nThe following example shows how to configure the `<scatter-gather>` endpoint by using the XML namespace:\n\n[source,xml]\n----\n<scatter-gather\n id=\"\" <1>\n auto-startup=\"\" <2>\n input-channel=\"\" <3>\n output-channel=\"\" <4>\n scatter-channel=\"\" <5>\n gather-channel=\"\" <6>\n order=\"\" <7>\n phase=\"\" <8>\n send-timeout=\"\" <9>\n gather-timeout=\"\" <10>\n requires-reply=\"\" > <11>\n <scatterer/> <12>\n <gatherer/> <13>\n</scatter-gather>\n----\n\n<1> The id of the endpoint.\nThe `ScatterGatherHandler` bean is registered with an alias of `id + '.handler'`.\nThe `RecipientListRouter` bean is registered with an alias of `id + '.scatterer'`.\nThe `AggregatingMessageHandler` bean is registered with an alias of `id + '.gatherer'`.\nOptional.\n(The `BeanFactory` generates a default `id` value.)\n<2> Lifecycle attribute signaling whether the endpoint should be started during application context initialization.\nIn addition, the `ScatterGatherHandler` also implements `Lifecycle` and starts and stops `gatherEndpoint`, which is created internally if a `gather-channel` is provided.\nOptional.\n(The default is `true`.)\n<3> The channel on which to receive request messages to handle them in the `ScatterGatherHandler`.\nRequired.\n<4> The channel to which the `ScatterGatherHandler` sends the aggregation results.\nOptional.\n(Incoming messages can specify a reply channel themselves in the `replyChannel` message header).\n<5> The channel to which to send the scatter message for the auction scenario.\nOptional.\nMutually exclusive with the `<scatterer>` sub-element.\n<6> The channel on which to receive replies from each supplier for the aggregation.\nIt is used as the `replyChannel` header in the scatter message.\nOptional.\nBy default, the `FixedSubscriberChannel` is created.\n<7> The order of this component when more than one handler is subscribed to the same `DirectChannel` (use for load balancing purposes).\nOptional.\n<8> Specifies the phase in which the endpoint should be started and stopped.\nThe startup order proceeds from lowest to highest, and the shutdown order is from highest to lowest.\nBy default, this value is `Integer.MAX_VALUE`, meaning that this container starts as late as possible and stops as soon as possible.\nOptional.\n<9> The timeout interval to wait when sending a reply `Message` to the `output-channel`.\nBy default, the `send()` blocks for one second.\nIt applies only if the output channel has some 'sending' limitations -- for example, a `QueueChannel` with a fixed 'capacity' that is full.\nIn this case, a `MessageDeliveryException` is thrown.\nThe `send-timeout` is ignored for `AbstractSubscribableChannel` implementations.\nFor `group-timeout(-expression)`, the `MessageDeliveryException` from the scheduled expired task leads this task to be rescheduled.\nOptional.\n<10> Lets you specify how long the scatter-gather waits for the reply message before returning.\nBy default, it waits for `30` seconds.\n'null' is returned if the reply times out.\nOptional.\n<11> Specifies whether the scatter-gather must return a non-null value.\nThis value is `true` by default.\nConsequently, a `ReplyRequiredException` is thrown when the underlying aggregator returns a null value after `gather-timeout`.\nNote, if `null` is a possibility, the `gather-timeout` should be specified to avoid an indefinite wait.\n<12> The `<recipient-list-router>` options.\nOptional.\nMutually exclusive with `scatter-channel` attribute.\n<13> The `<aggregator>` options.\nRequired.\n\nNOTE: Starting with version `6.5.3`, when a `ScatterGatherHandler` is configured for the `async = true` option, the request message handling thread is not blocked anymore waiting for a gather result on an internal `((PollableChannel) gatherResultChannel).receive(this.gatherTimeout)` operation.\nInstead, a `reactor.core.publisher.Mono` is returned as a reply object based on a gather result eventually produced from the `gatherResultChannel`.\nSuch a `Mono` is handled then according to the xref:reactive-streams.adoc#reactive-reply-payload[Reactive Streams support] in the framework.\n\n[[scatter-gather-error-handling]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/scatter-gather.adoc", "title": "scatter-gather", "heading": "Configuring a Scatter-Gather Endpoint", "heading_level": 2, "file_order": 260, "section_index": 4, "content_hash": "788a2138f23eed8bc6a527220f97c5e02b910ce338576f52351b4f96fd9d1161", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/scatter-gather.adoc"}}
{"id": "sha256:0013a4a94d9860abe0e72d21c7ee8f487cfa4133b9603110f31eb49dfa664adf", "content": "Since Scatter-Gather is a multi-request-reply component, error handling has some extra complexity.\nIn some cases, it is better to just catch and ignore downstream exceptions if the `ReleaseStrategy` allows the process to finish with fewer replies than requests.\nIn other cases something like a \"`compensation message`\" should be considered for returning from sub-flow, when an error happens.\n\nEvery async sub-flow should be configured with a `errorChannel` header for the proper error message sending from the `MessagePublishingErrorHandler`.\nOtherwise, an error will be sent to the global `errorChannel` with the common error handling logic.\nSee xref:scatter-gather.adoc#scatter-gather-error-handling[Error Handling] for more information about async error processing.\n\nSynchronous flows may use an `ExpressionEvaluatingRequestHandlerAdvice` for ignoring the exception or returning a compensation message.\nWhen an exception is thrown from one of the sub-flows to the `ScatterGatherHandler`, it is just re-thrown to upstream.\nThis way all other sub-flows will work for nothing, and their replies are going to be ignored in the `ScatterGatherHandler`.\nThis might be an expected behavior sometimes, but in most cases it would be better to handle the error in the particular sub-flow without impacting all others and the expectations in the gatherer.\n\nStarting with version 5.1.3, the `ScatterGatherHandler` is supplied with the `errorChannelName` option.\nIt is populated to the `errorChannel` header of the scatter message and is used when an async error happens or can be used in the regular synchronous sub-flow for directly sending an error message.\n\nThe sample configuration below demonstrates async error handling by returning a compensation message:\n\n[source,java]\n----\n@Bean\npublic IntegrationFlow scatterGatherAndExecutorChannelSubFlow(TaskExecutor taskExecutor) {\n return f -> f\n .scatterGather(\n scatterer -> scatterer\n .recipientFlow(f1 -> f1.transform(p -> \"Sub-flow#1\"))\n .recipientFlow(f2 -> f2\n .channel(c -> c.executor(taskExecutor))\n .transform(p -> {\n throw new RuntimeException(\"Sub-flow#2\");\n })),\n null,\n s -> s.errorChannel(\"scatterGatherErrorChannel\"));\n}\n\n@ServiceActivator(inputChannel = \"scatterGatherErrorChannel\")\npublic Message<?> processAsyncScatterError(MessagingException payload) {\n return MessageBuilder.withPayload(payload.getCause().getCause())\n .copyHeaders(payload.getFailedMessage().getHeaders())\n .build();\n}\n----\n\nTo produce a proper reply, we have to copy headers (including `replyChannel` and `errorChannel`) from the `failedMessage` of the `MessagingException` that has been sent to the `scatterGatherErrorChannel` by the `MessagePublishingErrorHandler`.\nThis way the target exception is returned to the gatherer of the `ScatterGatherHandler` for reply messages group completion.\nSuch an exception `payload` can be filtered out in the `MessageGroupProcessor` of the gatherer or processed other way downstream, after the scatter-gather endpoint.\n\nNOTE: Before sending scattering results to the gatherer, `ScatterGatherHandler` reinstates the request message headers, including reply and error channels if any.\nThis way errors from the `AggregatingMessageHandler` are going to be propagated to the caller, even if an async hand off is applied in scatter recipient subflows.\nFor successful operation, a `gatherResultChannel`, `originalReplyChannel` and `originalErrorChannel` headers must be transferred back to replies from scatter recipient subflows.\nIn this case a reasonable, finite `gatherTimeout` must be configured for the `ScatterGatherHandler`.\nOtherwise, it is going to be blocked waiting for a reply from the gatherer forever, by default.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/scatter-gather.adoc", "title": "scatter-gather", "heading": "Error Handling", "heading_level": 2, "file_order": 260, "section_index": 5, "content_hash": "0013a4a94d9860abe0e72d21c7ee8f487cfa4133b9603110f31eb49dfa664adf", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/scatter-gather.adoc"}}
{"id": "sha256:91b8293a6329a1dc7beeb1480000ecb0319ba42a90abd4b620eac7aca806395e", "content": "[[scripting]]\n\nSpring Integration 2.1 added support for the https://www.jcp.org/en/jsr/detail?id=223[JSR223 Scripting for Java specification], introduced in Java version 6.\nIt lets you use scripts written in any supported language (including Ruby, JRuby, Groovy and Kotlin) to provide the logic for various integration components, similar to the way the Spring Expression Language (SpEL) is used in Spring Integration.\nFor more information about JSR223, see the https://docs.oracle.com/javase/8/docs/technotes/guides/scripting/prog_guide/api.html[documentation].\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-scripting</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-scripting:{project-version}\"\n----\n======\n\nIn addition, you need to add a script engine implementation, e.g. JRuby.\n\nStarting with version 5.2, Spring Integration provides a Kotlin Jsr223 support.\nYou need to add this dependency into your project to make it working:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.jetbrains.kotlin</groupId>\n <artifactId>kotlin-scripting-jsr223</artifactId>\n <scope>runtime</scope>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nruntime 'org.jetbrains.kotlin:kotlin-scripting-jsr223'\n----\n======\n\nIn order to use a JVM scripting language, a JSR223 implementation for that language must be included in your class path.\nThe https://groovy-lang.org/[Groovy] and https://www.jruby.org[JRuby] projects provide JSR233 support in their standard distributions.\n\nIMPORTANT: Various JSR223 language implementations have been developed by third parties.\nA particular implementation's compatibility with Spring Integration depends on how well it conforms to the specification and the implementer's interpretation of the specification.\n\nTIP: If you plan to use Groovy as your scripting language, we recommend you use xref:groovy.adoc[Spring-Integration's Groovy Support] as it offers additional features specific to Groovy.\nHowever, this section is relevant as well.\n\n[[scripting-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/scripting.adoc", "title": "scripting", "heading": "scripting", "heading_level": 1, "file_order": 261, "section_index": 0, "content_hash": "91b8293a6329a1dc7beeb1480000ecb0319ba42a90abd4b620eac7aca806395e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/scripting.adoc"}}
{"id": "sha256:2367e87bafc3ac55bb08204dc0070aa242d88c69b49e7084da7dbab04c425812", "content": "Depending on the complexity of your integration requirements, scripts may be provided inline as CDATA in XML configuration or as a reference to a Spring resource that contains the script.\nTo enable scripting support, Spring Integration defines a `ScriptExecutingMessageProcessor`, which binds the message payload to a variable named `payload` and the message headers to a `headers` variable, both accessible within the script execution context.\nAll you need to do is write a script that uses these variables.\nThe following pair of examples show sample configurations that create filters:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow scriptFilter() {\n return f -> f.filter(Scripts.processor(\"some/path/to/ruby/script/RubyFilterTests.rb\"));\n}\n...\n@Bean\npublic Resource scriptResource() {\n\treturn new ByteArrayResource(\"headers.type == 'good'\".getBytes());\n}\n\n@Bean\npublic IntegrationFlow scriptFilter() {\n\treturn f -> f.filter(Scripts.processor(scriptResource()).lang(\"groovy\"));\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:filter input-channel=\"referencedScriptInput\">\n <int-script:script location=\"some/path/to/ruby/script/RubyFilterTests.rb\"/>\n</int:filter>\n\n<int:filter input-channel=\"inlineScriptInput\">\n <int-script:script lang=\"groovy\">\n <![CDATA[\n return payload == 'good'\n ]]>\n </int-script:script>\n</int:filter>\n----\n======\n\nAs the preceding examples show, the script can be included inline or can be included by reference to a resource location (by using the `location` attribute).\nAdditionally, the `lang` attribute corresponds to the language name (or its JSR223 alias).\n\nOther Spring Integration endpoint elements that support scripting include `router`, `service-activator`, `transformer`, and `splitter`.\nThe scripting configuration in each case would be identical to the above (besides the endpoint element).\n\nAnother useful feature of scripting support is the ability to update (reload) scripts without having to restart the application context.\nTo do so, specify the `refresh-check-delay` attribute on the `script` element, as the following example shows:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\nScripts.processor(...).refreshCheckDelay(5000)\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-script:script location=\"...\" refresh-check-delay=\"5000\"/>\n----\n======\n\nIn the preceding example, the script location is checked for updates every 5 seconds.\nIf the script is updated, any invocation that occurs later than 5 seconds since the update results in running the new script.\n\nConsider the following example:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\nScripts.processor(...).refreshCheckDelay(0)\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-script:script location=\"...\" refresh-check-delay=\"0\"/>\n----\n======\n\nIn the preceding example, the context is updated with any script modifications as soon as such modification occurs, providing a simple mechanism for 'real-time' configuration.\nAny negative value means the script is not reloaded after initialization of the application context.\nThis is the default behavior.\nThe following example shows a script that never updates:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\nScripts.processor(...).refreshCheckDelay(-1)\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-script:script location=\"...\" refresh-check-delay=\"-1\"/>\n----\n======\n\nIMPORTANT: Inline scripts cannot be reloaded.\n\n[[scripting-script-variable-bindings]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/scripting.adoc", "title": "scripting", "heading": "Script Configuration", "heading_level": 2, "file_order": 261, "section_index": 1, "content_hash": "2367e87bafc3ac55bb08204dc0070aa242d88c69b49e7084da7dbab04c425812", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/scripting.adoc"}}
{"id": "sha256:d580da68b89dab93558a791cbba3b92045760e9c7870d9c32c8769ad6d1d0e97", "content": "Variable bindings are required to enable the script to reference variables externally provided to the script's execution context.\nBy default, `payload` and `headers` are used as binding variables.\nYou can bind additional variables to a script by using `<variable>` elements (or `ScriptSpec.variables()` option), as the following example shows:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\nScripts.processor(\"foo/bar/MyScript.py\")\n .variables(Map.of(\"var1\", \"thing1\", \"var2\", \"thing2\", \"date\", date))\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<script:script lang=\"py\" location=\"foo/bar/MyScript.py\">\n <script:variable name=\"var1\" value=\"thing1\"/>\n <script:variable name=\"var2\" value=\"thing2\"/>\n <script:variable name=\"date\" ref=\"date\"/>\n</script:script>\n----\n======\n\nAs shown in the preceding example, you can bind a script variable either to a scalar value or to a Spring bean reference.\nNote that `payload` and `headers` are still included as binding variables.\n\nWith Spring Integration 3.0, in addition to the `variable` element, the `variables` attribute has been introduced.\nThis attribute and the `variable` elements are not mutually exclusive, and you can combine them within one `script` component.\nHowever, variables must be unique, regardless of where they are defined.\nAlso, since Spring Integration 3.0, variable bindings are allowed for inline scripts, too, as the following example shows:\n\n[source,xml]\n----\n<service-activator input-channel=\"input\">\n <script:script lang=\"ruby\" variables=\"thing1=THING1, date-ref=dateBean\">\n <script:variable name=\"thing2\" ref=\"thing2Bean\"/>\n <script:variable name=\"thing3\" value=\"thing2\"/>\n <![CDATA[\n payload.foo = thing1\n payload.date = date\n payload.bar = thing2\n payload.baz = thing3\n payload\n ]]>\n </script:script>\n</service-activator>\n----\n\nThe preceding example shows a combination of an inline script, a `variable` element, and a `variables` attribute.\nThe `variables` attribute contains a comma-separated value, where each segment contains an '=' separated pair of the variable and its value.\nThe variable name can be suffixed with `-ref`, as in the `date-ref` variable in the preceding example.\nThat means that the binding variable has the name, `date`, but the value is a reference to the `dateBean` bean from the application context.\nThis may be useful when using property placeholder configuration or command-line arguments.\n\nIf you need more control over how variables are generated, you can implement your own Java class that uses the `ScriptVariableGenerator` strategy, which is defined by the following interface:\n\n[source,java]\n----\npublic interface ScriptVariableGenerator {\n\n Map<String, Object> generateScriptVariables(Message<?> message);\n\n}\n----\n\nThis interface requires you to implement the `generateScriptVariables(Message)` method.\nThe message argument lets you access any data available in the message payload and headers, and the return value is the `Map` of bound variables.\nThis method is called every time the script is executed for a message.\nThe following example shows how to provide an implementation of `ScriptVariableGenerator` and reference it with the `script-variable-generator` attribute:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\nScripts.processor(\"foo/bar/MyScript.groovy\")\n .variableGenerator(new foo.bar.MyScriptVariableGenerator())\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-script:script location=\"foo/bar/MyScript.groovy\"\n script-variable-generator=\"variableGenerator\"/>\n\n<bean id=\"variableGenerator\" class=\"foo.bar.MyScriptVariableGenerator\"/>\n----\n======\n\nIf a `script-variable-generator` is not provided, script components use `DefaultScriptVariableGenerator`, which merges any provided `<variable>` elements with `payload` and `headers` variables from the `Message` in its `generateScriptVariables(Message)` method.\n\nIMPORTANT: You cannot provide both the `script-variable-generator` attribute and `<variable>` element(s).\nThey are mutually exclusive.\n\n[[graalmv-polyglot]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/scripting.adoc", "title": "scripting", "heading": "Script Variable Bindings", "heading_level": 3, "file_order": 261, "section_index": 2, "content_hash": "d580da68b89dab93558a791cbba3b92045760e9c7870d9c32c8769ad6d1d0e97", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/scripting.adoc"}}
{"id": "sha256:659dfcea924a8141c61e3b9e8a29b8c90e45fc9bdd1e8eb7da83a556edcc6a71", "content": "Starting with version 6.0, the framework provides a `PolyglotScriptExecutor` which is based the https://www.graalvm.org/latest/reference-manual/languages/[GraalVM Polyglot API].\nThe JSR223 engine implementation for JavaScript, removed from Java by itself, has been replaced by using this new script executor.\nSee more information about enabling JavaScript support in GraalVM and what https://www.graalvm.org/latest/reference-manual/js/[configuration options] can be propagated via script variables.\nIn particular, an `org.graalvm.polyglot:js` dependency has to be added to the target project to support JavaScript.\n\nStarting with version 6.4, the Python scripts support has been migrated to GraalVM Polyglot as well.\nNow these scripts can be written in Python 3.x and can use third-party libraries.\nSee https://www.graalvm.org/latest/reference-manual/python/[GraalPy] documentation for more information.\nIn particular, an `rg.graalvm.polyglot:python` dependency has to be added to the target project to support Python.\n\nBy default, the framework sets `allowAllAccess` to `true` on the shared Polyglot `Context` which enables this interaction with host JVM:\n\n* The creation and use of new threads.\n* The access to public host classes.\n* The loading of new host classes by adding entries to the class path.\n* Exporting new members into the polyglot bindings.\n* Unrestricted IO operations on a host system.\n* Passing experimental options.\n* The creation and use of new subprocesses.\n* The access to process environment variables.\n\nThis can be customized via overloaded `PolyglotScriptExecutor` constructor which accepts a `org.graalvm.polyglot.Context.Builder`.\nFor example, the Jython-based scripts still can be executed with an `option(\"python.EmulateJython\", \"true\")`.\nHowever, it is recommended to migrate to GraalPy altogether for better interpretation performance.\nTherefore, `import` for Java classes do not work anymore, instead `import java` has to be used and its `java.type()` function, respectively.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/scripting.adoc", "title": "scripting", "heading": "GraalVM Polyglot", "heading_level": 3, "file_order": 261, "section_index": 3, "content_hash": "659dfcea924a8141c61e3b9e8a29b8c90e45fc9bdd1e8eb7da83a556edcc6a71", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/scripting.adoc"}}
{"id": "sha256:d51c2b6554f8fa4bf9c650305b72017eeee0eb84ffb6e3cfe2a2d7bf02b91b95", "content": "[[security]]\n\nSecurity is one of the important functions in any modern enterprise (or cloud) application.\nMoreover, it is critical for distributed systems, such as those built on Enterprise Integration Patterns.\nMessaging independence and loose coupling let target systems communicate with each other with any type of data in the message's `payload`.\nWe can either trust all those messages or secure our service against \"`infecting`\" messages.\n\nNOTE: Starting with version `6.3` the whole `spring-integration-security` module is removed in favor of an API proposed by the more common `spring-security-messaging` library.\n\n[[securing-channels]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/security.adoc", "title": "security", "heading": "security", "heading_level": 1, "file_order": 262, "section_index": 0, "content_hash": "d51c2b6554f8fa4bf9c650305b72017eeee0eb84ffb6e3cfe2a2d7bf02b91b95", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/security.adoc"}}
{"id": "sha256:5891c2f1d99e7f434cfdc927622c76c99d23bae2bb090f1da2b095565e538c37", "content": "To secure message channels in the integration flow, an `AuthorizationChannelInterceptor` has to be added to those channels, or it can be configured as a global channel interceptor with a respective pattern:\n\n[tabs]\n======\nJava::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\n@GlobalChannelInterceptor(patterns = \"secured*\")\nAuthorizationChannelInterceptor authorizationChannelInterceptor() {\n return new AuthorizationChannelInterceptor(AuthorityAuthorizationManager.hasAnyRole(\"ADMIN\", \"PRESIDENT\"));\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<channel-interceptor pattern=\"securedChannel*\">\n <beans:bean class=\"org.springframework.security.messaging.access.intercept.AuthorizationChannelInterceptor\">\n <beans:constructor-arg>\n <beans:bean class=\"org.springframework.security.authorization.AuthorityAuthorizationManager\"\n factory-method=\"hasAnyRole\">\n <beans:constructor-arg>\n <beans:array>\n <beans:value>ADMIN</beans:value>\n <beans:value>PRESIDENT</beans:value>\n </beans:array>\n </beans:constructor-arg>\n </beans:bean>\n </beans:constructor-arg>\n </beans:bean>\n</channel-interceptor>\n----\n======\n\nSee xref:channel/configuration.adoc#global-channel-configuration-interceptors[Global Channel Interceptor Configuration] for more information.\n\n[[security-context-propagation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/security.adoc", "title": "security", "heading": "Securing channels", "heading_level": 2, "file_order": 262, "section_index": 1, "content_hash": "5891c2f1d99e7f434cfdc927622c76c99d23bae2bb090f1da2b095565e538c37", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/security.adoc"}}
{"id": "sha256:dccf02c578336ccab326f85ccd3145209a13b722ebe177ae9e256ec74509b282", "content": "To be sure that our interaction with the application is secure, according to its security system rules, we should supply some security context with an authentication (principal) object.\nThe Spring Security project provides a flexible, canonical mechanism to authenticate our application clients over HTTP, WebSocket, or SOAP protocols (as can be done for any other integration protocol with a simple Spring Security extension).\nIt also provides a `SecurityContext` for further authorization checks on the application objects, such as message channels.\nBy default, the `SecurityContext` is tied to the execution state of the current `Thread` by using the (`ThreadLocalSecurityContextHolderStrategy`).\nIt is accessed by an AOP (Aspect-oriented Programming) interceptor on secured methods to check (for example) whether that `principal` of the invocation has sufficient permissions to call that method.\nThis works well with the current thread.\nOften, though, processing logic can be performed on another thread, on several threads, or even on external systems.\n\nStandard thread-bound behavior is easy to configure if our application is built on the Spring Integration components and its message channels.\nIn this case, the secured objects can be any service activator or transformer, secured with a\n`MethodSecurityInterceptor` in their `<request-handler-advice-chain>` (see xref:handler-advice.adoc[Adding Behavior to Endpoints]) or even `MessageChannel` (see xref:security.adoc#securing-channels[Securing channels], earlier).\nWhen using `DirectChannel` communication, the `SecurityContext` is automatically available, because the downstream flow runs on the current thread.\nHowever, in the cases of the `QueueChannel`, `ExecutorChannel`, and `PublishSubscribeChannel` with an `Executor`, messages are transferred from one thread to another (or several) by the nature of those channels.\nIn order to support such scenarios, we have two choices:\n\n* Transfer an `Authentication` object within the message headers and extract and authenticate it on the other side before secured object access.\n* Propagate the `SecurityContext` to the thread that receives the transferred message.\n\nThis is implemented as a `org.springframework.security.messaging.context.SecurityContextPropagationChannelInterceptor` in the `spring-security-messaging` module, which can be added to any `MessageChannel` or configured as a `@GlobalChannelInterceptor`.\nThe logic of this interceptor is based on the `SecurityContext` extraction from the current thread (from the `preSend()` method) and its populating to another thread from the `postReceive()` (`beforeHandle()`) method.\nSee the `SecurityContextPropagationChannelInterceptor` Javadocs for more information.\n\nPropagation and population of `SecurityContext` is just one half of the work.\nSince the message is not an owner of the threads in the message flow, and the system should be sure that it is secured against any incoming messages, the `SecurityContext` has to be cleaned up from `ThreadLocal`.\nThe `SecurityContextPropagationChannelInterceptor` provides the `afterMessageHandled()` interceptor method implementation.\nIt cleans up operation by freeing the thread at the end of invocation from that propagated principal.\nThis means that, when the thread that processes the handed-off message finishes processing the message (successful or otherwise), the context is cleared so that it cannot inadvertently be used when processing another message.\n\n[NOTE]\n====\nWhen working with an xref:jms.adoc#jms-async-gateway[asynchronous gateway], you should use an appropriate `AbstractDelegatingSecurityContextSupport` implementation from Spring Security https://docs.spring.io/spring-security/site/docs/current/reference/html/servlet-webclient.html#concurrency[Concurrency Support], to let security context propagation be ensured over gateway invocation.\nThe following example shows how to do so:\n\n[source,java]\n----\n@Configuration\n@EnableIntegration\n@IntegrationComponentScan\npublic class ContextConfiguration {\n\n @Bean\n public AsyncTaskExecutor securityContextExecutor() {\n return new DelegatingSecurityContextAsyncTaskExecutor(\n new SimpleAsyncTaskExecutor());\n }\n\n}\n\n@MessagingGateway(asyncExecutor = \"securityContextExecutor\")\npublic interface SecuredGateway {\n\n @Gateway(requestChannel = \"queueChannel\")\n Future<String> send(String payload);\n\n}\n----\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/security.adoc", "title": "security", "heading": "Security Context Propagation", "heading_level": 2, "file_order": 262, "section_index": 2, "content_hash": "dccf02c578336ccab326f85ccd3145209a13b722ebe177ae9e256ec74509b282", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/security.adoc"}}
{"id": "sha256:6939130fbb22ed3b5553c148b6655181521b70cc2eaa3cea881221edab68926f", "content": "[[service-activator]]\n\nThe service activator is the endpoint type for connecting any Spring-managed object to an input channel so that it may play the role of a service.\nIf the service produces output, it may also be connected to an output channel.\nAlternatively, an output-producing service may be located at the end of a processing pipeline or message flow, in which case the inbound message's `replyChannel` header can be used.\nThis is the default behavior if no output channel is defined.\nAs with most of the configuration options described here, the same behavior actually applies for most of the other components.\n\nThe service activator is essentially a generic endpoint for calling a method on some object with an input message (payload and headers).\nIts internal logic is based on a `MessageHandler` which can be any possible implementation for a specific use-case, for example `DefaultMessageSplitter`, `AggregatingMessageHandler`, `SftpMessageHandler`, `JpaOutboundGateway` etc.\nTherefore, any outbound gateway and outbound channel adapter mentioned in this reference manual should be treated as a specific extension of this service activator endpoint; they all, in the end, call some object's method.\n\n[[service-activator-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/service-activator.adoc", "title": "service-activator", "heading": "service-activator", "heading_level": 1, "file_order": 263, "section_index": 0, "content_hash": "6939130fbb22ed3b5553c148b6655181521b70cc2eaa3cea881221edab68926f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/service-activator.adoc"}}
{"id": "sha256:361fa34d390b1aa232cbc89d164a78d45d559b3a5846f35513308e6beb433aa8", "content": "With Java & Annotation configuration, it is sufficient to mark the respective service method with the `@ServiceActivator` annotation - and the framework calls it when messages are consumed from an input channel:\n\n[source,java]\n----\npublic class SomeService {\n\n @ServiceActivator(inputChannel = \"exampleChannel\")\n public void exampleHandler(SomeData payload) {\n ...\n }\n\n}\n----\n\nSee more information in the xref:configuration/annotations.adoc[Annotation Support].\n\nFor Java, Groovy or Kotlin DSLs, the `.handle()` operator of an `IntegrationFlow` represents a service activator:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return IntegrationFlow\n .from(\"exampleChannel\")\n .handle(someService, \"exampleHandler\")\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun someFlow() =\n integrationFlow(\"exampleChannel\") {\n handle(someService, \"exampleHandler\")\n }\n----\n\nGroovy DSL::\n+\n[source, groovy, role=\"secondary\"]\n----\n@Bean\nsomeFlow() {\n integrationFlow 'exampleChannel',\n {\n handle someService, 'exampleHandler'\n }\n}\n----\n======\n\nSee more information about the DSLs in the respective chapters:\n\n* xref:dsl.adoc#java-dsl[Java DSL]\n* xref:kotlin-dsl.adoc[Kotlin DSL]\n* xref:groovy-dsl.adoc[Groovy DSL]\n\nTo create a service activator when using XML configuration, use the 'service-activator' element with the 'input-channel' and 'ref' attributes, as the following example shows:\n\n[source,xml]\n----\n<int:service-activator input-channel=\"exampleChannel\" ref=\"exampleHandler\"/>\n----\n\nThe preceding configuration selects all the methods from the `exampleHandler` that meet one of the messaging requirements, which are as follows:\n\n* annotated with `@ServiceActivator`\n* is `public`\n* not return `void` if `requiresReply == true`\n\nThe target method for invocation at runtime is selected for each request message by their `payload` type or as a fallback to the `Message<?>` type if such a method is present on target class.\n\nStarting with version 5.0, one service method can be marked with the `@org.springframework.integration.annotation.Default` as a fallback for all non-matching cases.\nThis can be useful when using xref:endpoint.adoc#content-type-conversion[content-type conversion] with the target method being invoked after conversion.\n\nTo delegate to an explicitly defined method of any object, you can add the `method` attribute, as the following example shows:\n\n[source,xml]\n----\n<int:service-activator input-channel=\"exampleChannel\" ref=\"somePojo\" method=\"someMethod\"/>\n----\n\nIn either case, when the service method returns a non-null value, the endpoint tries to send the reply message to an appropriate reply channel.\nTo determine the reply channel, it first checks whether an `output-channel` was provided in the endpoint configuration, as the following example shows:\n\n[source,xml]\n----\n<int:service-activator input-channel=\"exampleChannel\" output-channel=\"replyChannel\"\n ref=\"somePojo\" method=\"someMethod\"/>\n----\n\nIf the method returns a result and no `output-channel` is defined, the framework then checks the request message's `replyChannel` header value.\nIf that value is available, it then checks its type.\nIf it is a `MessageChannel`, the reply message is sent to that channel.\nIf it is a `String`, the endpoint tries to resolve the channel name to a channel instance.\nIf the channel cannot be resolved, a `DestinationResolutionException` is thrown.\nIf it can be resolved, the message is sent there.\nIf the request message does not have a `replyChannel` header and the `reply` object is a `Message`, its `replyChannel` header is consulted for a target destination.\nThis is the technique used for request-reply messaging in Spring Integration, and it is also an example of the return address pattern.\n\nIf your method returns a result, and you want to discard it and end the flow, you should configure the `output-channel` to send to a `NullChannel`.\nFor convenience, the framework registers one with the name, `nullChannel`.\nSee xref:channel/special-channels.adoc[Special Channels] for more information.\n\nThe service activator is one of those components that are not required to produce a reply message.\nIf your method returns `null` or has a `void` return type, the service activator exits after the method invocation, without any signals.\nThis behavior can be controlled by the `AbstractReplyProducingMessageHandler.requiresReply` option, which is also exposed as `requires-reply` when configuring with the XML namespace.\nIf the flag is set to `true` and the method returns null, a `ReplyRequiredException` is thrown.\n\nThe argument in the service method could be either a message or an arbitrary type.\nIf the latter, then it is assumed to be a message payload, which is extracted from the message and injected into the service method.\nWe generally recommend this approach, as it follows and promotes a POJO model when working with Spring Integration.\nArguments may also have `@Header` or `@Headers` annotations, as described in xref:configuration/annotations.adoc[Annotation Support].\n\nNOTE: The service method is not required to have any arguments, which means you can implement event-style service activators (where all you care about is an invocation of the service method) and not worry about the contents of the message.\nThink of it as a null JMS message.\nAn example use case for such an implementation is a simple counter or monitor of messages deposited on the input channel.\n\nStarting with version 4.1, the framework correctly converts message properties (`payload` and `headers`) to the Java 8 `Optional` POJO method parameters, as the following example shows:\n\n[source,java]\n----\npublic class MyBean {\n public String computeValue(Optional<String> payload,\n @Header(value=\"foo\", required=false) String foo1,\n @Header(value=\"foo\") Optional<String> foo2) {\n if (payload.isPresent()) {\n String value = payload.get();\n ...\n }\n else {\n ...\n }\n }\n\n}\n----\n\nWe generally recommend using a `ref` attribute if the custom service activator handler implementation can be reused in other `<service-activator>` definitions.\nHowever, if the custom service activator handler implementation is only used within a single definition of the `<service-activator>`, you can provide an inner bean definition, as the following example shows:\n\n[source,xml]\n----\n<int:service-activator id=\"exampleServiceActivator\" input-channel=\"inChannel\"\n output-channel = \"outChannel\" method=\"someMethod\">\n <beans:bean class=\"org.something.ExampleServiceActivator\"/>\n</int:service-activator>\n----\n\nNOTE: Using both the `ref` attribute and an inner handler definition in the same `<service-activator>` configuration is not allowed, as it creates an ambiguous condition and results in an exception being thrown.\n\nIMPORTANT: If the `ref` attribute references a bean that extends `AbstractMessageProducingHandler` (such as handlers provided by the framework itself), the configuration is optimized by injecting the output channel into the handler directly.\nIn this case, each `ref` must be to a separate bean instance (or a `prototype`-scoped bean) or use the inner `<bean/>` configuration type.\nIf you inadvertently reference the same message handler from multiple beans, you get a configuration exception.\n\n[[service-activators-and-the-spring-expression-language-spel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/service-activator.adoc", "title": "service-activator", "heading": "Configuring Service Activator", "heading_level": 2, "file_order": 263, "section_index": 1, "content_hash": "361fa34d390b1aa232cbc89d164a78d45d559b3a5846f35513308e6beb433aa8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/service-activator.adoc"}}
{"id": "sha256:2e2e461b8a9f084023e91f049812a0b730ba90ccf16bf13035462282be64ea59", "content": "Since Spring Integration 2.0, service activators can also benefit from https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions[SpEL].\n\nFor example, you can invoke any bean method without pointing to the bean in a `ref` attribute or including it as an inner bean definition, as follows:\n\n[source,xml]\n----\n<int:service-activator input-channel=\"in\" output-channel=\"out\"\n\texpression=\"@accountService.processAccount(payload, headers.accountId)\"/>\n\n\t<bean id=\"accountService\" class=\"thing1.thing2.Account\"/>\n----\n\nIn the preceding configuration, instead of injecting 'accountService' by using a `ref` or as an inner bean, we use SpEL's `@beanId` notation and invoke a method that takes a type compatible with the message payload.\nWe also pass a header value.\nAny valid SpEL expression can be evaluated against any content in the message.\nFor simple scenarios, your service activators need not reference a bean if all logic can be encapsulated in such an expression, as the following example shows:\n\n[source,xml]\n----\n<int:service-activator input-channel=\"in\" output-channel=\"out\" expression=\"payload * 2\"/>\n----\n\nIn the preceding configuration, our service logic is to multiply the payload value by two.\nSpEL lets us handle it relatively easily.\n\nSee xref:dsl/java-handle.adoc[Service Activators and the `.handle()` method] in the Java DSL chapter for more information about configuring service activator.\n\n[[async-service-activator]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/service-activator.adoc", "title": "service-activator", "heading": "Service Activators and the Spring Expression Language (SpEL)", "heading_level": 3, "file_order": 263, "section_index": 2, "content_hash": "2e2e461b8a9f084023e91f049812a0b730ba90ccf16bf13035462282be64ea59", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/service-activator.adoc"}}
{"id": "sha256:f4b9e23b8496742cd60a51df0a25d88a35b544704c37a04fd0123aa5318cc161", "content": "The service activator is invoked by the calling thread.\nThis is an upstream thread if the input channel is a `SubscribableChannel` or a poller thread for a `PollableChannel`.\nIf the service returns a `CompletableFuture<?>`, the default action is to send that as the payload of the message sent to the output (or reply) channel.\nStarting with version 4.3, you can now set the `async` attribute to `true` (by using `setAsync(true)` when using Java configuration).\nIf the service returns a `CompletableFuture<?>` when this the `async` attribute is set to `true`, the calling thread is released immediately and the reply message is sent on the thread (from within your service) that completes the future.\nThis is particularly advantageous for long-running services that use a `PollableChannel`, because the poller thread is released to perform other services within the framework.\n\nIf the service completes the future with an `Exception`, normal error processing occurs.\nAn `ErrorMessage` is sent to the `errorChannel` message header, if present.\nOtherwise, an `ErrorMessage` is sent to the default `errorChannel` (if available).\n\nStarting with version 6.1, if the output channel of the `AbstractMessageProducingHandler` is configured to a `ReactiveStreamsSubscribableChannel`, the async mode is turned on by default.\nIf the handler result is not a reactive type or `CompletableFuture<?>`, then a regular reply-producing process happens despite the output channel type.\n\nSee also xref:reactive-streams.adoc[Reactive Streams Support] for more information.\n\n[[service-activator-return-type]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/service-activator.adoc", "title": "service-activator", "heading": "Asynchronous Service Activator", "heading_level": 2, "file_order": 263, "section_index": 3, "content_hash": "f4b9e23b8496742cd60a51df0a25d88a35b544704c37a04fd0123aa5318cc161", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/service-activator.adoc"}}
{"id": "sha256:f1bf1aff9cba3e16389b4495c1e7c974f36ec516f90d898208961b165d473bef", "content": "The service method can return any type that becomes reply message payload.\nIn this case a new `Message<?>` object is created and all the headers from a request message are copied.\nThis works the same way for most Spring Integration `MessageHandler` implementations, when interaction is based on a POJO method invocation.\n\nA complete `Message<?>` object can also be returned from the method.\nHowever, keep in mind that, unlike xref:transformer.adoc[transformers], for a Service Activator this message will be modified by copying the headers from the request message if they are not already present in the returned message.\nSo, if your method parameter is a `Message<?>` and you copy some, but not all, existing headers in your service method, they will reappear in the reply message.\nIt is not a Service Activator responsibility to remove headers from a reply message and, pursuing the loosely coupled principle, it is better to add a `HeaderFilter` in the integration flow.\nAlternatively, a Transformer can be used instead of a Service Activator but, in that case, when returning a full `Message<?>` the method is completely responsible for the message, including copying request message headers (if needed).\nYou must ensure that important framework headers (e.g. `replyChannel`, `errorChannel`), if present, have to be preserved.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/service-activator.adoc", "title": "service-activator", "heading": "Service Activator and Method Return Type", "heading_level": 2, "file_order": 263, "section_index": 4, "content_hash": "f1bf1aff9cba3e16389b4495c1e7c974f36ec516f90d898208961b165d473bef", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/service-activator.adoc"}}
{"id": "sha256:8a5e2e92aa6e2806736196f647f387b481f927ce2d62981fb42b899fb49695bd", "content": "[[sftp]]\n\nSpring Integration provides support for file transfer operations over SFTP.\n\nThe Secure File Transfer Protocol (SFTP) is a network protocol that lets you transfer files between two computers on the Internet over any reliable stream.\n\nThe SFTP protocol requires a secure channel, such as SSH, and visibility to a client's identity throughout the SFTP session.\n\nSpring Integration supports sending and receiving files over SFTP by providing three client side endpoints: inbound channel adapter, outbound channel adapter, and outbound gateway.\nIt also provides convenient namespace configuration to define these client components.\n\nNOTE: Starting with version 6.0, an outdated JCraft JSch client has been replaced with modern https://mina.apache.org/sshd-project/index.html[Apache MINA SSHD] framework.\nThis caused a lot of breaking changes in the framework components.\nHowever, in most cases, such a migration is hidden behind Spring Integration API.\nThe most drastic changed has happened with a `DefaultSftpSessionFactory` which is based now on the `org.apache.sshd.client.SshClient` and exposes some if its configuration properties.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-sftp</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-sftp:{project-version}\"\n----\n======\n\nTo include the SFTP namespace in your xml configuration, include the following attributes on the root element:\n\n[source,xml]\n----\nxmlns:int-sftp=\"http://www.springframework.org/schema/integration/sftp\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/integration/sftp\n https://www.springframework.org/schema/integration/sftp/spring-integration-sftp.xsd\"\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/sftp.adoc", "title": "sftp", "heading": "sftp", "heading_level": 1, "file_order": 264, "section_index": 0, "content_hash": "8a5e2e92aa6e2806736196f647f387b481f927ce2d62981fb42b899fb49695bd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/sftp.adoc"}}
{"id": "sha256:3386b943b9c8a798b83275cef828d80b6cfaf0f6c114690907b8faac9a10b0e0", "content": "[[jmx-shutdown]]\n\nAs described in \"xref:jmx.adoc#jmx-mbean-exporter[MBean Exporter]\", the MBean exporter provides a JMX operation called `stopActiveComponents`, which is used to stop the application in an orderly manner.\nThe operation has a single `Long` parameter.\nThe parameter indicates how long (in milliseconds) the operation waits to allow in-flight messages to complete.\nThe operation works as follows:\n\n. Call `beforeShutdown()` on all beans that implement `OrderlyShutdownCapable`.\n+\nDoing so lets such components prepare for shutdown.\nExamples of components that implement this interface and what they do with this call include JMS and AMQP message-driven adapters that stop their listener containers, TCP server connection factories that stop accepting new connections (while keeping existing connections open), TCP inbound endpoints that drop (log) any new messages received, and HTTP inbound endpoints that return `503 - Service Unavailable` for any new requests.\n. Stop any active channels, such as JMS- or AMQP-backed channels.\n. Stop all `MessageSource` instances.\n. Stop all inbound ``MessageProducer``s (that are not `OrderlyShutdownCapable`).\n. Wait for any remaining time left, as defined by the value of the `Long` parameter passed in to the operation.\n+\nDoing so lets any in-flight messages complete their journeys.\nIt is therefore important to select an appropriate timeout when invoking this operation.\n. Call `afterShutdown()` on all `OrderlyShutdownCapable` components.\n+\nDoing so lets such components perform final shutdown tasks (closing all open sockets, for example).\n\nAs discussed in xref:jmx.adoc#jmx-mbean-shutdown[Orderly Shutdown Managed Operation], this operation can be invoked by using JMX.\nIf you wish to programmatically invoke the method, you need to inject or otherwise get a reference to the `IntegrationMBeanExporter`.\nIf no `id` attribute is provided on the `<int-jmx:mbean-export/>` definition, the bean has a generated name.\nThis name contains a random component to avoid `ObjectName` collisions if multiple Spring Integration contexts exist in the same JVM (`MBeanServer`).\n\nFor this reason, if you wish to invoke the method programmatically, we recommend that you provide the exporter with an `id` attribute so that you can access it in the application context.\n\nFinally, the operation can be invoked by using the `<control-bus>` element.\nSee the https://github.com/spring-projects/spring-integration-samples/tree/main/intermediate/monitoring[monitoring Spring Integration sample application] for details.\n\nNOTE: The algorithm described earlier was improved in version 4.1.\nPreviously, all task executors and schedulers were stopped.\nThis could cause mid-flow messages in `QueueChannel` instances to remain.\nNow the shutdown leaves pollers running, to let these messages be drained and processed.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/shutdown.adoc", "title": "shutdown", "heading": "shutdown", "heading_level": 1, "file_order": 265, "section_index": 0, "content_hash": "3386b943b9c8a798b83275cef828d80b6cfaf0f6c114690907b8faac9a10b0e0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/shutdown.adoc"}}
{"id": "sha256:73d322be53b1674abef4d3e9f10fc928bd210ed728c4d3d4bca3ca50eb2856ea", "content": "[[smb]]\n\nSpring Integration provides support for file transfer operations with SMB.\n\nThe https://en.wikipedia.org/wiki/Server_Message_Block[Server Message Block] (SMB) is a simple network protocol that lets you transfer files to a shared file server.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-smb</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-smb:{project-version}\"\n----\n======\n\n[[overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "smb", "heading_level": 1, "file_order": 266, "section_index": 0, "content_hash": "73d322be53b1674abef4d3e9f10fc928bd210ed728c4d3d4bca3ca50eb2856ea", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:23c0a45d803f1a0e7693003cb15ef7ee2e9b832ead76113db8d656787030d343", "content": "The https://github.com/codelibs/jcifs[Java CIFS] Client Library has been chosen as a Java implementation for the CIFS/SMB networking protocol.\nIts `SmbFile` abstraction is simply wrapped to the Spring Integration \"Remote File\" foundations like `SmbSession`, `SmbRemoteFileTemplate`, etc.\n\nThe SMB Channel Adapters and support classes implementations are fully similar to existing components for (S)FTP or AWS S3 protocols.\nSo, if you are familiar with those components, it is straightforward to use.\n\nSpring Integration supports sending and receiving files over SMB by providing three client-side endpoints: inbound channel adapter, outbound channel adapter, and outbound gateway.\nIt also provides convenient namespace-based configuration options for defining these client components.\n\nTo use the SMB namespace, add the following to the header of your XML file:\n\n[source,xml]\n----\nxmlns:int-smb=\"http://www.springframework.org/schema/integration/smb\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/integration/smb\n https://www.springframework.org/schema/integration/smb/spring-integration-smb.xsd\"\n\n----\n\n[[smb-session-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Overview", "heading_level": 2, "file_order": 266, "section_index": 1, "content_hash": "23c0a45d803f1a0e7693003cb15ef7ee2e9b832ead76113db8d656787030d343", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:092e3f747a273dbb60a35ba8b742736a8d4c7d2449700ca863bfefa2cae303f4", "content": "Before configuring the SMB adapter, you must configure an SMB session factory.\nYou can configure the SMB session factory with a regular bean definition, as the following examples show:\n\nThe `SmbSessionFactory` exposes options to set the SMB protocol with Min/Max versions.\nFor example, supporting a minimum version of SMB 2.1 and a maximum version of the SMB 3.1.1:\n\n[source,java]\n----\n@Bean\npublic SmbSessionFactory smbSessionFactory() {\n SmbSessionFactory smbSession = new SmbSessionFactory();\n smbSession.setHost(\"myHost\");\n smbSession.setPort(445);\n smbSession.setDomain(\"myDomain\");\n smbSession.setUsername(\"myUser\");\n smbSession.setPassword(\"myPassword\");\n smbSession.setShareAndDir(\"myShareAndDir\");\n smbSession.setSmbMinVersion(DialectVersion.SMB210);\n smbSession.setSmbMaxVersion(DialectVersion.SMB311);\n return smbSession;\n}\n----\n\nThe `SmbSessionFactory` can be initialized with a custom `org.codelibs.jcifs.smb.CIFSContext`.\n\nNOTE: Setting of the SMB protocol Min/Max versions must be done in your implementation of `org.codelibs.jcifs.smb.CIFSContext`.\n\n[source,java]\n----\n@Bean\npublic SmbSessionFactory smbSessionFactory() {\n SmbSessionFactory smbSession = new SmbSessionFactory(new MyCIFSContext());\n smbSession.setHost(\"myHost\");\n smbSession.setPort(445);\n smbSession.setDomain(\"myDomain\");\n smbSession.setUsername(\"myUser\");\n smbSession.setPassword(\"myPassword\");\n smbSession.setShareAndDir(\"myShareAndDir\");\n return smbSession;\n}\n----\n\n[[smb-session-caching]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "SMB Session Factory", "heading_level": 2, "file_order": 266, "section_index": 2, "content_hash": "092e3f747a273dbb60a35ba8b742736a8d4c7d2449700ca863bfefa2cae303f4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:ed9197538678b853e2006c04bf54e92e769fc7f57f7175943bb83d31cc3e50f7", "content": "The `SmbSessionFactory` initiates a new connection every time when a `Session` is requested.\nIn most cases that is not necessary and `Session` could be cached.\nFor that purpose, the `SmbSessionFactory` as mentioned earlier should be wrapped into an instance of `CachingSessionFactory`:\n\n[source,java]\n----\n@Bean\npublic CachingSessionFactory cachingSessionFactory(SmbSessionFactory smbSessionFactory) {\n cachingSessionFactory cachingSessionFactory = new CachingSessionFactory(smbSessionFactory, 10);\n cachingSessionFactory.setSessionWaitTimeout(1000);\n return cachingSessionFactory;\n}\n----\nAnd then its bean can be injected into channel adapters described below.\n\n[[smb-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "SMB Session Caching", "heading_level": 2, "file_order": 266, "section_index": 3, "content_hash": "ed9197538678b853e2006c04bf54e92e769fc7f57f7175943bb83d31cc3e50f7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:54eafd47c0aecebd43b091dcb511c8078c4646bba4b94b32587ba40d599d8d00", "content": "To download SMB files locally the `SmbInboundFileSynchronizingMessageSource` is provided.\nIt is simple extension of the `AbstractInboundFileSynchronizingMessageSource` which requires `SmbInboundFileSynchronizer` injection.\nFor filtering remote files, you still can use any existing `FileListFilter` implementations, but particular `SmbRegexPatternFileListFilter` and `SmbSimplePatternFileListFilter` are provided.\n\n[source,java]\n----\n@Bean\npublic SmbInboundFileSynchronizer smbInboundFileSynchronizer() {\n SmbInboundFileSynchronizer fileSynchronizer =\n new SmbInboundFileSynchronizer(smbSessionFactory());\n fileSynchronizer.setFilter(compositeFileListFilter());\n fileSynchronizer.setRemoteDirectory(\"mySharedDirectoryPath\");\n fileSynchronizer.setDeleteRemoteFiles(true);\n return fileSynchronizer;\n}\n\n@Bean\npublic CompositeFileListFilter<SmbFile> compositeFileListFilter() {\n CompositeFileListFilter<SmbFile> filters = new CompositeFileListFilter<>();\n filters.addFilter(new SmbRegexPatternFileListFilter(\"^(?i).+((\\\\.txt))$\"));\n return filters;\n}\n\n@Bean\npublic MessageChannel smbFileInputChannel() {\n return new DirectChannel();\n}\n\n@Bean\n@InboundChannelAdapter(value = \"smbFileInputChannel\",\n poller = @Poller(fixedDelay = \"2000\"))\npublic MessageSource<File> smbMessageSource() {\n SmbInboundFileSynchronizingMessageSource messageSource =\n new SmbInboundFileSynchronizingMessageSource(smbInboundFileSynchronizer());\n messageSource.setLocalDirectory(new File(\"myLocalDirectoryPath\"));\n messageSource.setAutoCreateLocalDirectory(true);\n return messageSource;\n}\n----\n\nFor XML configuration the `<int-smb:inbound-channel-adapter>` component is provided.\n\nStarting with version 6.2, you can filter SMB files based on last-modified strategy using `SmbLastModifiedFileListFilter`.\nThis filter can be configured with an `age` property so that only files older than this value are passed by the filter.\nThe age defaults to 60 seconds, but you should choose an age that is large enough to avoid picking up a file early (due to, say, network glitches.\nLook into its Javadoc for more information.\n\nIn contrast, starting with version 6.5, an `SmbRecentFileListFilter` has been introduced to accept only those files which are not older than provided `age`.\n\n[[configuring-with-the-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "SMB Inbound Channel Adapter", "heading_level": 2, "file_order": 266, "section_index": 4, "content_hash": "54eafd47c0aecebd43b091dcb511c8078c4646bba4b94b32587ba40d599d8d00", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:8031c361c180f22f0b1804c857f5e318b02b98bf9869ec6681d743651db2256d", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class SmbJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(SmbJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public SmbSessionFactory smbSessionFactory() {\n SmbSessionFactory smbSession = new SmbSessionFactory();\n smbSession.setHost(\"myHost\");\n smbSession.setPort(445);\n smbSession.setDomain(\"myDomain\");\n smbSession.setUsername(\"myUser\");\n smbSession.setPassword(\"myPassword\");\n smbSession.setShareAndDir(\"myShareAndDir\");\n smbSession.setSmbMinVersion(DialectVersion.SMB210);\n smbSession.setSmbMaxVersion(DialectVersion.SMB311);\n return smbSession;\n }\n\n @Bean\n public IntegrationFlow smbInboundFlow() {\n return IntegrationFlow\n .from(Smb.inboundAdapter(smbSessionFactory())\n .preserveTimestamp(true)\n .remoteDirectory(\"smbSource\")\n .regexFilter(\".*\\\\.txt$\")\n .localFilename(f -> f.toUpperCase() + \".a\")\n .localDirectory(new File(\"d:\\\\smb_files\")),\n e -> e.id(\"smbInboundAdapter\")\n .autoStartup(true)\n .poller(Pollers.fixedDelay(5000)))\n .handle(m -> System.out.println(m.getPayload()))\n .get();\n }\n}\n----\n\n[[smb-streaming-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Configuring with the Java DSL", "heading_level": 3, "file_order": 266, "section_index": 5, "content_hash": "8031c361c180f22f0b1804c857f5e318b02b98bf9869ec6681d743651db2256d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:485d8c2b95377a1eefdf509474808f981648ec6154e10aa70c82fbe9d27e817b", "content": "This adapter produces a message with payloads of type `InputStream`, letting files be fetched without writing to the local file system.\nSince the session remains open, the consuming application is responsible for closing the session when the file has been consumed.\nThe session is provided in the `closeableResource` header (`IntegrationMessageHeaderAccessor.CLOSEABLE_RESOURCE`).\nStandard framework components, such as the `FileSplitter` and `StreamTransformer`, automatically close the session.\nSee xref:file/splitter.adoc[File Splitter] and xref:transformer.adoc#stream-transformer[Stream Transformer] for more information about these components.\nThe following example shows how to configure an `inbound-streaming-channel-adapter`:\n\n[source, xml]\n----\n<int-smb:inbound-streaming-channel-adapter id=\"smbInbound\"\n channel=\"smbChannel\"\n session-factory=\"sessionFactory\"\n filename-pattern=\"*.txt\"\n filename-regex=\".*\\.txt\"\n filter=\"filter\"\n filter-expression=\"@myFilterBean.check(#root)\"\n remote-file-separator=\"/\"\n comparator=\"comparator\"\n max-fetch-size=\"1\"\n remote-directory-expression=\"'foo/bar'\">\n <int:poller fixed-rate=\"1000\" />\n</int-smb:inbound-streaming-channel-adapter>\n----\n\nOnly one of `filename-pattern`, `filename-regex`, `filter`, or `filter-expression` is allowed.\n\nThe `SmbStreamingMessageSource` adapter prevents duplicates for remote files with `SmbPersistentAcceptOnceFileListFilter` based on the in-memory `SimpleMetadataStore`.\nBy default, this filter is also applied with the filename pattern (or regex).\nIf you need to allow duplicates, you can use `AcceptAllFileListFilter`.\nAny other use cases can be handled by `CompositeFileListFilter` (or `ChainFileListFilter`).\nThe Java configuration (xref:smb.adoc#smb-streaming-java[later in the document]) shows one technique to remove the remote file after processing to avoid duplicates.\n\nFor more information about the `SmbPersistentAcceptOnceFileListFilter`, and how it is used, see xref:file/remote-persistent-flf.adoc[Remote Persistent File List Filters].\n\nUse the `max-fetch-size` attribute to limit the number of files fetched on each poll when a fetch is necessary.\nSet it to `1` and use a persistent filter when running in a clustered environment.\nSee xref:smb.adoc#smb-max-fetch[Inbound Channel Adapters: Controlling Remote File Fetching] for more information.\n\nThe adapter puts the remote directory and file name in the `FileHeaders.REMOTE_DIRECTORY` and `FileHeaders.REMOTE_FILE` headers, respectively.\nThe `FileHeaders.REMOTE_FILE_INFO` header provides additional remote file information (represented in JSON by default).\nIf you set the `fileInfoJson` property on the `SmbStreamingMessageSource` to `false`, the header contains an `SmbFileInfo` object.\n\n[[smb-streaming-java]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "SMB Streaming Inbound Channel Adapter", "heading_level": 2, "file_order": 266, "section_index": 6, "content_hash": "485d8c2b95377a1eefdf509474808f981648ec6154e10aa70c82fbe9d27e817b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:111ab0d9c94d0759eb1578c1021259b9042c83e4143c1c27f51fa5edb13ecddd", "content": "The following Spring Boot application shows an example of how to configure the inbound adapter with Java configuration:\n\n[source, java]\n----\n@SpringBootApplication\npublic class SmbJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(SmbJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n @InboundChannelAdapter(channel = \"stream\")\n public MessageSource<InputStream> smbMessageSource() {\n SmbStreamingMessageSource messageSource = new SmbStreamingMessageSource(template());\n messageSource.setRemoteDirectory(\"smbSource/\");\n messageSource.setFilter(new AcceptAllFileListFilter<>());\n messageSource.setMaxFetchSize(1);\n return messageSource;\n }\n\n @Bean\n @Transformer(inputChannel = \"stream\", outputChannel = \"data\")\n public org.springframework.integration.transformer.Transformer transformer() {\n return new StreamTransformer(\"UTF-8\");\n }\n\n @Bean\n public SmbRemoteFileTemplate template() {\n return new SmbRemoteFileTemplate(smbSessionFactory());\n }\n\n @ServiceActivator(inputChannel = \"data\", adviceChain = \"after\")\n @Bean\n public MessageHandler handle() {\n return System.out::println;\n }\n\n @Bean\n public ExpressionEvaluatingRequestHandlerAdvice after() {\n ExpressionEvaluatingRequestHandlerAdvice advice = new ExpressionEvaluatingRequestHandlerAdvice();\n advice.setOnSuccessExpression(\n \"@template.remove(headers['file_remoteDirectory'] + headers['file_remoteFile'])\");\n advice.setPropagateEvaluationFailures(true);\n return advice;\n }\n\n}\n----\n\nNotice that, in this example, the message handler downstream of the transformer has an `advice` that removes the remote file after processing.\n\n[[smb-max-fetch]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Configuring with Java Configuration", "heading_level": 3, "file_order": 266, "section_index": 7, "content_hash": "111ab0d9c94d0759eb1578c1021259b9042c83e4143c1c27f51fa5edb13ecddd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:b40e6feabf8b5cf9445c6f178b491ebd8512fd6330b744307a36b8bd88d2918b", "content": "See xref:sftp/max-fetch.adoc[SFTP: Controlling Remote File Fetching] for exactly the same generic functionality.\n\n[[smb-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Inbound Channel Adapters: Controlling Remote File Fetching", "heading_level": 2, "file_order": 266, "section_index": 8, "content_hash": "b40e6feabf8b5cf9445c6f178b491ebd8512fd6330b744307a36b8bd88d2918b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:8d2880bf04eefa30be31f374473c39ffe5a0a395bbeb98f69e56b2773eb7c01f", "content": "For writing files to an SMB share, and for XML `<int-smb:outbound-channel-adapter>` component we use the `SmbMessageHandler`.\nIn case of Java configuration a `SmbMessageHandler` should be supplied with the `SmbSessionFactory` (or `SmbRemoteFileTemplate`).\n\n[source,java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"storeToSmbShare\")\npublic MessageHandler smbMessageHandler(SmbSessionFactory smbSessionFactory) {\n SmbMessageHandler handler = new SmbMessageHandler(smbSessionFactory);\n handler.setRemoteDirectoryExpression(\n new LiteralExpression(\"remote-target-dir\"));\n handler.setFileNameGenerator(m ->\n m.getHeaders().get(FileHeaders.FILENAME, String.class) + \".test\");\n handler.setAutoCreateDirectory(true);\n return handler;\n}\n----\n\n[[inbound-channel-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "SMB Outbound Channel Adapter", "heading_level": 2, "file_order": 266, "section_index": 9, "content_hash": "8d2880bf04eefa30be31f374473c39ffe5a0a395bbeb98f69e56b2773eb7c01f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:b6a1135dfdac9d056635bd987e2920cf99f0b5b9de1fead4bf5bd3cc04129fe2", "content": "The following Spring Boot application shows an example of how to configure the outbound adapter using the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\n@IntegrationComponentScan\npublic class SmbJavaApplication {\n\n public static void main(String[] args) {\n ConfigurableApplicationContext context =\n new SpringApplicationBuilder(SmbJavaApplication.class)\n .web(false)\n .run(args);\n MyGateway gateway = context.getBean(MyGateway.class);\n gateway.sendToSmb(new File(\"/foo/bar.txt\"));\n }\n\n @Bean\n public SmbSessionFactory smbSessionFactory() {\n SmbSessionFactory smbSession = new SmbSessionFactory();\n smbSession.setHost(\"myHost\");\n smbSession.setPort(445);\n smbSession.setDomain(\"myDomain\");\n smbSession.setUsername(\"myUser\");\n smbSession.setPassword(\"myPassword\");\n smbSession.setShareAndDir(\"myShareAndDir\");\n smbSession.setSmbMinVersion(DialectVersion.SMB210);\n smbSession.setSmbMaxVersion(DialectVersion.SMB311);\n return smbSession;\n }\n\n @Bean\n public IntegrationFlow smbOutboundFlow() {\n return IntegrationFlow.from(\"toSmbChannel\")\n .handle(Smb.outboundAdapter(smbSessionFactory(), FileExistsMode.REPLACE)\n .useTemporaryFileName(false)\n .fileNameExpression(\"headers['\" + FileHeaders.FILENAME + \"']\")\n .remoteDirectory(\"smbTarget\")\n ).get();\n }\n\n @MessagingGateway\n public interface MyGateway {\n\n @Gateway(requestChannel = \"toSmbChannel\")\n void sendToSmb(File file);\n }\n\n}\n----\n\n[[smb-outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Configuring with the Java DSL", "heading_level": 3, "file_order": 266, "section_index": 10, "content_hash": "b6a1135dfdac9d056635bd987e2920cf99f0b5b9de1fead4bf5bd3cc04129fe2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:df459fe85e1aa9a77b63dc229ebb0d5d18b85ad83bbf4a2f16e4504105d9c72e", "content": "The SMB outbound gateway provides a limited set of commands to interact with a remote SMB server.\nThe supported commands are:\n\n* `ls` (list files)\n* `nlst` (list file names)\n* `get` (retrieve file)\n* `mget` (retrieve file(s))\n* `rm` (remove file(s))\n* `mv` (move/rename file)\n* `put` (send a file)\n* `mput` (send multiple files)\n\n[[using-the-ls-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "SMB Outbound Gateway", "heading_level": 2, "file_order": 266, "section_index": 11, "content_hash": "df459fe85e1aa9a77b63dc229ebb0d5d18b85ad83bbf4a2f16e4504105d9c72e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:d25069f57b86c2b8466a0e22ccf3348be3f1c73a4e6b6ee9038798a6e88e527d", "content": "`ls` lists remote files and supports the following options:\n\n* `-1`: Retrieve a list of filenames.\nThe default is to retrieve a list of `FileInfo` objects\n* `-a`: Include all files (including those starting with a `.`)\n* `-f`: Do not sort the list\n* `-dirs`: Include directories (excluded by default)\n* `-links`: Include symbolic links (excluded by default)\n* `-R`: List the remote directory recursively\n\nIn addition, filename filtering is provided in the same manner as the `inbound-channel-adapter`.\n\nThe message payload resulting from an `ls` operation is a list of file names or a list of `FileInfo` objects (depending on whether you use the `-1` switch).\nThese objects provide information such as modified time, permissions, and others.\n\nThe remote directory that the `ls` command acted on is provided in the `file_remoteDirectory` header.\n\nWhen using the recursive option (`-R`), the `fileName` includes any subdirectory elements and represents the relative path to the file (relative to the remote directory).\nIf you use the `-dirs` option, each recursive directory is also returned as an element in the list.\nIn this case, we recommend that you not use the `-1` option, because you would not be able to distinguish files from directories, which you can do when you use `FileInfo` objects.\n\n[[using-nlst-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Using the `ls` Command", "heading_level": 3, "file_order": 266, "section_index": 12, "content_hash": "d25069f57b86c2b8466a0e22ccf3348be3f1c73a4e6b6ee9038798a6e88e527d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:27fb56c8e826ac148803d7a31dd98c544455e5030078de65ce176daa3194372f", "content": "`nlst` lists remote file names and supports only one option:\n\n* `-f`: Do not sort the list\n\nThe message payload resulting from an `nlst` operation is a list of file names.\n\nThe `file_remoteDirectory` header holds the remote directory on which the `nlst` command acted.\n\n[[using-the-get-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Using `nlst` Command", "heading_level": 3, "file_order": 266, "section_index": 13, "content_hash": "27fb56c8e826ac148803d7a31dd98c544455e5030078de65ce176daa3194372f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:14a47cd5563dfa08ad0f64df3aa35bf2919a10c7133b692d615eb19fc4752204", "content": "`get` retrieves a remote file and supports the following options:\n\n* `-P`: Preserve the timestamp of the remote file.\n* `-stream`: Retrieve the remote file as a stream.\n* `-D`: Delete the remote file after successful transfer.\nThe remote file is not deleted if the transfer is ignored, because the `FileExistsMode` is `IGNORE` and the local file already exists.\n\nThe `file_remoteDirectory` header holds the remote directory, and the `file_remoteFile` header holds the filename.\n\nThe message payload resulting from a `get` operation is a `File` object representing the retrieved file.\nIf you use the `-stream` option, the payload is an `InputStream` rather than a `File`.\nFor text files, a common use case is to combine this operation with a xref:file/splitter.adoc[file splitter] or a xref:transformer.adoc#stream-transformer[stream transformer].\nWhen consuming remote files as streams, you are responsible for closing the `Session` after the stream is consumed.\nFor convenience, the `Session` is provided in the `closeableResource` header, and `IntegrationMessageHeaderAccessor` offers convenience method:\n\n[source, java]\n----\nCloseable closeable = new IntegrationMessageHeaderAccessor(message).getCloseableResource();\nif (closeable != null) {\n closeable.close();\n}\n----\n\nFramework components, such as the xref:file/splitter.adoc[File Splitter] and xref:transformer.adoc#stream-transformer[Stream Transformer], automatically close the session after the data is transferred.\n\nThe following example shows how to consume a file as a stream:\n\n[source, xml]\n----\n<int-smb:outbound-gateway session-factory=\"smbSessionFactory\"\n request-channel=\"inboundGetStream\"\n command=\"get\"\n command-options=\"-stream\"\n expression=\"payload\"\n remote-directory=\"smbTarget\"\n reply-channel=\"stream\" />\n\n<int-file:splitter input-channel=\"stream\" output-channel=\"lines\" />\n----\n\nNOTE: If you consume the input stream in a custom component, you must close the `Session`.\nYou can either do that in your custom code or route a copy of the message to a `service-activator` and use SpEL, as the following example shows:\n\n[source, xml]\n----\n<int:service-activator input-channel=\"closeSession\"\n expression=\"headers['closeableResource'].close()\" />\n----\n\n[[using-the-mget-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Using the `get` Command", "heading_level": 3, "file_order": 266, "section_index": 14, "content_hash": "14a47cd5563dfa08ad0f64df3aa35bf2919a10c7133b692d615eb19fc4752204", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:791ea807436fcf71ec673507ebeae19738c3b4e0475d66e72cd01f6b7d90b7d5", "content": "`mget` retrieves multiple remote files based on a pattern and supports the following options:\n\n* `-P`: Preserve the timestamps of the remote files.\n\n* `-R`: Retrieve the entire directory tree recursively.\n\n* `-x`: Throw an exception if no files match the pattern (otherwise, an empty list is returned).\n\n* `-D`: Delete each remote file after successful transfer.\nIf the transfer is ignored, the remote file is not deleted, because the `FileExistsMode` is `IGNORE` and the local file already exists.\n\nThe message payload resulting from an `mget` operation is a `List<File>` object (that is, a `List` of `File` objects, each representing a retrieved file).\n\nIMPORTANT: If the `FileExistsMode` is `IGNORE`, the payload of the output message no longer contains files not fetched due to the file already existing.\nPreviously, the array contained all files, including those that already existed.\n\nThe expression you use determines the remote path should produce a result that ends with `\\*` for example `myfiles/*` fetches the complete tree under `myfiles`.\n\nYou can use a recursive `MGET`, combined with the `FileExistsMode.REPLACE_IF_MODIFIED` mode, to periodically synchronize an entire remote directory tree locally.\nThis mode sets the local file's last modified timestamp to the remote file's timestamp, regardless of the `-P` (preserve timestamp) option.\n\n.Notes for when using recursion (`-R`)\n[IMPORTANT]\n=====\n\nThe pattern is ignored and `*` is assumed.\nBy default, the entire remote tree is retrieved.\nHowever, you can filter files in the tree by providing a `FileListFilter`.\nYou can also filter directories in the tree this way.\nA `FileListFilter` can be provided by reference or by `filename-pattern` or `filename-regex` attributes.\nFor example, `filename-regex=\"(subDir|.*1.txt)\"` retrieves all files ending with `1.txt` in the remote directory and the subdirectory `subDir`.\nHowever, we describe an alternative available after this note.\n\nIf you filter a subdirectory, no additional traversal of that subdirectory is performed.\n\nThe `-dirs` option is not allowed (the recursive `mget` uses the recursive `ls` to get the directory tree and the directories themselves cannot be included in the list).\n\nTypically, you would use the `#remoteDirectory` variable in the `local-directory-expression` so that the remote directory structure is retained locally.\n=====\n\nThe persistent file list filters now have a boolean property `forRecursion`.\nSetting this property to `true`, also sets `alwaysAcceptDirectories`, which means that the recursive operation on the outbound gateways (`ls` and `mget`) will now always traverse the full directory tree each time.\nThis is to solve a problem where changes deep in the directory tree were not detected.\nIn addition, `forRecursion=true` causes the full path to files to be used as the metadata store keys; this solves a problem where the filter did not work properly if a file with the same name appears multiple times in different directories.\nIMPORTANT: This means that existing keys in a persistent metadata store will not be found for files beneath the top level directory.\nFor this reason, the property is `false` by default; this may change in a future release.\n\nYou can configure the `SmbSimplePatternFileListFilter` and `SmbRegexPatternFileListFilter` to always pass directories by setting the `alwaysAcceptDirectorties` to `true`.\nDoing so allows recursion for a simple pattern, as the following examples show:\n\n[source, xml]\n----\n<bean id=\"starDotTxtFilter\"\n class=\"org.springframework.integration.smb.filters.SmbSimplePatternFileListFilter\">\n <constructor-arg value=\"*.txt\" />\n <property name=\"alwaysAcceptDirectories\" value=\"true\" />\n</bean>\n\n<bean id=\"dotStarDotTxtFilter\"\n class=\"org.springframework.integration.smb.filters.SmbRegexPatternFileListFilter\">\n <constructor-arg value=\"^.*\\.txt$\" />\n <property name=\"alwaysAcceptDirectories\" value=\"true\" />\n</bean>\n----\n\nYou can provide one of these filters by using the `filter` property on the gateway.\n\nSee also xref:smb.adoc#smb-partial[Outbound Gateway Partial Success (`mget` and `mput`)].\n\n[[smb-put-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Using the `mget` Command", "heading_level": 3, "file_order": 266, "section_index": 15, "content_hash": "791ea807436fcf71ec673507ebeae19738c3b4e0475d66e72cd01f6b7d90b7d5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:0c6d33b5df5f5b5a1432defc285e06a9b8c2eff33e51b480e994ae24a1314532", "content": "`put` sends a file to the remote server.\nThe payload of the message can be a `java.io.File`, a `byte[]`, or a `String`.\nA `remote-filename-generator` (or expression) is used to name the remote file.\nOther available attributes include `remote-directory`, `temporary-remote-directory` and their `*-expression` equivalents: `use-temporary-file-name` and `auto-create-directory`.\nSee the https://github.com/spring-projects/spring-integration/tree/main/spring-integration-core/src/main/resources/org/springframework/integration/config[schema documentation] for more information.\n\nThe message payload resulting from a `put` operation is a `String` that contains the full path of the file on the server after transfer.\n\n[[using-the-mput-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Using the `put` Command", "heading_level": 3, "file_order": 266, "section_index": 16, "content_hash": "0c6d33b5df5f5b5a1432defc285e06a9b8c2eff33e51b480e994ae24a1314532", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:2593748a9f664f426737597f029e350b2f9b5121a9614a0b4976c1d372c9ce0b", "content": "`mput` sends multiple files to the server and supports the following option:\n\n* `-R`: Recursive -- send all files (possibly filtered) in the directory and subdirectories\n\nThe message payload must be a `java.io.File` (or `String`) that represents a local directory.\nA collection of `File` or `String` is also supported.\n\nThe same attributes as the xref:smb.adoc#smb-put-command[`put` command] are supported.\nIn addition, you can filter files in the local directory with one of `mput-pattern`, `mput-regex`, `mput-filter`, or `mput-filter-expression`.\nThe filter works with recursion, as long as the subdirectories themselves pass the filter.\nSubdirectories that do not pass the filter are not recursed.\n\nThe message payload resulting from an `mput` operation is a `List<String>` object (that is, a `List` of remote file paths resulting from the transfer).\n\nSee also xref:smb.adoc#smb-partial[Outbound Gateway Partial Success (`mget` and `mput`)].\n\n[[using-the-rm-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Using the `mput` Command", "heading_level": 3, "file_order": 266, "section_index": 17, "content_hash": "2593748a9f664f426737597f029e350b2f9b5121a9614a0b4976c1d372c9ce0b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:486b4538a50710004ad8ad4b174fee76eaeae92d20532266116883067c78071c", "content": "The `rm` command has no options.\n\nIf the remove operation was successful, the resulting message payload is `Boolean.TRUE`.\nOtherwise, the message payload is `Boolean.FALSE`.\nThe `file_remoteDirectory` header holds the remote directory, and the `file_remoteFile` header holds the file name.\n\n[[using-the-mv-command]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Using the `rm` Command", "heading_level": 3, "file_order": 266, "section_index": 18, "content_hash": "486b4538a50710004ad8ad4b174fee76eaeae92d20532266116883067c78071c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:c2c748f4833f9094b140e72aad30d6be44253f746757c19621e4e3c5826322ec", "content": "The `mv` command has no options.\n\nThe `expression` attribute defines the \"`from`\" path, and the `rename-expression` attribute defines the \"`to`\" path.\nBy default, the `rename-expression` is `headers['file_renameTo']`.\nThis expression must not evaluate to null or an empty `String`.\nIf necessary, any remote directories needed are created.\nThe payload of the result message is `Boolean.TRUE`.\nThe `file_remoteDirectory` header holds the original remote directory, and the `file_remoteFile` header holds the filename.\nThe `file_renameTo` header holds the new path.\n\nThe `remoteDirectoryExpression` can be used in the `mv` command for convenience.\nIf the \"`from`\" file is not a full file path, the result of `remoteDirectoryExpression` is used as the remote directory.\nThe same applies for the \"`to`\" file, for example, if the task is just to rename a remote file in some directory.\n\n[[additional-command-information]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Using the `mv` Command", "heading_level": 3, "file_order": 266, "section_index": 19, "content_hash": "c2c748f4833f9094b140e72aad30d6be44253f746757c19621e4e3c5826322ec", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:d21bea53261f814c584b0904b663e68141838d02c24f13091c5f3974e18f5811", "content": "The `get` and `mget` commands support the `local-filename-generator-expression` attribute.\nIt defines a SpEL expression to generate the names of local files during the transfer.\nThe root object of the evaluation context is the request message.\nThe `remoteFileName` variable is also available.\nIt is particularly useful for `mget` (for example: `local-filename-generator-expression=\"#remoteFileName.toUpperCase() + headers.foo\"`).\n\nThe `get` and `mget` commands support the `local-directory-expression` attribute.\nIt defines a SpEL expression to generate the names of local directories during the transfer.\nThe root object of the evaluation context is the request message.\nThe `remoteDirectory` variable is also available.\nIt is particularly useful for `mget` (for example: `local-directory-expression=\"'/tmp/local/' + #remoteDirectory.toUpperCase() + headers.myheader\"`).\nThis attribute is mutually exclusive with the `local-directory` attribute.\n\nFor all commands, the 'expression' property of the gateway holds the path on which the command acts.\nFor the `mget` command, the expression might evaluate to `\\*`, meaning to retrieve all files, `somedirectory/\\*`, and other values that end with `*`.\n\nThe following example shows a gateway configured for an `ls` command:\n\n[source,xml]\n----\n<int-smb:outbound-gateway id=\"gateway1\"\n session-factory=\"smbSessionFactory\"\n request-channel=\"inbound1\"\n command=\"ls\"\n command-options=\"-1\"\n expression=\"payload\"\n reply-channel=\"toSplitter\"/>\n----\n\nThe payload of the message sent to the `toSplitter` channel is a list of `String` objects, each of which contains the name of a file.\nIf you omitted `command-options=\"-1\"`, the payload would be a list of `FileInfo` objects.\nYou can provide options as a space-delimited list, for example, `command-options=\"-1 -dirs -links\"`.\n\nThe `GET`, `MGET`, `PUT`, and `MPUT` commands support a `FileExistsMode` property (`mode` when using the namespace support).\nThis affects the behavior when the local file exists (`GET` and `MGET`) or the remote file exists (`PUT` and `MPUT`).\nThe supported modes are `REPLACE`, `APPEND`, `FAIL`, and `IGNORE`.\nFor backwards compatibility, the default mode for `PUT` and `MPUT` operations is `REPLACE`.\nFor `GET` and `MGET` operations, the default is `FAIL`.\n\n[[configuring-with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Additional Command Information", "heading_level": 3, "file_order": 266, "section_index": 20, "content_hash": "d21bea53261f814c584b0904b663e68141838d02c24f13091c5f3974e18f5811", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:ed0ad2c67ad6857745e03a820ac0d00f66c654d9d6d65a49a2ad9ea802472b62", "content": "The following Spring Boot application shows an example of how to configure the outbound gateway with Java configuration:\n\n[source, java]\n----\n@SpringBootApplication\npublic class SmbJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(SmbJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public SmbSessionFactory smbSessionFactory() {\n SmbSessionFactory smbSession = new SmbSessionFactory();\n smbSession.setHost(\"myHost\");\n smbSession.setPort(445);\n smbSession.setDomain(\"myDomain\");\n smbSession.setUsername(\"myUser\");\n smbSession.setPassword(\"myPassword\");\n smbSession.setShareAndDir(\"myShareAndDir\");\n smbSession.setSmbMinVersion(DialectVersion.SMB210);\n smbSession.setSmbMaxVersion(DialectVersion.SMB311);\n return smbSession;\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"smbChannel\")\n public MessageHandler handler() {\n SmbOutboundGateway smbOutboundGateway =\n new SmbOutboundGateway(smbSessionFactory(), \"'my_remote_dir/'\");\n smbOutboundGateway.setOutputChannelName(\"replyChannel\");\n return smbOutboundGateway;\n }\n\n}\n----\n\n[[outbound-gateway-java-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Configuring with Java Configuration", "heading_level": 3, "file_order": 266, "section_index": 21, "content_hash": "ed0ad2c67ad6857745e03a820ac0d00f66c654d9d6d65a49a2ad9ea802472b62", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:d27506733f5dda154b22bbd53d48305d202e9fcb02b9e605278701aef1ab3348", "content": "The following Spring Boot application shows an example of how to configure the outbound gateway with the Java DSL:\n\n[source, java]\n----\n@SpringBootApplication\npublic class SmbJavaApplication {\n\n public static void main(String[] args) {\n new SpringApplicationBuilder(SmbJavaApplication.class)\n .web(false)\n .run(args);\n }\n\n @Bean\n public SmbSessionFactory smbSessionFactory() {\n SmbSessionFactory smbSession = new SmbSessionFactory();\n smbSession.setHost(\"myHost\");\n smbSession.setPort(445);\n smbSession.setDomain(\"myDomain\");\n smbSession.setUsername(\"myUser\");\n smbSession.setPassword(\"myPassword\");\n smbSession.setShareAndDir(\"myShareAndDir\");\n smbSession.setSmbMinVersion(DialectVersion.SMB210);\n smbSession.setSmbMaxVersion(DialectVersion.SMB311);\n return smbSession;\n }\n\n @Bean\n public SmbOutboundGatewaySpec smbOutboundGateway() {\n return Smb.outboundGateway(smbSessionFactory(),\n AbstractRemoteFileOutboundGateway.Command.MGET, \"payload\")\n .options(AbstractRemoteFileOutboundGateway.Option.RECURSIVE)\n .regexFileNameFilter(\"(subSmbSource|.*.txt)\")\n .localDirectoryExpression(\"'localDirectory/' + #remoteDirectory\")\n .localFilenameExpression(\"#remoteFileName.replaceFirst('smbSource', 'localTarget')\");\n }\n\n @Bean\n public IntegrationFlow smbFlow(AbstractRemoteFileOutboundGateway<SmbFile> smbOutboundGateway) {\n return f -> f\n .handle(smbOutboundGateway)\n .channel(c -> c.queue(\"remoteFileOutputChannel\"));\n }\n\n}\n----\n\n[[smb-partial]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Configuring with the Java DSL", "heading_level": 3, "file_order": 266, "section_index": 22, "content_hash": "d27506733f5dda154b22bbd53d48305d202e9fcb02b9e605278701aef1ab3348", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:a1aad886bd8de54ee7feb5cdba0d891792b7a83d81724aae92366bcd9ff597ed", "content": "When performing operations on multiple files (by using `mget` and `mput`) an exception can occur some time after one or more files have been transferred.\nIn this case a `PartialSuccessException` is thrown.\nAs well as the usual `MessagingException` properties (`failedMessage` and `cause`), this exception has two additional properties:\n\n* `partialResults`: The successful transfer results.\n* `derivedInput`: The list of files generated from the request message (such as local files to transfer for an `mput`).\n\nThese attributes let you determine which files were successfully transferred and which were not.\n\nIn the case of a recursive `mput`, the `PartialSuccessException` may have nested `PartialSuccessException` instances.\n\nConsider the following directory structure:\n\n[source]\n----\nroot/\n|- file1.txt\n|- subdir/\n | - file2.txt\n | - file3.txt\n|- zoo.txt\n----\n\nIf the exception occurs on `file3.txt`, the `PartialSuccessException` thrown by the gateway has `derivedInput` of `file1.txt`, `subdir`, and `zoo.txt` and `partialResults` of `file1.txt`.\nIts `cause` is another `PartialSuccessException` with `derivedInput` of `file2.txt` and `file3.txt` and `partialResults` of `file2.txt`.\n\n[[smb-remote-file-info]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Outbound Gateway Partial Success (`mget` and `mput`)", "heading_level": 3, "file_order": 266, "section_index": 23, "content_hash": "a1aad886bd8de54ee7feb5cdba0d891792b7a83d81724aae92366bcd9ff597ed", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:b236f398e88b46e53b14e8296c60a2ba22c46ca0759e0161be3bebac34e30571", "content": "The `SmbStreamingMessageSource` (xref:smb.adoc#smb-streaming-inbound[SMB Streaming Inbound Channel Adapter]), `SmbInboundFileSynchronizingMessageSource` (xref:smb.adoc#smb-inbound[SMB Inbound Channel Adapter,]) and \"read\"-commands of the `SmbOutboundGateway` (xref:smb.adoc#smb-outbound-gateway[SMB Outbound Gateway]) provide additional headers in the message to produce with information about the remote file:\n\n* `FileHeaders.REMOTE_HOST_PORT` - the host:port pair the remote session has been connected to during file transfer operation;\n* `FileHeaders.REMOTE_DIRECTORY` - the remote directory the operation has been performed;\n* `FileHeaders.REMOTE_FILE` - the remote file name; applicable only for single file operations.\n\nSince the `SmbInboundFileSynchronizingMessageSource` doesn't produce messages against remote files, but using a local copy, the `AbstractInboundFileSynchronizer` stores an information about a remote file in the `MetadataStore` (which can be configured externally) in the URI style (`protocol://host:port/remoteDirectory#remoteFileName`) during synchronization operation.\nThis metadata is retrieved by the `SmbInboundFileSynchronizingMessageSource` when a local file is polled.\nWhen a local file is deleted, it is recommended to remove its metadata entry.\nThe `AbstractInboundFileSynchronizer` provides a `removeRemoteFileMetadata()` callback for this purpose.\nIn addition, there is a `setMetadataStorePrefix()` to be used in the metadata keys.\nIt is recommended to have this prefix be different from the one used in the `MetadataStore`-based `FileListFilter` implementations, when the same `MetadataStore` instance is shared between these components, to avoid entry overriding because both filter and `AbstractInboundFileSynchronizer` use the same local file name for the metadata entry key.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/smb.adoc", "title": "smb", "heading": "Remote File Information", "heading_level": 2, "file_order": 266, "section_index": 24, "content_hash": "b236f398e88b46e53b14e8296c60a2ba22c46ca0759e0161be3bebac34e30571", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/smb.adoc"}}
{"id": "sha256:b689f6323b70d0f280d31bd4d9407b314c28fada3bc1f8b3374930973b1406aa", "content": "[[spel]]\n\nYou can configure many Spring Integration components by using expressions written in the https://docs.spring.io/spring-framework/reference/core/expressions.html[Spring Expression Language].\n\nIn most cases, the `#root` object is the `Message`, which has two properties (`headers` and `payload`) that allow such expressions as `payload`, `payload.thing`, `headers['my.header']`, and so on.\n\nIn some cases, additional variables are provided.\nFor example, `<int-http:inbound-gateway/>` provides `#requestParams` (parameters from the HTTP request) and `#pathVariables` (values from path placeholders in the URI).\n\nFor all SpEL expressions, a `BeanResolver` is available to enable references to any bean in the application context, for example, `@myBean.foo(payload)`.\nIn addition, two `PropertyAccessors` are available.\nA `MapAccessor` enables accessing values in a `Map` by using a key and a `ReflectivePropertyAccessor`, which allows access to fields and JavaBean compliant properties (by using getters and setters).\nThis is how you can access the `Message` headers and payload properties.\n\n[[spel-customization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/spel.adoc", "title": "spel", "heading": "spel", "heading_level": 1, "file_order": 267, "section_index": 0, "content_hash": "b689f6323b70d0f280d31bd4d9407b314c28fada3bc1f8b3374930973b1406aa", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/spel.adoc"}}
{"id": "sha256:ea799359168690f68ac64a52c802817fae0e37504eb6cd0d302f53e146aec7f0", "content": "Starting with Spring Integration 3.0, you can add additional `PropertyAccessor` instances to the SpEL evaluation contexts used by the framework.\nThe framework provides the (read-only) `JacksonPropertyAccessor`, which you can use to access fields from a `JsonNode` or JSON in a `String`.\nYou can also create your own `PropertyAccessor` if you have specific needs.\n\nThe `JacksonIndexAccessor` implementation is provided that knows how to read indexes from JSON arrays, using Jackson's `ArrayNode` API.\nSupports indexes supplied as an integer literal, for example, `myJsonArray[1]`.\nAlso supports negative indexes, for example, `myJsonArray[-1]` which equates to `myJsonArray[myJsonArray.length - 1]`.\nFurthermore, `null` is returned for any index that is out of bounds (see `ArrayNode.get(int)` for details).\n\nIn addition, you can add custom functions.\nCustom functions are `static` methods declared on a class.\nFunctions and property accessors are available in any SpEL expression used throughout the framework.\n\nThe following configuration shows how to directly configure the `IntegrationEvaluationContextFactoryBean` with custom property accessors and functions:\n\n[source,xml]\n----\n<bean id=\"integrationEvaluationContext\"\n class=\"org.springframework.integration.config.IntegrationEvaluationContextFactoryBean\">\n\t<property name=\"propertyAccessors\">\n <util:map>\n <entry key=\"things\">\n <bean class=\"things.MyCustomPropertyAccessor\"/>\n </entry>\n </util:map>\n\t</property>\n\t<property name=\"functions\">\n <map>\n <entry key=\"barcalc\" value=\"#{T(things.MyFunctions).getMethod('calc', T(things.MyThing))}\"/>\n </map>\n\t</property>\n</bean>\n----\n\nStarting with version 6.4, the `AbstractEvaluationContextFactoryBean` supports an injection of `IndexAccessor` instances.\nSee `AbstractEvaluationContextFactoryBean` method Javadocs for more information.\n\nFor convenience, Spring Integration provides namespace support for both property accessors and functions, as described in the following sections.\nThe framework automatically configures the factory bean on your behalf.\n\nThis factory bean definition overrides the default `integrationEvaluationContext` bean definition.\nIt adds the custom accessor and one custom function to the list, which also includes the standard accessors xref:spel.adoc[mentioned earlier].\n\nNote that custom functions are static methods.\nIn the preceding example, the custom function is a static method called `calc` on a class called `MyFunctions` and takes a single parameter of type `MyThing`.\n\nSuppose you have a `Message` with a payload that has a type of `MyThing`.\nFurther, suppose that you need to perform some action to create an object called `MyObject` from `MyThing` and then invoke a custom function called `calc` on that object.\n\nThe standard property accessors do not know how to get a `MyObject` from a `MyThing`, so you could write and configure a custom property accessor to do so.\nAs a result, your final expression might be `\"#barcalc(payload.myObject)\"`.\n\nThe factory bean has another property (`typeLocator`), which lets you customize the `TypeLocator` used during SpEL evaluation.\nYou might need to do so running in some environments that use a non-standard `ClassLoader`.\nIn the following example, SpEL expressions always use the bean factory's class loader:\n\n[source,xml]\n----\n<bean id=\"integrationEvaluationContext\"\n class=\"org.springframework.integration.config.IntegrationEvaluationContextFactoryBean\">\n\t<property name=\"typeLocator\">\n <bean class=\"org.springframework.expression.spel.support.StandardTypeLocator\">\n <constructor-arg value=\"#{beanFactory.beanClassLoader}\"/>\n </bean>\n\t</property>\n</bean>\n----\n\n[[spel-functions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/spel.adoc", "title": "spel", "heading": "SpEL Evaluation Context Customization", "heading_level": 2, "file_order": 267, "section_index": 1, "content_hash": "ea799359168690f68ac64a52c802817fae0e37504eb6cd0d302f53e146aec7f0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/spel.adoc"}}
{"id": "sha256:037c2cddb29db86e665cd3f693746b12430daabff7c0fe40ea7cb83f5652091c", "content": "Spring Integration provides namespace support to let you create SpEL custom functions.\nYou can specify `<spel-function/>` components to provide https://docs.spring.io/spring-framework/reference/core/expressions/language-ref/functions.html[custom SpEL functions] to the `EvaluationContext` used throughout the framework.\nInstead of configuring the factory bean shown earlier, you can add one or more of these components, and the framework automatically adds them to the default `integrationEvaluationContext` factory bean.\n\nFor example, suppose you have a useful static method to evaluate XPath.\nThe following example shows how you can create a custom function to use that method:\n\n[source,xml]\n----\n<int:spel-function id=\"xpath\"\n\tclass=\"com.something.test.XPathUtils\" method=\"evaluate(java.lang.String, java.lang.Object)\"/>\n\n<int:transformer input-channel=\"in\" output-channel=\"out\"\n expression=\"#xpath('//things/@mythings', payload)\" />\n----\n\nGiven the preceding example:\n\n* The default `IntegrationEvaluationContextFactoryBean` bean with an ID of `integrationEvaluationContext` is registered with the application context.\n\n* The `<spel-function/>` is parsed and added to the `functions` `Map` of `integrationEvaluationContext` as a map entry with its `id` as the key and the static `Method` as the value.\n\n* The `integrationEvaluationContext` factory bean creates a new `StandardEvaluationContext` instance, and it is configured with the default `PropertyAccessor` instances, a `BeanResolver`, and the custom functions.\n\n* That `EvaluationContext` instance is injected into the `ExpressionEvaluatingTransformer` bean.\n\nTo provide a SpEL Function by using Java configuration, you can declare a `SpelFunctionFactoryBean` bean for each function.\nThe following example shows how to create a custom function:\n\n[source,java]\n----\n@Bean\npublic SpelFunctionFactoryBean xpath() {\n return new SpelFunctionFactoryBean(XPathUtils.class, \"evaluate\");\n}\n----\n\nNOTE: SpEL functions declared in a parent context are also made available in any child contexts.\nEach context has its own instance of the `integrationEvaluationContext` factory bean, because each needs a different `BeanResolver`, but the function declarations are inherited and can be overridden by declaring a SpEL function with the same name.\n\n[[built-in-spel-functions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/spel.adoc", "title": "spel", "heading": "SpEL Functions", "heading_level": 2, "file_order": 267, "section_index": 2, "content_hash": "037c2cddb29db86e665cd3f693746b12430daabff7c0fe40ea7cb83f5652091c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/spel.adoc"}}
{"id": "sha256:3a696dabefd0490c29dd4f99c9a3558afeac048de107dee28de51315d038023c", "content": "Spring Integration provides the following standard functions, which are registered with the application context automatically on startup:\n\n* `#jsonPath`: Evaluates a 'jsonPath' on a specified object.\nThis function invokes `JsonPathUtils.evaluate(...)`, which delegates to the https://github.com/json-path/JsonPath[Jayway JsonPath library].\nThe following listing shows some usage examples:\n+\n[source,xml]\n----\n<transformer expression=\"#jsonPath(payload, '$.store.book[0].author')\"/>\n\n<filter expression=\"#jsonPath(payload,'$..book[2].isbn') matches '\\d-\\d{3}-\\d{5}-\\d'\"/>\n\n<splitter expression=\"#jsonPath(payload, '$.store.book')\"/>\n\n<router expression=\"#jsonPath(payload, headers.jsonPath)\">\n\t<mapping channel=\"output1\" value=\"reference\"/>\n\t<mapping channel=\"output2\" value=\"fiction\"/>\n</router>\n----\n+\n`#jsonPath` also supports a third (optional) parameter: an array of https://github.com/json-path/JsonPath#filter-predicates[`com.jayway.jsonpath.Filter`], which can be provided by a reference to a bean or bean method (for example).\n+\nNOTE: Using this function requires the Jayway JsonPath library (`json-path.jar`) to be on the classpath.\nOtherwise, the `#jsonPath` SpEL function is not registered.\n+\nFor more information regarding JSON, see 'JSON Transformers' in xref:transformer.adoc[Transformer].\n\n* `#xpath`: To evaluate an xpath on some provided object.\nFor more information regarding XML and XPath, see xref:xml.adoc[XML Support - Dealing with XML Payloads].\n\n[[spel-property-accessors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/spel.adoc", "title": "spel", "heading": "Built-in SpEL Functions", "heading_level": 3, "file_order": 267, "section_index": 3, "content_hash": "3a696dabefd0490c29dd4f99c9a3558afeac048de107dee28de51315d038023c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/spel.adoc"}}
{"id": "sha256:66c9c20f952313d7489dd667f68e23eea9c4af8cef2a258b5c00549eb20206a0", "content": "Spring Integration provides namespace support to let you create SpEL custom https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/expression/PropertyAccessor.html[`PropertyAccessor`] implementations.\nYou can use the `<spel-property-accessors/>` component to provide a list of custom `PropertyAccessor` instances to the `EvaluationContext` used throughout the framework.\nInstead of configuring the factory bean shown earlier, you can add this component, and the framework automatically adds the accessors to the default `integrationEvaluationContext` factory bean.\nAlso, starting with version 6.4, a dedicated `<index-accessors>` sub-element is provided to configure `IndexAccessor` beans similar way.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<int:spel-property-accessors>\n <index-accessors>\n <beans:bean id=\"jsonIndex\" class=\"org.springframework.integration.json.JacksonIndexAccessor\"/>\n </index-accessors>\n\t<bean id=\"jsonPA\" class=\"org.springframework.integration.json.JacksonPropertyAccessor\"/>\n\t<ref bean=\"fooPropertyAccessor\"/>\n</int:spel-property-accessors>\n----\n\nIn the preceding example, two custom `PropertyAccessor` instances are injected into the `EvaluationContext` (in the order in which they are declared).\n\nTo provide `PropertyAccessor` instances by using Java Configuration, you should declare a `SpelPropertyAccessorRegistrar` bean with a name of `spelPropertyAccessorRegistrar` (dictated by the `IntegrationContextUtils.SPEL_PROPERTY_ACCESSOR_REGISTRAR_BEAN_NAME` constant).\nThe following example shows how to configure two custom `PropertyAccessor` (and `IndexAccessor` starting with version 6.4) instances with Java:\n\n[source,java]\n----\n@Bean\npublic SpelPropertyAccessorRegistrar spelPropertyAccessorRegistrar() {\n return new SpelPropertyAccessorRegistrar(new JacksonPropertyAccessor())\n .add(fooPropertyAccessor())\n .add(new JacksonIndexAccessor());\n}\n----\n\n[NOTE]\n====\nCustom `PropertyAccessor` instances declared in a parent context are also made available in any child contexts.\nThey are placed at the end of a result list (but before the default `org.springframework.context.expression.MapAccessor` and `o.s.expression.spel.support.ReflectivePropertyAccessor`).\nIf you declare a `PropertyAccessor` with the same bean ID in a child context, it overrides the parent accessor.\nBeans declared within a `<spel-property-accessors/>` must have an 'id' attribute.\nThe final order of usage is as follows:\n\n* The accessors in the current context, in the order in which they are declared\n* Any accessors from parent contexts, in order\n* The `MapAccessor`\n* The `ReflectivePropertyAccessor`\n====", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/spel.adoc", "title": "spel", "heading": "Property Accessors", "heading_level": 2, "file_order": 267, "section_index": 4, "content_hash": "66c9c20f952313d7489dd667f68e23eea9c4af8cef2a258b5c00549eb20206a0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/spel.adoc"}}
{"id": "sha256:e3c7e517ca2f21a8275303b7d17cbcccd23055762d3ac0addaaa729a06651639", "content": "[[splitter]]\n\nThe splitter is a component whose role is to partition a message into several parts and send the resulting messages to be processed independently.\nVery often, they are upstream producers in a pipeline that includes an aggregator.\n\n[[programming-model]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/splitter.adoc", "title": "splitter", "heading": "splitter", "heading_level": 1, "file_order": 268, "section_index": 0, "content_hash": "e3c7e517ca2f21a8275303b7d17cbcccd23055762d3ac0addaaa729a06651639", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/splitter.adoc"}}
{"id": "sha256:e53b1d87a8ce594b86c2c09ba402e8a1611a883e8b5004c9bab0cfb18e59b0e0", "content": "The API for performing splitting consists of one base class, `AbstractMessageSplitter`.\nIt is a `MessageHandler` implementation that encapsulates features common to splitters, such as filling in the appropriate message headers (`CORRELATION_ID`, `SEQUENCE_SIZE`, and `SEQUENCE_NUMBER`) on the messages that are produced.\nThis filling enables tracking down the messages and the results of their processing (in a typical scenario, these headers get copied to the messages that are produced by the various transforming endpoints).\nThe values can then be used, for example, by a https://www.enterpriseintegrationpatterns.com/DistributionAggregate.html[composed message processor].\n\nThe following example shows an excerpt from `AbstractMessageSplitter`:\n\n[source,java]\n----\npublic abstract class AbstractMessageSplitter\n extends AbstractReplyProducingMessageConsumer {\n ...\n protected abstract Object splitMessage(Message<?> message);\n\n}\n----\n\nTo implement a specific splitter in an application, you can extend `AbstractMessageSplitter` and implement the `splitMessage` method, which contains logic for splitting the messages.\nThe return value can be one of the following:\n\n* A `Collection` or an array of messages or an `Iterable` (or `Iterator`) that iterates over messages.\nIn this case, the messages are sent as messages (after the `CORRELATION_ID`, `SEQUENCE_SIZE` and `SEQUENCE_NUMBER` are populated).\nUsing this approach gives you more control -- for example, to populate custom message headers as part of the splitting process.\n\n* A `Collection` or an array of non-message objects or an `Iterable` (or `Iterator`) that iterates over non-message objects.\nIt works like the prior case, except that each collection element is used as a message payload.\nUsing this approach lets you focus on the domain objects without having to consider the messaging system and produces code that is easier to test.\n\n* a `Message` or non-message object (but not a collection or an array).\nIt works like the previous cases, except that a single message is sent out.\n\nIn Spring Integration, any POJO can implement the splitting algorithm, provided that it defines a method that accepts a single argument and has a return value.\nIn this case, the return value of the method is interpreted as described earlier.\nThe input argument might either be a `Message` or a simple POJO.\nIn the latter case, the splitter receives the payload of the incoming message.\nWe recommend this approach because it decouples the code from the Spring Integration API and is typically easier to test.\n\n[[iterators]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/splitter.adoc", "title": "splitter", "heading": "Programming Model", "heading_level": 2, "file_order": 268, "section_index": 1, "content_hash": "e53b1d87a8ce594b86c2c09ba402e8a1611a883e8b5004c9bab0cfb18e59b0e0", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/splitter.adoc"}}
{"id": "sha256:7e0930317efcc822cbbef9006c74173ef8ba6f5fbdbf0d63f231b45b4f1beccb", "content": "Starting with version 4.1, the `AbstractMessageSplitter` supports the `Iterator` type for the `value` to split.\nNote, in the case of an `Iterator` (or `Iterable`), we don't have access to the number of underlying items and the `SEQUENCE_SIZE` header is set to `0`.\nThis means that the default `SequenceSizeReleaseStrategy` of an `<aggregator>` won't work and the group for the `CORRELATION_ID` from the `splitter` won't be released; it will remain as `incomplete`.\nIn this case you should use an appropriate custom `ReleaseStrategy` or rely on `send-partial-result-on-expiry` together with `group-timeout` or a `MessageGroupStoreReaper`.\n\nStarting with version 5.0, the `AbstractMessageSplitter` provides `protected obtainSizeIfPossible()` methods to allow the determination of the size of the `Iterable` and `Iterator` objects if that is possible.\nFor example `XPathMessageSplitter` can determine the size of the underlying `NodeList` object.\nAnd starting with version 5.0.9, this method also properly returns a size of the `com.fasterxml.jackson.core.TreeNode`.\n\nAn `Iterator` object is useful to avoid the need for building an entire collection in the memory before splitting.\nFor example, when underlying items are populated from some external system (e.g. DataBase or FTP `MGET`) using iterations or streams.\n\n[[split-stream-and-flux]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/splitter.adoc", "title": "splitter", "heading": "Iterators", "heading_level": 3, "file_order": 268, "section_index": 2, "content_hash": "7e0930317efcc822cbbef9006c74173ef8ba6f5fbdbf0d63f231b45b4f1beccb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/splitter.adoc"}}
{"id": "sha256:f23e132f3bd98805232f5602c9e73860844a24bb787f182f926c818d4561c4f2", "content": "Starting with version 5.0, the `AbstractMessageSplitter` supports the Java `Stream` and Reactive Streams `Publisher` types for the `value` to split.\nIn this case, the target `Iterator` is built on their iteration functionality.\n\nIn addition, if the splitter's output channel is an instance of a `ReactiveStreamsSubscribableChannel`, the `AbstractMessageSplitter` produces a `Flux` result instead of an `Iterator`, and the output channel is subscribed to this `Flux` for back-pressure-based splitting on downstream flow demand.\n\nStarting with version 5.2, the splitter supports a `discardChannel` option for sending those request messages for which a split function has returned an empty container (collection, array, stream, `Flux` etc.).\nIn this case there is just no item to iterate for sending to the `outputChannel`.\nThe `null` splitting result remains as an end-of-flow indicator.\n\n[[configuring-a-splitter-with-java-groovy-and-kotlin-dsls]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/splitter.adoc", "title": "splitter", "heading": "Stream and Flux", "heading_level": 3, "file_order": 268, "section_index": 3, "content_hash": "f23e132f3bd98805232f5602c9e73860844a24bb787f182f926c818d4561c4f2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/splitter.adoc"}}
{"id": "sha256:1d36c5ddb997071489d200201b4cbb937e06ad709d6a4e2a331537acd72fdeb2", "content": "An example of simple splitter based on a `Message` and its iterable payload with DSL configuration:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return f -> f.split(Message.class, Message::getPayload);\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun someFlow() =\n integrationFlow {\n split<Message<*>> { it.payload }\n }\n----\n\nGroovy DSL::\n+\n[source, groovy, role=\"secondary\"]\n----\n@Bean\nsomeFlow() {\n integrationFlow {\n splitWith {\n expectedType Message<?>\n function { it.payload }\n }\n }\n}\n----\n======\n\nSee more information about the DSLs in the respective chapters:\n\n* xref:dsl.adoc#java-dsl[Java DSL]\n* xref:kotlin-dsl.adoc[Kotlin DSL]\n* xref:groovy-dsl.adoc[Groovy DSL]\n\n[[configuring-a-splitter-with-xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/splitter.adoc", "title": "splitter", "heading": "Configuring a Splitter with Java, Groovy and Kotlin DSLs", "heading_level": 2, "file_order": 268, "section_index": 4, "content_hash": "1d36c5ddb997071489d200201b4cbb937e06ad709d6a4e2a331537acd72fdeb2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/splitter.adoc"}}
{"id": "sha256:5f208811e2beff88a0ddb7baf95f0e0c3cfdc50a8cf8d710bd94783e8d11dd76", "content": "A splitter can be configured through XML as follows:\n\n[source,xml]\n----\n<int:channel id=\"inputChannel\"/>\n\n<int:splitter id=\"splitter\" <1>\n ref=\"splitterBean\" <2>\n method=\"split\" <3>\n input-channel=\"inputChannel\" <4>\n output-channel=\"outputChannel\" <5>\n discard-channel=\"discardChannel\" /> <6>\n\n<int:channel id=\"outputChannel\"/>\n\n<beans:bean id=\"splitterBean\" class=\"sample.PojoSplitter\"/>\n----\n<1> The ID of the splitter is optional.\n<2> A reference to a bean defined in the application context.\nThe bean must implement the splitting logic, as described in the earlier section.\nOptional.\nIf a reference to a bean is not provided, it is assumed that the payload of the message that arrived at the `input-channel` is an implementation of `java.util.Collection` and the default splitting logic is applied to the collection, incorporating each individual element into a message and sending it to the `output-channel`.\n<3> The method (defined on the bean) that implements the splitting logic.\nOptional.\n<4> The input channel of the splitter.\nRequired.\n<5> The channel to which the splitter sends the results of splitting the incoming message.\nOptional (because incoming messages can specify a reply channel themselves).\n<6> The channel to which the request message is sent in case of an empty splitting result.\nOptional (they will stop as in case of `null` result).\n\nWe recommend using a `ref` attribute if the custom splitter implementation can be referenced in other `<splitter>` definitions.\nHowever, if the custom splitter handler implementation should be scoped to a single definition of the `<splitter>`, you can configure an inner bean definition, as the following example follows:\n\n[source,xml]\n----\n<int:splitter id=\"testSplitter\" input-channel=\"inChannel\" method=\"split\"\n output-channel=\"outChannel\">\n <beans:bean class=\"org.foo.TestSplitter\"/>\n</int:splitter>\n----\n\nNOTE: Using both a `ref` attribute and an inner handler definition in the same `<int:splitter>` configuration is not allowed, as it creates an ambiguous condition and results in an exception being thrown.\n\nIMPORTANT: If the `ref` attribute references a bean that extends `AbstractMessageProducingHandler` (such as splitters provided by the framework itself), the configuration is optimized by injecting the output channel into the handler directly.\nIn this case, each `ref` must be a separate bean instance (or a `prototype`-scoped bean) or use the inner `<bean/>` configuration type.\nHowever, this optimization applies only if you do not provide any splitter-specific attributes in the splitter XML definition.\nIf you inadvertently reference the same message handler from multiple beans, you get a configuration exception.\n\n[[configuring-a-splitter-with-annotations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/splitter.adoc", "title": "splitter", "heading": "Configuring a Splitter with XML", "heading_level": 2, "file_order": 268, "section_index": 5, "content_hash": "5f208811e2beff88a0ddb7baf95f0e0c3cfdc50a8cf8d710bd94783e8d11dd76", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/splitter.adoc"}}
{"id": "sha256:84272866cc27a215dde4b97c43f9dbc99ecc1429fb457d2cf30072f2db24b577", "content": "The `@Splitter` annotation is applicable to methods that expect either the `Message` type or the message payload type, and the return values of the method should be a `Collection` of any type.\nIf the returned values are not actual `Message` objects, each item is wrapped in a `Message` as the payload of the `Message`.\nEach resulting `Message` is sent to the designated output channel for the endpoint on which the `@Splitter` is defined.\n\nThe following example shows how to configure a splitter by using the `@Splitter` annotation:\n\n[source,java]\n----\n@Splitter\nList<LineItem> extractItems(Order order) {\n return order.getItems()\n}\n----\n\nSee also xref:handler-advice/advising-with-annotations.adoc[Advising Endpoints Using Annotations] and xref:file/splitter.adoc[File Splitter].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/splitter.adoc", "title": "splitter", "heading": "Configuring a Splitter with Annotations", "heading_level": 2, "file_order": 268, "section_index": 6, "content_hash": "84272866cc27a215dde4b97c43f9dbc99ecc1429fb457d2cf30072f2db24b577", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/splitter.adoc"}}
{"id": "sha256:42c2d2bcab677635e81eb845e3110453bacd9a3f105a88d610e70fafabd0d111", "content": "[[stomp]]\n\nSpring Integration version 4.2 introduced STOMP (Simple Text Orientated Messaging Protocol) client support.\nIt is based on the architecture, infrastructure, and API from the Spring Framework's messaging module, stomp package.\nSpring Integration uses many of Spring STOMP components (such as `StompSession` and `StompClientSupport`).\nFor more information, see the https://docs.spring.io/spring-framework/reference/web/websocket/stomp/client.html[Spring Framework STOMP Support] chapter in the Spring Framework reference manual.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-stomp</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-stomp:{project-version}\"\n----\n======\n\nFor server side components you need to add a `org.springframework:spring-websocket` and/or `io.projectreactor.netty:reactor-netty` dependencies.\n\n[[stomp-overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stomp.adoc", "title": "stomp", "heading": "stomp", "heading_level": 1, "file_order": 269, "section_index": 0, "content_hash": "42c2d2bcab677635e81eb845e3110453bacd9a3f105a88d610e70fafabd0d111", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stomp.adoc"}}
{"id": "sha256:706756e3fde5a026e74d29ee58b5131d1387d88a49cb37d7d5591ae2515948cb", "content": "To configure STOMP, you should start with the STOMP client object.\nThe Spring Framework provides the following implementations:\n\n* `WebSocketStompClient`: Built on the Spring WebSocket API with support for standard JSR-356 WebSocket, Jetty 9, and SockJS for HTTP-based WebSocket emulation with SockJS Client.\n\n* `ReactorNettyTcpStompClient`: Built on `ReactorNettyTcpClient` from the `reactor-netty` project.\n\nYou can provide any other `StompClientSupport` implementation.\nSee the https://docs.spring.io/spring-integration/api/[Javadoc] of those classes.\n\nThe `StompClientSupport` class is designed as a _factory_ to produce a `StompSession` for the provided `StompSessionHandler` and all the remaining work is done through the _callbacks_ to that `StompSessionHandler` and `StompSession` abstraction.\nWith the Spring Integration _adapter_ abstraction, we need to provide some managed shared object to represent our application as a STOMP client with its unique session.\nFor this purpose, Spring Integration provides the `StompSessionManager` abstraction to manage the _single_ `StompSession` between any provided `StompSessionHandler`.\nThis allows the use of _inbound_ or _outbound_ channel adapters (or both) for the particular STOMP Broker.\nSee `StompSessionManager` (and its implementations) Javadocs for more information.\n\n[[stomp-inbound-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stomp.adoc", "title": "stomp", "heading": "Overview", "heading_level": 2, "file_order": 269, "section_index": 1, "content_hash": "706756e3fde5a026e74d29ee58b5131d1387d88a49cb37d7d5591ae2515948cb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stomp.adoc"}}
{"id": "sha256:1b9d28115452d2e421977f69e9b531d62a91bfa220e08349cb9ecb2e455a6780", "content": "The `StompInboundChannelAdapter` is a one-stop `MessageProducer` component that subscribes your Spring Integration application to the provided STOMP destinations and receives messages from them (converted from the STOMP frames by using the provided `MessageConverter` on the connected `StompSession`).\nYou can change the destinations (and therefore STOMP subscriptions) at runtime by using appropriate `@ManagedOperation` annotations on the `StompInboundChannelAdapter`.\n\nFor more configuration options, see xref:stomp.adoc#stomp-namespace[STOMP Namespace Support] and the `StompInboundChannelAdapter` https://docs.spring.io/spring-integration/api/org/springframework/integration/stomp/inbound/StompInboundChannelAdapter.html[Javadoc].\n\n[[stomp-outbound-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stomp.adoc", "title": "stomp", "heading": "STOMP Inbound Channel Adapter", "heading_level": 2, "file_order": 269, "section_index": 2, "content_hash": "1b9d28115452d2e421977f69e9b531d62a91bfa220e08349cb9ecb2e455a6780", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stomp.adoc"}}
{"id": "sha256:3d6061dbc620e3644bc41467e25c1ea39adb8958789cc2eb532d30f75e88de76", "content": "The `StompMessageHandler` is the `MessageHandler` for the `<int-stomp:outbound-channel-adapter>` and is used to send the outgoing `Message<?>` instances to the STOMP `destination` (pre-configured or determined at runtime with a SpEL expression) through the `StompSession` (which is provided by the shared `StompSessionManager`).\n\nFor more configuration options see xref:stomp.adoc#stomp-namespace[STOMP Namespace Support] and the `StompMessageHandler` https://docs.spring.io/spring-integration/api/org/springframework/integration/stomp/outbound/StompMessageHandler.html[Javadoc].\n\n[[stomp-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stomp.adoc", "title": "stomp", "heading": "STOMP Outbound Channel Adapter", "heading_level": 2, "file_order": 269, "section_index": 3, "content_hash": "3d6061dbc620e3644bc41467e25c1ea39adb8958789cc2eb532d30f75e88de76", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stomp.adoc"}}
{"id": "sha256:8527085d9593938934bd1cc7780b2b142a1b90b33a3efd4ff705c760d12117dd", "content": "The STOMP protocol provides headers as part of its frame.\nThe entire structure of the STOMP frame has the following format:\n\n[source]\n----\n....\nCOMMAND\nheader1:value1\nheader2:value2\n\nBody^@\n....\n----\n\nSpring Framework provides `StompHeaders` to represent these headers.\nSee the https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/simp/stomp/StompHeaders.html[Javadoc] for more details.\nSTOMP frames are converted to and from `Message<?>` instances and these headers are mapped to and from `MessageHeaders` instances.\nSpring Integration provides a default `HeaderMapper` implementation for the STOMP adapters.\nThe implementation is `StompHeaderMapper`.\nIt provides `fromHeaders()` and `toHeaders()` operations for the inbound and outbound adapters, respectively.\n\nAs with many other Spring Integration modules, the `IntegrationStompHeaders` class has been introduced to map standard STOMP headers to `MessageHeaders`, with `stomp_` as the header name prefix.\nIn addition, all `MessageHeaders` instances with that prefix are mapped to the `StompHeaders` when sending to a destination.\n\nFor more information, see the https://docs.spring.io/spring-integration/api/[Javadoc] for those classes and the `mapped-headers` attribute description in the xref:stomp.adoc#stomp-namespace[STOMP Namespace Support].\n\n[[stomp-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stomp.adoc", "title": "stomp", "heading": "STOMP Headers Mapping", "heading_level": 2, "file_order": 269, "section_index": 4, "content_hash": "8527085d9593938934bd1cc7780b2b142a1b90b33a3efd4ff705c760d12117dd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stomp.adoc"}}
{"id": "sha256:2b9664c5ec0ce4c219cb4605ebb2da8d27f204f87bdb272809df65ffaa42338f", "content": "Many STOMP operations are asynchronous, including error handling.\nFor example, STOMP has a `RECEIPT` server frame that it returns when a client frame has requested one by adding the `RECEIPT` header.\nTo provide access to these asynchronous events, Spring Integration emits `StompIntegrationEvent` instances, which you can obtain by implementing an `ApplicationListener` or by using an `<int-event:inbound-channel-adapter>` (see xref:event.adoc#appevent-inbound[Receiving Spring Application Events]).\n\nSpecifically, a `StompExceptionEvent` is emitted from the `AbstractStompSessionManager` when a `stompSessionListenableFuture` receives `onFailure()` due to failure to connect to STOMP broker.\nAnother example is the `StompMessageHandler`.\nIt processes `ERROR` STOMP frames, which are server responses to improper (unaccepted) messages sent by this `StompMessageHandler`.\n\nThe `StompMessageHandler` emits `StompReceiptEvent` as a part of `StompSession.Receiptable` callbacks in the asynchronous answers for the messages sent to the `StompSession`.\nThe `StompReceiptEvent` can be positive or negative, depending on whether the `RECEIPT` frame was received from the server within the `receiptTimeLimit` period, which you can configure on the `StompClientSupport` instance.\nIt defaults to `15 * 1000` (in milliseconds, so 15 seconds).\n\nNOTE: The `StompSession.Receiptable` callbacks are added only if the `RECEIPT` STOMP header of the message to send is not `null`.\nYou can enable automatic `RECEIPT` header generation on the `StompSession` through its `autoReceipt` option and on the `StompSessionManager` respectively.\n\nSee xref:stomp.adoc#stomp-java-config[STOMP Adapters Java Configuration] for more information how to configure Spring Integration to accept those `ApplicationEvent` instances.\n\n[[stomp-java-config]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stomp.adoc", "title": "stomp", "heading": "STOMP Integration Events", "heading_level": 2, "file_order": 269, "section_index": 5, "content_hash": "2b9664c5ec0ce4c219cb4605ebb2da8d27f204f87bdb272809df65ffaa42338f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stomp.adoc"}}
{"id": "sha256:70f25c995c695d182ed167ec57f547b1de0cbd2982fae1e3c10a96d6bade85da", "content": "The following example shows a comprehensive Java configuration for STOMP adapters:\n\n[source,java]\n----\n@Configuration\n@EnableIntegration\npublic class StompConfiguration {\n\n @Bean\n public ReactorNettyTcpStompClient stompClient() {\n ReactorNettyTcpStompClient stompClient = new ReactorNettyTcpStompClient(\"127.0.0.1\", 61613);\n stompClient.setMessageConverter(new PassThruMessageConverter());\n ThreadPoolTaskScheduler taskScheduler = new ThreadPoolTaskScheduler();\n taskScheduler.afterPropertiesSet();\n stompClient.setTaskScheduler(taskScheduler);\n stompClient.setReceiptTimeLimit(5000);\n return stompClient;\n }\n\n @Bean\n public StompSessionManager stompSessionManager() {\n ReactorNettyTcpStompSessionManager stompSessionManager = new ReactorNettyTcpStompSessionManager(stompClient());\n stompSessionManager.setAutoReceipt(true);\n return stompSessionManager;\n }\n\n @Bean\n public PollableChannel stompInputChannel() {\n return new QueueChannel();\n }\n\n @Bean\n public StompInboundChannelAdapter stompInboundChannelAdapter() {\n StompInboundChannelAdapter adapter =\n new StompInboundChannelAdapter(stompSessionManager(), \"/topic/myTopic\");\n adapter.setOutputChannel(stompInputChannel());\n return adapter;\n }\n\n @Bean\n @ServiceActivator(inputChannel = \"stompOutputChannel\")\n public MessageHandler stompMessageHandler() {\n StompMessageHandler handler = new StompMessageHandler(stompSessionManager());\n handler.setDestination(\"/topic/myTopic\");\n return handler;\n }\n\n @Bean\n public PollableChannel stompEvents() {\n return new QueueChannel();\n }\n\n @Bean\n public ApplicationListener<ApplicationEvent> stompEventListener() {\n ApplicationEventListeningMessageProducer producer = new ApplicationEventListeningMessageProducer();\n producer.setEventTypes(StompIntegrationEvent.class);\n producer.setOutputChannel(stompEvents());\n return producer;\n }\n\n}\n----\n\n[[stomp-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stomp.adoc", "title": "stomp", "heading": "STOMP Adapters Java Configuration", "heading_level": 2, "file_order": 269, "section_index": 6, "content_hash": "70f25c995c695d182ed167ec57f547b1de0cbd2982fae1e3c10a96d6bade85da", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stomp.adoc"}}
{"id": "sha256:9470236ef26518349573ac4db5f1eb332958cd93c745da60bb003bca81d10dfd", "content": "The Spring Integration STOMP namespace implements the inbound and outbound channel adapter components.\nTo include it in your configuration, provide the following namespace declaration in your application context configuration file:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int=\"http://www.springframework.org/schema/integration\"\n xmlns:int-stomp=\"http://www.springframework.org/schema/integration/stomp\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration.xsd\n http://www.springframework.org/schema/integration/stomp\n https://www.springframework.org/schema/integration/stomp/spring-integration-stomp.xsd\">\n ...\n</beans>\n----\n\n[[stomp-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stomp.adoc", "title": "stomp", "heading": "STOMP Namespace Support", "heading_level": 2, "file_order": 269, "section_index": 7, "content_hash": "9470236ef26518349573ac4db5f1eb332958cd93c745da60bb003bca81d10dfd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stomp.adoc"}}
{"id": "sha256:5bbccfc0e08433550a6a120fd65e90b4a3b9b0b6ecda5607d7be72cbcf569b13", "content": "The following listing shows the available attributes for the STOMP outbound channel adapter:\n\n[source,xml]\n----\n<int-stomp:outbound-channel-adapter\n id=\"\" <1>\n channel=\"\" <2>\n stomp-session-manager=\"\" <3>\n header-mapper=\"\" <4>\n mapped-headers=\"\" <5>\n destination=\"\" <6>\n destination-expression=\"\" <7>\n auto-startup=\"\" <8>\n phase=\"\"/> <9>\n----\n\n<1> The component bean name.\nThe `MessageHandler` is registered with a bean alias of `id` plus `.handler`.\nIf you do not set the `channel` attribute, a `DirectChannel` is created and registered in the application context with the value of this `id` attribute as the bean name.\nIn this case, the endpoint is registered with a bean name `id` plus `.adapter`.\n<2> Identifies the channel attached to this adapter if `id` is present.\nSee `id`.\nOptional.\n<3> Reference to a `StompSessionManager` bean, which encapsulates the low-level connection and `StompSession` handling operations.\nRequired.\n<4> Reference to a bean that implements `HeaderMapper<StompHeaders>`, which maps Spring Integration `MessageHeaders` to and from\nSTOMP frame headers.\nIt is mutually exclusive with `mapped-headers`.\nIt defaults to `StompHeaderMapper`.\n<5> Comma-separated list of names of STOMP Headers to be mapped to the STOMP frame headers.\nIt can be provided only if the `header-mapper` reference is not set.\nThe values in this list can also be simple patterns to be matched against the header names (such as `myheader*` or `*myheader`).\nA special token (`STOMP_OUTBOUND_HEADERS`) represents all the standard STOMP headers (content-length, receipt, heart-beat, and so on).\nThey are included by default.\nIf you want to add your own headers and want the standard headers to also be mapped, you must include this token or provide your own `HeaderMapper` implementation by using `header-mapper`.\n<6> Name of the destination to which STOMP Messages are sent.\nIt is mutually exclusive with the `destination-expression`.\n<7> A SpEL expression to be evaluated at runtime against each Spring Integration `Message` as the root object.\nIt is mutually exclusive with the `destination`.\n<8> Boolean value indicating whether this endpoint should start automatically.\nIt defaults to `true`.\n<9> The lifecycle phase within which this endpoint should start and stop.\nThe lower the value, the earlier this endpoint starts and the later it stops.\nThe default is `Integer.MIN_VALUE`.\nValues can be negative.\nSee https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/SmartLifecycle.html[`SmartLifeCycle`].\n\n[[understanding-the-int-stomp:inbound-channel-adapter-element]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stomp.adoc", "title": "stomp", "heading": "Understanding the `<int-stomp:outbound-channel-adapter>` Element", "heading_level": 3, "file_order": 269, "section_index": 8, "content_hash": "5bbccfc0e08433550a6a120fd65e90b4a3b9b0b6ecda5607d7be72cbcf569b13", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stomp.adoc"}}
{"id": "sha256:32b52a3a80c206ff35b5bfacf8340854adc6a0a825d67e5055a74d81a44ad390", "content": "The following listing shows the available attributes for the STOMP inbound channel adapter:\n\n[source,xml]\n----\n<int-stomp:inbound-channel-adapter\n id=\"\" <1>\n channel=\"\" <2>\n error-channel=\"\" <3>\n stomp-session-manager=\"\" <4>\n header-mapper=\"\" <5>\n mapped-headers=\"\" <6>\n destinations=\"\" <7>\n send-timeout=\"\" <8>\n payload-type=\"\" <9>\n auto-startup=\"\" <10>\n phase=\"\"/> <11>\n----\n\n<1> The component bean name.\nIf you do not set the `channel` attribute, a `DirectChannel` is created and registered in the application context with the value of this `id` attribute as the bean name.\nIn this case, the endpoint is registered with the bean name `id` plus `.adapter`.\n<2> Identifies the channel attached to this adapter.\n<3> The `MessageChannel` bean reference to which `ErrorMessage` instances should be sent.\n<4> See the same option on the <<stomp-outbound-channel-adapter,`<int-stomp:outbound-channel-adapter>`>>.\n<5> Comma-separated list of names of STOMP Headers to be mapped from the STOMP frame headers.\nYou can only provide this if the `header-mapper` reference is not set.\nThe values in this list can also be simple patterns to be matched against the header names (for example, `myheader*` or `*myheader`).\nA special token (`STOMP_INBOUND_HEADERS`) represents all the standard STOMP headers (content-length, receipt, heart-beat, and so on).\nThey are included by default.\nIf you want to add your own headers and want the standard headers to also be mapped, you must also include this token or provide your own `HeaderMapper` implementation using `header-mapper`.\n<6> See the same option on the <<stomp-outbound-channel-adapter,`<int-stomp:outbound-channel-adapter>`>>.\n<7> Comma-separated list of STOMP destination names to subscribe.\nThe list of destinations (and therefore subscriptions) can be modified at runtime through the `addDestination()` and `removeDestination()` `@ManagedOperation` annotations.\n<8> Maximum amount of time (in milliseconds) to wait when sending a message to the channel if the channel can block.\nFor example, a `QueueChannel` can block until space is available if its maximum capacity has been reached.\n<9> Fully qualified name of the Java type for the target `payload` to convert from the incoming STOMP frame.\nIt defaults to `String.class`.\n<10> See the same option on the <<stomp-outbound-channel-adapter,`<int-stomp:outbound-channel-adapter>`>>.\n<11> See the same option on the <<stomp-outbound-channel-adapter,`<int-stomp:outbound-channel-adapter>`>>.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stomp.adoc", "title": "stomp", "heading": "Understanding the `<int-stomp:inbound-channel-adapter>` Element", "heading_level": 3, "file_order": 269, "section_index": 9, "content_hash": "32b52a3a80c206ff35b5bfacf8340854adc6a0a825d67e5055a74d81a44ad390", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stomp.adoc"}}
{"id": "sha256:b2195b1a3bb8c06868ac0cc159c6ff924172f4dcd7965e184e0cfa9bab4fc6ba", "content": "[[stream]]\n\nIn many cases, application data is obtained from a stream.\nIt is not recommended sending a reference to a stream as a message payload to a consumer.\nInstead, messages are created from data that is read from an input stream, and message payloads are written to an output stream one by one.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-stream</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-stream:{project-version}\"\n----\n======\n\n[[stream-reading]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "stream", "heading_level": 1, "file_order": 270, "section_index": 0, "content_hash": "b2195b1a3bb8c06868ac0cc159c6ff924172f4dcd7965e184e0cfa9bab4fc6ba", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:37d2d52ec1e4f398c98ec3fd06fb546773795fb2d4c9a96b45afb47a134ffc6a", "content": "Spring Integration provides two adapters for streams.\nBoth `ByteStreamReadingMessageSource` and `CharacterStreamReadingMessageSource` implement `MessageSource`.\nBy configuring one of these within a channel-adapter element, the polling period can be configured, and the message bus can automatically detect and schedule them.\nThe byte stream version requires an `InputStream`, and the character stream version requires a `Reader` as the single constructor argument.\nThe `ByteStreamReadingMessageSource` also accepts the 'bytesPerMessage' property to determine how many bytes it tries to read into each `Message`.\nThe default value is `1024`.\nThe following example creates an input stream that creates messages that each contain 2048 bytes:\n\n[source,xml]\n----\n<bean class=\"org.springframework.integration.stream.inbound.ByteStreamReadingMessageSource\">\n <constructor-arg ref=\"someInputStream\"/>\n <property name=\"bytesPerMessage\" value=\"2048\"/>\n</bean>\n\n<bean class=\"org.springframework.integration.stream.inbound.CharacterStreamReadingMessageSource\">\n <constructor-arg ref=\"someReader\"/>\n</bean>\n----\n\nThe `CharacterStreamReadingMessageSource` wraps the reader in a `BufferedReader` (if it is not one already).\nYou can set the buffer size used by the buffered reader in the second constructor argument.\nStarting with version 5.0, a third constructor argument (`blockToDetectEOF`) controls the behavior of the `CharacterStreamReadingMessageSource`.\nWhen `false` (the default), the `receive()` method checks whether the reader is `ready()` and returns null if not.\nEOF (end of a file) is not detected in this case.\nWhen `true`, the `receive()` method blocks until data is available or EOF is detected on the underlying stream.\nWhen EOF is detected, a `StreamClosedEvent` (application event) is published.\nYou can consume this event with a bean that implements `ApplicationListener<StreamClosedEvent>`.\n\nNOTE: To facilitate EOF detection, the poller thread blocks in the `receive()` method until either data arrives or EOF is detected.\n\nIMPORTANT: The poller continues to publish an event on each poll once EOF has been detected.\nThe application listener can stop the adapter to prevent this.\nThe event is published on the poller thread.\nStopping the adapter causes the thread to be interrupted.\nIf you intend to perform some interruptible task after stopping the adapter, you must either perform the `stop()` on a different thread or use a different thread for those downstream activities.\nNote that sending to a `QueueChannel` is interruptible, so, if you wish to send a message from the listener, do it before stopping the adapter.\n\nThis facilitates \"`piping`\" or redirecting data to `stdin`, as the following two examples show:\n\n[source]\n----\ncat myfile.txt | java -jar my.jar\n----\n\n[source]\n----\njava -jar my.jar < foo.txt\n----\n\nThis approach lets the application stop when the pipe is closed.\n\nFour convenient factory methods are available:\n\n[source, java]\n----\npublic static final CharacterStreamReadingMessageSource stdin() { ... }\n\npublic static final CharacterStreamReadingMessageSource stdin(String charsetName) { ... }\n\npublic static final CharacterStreamReadingMessageSource stdinPipe() { ... }\n\npublic static final CharacterStreamReadingMessageSource stdinPipe(String charsetName) { ... }\n----\n\n[[stream-writing]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "Reading from Streams", "heading_level": 2, "file_order": 270, "section_index": 1, "content_hash": "37d2d52ec1e4f398c98ec3fd06fb546773795fb2d4c9a96b45afb47a134ffc6a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:bfbd17f73673a739860e89cf92e0277836a86f40f5d9ea3ac98376d41be3a206", "content": "For target streams, you can use either of two implementations: `ByteStreamWritingMessageHandler` or `CharacterStreamWritingMessageHandler`.\nEach requires a single constructor argument (`OutputStream` for byte streams or `Writer` for character streams), and each provides a second constructor that adds the optional 'bufferSize'.\nSince both of these ultimately implement the `MessageHandler` interface, you can reference them from a `channel-adapter` configuration, as described in xref:overview.adoc#overview-endpoints-channeladapter[Channel Adapter].\n\n[source,xml]\n----\n<bean class=\"org.springframework.integration.stream.outbound.ByteStreamWritingMessageHandler\">\n <constructor-arg ref=\"someOutputStream\"/>\n <constructor-arg value=\"1024\"/>\n</bean>\n\n<bean class=\"org.springframework.integration.stream.outbound.CharacterStreamWritingMessageHandler\">\n <constructor-arg ref=\"someWriter\"/>\n</bean>\n----\n\n[[stream-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "Writing to Streams", "heading_level": 2, "file_order": 270, "section_index": 2, "content_hash": "bfbd17f73673a739860e89cf92e0277836a86f40f5d9ea3ac98376d41be3a206", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:44e4e4efa3fa963b1513dca462ccfcb99130aef8607bd1786d4f034b7939be02", "content": "Spring Integration defines a namespace to reduce the configuration needed for stream-related channel adapters.\nThe following schema locations are needed to use it:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans:beans xmlns:int-stream=\"http://www.springframework.org/schema/integration/stream\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:beans=\"http://www.springframework.org/schema/beans\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration/stream\n https://www.springframework.org/schema/integration/stream/spring-integration-stream.xsd\">\n----\n\nThe following code snippet shows the different configuration options that are supported to configure the inbound channel adapter:\n\n[source,xml]\n----\n<int-stream:stdin-channel-adapter id=\"adapterWithDefaultCharset\"/>\n\n<int-stream:stdin-channel-adapter id=\"adapterWithProvidedCharset\" charset=\"UTF-8\"/>\n----\n\nStarting with version 5.0, you can set the `detect-eof` attribute, which sets the `blockToDetectEOF` property.\nSee xref:stream.adoc#stream-reading[Reading from Streams] for more information.\n\nTo configure the outbound channel adapter, you can use the namespace support as well.\nThe following example shows the different configurations for an outbound channel adapter:\n\n[source,xml]\n----\n<int-stream:stdout-channel-adapter id=\"stdoutAdapterWithDefaultCharset\"\n channel=\"testChannel\"/>\n\n<int-stream:stdout-channel-adapter id=\"stdoutAdapterWithProvidedCharset\" charset=\"UTF-8\"\n channel=\"testChannel\"/>\n\n<int-stream:stderr-channel-adapter id=\"stderrAdapter\" channel=\"testChannel\"/>\n\n<int-stream:stdout-channel-adapter id=\"newlineAdapter\" append-newline=\"true\"\n channel=\"testChannel\"/>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "Stream Namespace Support", "heading_level": 2, "file_order": 270, "section_index": 3, "content_hash": "44e4e4efa3fa963b1513dca462ccfcb99130aef8607bd1786d4f034b7939be02", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:9738e223767dbe842e995397060c14fc03662f2001b06b1c5938ac59badd447c", "content": "[[syslog]]\n\nSpring Integration 2.2 introduced the syslog transformer: `SyslogToMapTransformer`.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-syslog</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-syslog:{project-version}\"\n----\n======\n\nThis transformer, together with a `UDP` or `TCP` inbound adapter, could be used to receive and analyze syslog records from other hosts.\nThe transformer creates a message payload that contains a map of the elements from the syslog message.\n\nSpring Integration 3.0 introduced convenient namespace support for configuring a syslog inbound adapter in a single element.\n\nStarting with version 4.1.1, the framework now supports the extended syslog format, as specified in https://tools.ietf.org/html/rfc5424[RFC 5424>].\nIn addition, when using TCP and RFC5424, both `octet counting` and `non-transparent framing` described in https://tools.ietf.org/html/rfc6587[RFC 6587] are supported.\n\n[[syslog-inbound-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/syslog.adoc", "title": "syslog", "heading": "syslog", "heading_level": 1, "file_order": 271, "section_index": 0, "content_hash": "9738e223767dbe842e995397060c14fc03662f2001b06b1c5938ac59badd447c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/syslog.adoc"}}
{"id": "sha256:955f7ebe99d0cd604af36af638dd86e696c9560c582dacb656bfc3ae1f2279ee", "content": "This element encompasses a `UDP` or `TCP` inbound channel adapter and a `MessageConverter` to convert the syslog message to a Spring Integration message.\nThe `DefaultMessageConverter` delegates to the `SyslogToMapTransformer`, creating a message with its payload being the `Map` of syslog fields.\nIn addition, all fields except the message are also made available as headers in the message and are prefixed with `syslog_`.\nIn this mode, only https://tools.ietf.org/html/rfc3164[RFC 3164] (BSD) syslogs are supported.\n\nSince version 4.1, the `DefaultMessageConverter` has a property called `asMap` (the default is `true`).\nWhen it is `false`, the converter leaves the message payload as the original complete syslog message (in a `byte[]`) while still setting the headers.\n\nSince version 4.1.1, RFC 5424 is also supported, by using the `RFC5424MessageConverter`.\nIn this case, the fields are not copied as headers, unless `asMap` is set to `false`, in which case the original message is the payload and the decoded fields are headers.\n\nIMPORTANT: To use RFC 5424 with a TCP transport, you must provide additional configuration to enable the different framing techniques described in RFC 6587.\nThe adapter needs a TCP connection factory that is configured with a `RFC6587SyslogDeserializer`.\nBy default, this deserializer handles `octet counting` and `non-transparent framing` by using a linefeed (LF) to delimit syslog messages.\nIt uses a `ByteArrayLfSerializer` when `octet counting` is not detected.\nTo use different `non-transparent` framing, you can provide it with some other deserializer.\nWhile the deserializer can support both `octet counting` and `non-transparent framing`, only one form of the latter is supported.\nIf `asMap` is `false` on the converter, you must set the `retainOriginal` constructor argument in the `RFC6587SyslogDeserializer`.\n\n[[syslog-inbound-examplers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/syslog.adoc", "title": "syslog", "heading": "Syslog Inbound Channel Adapter", "heading_level": 2, "file_order": 271, "section_index": 1, "content_hash": "955f7ebe99d0cd604af36af638dd86e696c9560c582dacb656bfc3ae1f2279ee", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/syslog.adoc"}}
{"id": "sha256:78c01d8b4bd3e0575d470b0b9383b6b4e48b2ffbb445023fa0b0bcd809f3bfa4", "content": "The following example defines a `UDP` adapter that sends messages to the `syslogIn` channel (the adapter bean name is `syslogIn.adapter`):\n\n[source,xml]\n----\n<int-syslog:inbound-channel-adapter id=\"syslogIn\" port=\"1514\" />\n----\n\nThe adapter listens on port `1514`.\n\nThe following example defines a `UDP` adapter that sends messages to the `fromSyslog` channel (the adapter bean name is `syslogIn`):\n\n[source,xml]\n----\n<int-syslog:inbound-channel-adapter id=\"syslogIn\"\n\tchannel=\"fromSyslog\" port=\"1514\" />\n----\n\nThe adapter listens on port `1514`.\n\nThe following example defines a `TCP` adapter that sends messages to channel `syslogIn` (the adapter bean name is `syslogIn.adapter`):\n\n[source,xml]\n----\n<int-syslog:inbound-channel-adapter id=\"bar\" protocol=\"tcp\" port=\"1514\" />\n----\n\nThe adapter listens on port `1514`.\n\nNote the addition of the `protocol` attribute.\nThis attribute can contain `udp` or `tcp`.\nIt defaults to `udp`.\n\nThe following example shows a `UDP` adapter that sends messages to channel `fromSyslog`:\n\n[source,xml]\n----\n<int-syslog:inbound-channel-adapter id=\"udpSyslog\"\n\tchannel=\"fromSyslog\"\n\tauto-startup=\"false\"\n\tphase=\"10000\"\n\tconverter=\"converter\"\n\tsend-timeout=\"1000\"\n\terror-channel=\"errors\">\n <int-syslog:udp-attributes port=\"1514\" lookup-host=\"false\" />\n</int-syslog:inbound-channel-adapter>\n----\n\nThe preceding example also shows two `SmartLifecycle` attributes: `auto-startup` and `phase`.\nIt has a reference to a custom `org.springframework.integration.syslog.MessageConverter` with an ID of `converter` and an `error-channel`.\nAlso notice the `udp-attributes` child element.\nYou can set various UDP attributes here, as defined in xref:ip/endpoint-reference.adoc#ip-udp-ib-atts[.UDP Inbound Channel Adapter Attributes].\n\nNOTE: When you use the `udp-attributes` element, you must provide the `port` attribute there rather than on the `inbound-channel-adapter` element itself.\n\nThe following example shows a `TCP` adapter that sends messages to channel `fromSyslog`:\n\n[source,xml]\n----\n<int-syslog:inbound-channel-adapter id=\"TcpSyslog\"\n\tprotocol=\"tcp\"\n\tchannel=\"fromSyslog\"\n\tconnection-factory=\"cf\" />\n\n<int-ip:tcp-connection-factory id=\"cf\" type=\"server\" port=\"1514\" />\n----\n\nIt also shows how to reference an externally defined connection factory, which can be used for advanced configuration (socket keep-alive and other uses).\nFor more information, see xref:ip/tcp-connection-factories.adoc[TCP Connection Factories].\n\nNOTE: The externally configured `connection-factory` must be of type `server`, and the port is defined there rather than on the `inbound-channel-adapter` element itself.\n\nThe following example shows a `TCP` adapter that sends messages to channel `fromSyslog`:\n\n[source,xml]\n----\n<int-syslog:inbound-channel-adapter id=\"rfc5424Tcp\"\n\tprotocol=\"tcp\"\n\tchannel=\"fromSyslog\"\n\tconnection-factory=\"cf\"\n\tconverter=\"rfc5424\" />\n\n<int-ip:tcp-connection-factory id=\"cf\"\n\tusing-nio=\"true\"\n\ttype=\"server\"\n\tport=\"1514\"\n\tdeserializer=\"rfc6587\" />\n\n<bean id=\"rfc5424\" class=\"org.springframework.integration.syslog.RFC5424MessageConverter\" />\n\n<bean id=\"rfc6587\" class=\"org.springframework.integration.syslog.inbound.RFC6587SyslogDeserializer\" />\n----\n\nThe preceding example is configured to use the `RFC 5424` converter and is configured with a reference to an externally defined connection factory with the `RFC 6587` deserializer (required for RFC 5424).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/syslog.adoc", "title": "syslog", "heading": "Example Configuration", "heading_level": 3, "file_order": 271, "section_index": 2, "content_hash": "78c01d8b4bd3e0575d470b0b9383b6b4e48b2ffbb445023fa0b0bcd809f3bfa4", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/syslog.adoc"}}
{"id": "sha256:844f4ce13c6e944be45f52cb9e6366960d59156be9dafd4c704d914c691e4c45", "content": "[[system-management-chapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/system-management.adoc", "title": "system-management", "heading": "system-management", "heading_level": 1, "file_order": 272, "section_index": 0, "content_hash": "844f4ce13c6e944be45f52cb9e6366960d59156be9dafd4c704d914c691e4c45", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/system-management.adoc"}}
{"id": "sha256:78001dd39ead907ae310bc7de9cefd11e8ba06b2e1c1563709b06fb6f81dbea2", "content": "[[testing]]\n\nSpring Integration provides a number of utilities and annotations to help you test your application.\nTesting support is presented by two modules:\n\n* `spring-integration-test-support` contains core items and shared utilities\n* `spring-integration-test` provides mocking and application context configuration components for integration tests\n\n`spring-integration-test-support` (`spring-integration-test` in versions before 5.0) provides basic, standalone utilities, rules, and matchers for unit testing.\n(it also has no dependencies on Spring Integration itself and is used internally in Framework tests).\n`spring-integration-test` aims to help with integration testing and provides a comprehensive high-level API to mock integration components and verify the behavior of individual components, including whole integration flows or only parts of them.\n\nA thorough treatment of testing in the enterprise is beyond the scope of this reference manual.\nSee the https://www.enterpriseintegrationpatterns.com/docs/TestDrivenEAI.pdf[\"`Test-Driven Development in Enterprise Integration Projects`\"] paper, by Gregor Hohpe and Wendy Istvanick, for a source of ideas and principles for testing your target integration solution.\n\nThe Spring Integration Test Framework and test utilities are fully based on existing JUnit, Hamcrest, and Mockito libraries.\nThe application context interaction is based on the https://docs.spring.io/spring-framework/reference/testing.html#testing[Spring test framework].\nSee the documentation for those projects for further information.\n\nThanks to the canonical implementation of the EIP in Spring Integration Framework and its first-class citizens (such as `MessageChannel`, `Endpoint` and `MessageHandler`), abstractions, and loose coupling principles, you can implement integration solutions of any complexity.\nWith the Spring Integration API for the flow definitions, you can improve, modify, or even replace some parts of the flow without impacting (mostly) other components in the integration solution.\nTesting such an integration solution is still a challenge, both from an end-to-end approach and from an in-isolation approach.\nSeveral existing tools can help to test or mock some integration protocols, and they work well with Spring Integration channel adapters.\nExamples of such tools include the following:\n\n* Spring `MockMVC` and its `MockRestServiceServer` can be used for testing HTTP.\n* Some RDBMS vendors provide embedded data bases for JDBC or JPA support.\n* ActiveMQ can be embedded for testing JMS or STOMP protocols.\n* There are tools for embedded MongoDB and Redis.\n* Tomcat and Jetty have embedded libraries to test real HTTP, Web Services, or WebSockets.\n* The `FtpServer` and `SshServer` from the Apache Mina project can be used for testing the FTP and SFTP protocols.\n* Hazelcast can be run as real-data grid nodes in the tests.\n* The Curator Framework provides a `TestingServer` for Zookeeper interaction.\n* Apache Kafka provides admin tools to embed a Kafka Broker in the tests.\n* The GreenMail is an open-source, intuitive and easy-to-use test suite of email servers for testing purposes.\n\nMost of these tools and libraries are used in Spring Integration tests.\nAlso, from the GitHub https://github.com/spring-projects/spring-integration[repository] (in the `test` directory of each module), you can discover ideas for how to build your own tests for integration solutions.\n\nThe rest of this chapter describes the testing tools and utilities provided by Spring Integration.\n\n[[testing-utilities]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "testing", "heading_level": 1, "file_order": 273, "section_index": 0, "content_hash": "78001dd39ead907ae310bc7de9cefd11e8ba06b2e1c1563709b06fb6f81dbea2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:91a48520fb3f7af753dca9ee9a79cf2cb38849329f27861802621f822d93bc78", "content": "The `spring-integration-test-support` module provides utilities and helpers for unit testing.\n\n[[testutils]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Testing Utilities", "heading_level": 2, "file_order": 273, "section_index": 1, "content_hash": "91a48520fb3f7af753dca9ee9a79cf2cb38849329f27861802621f822d93bc78", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:b30c8c454c3c80f1986eb120f6514d6c92b725ccd1dbbee6edab2528049f90c7", "content": "The `TestUtils` class is mostly used for properties assertions in JUnit tests, as the following example shows:\n\n[source,java]\n----\n@Test\npublic void loadBalancerRef() {\n MessageChannel channel = channels.get(\"lbRefChannel\");\n LoadBalancingStrategy lbStrategy = TestUtils.getPropertyValue(channel, \"dispatcher.loadBalancingStrategy\");\n assertTrue(lbStrategy instanceof SampleLoadBalancingStrategy);\n}\n----\n\n`TestUtils.getPropertyValue()` is based on Spring's `DirectFieldAccessor` and provides the ability to get a value from the target private property.\nAs shown in the preceding example, it also supports nested properties access by using dotted notation.\nThis method also comes with a generic argument for flexible casting of the extracted value to the expected type in tests logic.\n\nThe `createTestApplicationContext()` factory method produces a `TestApplicationContext` instance with the supplied Spring Integration environment.\n\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/test/util/TestUtils.html[Javadoc] of other `TestUtils` methods for more information about this class.\n\n[[using-onlyoncetrigger]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "TestUtils", "heading_level": 3, "file_order": 273, "section_index": 2, "content_hash": "b30c8c454c3c80f1986eb120f6514d6c92b725ccd1dbbee6edab2528049f90c7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:14757d481d9f9d09a7d6549242086c11d1aa54660300fa053fa1bf9ebb061866", "content": "https://docs.spring.io/spring-integration/api/org/springframework/integration/test/util/OnlyOnceTrigger.html[`OnlyOnceTrigger`] is useful for polling endpoints when you need to produce only one test message and verify the behavior without impacting other period messages.\nThe following example shows how to configure `OnlyOnceTrigger`:\n\n[source,xml]\n----\n<bean id=\"testTrigger\" class=\"org.springframework.integration.test.util.OnlyOnceTrigger\" />\n\n<int:poller id=\"jpaPoller\" trigger=\"testTrigger\">\n <int:transactional transaction-manager=\"transactionManager\" />\n</int:poller>\n----\n\nThe following example shows how to use the preceding configuration of `OnlyOnceTrigger` for testing:\n\n[source,java]\n----\n@Autowired\n@Qualifier(\"jpaPoller\")\nPollerMetadata poller;\n\n@Autowired\nOnlyOnceTrigger testTrigger;\n\n@Test\n@DirtiesContext\npublic void testWithEntityClass() throws Exception {\n this.testTrigger.reset();\n ...\n JpaPollingChannelAdapter jpaPollingChannelAdapter = new JpaPollingChannelAdapter(jpaExecutor);\n\n SourcePollingChannelAdapter adapter = JpaTestUtils.getSourcePollingChannelAdapter(\n jpaPollingChannelAdapter, this.outputChannel, this.poller, this.context,\n this.getClass().getClassLoader());\n adapter.start();\n ...\n}\n----\n\n[[support-components]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Using `OnlyOnceTrigger`", "heading_level": 3, "file_order": 273, "section_index": 3, "content_hash": "14757d481d9f9d09a7d6549242086c11d1aa54660300fa053fa1bf9ebb061866", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:09b9b2aafd7ccbf4282ff07a5f6285d06d00056ec798571b3ca9707124d8cbbb", "content": "The `org.springframework.integration.test.support` package contains various abstract classes that you should implement in target tests\n\n* https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/AbstractRequestResponseScenarioTest.html[`AbstractRequestResponseScenarioTest`]\n* https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/AbstractResponseValidator.html[`AbstractResponseValidator`]\n* https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/MessageValidator.html[`MessageValidator`]\n* https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/PayloadValidator.html[`PayloadValidator`]\n* https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/RequestResponseScenario.html[`RequestResponseScenario`]\n* https://docs.spring.io/spring-integration/api/org/springframework/integration/test/support/SingleRequestResponseScenarioTest.html[`SingleRequestResponseScenarioTest`]\n\n[[test-junit-conditions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Support Components", "heading_level": 3, "file_order": 273, "section_index": 4, "content_hash": "09b9b2aafd7ccbf4282ff07a5f6285d06d00056ec798571b3ca9707124d8cbbb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:6acd98aa9eac2e3e12418267e39cba2068b6e04f4fcd1dfb0182999ae148b6b5", "content": "The `@LongRunningTest` conditional annotation is present to indicate if test should be run if `RUN_LONG_INTEGRATION_TESTS` environment or system property is set to `true`.\nOtherwise, it is skipped.\n\n[[hamcrest-and-mockito-matchers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "JUnit Conditions", "heading_level": 3, "file_order": 273, "section_index": 5, "content_hash": "6acd98aa9eac2e3e12418267e39cba2068b6e04f4fcd1dfb0182999ae148b6b5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:3a41402bc6e3132d273f5859b7a4640d3d0a0830577a8ef9c9d9988eae99dcef", "content": "The `org.springframework.integration.test.matcher` package contains several `Matcher` implementations to assert `Message` and its properties in unit tests.\nThe following example shows how to use one such matcher (`PayloadMatcher`):\n\n[source,java]\n----\nimport static org.springframework.integration.test.matcher.PayloadMatcher.hasPayload;\n...\n@Test\npublic void transform_withFilePayload_convertedToByteArray() throws Exception {\n Message<?> result = this.transformer.transform(message);\n assertThat(result, is(notNullValue()));\n assertThat(result, hasPayload(is(instanceOf(byte[].class))));\n assertThat(result, hasPayload(SAMPLE_CONTENT.getBytes(DEFAULT_ENCODING)));\n}\n----\n\nThe `MockitoMessageMatchers` factory can be used for mocks for stubbing and verifications, as the following example shows:\n\n[source,java]\n----\nstatic final Date SOME_PAYLOAD = new Date();\n\nstatic final String SOME_HEADER_VALUE = \"bar\";\n\nstatic final String SOME_HEADER_KEY = \"test.foo\";\n...\nMessage<?> message = MessageBuilder.withPayload(SOME_PAYLOAD)\n .setHeader(SOME_HEADER_KEY, SOME_HEADER_VALUE)\n .build();\nMessageHandler handler = mock(MessageHandler.class);\nhandler.handleMessage(message);\nverify(handler).handleMessage(messageWithPayload(SOME_PAYLOAD));\nverify(handler).handleMessage(messageWithPayload(is(instanceOf(Date.class))));\n...\nMessageChannel channel = mock(MessageChannel.class);\nwhen(channel.send(messageWithHeaderEntry(SOME_HEADER_KEY, is(instanceOf(Short.class)))))\n .thenReturn(true);\nassertThat(channel.send(message), is(false));\n----\n\n[[assertj-conditions-and-predicates]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Hamcrest and Mockito Matchers", "heading_level": 3, "file_order": 273, "section_index": 6, "content_hash": "3a41402bc6e3132d273f5859b7a4640d3d0a0830577a8ef9c9d9988eae99dcef", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:3286cf71d85009f36be995460477fdb8e9c6bec938f1634ebe4feab3f488b6a2", "content": "Starting with version 5.2, the `MessagePredicate` is introduced to be used in the AssertJ `matches()` assertion.\nIt requires a `Message` object as an expectation.\nAnd also ot can be configured with headers to exclude from expectation as well as from actual message to assert.\n\n[[test-context]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "AssertJ conditions and predicates", "heading_level": 3, "file_order": 273, "section_index": 7, "content_hash": "3286cf71d85009f36be995460477fdb8e9c6bec938f1634ebe4feab3f488b6a2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:b675182c5ba952ca1e6fdc0a87b52fbae1d5c32b22e8775a21bb0237310dd9a9", "content": "Typically, tests for Spring applications use the Spring Test Framework.\nSince Spring Integration is based on the Spring Framework foundation, everything we can do with the Spring Test Framework also applies when testing integration flows.\nThe `org.springframework.integration.test.context` package provides some components for enhancing the test context for integration needs.\nFirst we configure our test class with a `@SpringIntegrationTest` annotation to enable the Spring Integration Test Framework, as the following example shows:\n\n[source,java]\n----\n@SpringJUnitConfig\n@SpringIntegrationTest(noAutoStartup = {\"inboundChannelAdapter\", \"*Source*\"})\npublic class MyIntegrationTests {\n\n @Autowired\n private MockIntegrationContext mockIntegrationContext;\n\n}\n----\n\nThe `@SpringIntegrationTest` annotation populates a `MockIntegrationContext` bean, which you can autowire to the test class to access its methods.\nWith the `noAutoStartup` option, the Spring Integration Test Framework prevents endpoints that are normally `autoStartup=true` from starting.\nThe endpoints are matched to the provided patterns, which support the following simple pattern styles: `xxx*`, `*xxx`, `*xxx*`, and `xxx*yyy`.\n\nThis is useful when we would like to not have real connections to the target systems from inbound channel adapters, (for example, an AMQP Inbound Gateway, JDBC Polling Channel Adapter, WebSocket Message Producer in client mode, and so on).\n\nThe `@SpringIntegrationTest` honors the `org.springframework.test.context.NestedTestConfiguration` semantics, hence it can be declared on the outer class (or even its super class) - and `@SpringIntegrationTest` environment will be available to inherited `@Nested` tests.\n\nThe `MockIntegrationContext` is meant to be used in the target test cases for modifications to beans in the real application context.\nFor example, endpoints that have `autoStartup` overridden to `false` can be replaced with mocks, as the following example shows:\n\n[source,java]\n----\n@Test\npublic void testMockMessageSource() {\n MessageSource<String> messageSource = () -> new GenericMessage<>(\"foo\");\n\n this.mockIntegrationContext.substituteMessageSourceFor(\"mySourceEndpoint\", messageSource);\n\n Message<?> receive = this.results.receive(10_000);\n assertNotNull(receive);\n}\n----\n\nNOTE: The `mySourceEndpoint` refers here to the bean name of the `SourcePollingChannelAdapter` for which we replace the real `MessageSource` with our mock.\nSimilarly, the `MockIntegrationContext.substituteMessageHandlerFor()` expects a bean name for the `IntegrationConsumer`, which wraps a `MessageHandler` as an endpoint.\n\nAfter test is performed you can restore the state of endpoint beans to the real configuration using `MockIntegrationContext.resetBeans()`:\n\n[source,java]\n----\n@AfterEach\npublic void tearDown() {\n this.mockIntegrationContext.resetBeans();\n}\n----\n\nStarting with version 6.3, the `MockIntegrationContext.substituteTriggerFor()` API has been introduced.\nThis can be used to replace the real `Trigger` in the `AbstractPollingEndpoint`.\nFor example the production configuration may rely on a daily (or even weekly) cron schedule.\nAny custom `Trigger` can be injected into the target endpoint to mitigate the time span.\nFor example, the mentioned above <<using-onlyoncetrigger, `OnlyOnceTrigger`>> suggests a behavior to schedule a polling task immediately and do that only once.\n\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/test/context/MockIntegrationContext.html[Javadoc] for more information.\n\n[[testing-mocks]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Spring Integration and the Test Context", "heading_level": 2, "file_order": 273, "section_index": 8, "content_hash": "b675182c5ba952ca1e6fdc0a87b52fbae1d5c32b22e8775a21bb0237310dd9a9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:3e27ed25e4babdb317d976ceb1ca3880cb34488a3e067326b27c97159aa79431", "content": "The `org.springframework.integration.test.mock` package offers tools and utilities for mocking, stubbing, and verification of activity on Spring Integration components.\nThe mocking functionality is fully based on and compatible with the well-known Mockito Framework.\n(The current Mockito transitive dependency is on version 2.5.x or higher.)\n\n[[mockintegration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Integration Mocks", "heading_level": 2, "file_order": 273, "section_index": 9, "content_hash": "3e27ed25e4babdb317d976ceb1ca3880cb34488a3e067326b27c97159aa79431", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:787086293a7727c53852d000edd0b3079c649b42ba19458b63f843ff90816d49", "content": "The `MockIntegration` factory provides an API to build mocks for Spring Integration beans that are parts of the integration flow (`MessageSource`, `MessageProducer`, `MessageHandler`, and `MessageChannel`).\nYou can use the target mocks during the configuration phase as well as in the target test method to replace the real endpoints before performing verifications and assertions, as the following example shows:\n\n[source,xml]\n----\n<int:inbound-channel-adapter id=\"inboundChannelAdapter\" channel=\"results\">\n <bean class=\"org.springframework.integration.test.mock.MockIntegration\" factory-method=\"mockMessageSource\">\n <constructor-arg value=\"a\"/>\n <constructor-arg>\n <array>\n <value>b</value>\n <value>c</value>\n </array>\n </constructor-arg>\n </bean>\n</int:inbound-channel-adapter>\n----\n\nThe following example shows how to use Java Configuration to achieve the same configuration as the preceding example:\n\n[source,java]\n----\n@InboundChannelAdapter(channel = \"results\")\n@Bean\npublic MessageSource<Integer> testingMessageSource() {\n return MockIntegration.mockMessageSource(1, 2, 3);\n}\n...\nStandardIntegrationFlow flow = IntegrationFlow\n .from(MockIntegration.mockMessageSource(\"foo\", \"bar\", \"baz\"))\n .<String, String>transform(String::toUpperCase)\n .channel(out)\n .get();\nIntegrationFlowRegistration registration = this.integrationFlowContext.registration(flow)\n .register();\n----\n\nFor this purpose, the aforementioned `MockIntegrationContext` should be used from the test, as the following example shows:\n\n[source,java]\n----\nthis.mockIntegrationContext.substituteMessageSourceFor(\"mySourceEndpoint\",\n MockIntegration.mockMessageSource(\"foo\", \"bar\", \"baz\"));\nMessage<?> receive = this.results.receive(10_000);\nassertNotNull(receive);\nassertEquals(\"FOO\", receive.getPayload());\n----\n\nUnlike the Mockito `MessageSource` mock object, the `MockMessageHandler` is a regular `AbstractMessageProducingHandler` extension with a chain API to stub handling for incoming messages.\nThe `MockMessageHandler` provides `handleNext(Consumer<Message<?>>)` to specify a one-way stub for the next request message.\nIt is used to mock message handlers that do not produce replies.\nThe `handleNextAndReply(Function<Message<?>, ?>)` is provided for performing the same stub logic for the next request message and producing a reply for it.\nThey can be chained to simulate any arbitrary request-reply scenarios for all expected request messages variants.\nThese consumers and functions are applied to the incoming messages, one at a time from the stack, until the last, which is then used for all remaining messages.\nThe behavior is similar to the Mockito `Answer` or `doReturn()` API.\n\nIn addition, you can supply a Mockito `ArgumentCaptor<Message<?>>` to the `MockMessageHandler` in a constructor argument.\nEach request message for the `MockMessageHandler` is captured by that `ArgumentCaptor`.\nDuring the test, you can use its `getValue()` and `getAllValues()` methods to verify and assert those request messages.\n\nThe `MockIntegrationContext` provides a `substituteMessageHandlerFor()` API that lets you replace the actual configured `MessageHandler` with a `MockMessageHandler` in the endpoint under test.\n\nThe following example shows a typical usage scenario:\n\n[source,java]\n----\nArgumentCaptor<Message<?>> messageArgumentCaptor = ArgumentCaptor.forClass(Message.class);\n\nMessageHandler mockMessageHandler =\n mockMessageHandler(messageArgumentCaptor)\n .handleNextAndReply(m -> m.getPayload().toString().toUpperCase());\n\nthis.mockIntegrationContext.substituteMessageHandlerFor(\"myService.serviceActivator\",\n mockMessageHandler);\nGenericMessage<String> message = new GenericMessage<>(\"foo\");\nthis.myChannel.send(message);\nMessage<?> received = this.results.receive(10000);\nassertNotNull(received);\nassertEquals(\"FOO\", received.getPayload());\nassertSame(message, messageArgumentCaptor.getValue());\n----\n\nNOTE: The regular `MessageHandler` mocking (or `MockMessageHandler`) has to be used even for a `ReactiveStreamsConsumer` with a `ReactiveMessageHandler` configuration.\n\nSee the https://docs.spring.io/spring-integration/api/org/springframework/integration/test/mock/MockIntegration.html[`MockIntegration`] and https://docs.spring.io/spring-integration/api/org/springframework/integration/test/mock/MockMessageHandler.html[`MockMessageHandler`] Javadoc for more information.\n\n[[testing-other-resources]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "MockIntegration", "heading_level": 3, "file_order": 273, "section_index": 10, "content_hash": "787086293a7727c53852d000edd0b3079c649b42ba19458b63f843ff90816d49", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:edf4baacbb0c70721f30041c098582217d088fa2cff469fcbc9947dee578859b", "content": "As well as exploring the test cases in the framework itself, the https://github.com/spring-projects/spring-integration-samples[Spring Integration Samples repository] has some sample applications specifically made to show testing, such as `testing-examples` and `advanced-testing-examples`.\nIn some cases, the samples themselves have comprehensive end-to-end tests, such as the `file-split-ftp` sample.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Other Resources", "heading_level": 2, "file_order": 273, "section_index": 11, "content_hash": "edf4baacbb0c70721f30041c098582217d088fa2cff469fcbc9947dee578859b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:fd20d7310805543bf58f5b63bfa2b5399f390c518ca84cd2fcf78a40a2e7ba05", "content": "[[transactions]]\n\nThis chapter covers Spring Integration's support for transactions.\nIt covers the following topics:\n\n* xref:transactions.adoc#understanding-transaction[Understanding Transactions in Message flows]\n* xref:transactions.adoc#transaction-boundaries[Transaction Boundaries]\n* xref:transactions.adoc#transaction-synchronization[Transaction Synchronization]\n* xref:transactions.adoc#pseudo-transactions[Pseudo Transactions]\n\n[[understanding-transaction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transactions.adoc", "title": "transactions", "heading": "transactions", "heading_level": 1, "file_order": 274, "section_index": 0, "content_hash": "fd20d7310805543bf58f5b63bfa2b5399f390c518ca84cd2fcf78a40a2e7ba05", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transactions.adoc"}}
{"id": "sha256:b63f94a524f9e0be6a6dfc4839176a03fe39cf60079c7fe9674e014a65063743", "content": "Spring Integration exposes several hooks to address the transactional needs of your message flows.\nTo better understand these hooks and how you can benefit from them, we must first revisit the six mechanisms that you can use to initiate message flows and see how you can address the transactional needs of these flows within each of these mechanisms.\n\nThe following six mechanisms initiate a message flow (detail for each are provided throughout this manual):\n\n* Gateway proxy: A basic messaging gateway.\n\n* Message channel: Direct interactions with `MessageChannel` methods (for example, `channel.send(message)`).\n\n* Message publisher: The way to initiate a message flow as the by-product of method invocations on Spring beans.\n\n* Inbound channel adapters and gateways: The way to initiate a message flow based on connecting third-party system with the Spring Integration messaging system, (for example, `[JmsMessage] -> Jms Inbound Adapter[SI Message] -> SI Channel`).\n\n* Scheduler: The way to initiate a message flow based on scheduling events distributed by a pre-configured scheduler.\n\n* Poller: Similar to the scheduler, this is the way to initiate message flow based on scheduling or interval-based events distributed by a pre-configured poller.\n\nWe can split these six mechanisms into two general categories:\n\n* Message flows initiated by a user process: Example scenarios in this category would be invoking a gateway method or explicitly sending a `Message` to a `MessageChannel`.\nIn other words, these message flows depend on a third party process (such as some code that you wrote) to be initiated.\n\n* Message flows initiated by a daemon process: Example scenarios in this category include a Poller polling a message queue to initiate a new message flow with the polled message or a scheduler scheduling the process by creating a new message and initiating a message flow at a predefined time.\n\nClearly the gateway proxy, `MessageChannel.send(...)` and `MessagePublisher` all belong to the first category, and inbound adapters and gateways, scheduler, and poller belong to the second category.\n\nSo, how can you address transactional needs in various scenarios within each category, and is there a need for Spring Integration to provide something explicit with regard to transactions for a particular scenario?\nOr can you use Spring's transaction support instead?\n\nSpring itself provides first-class support for transaction management.\nSo our goal here is not to provide something new but rather use Spring to benefit from its existing support for transactions.\nIn other words, as a framework, we must expose hooks to Spring's transaction management functionality.\nHowever, since Spring Integration configuration is based on Spring configuration, we need not always expose these hooks, because Spring already exposes them .\nAfter all, every Spring Integration component is a Spring Bean.\n\nWith this goal in mind, we can again consider the two scenarios: message flows initiated by a user process and message flows initiated by a daemon.\n\nMessage flows that are initiated by a user process and configured in a Spring application context are subject to the usual transactional configuration of such processes.\nTherefore, they need not be explicitly configured by Spring Integration to support transactions.\nThe transaction could and should be initiated through Spring's standard transaction support.\nThe Spring Integration message flow naturally honors the transactional semantics of the components because it is itself configured by Spring.\nFor example, a gateway or service activator method could be annotated with `@Transactional`, or a `TransactionInterceptor` could be defined in an XML configuration with a pointcut expression that points to specific methods that should be transactional.\nThe bottom line is that you have full control over transaction configuration and boundaries in these scenarios.\n\nHowever, things are a bit different when it comes to message flows initiated by a daemon process.\nAlthough configured by the developer, these flows do not directly involve a human or some other process to be initiated.\nThese are trigger-based flows that are initiated by a trigger process (a daemon process) based on the configuration of the process.\nFor example, we could have a scheduler initiate a message flow every Friday night.\nWe can also configure a trigger that initiates a message flow every second and so on.\nAs a result, we need a way to let these trigger-based processes know of our intention to make the resulting message flows be transactional, so that a Transaction context can be created whenever a new message flow is initiated.\nIn other words, we need to expose some transaction configuration, but only enough to delegate to the transaction support already provided by Spring (as we do in other scenarios).\n\n[[transaction-poller]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transactions.adoc", "title": "transactions", "heading": "Understanding Transactions in Message flows", "heading_level": 2, "file_order": 274, "section_index": 1, "content_hash": "b63f94a524f9e0be6a6dfc4839176a03fe39cf60079c7fe9674e014a65063743", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transactions.adoc"}}
{"id": "sha256:d16a2518f99afa02ea57c8819194f76f1d08e5759fbf0911019950d85934c7fd", "content": "Spring Integration provides transactional support for pollers.\nPollers are a special type of component because, within a poller task, we can call `receive()` against a resource that is itself transactional, thus including the `receive()` call in the boundaries of the transaction, which lets it be rolled back in case of a task failure.\nIf we were to add the same support for channels, the added transactions would affect all downstream components starting with the `send()` call.\nThat provides a rather wide scope for transaction demarcation without any strong reason, especially when Spring already provides several ways to address the transactional needs of any component downstream.\nHowever, the `receive()` method being included in a transaction boundary is the \"`strong reason`\" for pollers.\n\nAny time you configure a Poller, you can provide transactional configuration by using the `transactional` child element and its attributes, as the following example shows:\n\n[source,xml]\n----\n<int:poller max-messages-per-poll=\"1\" fixed-rate=\"1000\">\n <transactional transaction-manager=\"txManager\"\n isolation=\"DEFAULT\"\n propagation=\"REQUIRED\"\n read-only=\"true\"\n timeout=\"1000\"/>\n</poller>\n----\n\nThe preceding configuration looks similar to a native Spring transaction configuration.\nYou must still provide a reference to a transaction manager and either specify transaction attributes or rely on defaults (for example, if the 'transaction-manager' attribute is not specified, it defaults to the bean named 'transactionManager').\nInternally, the process is wrapped in Spring's native transaction, where `TransactionInterceptor` is responsible for handling transactions.\nFor more information on how to configure a transaction manager, the types of transaction managers (such as JTA, Datasource, and others), and other details related to transaction configuration, see the https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction[Spring Framework Reference Guide].\n\nWith the preceding configuration, all message flows initiated by this poller are transactional.\nFor more information and details on a poller's transactional configuration, see xref:jdbc/inbound-channel-adapter.adoc#jdbc-polling-transactions[Polling and Transactions].\n\nAlong with transactions, you might need to address several more cross-cutting concerns when you run a poller.\nTo help with that, the poller element accepts an `<advice-chain>` child element, which lets you define a custom chain of advice instances to be applied on the Poller.\n(See xref:polling-consumer.adoc#pollable-message-source[Pollable Message Source] for more details.)\nIn Spring Integration 2.0, the Poller went through a refactoring effort and now uses a proxy mechanism to address transactional concerns as well as other cross-cutting concerns.\nOne of the significant changes evolving from this effort is that we made the `<transactional>` and `<advice-chain>` elements be mutually exclusive.\nThe rationale behind this is that, if you need more than one advice and one of them is Transaction advice, you can include it in the `<advice-chain>` with the same convenience as before but with much more control, since you now have an option to position the advice in the desired order.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<int:poller max-messages-per-poll=\"1\" fixed-rate=\"10000\">\n <advice-chain>\n <ref bean=\"txAdvice\"/>\n <ref bean=\"someOtherAdviceBean\" />\n <beans:bean class=\"foo.bar.SampleAdvice\"/>\n </advice-chain>\n</poller>\n\n<tx:advice id=\"txAdvice\" transaction-manager=\"txManager\">\n <tx:attributes>\n <tx:method name=\"get*\" read-only=\"true\"/>\n <tx:method name=\"*\"/>\n </tx:attributes>\n</tx:advice>\n----\n\nThe preceding example shows a basic XML-based configuration of Spring Transaction advice (`txAdvice`) and included it within the `<advice-chain>` defined by the Poller.\nIf you need to address only the transactional concerns of the poller, you can still use the `<transactional>` element as a convenience.\n\n[[transaction-boundaries]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transactions.adoc", "title": "transactions", "heading": "Poller Transaction Support", "heading_level": 3, "file_order": 274, "section_index": 2, "content_hash": "d16a2518f99afa02ea57c8819194f76f1d08e5759fbf0911019950d85934c7fd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transactions.adoc"}}
{"id": "sha256:ff8c2fc416fd32c9eaed8bc5694a3b91fbf8dc37fa8db324d5f1ad32175fbe52", "content": "Another important factor is the boundaries of Transactions within a Message flow.\nWhen a transaction is started, the transaction context is bound to the current thread.\nSo regardless of how many endpoints and channels you have in your Message flow, your transaction context will be preserved as long as you are ensuring that the flow continues on the same thread.\nAs soon as you break it by introducing a _Pollable Channel_ or _Executor Channel_ or initiate a new thread manually in some service, the Transactional boundary will be broken as well.\nEssentially, the Transaction will END right there, and if a successful handoff has transpired between the threads, the flow would be considered a success, and a COMMIT signal would be sent even though the flow will continue and might still result in an Exception somewhere downstream.\nIf such a flow were synchronous, that Exception could be thrown back to the initiator of the Message flow who is also the initiator of the transactional context, and the transaction would result in a ROLLBACK.\nThe middle ground is to use transactional channels at any point where a thread boundary is being broken.\nFor example, you can use a Queue-backed Channel that delegates to a transactional MessageStore strategy, or you could use a JMS-backed channel.\n\n[[transaction-synchronization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transactions.adoc", "title": "transactions", "heading": "Transaction Boundaries", "heading_level": 2, "file_order": 274, "section_index": 3, "content_hash": "ff8c2fc416fd32c9eaed8bc5694a3b91fbf8dc37fa8db324d5f1ad32175fbe52", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transactions.adoc"}}
{"id": "sha256:e271e336acdf6b37b8e2e3980c1584da43519a52bfa5640f692fbeb73599db2a", "content": "In some environments, it helps to synchronize operations with a transaction that encompasses the entire flow.\nFor example, consider a `<file:inbound-channel-adapter/>` at the start of a flow that performs a number of database updates.\nIf the transaction commits, we might want to move the file to a `success` directory, while we might want to move it to a `failure` directory if the transaction rolls back.\n\nSpring Integration 2.2 introduced the capability of synchronizing these operations with a transaction.\nIn addition, you can configure a `PseudoTransactionManager` if you do not have a 'real' transaction but still want to perform different actions on success or failure.\nFor more information, see xref:transactions.adoc#pseudo-transactions[Pseudo Transactions].\n\nThe following listing shows the key strategy interfaces for this feature:\n\n[source,java]\n----\npublic interface TransactionSynchronizationFactory {\n\n TransactionSynchronization create(Object key);\n}\n\npublic interface TransactionSynchronizationProcessor {\n\n void processBeforeCommit(IntegrationResourceHolder holder);\n\n void processAfterCommit(IntegrationResourceHolder holder);\n\n void processAfterRollback(IntegrationResourceHolder holder);\n\n}\n----\n\nThe factory is responsible for creating a https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/support/TransactionSynchronization.html[`TransactionSynchronization`] object.\nYou can implement your own or use the one provided by the framework: `DefaultTransactionSynchronizationFactory`.\nThis implementation returns a `TransactionSynchronization` that delegates to a default implementation of `TransactionSynchronizationProcessor`: `ExpressionEvaluatingTransactionSynchronizationProcessor`.\nThis processor supports three SpEL expressions: `beforeCommitExpression`, `afterCommitExpression`, and `afterRollbackExpression`.\n\nThese actions should be self-explanatory to those familiar with transactions.\nIn each case, the `#root` variable is the original `Message`.\nIn some cases, other SpEL variables are made available, depending on the `MessageSource` being polled by the poller.\nFor example, the `MongoDbMessageSource` provides the `#mongoTemplate` variable, which references the message source's `MongoTemplate`.\nSimilarly, the `RedisStoreMessageSource` provides the `#store` variable, which references the `RedisStore` created by the poll.\n\nTo enable the feature for a particular poller, you can provide a reference to the `TransactionSynchronizationFactory` on the poller's `<transactional/>` element by using the `synchronization-factory` attribute.\n\nStarting with version 5.0, Spring Integration provides `PassThroughTransactionSynchronizationFactory`, which is applied by default to polling endpoints when no `TransactionSynchronizationFactory` is configured but an advice of type `TransactionInterceptor` exists in the advice chain.\nWhen using any out-of-the-box `TransactionSynchronizationFactory` implementation, polling endpoints bind a polled message to the current transactional context and provide it as a `failedMessage` in a `MessagingException` if an exception is thrown after the transaction advice.\nWhen using a custom transaction advice that does not implement `TransactionInterceptor`, you can explicitly configure a `PassThroughTransactionSynchronizationFactory` to achieve this behavior.\nIn either case, the `MessagingException` becomes the payload of the `ErrorMessage` that is sent to the `errorChannel`, and the cause is the raw exception thrown by the advice.\nPreviously, the `ErrorMessage` had a payload that was the raw exception thrown by the advice and did not provide a reference to the `failedMessage` information, making it difficult to determine the reasons for the transaction commit problem.\n\nTo simplify configuration of these components, Spring Integration provides namespace support for the default factory.\nThe following example shows how to use the namespace to configure a file inbound channel adapter:\n\n[source,xml]\n----\n<int-file:inbound-channel-adapter id=\"inputDirPoller\"\n channel=\"someChannel\"\n directory=\"/foo/bar\"\n filter=\"filter\"\n comparator=\"testComparator\">\n <int:poller fixed-rate=\"5000\">\n <int:transactional transaction-manager=\"transactionManager\" synchronization-factory=\"syncFactory\" />\n </int:poller>\n</int-file:inbound-channel-adapter>\n\n<int:transaction-synchronization-factory id=\"syncFactory\">\n <int:after-commit expression=\"payload.renameTo(new java.io.File('/success/' + payload.name))\"\n channel=\"committedChannel\" />\n <int:after-rollback expression=\"payload.renameTo(new java.io.File('/failed/' + payload.name))\"\n channel=\"rolledBackChannel\" />\n</int:transaction-synchronization-factory>\n----\n\nThe result of the SpEL evaluation is sent as the payload to either `committedChannel` or `rolledBackChannel` (in this case, this would be `Boolean.TRUE` or `Boolean.FALSE` -- the result of the `java.io.File.renameTo()` method call).\n\nIf you wish to send the entire payload for further Spring Integration processing, use the 'payload' expression.\n\n[IMPORTANT]\n=====\nIt is important to understand that this synchronizes the actions with a transaction.\nIt does not make a resource that is not inherently transactional actually be transactional.\nInstead, the transaction, be it JDBC or otherwise, is started before the poll and either committed or rolled back when the flow completes, followed by the synchronized action.\n\nIf you provide a custom `TransactionSynchronizationFactory`, it is responsible for creating a resource synchronization that causes the bound resource to be unbound automatically when the transaction completes.\nThe default `TransactionSynchronizationFactory` does so by returning a subclass of `ResourceHolderSynchronization`, with the default `shouldUnbindAtCompletion()` returning `true`.\n=====\n\nIn addition to the `after-commit` and `after-rollback` expressions, `before-commit` is also supported.\nIn that case, if the evaluation (or downstream processing) throws an exception, the transaction is rolled back instead of being committed.\n\n[[pseudo-transactions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transactions.adoc", "title": "transactions", "heading": "Transaction Synchronization", "heading_level": 2, "file_order": 274, "section_index": 4, "content_hash": "e271e336acdf6b37b8e2e3980c1584da43519a52bfa5640f692fbeb73599db2a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transactions.adoc"}}
{"id": "sha256:188088573d458dd695a1da794d5e4eebed99b92284978014863fa6ac432aad31", "content": "After reading the xref:transactions.adoc#transaction-synchronization[Transaction Synchronization] section, you might think it would be useful to take these 'success' or 'failure' actions when a flow completes, even if there is no \"`real`\" transactional resources (such as JDBC) downstream of the poller.\nFor example, consider a \"`<file:inbound-channel-adapter/>`\" followed by an \"`<ftp:outbout-channel-adapter/>`\".\nNeither of these components is transactional, but we might want to move the input file to different directories, based on the success or failure of the FTP transfer.\n\nTo provide this functionality, the framework provides a `PseudoTransactionManager`, enabling the above configuration even when there is no real transactional resource involved.\nIf the flow completes normally, the `beforeCommit` and `afterCommit` synchronizations are called.\nOn failure, the `afterRollback` synchronization is called.\nBecause it is not a real transaction, no actual commit or rollback occurs.\nThe pseudo transaction is a vehicle used to enable the synchronization features.\n\nTo use a `PseudoTransactionManager`, you can define it as a <bean/>, in the same way you would configure a real transaction manager.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<bean id=\"transactionManager\" class=\"o.s.i.transaction.PseudoTransactionManager\" />\n----\n\n[[reactive-transactions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transactions.adoc", "title": "transactions", "heading": "Pseudo Transactions", "heading_level": 2, "file_order": 274, "section_index": 5, "content_hash": "188088573d458dd695a1da794d5e4eebed99b92284978014863fa6ac432aad31", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transactions.adoc"}}
{"id": "sha256:968bc7b221944af8eefd4bbde57ae32fdfe0d6a19d0b59bf77d94fdb9a405c4d", "content": "Starting with version 5.3, a `ReactiveTransactionManager` can also be used together with a `TransactionInterceptor` advice for endpoints returning a reactive type.\nThis includes `MessageSource` and `ReactiveMessageHandler` implementations (e.g. `ReactiveMongoDbMessageSource`) which produce a message with a `Flux` or `Mono` payload.\nAll other reply-producing message handler implementations can rely on a `ReactiveTransactionManager` when their reply payload is also some reactive type.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transactions.adoc", "title": "transactions", "heading": "Reactive Transactions", "heading_level": 2, "file_order": 274, "section_index": 6, "content_hash": "968bc7b221944af8eefd4bbde57ae32fdfe0d6a19d0b59bf77d94fdb9a405c4d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transactions.adoc"}}
{"id": "sha256:92dcdebfe9e2220c06dda86890953ec120a0325a30c6623c6584f725d23b9082", "content": "[[transformer]]\n\nMessage transformers play a very important role in enabling the loose-coupling of message producers and message consumers.\nRather than requiring every message-producing component to know what type is expected by the next consumer, you can add transformers between those components.\nGeneric transformers, such as one that converts a `String` to an XML Document, are also highly reusable.\n\nFor some systems, it may be best to provide a https://www.enterpriseintegrationpatterns.com/CanonicalDataModel.html[canonical data model], but Spring Integration's general philosophy is not to require any particular format.\nRather, for maximum flexibility, Spring Integration aims to provide the simplest possible model for extension.\nAs with the other endpoint types, the use of declarative configuration in XML or Java annotations enables simple POJOs to be adapted for the role of message transformers.\nThe rest of this chapter describes these configuration options.\n\nNOTE: For the sake of maximizing flexibility, Spring does not require XML-based message payloads.\nNevertheless, the framework does provide some convenient transformers for dealing with XML-based payloads if that is indeed the right choice for your application.\nFor more information on those transformers, see xref:xml.adoc[XML Support - Dealing with XML Payloads].\n\n[[configuring-a-transformer-with-java-and-other-dsls]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "transformer", "heading_level": 1, "file_order": 275, "section_index": 0, "content_hash": "92dcdebfe9e2220c06dda86890953ec120a0325a30c6623c6584f725d23b9082", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:0316cb67ae83cb2d020e6f8804375028e24422edf0391c1ccfd8f4fccabbff7e", "content": "For simple Java & Annotation configuration, the Spring bean POJO method must be marked with a `@Transformer` annotation and the framework calls it when messages are consumed from an input channel:\n\n[source,java]\n----\npublic class SomeService {\n\n @Transformer(inputChannel = \"transformChannel\", outputChannel = \"nextServiceChannel\")\n public OutputData exampleTransformer(InputData payload) {\n ...\n }\n\n}\n----\n\nSee more information in the xref:configuration/annotations.adoc[Annotation Support].\n\nFor Java, Groovy or Kotlin DSLs, the `.transform()` operator of an `IntegrationFlow` represents a transformer endpoint:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return IntegrationFlow\n .from(\"transformChannel\")\n .transform(someService, \"exampleTransformer\")\n .channel(\"nextServiceChannel\")\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun someFlow() =\n integrationFlow(\"transformChannel\") {\n transform(someService, \"exampleTransformer\")\n channel(\"nextServiceChannel\")\n }\n----\n\nGroovy DSL::\n+\n[source, groovy, role=\"secondary\"]\n----\n@Bean\nsomeFlow() {\n integrationFlow 'transformChannel',\n {\n transform someService, 'exampleTransformer'\n channel 'nextServiceChannel'\n }\n}\n----\n======\n\nSee more information about the DSLs in the respective chapters:\n\n* xref:dsl.adoc#java-dsl[Java DSL]\n* xref:kotlin-dsl.adoc[Kotlin DSL]\n* xref:groovy-dsl.adoc[Groovy DSL]\n\n[[transformer-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "Configuring a Transformer with Java and other DSLs", "heading_level": 2, "file_order": 275, "section_index": 1, "content_hash": "0316cb67ae83cb2d020e6f8804375028e24422edf0391c1ccfd8f4fccabbff7e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:65bd023cd40aca741d95a1e4e76d218ada813e02fc633f135572b4927b2b9678", "content": "The `<transformer>` element is used to create a message-transforming endpoint.\nIn addition to `input-channel` and `output-channel` attributes, it requires a `ref` attribute.\nThe `ref` may either point to an object that contains the `@Transformer` annotation on a single method (see xref:transformer.adoc#transformer-annotation[Configuring a Transformer with Annotations]), or it may be combined with an explicit method name value provided in the `method` attribute.\n\n[source,xml]\n----\n<int:transformer id=\"testTransformer\" ref=\"testTransformerBean\" input-channel=\"inChannel\"\n method=\"transform\" output-channel=\"outChannel\"/>\n<beans:bean id=\"testTransformerBean\" class=\"org.foo.TestTransformer\" />\n----\n\nUsing a `ref` attribute is generally recommended if the custom transformer handler implementation can be reused in other `<transformer>` definitions.\nHowever, if the custom transformer handler implementation should be scoped to a single definition of the `<transformer>`, you can define an inner bean definition, as the following example shows:\n\n[source,xml]\n----\n<int:transformer id=\"testTransformer\" input-channel=\"inChannel\" method=\"transform\"\n output-channel=\"outChannel\">\n <beans:bean class=\"org.foo.TestTransformer\"/>\n</transformer>\n----\n\nNOTE: Using both the `ref` attribute and an inner handler definition in the same `<transformer>` configuration is not allowed, as it creates an ambiguous condition and results in an exception being thrown.\n\nIMPORTANT: If the `ref` attribute references a bean that extends `AbstractMessageProducingHandler` (such as transformers provided by the framework itself), the configuration is optimized by injecting the output channel into the handler directly.\nIn this case, each `ref` must be to a separate bean instance (or a `prototype`-scoped bean) or use the inner `<bean/>` configuration type.\nIf you inadvertently reference the same message handler from multiple beans, you get a configuration exception.\n\nWhen using a POJO, the method that is used for transformation may expect either the `Message` type or the payload type of inbound messages.\nIt may also accept message header values either individually or as a full map by using the `@Header` and `@Headers` parameter annotations, respectively.\nThe return value of the method can be any type.\nIf the return value is itself a `Message`, that is passed along to the transformer's output channel.\n\nAs of Spring Integration 2.0, a message transformer's transformation method can no longer return `null`.\nReturning `null` results in an exception (a `MessageTransformationException` to be precise), because a message transformer should always be expected to transform each source message into a valid target message.\nIn other words, a message transformer should not be used as a message filter, because there is a dedicated `<filter>` option for that.\nHowever, if you do need this type of behavior (where a component might return `null` and that should not be considered an error), you could use a service activator.\nThe service activator's `requiresReply` value is `false` by default, but that can be set to `true` in order to have exceptions thrown for `null` return values, as with the transformer.\nThe transformer's `requiresReply` property cannot be modified: it is always `true` since the transformer pattern definition does not allow nulls for replies.\n\n[[transformers-and-spring-expression-language-spel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "Configuring a Transformer with XML", "heading_level": 2, "file_order": 275, "section_index": 2, "content_hash": "65bd023cd40aca741d95a1e4e76d218ada813e02fc633f135572b4927b2b9678", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:1c83d196131418bf488fb1a88cb7154d50de38cbf2344fecca5d21a634d5b104", "content": "Like routers, aggregators, and other components, as of Spring Integration 2.0, transformers can also benefit from https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#expressions[SpEL support] whenever transformation logic is relatively simple.\nThe following example shows how to use a SpEL expression:\n\n[source,xml]\n----\n<int:transformer input-channel=\"inChannel\"\n\toutput-channel=\"outChannel\"\n\texpression=\"payload.toUpperCase() + '- [' + T(System).currentTimeMillis() + ']'\"/>\n----\n\nThe preceding example transforms the payload without writing a custom transformer.\nOur payload (assumed to be a `String`) is upper-cased, concatenated with the current timestamp, and has some formatting applied.\n\n[[common-transformers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "Transformers and Spring Expression Language (SpEL)", "heading_level": 2, "file_order": 275, "section_index": 3, "content_hash": "1c83d196131418bf488fb1a88cb7154d50de38cbf2344fecca5d21a634d5b104", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:a161c2765aed93267febf3027be5e1d3262813537523efbbf337ea6ca4d545d3", "content": "Spring Integration provides a few transformer implementations.\n\n[[object-to-string-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "Common Transformers", "heading_level": 2, "file_order": 275, "section_index": 4, "content_hash": "a161c2765aed93267febf3027be5e1d3262813537523efbbf337ea6ca4d545d3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:1c21d7328952c3b5692eaa9d2e8c0cf4fd9e8c3e912db8a7849db273766b5f08", "content": "Because it is fairly common to use the `toString()` representation of an `Object`, Spring Integration provides an `ObjectToStringTransformer` (see also the `Transformers` factory) where the output is a `Message` with a String `payload`.\nThat `String` is the result of invoking the `toString()` operation on the inbound Message's payload.\nThe following example shows how to declare an instance of the object-to-string transformer:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return IntegrationFlow\n .from(\"in\")\n .transform(Transformers.objectToString())\n .channel(\"out\")\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun someFlow() =\n integrationFlow(\"in\") {\n transform(Transformers.objectToString())\n channel(\"out\")\n }\n----\n\nGroovy DSL::\n+\n[source, groovy, role=\"secondary\"]\n----\n@Bean\nsomeFlow() {\n integrationFlow 'in',\n {\n transform Transformers.objectToString()\n channel 'out'\n }\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:object-to-string-transformer input-channel=\"in\" output-channel=\"out\"/>\n----\n======\n\nA potential use for this transformer would be sending some arbitrary object to the 'outbound-channel-adapter' in the `file` namespace.\nWhereas that channel adapter only supports `String`, byte-array, or `java.io.File` payloads by default, adding this transformer immediately before the adapter handles the necessary conversion.\nThat works fine as long as the result of the `toString()` call is what you want to be written to the file.\nOtherwise, you can provide a custom POJO-based transformer by using the generic 'transformer' element shown previously.\n\nTIP: When debugging, this transformer is not typically necessary, since the `logging-channel-adapter` is capable of logging the message payload.\nSee xref:channel/configuration.adoc#channel-wiretap[Wire Tap] for more detail.\n\nThe object-to-string transformer is very simple.\nIt invokes `toString()` on the inbound payload.\nSince Spring Integration 3.0, there are two exceptions to this rule:\n\n* If the payload is a `char[]`, it invokes `new String(payload)`.\n* If the payload is a `byte[]`, it invokes `new String(payload, charset)`, where `charset` is UTF-8 by default.\nThe `charset` can be modified by supplying the charset attribute on the transformer.\n\nFor more sophistication (such as selection of the charset dynamically, at runtime), you can use a SpEL expression-based transformer instead, as the following example shows:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return IntegrationFlow\n .from(\"in\")\n .transform(\"new String(payload, headers['myCharset']\")\n .channel(\"out\")\n .get();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:transformer input-channel=\"in\" output-channel=\"out\"\n expression=\"new String(payload, headers['myCharset']\" />\n----\n======\n\nIf you need to serialize an `Object` to a byte array or deserialize a byte array back into an `Object`, Spring Integration provides symmetrical serialization transformers.\nThese use standard Java serialization by default, but you can provide an implementation of Spring `Serializer` or `Deserializer` strategies by using the `serializer` and `deserializer` attributes, respectively.\nSee also the `Transformers` factory class.\nThe following example shows how to use Spring's serializer and deserializer:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return IntegrationFlow\n .from(\"objectsIn\")\n .transform(Transformers.serializer())\n .channel(\"bytesOut\")\n .channel(\"bytesIn\")\n .transform(Transformers.deserializer(\"com.mycom.*\", \"com.yourcom.*\"))\n .channel(\"objectsOut\")\n .get();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:payload-serializing-transformer input-channel=\"objectsIn\" output-channel=\"bytesOut\"/>\n\n<int:payload-deserializing-transformer input-channel=\"bytesIn\" output-channel=\"objectsOut\"\n allow-list=\"com.mycom.*,com.yourcom.*\"/>\n----\n======\n\nIMPORTANT: When deserializing data from untrusted sources, you should consider adding a `allow-list` of package and class patterns.\nBy default, all classes are deserialized.\n\n[[object-to-map-and-map-to-object-transformers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "Object-to-String Transformer", "heading_level": 3, "file_order": 275, "section_index": 5, "content_hash": "1c21d7328952c3b5692eaa9d2e8c0cf4fd9e8c3e912db8a7849db273766b5f08", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:cfa40c75ab93b0d0d05f17879a63f3b3f7402e4d1eb0ad1fd3648201e140858a", "content": "Spring Integration also provides `Object`-to-`Map` and `Map`-to-`Object` transformers, which use the JSON to serialize and de-serialize the object graphs.\nThe object hierarchy is introspected to the most primitive types (`String`, `int`, and so on).\nThe path to this type is described with SpEL, which becomes the `key` in the transformed `Map`.\nThe primitive type becomes the value.\n\nConsider the following example:\n\n[source,java]\n----\npublic class Parent{\n private Child child;\n private String name;\n // setters and getters are omitted\n}\n\npublic class Child{\n private String name;\n private List<String> nickNames;\n // setters and getters are omitted\n}\n----\n\nThe two classes in the preceding example are transformed to the following `Map`:\n\n[source]\n----\n{person.name=George, person.child.name=Jenna, person.child.nickNames[0]=Jen ...}\n----\n\nThe JSON-based `Map` lets you describe the object structure without sharing the actual types, which lets you restore and rebuild the object graph into a differently typed object graph, as long as you maintain the structure.\n\nFor example, the preceding structure could be restored back to the following object graph by using the `Map`-to-`Object` transformer:\n\n[source,java]\n----\npublic class Father {\n private Kid child;\n private String name;\n // setters and getters are omitted\n}\n\npublic class Kid {\n private String name;\n private List<String> nickNames;\n // setters and getters are omitted\n}\n----\n\nIf you need to create a \"`structured`\" map, you can provide the `flatten` attribute.\nThe default is 'true'.\nIf you set it to 'false', the structure is a `Map` of `Map` objects.\n\nConsider the following example:\n\n[source,java]\n----\npublic class Parent {\n\tprivate Child child;\n\tprivate String name;\n\t// setters and getters are omitted\n}\n\npublic class Child {\n\tprivate String name;\n\tprivate List<String> nickNames;\n\t// setters and getters are omitted\n}\n----\n\nThe two classes in the preceding example are transformed to the following `Map`:\n\n[source]\n----\n{name=George, child={name=Jenna, nickNames=[Bimbo, ...]}}\n----\n\nTo configure these transformers, Spring Integration provides the respective XML component and Java DSL factory:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return IntegrationFlow\n .from(\"directInput\")\n .transform(Transformers.toMap())\n .channel(\"output\")\n .get();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:object-to-map-transformer input-channel=\"directInput\" output-channel=\"output\"/>\n----\n======\n\nYou can also set the `flatten` attribute to false, as follows:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return IntegrationFlow\n .from(\"directInput\")\n .transform(Transformers.toMap(false))\n .channel(\"output\")\n .get();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:object-to-map-transformer input-channel=\"directInput\" output-channel=\"output\" flatten=\"false\"/>\n----\n======\n\nSpring Integration provides XML namespace support for Map-to-Object, and the Java DSL factory has the `fromMap()` method, as the following example shows:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return IntegrationFlow\n .from(\"input\")\n .transform(Transformers.fromMap(org.something.Person.class))\n .channel(\"output\")\n .get();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:map-to-object-transformer input-channel=\"input\"\n output-channel=\"output\"\n type=\"org.something.Person\"/>\n----\n======\n\nAlternatively, you could use a `ref` attribute and a prototype-scoped bean, as the following example shows:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\nIntegrationFlow someFlow() {\n return IntegrationFlow\n .from(\"inputA\")\n .transform(Transformers.fromMap(\"person\"))\n .channel(\"outputA\")\n .get();\n}\n\n@Bean\n@Scope(\"prototype\")\nPerson person() {\n return new Person();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:map-to-object-transformer input-channel=\"inputA\"\n output-channel=\"outputA\"\n ref=\"person\"/>\n<bean id=\"person\" class=\"org.something.Person\" scope=\"prototype\"/>\n----\n======\n\nNOTE: The 'ref' and 'type' attributes are mutually exclusive.\nAlso, if you use the 'ref' attribute, you must point to a 'prototype' scoped bean.\nOtherwise, a `BeanCreationException` is thrown.\n\nStarting with version 5.0, you can supply the `ObjectToMapTransformer` with a customized `JsonObjectMapper` -- for when you need special formats for dates or nulls for empty collections (and other uses).\nSee xref:transformer.adoc#json-transformers[JSON Transformers] for more information about `JsonObjectMapper` implementations.\n\n[[stream-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "`Object`-to-`Map` and `Map`-to-`Object` Transformers", "heading_level": 3, "file_order": 275, "section_index": 6, "content_hash": "cfa40c75ab93b0d0d05f17879a63f3b3f7402e4d1eb0ad1fd3648201e140858a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:3f0e82524dfa4c5feb01c642227019a55396fe42a4152f0b098f4224dee0aa70", "content": "The `StreamTransformer` transforms `InputStream` payloads to a `byte[]`( or a `String` if a `charset` is provided).\n\nThe following example shows how to use the `stream-transformer` element in XML:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return IntegrationFlow\n .from(\"input\")\n .transform(Transformers.fromStream(\"UTF-8\"))\n .channel(\"output\")\n .get();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:stream-transformer input-channel=\"directInput\" output-channel=\"output\"/> <!-- byte[] -->\n\n<int:stream-transformer id=\"withCharset\" charset=\"UTF-8\"\n input-channel=\"charsetChannel\" output-channel=\"output\"/> <!-- String -->\n----\n======\n\nThe following example shows how to use the `StreamTransformer` class and the `@Transformer` annotation to configure a stream transformer in Java:\n\n[source, java]\n----\n@Bean\n@Transformer(inputChannel = \"stream\", outputChannel = \"data\")\npublic StreamTransformer streamToBytes() {\n return new StreamTransformer(); // transforms to byte[]\n}\n\n@Bean\n@Transformer(inputChannel = \"stream\", outputChannel = \"data\")\npublic StreamTransformer streamToString() {\n return new StreamTransformer(\"UTF-8\"); // transforms to String\n}\n----\n\n[[json-transformers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "Stream Transformer", "heading_level": 3, "file_order": 275, "section_index": 7, "content_hash": "3f0e82524dfa4c5feb01c642227019a55396fe42a4152f0b098f4224dee0aa70", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:131c887a26dd9b7f914a271f76c977434eef5835aaeb90b9a8ebfed33d178f95", "content": "Spring Integration provides Object-to-JSON and JSON-to-Object transformers.\nThe following pair of examples show how to declare them in XML:\n\n[source,xml]\n----\n<int:object-to-json-transformer input-channel=\"objectMapperInput\"/>\n\n<int:json-to-object-transformer input-channel=\"objectMapperInput\"\n type=\"foo.MyDomainObject\"/>\n----\n\nBy default, the transformers in the preceding listing use a vanilla `JsonObjectMapper`.\nIt is based on an implementation from the classpath.\nYou can provide your own custom `JsonObjectMapper` implementation with appropriate options or based on a required library (such as GSON), as the following example shows:\n\n[source,xml]\n----\n<int:json-to-object-transformer input-channel=\"objectMapperInput\"\n type=\"something.MyDomainObject\" object-mapper=\"customObjectMapper\"/>\n----\n\n[NOTE]\n====\nBeginning with version 3.0, the `object-mapper` attribute references an instance of a new strategy interface: `JsonObjectMapper`.\nThis abstraction lets multiple implementations of JSON mappers be used.\nImplementation that wraps https://github.com/FasterXML[Jackson 3] is provided, with the version being detected on the classpath.\nThe class is `JacksonJsonObjectMapper`, respectively.\n====\n\nYou may wish to consider using a `FactoryBean` or a factory method to create the `JsonObjectMapper` with the required characteristics.\nThe following example shows how to use such a factory:\n\n[source,java]\n----\npublic class ObjectMapperFactory {\n\n public static JacksonJsonObjectMapper getMapper() {\n ObjectMapper mapper = JsonMapper.builder()\n .configure(JsonReadFeature.ALLOW_JAVA_COMMENTS, true)\n .build();\n return new JacksonJsonObjectMapper(mapper);\n }\n}\n----\n\nThe following example shows how to do the same thing in XML:\n\n[source,xml]\n----\n<bean id=\"customObjectMapper\" class=\"something.ObjectMapperFactory\"\n factory-method=\"getMapper\"/>\n----\n\n[IMPORTANT]\n====\nBeginning with version 2.2, the `object-to-json-transformer` sets the `content-type` header to `application/json`, by default, if the input message does not already have that header.\n\nIf you wish to set the `content-type` header to some other value or explicitly overwrite any existing header with some value (including `application/json`), use the `content-type` attribute.\nIf you wish to suppress the setting of the header, set the `content-type` attribute to an empty string (`\"\"`).\nDoing so results in a message with no `content-type` header, unless such a header was present on the input message.\n====\n\nBeginning with version 3.0, the `ObjectToJsonTransformer` adds headers, reflecting the source type, to the message.\nSimilarly, the `JsonToObjectTransformer` can use those type headers when converting the JSON to an object.\nThese headers are mapped in the AMQP adapters so that they are entirely compatible with the Spring-AMQP https://docs.spring.io/spring-amqp/api/[`JsonMessageConverter`].\n\nThis enables the following flows to work without any special configuration:\n\n* `...->amqp-outbound-adapter---->`\n* `---->amqp-inbound-adapter->json-to-object-transformer->...`\n+\nWhere the outbound adapter is configured with a `JsonMessageConverter` and the inbound adapter uses the default `SimpleMessageConverter`.\n\n* `...->object-to-json-transformer->amqp-outbound-adapter---->`\n* `---->amqp-inbound-adapter->...`\n+\nWhere the outbound adapter is configured with a `SimpleMessageConverter` and the inbound adapter uses the default `JsonMessageConverter`.\n\n* `...->object-to-json-transformer->amqp-outbound-adapter---->`\n* `---->amqp-inbound-adapter->json-to-object-transformer->`\n+\nWhere both adapters are configured with a `SimpleMessageConverter`.\n\nNOTE: When using the headers to determine the type, you should not provide a `class` attribute, because it takes precedence over the headers.\n\nIn addition to JSON Transformers, Spring Integration provides a built-in `#jsonPath` SpEL function for use in expressions.\nFor more information see xref:spel.adoc[Spring Expression Language (SpEL)].\n\n[[transformer-xpath-spel-function]]\nSince version 3.0, Spring Integration also provides a built-in `#xpath` SpEL function for use in expressions.\nFor more information see xref:xml/xpath-spel-function.adoc[#xpath SpEL Function].\n\nBeginning with version 4.0, the `ObjectToJsonTransformer` supports the `resultType` property, to specify the node JSON representation.\nThe result node tree representation depends on the implementation of the provided `JsonObjectMapper`.\nBy default, the `ObjectToJsonTransformer` uses a `JacksonJsonObjectMapper` and delegates the conversion of the object to the node tree to the `ObjectMapper#valueToTree` method.\nThe node JSON representation provides efficiency for using the `JacksonPropertyAccessor` when the downstream message flow uses SpEL expressions with access to the properties of the JSON data.\nSee xref:spel.adoc#spel-property-accessors[Property Accessors] for more information.\n\nBeginning with version 5.1, the `resultType` can be configured as `BYTES` to produce a message with the `byte[]` payload for convenience when working with downstream handlers which operate with this data type.\n\nStarting with version 5.2, the `JsonToObjectTransformer` can be configured with a `ResolvableType` to support generics during deserialization with the target JSON processor.\nAlso, this component now consults request message headers first for the presence of the `JsonHeaders.RESOLVABLE_TYPE` or `JsonHeaders.TYPE_ID` and falls back to the configured type otherwise.\nThe `ObjectToJsonTransformer` now also populates a `JsonHeaders.RESOLVABLE_TYPE` header based on the request message payload for any possible downstream scenarios.\n\nStarting with version 5.2.6, the `JsonToObjectTransformer` can be supplied with a `valueTypeExpression` to resolve a `ResolvableType` for the payload to convert from JSON at runtime against the request message.\nBy default, it consults `JsonHeaders` in the request message.\nIf this expression returns `null` or `ResolvableType` building throws a `ClassNotFoundException`, the transformer falls back to the provided `targetType`.\nThis logic is present as an expression because `JsonHeaders` may not have real class values, but rather some type ids which have to be mapped to target classes according some external registry.\n\n[[Avro-transformers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "JSON Transformers", "heading_level": 3, "file_order": 275, "section_index": 8, "content_hash": "131c887a26dd9b7f914a271f76c977434eef5835aaeb90b9a8ebfed33d178f95", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:30f5888cce7ed1289fd46f540ae5ee5abce234f6b39b77b1f40e79a9b1fd2c23", "content": "Version 5.2 added simple transformers to transform to/from Apache Avro.\n\nThey are unsophisticated in that there is no schema registry; the transformers simply use the schema embedded in the `SpecificRecord` implementation generated from the Avro schema.\n\nMessages sent to the `SimpleToAvroTransformer` must have a payload that implements `SpecificRecord`; the transformer can handle multiple types.\nThe `SimpleFromAvroTransformer` must be configured with a `SpecificRecord` class which is used as the default type to deserialize.\nYou can also specify a SpEL expression to determine the type to deserialize using the `setTypeExpression` method.\nThe default SpEL expression is `headers[avro_type]` (`AvroHeaders.TYPE`) which, by default, is populated by the `SimpleToAvroTransformer` with the fully qualified class name of the source class.\nIf the expression returns `null`, the `defaultType` is used.\n\nThe `SimpleToAvroTransformer` also has a `setTypeExpression` method.\nThis allows decoupling of the producer and consumer where the sender can set the header to some token representing the type, and the consumer then maps that token to a type.\n\n[[Protobuf-transformers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "Apache Avro Transformers", "heading_level": 3, "file_order": 275, "section_index": 9, "content_hash": "30f5888cce7ed1289fd46f540ae5ee5abce234f6b39b77b1f40e79a9b1fd2c23", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:6a7a99d39ee3b895f57d7691e9712214e352e551fd751c1ad65bf3a8c795ad42", "content": "Version 6.1 adds support for transforming from and to https://protobuf.dev/[Protocol Buffers] data content.\n\nThe `ToProtobufTransformer` transforms a `com.google.protobuf.Message` message payloads into native byte array or json text payloads.\nThe `application/x-protobuf` content type (used by default) produces byte array output payload.\nIf the content type is `application/json` add the `com.google.protobuf:protobuf-java-util` if found on the classpath, then the output is text json payload.\nIf the content type header is not set the `ToProtobufTransformer` defaults to `application/x-protobuf`.\n\nThe `FromProtobufTransformer` transforms byte array or text protobuf payload (depending on the content type) back into `com.google.protobuf.Message` instances.\nThe `FromProtobufTransformer` should specify either an expected class type explicitly (use the `setExpectedType` method) or use a SpEL expression to determine the type to deserialize using the `setExpectedTypeExpression` method.\nThe default SpEL expression is `headers[proto_type]` (`ProtoHeaders.TYPE`) which is populated by the `ToProtobufTransformer` with the fully qualified class name of the source `com.google.protobuf.Message` class.\n\nFor example, compiling the following IDL:\n\n[source,proto]\n----\nsyntax = \"proto2\";\npackage tutorial;\n\noption java_multiple_files = true;\noption java_package = \"org.example\";\noption java_outer_classname = \"MyProtos\";\n\nmessage MyMessageClass {\n optional string foo = 1;\n optional string bar = 2;\n}\n----\n\nwill generate a new `org.example.MyMessageClass` class.\n\nThen use the:\n[source,java]\n----\nToProtobufTransformer toTransformer = new ToProtobufTransformer();\n\nMyMessageClass test = MyMessageClass.newBuilder()\n .setFoo(\"foo\")\n .setBar(\"bar\")\n .build();\nMessage message1 = toTransformer.transform(new GenericMessage<>(test));\n\nFromProtobufTransformer fromTransformer = new FromProtobufTransformer();\n\nMessage message2 = fromTransformer.transform(message1);\n\n----\n\n[[transformer-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "Protocol Buffers Transformers", "heading_level": 3, "file_order": 275, "section_index": 10, "content_hash": "6a7a99d39ee3b895f57d7691e9712214e352e551fd751c1ad65bf3a8c795ad42", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:e84b5728ee034008eeabbd3619ae265888c8b2fe9f095fbc409b36f10948e64c", "content": "You can add the `@Transformer` annotation to methods that expect either the `Message` type or the message payload type.\nThe return value is handled in the exact same way as described earlier <<transformer-namespace,in the section describing the `<transformer>` element>>.\nThe following example shows how to use the `@Transformer` annotation to transform a `String` into an `Order`:\n\n[source,java]\n----\n@Transformer\nOrder generateOrder(String productId) {\n return new Order(productId);\n}\n----\n\nTransformer methods can also accept the `@Header` and `@Headers` annotations, as documented in `xref:configuration/annotations.adoc[Annotation Support]`.\nThe following examples shows how to use the `@Header` annotation:\n\n[source,java]\n----\n@Transformer\nOrder generateOrder(String productId, @Header(\"customerName\") String customer) {\n return new Order(productId, customer);\n}\n----\n\nSee also xref:handler-advice/advising-with-annotations.adoc[Advising Endpoints Using Annotations].\n\n[[header-filter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "Configuring a Transformer with Annotations", "heading_level": 2, "file_order": 275, "section_index": 11, "content_hash": "e84b5728ee034008eeabbd3619ae265888c8b2fe9f095fbc409b36f10948e64c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:7a9ee9c550d25d65c23e8517d2c40a46e7a6f51ba01aa34e7e31ae9818fd4ffd", "content": "Sometimes, your transformation use case might be as simple as removing a few headers.\nFor such a use case, Spring Integration provides a header filter that lets you specify certain header names that should be removed from the output message (for example, removing headers for security reasons or a value that was needed only temporarily).\nBasically, the header filter is the opposite of the header enricher.\nThe latter is discussed in xref:content-enrichment.adoc#header-enricher[Header Enricher].\nThe following example defines a header filter:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow someFlow() {\n return IntegrationFlow\n .from(\"inputChannel\")\n .headerFilter(\"lastName\", \"state\")\n .channel(\"outputChannel\")\n .get();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:header-filter input-channel=\"inputChannel\"\n output-channel=\"outputChannel\" header-names=\"lastName, state\"/>\n----\n======\n\nAs you can see, configuration of a header filter is quite simple.\nIt is a typical endpoint with input and output channels and a `header-names` attribute.\nThat attribute accepts the names of the headers (delimited by commas if there are multiple of them) that need to be removed.\nSo, in the preceding example, the headers named 'lastName' and 'state' are not present on the outbound message.\n\n[[codec-based-transformers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "Header Filter", "heading_level": 2, "file_order": 275, "section_index": 12, "content_hash": "7a9ee9c550d25d65c23e8517d2c40a46e7a6f51ba01aa34e7e31ae9818fd4ffd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:811db4f773b5df0c37d7b38044b53c4e0ff4ee8d13db4062e925c55d0ddc73b8", "content": "See xref:codec.adoc[Codec].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/transformer.adoc", "title": "transformer", "heading": "Codec-Based Transformers", "heading_level": 2, "file_order": 275, "section_index": 13, "content_hash": "811db4f773b5df0c37d7b38044b53c4e0ff4ee8d13db4062e925c55d0ddc73b8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/transformer.adoc"}}
{"id": "sha256:90e6a2622ef4343502cfd8c16b8e9d9b859db88d099743d71daa7a3533f0ba68", "content": "[[web-sockets]]\n\nStarting with version 4.1, Spring Integration has WebSocket support.\nIt is based on the architecture, infrastructure, and API from the Spring Framework's `web-socket` module.\nTherefore, many of Spring WebSocket's components (such as `SubProtocolHandler` or `WebSocketClient`) and configuration options (such as `@EnableWebSocketMessageBroker`) can be reused within Spring Integration.\nFor more information, see the https://docs.spring.io/spring-framework/reference/web/websocket.html[Spring Framework WebSocket Support] chapter in the Spring Framework reference manual.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-websocket</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-websocket:{project-version}\"\n----\n======\n\nFor server side, the `org.springframework:spring-webmvc` dependency must be included explicitly.\n\nThe Spring Framework WebSocket infrastructure is based on the Spring messaging foundation and provides a basic messaging framework based on the same `MessageChannel` implementations and `MessageHandler` implementations that Spring Integration uses (and some POJO-method annotation mappings).\nConsequently, Spring Integration can be directly involved in a WebSocket flow, even without WebSocket adapters.\nFor this purpose, you can configure a Spring Integration `@MessagingGateway` with appropriate annotations, as the following example shows:\n\n[source,java]\n----\n@MessagingGateway\n@Controller\npublic interface WebSocketGateway {\n\n @MessageMapping(\"/greeting\")\n @SendToUser(\"/queue/answer\")\n @Gateway(requestChannel = \"greetingChannel\")\n String greeting(String payload);\n\n}\n----\n\n[[web-socket-overview]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/web-sockets.adoc", "title": "web-sockets", "heading": "web-sockets", "heading_level": 1, "file_order": 276, "section_index": 0, "content_hash": "90e6a2622ef4343502cfd8c16b8e9d9b859db88d099743d71daa7a3533f0ba68", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/web-sockets.adoc"}}
{"id": "sha256:e8ede6b35a9fc6077fbc820f06b542a15298727834d95d9b41312328b5182680", "content": "Since the WebSocket protocol is streaming by definition, and we can send and receive messages to and from a WebSocket at the same time, we can deal with an appropriate `WebSocketSession`, regardless of being on the client or server side.\nTo encapsulate the connection management and `WebSocketSession` registry, the `IntegrationWebSocketContainer` is provided with `ClientWebSocketContainer` and `ServerWebSocketContainer` implementations.\nThanks to the https://www.jcp.org/en/jsr/detail?id=356[WebSocket API] and its implementation in the Spring Framework (with many extensions), the same classes are used on the server side as well as the client side (from a Java perspective, of course).\nConsequently, most connection and `WebSocketSession` registry options are the same on both sides.\nThat lets us reuse many configuration items and infrastructure hooks to build WebSocket applications on the server side as well as on the client side.\nThe following example shows how components can serve both purposes:\n\n[source,java]\n----\n@Bean\npublic WebSocketClient webSocketClient() {\n return new SockJsClient(Collections.singletonList(new WebSocketTransport(new JettyWebSocketClient())));\n}\n\n@Bean\npublic IntegrationWebSocketContainer clientWebSocketContainer() {\n return new ClientWebSocketContainer(webSocketClient(), \"ws://my.server.com/endpoint\");\n}\n\n@Bean\npublic IntegrationWebSocketContainer serverWebSocketContainer() {\n return new ServerWebSocketContainer(\"/endpoint\").withSockJs();\n}\n----\n\nThe `IntegrationWebSocketContainer` is designed to achieve bidirectional messaging and can be shared between inbound and outbound channel adapters (see below), can be referenced from only one of them when using one-way (sending or receiving) WebSocket messaging.\nIt can be used without any channel adapter, but, in this case, `IntegrationWebSocketContainer` only plays a role as the `WebSocketSession` registry.\n\nNOTE: The `ServerWebSocketContainer` implements `WebSocketConfigurer` to register an internal `IntegrationWebSocketContainer.IntegrationWebSocketHandler` as an `Endpoint`.\nIt does so under the provided `paths` and other server WebSocket options (such as `HandshakeHandler` or `SockJS fallback`) within the `ServletWebSocketHandlerRegistry` for the target vendor WebSocket Container.\nThis registration is achieved with an infrastructural `WebSocketIntegrationConfigurationInitializer` component, which does the same as the `@EnableWebSocket` annotation.\nThis means that, by using `@EnableIntegration` (or any Spring Integration namespace in the application context), you can omit the `@EnableWebSocket` declaration, because the Spring Integration infrastructure detects all WebSocket endpoints.\n\nStarting with version 6.1, the `ClientWebSocketContainer` can be configured with a provided `URI` instead of `uriTemplate` and `uriVariables` combination.\nThis is useful in cases when custom encoding is required for some parts of the uri.\nSee an `UriComponentsBuilder` API for convenience.\n\n[[web-socket-inbound-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/web-sockets.adoc", "title": "web-sockets", "heading": "Overview", "heading_level": 2, "file_order": 276, "section_index": 1, "content_hash": "e8ede6b35a9fc6077fbc820f06b542a15298727834d95d9b41312328b5182680", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/web-sockets.adoc"}}
{"id": "sha256:e73679d6bab48a5c7417d57f3854e6d31b841dd2af15170f59a951f18364fcca", "content": "The `WebSocketInboundChannelAdapter` implements the receiving part of `WebSocketSession` interaction.\nYou must supply it with a `IntegrationWebSocketContainer`, and the adapter registers itself as a `WebSocketListener` to handle incoming messages and `WebSocketSession` events.\n\nNOTE: Only one `WebSocketListener` can be registered in the `IntegrationWebSocketContainer`.\n\nFor WebSocket sub-protocols, the `WebSocketInboundChannelAdapter` can be configured with `SubProtocolHandlerRegistry` as the second constructor argument.\nThe adapter delegates to the `SubProtocolHandlerRegistry` to determine the appropriate `SubProtocolHandler` for the accepted `WebSocketSession` and to convert a `WebSocketMessage` to a `Message` according to the sub-protocol implementation.\n\nNOTE: By default, the `WebSocketInboundChannelAdapter` relies only on the raw `PassThruSubProtocolHandler` implementation, which converts the `WebSocketMessage` to a `Message`.\n\nThe `WebSocketInboundChannelAdapter` accepts and sends to the underlying integration flow only `Message` instances that have `SimpMessageType.MESSAGE` or an empty `simpMessageType` header.\nAll other `Message` types are handled through the `ApplicationEvent` instances emitted from a `SubProtocolHandler` implementation (such as `StompSubProtocolHandler`).\n\nOn the server side, if the `@EnableWebSocketMessageBroker` configuration is present, you can configure `WebSocketInboundChannelAdapter` with the `useBroker = true` option.\nIn this case, all `non-MESSAGE` `Message` types are delegated to the provided `AbstractBrokerMessageHandler`.\nIn addition, if the broker relay is configured with destination prefixes, those messages that match the Broker destinations are routed to the `AbstractBrokerMessageHandler` instead of to the `outputChannel` of the `WebSocketInboundChannelAdapter`.\n\nIf `useBroker = false` and the received message is of the `SimpMessageType.CONNECT` type, the `WebSocketInboundChannelAdapter` immediately sends a `SimpMessageType.CONNECT_ACK` message to the `WebSocketSession` without sending it to the channel.\n\nNOTE: Spring's WebSocket Support allows the configuration of only one broker relay.\nConsequently, we do not require an `AbstractBrokerMessageHandler` reference.\nIt is detected in the Application Context.\n\nFor more configuration options, see xref:web-sockets.adoc#web-sockets-namespace[WebSockets Namespace Support].\n\n[[web-socket-outbound-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/web-sockets.adoc", "title": "web-sockets", "heading": "WebSocket Inbound Channel Adapter", "heading_level": 2, "file_order": 276, "section_index": 2, "content_hash": "e73679d6bab48a5c7417d57f3854e6d31b841dd2af15170f59a951f18364fcca", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/web-sockets.adoc"}}
{"id": "sha256:138eee2744b4161665abbcc79abe22203d03af83bbba094b10ef291425dce896", "content": "The `WebSocketOutboundChannelAdapter`:\n\n. Accepts Spring Integration messages from its `MessageChannel`\n. Determines the `WebSocketSession` `id` from the `MessageHeaders`\n. Retrieves the `WebSocketSession` from the provided `IntegrationWebSocketContainer`\n. Delegates the conversion and sending of `WebSocketMessage` work to the appropriate `SubProtocolHandler` from the provided `SubProtocolHandlerRegistry`.\n\nOn the client side, the `WebSocketSession` `id` message header is not required, because `ClientWebSocketContainer` deals only with a single connection and its `WebSocketSession` respectively.\n\nTo use the STOMP sub-protocol, you should configure this adapter with a `StompSubProtocolHandler`.\nThen you can send any STOMP message type to this adapter, using `StompHeaderAccessor.create(StompCommand...)` and a `MessageBuilder`, or just using a `HeaderEnricher` (see xref:content-enrichment.adoc#header-enricher[Header Enricher]).\n\nThe rest of this chapter covers largely additional configuration options.\n\n[[web-sockets-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/web-sockets.adoc", "title": "web-sockets", "heading": "WebSocket Outbound Channel Adapter", "heading_level": 2, "file_order": 276, "section_index": 3, "content_hash": "138eee2744b4161665abbcc79abe22203d03af83bbba094b10ef291425dce896", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/web-sockets.adoc"}}
{"id": "sha256:1bf779bd89d18463276ece4d201bf450f210849242d40e82ee6f803debcbfa26", "content": "The Spring Integration WebSocket namespace includes several components described in the remainder of this chapter.\nTo include it in your configuration, use the following namespace declaration in your application context configuration file:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int=\"http://www.springframework.org/schema/integration\"\n xmlns:int-websocket=\"http://www.springframework.org/schema/integration/websocket\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration.xsd\n http://www.springframework.org/schema/integration/websocket\n https://www.springframework.org/schema/integration/websocket/spring-integration-websocket.xsd\">\n ...\n</beans>\n----\n\n[[websocket-client-container-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/web-sockets.adoc", "title": "web-sockets", "heading": "WebSockets Namespace Support", "heading_level": 2, "file_order": 276, "section_index": 4, "content_hash": "1bf779bd89d18463276ece4d201bf450f210849242d40e82ee6f803debcbfa26", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/web-sockets.adoc"}}
{"id": "sha256:588a75077abe54eb8bbc5f91374c74eccf6a955b0eb3a63fd7872aa92e3c0683", "content": "The following listing shows the attributes available for the `<int-websocket:client-container>` element:\n\n[source,xml]\n----\n<int-websocket:client-container\n id=\"\" <1>\n client=\"\" <2>\n uri=\"\" <3>\n uri-variables=\"\" <4>\n origin=\"\" <5>\n send-time-limit=\"\" <6>\n send-buffer-size-limit=\"\" <7>\n send-buffer-overflow-strategy=\"\" <8>\n auto-startup=\"\" <9>\n phase=\"\"> <10>\n <int-websocket:http-headers>\n <entry key=\"\" value=\"\"/>\n </int-websocket:http-headers> <11>\n</int-websocket:client-container>\n----\n\n<1> The component bean name.\n<2> The `WebSocketClient` bean reference.\n<3> The `uri` or `uriTemplate` to the target WebSocket service.\nIf you use it as a `uriTemplate` with URI variable placeholders, the `uri-variables` attribute is required.\n<4> Comma-separated values for the URI variable placeholders within the `uri` attribute value.\nThe values are replaced into the placeholders according to their order in the `uri`.\nSee https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/util/UriComponents.html#expand-java.lang.Object[`UriComponents.expand(Object...uriVariableValues)`].\n<5> The `Origin` Handshake HTTP header value.\n<6> The WebSocket session `send` timeout limit.\nDefaults to `10000`.\n<7> The WebSocket session `send` message size limit.\nDefaults to `524288`.\n<8> The WebSocket session send buffer overflow strategy\ndetermines the behavior when a session's outbound message buffer has reached the `send-buffer-size-limit`.\nSee `ConcurrentWebSocketSessionDecorator.OverflowStrategy` for possible values and more details.\n<9> Boolean value indicating whether this endpoint should start automatically.\nDefaults to `false`, assuming that this container is started from the xref:web-sockets.adoc#web-socket-inbound-adapter[WebSocket inbound adapter].\n<10> The lifecycle phase within which this endpoint should start and stop.\nThe lower the value, the earlier this endpoint starts and the later it stops.\nThe default is `Integer.MAX_VALUE`.\nValues can be negative.\nSee https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/SmartLifecycle.html[`SmartLifeCycle`].\n<11> A `Map` of `HttpHeaders` to be used with the Handshake request.\n\n[[int-websocket:server-container-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/web-sockets.adoc", "title": "web-sockets", "heading": "`<int-websocket:client-container>` Attributes", "heading_level": 3, "file_order": 276, "section_index": 5, "content_hash": "588a75077abe54eb8bbc5f91374c74eccf6a955b0eb3a63fd7872aa92e3c0683", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/web-sockets.adoc"}}
{"id": "sha256:bf409774758f950ca7fb4b8c66ac194460203173270d87fbf4bd8d74f4163419", "content": "The following listing shows the attributes available for the `<int-websocket:server-container>` element:\n\n[source,xml]\n----\n<int-websocket:server-container\n id=\"\" <1>\n path=\"\" <2>\n handshake-handler=\"\" <3>\n handshake-interceptors=\"\" <4>\n decorator-factories=\"\" <5>\n send-time-limit=\"\" <6>\n send-buffer-size-limit=\"\" <7>\n send-buffer-overflow-strategy=\"\" <8>\n allowed-origins=\"\"> <9>\n <int-websocket:sockjs\n client-library-url=\"\" <10>\n stream-bytes-limit=\"\" <11>\n session-cookie-needed=\"\" <12>\n heartbeat-time=\"\" <13>\n disconnect-delay=\"\" <14>\n message-cache-size=\"\" <15>\n websocket-enabled=\"\" <16>\n scheduler=\"\" <17>\n message-codec=\"\" <18>\n transport-handlers=\"\" <19>\n suppress-cors=\"true\" /> <20>\n</int-websocket:server-container>\n----\n\n<1> The component bean name.\n<2> A path (or comma-separated paths) that maps a particular request to a `WebSocketHandler`.\nSupports exact path mapping URIs (such as `/myPath`) and ant-style path patterns (such as `/myPath/**`).\n<3> The `HandshakeHandler` bean reference.\nDefaults to `DefaultHandshakeHandler`.\n<4> List of `HandshakeInterceptor` bean references.\n<5> List of one or more factories (`WebSocketHandlerDecoratorFactory`) that decorate the handler used to process WebSocket messages.\nThis may be useful for some advanced use cases, (for example, to allow Spring Security to forcibly close\nthe WebSocket session when the corresponding HTTP session expires).\nSee the https://docs.spring.io/spring-session/docs/current/reference/html5/#websocket[Spring Session Project] for more information.\n<6> See the same option on the <<websocket-client-container-attributes,`<int-websocket:client-container>`>>.\n<7> See the same option on the <<websocket-client-container-attributes,`<int-websocket:client-container>`>>.\n<8> The WebSocket session send buffer overflow strategy\ndetermines the behavior when a session's outbound message buffer has reached the `send-buffer-size-limit`.\nSee `ConcurrentWebSocketSessionDecorator.OverflowStrategy` for possible values and more details.\n<9> The allowed origin header values.\nYou can specify multiple origins as a comma-separated list.\nThis check is mostly designed for browser clients.\nThere is nothing preventing other types of a client from modifying the origin header value.\nWhen SockJS is enabled and allowed origins are restricted, transport types that do not use origin headers for cross-origin requests (`jsonp-polling`, `iframe-xhr-polling`, `iframe-eventsource`, and `iframe-htmlfile`) are disabled.\nAs a consequence, IE6 and IE7 are not supported, and IE8 and IE9 are supported only without cookies.\nBy default, all origins are allowed.\n<10> Transports with no native cross-domain communication (such as `eventsource` and `htmlfile`) must get a simple page from the \"`foreign`\" domain in an invisible iframe so that code in the iframe can run from a domain local to the SockJS server.\nSince the iframe needs to load the SockJS JavaScript client library, this property lets you specify the location from which to load it.\nBy default, it points to `https://d1fxtkz8shb9d2.cloudfront.net/sockjs-0.3.4.min.js`.\nHowever, you can also set it to point to a URL served by the application.\nNote that it is possible to specify a relative URL, in which case the URL must be relative to the iframe URL.\nFor example, assuming a SockJS endpoint mapped to `/sockjs` and the resulting iframe URL is `/sockjs/iframe.html`, the relative URL must start with `../../` to traverse up to the location above the SockJS mapping.\nFor prefix-based servlet mapping, you may need one more traversal.\n<11> Minimum number of bytes that can be sent over a single HTTP streaming request before it is closed.\nDefaults to `128K` (that is, 128*1024 or 131072 bytes).\n<12> The `cookie_needed` value in the response from the SockJs `/info` endpoint.\nThis property indicates whether a `JSESSIONID` cookie is required for the application to function correctly, (for example, for load balancing or in Java Servlet containers for the use of an HTTP session).\n<13> The amount of time (in milliseconds) when the server has not sent any messages and after which the server should\nsend a heartbeat frame to the client to keep the connection from breaking.\nThe default value is `25,000` (25 seconds).\n<14> The amount of time (in milliseconds) before a client is considered disconnected after not having a receiving connection (that is, an active connection over which the server can send data to the client).\nThe default value is `5000`.\n<15> The number of server-to-client messages that a session can cache while waiting for the next HTTP polling request from the client.\nThe default size is `100`.\n<16> Some load balancers do not support WebSockets.\nSet this option to `false` to disable the WebSocket transport on the server side.\nThe default value is `true`.\n<17> The `TaskScheduler` bean reference.\nA new `ThreadPoolTaskScheduler` instance is created if no value is provided.\nThis scheduler instance is used for scheduling heart-beat messages.\n<18> The `SockJsMessageCodec` bean reference to use for encoding and decoding SockJS messages.\nBy default, `Jackson2SockJsMessageCodec` is used, which requires the Jackson library to be present on the classpath.\n<19> List of `TransportHandler` bean references.\n<20> Whether to disable the automatic addition of CORS headers for SockJS requests.\nThe default value is `false`.\n\n[[websocket-outbound-channel-adapter-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/web-sockets.adoc", "title": "web-sockets", "heading": "`<int-websocket:server-container>` Attributes", "heading_level": 3, "file_order": 276, "section_index": 6, "content_hash": "bf409774758f950ca7fb4b8c66ac194460203173270d87fbf4bd8d74f4163419", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/web-sockets.adoc"}}
{"id": "sha256:9f6dbb7a3f8c326a86e1b247fad39e22da71295cf4c1e28749cc86ba436420e5", "content": "The following listing shows the attributes available for the `<int-websocket:outbound-channel-adapter>` element:\n\n[source,xml]\n----\n<int-websocket:outbound-channel-adapter\n id=\"\" <1>\n channel=\"\" <2>\n container=\"\" <3>\n default-protocol-handler=\"\" <4>\n protocol-handlers=\"\" <5>\n message-converters=\"\" <6>\n merge-with-default-converters=\"\" <7>\n auto-startup=\"\" <8>\n phase=\"\"/> <9>\n----\n\n<1> The component bean name.\nIf you do not provide the `channel` attribute, a `DirectChannel` is created and registered in the application context with this `id` attribute as the bean name.\nIn this case, the endpoint is registered with the bean name `id` plus `.adapter`.\nAnd the `MessageHandler` is registered with the bean alias `id` plus `.handler`.\n<2> Identifies the channel attached to this adapter.\n<3> The reference to the `IntegrationWebSocketContainer` bean, which encapsulates the low-level connection and `WebSocketSession` handling operations.\nRequired.\n<4> Optional reference to a `SubProtocolHandler` instance.\nIt is used when the client did not request a sub-protocol or it is a single protocol-handler.\nIf this reference or a `protocol-handlers` list is not provided, the `PassThruSubProtocolHandler` is used by default.\n<5> List of `SubProtocolHandler` bean references for this channel adapter.\nIf you provide only a single bean reference and do not provide a `default-protocol-handler`, that single `SubProtocolHandler` is used as the `default-protocol-handler`.\nIf you do not set this attribute or `default-protocol-handler`, the `PassThruSubProtocolHandler` is used by default.\n<6> List of `MessageConverter` bean references for this channel adapter.\n<7> Boolean value indicating whether the default converters should be registered after any custom converters.\nThis flag is used only if `message-converters` is provided.\nOtherwise, all default converters are registered.\nDefaults to `false`.\nThe default converters are (in order): `StringMessageConverter`, `ByteArrayMessageConverter`, and `MappingJackson2MessageConverter` (if the Jackson library is present on the classpath).\n<8> Boolean value indicating whether this endpoint should start automatically.\nDefaults to `true`.\n<9> The lifecycle phase within which this endpoint should start and stop.\nThe lower the value, the earlier this endpoint starts and the later it stops.\nThe default is `Integer.MIN_VALUE`.\nValues can be negative.\nSee https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/SmartLifecycle.html[`SmartLifeCycle`].\n\n[[int-websocket:inbound-channel-adapter-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/web-sockets.adoc", "title": "web-sockets", "heading": "`<int-websocket:outbound-channel-adapter>` Attributes", "heading_level": 3, "file_order": 276, "section_index": 7, "content_hash": "9f6dbb7a3f8c326a86e1b247fad39e22da71295cf4c1e28749cc86ba436420e5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/web-sockets.adoc"}}
{"id": "sha256:f650fe0806705cb99bfddbf1c9d1566774db0f35e1811875d2eccd753d0f6449", "content": "The following listing shows the attributes available for the `<int-websocket:outbound-channel-adapter>` element:\n\n[source,xml]\n----\n<int-websocket:inbound-channel-adapter\n id=\"\" <1>\n channel=\"\" <2>\n error-channel=\"\" <3>\n container=\"\" <4>\n default-protocol-handler=\"\" <5>\n protocol-handlers=\"\" <6>\n message-converters=\"\" <7>\n merge-with-default-converters=\"\" <8>\n send-timeout=\"\" <9>\n payload-type=\"\" <10>\n use-broker=\"\" <11>\n auto-startup=\"\" <12>\n phase=\"\"/> <13>\n----\n\n<1> The component bean name.\nIf you do not set the `channel` attribute, a `DirectChannel` is created and registered in the application context with this `id` attribute as the bean name.\nIn this case, the endpoint is registered with the bean name `id` plus `.adapter`.\n<2> Identifies the channel attached to this adapter.\n<3> The `MessageChannel` bean reference to which the `ErrorMessage` instances should be sent.\n<4> See the same option on the <<websocket-outbound-channel-adapter-attributes,`<int-websocket:outbound-channel-adapter>`>>.\n<5> See the same option on the <<websocket-outbound-channel-adapter-attributes,`<int-websocket:outbound-channel-adapter>`>>.\n<6> See the same option on the <<websocket-outbound-channel-adapter-attributes,`<int-websocket:outbound-channel-adapter>`>>.\n<7> See the same option on the <<websocket-outbound-channel-adapter-attributes,`<int-websocket:outbound-channel-adapter>`>>.\n<8> See the same option on the <<websocket-outbound-channel-adapter-attributes,`<int-websocket:outbound-channel-adapter>`>>.\n<9> Maximum amount of time (in milliseconds) to wait when sending a message to the channel if the channel can block.\nFor example, a `QueueChannel` can block until space is available if its maximum capacity has been reached.\n<10> Fully qualified name of the Java type for the target `payload` to convert from the incoming `WebSocketMessage`.\nDefaults to `java.lang.String`.\n<11> Indicates whether this adapter sends `non-MESSAGE` `WebSocketMessage` instances and messages with broker destinations to the `AbstractBrokerMessageHandler` from the application context.\nWhen this attribute is `true`, the `Broker Relay` configuration is required.\nThis attribute is used only on the server side.\nOn the client side, it is ignored.\nDefaults to `false`.\n<12> See the same option on the <<websocket-outbound-channel-adapter-attributes,`<int-websocket:outbound-channel-adapter>`>>.\n<13> See the same option on the <<websocket-outbound-channel-adapter-attributes,`<int-websocket:outbound-channel-adapter>`>>.\n\n[[client-stomp-encoder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/web-sockets.adoc", "title": "web-sockets", "heading": "`<int-websocket:inbound-channel-adapter>` Attributes", "heading_level": 3, "file_order": 276, "section_index": 8, "content_hash": "f650fe0806705cb99bfddbf1c9d1566774db0f35e1811875d2eccd753d0f6449", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/web-sockets.adoc"}}
{"id": "sha256:9582ff14de14d3840ec931d72e0fb696276302769dac1250e6bd8b2eaa2985f2", "content": "Starting with version 4.3.13, Spring Integration provides `ClientStompEncoder` (as an extension of the standard `StompEncoder`) for use on the client side of WebSocket channel adapters.\nFor proper client side message preparation, you must inject an instance of the `ClientStompEncoder` into the `StompSubProtocolHandler`.\nOne problem with the default `StompSubProtocolHandler` is that it was designed for the server side, so it updates the `SEND` `stompCommand` header into `MESSAGE` (as required by the STOMP protocol for the server side).\nIf the client does not send its messages in the proper `SEND` web socket frame, some STOMP brokers do not accept them.\nThe purpose of the `ClientStompEncoder`, in this case, is to override the `stompCommand` header and set it to the `SEND` value before encoding the message to the `byte[]`.\n\n[[websocket-dynamic-endpoints]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/web-sockets.adoc", "title": "web-sockets", "heading": "Using `ClientStompEncoder`", "heading_level": 2, "file_order": 276, "section_index": 9, "content_hash": "9582ff14de14d3840ec931d72e0fb696276302769dac1250e6bd8b2eaa2985f2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/web-sockets.adoc"}}
{"id": "sha256:1153dfabb93600fec873456e9d795baee9a733d60d162f7f9e3b2422a78f128b", "content": "Starting with version 5.5, the WebSocket server endpoints (channel adapters based on a `ServerWebSocketContainer`) can now be registered (and removed) at runtime - the `paths` a `ServerWebSocketContainer` is mapped is exposed via `HandlerMapping` into a `DispatcherServlet` and accessible for WebSocket clients.\nThe xref:dsl/java-runtime-flows.adoc[Dynamic and Runtime Integration Flows] support helps to register these endpoints in a transparent manner:\n\n[source,java]\n----\n@Autowired\nIntegrationFlowContext integrationFlowContext;\n\n@Autowired\nHandshakeHandler handshakeHandler;\n...\nServerWebSocketContainer serverWebSocketContainer =\n new ServerWebSocketContainer(\"/dynamic\")\n .setHandshakeHandler(this.handshakeHandler);\n\nWebSocketInboundChannelAdapter webSocketInboundChannelAdapter =\n new WebSocketInboundChannelAdapter(serverWebSocketContainer);\n\nQueueChannel dynamicRequestsChannel = new QueueChannel();\n\nIntegrationFlow serverFlow =\n IntegrationFlow.from(webSocketInboundChannelAdapter)\n .channel(dynamicRequestsChannel)\n .get();\n\nIntegrationFlowContext.IntegrationFlowRegistration dynamicServerFlow =\n this.integrationFlowContext.registration(serverFlow)\n .addBean(serverWebSocketContainer)\n .register();\n...\ndynamicServerFlow.destroy();\n----\n\nNOTE: It is important to call `.addBean(serverWebSocketContainer)` on the dynamic flow registration to add the instance of `ServerWebSocketContainer` into an `ApplicationContext` for endpoint registration.\nWhen a dynamic flow registration is destroyed, the associated `ServerWebSocketContainer` instance is destroyed, too, as well as the respective endpoint registration, including URL path mappings.\n\nIMPORTANT: The dynamic Websocket endpoints can only be registered via a Spring Integration mechanism: when regular Spring `@EnableWebsocket` is used, Spring Integration configuration backs off and no infrastructure for dynamic endpoints is registered.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/web-sockets.adoc", "title": "web-sockets", "heading": "Dynamic WebSocket Endpoints Registration", "heading_level": 2, "file_order": 276, "section_index": 10, "content_hash": "1153dfabb93600fec873456e9d795baee9a733d60d162f7f9e3b2422a78f128b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/web-sockets.adoc"}}
{"id": "sha256:e8a47930a750bab7297b590a46ae4f330f25d47e78cbd704d11aa883962709b3", "content": "[[webflux]]\n\nThe WebFlux Spring Integration module (`spring-integration-webflux`) allows for the execution of HTTP requests and the processing of inbound HTTP requests in a reactive manner.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-webflux</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-webflux:{project-version}\"\n----\n======\n\nThe `io.projectreactor.netty:reactor-netty` dependency must be included in case of non-Servlet-based server configuration.\n\nThe WebFlux support consists of the following gateway implementations: `WebFluxInboundEndpoint` and `WebFluxRequestExecutingMessageHandler`.\nThe support is fully based on the Spring https://docs.spring.io/spring-framework/reference/web/webflux.html[WebFlux] and https://projectreactor.io/[Project Reactor] foundations.\nSee xref:http.adoc[HTTP Support] for more information, since many options are shared between reactive and regular HTTP components.\n\n[[webflux-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/webflux.adoc", "title": "webflux", "heading": "webflux", "heading_level": 1, "file_order": 277, "section_index": 0, "content_hash": "e8a47930a750bab7297b590a46ae4f330f25d47e78cbd704d11aa883962709b3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/webflux.adoc"}}
{"id": "sha256:12f6b29f55dc616484f3a548e4478d329bfa7f6df9a7b2846e6bf30589898a05", "content": "Spring Integration provides a `webflux` namespace and the corresponding schema definition.\nTo include it in your configuration, add the following namespace declaration in your application context configuration file:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int=\"http://www.springframework.org/schema/integration\"\n xmlns:int-webflux=\"http://www.springframework.org/schema/integration/webflux\"\n xsi:schemaLocation=\"\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration.xsd\n http://www.springframework.org/schema/integration/webflux\n https://www.springframework.org/schema/integration/webflux/spring-integration-webflux.xsd\">\n ...\n</beans>\n----\n\n[[webflux-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/webflux.adoc", "title": "webflux", "heading": "WebFlux Namespace Support", "heading_level": 2, "file_order": 277, "section_index": 1, "content_hash": "12f6b29f55dc616484f3a548e4478d329bfa7f6df9a7b2846e6bf30589898a05", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/webflux.adoc"}}
{"id": "sha256:45d47adf55efd125daacdd0a61c3e69e70dd2ae5b76fc1d69d2b00b9a2da8fc2", "content": "Starting with version 5.0, the `WebFluxInboundEndpoint` implementation of `WebHandler` is provided.\nThis component is similar to the MVC-based `HttpRequestHandlingEndpointSupport`, with which it shares some common options through the newly extracted `BaseHttpInboundEndpoint`.\nIt is used in the Spring WebFlux reactive environment (instead of MVC).\nThe following example shows a simple implementation of a WebFlux endpoint:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow inboundChannelAdapterFlow() {\n return IntegrationFlow\n .from(WebFlux.inboundChannelAdapter(\"/reactivePost\")\n .requestMapping(m -> m.methods(HttpMethod.POST))\n .requestPayloadType(ResolvableType.forClassWithGenerics(Flux.class, String.class))\n .statusCodeFunction(m -> HttpStatus.ACCEPTED))\n .channel(c -> c.queue(\"storeChannel\"))\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun inboundChannelAdapterFlow() =\n integrationFlow(\n WebFlux.inboundChannelAdapter(\"/reactivePost\")\n .apply {\n requestMapping { m -> m.methods(HttpMethod.POST) }\n requestPayloadType(ResolvableType.forClassWithGenerics(Flux::class.java, String::class.java))\n statusCodeFunction { m -> HttpStatus.ACCEPTED }\n })\n {\n channel { queue(\"storeChannel\") }\n }\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Configuration\n@EnableWebFlux\n@EnableIntegration\npublic class ReactiveHttpConfiguration {\n\n @Bean\n public WebFluxInboundEndpoint simpleInboundEndpoint() {\n WebFluxInboundEndpoint endpoint = new WebFluxInboundEndpoint();\n RequestMapping requestMapping = new RequestMapping();\n requestMapping.setPathPatterns(\"/test\");\n endpoint.setRequestMapping(requestMapping);\n endpoint.setRequestChannelName(\"serviceChannel\");\n return endpoint;\n }\n\n @ServiceActivator(inputChannel = \"serviceChannel\")\n String service() {\n return \"It works!\";\n }\n\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-webflux:inbound-gateway request-channel=\"requests\" path=\"/sse\">\n <int-webflux:request-mapping produces=\"text/event-stream\"/>\n</int-webflux:inbound-gateway>\n----\n======\n\nThe configuration is similar to the `HttpRequestHandlingEndpointSupport` (mentioned prior to the example), except that we use `@EnableWebFlux` to add the WebFlux infrastructure to our integration application.\nAlso, the `WebFluxInboundEndpoint` performs `sendAndReceive` operations to the downstream flow by using back-pressure, on-demand based capabilities, provided by the reactive HTTP server implementation.\n\nNOTE: The reply part is non-blocking as well and is based on the internal `FutureReplyChannel`, which is flat-mapped to a reply `Mono` for on-demand resolution.\n\nYou can configure the `WebFluxInboundEndpoint` with a custom `ServerCodecConfigurer`, a `RequestedContentTypeResolver`, and even a `ReactiveAdapterRegistry`.\nThe latter provides a mechanism you can use to return a reply as any reactive type: Reactor `Flux`, RxJava `Observable`, `Flowable`, and others.\nThis way, we can implement https://en.wikipedia.org/wiki/Server-sent_events[Server Sent Events] scenarios with Spring Integration components, as the following example shows:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow sseFlow() {\n return IntegrationFlow\n .from(WebFlux.inboundGateway(\"/sse\")\n .requestMapping(m -> m.produces(MediaType.TEXT_EVENT_STREAM_VALUE)))\n .handle((p, h) -> Flux.just(\"foo\", \"bar\", \"baz\"))\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun sseFlow() =\n integrationFlow(\n WebFlux.inboundGateway(\"/sse\")\n .requestMapping(m -> m.produces(MediaType.TEXT_EVENT_STREAM_VALUE)))\n {\n handle { (p, h) -> Flux.just(\"foo\", \"bar\", \"baz\") }\n }\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Bean\npublic WebFluxInboundEndpoint webfluxInboundGateway() {\n WebFluxInboundEndpoint endpoint = new WebFluxInboundEndpoint();\n RequestMapping requestMapping = new RequestMapping();\n requestMapping.setPathPatterns(\"/sse\");\n requestMapping.setProduces(MediaType.TEXT_EVENT_STREAM_VALUE);\n endpoint.setRequestMapping(requestMapping);\n endpoint.setRequestChannelName(\"requests\");\n return endpoint;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-webflux:inbound-channel-adapter id=\"reactiveFullConfig\" channel=\"requests\"\n path=\"test1\"\n auto-startup=\"false\"\n phase=\"101\"\n request-payload-type=\"byte[]\"\n error-channel=\"errorChannel\"\n payload-expression=\"payload\"\n supported-methods=\"PUT\"\n status-code-expression=\"'202'\"\n header-mapper=\"headerMapper\"\n codec-configurer=\"codecConfigurer\"\n reactive-adapter-registry=\"reactiveAdapterRegistry\"\n requested-content-type-resolver=\"requestedContentTypeResolver\">\n <int-webflux:request-mapping headers=\"foo\"/>\n <int-webflux:cross-origin origin=\"foo\" method=\"PUT\"/>\n <int-webflux:header name=\"foo\" expression=\"'foo'\"/>\n</int-webflux:inbound-channel-adapter>\n----\n======\n\nSee xref:changes-2.2-3.0.adoc#x3.0-request-mapping[Request Mapping Support] and xref:http/namespace.adoc#http-cors[Cross-origin Resource Sharing (CORS) Support] for more possible configuration options.\n\nWhen the request body is empty or `payloadExpression` returns `null`, the request params (`MultiValueMap<String, String>`) is used for a `payload` of the target message to process.\n\n[[webflux-validation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/webflux.adoc", "title": "webflux", "heading": "WebFlux Inbound Components", "heading_level": 2, "file_order": 277, "section_index": 2, "content_hash": "45d47adf55efd125daacdd0a61c3e69e70dd2ae5b76fc1d69d2b00b9a2da8fc2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/webflux.adoc"}}
{"id": "sha256:374c769b36593a4151822c2c315733375a87b7f396c8bc98761bb00395890e53", "content": "Starting with version 5.2, the `WebFluxInboundEndpoint` can be configured with a `Validator`.\nUnlike the MVC validation in the xref:http/inbound.adoc#http-validation[HTTP Support], it is used to validate elements in the `Publisher` to which a request has been converted by the `HttpMessageReader`, before performing a fallback and `payloadExpression` functions.\nThe Framework can't assume how complex the `Publisher` object can be after building the final payload.\nIf there are requirements to restrict validation visibility for exactly final payload (or its `Publisher` elements), the validation should go downstream instead of WebFlux endpoint.\nSee more information in the Spring WebFlux https://docs.spring.io/spring/docs/5.1.8.RELEASE/spring-framework-reference/web-reactive.html#webflux-fn-handler-validation[documentation].\nAn invalid payload is rejected with an `IntegrationWebExchangeBindException` (a `WebExchangeBindException` extension), containing all the validation `Errors`.\nSee more in Spring Framework https://docs.spring.io/spring-framework/reference/core/validation.html[Reference Manual] about validation.\n\n[[webflux-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/webflux.adoc", "title": "webflux", "heading": "Payload Validation", "heading_level": 3, "file_order": 277, "section_index": 3, "content_hash": "374c769b36593a4151822c2c315733375a87b7f396c8bc98761bb00395890e53", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/webflux.adoc"}}
{"id": "sha256:07897c0358f6386f14b974b64eee01cbfb3e09223611dc8936203bfd388f3b3c", "content": "The `WebFluxRequestExecutingMessageHandler` (starting with version 5.0) implementation is similar to `HttpRequestExecutingMessageHandler`.\nIt uses a `WebClient` from the Spring Framework WebFlux module.\nTo configure it, define a bean similar to the following:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow outboundReactive() {\n return f -> f\n .handle(WebFlux.<MultiValueMap<String, String>>outboundGateway(m ->\n UriComponentsBuilder.fromUriString(\"http://localhost:8080/foo\")\n .queryParams(m.getPayload())\n .build()\n .toUri())\n .httpMethod(HttpMethod.GET)\n .expectedResponseType(String.class));\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun outboundReactive() =\n integrationFlow {\n handle(\n WebFlux.outboundGateway<MultiValueMap<String, String>>({ m ->\n UriComponentsBuilder.fromUriString(\"http://localhost:8080/foo\")\n .queryParams(m.getPayload())\n .build()\n .toUri()\n })\n .httpMethod(HttpMethod.GET)\n .expectedResponseType(String::class.java)\n )\n }\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@ServiceActivator(inputChannel = \"reactiveHttpOutRequest\")\n@Bean\npublic WebFluxRequestExecutingMessageHandler reactiveOutbound(WebClient client) {\n WebFluxRequestExecutingMessageHandler handler =\n new WebFluxRequestExecutingMessageHandler(\"http://localhost:8080/foo\", client);\n handler.setHttpMethod(HttpMethod.POST);\n handler.setExpectedResponseType(String.class);\n return handler;\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-webflux:outbound-gateway id=\"reactiveExample1\"\n request-channel=\"requests\"\n url=\"http://localhost/test\"\n http-method-expression=\"headers.httpMethod\"\n extract-request-payload=\"false\"\n expected-response-type-expression=\"payload\"\n charset=\"UTF-8\"\n reply-timeout=\"1234\"\n reply-channel=\"replies\"/>\n\n<int-webflux:outbound-channel-adapter id=\"reactiveExample2\"\n url=\"http://localhost/example\"\n http-method=\"GET\"\n channel=\"requests\"\n charset=\"UTF-8\"\n extract-payload=\"false\"\n expected-response-type=\"java.lang.String\"\n order=\"3\"\n auto-startup=\"false\"/>\n----\n======\n\nThe `WebClient` `exchange()` operation returns a `Mono<ClientResponse>`, which is mapped (by using several `Mono.map()` steps) to an `AbstractIntegrationMessageBuilder` as the output from the `WebFluxRequestExecutingMessageHandler`.\nTogether with the `ReactiveChannel` as an `outputChannel`, the `Mono<ClientResponse>` evaluation is deferred until a downstream subscription is made.\nOtherwise, it is treated as an `async` mode, and the `Mono` response is adapted to a `SettableListenableFuture` for an asynchronous reply from the `WebFluxRequestExecutingMessageHandler`.\nThe target payload of the output message depends on the `WebFluxRequestExecutingMessageHandler` configuration.\nThe `setExpectedResponseType(Class<?>)` or `setExpectedResponseTypeExpression(Expression)` identifies the target type of the response body element conversion.\nIf `replyPayloadToFlux` is set to `true`, the response body is converted to a `Flux` with the provided `expectedResponseType` for each element, and this `Flux` is sent as the payload downstream.\nAfterward, you can use a xref:splitter.adoc[splitter] to iterate over this `Flux` in a reactive manner.\n\nIn addition, a `BodyExtractor<?, ClientHttpResponse>` can be injected into the `WebFluxRequestExecutingMessageHandler` instead of the `expectedResponseType` and `replyPayloadToFlux` properties.\nIt can be used for low-level access to the `ClientHttpResponse` and more control over body and HTTP headers conversion.\nSpring Integration provides `ClientHttpResponseBodyExtractor` as a identity function to produce (downstream) the whole `ClientHttpResponse` and any other possible custom logic.\n\nStarting with version 5.2, the `WebFluxRequestExecutingMessageHandler` supports reactive `Publisher`, `Resource`, and `MultiValueMap` types as the request message payload.\nA respective `BodyInserter` is used internally to be populated into the `WebClient.RequestBodySpec`.\nWhen the payload is a reactive `Publisher`, a configured `publisherElementType` or `publisherElementTypeExpression` can be used to determine a type for the publisher's element type.\nThe expression must be resolved to a `Class<?>`, `String` which is resolved to the target `Class<?>` or `ParameterizedTypeReference`.\n\nStarting with version 5.5, the `WebFluxRequestExecutingMessageHandler` exposes an `extractResponseBody` flag (which is `true` by default) to return just the response body, or to return the whole `ResponseEntity` as the reply message payload, independently of the provided `expectedResponseType` or `replyPayloadToFlux`.\nIf a body is not present in the `ResponseEntity`, this flag is ignored and the whole `ResponseEntity` is returned.\n\nSee xref:http/outbound.adoc[HTTP Outbound Components] for more possible configuration options.\n\n[[webflux-header-mapping]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/webflux.adoc", "title": "webflux", "heading": "WebFlux Outbound Components", "heading_level": 2, "file_order": 277, "section_index": 4, "content_hash": "07897c0358f6386f14b974b64eee01cbfb3e09223611dc8936203bfd388f3b3c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/webflux.adoc"}}
{"id": "sha256:333d6e2a7198c9d09a4527c9dca498dc0143ef924d0a08235b99ab114de17c32", "content": "Since WebFlux components are fully based on the HTTP protocol, there is no difference in the HTTP headers mapping.\nSee xref:http/header-mapping.adoc[HTTP Header Mappings] for more possible options and components to use for mapping headers.\n\n[[webflux-request-attributes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/webflux.adoc", "title": "webflux", "heading": "WebFlux Header Mappings", "heading_level": 2, "file_order": 277, "section_index": 5, "content_hash": "333d6e2a7198c9d09a4527c9dca498dc0143ef924d0a08235b99ab114de17c32", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/webflux.adoc"}}
{"id": "sha256:bb12e78830efeba1096782409472cdae3a6a7edaaffc1fdac44fb8f7d24e9e89", "content": "Starting with version 6.0, the `WebFluxRequestExecutingMessageHandler` can be configured to evaluate request attributes via `setAttributeVariablesExpression()`.\nThis SpEL expression must be evaluated in `Map`.\nSuch a map is then propagated to the `WebClient.RequestBodySpec.attributes(Consumer<Map<String, Object>> attributesConsumer)` HTTP request configuration callback.\nThis will be helpful if information in a form of a key-value object needs to be passed from `Message` to request and downstream filter will get access to these attributes for further processing.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/webflux.adoc", "title": "webflux", "heading": "WebFlux Request Attributes", "heading_level": 2, "file_order": 277, "section_index": 6, "content_hash": "bb12e78830efeba1096782409472cdae3a6a7edaaffc1fdac44fb8f7d24e9e89", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/webflux.adoc"}}
{"id": "sha256:6ca0d1168bdd164f689f9eb99143ecb5f075a869d54ae018f5dda93e4f9763dd", "content": "[[whats-new-part]]\n\n[[spring-integration-intro-new]]\nFor those who are already familiar with Spring Integration, this chapter provides a brief overview of the new features of version 7.1.\n\nIf you are interested in the changes and features that were introduced in earlier versions, see the xref:history.adoc[Change History].\n\n[[what-s-new-in-spring-integration-7-1]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/whats-new.adoc", "title": "whats-new", "heading": "whats-new", "heading_level": 1, "file_order": 278, "section_index": 0, "content_hash": "6ca0d1168bdd164f689f9eb99143ecb5f075a869d54ae018f5dda93e4f9763dd", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/whats-new.adoc"}}
{"id": "sha256:7cbabbc147e7e0524e53ddc47884a6084822d47a4d01640e6217843e3a0363a2", "content": "For more details, see the https://github.com/spring-projects/spring-integration/issues[GitHub Issues] that were resolved as part of the 7.1 development process.\n\nIn general, the project has been moved to the latest dependency versions.\nJava 17 is still the baseline, but Java 25 is supported.\n\n[[x7.1-general-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/whats-new.adoc", "title": "whats-new", "heading": "What's New in Spring Integration 7.1?", "heading_level": 2, "file_order": 278, "section_index": 1, "content_hash": "7cbabbc147e7e0524e53ddc47884a6084822d47a4d01640e6217843e3a0363a2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/whats-new.adoc"}}
{"id": "sha256:cdc5abc509f89f5a41db1be33129fd6c60de49ef2819b59d167e00e942a3d8e3", "content": "The `MessageTransformingHandler.requiresReply` flag cannot be modified: an `UnsupportedOperationException` is thrown from the overridden `setRequiresReply()` method to indicate the transformer pattern cannot produce nulls for replies.\nSee xref:transformer.adoc[] for more information.\n\n[[x7.1-web-services-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/whats-new.adoc", "title": "whats-new", "heading": "General Changes", "heading_level": 3, "file_order": 278, "section_index": 2, "content_hash": "cdc5abc509f89f5a41db1be33129fd6c60de49ef2819b59d167e00e942a3d8e3", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/whats-new.adoc"}}
{"id": "sha256:665e28eada40e2ab72a3e84fbee0fd0190c2577d74941a3c29036423ea3bf6e6", "content": "The Web Services Outbound Gateway now can rely on the provided `WebServiceTemplate.defaultUri`.\nSee xref:ws.adoc[] for more information.\n\n[[x7.1-cloudevents]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/whats-new.adoc", "title": "whats-new", "heading": "Web Services Support Changes", "heading_level": 3, "file_order": 278, "section_index": 3, "content_hash": "665e28eada40e2ab72a3e84fbee0fd0190c2577d74941a3c29036423ea3bf6e6", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/whats-new.adoc"}}
{"id": "sha256:83da2efe137b588f7edd175f2f3d101e40cb9d67fb6e65007230b816868d9c35", "content": "The new `spring-integration-cloudevents` module has been introduced to support CloudEvents specification.\nSee xref:cloudevents.adoc[] for more information.\n\n[[x7.1-grpc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/whats-new.adoc", "title": "whats-new", "heading": "CloudEvents", "heading_level": 3, "file_order": 278, "section_index": 4, "content_hash": "83da2efe137b588f7edd175f2f3d101e40cb9d67fb6e65007230b816868d9c35", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/whats-new.adoc"}}
{"id": "sha256:d20b447dbdee8cdd91ece43ee7aba90b9db1ea4cd33e7d00e86fc251b11783e5", "content": "The new `spring-integration-grpc` module has been introduced to support gRPC framework.\nSee xref:grpc.adoc[] for more information.\n\n[[x7.1-testing-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/whats-new.adoc", "title": "whats-new", "heading": "gRPC", "heading_level": 3, "file_order": 278, "section_index": 5, "content_hash": "d20b447dbdee8cdd91ece43ee7aba90b9db1ea4cd33e7d00e86fc251b11783e5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/whats-new.adoc"}}
{"id": "sha256:8335d1ac04e58a556ec1b196220b06cb41cf65e1f0eb384b13da98fdebed2828", "content": "The `TestUtils.getPropertyValue()` with a `Class<?>` argument has been deprecated in favor of the change on the overloaded method from an `Object` return type to the generic argument.\nThis gives a flexible casting of the extracted value to the expected type in tests logic.\nSee xref:testing.adoc[] for more information.\n\n[[x7.1-redis-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/whats-new.adoc", "title": "whats-new", "heading": "Testing Support Changes", "heading_level": 3, "file_order": 278, "section_index": 6, "content_hash": "8335d1ac04e58a556ec1b196220b06cb41cf65e1f0eb384b13da98fdebed2828", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/whats-new.adoc"}}
{"id": "sha256:eb3adc5264e2c215fae4ad094b7db059956ca1e8ea450de1e93b0827aca3ae3f", "content": "The `RedisMessageStore.doRemove` now uses `GETDEL` instead of `GET` + `UNLINK` for Redis 6.2+ by default.\nUse `RedisMessageStore.setUseUnlink(true)` to use `GET` + `UNLINK` when atomicity is not required and `GETDEL` causes noticeable Redis latency.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/whats-new.adoc", "title": "whats-new", "heading": "Redis Support Changes", "heading_level": 3, "file_order": 278, "section_index": 7, "content_hash": "eb3adc5264e2c215fae4ad094b7db059956ca1e8ea450de1e93b0827aca3ae3f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/whats-new.adoc"}}
{"id": "sha256:15c5554f2d226636fff74c26ff16aec671a68423625675082a7d6e9e7f8974ac", "content": "[[ws]]\n\nThis chapter describes Spring Integration's support for web services, including:\n\n* xref:ws.adoc#webservices-outbound[Outbound Web Service Gateways]\n* xref:ws.adoc#webservices-inbound[Inbound Web Service Gateways]\n* xref:ws.adoc#webservices-namespace[Web Service Namespace Support]\n* xref:ws.adoc#outbound-uri[Outbound URI Configuration]\n* xref:ws.adoc#ws-message-headers[WS Message Headers]\n* xref:ws.adoc#mtom-support[MTOM Support]\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-ws</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-ws:{project-version}\"\n----\n======\n\n[[webservices-outbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ws.adoc", "title": "ws", "heading": "ws", "heading_level": 1, "file_order": 279, "section_index": 0, "content_hash": "15c5554f2d226636fff74c26ff16aec671a68423625675082a7d6e9e7f8974ac", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ws.adoc"}}
{"id": "sha256:86c4b0ba1bdd1f6fb4a49a17834a70ea08ebcebc6a503450d919715ea4321219", "content": "To invoke a web service when you send a message to a channel, you have two options, both of which build upon the https://projects.spring.io/spring-ws/[Spring Web Services] project: `SimpleWebServiceOutboundGateway` and `MarshallingWebServiceOutboundGateway`.\nThe former accepts either a `String` or `javax.xml.transform.Source` as the message payload.\nThe latter supports any implementation of the `Marshaller` and `Unmarshaller` interfaces.\nBoth require a Spring Web Services `DestinationProvider` to determine the URI of the web service to be called, or an explicit URI can be provided directly or via `WebServiceTemplate.defaultUri` (since version 7.1).\nThe following example shows both options for invoking a web service:\n\n[source,java]\n----\n simpleGateway = new SimpleWebServiceOutboundGateway(destinationProvider);\n\n marshallingGateway = new MarshallingWebServiceOutboundGateway(destinationProvider, marshaller);\n----\n\nNOTE: When using the namespace support (xref:ws.adoc#webservices-namespace[described later]), you need only set a URI.\nInternally, the parser configures a fixed URI `DestinationProvider` implementation.\nIf you need dynamic resolution of the URI at runtime, however, then the `DestinationProvider` can provide such behavior as looking up the URI from a registry.\nSee the Spring Web Services https://docs.spring.io/spring-ws/docs/current/api/org/springframework/ws/client/support/destination/DestinationProvider.html[`DestinationProvider`] Javadoc for more information about this strategy.\n\nStarting with version 5.0, you can supply the `SimpleWebServiceOutboundGateway` and `MarshallingWebServiceOutboundGateway` with an external `WebServiceTemplate` instance, which you can configure for any custom properties, including `checkConnectionForFault` (which allows your application to deal with non-conforming services).\n\nFor more detail on the inner workings, see the Spring Web Services reference guide's chapter covering https://docs.spring.io/spring-ws/docs/current/reference/#client[client access] and the chapter covering https://docs.spring.io/spring-framework/reference/data-access/oxm.html[Object/XML mapping].\n\n[[webservices-inbound]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ws.adoc", "title": "ws", "heading": "Outbound Web Service Gateways", "heading_level": 2, "file_order": 279, "section_index": 1, "content_hash": "86c4b0ba1bdd1f6fb4a49a17834a70ea08ebcebc6a503450d919715ea4321219", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ws.adoc"}}
{"id": "sha256:b7b346286f8e189da49653b26d72bc7cddb8171aa5ba2bc4ddf2dd5cdaa9a84d", "content": "To send a message to a channel upon receiving a web service invocation, you again have two options: `SimpleWebServiceInboundGateway` and `MarshallingWebServiceInboundGateway`.\nThe former extracts a `javax.xml.transform.Source` from the `WebServiceMessage` and sets it as the message payload.\nThe latter supports implementation of the `Marshaller` and `Unmarshaller` interfaces.\nIf the incoming web service message is a SOAP message, the SOAP action header is added to the headers of the `Message` that is forwarded onto the request channel.\nThe following example shows both options:\n\n[source,java]\n----\n simpleGateway = new SimpleWebServiceInboundGateway();\n simpleGateway.setRequestChannel(forwardOntoThisChannel);\n simpleGateway.setReplyChannel(listenForResponseHere); //Optional\n\n marshallingGateway = new MarshallingWebServiceInboundGateway(marshaller);\n //set request and optionally reply channel\n----\n\nBoth gateways implement the Spring Web Services `MessageEndpoint` interface, so they can be configured with a `MessageDispatcherServlet` as per standard Spring Web Services configuration.\n\nFor more detail on how to use these components, see the Spring Web Services reference guide's chapter covering https://docs.spring.io/spring-ws/docs/current/reference/#server[creating a web service].\nThe chapter covering https://docs.spring.io/spring-framework/reference/data-access/oxm.html[Object/XML mapping] is also applicable again.\n\nTo add the `SimpleWebServiceInboundGateway` and `MarshallingWebServiceInboundGateway` configurations to the Spring WS infrastructure, you should add the `EndpointMapping` definition between `MessageDispatcherServlet` and the target `MessageEndpoint` implementations, as you would for a normal Spring WS application.\nFor this purpose (from the Spring Integration perspective), Spring WS provides the following convenient `EndpointMapping` implementations:\n\n* `o.s.ws.server.endpoint.mapping.UriEndpointMapping`\n* `o.s.ws.server.endpoint.mapping.PayloadRootQNameEndpointMapping`\n* `o.s.ws.soap.server.endpoint.mapping.SoapActionEndpointMapping`\n* `o.s.ws.server.endpoint.mapping.XPathPayloadEndpointMapping`\n\nYou must specify the beans for these classes in the application context and reference the `SimpleWebServiceInboundGateway` and/or `MarshallingWebServiceInboundGateway` bean definitions according to the WS mapping algorithm.\n\nSee the https://docs.spring.io/spring-ws/docs/current/reference/#server-endpoint-mapping[endpoint mappings] for more information.\n\n[[webservices-namespace]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ws.adoc", "title": "ws", "heading": "Inbound Web Service Gateways", "heading_level": 2, "file_order": 279, "section_index": 2, "content_hash": "b7b346286f8e189da49653b26d72bc7cddb8171aa5ba2bc4ddf2dd5cdaa9a84d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ws.adoc"}}
{"id": "sha256:085155b63ac56a70657c49c707519b86c611de18bf2208c4bf9b158f2487f51d", "content": "To configure an outbound web service gateway, use the `outbound-gateway` element from the `ws` namespace, as the following example shows:\n\n[source,xml]\n----\n<int-ws:outbound-gateway id=\"simpleGateway\"\n request-channel=\"inputChannel\"\n uri=\"https://example.org\"/>\n----\n\nNOTE: This example does not provide a 'reply-channel'.\nIf the web service returns a non-empty response, the `Message` containing that response is sent to the reply channel defined in the request message's `REPLY_CHANNEL` header.\nIf that is not available, a channel resolution exception is thrown.\nIf you want to send the reply to another channel instead, provide a 'reply-channel' attribute on the 'outbound-gateway' element.\n\nTIP: By default, when you invoke a web service that returns an empty response after using a String payload for the request `Message`, no reply `Message` is sent.\nTherefore, you need not set a 'reply-channel' or have a `REPLY_CHANNEL` header in the request `Message`.\nIf you actually do want to receive the empty response as a `Message`, you can set the 'ignore-empty-responses' attribute to `false`.\nDoing so works only for `String` objects, because using a `Source` or a `Document` object leads to a null response and consequently never generates a reply `Message`.\n\nTo set up an inbound Web Service Gateway, use the `inbound-gateway` element, as the following example shows:\n\n[source,xml]\n----\n<int-ws:inbound-gateway id=\"simpleGateway\"\n request-channel=\"inputChannel\"/>\n----\n\nTo use Spring OXM marshallers or unmarshallers, you must provide bean references.\nThe following example shows how to provide a bean reference for an outbound marshalling gateway:\n\n[source,xml]\n----\n<int-ws:outbound-gateway id=\"marshallingGateway\"\n request-channel=\"requestChannel\"\n uri=\"https://example.org\"\n marshaller=\"someMarshaller\"\n unmarshaller=\"someUnmarshaller\"/>\n----\n\nThe following example shows how to provide a bean reference for an inbound marshalling gateway:\n\n[source,xml]\n----\n<int-ws:inbound-gateway id=\"marshallingGateway\"\n request-channel=\"requestChannel\"\n marshaller=\"someMarshaller\"\n unmarshaller=\"someUnmarshaller\"/>\n----\n\nNOTE: Most `Marshaller` implementations also implement the `Unmarshaller` interface.\nWhen using such a `Marshaller`, only the `marshaller` attribute is necessary.\nEven when using a `Marshaller`, you may also provide a reference for the `request-callback` on the outbound gateways.\n\nFor either outbound gateway type, you can specify a `destination-provider` attribute instead of the `uri` (exactly one of them is required).\nYou can then reference any Spring Web Services `DestinationProvider` implementation (for example, to look up the URI from a registry at runtime).\n\nFor either outbound gateway type, the `message-factory` attribute can also be configured with a reference to any Spring Web Services `WebServiceMessageFactory` implementation.\n\nFor the simple inbound gateway type, you can set the `extract-payload` attribute to `false` to forward the entire `WebServiceMessage` instead of just its payload as a `Message` to the request channel.\nDoing so might be useful, for example, when a custom transformer works against the `WebServiceMessage` directly.\n\nStarting with version 5.0, the `web-service-template` reference attribute lets you inject a `WebServiceTemplate` with any possible custom properties.\n\n[[webservices-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ws.adoc", "title": "ws", "heading": "Web Service Namespace Support", "heading_level": 2, "file_order": 279, "section_index": 3, "content_hash": "085155b63ac56a70657c49c707519b86c611de18bf2208c4bf9b158f2487f51d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ws.adoc"}}
{"id": "sha256:07f142dc61fa97d42e6d8c1c62647873f22184906321199f5f081c5017fdd4a2", "content": "The equivalent configuration for the gateways shown in xref:ws.adoc#webservices-namespace[Web Service Namespace Support] is shown in the following snippets:\n\n[source, java]\n----\n@Bean\nIntegrationFlow inbound() {\n return IntegrationFlow.from(Ws.simpleInboundGateway()\n .id(\"simpleGateway\"))\n ...\n .get();\n}\n----\n\n[source, java]\n----\n@Bean\nIntegrationFlow outboundMarshalled() {\n return f -> f.handle(Ws.marshallingOutboundGateway()\n .id(\"marshallingGateway\")\n .marshaller(someMarshaller())\n .unmarshaller(someUnmarshalller()))\n ...\n}\n----\n\n[source, java]\n----\n@Bean\nIntegrationFlow inboundMarshalled() {\n return IntegrationFlow.from(Ws.marshallingInboundGateway()\n .marshaller(someMarshaller())\n .unmarshaller(someUnmarshalller())\n .id(\"marshallingGateway\"))\n ...\n .get();\n}\n----\n\nOther properties can be set on the endpoint specs in a fluent manner (with the properties depending on whether an external `WebServiceTemplate` has been provided for outbound gateways).\nExamples:\n\n[source, java]\n----\n.from(Ws.simpleInboundGateway()\n .extractPayload(false))\n----\n\n[source, java]\n----\n.handle(Ws.simpleOutboundGateway(template)\n .uri(uri)\n .sourceExtractor(sourceExtractor)\n .encodingMode(DefaultUriBuilderFactory.EncodingMode.NONE)\n .headerMapper(headerMapper)\n .ignoreEmptyResponses(true)\n .requestCallback(requestCallback)\n .uriVariableExpressions(uriVariableExpressions)\n .extractPayload(false))\n)\n----\n\n[source, java]\n----\n.handle(Ws.marshallingOutboundGateway()\n .destinationProvider(destinationProvider)\n .marshaller(marshaller)\n .unmarshaller(unmarshaller)\n .messageFactory(messageFactory)\n .encodingMode(DefaultUriBuilderFactory.EncodingMode.VALUES_ONLY)\n .faultMessageResolver(faultMessageResolver)\n .headerMapper(headerMapper)\n .ignoreEmptyResponses(true)\n .interceptors(interceptor)\n .messageSenders(messageSender)\n .requestCallback(requestCallback)\n .uriVariableExpressions(uriVariableExpressions))\n----\n\n[source, java]\n----\n.handle(Ws.marshallingOutboundGateway(template)\n .uri(uri)\n .encodingMode(DefaultUriBuilderFactory.EncodingMode.URI_COMPONENT)\n .headerMapper(headerMapper)\n .ignoreEmptyResponses(true)\n .requestCallback(requestCallback)\n .uriVariableExpressions(uriVariableExpressions))\n)\n----\n\n[[outbound-uri]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ws.adoc", "title": "ws", "heading": "Web Service Java DSL Support", "heading_level": 2, "file_order": 279, "section_index": 4, "content_hash": "07f142dc61fa97d42e6d8c1c62647873f22184906321199f5f081c5017fdd4a2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ws.adoc"}}
{"id": "sha256:58ab0021e092fe593b8106a215842baa9a06fd4bff00ef4de28f700d1a82cc6a", "content": "For all URI schemes supported by Spring Web Services (see https://docs.spring.io/spring-ws/docs/current/reference/#client-transports[URIs and Transports]) `<uri-variable/>` substitution is provided.\nThe following example shows how to define it:\n\n[source,xml]\n----\n<ws:outbound-gateway id=\"gateway\" request-channel=\"input\"\n uri=\"https://springsource.org/{thing1}-{thing2}\">\n <ws:uri-variable name=\"thing1\" expression=\"payload.substring(1,7)\"/>\n <ws:uri-variable name=\"thing2\" expression=\"headers.x\"/>\n</ws:outbound-gateway>\n\n<ws:outbound-gateway request-channel=\"inputJms\"\n uri=\"jms:{destination}?deliveryMode={deliveryMode}&amp;priority={priority}\"\n message-sender=\"jmsMessageSender\">\n <ws:uri-variable name=\"destination\" expression=\"headers.jmsQueue\"/>\n <ws:uri-variable name=\"deliveryMode\" expression=\"headers.deliveryMode\"/>\n <ws:uri-variable name=\"priority\" expression=\"headers.jms_priority\"/>\n</ws:outbound-gateway>\n----\n\nIf you supply a `DestinationProvider`, variable substitution is not supported and a configuration error occurs if you provide variables.\n\n[[controlling-uri-encoding]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ws.adoc", "title": "ws", "heading": "Outbound URI Configuration", "heading_level": 2, "file_order": 279, "section_index": 5, "content_hash": "58ab0021e092fe593b8106a215842baa9a06fd4bff00ef4de28f700d1a82cc6a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ws.adoc"}}
{"id": "sha256:71513604a788224d99c8f11b4eae422cfaae3980fc2261e57b139b8354097af9", "content": "By default, the URL string is encoded (see https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html[`UriComponentsBuilder`]) to the URI object before sending the request.\nIn some scenarios with a non-standard URI, it is undesirable to perform the encoding.\nThe `<ws:outbound-gateway/>` element provides an `encoding-mode` attribute.\nTo disable encoding the URL, set this attribute to `NONE` (by default, it is `TEMPLATE_AND_VALUES`).\nIf you wish to partially encode some of the URL, you can do so by using an `expression` within a `<uri-variable/>`, as the following example shows:\n\n[source,xml]\n----\n<ws:outbound-gateway url=\"https://somehost/%2f/someApps?someKey={param}\" encoding-mode=\"NONE\">\n <http:uri-variable name=\"param\"\n expression=\"T(org.apache.commons.httpclient.util.URIUtil)\n .encodeWithinQuery('Hello World!')\"/>\n</ws:outbound-gateway>\n----\n\nNOTE: If you set `DestinationProvider`, `encoding-mode` is ignored.\n\n[[ws-message-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ws.adoc", "title": "ws", "heading": "Controlling URI Encoding", "heading_level": 3, "file_order": 279, "section_index": 6, "content_hash": "71513604a788224d99c8f11b4eae422cfaae3980fc2261e57b139b8354097af9", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ws.adoc"}}
{"id": "sha256:8087a9936b08528a72fe66463397360b4d67460027657a574b4b25cbaa3d758f", "content": "The Spring Integration web service gateways automatically map the SOAP action header.\nBy default, it is copied to and from Spring Integration `MessageHeaders` by using the https://docs.spring.io/spring-integration/api/org/springframework/integration/ws/DefaultSoapHeaderMapper.html[`DefaultSoapHeaderMapper`].\n\nYou can pass in your own implementation of SOAP-specific header mappers, as the gateways have properties to support doing so.\n\nUnless explicitly specified by the `requestHeaderNames` or `replyHeaderNames` properties of the `DefaultSoapHeaderMapper`, any user-defined SOAP headers are not copied to or from a SOAP Message.\n\nWhen you use the XML namespace for configuration, you can set these properties by using the `mapped-request-headers` and `mapped-reply-headers` attributes, you can provide a custom mapper by setting the `header-mapper` attribute.\n\nTIP: When mapping user-defined headers, the values can also contain simple wildcard patterns (such `myheader*` or `*myheader`).\nFor example, if you need to copy all user-defined headers, you can use the wildcard character: `*`.\n\nStarting with version 4.1, the `AbstractHeaderMapper` (a `DefaultSoapHeaderMapper` superclass) lets the `NON_STANDARD_HEADERS` token be configured for the `requestHeaderNames` and `replyHeaderNames` properties (in addition to existing `STANDARD_REQUEST_HEADERS` and `STANDARD_REPLY_HEADERS`) to map all user-defined headers.\n\nNOTE: Rather than using the wildcard (`*`), we recommend using the following combination : `STANDARD_REPLY_HEADERS, NON_STANDARD_HEADERS`.\nDoing so avoids mapping `request` headers to the reply.\n\nStarting with version 4.3, you can negate patterns in the header mappings by preceding the pattern with `!`.\nNegated patterns get priority, so a list such as `STANDARD_REQUEST_HEADERS,thing1,thing*,!thing2,!thing3,thing5,!thing1` does not map `thing1`, `thing2`, or `thing3`.\nIt does map the standard headers, `thing4`, and `thing5`.\n(Note that `thing1` is included in both non-negated and negated forms.\nBecause negated values take precedence, `thing1` is not mapped.)\n\nIMPORTANT: If you have a user-defined header that begins with `!` that you do wish to map, you can escape it with `\\`, as follows: `STANDARD_REQUEST_HEADERS,\\!myBangHeader`.\nA `!myBangHeader` is then mapped.\n\nInbound SOAP headers (request headers for the inbound gateway and reply headers for the outbound gateway) are mapped as `SoapHeaderElement` objects.\nYou can explore the contents by accessing the `Source`:\n\n[source, xml]\n----\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n <soapenv:Header>\n <auth>\n <username>user</username>\n <password>pass</password>\n </auth>\n <cat>CAT</cat>\n <can>CAN</can>\n <dog>DOG</dog>\n </soapenv:Header>\n <soapenv:Body>\n ...\n </soapenv:Body>\n</soapenv:Envelope>\n----\n\nIf `mapped-request-headers` is `auth, ca*`, the `auth`, `cat`, and `can` headers are mapped, but `dog` is not mapped.\n\nThe following example shows how to get a value named `user` from a header named `auth`:\n\n[source, java]\n----\n...\nSoapHeaderElement header = (SoapHeaderElement) headers.get(\"auth\");\nDOMSource source = (DOMSource) header.getSource();\nNodeList nodeList = source.getNode().getChildNodes();\nassertEquals(\"username\", nodeList.item(0).getNodeName());\nassertEquals(\"user\", nodeList.item(0).getFirstChild().getNodeValue());\n...\n----\n\nStarting with version 5.0, the `DefaultSoapHeaderMapper` supports user-defined headers of type `javax.xml.transform.Source` and populates them as child nodes of the `<soapenv:Header>`.\nThe following example shows how to do so:\n\n[source, java]\n----\nMap<String, Object> headers = new HashMap<>();\n\nString authXml =\n \"<auth xmlns='http://test.auth.org'>\"\n + \"<username>user</username>\"\n + \"<password>pass</password>\"\n + \"</auth>\";\nheaders.put(\"auth\", new StringSource(authXml));\n...\nDefaultSoapHeaderMapper mapper = new DefaultSoapHeaderMapper();\nmapper.setRequestHeaderNames(\"auth\");\n----\n\nThe result of the preceding examples is the following SOAP envelope:\n\n[source, xml]\n----\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\">\n <soapenv:Header>\n <auth xmlns=\"http://test.auth.org\">\n <username>user</username>\n <password>pass</password>\n </auth>\n </soapenv:Header>\n <soapenv:Body>\n ...\n </soapenv:Body>\n</soapenv:Envelope>\n----\n\n[[mtom-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ws.adoc", "title": "ws", "heading": "WS Message Headers", "heading_level": 2, "file_order": 279, "section_index": 7, "content_hash": "8087a9936b08528a72fe66463397360b4d67460027657a574b4b25cbaa3d758f", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ws.adoc"}}
{"id": "sha256:da4db16288010fd3dff3264df360d4eeb04620e0c877b420fce9cf3d443c8427", "content": "The marshalling inbound and outbound web service gateways support attachments directly through built-in functionality of the marshaller, (for example, `Jaxb2Marshaller` provides the `mtomEnabled` option).\nStarting with version 5.0, the simple web service gateways can directly operate with inbound and outbound `MimeMessage` instances, which have an API to manipulate attachments.\nWhen you need to send a web service message with attachments (either a reply from a server or a client request) you should use the `WebServiceMessageFactory` directly and send a `WebServiceMessage` with attachments as a `payload` to the request or reply channel of the gateway.\nThe following example shows how to do so:\n\n[source, java]\n----\nWebServiceMessageFactory messageFactory = new SaajSoapMessageFactory(MessageFactory.newInstance());\nMimeMessage webServiceMessage = (MimeMessage) messageFactory.createWebServiceMessage();\n\nString request = \"<test>test data</test>\";\n\nTransformerFactory transformerFactory = TransformerFactory.newInstance();\nTransformer transformer = transformerFactory.newTransformer();\ntransformer.transform(new StringSource(request), webServiceMessage.getPayloadResult());\n\nwebServiceMessage.addAttachment(\"myAttachment\", new ByteArrayResource(\"my_data\".getBytes()), \"plain/text\");\n\nthis.webServiceChannel.send(new GenericMessage<>(webServiceMessage));\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/ws.adoc", "title": "ws", "heading": "MTOM Support", "heading_level": 2, "file_order": 279, "section_index": 8, "content_hash": "da4db16288010fd3dff3264df360d4eeb04620e0c877b420fce9cf3d443c8427", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/ws.adoc"}}
{"id": "sha256:cdc363b76db817ce8d6316119c31a0582efaaef5236d2a9fbd4a5e5c305f4cd1", "content": "[[xml]]\n\nSpring Integration's XML support extends the core of Spring Integration with the following components:\n\n* xref:xml/transformation.adoc[Marshalling Transformer]\n* xref:xml/transformation.adoc[Unmarshalling Transformer]\n* xref:xml/transformation.adoc[XSLT Transformer]\n* xref:xml/xpath-transformer.adoc[XPath Transformer]\n* xref:xml/xpath-splitting.adoc[XPath Splitter]\n* xref:xml/xpath-routing.adoc[XPath Router]\n* xref:xml/xpath-header-enricher.adoc[XPath Header Enricher]\n* xref:xml/xpath-filter.adoc[XPath Filter]\n* xref:xml/xpath-spel-function.adoc[#xpath SpEL Function]\n* xref:xml/validating-filter.adoc[Validating Filter]\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-xml</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-xml:{project-version}\"\n----\n======\n\nThese components make working with XML messages in Spring Integration simpler.\nThe messaging components work with XML that is represented in a range of formats, including instances of `java.lang.String`, `org.w3c.dom.Document`, and `javax.xml.transform.Source`.\nHowever, where a DOM representation is required, (for example, in order to evaluate an XPath expression), the `String` payload is converted into the required type and then converted back to `String`.\nComponents that require an instance of `DocumentBuilder` create a namespace-aware instance if you do not provide one.\nWhen you require greater control over document creation, you can provide an appropriately configured instance of `DocumentBuilder`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xml.adoc", "title": "xml", "heading": "xml", "heading_level": 1, "file_order": 280, "section_index": 0, "content_hash": "cdc363b76db817ce8d6316119c31a0582efaaef5236d2a9fbd4a5e5c305f4cd1", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xml.adoc"}}
{"id": "sha256:317761be3520282c2130100970654702f06425c3faede7264042aafa3cf22a9b", "content": "[[xmpp]]\n\nSpring Integration provides channel adapters for https://www.xmpp.org[XMPP].\nXMPP stands for \"`Extensible Messaging and Presence Protocol`\".\n\nXMPP describes a way for multiple agents to communicate with each other in a distributed system.\nThe canonical use case is to send and receive chat messages, though XMPP can be (and is) used for other kinds of applications.\nXMPP describes a network of actors.\nWithin that network, actors may address each other directly and broadcast status changes (such as \"`presence`\").\n\nXMPP provides the messaging fabric that underlies some of the biggest instant messaging networks in the world, including Google Talk (GTalk, which is also available from within GMail) and Facebook Chat.\nMany good open-source XMPP servers are available.\nTwo popular implementations are https://www.igniterealtime.org/projects/openfire/[Openfire] and https://www.ejabberd.im[ejabberd].\n\nSpring integration provides support for XMPP by providing XMPP adapters, which support sending and receiving both XMPP chat messages and presence changes from other entries in a client's roster.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-xmpp</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-xmpp:{project-version}\"\n----\n======\n\nAs with other adapters, the XMPP adapters come with support for a convenient namespace-based configuration.\nTo configure the XMPP namespace, include the following elements in the headers of your XML configuration file:\n\n[source,xml]\n----\nxmlns:int-xmpp=\"http://www.springframework.org/schema/integration/xmpp\"\nxsi:schemaLocation=\"http://www.springframework.org/schema/integration/xmpp\n\thttps://www.springframework.org/schema/integration/xmpp/spring-integration-xmpp.xsd\"\n----\n\n[[xmpp-connection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xmpp.adoc", "title": "xmpp", "heading": "xmpp", "heading_level": 1, "file_order": 281, "section_index": 0, "content_hash": "317761be3520282c2130100970654702f06425c3faede7264042aafa3cf22a9b", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xmpp.adoc"}}
{"id": "sha256:daf048ca79ba275c30e0e03c4f081500e9a9a46dac7c8926237a6ea0a40d6791", "content": "Before using inbound or outbound XMPP adapters to participate in the XMPP network, an actor must establish its XMPP connection.\nAll XMPP adapters connected to a particular account can share this connection object.\nTypically, this requires (at a minimum) `user`, `password`, and `host`.\nTo create a basic XMPP connection, you can use the convenience of the namespace, as the following example shows:\n\n[source,xml]\n----\n<int-xmpp:xmpp-connection\n id=\"myConnection\"\n user=\"user\"\n password=\"password\"\n host=\"host\"\n port=\"port\"\n resource=\"theNameOfTheResource\"\n subscription-mode=\"accept_all\"/>\n----\n\nNOTE: For added convenience, you can rely on the default naming convention and omit the `id` attribute.\nThe default name (`xmppConnection`) is used for this connection bean.\n\nIf the XMPP connection goes stale, reconnection attempts are made with an automatic login as long as the previous connection state was logged (authenticated).\nWe also register a `ConnectionListener`, which logs connection events if the `DEBUG` logging level is enabled.\n\nThe `subscription-mode` attribute initiates the roster listener to deal with incoming subscriptions from other users.\nThis functionality is not always available for the target XMPP servers.\nFor example, Google Cloud Messaging (GCM) and Firebase Cloud Messaging (FCM) fully disable it.\nTo switch off the roster listener for subscriptions, you can configure it with an empty string when using XML configuration (`subscription-mode=\"\"`) or with `XmppConnectionFactoryBean.setSubscriptionMode(null)` when using Java Configuration.\nDoing so disables the roster at the login phase as well.\nSee https://download.igniterealtime.org/smack/docs/latest/javadoc/org/jivesoftware/smack/roster/Roster.html#setRosterLoadedAtLogin-boolean-[`Roster.setRosterLoadedAtLogin(boolean)`] for more information.\n\n[[xmpp-messages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xmpp.adoc", "title": "xmpp", "heading": "XMPP Connection", "heading_level": 2, "file_order": 281, "section_index": 1, "content_hash": "daf048ca79ba275c30e0e03c4f081500e9a9a46dac7c8926237a6ea0a40d6791", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xmpp.adoc"}}
{"id": "sha256:7cae2c089550522b91bcef32bb1be9d3b867872ed7aac3eeaf597d069982bf21", "content": "Spring Integration provides support for sending and receiving XMPP messages.\nFor receiving them, it offers an inbound message channel adapter.\nFor sending them, it offers an outbound message channel adapter.\n\n[[xmpp-message-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xmpp.adoc", "title": "xmpp", "heading": "XMPP Messages", "heading_level": 2, "file_order": 281, "section_index": 2, "content_hash": "7cae2c089550522b91bcef32bb1be9d3b867872ed7aac3eeaf597d069982bf21", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xmpp.adoc"}}
{"id": "sha256:ea2c58933d4e978785d2868d6e39ea13b580f15c2bddad88d98224a116605460", "content": "The Spring Integration adapters support receiving chat messages from other users in the system.\nTo do so, the inbound message channel adapter \"`logs in`\" as a user on your behalf and receives the messages sent to that user.\nThose messages are then forwarded to your Spring Integration client.\nThe `inbound-channel-adapter` element provides Configuration support for the XMPP inbound message channel adapter.\nThe following example shows how to configure it:\n\n[source,xml]\n----\n<int-xmpp:inbound-channel-adapter id=\"xmppInboundAdapter\"\n\tchannel=\"xmppInbound\"\n\txmpp-connection=\"testConnection\"\n\tpayload-expression=\"getExtension('google:mobile:data').json\"\n\tstanza-filter=\"stanzaFilter\"\n\tauto-startup=\"true\"/>\n----\n\nAlong with the usual attributes (for a message channel adapter), this adapter also requires a reference to an XMPP Connection.\n\nThe XMPP inbound adapter is event-driven and a `Lifecycle` implementation.\nWhen started, it registers a `PacketListener` that listens for incoming XMPP chat messages.\nIt forwards any received messages to the underlying adapter, which converts them to Spring Integration messages and sends them to the specified `channel`.\nWhen stopped, it unregisters the `PacketListener`.\n\nStarting with version 4.3, the `ChatMessageListeningEndpoint` (and its `<int-xmpp:inbound-channel-adapter>`) supports the injection of a `org.jivesoftware.smack.filter.StanzaFilter` to be registered on the provided `XMPPConnection`, together with an internal `StanzaListener` implementation.\nSee the https://www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/XMPPConnection.html#addAsyncStanzaListener%28org.jivesoftware.smack.StanzaListener,%20org.jivesoftware.smack.filter.StanzaFilter%29[Javadoc] for more information.\n\nVersion 4.3 introduced the `payload-expression` attribute for the `ChatMessageListeningEndpoint`.\nThe incoming `org.jivesoftware.smack.packet.Message` represents a root object for the evaluation context.\nThis option is useful when you use xref:xmpp.adoc#xmpp-extensions[XMPP extensions].\nFor example, for the GCM protocol we can extract the body by using the following expression:\n\n[source,xml]\n----\npayload-expression=\"getExtension('google:mobile:data').json\"\n----\n\nThe following example extracts the body for the XHTML protocol:\n\n[source,xml]\n----\npayload-expression=\"getExtension(T(org.jivesoftware.smackx.xhtmlim.packet.XHTMLExtension).NAMESPACE).bodies[0]\"\n----\n\nTo simplify access to the extension in the XMPP Message, the `extension` variable is added into the `EvaluationContext`.\nNote that it is added when only one extension is present in the message.\nThe preceding examples that show the `namespace` manipulations can be simplified to the following example:\n\n[source,xml]\n----\npayload-expression=\"#extension.json\"\npayload-expression=\"#extension.bodies[0]\"\n----\n\n[[xmpp-message-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xmpp.adoc", "title": "xmpp", "heading": "Inbound Message Channel Adapter", "heading_level": 3, "file_order": 281, "section_index": 3, "content_hash": "ea2c58933d4e978785d2868d6e39ea13b580f15c2bddad88d98224a116605460", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xmpp.adoc"}}
{"id": "sha256:60f51e5bac535a59601dad3fa5d4903c3b81762e69154dac66d09609acdb487e", "content": "You can also send chat messages to other users on XMPP by using the outbound message channel adapter.\nThe `outbound-channel-adapter` element provides configuration support for the XMPP outbound message channel adapter.\n\n[source,xml]\n----\n<int-xmpp:outbound-channel-adapter id=\"outboundEventAdapter\"\n channel=\"outboundEventChannel\"\n xmpp-connection=\"testConnection\"/>\n----\n\nThe adapter expects its input to be (at a minimum) a payload of type `java.lang.String` and a header value for `XmppHeaders.CHAT_TO` that specifies to which user the message should be sent.\nTo create a message, you can use Java code similar to the following:\n\n[source,java]\n----\nMessage<String> xmppOutboundMsg = MessageBuilder.withPayload(\"Hello, XMPP!\" )\n .setHeader(XmppHeaders.CHAT_TO, \"userhandle\")\n .build();\n----\n\nYou can also set the header by using the XMPP header-enricher support, as the following example shows:\n\n[source,xml]\n----\n<int-xmpp:header-enricher input-channel=\"input\" output-channel=\"output\">\n\t<int-xmpp:chat-to value=\"test1@example.org\"/>\n</int-xmpp:header-enricher>\n----\n\nStarting with version 4.3, the packet extension support has been added to the `ChatMessageSendingMessageHandler` (the `<int-xmpp:outbound-channel-adapter>` in XML configuration).\nAlong with the regular `String` and `org.jivesoftware.smack.packet.Message` payload, now you can send a message with a payload of `org.jivesoftware.smack.packet.XmlElement` (which is populated to the `org.jivesoftware.smack.packet.Message.addExtension()`) instead of `setBody()`.\nFor convenience, we added an `extension-provider` option for the `ChatMessageSendingMessageHandler`.\nIt lets you inject `org.jivesoftware.smack.provider.ExtensionElementProvider`, which builds an `XmlElement` against the payload at runtime.\nFor this case, the payload must be a string in JSON or XML format, depending on the XEP protocol.\n\n[[xmpp-presence]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xmpp.adoc", "title": "xmpp", "heading": "Outbound Message Channel Adapter", "heading_level": 3, "file_order": 281, "section_index": 4, "content_hash": "60f51e5bac535a59601dad3fa5d4903c3b81762e69154dac66d09609acdb487e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xmpp.adoc"}}
{"id": "sha256:ac8dd844f3197442e08a5639125e988d750e11a160f96148e7ffcebfd79f7a0d", "content": "XMPP also supports broadcasting state.\nYou can use this ability to let people who have you on their roster see your state changes.\nThis happens all the time with your IM clients.\nYou change your away status and set an away message, and everybody who has you on their roster sees your icon or username change to reflect this new state and might see your new \"`away`\" message.\nIf you would like to receive notifications or notify others of state changes, you can use Spring Integration's \"`presence`\" adapters.\n\n[[xmpp-roster-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xmpp.adoc", "title": "xmpp", "heading": "XMPP Presence", "heading_level": 2, "file_order": 281, "section_index": 5, "content_hash": "ac8dd844f3197442e08a5639125e988d750e11a160f96148e7ffcebfd79f7a0d", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xmpp.adoc"}}
{"id": "sha256:eddafefb4ed2b2877dc192a2104c190c75faa521a9fa6c31b42fde528c9df6ce", "content": "Spring Integration provides an inbound presence message channel adapter, which supports receiving presence events from other users in the system who are on your roster.\nTo do this, the adapter \"`logs in`\" as a user on your behalf, registers a `RosterListener`, and forwards received presence update events as messages to the channel identified by the `channel` attribute.\nThe payload of the message is a `org.jivesoftware.smack.packet.Presence` object (see https://www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/packet/Presence.html).\n\nThe `presence-inbound-channel-adapter` element provides configuration support for the XMPP inbound presence message channel adapter.\nThe following example configures an inbound presence message channel adapter:\n\n[source,xml]\n----\n<int-xmpp:presence-inbound-channel-adapter channel=\"outChannel\"\n xmpp-connection=\"testConnection\" auto-startup=\"false\"/>\n----\n\nAlong with the usual attributes, this adapter requires a reference to an XMPP Connection.\nThis adapter is event-driven and a `Lifecycle` implementation.\nIt registers a `RosterListener` when started and unregisters that `RosterListener` when stopped.\n\n[[xmpp-roster-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xmpp.adoc", "title": "xmpp", "heading": "Inbound Presence Message Channel Adapter", "heading_level": 3, "file_order": 281, "section_index": 6, "content_hash": "eddafefb4ed2b2877dc192a2104c190c75faa521a9fa6c31b42fde528c9df6ce", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xmpp.adoc"}}
{"id": "sha256:678a20c546864163bffa3acb6f1bb162a025b8b8afb5baac7e70b18d7d3b0ae5", "content": "Spring Integration also supports sending presence events to be seen by other users in the network who happen to have you on their roster.\nWhen you send a message to the outbound presence message channel adapter, it extracts the payload (which is expected to be of type `org.jivesoftware.smack.packet.Presence`) and sends it to the XMPP Connection, thus advertising your presence events to the rest of the network.\n\nThe `presence-outbound-channel-adapter` element provides configuration support for the XMPP outbound presence message channel adapter.\nThe following example shows how to configure an outbound presence message channel adapter:\n\n[source,xml]\n----\n<int-xmpp:presence-outbound-channel-adapter id=\"eventOutboundPresenceChannel\"\n\txmpp-connection=\"testConnection\"/>\n----\n\nIt can also be a polling consumer (if it receives messages from a pollable channel) in which case you would need to register a poller.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<int-xmpp:presence-outbound-channel-adapter id=\"pollingOutboundPresenceAdapter\"\n xmpp-connection=\"testConnection\"\n channel=\"pollingChannel\">\n\t<int:poller fixed-rate=\"1000\" max-messages-per-poll=\"1\"/>\n</int-xmpp:presence-outbound-channel-adapter>\n----\n\nLike its inbound counterpart, it requires a reference to an XMPP Connection.\n\nNOTE: If you rely on the default naming convention for an XMPP Connection bean (xref:xmpp.adoc#xmpp-connection[described earlier]) and you have only one XMPP Connection bean configured in your application context, you can omit the `xmpp-connection` attribute.\nIn that case, the bean with named `xmppConnection` is located and injected into the adapter.\n\n[[xmpp-advanced]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xmpp.adoc", "title": "xmpp", "heading": "Outbound Presence Message Channel Adapter", "heading_level": 3, "file_order": 281, "section_index": 7, "content_hash": "678a20c546864163bffa3acb6f1bb162a025b8b8afb5baac7e70b18d7d3b0ae5", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xmpp.adoc"}}
{"id": "sha256:9e3e98fdf62ed15152b800fe617d6011af18439e033a0b9146dd2922a6b5ace2", "content": "Spring Integration's XMPP support is based on the Smack 4.0 API (https://www.igniterealtime.org/projects/smack/), which allows more complex configuration of the XMPP Connection object.\n\nAs xref:xmpp.adoc#xmpp-connection[stated earlier], the `xmpp-connection` namespace support is designed to simplify basic connection configuration and supports only a few common configuration attributes.\nHowever, the `org.jivesoftware.smack.ConnectionConfiguration` object defines about 20 attributes, and adding namespace support for all of them offers no real value.\nSo, for more complex connection configurations, you can configure an instance of our `XmppConnectionFactoryBean` as a regular bean and inject a `org.jivesoftware.smack.ConnectionConfiguration` as a constructor argument to that `FactoryBean`.\nYou can specify every property you need directly on that `ConnectionConfiguration` instance.\n(A bean definition with the 'p' namespace would work well.)\nThis way, you can directly set SSL (or any other attributes).\nThe following example shows how to do so:\n\n[source,xml]\n----\n<bean id=\"xmppConnection\" class=\"o.s.i.xmpp.XmppConnectionFactoryBean\">\n <constructor-arg>\n <bean class=\"org.jivesoftware.smack.ConnectionConfiguration\">\n <constructor-arg value=\"myServiceName\"/>\n <property name=\"socketFactory\" ref=\"...\"/>\n </bean>\n </constructor-arg>\n</bean>\n\n<int:channel id=\"outboundEventChannel\"/>\n\n<int-xmpp:outbound-channel-adapter id=\"outboundEventAdapter\"\n channel=\"outboundEventChannel\"\n xmpp-connection=\"xmppConnection\"/>\n----\n\nThe Smack API also offers static initializers, which can be helpful.\nFor more complex cases (such as registering a SASL mechanism), you may need to execute certain static initializers.\nOne of those static initializers is `SASLAuthentication`, which lets you register supported SASL mechanisms.\nFor that level of complexity, we recommend using Spring Java configuration for the XMPP connection configuration.\nThat way, you can configure the entire component through Java code and execute all other necessary Java code, including static initializers, at the appropriate time.\nThe following example shows how to configure an XMPP connection with an SASL (Simple Authentication and Security Layer) in Java:\n\n[source,java]\n----\n@Configuration\npublic class CustomConnectionConfiguration {\n @Bean\n public XMPPConnection xmppConnection() {\n\tSASLAuthentication.supportSASLMechanism(\"EXTERNAL\", 0); // static initializer\n\n\tConnectionConfiguration config = new ConnectionConfiguration(\"localhost\", 5223);\n\tconfig.setKeystorePath(\"path_to_truststore.jks\");\n\tconfig.setSecurityEnabled(true);\n\tconfig.setSocketFactory(SSLSocketFactory.getDefault());\n\treturn new XMPPConnection(config);\n }\n}\n----\n\nFor more information on using Java for application context configuration, see the following section in the https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#beans-java[Spring Reference Manual].\n\n[[xmpp-message-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xmpp.adoc", "title": "xmpp", "heading": "Advanced Configuration", "heading_level": 2, "file_order": 281, "section_index": 8, "content_hash": "9e3e98fdf62ed15152b800fe617d6011af18439e033a0b9146dd2922a6b5ace2", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xmpp.adoc"}}
{"id": "sha256:d34368155f385f6fa901923bc4d4492718573caa8b73ded3afa36196901c7331", "content": "The Spring Integration XMPP Adapters automatically map standard XMPP properties.\nBy default, these properties are copied to and from Spring Integration `MessageHeaders` by using https://docs.spring.io/spring-integration/api/org/springframework/integration/xmpp/support/DefaultXmppHeaderMapper.html[`DefaultXmppHeaderMapper`].\n\nAny user-defined headers are not copied to or from an XMPP Message, unless explicitly specified by the `requestHeaderNames` or `replyHeaderNames` properties of the `DefaultXmppHeaderMapper`.\n\nTIP: When mapping user-defined headers, the values can also contain simple wildcard patterns (such \"thing*\" or \"*thing\").\n\nStarting with version 4.1, `AbstractHeaderMapper` (a superclass of `DefaultXmppHeaderMapper`) lets you configure the `NON_STANDARD_HEADERS` token for the `requestHeaderNames` property (in addition to `STANDARD_REQUEST_HEADERS`), to map all user-defined headers.\n\nThe `org.springframework.xmpp.XmppHeaders` class identifies the default headers to be used by the `DefaultXmppHeaderMapper`:\n\n* `xmpp_from`\n* `xmpp_subject`\n* `xmpp_thread`\n* `xmpp_to`\n* `xmpp_type`\n\nStarting with version 4.3, you can negate patterns in the header mappings by preceding the pattern with `!`.\nNegated patterns get priority, so a list such as `STANDARD_REQUEST_HEADERS,thing1,thing*,!thing2,!thing3,qux,!thing1` does not map `thing1`, `thing2`,or `thing3`.\nThat list does map the standard headers plus `thing4` and `qux`.\n\nIMPORTANT: If you have a user-defined header that begins with `!` that you do wish to map, can escape it with `\\` thus: `STANDARD_REQUEST_HEADERS,\\!myBangHeader`.\nIn that example, the standard request headers and `!myBangHeader` are mapped.\n\n[[xmpp-extensions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xmpp.adoc", "title": "xmpp", "heading": "XMPP Message Headers", "heading_level": 2, "file_order": 281, "section_index": 9, "content_hash": "d34368155f385f6fa901923bc4d4492718573caa8b73ded3afa36196901c7331", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xmpp.adoc"}}
{"id": "sha256:8ff43c587a12c43e1162e1b733a2c02f0e0a7af72e2830e4f0185b61cf36b4fb", "content": "Extensions put the \"`Extensible`\" in the \"`Extensible Messaging and Presence Protocol`\".\n\nXMPP is based around XML, a data format that supports a concept known as namespacing.\nThrough namespacing, you can add bits to XMPP that are not defined in the original specifications.\nThe XMPP specification deliberately describes only a set of core features:\n\n* How a client connects to a server\n* Encryption (SSL/TLS)\n* Authentication\n* How servers can communicate with each other to relay messages\n* A few other basic building blocks\n\nOnce you have implemented this, you have an XMPP client and can send any kind of data you like.\nHowever, you may need to do more than the basics.\nFor example, you might need to include formatting (bold, italic, and so on) in a message, which is not defined in the core XMPP specification.\nWell, you can make up a way to do that, but, unless everyone else does it the same way you do, no other software can interpret it (they ignore namespaces they cannot understand).\n\nTo solve that problem, the XMPP Standards Foundation (XSF) publishes a series of extra documents, known as https://xmpp.org/extensions/xep-0001.html[XMPP Extension Protocols] (XEPs).\nIn general, each XEP describes a particular activity (from message formatting to file transfers, multi-user chats, and many more).\nThey also provide a standard format for everyone to use for that activity.\n\nThe Smack API provides many XEP implementations with its `extensions` and `experimental` https://www.igniterealtime.org/builds/smack/docs/latest/documentation/extensions/index.html[projects].\nStarting with Spring Integration version 4.3, you can use any XEP with the existing XMPP channel adapters.\n\nTo be able to process XEPs or any other custom XMPP extensions, you must provide the Smack's `ProviderManager` pre-configuration.\nYou can do so with `static` Java code, as the following example shows:\n\n[source,java]\n----\nProviderManager.addIQProvider(\"element\", \"namespace\", new MyIQProvider());\nProviderManager.addExtensionProvider(\"element\", \"namespace\", new MyExtProvider());\n----\n\nYou can also use a `.providers` configuration file in the specific instance and access it with a JVM argument, as the following example shows:\n\n[source,xml]\n----\n-Dsmack.provider.file=file:///c:/my/provider/mycustom.providers\n----\n\nThe `mycustom.providers` file might be as follows:\n\n[source,xml]\n----\n<?xml version=\"1.0\"?>\n<smackProviders>\n<iqProvider>\n <elementName>query</elementName>\n <namespace>jabber:iq:time</namespace>\n <className>org.jivesoftware.smack.packet.Time</className>\n</iqProvider>\n\n<iqProvider>\n <elementName>query</elementName>\n <namespace>https://jabber.org/protocol/disco#items</namespace>\n <className>org.jivesoftware.smackx.provider.DiscoverItemsProvider</className>\n</iqProvider>\n\n<extensionProvider>\n <elementName>subscription</elementName>\n <namespace>https://jabber.org/protocol/pubsub</namespace>\n <className>org.jivesoftware.smackx.pubsub.provider.SubscriptionProvider</className>\n</extensionProvider>\n</smackProviders>\n----\n\nFor example, the most popular XMPP messaging extension is https://developers.google.com/cloud-messaging/[Google Cloud Messaging] (GCM).\nThe Smack library provides `org.jivesoftware.smackx.gcm.provider.GcmExtensionProvider` for that purpose.\nBy default, it registers that class with the `smack-experimental` jar in the classpath by using the `experimental.providers` resource, as the following Maven example shows:\n\n[source,xml]\n----\n<!-- GCM JSON payload -->\n<extensionProvider>\n <elementName>gcm</elementName>\n <namespace>google:mobile:data</namespace>\n <className>org.jivesoftware.smackx.gcm.provider.GcmExtensionProvider</className>\n</extensionProvider>\n----\n\nAlso, the `GcmPacketExtension` lets the target messaging protocol parse incoming packets and build outgoing packets, as the following examples show:\n\n[source,java]\n----\nGcmPacketExtension gcmExtension = (GcmPacketExtension) xmppMessage.getExtension(GcmPacketExtension.NAMESPACE);\nString message = gcmExtension.getJson());\n----\n\n[source,java]\n----\nGcmPacketExtension packetExtension = new GcmPacketExtension(gcmJson);\nMessage smackMessage = new Message();\nsmackMessage.addExtension(packetExtension);\n----\n\nSee xref:xmpp.adoc#xmpp-message-inbound-channel-adapter[Inbound Message Channel Adapter] and xref:xmpp.adoc#xmpp-message-outbound-channel-adapter[Outbound Message Channel Adapter] earlier in this chapter for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/xmpp.adoc", "title": "xmpp", "heading": "XMPP Extensions", "heading_level": 2, "file_order": 281, "section_index": 10, "content_hash": "8ff43c587a12c43e1162e1b733a2c02f0e0a7af72e2830e4f0185b61cf36b4fb", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/xmpp.adoc"}}
{"id": "sha256:447baa4b7857c6f3a0a04d2fb91e6e57d188a11f0d75fb9d0b461ecb6c40a171", "content": "[[zeromq]]\n\nSpring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\nThe implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\nAll components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making interactions with these components lock-free and thread-safe.\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-zeromq</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n----\n======\n\n[[zeromq-proxy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zeromq.adoc", "title": "zeromq", "heading": "zeromq", "heading_level": 1, "file_order": 282, "section_index": 0, "content_hash": "447baa4b7857c6f3a0a04d2fb91e6e57d188a11f0d75fb9d0b461ecb6c40a171", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zeromq.adoc"}}
{"id": "sha256:055daa82a9560c5bf4b64b00ea894520e55d019afc66207473da14072e7dc7f7", "content": "The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\nIt encapsulates socket lifecycles and thread management.\nThe clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\nAlongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\nThis way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\nSee `ZeroMqProxy.Type` for details.\n\nThe `ZeroMqProxy` implements `SmartLifecycle` to create, bind and configure the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\nThe binding for frontend and backend sockets is done over the `tcp://` protocol onto all of the available network interfaces with the provided ports.\nOtherwise, they are bound to random ports which can be obtained later via the respective `getFrontendPort()` and `getBackendPort()` API methods.\n\nThe control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\nIt should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\nThe `ZeroMqProxy` performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate the `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n\nThe `setExposeCaptureSocket(boolean)` option causes this component to bind an additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between the frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\nThis socket is bound to the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n\nThe frontend and backend sockets can be customized with additional properties, such as read/write timeout or security.\nThis customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n\nThe `ZeroMqProxy` could be provided as simple bean like this:\n\n[source,java]\n----\n@Bean\nZeroMqProxy zeroMqProxy() {\n ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n proxy.setExposeCaptureSocket(true);\n proxy.setFrontendPort(6001);\n proxy.setBackendPort(6002);\n return proxy;\n}\n----\n\nAll the client nodes should connect to the host of this proxy via `tcp://` and use the respective port of their interest.\n\n[[zeromq-message-channel]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zeromq.adoc", "title": "zeromq", "heading": "ZeroMQ Proxy", "heading_level": 2, "file_order": 282, "section_index": 1, "content_hash": "055daa82a9560c5bf4b64b00ea894520e55d019afc66207473da14072e7dc7f7", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zeromq.adoc"}}
{"id": "sha256:cd35f933aeaa07ebc3a681a68405cf56d99b8892a343d853b8d6e4a18f0623ca", "content": "The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\nIt can work in a PUB/SUB mode (defaults to PUSH/PULL); it can also be used as a local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided in this case.\nIn distributed mode it has to be connected to an externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\nThe connection url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\nFor convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as the proxy.\n\nBoth sending and receiving sockets are managed in their own dedicated threads, making this channel concurrency-friendly.\nThis way we can publish and consume to/from a `ZeroMqChannel` from different threads without synchronization.\n\nBy default, the `ZeroMqChannel` uses an `EmbeddedHeadersJsonMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using a Jackson JSON processor.\nThis logic can be configured via `setMessageMapper(BytesMessageMapper)`.\n\nSending and receiving sockets can be customized for any options (read/write timeout, security etc.) via respective `setSendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setSubscribeSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks.\n\nThe internal logic of the `ZeroMqChannel` is based on the reactive streams via Project Reactor `Flux` and `Mono` operators.\nThis provides easier threading control and allows lock-free concurrent publication and consumption to/from the channel.\nLocal PUB/SUB logic is implemented as a `Flux.publish()` operator to allow all of the local subscribers to this channel to receive the same published message, as distributed subscribers to the `PUB` socket.\n\nThe following is a simple example of a `ZeroMqChannel` configuration:\n\n[source,java]\n----\n@Bean\nZeroMqChannel zeroMqPubSubChannel(ZContext context) {\n ZeroMqChannel channel = new ZeroMqChannel(context, true);\n channel.setConnectUrl(\"tcp://localhost:6001:6002\");\n channel.setConsumeDelay(Duration.ofMillis(100));\n return channel;\n}\n----\n\n[[zeromq-inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zeromq.adoc", "title": "zeromq", "heading": "ZeroMQ Message Channel", "heading_level": 2, "file_order": 282, "section_index": 2, "content_hash": "cd35f933aeaa07ebc3a681a68405cf56d99b8892a343d853b8d6e4a18f0623ca", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zeromq.adoc"}}
{"id": "sha256:ac2daaf923ee905e03b42b8a67f2939964161d03b7c50ae09a9199ce86699ded", "content": "The `ZeroMqMessageProducer` is a `MessageProducerSupport` implementation with reactive semantics.\nIt constantly reads the data from a ZeroMQ socket in a non-blocking manner and publishes the messages to an infinite `Flux` which is subscribed to by a `FluxMessageChannel` or explicitly in the `start()` method, if the output channel is not reactive.\nWhen no data are received on the socket, a `consumeDelay` (defaults to 1 second) is applied before the next read attempt.\n\nOnly `SocketType.PAIR`, `SocketType.PULL` and `SocketType.SUB` are supported by the `ZeroMqMessageProducer`.\nThis component can connect to the remote socket or bind onto TCP protocol with the provided or random port.\nThe actual port can be obtained via `getBoundPort()` after this component is started and ZeroMQ socket is bound.\nThe socket options (e.g. security or write timeout) can be configured via `setSocketConfigurer(Consumer<ZMQ.Socket> socketConfigurer)` callback.\n\nIf the `receiveRaw` option is set to `true`, a `ZMsg`, consumed from the socket, is sent as is in the payload of the produced `Message`: it is up to the downstream flow to parse and convert the `ZMsg`.\nOtherwise, an `InboundMessageMapper` is used to convert the consumed data into a `Message`.\nIf the received `ZMsg` is multi-frame, the first frame is treated as the `ZeroMqHeaders.TOPIC` header this ZeroMQ message was published to.\n\nIf the `unwrapTopic` option is set to `false`, the incoming message is considered to consist of two frames: the topic and the ZeroMQ message.\nOtherwise, by default, the `ZMsg` is considered to consist of three frames: the first one containing the topic, the last frame containing the message, with an empty frame in the middle.\n\nWith `SocketType.SUB`, the `ZeroMqMessageProducer` uses the provided `topics` option for subscriptions; defaults to subscribe to all.\nSubscriptions can be adjusted at runtime using `subscribeToTopics()` and `unsubscribeFromTopics()` ``@ManagedOperation``s.\n\nHere is a sample of `ZeroMqMessageProducer` configuration:\n\n[source,java]\n----\n@Bean\nZeroMqMessageProducer zeroMqMessageProducer(ZContext context, MessageChannel outputChannel) {\n ZeroMqMessageProducer messageProducer = new ZeroMqMessageProducer(context, SocketType.SUB);\n messageProducer.setOutputChannel(outputChannel);\n messageProducer.setTopics(\"some\");\n messageProducer.setReceiveRaw(true);\n messageProducer.setBindPort(7070);\n messageProducer.setConsumeDelay(Duration.ofMillis(100));\n return messageProducer;\n}\n----\n\n[[zeromq-outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zeromq.adoc", "title": "zeromq", "heading": "ZeroMQ Inbound Channel Adapter", "heading_level": 2, "file_order": 282, "section_index": 3, "content_hash": "ac2daaf923ee905e03b42b8a67f2939964161d03b7c50ae09a9199ce86699ded", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zeromq.adoc"}}
{"id": "sha256:48733c4ce4bc3f0869484e5b9794ccca733f66404b571066211229eabbb4d55e", "content": "The `ZeroMqMessageHandler` is a `ReactiveMessageHandler` implementation to produce publish messages into a ZeroMQ socket.\nOnly `SocketType.PAIR`, `SocketType.PUSH` and `SocketType.PUB` are supported.\nThis component can connect to the remote socket or bind onto TCP protocol with the provided or random port.\nThe actual port can be obtained via `getBoundPort()` after this component is started and ZeroMQ socket is bound.\n\nWhen the `SocketType.PUB` is used, the `topicExpression` is evaluated against a request message to inject a topic frame into a ZeroMQ message if it is not null.\nThe subscriber side (`SocketType.SUB`) must receive the topic frame first before parsing the actual data.\n\nIf the `wrapTopic` option is set to `false`, the ZeroMQ message frame is sent after the injected topic, if present.\nBy default, an additional empty frame is sent between the topic and the message.\n\nWhen the payload of the request message is a `ZMsg`, no conversion or topic extraction is performed: the `ZMsg` is sent into a socket as is and it is not destroyed for possible further reuse.\nOtherwise, an `OutboundMessageMapper<byte[]>` is used to convert a request message (or just its payload) into a ZeroMQ frame to publish.\nBy default, a `ConvertingBytesMessageMapper` is used supplied with a `ConfigurableCompositeMessageConverter`.\nThe socket options (e.g. security or write timeout) can be configured via `setSocketConfigurer(Consumer<ZMQ.Socket> socketConfigurer)` callback.\n\nHere is a sample of `ZeroMqMessageHandler` configuration which connect to a socket:\n\n[source,java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"zeroMqPublisherChannel\")\nZeroMqMessageHandler zeroMqMessageHandler(ZContext context) {\n ZeroMqMessageHandler messageHandler =\n new ZeroMqMessageHandler(context, \"tcp://localhost:6060\", SocketType.PUB);\n messageHandler.setTopicExpression(\n new FunctionExpression<Message<?>>((message) -> message.getHeaders().get(\"topic\")));\n messageHandler.setMessageMapper(new EmbeddedHeadersJsonMessageMapper());\n}\n----\n\nHere is a sample of `ZeroMqMessageHandler` configuration which bind to a provided port:\n\n[source,java]\n----\n@Bean\n@ServiceActivator(inputChannel = \"zeroMqPublisherChannel\")\nZeroMqMessageHandler zeroMqMessageHandler(ZContext context) {\n ZeroMqMessageHandler messageHandler =\n new ZeroMqMessageHandler(context, 7070, SocketType.PUB);\n messageHandler.setTopicExpression(\n new FunctionExpression<Message<?>>((message) -> message.getHeaders().get(\"topic\")));\n messageHandler.setMessageMapper(new EmbeddedHeadersJsonMessageMapper());\n}\n----\n\n[[zeromq-dsl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zeromq.adoc", "title": "zeromq", "heading": "ZeroMQ Outbound Channel Adapter", "heading_level": 2, "file_order": 282, "section_index": 4, "content_hash": "48733c4ce4bc3f0869484e5b9794ccca733f66404b571066211229eabbb4d55e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zeromq.adoc"}}
{"id": "sha256:34c10fa23b38e146e1f64bfcc69aef85cadfe2fbf3c77e2105041d846df30e9c", "content": "The `spring-integration-zeromq` provide a convenient Java DSL fluent API via `ZeroMq` factory and `IntegrationComponentSpec` implementations for the components mentioned above.\n\nThis is a sample of Java DSL for `ZeroMqChannel`:\n\n[source,java]\n----\n.channel(ZeroMq.zeroMqChannel(this.context)\n .connectUrl(\"tcp://localhost:6001:6002\")\n .consumeDelay(Duration.ofMillis(100)))\n}\n----\n\nThe Inbound Channel Adapter for ZeroMQ Java DSL is:\n\n[source,java]\n----\nIntegrationFlow.from(\n ZeroMq.inboundChannelAdapter(this.context, SocketType.SUB)\n .connectUrl(\"tcp://localhost:9000\")\n .topics(\"someTopic\")\n .receiveRaw(true)\n .consumeDelay(Duration.ofMillis(100)))\n}\n----\n\nThe Outbound Channel Adapter for ZeroMQ Java DSL is:\n\n[source,java]\n----\n.handle(ZeroMq.outboundChannelAdapter(this.context, \"tcp://localhost:9001\", SocketType.PUB)\n .topicFunction(message -> message.getHeaders().get(\"myTopic\")))\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zeromq.adoc", "title": "zeromq", "heading": "ZeroMQ Java DSL Support", "heading_level": 2, "file_order": 282, "section_index": 5, "content_hash": "34c10fa23b38e146e1f64bfcc69aef85cadfe2fbf3c77e2105041d846df30e9c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zeromq.adoc"}}
{"id": "sha256:199a6f96700a76b901377bf402db45d4ddb2981a634da82322763af3028b1340", "content": "[[zip]]\n\nThis Spring Integration module provides https://en.wikipedia.org/wiki/ZIP_(file_format)[Zip] (un-)compression support.\nA zipping algorithm implementation is based on a https://github.com/zeroturnaround/zt-zip[ZeroTurnaround ZIP Library].\nThe following components are provided:\n\n* xref:zip.adoc#zip-transformer[Zip Transformer]\n* xref:zip.adoc#zip-transformer[UnZip Transformer]\n* xref:zip.adoc#unzip-splitter[UnZip Result Splitter]\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-zip</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-zip:{project-version}\"\n----\n======\n\n[[xpath-namespace-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zip.adoc", "title": "zip", "heading": "zip", "heading_level": 1, "file_order": 283, "section_index": 0, "content_hash": "199a6f96700a76b901377bf402db45d4ddb2981a634da82322763af3028b1340", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zip.adoc"}}
{"id": "sha256:a803f94ba47b9890e0003a76ea10bb2ae6874ce637036013c35d601feb80303e", "content": "All components within the Spring Integration Zip module provide namespace support.\nIn order to enable namespace support, you need to import the schema for the Spring Integration Zip Module.\nThe following example shows a typical setup:\n\n[source,xml]\n----\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:int=\"http://www.springframework.org/schema/integration\"\n xmlns:int-zip=\"http://www.springframework.org/schema/integration/zip\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\n http://www.springframework.org/schema/integration\n https://www.springframework.org/schema/integration/spring-integration.xsd\n http://www.springframework.org/schema/integration/zip\n https://www.springframework.org/schema/integration/zip/spring-integration-zip.xsd\">\n</beans>\n----\n\n[[zip-transformer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zip.adoc", "title": "zip", "heading": "Namespace Support", "heading_level": 2, "file_order": 283, "section_index": 1, "content_hash": "a803f94ba47b9890e0003a76ea10bb2ae6874ce637036013c35d601feb80303e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zip.adoc"}}
{"id": "sha256:08e6959a364409f03d00c9af2742f30c02b1efdbe68c23c4437a884fead75f2a", "content": "The `ZipTransformer` implements a zipping functionality for these types of input `payload`: `File`, `String`, `byte[]` and `Iterable`.\nIn input data types can be mixed as part of an `Iterable`.\nFor example, it should be easy to compress a collection containing Strings, byte arrays and Files.\nIt is important to note that nested Iterables are *NOT SUPPORTED* at present time.\n\nThe `ZipTransformer` can be customized by setting several properties:\n\n* `compressionLevel` - sets the compression level.\nDefault is `Deflater#DEFAULT_COMPRESSION`.\n\n* `useFileAttributes` - specifies whether the name of the file shall be used for the zip entry.\n* `fileNameGenerator` - uses to generate an original file name based on the request message.\nDefaults to `DefaultFileNameGenerator`.\nThe `.zip` extension is added into this name for the target zip file name.\nUnless it is already present as a result of this generator.\n\nIn addition, a `ZipHeaders.ZIP_ENTRY_FILE_NAME` and `ZipHeaders.ZIP_ENTRY_LAST_MODIFIED_DATE` can be supplied for the name of zip entry and its `lastmodified` attribute.\nIf not provided, the entry name is exact result of the `fileNameGenerator` and `lastmodified` falls back to the current date and time.\nIf the payload of a request message is an `Iterable`, then this entry name is modified with an index starting `1`.\n\nFor example to zip a simple `test.txt` file into a `test.txt.zip`, only this configuration is enough:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow zipFlow() {\n return IntegrationFlow\n .from(\"zipChannel\")\n .transform(new ZipTransformer())\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun zipFlow() =\n integrationFlow(\"zipChannel\") {\n transform(ZipTransformer())\n }\n----\n\nGroovy DSL::\n+\n[source, groovy, role=\"secondary\"]\n----\n@Bean\nzipFlow() {\n integrationFlow 'zipChannel',\n {\n transform new ZipTransformer()\n }\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Transformer(inputChannel = \"zipChannel\")\n@Bean\nZipTransformer zipTransformer() {\n return new ZipTransformer();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-zip:zip-transformer input-channel=\"zipChannel\"/>\n----\n======\n\nSee `ZipTransformer` Javadocs for more information.\n\nAn `UnZipTransformer` supports these of input `payload`: `File`, `byte[]` and `InputStream`.\nWhen unzipping data, an `expectSingleResult` property can be specified.\nIf set to `true` and more than `1` zip entry was detected, a `MessagingException` will be raised.\nThis property also influences the return type of the payload.\nIf set to `false` (default), then the payload will be of type `SortedMap`, if `true`, however, the actual zip entry will be returned.\n\nOther properties that can be set on the `UnZipTransformer`:\n\n* `deleteFiles` - if the payload is an instance of `File`, this property specifies whether to delete the File after transformation.\nDefault is `false`.\n\n* `ZipResultType` - defines the format of the data returned after transformation.\nAvailable options are: `File`, `byte[]`.\n\n* `workDirectory` - the work directory is used when a `ZipResultType` is set to `ZipResultType.FILE`.\nBy default, this property is set to the System temporary directory containing a subdirectory `ziptransformer`.\n\nFor example to zip a simple `test.zip` file into a map of its entries, only this configuration is enough:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow unzipFlow() {\n return IntegrationFlow\n .from(\"unzipChannel\")\n .transform(new UnZipTransformer())\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun unzipFlow() =\n integrationFlow(\"unzipChannel\") {\n transform(UnZipTransformer())\n }\n----\n\nGroovy DSL::\n+\n[source, groovy, role=\"secondary\"]\n----\n@Bean\nunzipFlow() {\n integrationFlow 'unzipChannel',\n {\n transform new UnZipTransformer()\n }\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Transformer(inputChannel = \"unzipChannel\")\n@Bean\nUnZipTransformer unzipTransformer() {\n return new UnZipTransformer();\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int-zip:unzip-transformer input-channel=\"unzipChannel\"/>\n----\n======\n\n[[unzip-splitter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zip.adoc", "title": "zip", "heading": "(Un)Zip Transformer", "heading_level": 2, "file_order": 283, "section_index": 2, "content_hash": "08e6959a364409f03d00c9af2742f30c02b1efdbe68c23c4437a884fead75f2a", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zip.adoc"}}
{"id": "sha256:f88efc42b4521baadc55de3691a86f6d5894fa69a58e4b94940f8a7ed310ce56", "content": "The `UnZipResultSplitter` is useful in cases where zip files contain more than `1` entry.\nEssentially it has to be used as the next step in the integration flow after the mentioned above `UnZipTransformer`.\nIt supports only a `Map` as an input data and emits every entry into an `outputChannel` with `FileHeaders.FILENAME` and `ZipHeaders.ZIP_ENTRY_PATH` headers.\n\nThe following example demonstrates a simple configuration for splitting an unzipped result:\n\n[tabs]\n======\nJava DSL::\n+\n[source, java, role=\"primary\"]\n----\n@Bean\npublic IntegrationFlow unzipSplitFlow(Executor executor) {\n return IntegrationFlow\n .from(\"unzipChannel\")\n .transform(new UnZipTransformer())\n .split(new UnZipResultSplitter())\n .channel(c -> c.executor(\"entriesChannel\", executor))\n .get();\n}\n----\n\nKotlin DSL::\n+\n[source, kotlin, role=\"secondary\"]\n----\n@Bean\nfun unzipFlow(executor: Executor) =\n integrationFlow(\"unzipChannel\") {\n transform(UnZipTransformer())\n split(UnZipResultSplitter())\n channel { executor(\"entriesChannel\", executor) }\n }\n----\n\nGroovy DSL::\n+\n[source, groovy, role=\"secondary\"]\n----\n@Bean\nunzipFlow(Executor executor) {\n integrationFlow 'unzipChannel',\n {\n transformWith {\n ref new UnZipTransformer()\n }\n splitWith {\n ref new UnZipResultSplitter()\n }\n channel { executor 'entriesChannel', executor }\n }\n}\n----\n\nJava::\n+\n[source, java, role=\"secondary\"]\n----\n@Transformer(inputChannel = \"unzipChannel\", outputChannel = \"splitChannel\")\n@Bean\nUnZipTransformer unzipTransformer() {\n return new UnZipTransformer();\n}\n\n@Spitter(inputChannel = \"splitChannel\", outputChannel = \"entriesChannel\")\n@Bean\nUnZipResultSplitter unZipSplitter() {\n return new UnZipResultSplitter();\n}\n\n@Bean\nExecutorChannel entriesChannel(Executor executor) {\n return new ExecutorChannel(executor);\n}\n----\n\nXML::\n+\n[source, xml, role=\"secondary\"]\n----\n<int:chain input-channel=\"unzipChannel\" output-channel=\"entriesChannel\">\n <int-zip:unzip-transformer/>\n <int:splitter>\n <bean class=\"org.springframework.integration.zip.splitter.UnZipResultSplitter\"/>\n </int:splitter>\n</int:chain>\n\n<int:channel id=\"entriesChannel\">\n <int:dispatcher task-executor=\"executor\"/>\n</int:channel>\n----\n======", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zip.adoc", "title": "zip", "heading": "Unzipped Splitter", "heading_level": 2, "file_order": 283, "section_index": 3, "content_hash": "f88efc42b4521baadc55de3691a86f6d5894fa69a58e4b94940f8a7ed310ce56", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zip.adoc"}}
{"id": "sha256:661749afb94c61e434a46bfe0f302eda0df41a611f3577b9aca4ffe5a2b0869e", "content": "[[zookeeper]]\n\nVersion 4.2 added https://zookeeper.apache.org/[Zookeeper] support to the framework in version 4.2, which consists of:\n\n* xref:zookeeper.adoc#zk-metadata-store[A metadata store]\n* xref:zookeeper.adoc#zk-lock-registry[A lock registry]\n* xref:zookeeper.adoc#zk-leadership[Leadership event handling]\n\nThis dependency is required for the project:\n\n[tabs]\n======\nMaven::\n+\n[source, xml, subs=\"normal\", role=\"primary\"]\n----\n<dependency>\n <groupId>org.springframework.integration</groupId>\n <artifactId>spring-integration-zookeeper</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source, groovy, subs=\"normal\", role=\"secondary\"]\n----\nimplementation \"org.springframework.integration:spring-integration-zookeeper:{project-version}\"\n----\n======\n\n[[zk-metadata-store]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zookeeper.adoc", "title": "zookeeper", "heading": "zookeeper", "heading_level": 1, "file_order": 284, "section_index": 0, "content_hash": "661749afb94c61e434a46bfe0f302eda0df41a611f3577b9aca4ffe5a2b0869e", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zookeeper.adoc"}}
{"id": "sha256:7f6434bbf59c98bfccd71e5194688b8d1833980083f71134644e84fd828195c8", "content": "You can use the `ZookeeperMetadataStore` where any `MetadataStore` is needed, such as for persistent file list filters.\nSee xref:meta-data-store.adoc[Metadata Store] for more information.\nThe following example configures a Zookeeper metadata store with XML:\n\n[source, xml]\n----\n<bean id=\"client\" class=\"org.springframework.integration.zookeeper.config.CuratorFrameworkFactoryBean\">\n <constructor-arg value=\"${connect.string}\" />\n</bean>\n\n<bean id=\"meta\" class=\"org.springframework.integration.zookeeper.metadata.ZookeeperMetadataStore\">\n <constructor-arg ref=\"client\" />\n</bean>\n----\n\nThe following example shows how to configure a Zookeeper metadata store with Java:\n\n[source, java]\n----\n@Bean\npublic MetadataStore zkStore(CuratorFramework client) {\n return new ZookeeperMetadataStore(client);\n}\n----\n\n[[zk-lock-registry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zookeeper.adoc", "title": "zookeeper", "heading": "Zookeeper Metadata Store", "heading_level": 2, "file_order": 284, "section_index": 1, "content_hash": "7f6434bbf59c98bfccd71e5194688b8d1833980083f71134644e84fd828195c8", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zookeeper.adoc"}}
{"id": "sha256:9400b892c9b1461040ee1b0a47e92bd882bd1e604783c252895f71a61302fb1c", "content": "The `ZookeeperLockRegistry` can be used where any `LockRegistry` is needed, such as when using an aggregator in a clustered environment with a shared `MessageStore`.\n\nA `LockRegistry` is used to \"`look up`\" a lock based on a key (the aggregator uses `correlationId`).\nBy default, locks in the `ZookeeperLockRegistry` are maintained in zookeeper under the following path: `/SpringIntegration-LockRegistry/`.\nYou can customize the path by providing an implementation of `ZookeeperLockRegistry.KeyToPathStrategy`, as the following example shows:\n\n[source, java]\n----\npublic interface KeyToPathStrategy {\n\n String pathFor(String key);\n\n boolean bounded();\n\n}\n----\n\nIf the strategy returns `true` from `isBounded`, unused locks do not need to be harvested.\nFor unbounded strategies (such as the default), you need to periodically invoke `expireUnusedOlderThan(long age)` to remove old unused locks from memory.\n\nStarting with version 5.5.6, the `ZookeeperLockRegistry` is support automatically clean up cache for ZkLock in `ZookeeperLockRegistry.locks` via `ZookeeperLockRegistry.setCacheCapacity()`.\nSee its JavaDocs for more information.\n\n[[zk-leadership]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zookeeper.adoc", "title": "zookeeper", "heading": "Zookeeper Lock Registry", "heading_level": 2, "file_order": 284, "section_index": 2, "content_hash": "9400b892c9b1461040ee1b0a47e92bd882bd1e604783c252895f71a61302fb1c", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zookeeper.adoc"}}
{"id": "sha256:b4cae0c999557f280975bcea5c114a5890e592318e8b1dd99bf617c194950157", "content": "The following example uses XML to configure an application for leader election in Zookeeper:\n\n[source, xml]\n----\n<int-zk:leader-listener client=\"client\" path=\"/siNamespace\" role=\"cluster\" />\n----\n\n`client` is a reference to a `CuratorFramework` bean.\nA `CuratorFrameworkFactoryBean` is available.\nWhen a leader is elected, an `OnGrantedEvent` is published for the role `cluster`.\nAny endpoints in that role are started.\nWhen leadership is revoked, an `OnRevokedEvent` is published for the role `cluster`.\nAny endpoints in that role are stopped.\nSee xref:endpoint-roles.adoc[Endpoint Roles] for more information.\n\nYou can use Java configuration to create an instance of the leader initiator, as the following example shows:\n\n[source, java]\n----\n@Bean\npublic LeaderInitiatorFactoryBean leaderInitiator(CuratorFramework client) {\n return new LeaderInitiatorFactoryBean()\n .setClient(client)\n .setPath(\"/siTest/\")\n .setRole(\"cluster\");\n}\n----\n\nStarting with version 5.3, a `candidate` option is exposed on the `LeaderInitiatorFactoryBean` for more configuration control of the externally provided `Candidate` instance.\nOnly one of the `candidate` or `role` options has to be provided, but not both; the `role` options creates internally a `DefaultCandidate` instance with an `UUID` for `id` option.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-integration", "path": "antora/modules/ROOT/pages/zookeeper.adoc", "title": "zookeeper", "heading": "Zookeeper Leadership Event Handling", "heading_level": 2, "file_order": 284, "section_index": 3, "content_hash": "b4cae0c999557f280975bcea5c114a5890e592318e8b1dd99bf617c194950157", "source_url": "https://github.com/spring-projects/spring-integration/blob/efb805ee599086434126f18d20676b6f9302f094/src/reference/antora/modules/ROOT/pages/zookeeper.adoc"}}
