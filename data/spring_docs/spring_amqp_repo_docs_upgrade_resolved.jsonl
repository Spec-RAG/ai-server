{"id": "sha256:5ed8c2c59a4f89f033f032e891fda9b07f0b0a1cafc1ae63ce55f7a0cc387a3c", "content": "[[container-management]]\n\nContainers created for annotations are not registered with the application context.\nYou can obtain a collection of all containers by invoking `getListenerContainers()` on the\n`RabbitListenerEndpointRegistry` bean.\nYou can then iterate over this collection, for example, to stop or start all containers or invoke the `Lifecycle` methods\non the registry itself, which will invoke the operations on each container.\n\nYou can also get a reference to an individual container by using its `id`, using `getListenerContainer(String id)` -- for\nexample, `registry.getListenerContainer(\"multi\")` for the container created by the snippet above.\n\nStarting with version 1.5.2, you can obtain the `id` values of the registered containers with `getListenerContainerIds()`.\n\nStarting with version 1.5, you can now assign a `group` to the container on the `RabbitListener` endpoint.\nThis provides a mechanism to get a reference to a subset of containers.\nAdding a `group` attribute causes a bean of type `Collection<MessageListenerContainer>` to be registered with the context with the group name.\n\nBy default, stopping a container will cancel the consumer and process all prefetched messages before stopping.\nStarting with versions 2.4.14, 3.0.6, you can set the xref:amqp/containerAttributes.adoc#forceStop[`forceStop`] container property to true to stop immediately after the current message is processed, causing any prefetched messages to be requeued.\nThis is useful, for example, if exclusive or single-active consumers are being used.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/container-management.adoc", "title": "container-management", "heading": "container-management", "heading_level": 1, "file_order": 0, "section_index": 0, "content_hash": "5ed8c2c59a4f89f033f032e891fda9b07f0b0a1cafc1ae63ce55f7a0cc387a3c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/container-management.adoc"}}
{"id": "sha256:a8e99320413831a212b695bf998ac0d478167773ebbab75abf7103c0d646ba71", "content": "[[async-annotation-conversion]]\n\nThere are two conversion steps in the pipeline before invoking the listener.\nThe first step uses a `MessageConverter` to convert the incoming Spring AMQP `Message` to a Spring-messaging `Message`.\nWhen the target method is invoked, the message payload is converted, if necessary, to the method parameter type.\n\nThe default `MessageConverter` for the first step is a Spring AMQP `SimpleMessageConverter` that handles conversion to\n`String` and `java.io.Serializable` objects.\nAll others remain as a `byte[]`.\nIn the following discussion, we call this the \"`message converter`\".\n\nThe default converter for the second step is a `GenericMessageConverter`, which delegates to a conversion service\n(an instance of `DefaultFormattingConversionService`).\nIn the following discussion, we call this the \"`method argument converter`\".\n\nTo change the message converter, you can add it as a property to the container factory bean.\nThe following example shows how to do so:\n\n[source, java]\n----\n@Bean\npublic SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() {\n SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n ...\n factory.setMessageConverter(new Jackson2JsonMessageConverter());\n ...\n return factory;\n}\n----\n\nThis configures a Jackson2 converter that expects header information to be present to guide the conversion.\n\nYou can also use a `ContentTypeDelegatingMessageConverter`, which can handle conversion of different content types.\n\nStarting with version 2.3, you can override the factory converter by specifying a bean name in the `messageConverter` property.\n\n[source, java]\n----\n@Bean\npublic Jackson2JsonMessageConverter jsonConverter() {\n return new Jackson2JsonMessageConverter();\n}\n\n@RabbitListener(..., messageConverter = \"jsonConverter\")\npublic void listen(String in) {\n ...\n}\n----\n\nThis avoids having to declare a different container factory just to change the converter.\n\nIn most cases, it is not necessary to customize the method argument converter unless, for example, you want to use\na custom `ConversionService`.\n\nIn versions prior to 1.6, the type information to convert the JSON had to be provided in message headers, or a\ncustom `ClassMapper` was required.\nStarting with version 1.6, if there are no type information headers, the type can be inferred from the target\nmethod arguments.\n\nNOTE: This type inference works only for `@RabbitListener` at the method level.\n\nSee xref:amqp/message-converters.adoc#json-message-converter[`Jackson2JsonMessageConverter`] for more information.\n\nIf you wish to customize the method argument converter, you can do so as follows:\n\n[source, java]\n----\n@Configuration\n@EnableRabbit\npublic class AppConfig implements RabbitListenerConfigurer {\n\n ...\n\n @Bean\n public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {\n DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();\n factory.setMessageConverter(new GenericMessageConverter(myConversionService()));\n return factory;\n }\n\n @Bean\n public DefaultConversionService myConversionService() {\n DefaultConversionService conv = new DefaultConversionService();\n conv.addConverter(mySpecialConverter());\n return conv;\n }\n\n @Override\n public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) {\n registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());\n }\n\n ...\n\n}\n----\n\nIMPORTANT: For multi-method listeners (see xref:amqp/receiving-messages/async-annotation-driven/method-selection.adoc[Multi-method Listeners]), the method selection is based on the payload of the message *after the message conversion*.\nThe method argument converter is called only after the method has been selected.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/conversion.adoc", "title": "conversion", "heading": "conversion", "heading_level": 1, "file_order": 1, "section_index": 0, "content_hash": "a8e99320413831a212b695bf998ac0d478167773ebbab75abf7103c0d646ba71", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/conversion.adoc"}}
{"id": "sha256:6b5a3e76d2dedbc2408d5c8716992b26496d11146cbb095fcdd55632ebab605f", "content": "[[custom-argument-resolver]]\n\nStarting with version 2.3.7 you are able to add your own `HandlerMethodArgumentResolver` and resolve custom method parameters.\nAll you need is to implement `RabbitListenerConfigurer` and use method `setCustomMethodArgumentResolvers()` from class `RabbitListenerEndpointRegistrar`.\n\n[source, java]\n----\n@Configuration\nclass CustomRabbitConfig implements RabbitListenerConfigurer {\n\n @Override\n public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) {\n registrar.setCustomMethodArgumentResolvers(\n new HandlerMethodArgumentResolver() {\n\n @Override\n public boolean supportsParameter(MethodParameter parameter) {\n return CustomMethodArgument.class.isAssignableFrom(parameter.getParameterType());\n }\n\n @Override\n public Object resolveArgument(MethodParameter parameter, org.springframework.messaging.Message<?> message) {\n return new CustomMethodArgument(\n (String) message.getPayload(),\n message.getHeaders().get(\"customHeader\", String.class)\n );\n }\n\n }\n );\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/custom-argument-resolver.adoc", "title": "custom-argument-resolver", "heading": "custom-argument-resolver", "heading_level": 1, "file_order": 2, "section_index": 0, "content_hash": "6b5a3e76d2dedbc2408d5c8716992b26496d11146cbb095fcdd55632ebab605f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/custom-argument-resolver.adoc"}}
{"id": "sha256:437620f947f0d77c256db3b9110b69a9ea9567c08cac9342c7f751d1aa80c806", "content": "[[async-annotation-driven-enable-signature]]\n\nSo far, we have been injecting a simple `String` in our endpoint, but it can actually have a very flexible method signature.\nThe following example rewrites it to inject the `Order` with a custom header:\n\n[source,java]\n----\n@Component\npublic class MyService {\n\n @RabbitListener(queues = \"myQueue\")\n public void processOrder(Order order, @Header(\"order_type\") String orderType) {\n ...\n }\n}\n----\n\nThe following list shows the arguments that are available to be matched with parameters in listener endpoints:\n\n* The raw `org.springframework.amqp.core.Message`.\n* The `MessageProperties` from the raw `Message`.\n* The `com.rabbitmq.client.Channel` on which the message was received.\n* The `org.springframework.messaging.Message` converted from the incoming AMQP message.\n* `@Header`-annotated method arguments to extract a specific header value, including standard AMQP headers.\n* `@Headers`-annotated argument that must also be assignable to `java.util.Map` for getting access to all headers.\n* The converted payload\n\nA non-annotated element that is not one of the supported types (that is,\n`Message`, `MessageProperties`, `Message<?>` and `Channel`) is matched with the payload.\nYou can make that explicit by annotating the parameter with `@Payload`.\nYou can also turn on validation by adding an extra `@Valid`.\n\nThe ability to inject Springâ€™s message abstraction is particularly useful to benefit from all the information stored in the transport-specific message without relying on the transport-specific API.\nThe following example shows how to do so:\n\n[source,java]\n----\n\n@RabbitListener(queues = \"myQueue\")\npublic void processOrder(Message<Order> order) { ...\n}\n\n----\n\nHandling of method arguments is provided by `DefaultMessageHandlerMethodFactory`, which you can further customize to support additional method arguments.\nThe conversion and validation support can be customized there as well.\n\nFor instance, if we want to make sure our `Order` is valid before processing it, we can annotate the payload with `@Valid` and configure the necessary validator, as follows:\n\n[source,java]\n----\n\n@Configuration\n@EnableRabbit\npublic class AppConfig implements RabbitListenerConfigurer {\n\n @Override\n public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) {\n registrar.setMessageHandlerMethodFactory(myHandlerMethodFactory());\n }\n\n @Bean\n public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() {\n DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory();\n factory.setValidator(myValidator());\n return factory;\n }\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/enable-signature.adoc", "title": "enable-signature", "heading": "enable-signature", "heading_level": 1, "file_order": 3, "section_index": 0, "content_hash": "437620f947f0d77c256db3b9110b69a9ea9567c08cac9342c7f751d1aa80c806", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/enable-signature.adoc"}}
{"id": "sha256:c84da32812627e74d2207a1ec4d8e48ab93102fb8a15f38b3f5312e12e779b5a", "content": "[[async-annotation-driven-enable]]\n\nTo enable support for `@RabbitListener` annotations, you can add `@EnableRabbit` to one of your `@Configuration` classes.\nThe following example shows how to do so:\n\n[source,java]\n----\n@Configuration\n@EnableRabbit\npublic class AppConfig {\n\n @Bean\n public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() {\n SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n factory.setConnectionFactory(connectionFactory());\n factory.setConcurrentConsumers(3);\n factory.setMaxConcurrentConsumers(10);\n factory.setContainerCustomizer(container -> /* customize the container */);\n return factory;\n }\n}\n----\n\nSince version 2.0, a `DirectMessageListenerContainerFactory` is also available.\nIt creates `DirectMessageListenerContainer` instances.\n\nNOTE: For information to help you choose between `SimpleRabbitListenerContainerFactory` and `DirectRabbitListenerContainerFactory`, see xref:amqp/receiving-messages/choose-container.adoc[Choosing a Container].\n\nStarting with version 2.2.2, you can provide a `ContainerCustomizer` implementation (as shown above).\nThis can be used to further configure the container after it has been created and configured; you can use this, for example, to set properties that are not exposed by the container factory.\n\nVersion 2.4.8 provides the `CompositeContainerCustomizer` for situations where you wish to apply multiple customizers.\n\nBy default, the infrastructure looks for a bean named `rabbitListenerContainerFactory` as the source for the factory to use to create message listener containers.\nIn this case, and ignoring the RabbitMQ infrastructure setup, the `processOrder` method can be invoked with a core poll size of three threads and a maximum pool size of ten threads.\n\nYou can customize the listener container factory to use it for each annotation, or you can configure an explicit default by implementing the `RabbitListenerConfigurer` interface.\nThe default is required only if at least one endpoint is registered without a specific container factory.\nSee the javadoc:org.springframework.amqp.rabbit.annotation.RabbitListenerConfigurer[Javadoc] for full details and examples.\n\nThe container factories provide methods for adding `MessagePostProcessor` instances that are applied after receiving messages (before invoking the listener) and before sending replies.\n\nSee xref:amqp/receiving-messages/async-annotation-driven/reply.adoc[Reply Management] for information about replies.\n\nStarting with version 2.0.6, you can add a `RetryTemplate` and `RecoveryCallback` to the listener container factory.\nIt is used when sending replies.\nThe `RecoveryCallback` is invoked when retries are exhausted.\n\nIf you prefer XML configuration, you can use the `<rabbit:annotation-driven>` element.\nAny beans annotated with `@RabbitListener` are detected.\n\nFor `SimpleRabbitListenerContainer` instances, you can use XML similar to the following:\n\n[source,xml]\n----\n<rabbit:annotation-driven/>\n\n<bean id=\"rabbitListenerContainerFactory\"\n class=\"org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory\">\n <property name=\"connectionFactory\" ref=\"connectionFactory\"/>\n <property name=\"concurrentConsumers\" value=\"3\"/>\n <property name=\"maxConcurrentConsumers\" value=\"10\"/>\n</bean>\n----\n\nFor `DirectMessageListenerContainer` instances, you can use XML similar to the following:\n\n[source,xml]\n----\n<rabbit:annotation-driven/>\n\n<bean id=\"rabbitListenerContainerFactory\"\n class=\"org.springframework.amqp.rabbit.config.DirectRabbitListenerContainerFactory\">\n <property name=\"connectionFactory\" ref=\"connectionFactory\"/>\n <property name=\"consumersPerQueue\" value=\"3\"/>\n</bean>\n----\n\n[[listener-property-overrides]]\nStarting with version 2.0, the `@RabbitListener` annotation has a `concurrency` property.\nIt supports SpEL expressions (`#{...}`) and property placeholders (`${...}`).\nIts meaning and allowed values depend on the container type, as follows:\n\n* For the `DirectMessageListenerContainer`, the value must be a single integer value, which sets the `consumersPerQueue` property on the container.\n* For the `SimpleRabbitListenerContainer`, the value can be a single integer value, which sets the `concurrentConsumers` property on the container, or it can have the form, `m-n`, where `m` is the `concurrentConsumers` property and `n` is the `maxConcurrentConsumers` property.\n\nIn either case, this setting overrides the settings on the factory.\nPreviously you had to define different container factories if you had listeners that required different concurrency.\n\nThe annotation also allows overriding the factory `autoStartup` and `taskExecutor` properties via the `autoStartup` and `executor` (since 2.2) annotation properties.\nUsing a different executor for each might help with identifying threads associated with each listener in logs and thread dumps.\n\nVersion 2.2 also added the `ackMode` property, which allows you to override the container factory's `acknowledgeMode` property.\n\n[source, java]\n----\n@RabbitListener(id = \"manual.acks.1\", queues = \"manual.acks.1\", ackMode = \"MANUAL\")\npublic void manual1(String in, Channel channel,\n @Header(AmqpHeaders.DELIVERY_TAG) long tag) throws IOException {\n\n ...\n channel.basicAck(tag, false);\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/enable.adoc", "title": "enable", "heading": "enable", "heading_level": 1, "file_order": 4, "section_index": 0, "content_hash": "c84da32812627e74d2207a1ec4d8e48ab93102fb8a15f38b3f5312e12e779b5a", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/enable.adoc"}}
{"id": "sha256:5b05770066f6c8c366b0ee16d72f0eaed6cd6a61655c4b9eeba8215d5a89c458", "content": "[[annotation-error-handling]]\n\nBy default, if an annotated listener method throws an exception, it is thrown to the container and the message are requeued and redelivered, discarded, or routed to a dead letter exchange, depending on the container and broker configuration.\nNothing is returned to the sender.\n\nStarting with version 2.0, the `@RabbitListener` annotation has two new attributes: `errorHandler` and `returnExceptions`.\n\nThese are not configured by default.\n\nYou can use the `errorHandler` to provide the bean name of a `RabbitListenerErrorHandler` implementation.\nThis functional interface has one method, as follows:\n\n[source, java]\n----\n@FunctionalInterface\npublic interface RabbitListenerErrorHandler {\n\n Object handleError(Message amqpMessage, org.springframework.messaging.Message<?> message,\n ListenerExecutionFailedException exception) throws Exception;\n\n}\n----\n\nAs you can see, you have access to the raw message received from the container, the spring-messaging `Message<?>` object produced by the message converter, and the exception that was thrown by the listener (wrapped in a `ListenerExecutionFailedException`).\nThe error handler can either return some result (which is sent as the reply) or throw the original or a new exception (which is thrown to the container or returned to the sender, depending on the `returnExceptions` setting).\n\nThe `returnExceptions` attribute, when `true`, causes exceptions to be returned to the sender.\nThe exception is wrapped in a `RemoteInvocationResult` object.\nOn the sender side, there is an available `RemoteInvocationAwareMessageConverterAdapter`, which, if configured into the `RabbitTemplate`, re-throws the server-side exception, wrapped in an `AmqpRemoteException`.\nThe stack trace of the server exception is synthesized by merging the server and client stack traces.\n\nIMPORTANT: This mechanism generally works only with the default `SimpleMessageConverter`, which uses Java serialization.\nExceptions are generally not \"`Jackson-friendly`\" and cannot be serialized to JSON.\nIf you use JSON, consider using an `errorHandler` to return some other Jackson-friendly `Error` object when an exception is thrown.\n\nIMPORTANT: In version 2.1, this interface moved from package `o.s.amqp.rabbit.listener` to `o.s.amqp.rabbit.listener.api`.\n\nStarting with version 2.1.7, the `Channel` is available in a messaging message header; this allows you to ack or nack the failed message when using `AcknowledgeMode.MANUAL`:\n\n[source, java]\n----\npublic Object handleError(Message amqpMessage, org.springframework.messaging.Message<?> message,\n ListenerExecutionFailedException exception) {\n ...\n message.getHeaders().get(AmqpHeaders.CHANNEL, Channel.class)\n .basicReject(message.getHeaders().get(AmqpHeaders.DELIVERY_TAG, Long.class),\n true);\n }\n----\n\nStarting with version 2.2.18, if a message conversion exception is thrown, the error handler will be called, with `null` in the `message` argument.\nThis allows the application to send some result to the caller, indicating that a badly-formed message was received.\nPreviously, such errors were thrown and handled by the container.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/error-handling.adoc", "title": "error-handling", "heading": "error-handling", "heading_level": 1, "file_order": 5, "section_index": 0, "content_hash": "5b05770066f6c8c366b0ee16d72f0eaed6cd6a61655c4b9eeba8215d5a89c458", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/error-handling.adoc"}}
{"id": "sha256:bdf3b0f74ab9fe4a81346453e95a2ca75f5004dc861df156e990a1216049123d", "content": "[[meta-annotation-driven]]\n\nSometimes you may want to use the same configuration for multiple listeners.\nTo reduce the boilerplate configuration, you can use meta-annotations to create your own listener annotation.\nThe following example shows how to do so:\n\n[source, java]\n----\n@Target({ElementType.TYPE, ElementType.METHOD, ElementType.ANNOTATION_TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@RabbitListener(bindings = @QueueBinding(\n value = @Queue,\n exchange = @Exchange(value = \"metaFanout\", type = ExchangeTypes.FANOUT)))\npublic @interface MyAnonFanoutListener {\n}\n\npublic class MetaListener {\n\n @MyAnonFanoutListener\n public void handle1(String foo) {\n ...\n }\n\n @MyAnonFanoutListener\n public void handle2(String foo) {\n ...\n }\n\n}\n----\n\nIn the preceding example, each listener created by the `@MyAnonFanoutListener` annotation binds an anonymous, auto-delete\nqueue to the fanout exchange, `metaFanout`.\nStarting with version 2.2.3, `@AliasFor` is supported to allow overriding properties on the meta-annotated annotation.\nAlso, user annotations can now be `@Repeatable`, allowing multiple containers to be created for a method.\n\n[source, java]\n----\n@Component\nstatic class MetaAnnotationTestBean {\n\n @MyListener(\"queue1\")\n @MyListener(\"queue2\")\n public void handleIt(String body) {\n }\n\n}\n\n@RabbitListener\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Repeatable(MyListeners.class)\nstatic @interface MyListener {\n\n @AliasFor(annotation = RabbitListener.class, attribute = \"queues\")\n String[] value() default {};\n\n}\n\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\nstatic @interface MyListeners {\n\n MyListener[] value();\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/meta.adoc", "title": "meta", "heading": "meta", "heading_level": 1, "file_order": 6, "section_index": 0, "content_hash": "bdf3b0f74ab9fe4a81346453e95a2ca75f5004dc861df156e990a1216049123d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/meta.adoc"}}
{"id": "sha256:62e5631da694e8542b46ed0ecf0557d0512bfc0aff93e4f0b2e729b49b9f1dc1", "content": "[[annotation-method-selection]]\n\nStarting with version 1.5.0, you can specify the `@RabbitListener` annotation at the class level.\nTogether with the new `@RabbitHandler` annotation, this lets a single listener invoke different methods, based on\nthe payload type of the incoming message.\nThis is best described using an example:\n\n[source, java]\n----\n@RabbitListener(id=\"multi\", queues = \"someQueue\")\n@SendTo(\"my.reply.queue\")\npublic class MultiListenerBean {\n\n @RabbitHandler\n public String thing2(Thing2 thing2) {\n ...\n }\n\n @RabbitHandler\n public String cat(Cat cat) {\n ...\n }\n\n @RabbitHandler\n public String hat(@Header(\"amqp_receivedRoutingKey\") String rk, @Payload Hat hat) {\n ...\n }\n\n @RabbitHandler(isDefault = true)\n public String defaultMethod(Object object) {\n ...\n }\n\n}\n----\n\nIn this case, the individual `@RabbitHandler` methods are invoked if the converted payload is a `Thing2`, a `Cat`, or a `Hat`.\nYou should understand that the system must be able to identify a unique method based on the payload type.\nThe type is checked for assignability to a single parameter that has no annotations or that is annotated with the `@Payload` annotation.\nNotice that the same method signatures apply, as discussed in the method-level `@RabbitListener` (xref:amqp/receiving-messages/async-consumer.adoc#message-listener-adapter[described earlier]).\n\nStarting with version 2.0.3, a `@RabbitHandler` method can be designated as the default method, which is invoked if there is no match on other methods.\nAt most, one method can be so designated.\n\nIMPORTANT: `@RabbitHandler` is intended only for processing message payloads after conversion, if you wish to receive the unconverted raw `Message` object, you must use `@RabbitListener` on the method, not the class.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/method-selection.adoc", "title": "method-selection", "heading": "method-selection", "heading_level": 1, "file_order": 7, "section_index": 0, "content_hash": "62e5631da694e8542b46ed0ecf0557d0512bfc0aff93e4f0b2e729b49b9f1dc1", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/method-selection.adoc"}}
{"id": "sha256:5af6178d0936a5120246704bf7ff411ec9a7b9a40c67f64268ca9f0ef546d1ab", "content": "[[annotation-multiple-queues]]\n\nWhen you use the `queues` attribute, you can specify that the associated container can listen to multiple queues.\nYou can use a `@Header` annotation to make the queue name from which a message was received available to the POJO\nmethod.\nThe following example shows how to do so:\n\n[source, java]\n----\n@Component\npublic class MyService {\n\n @RabbitListener(queues = { \"queue1\", \"queue2\" } )\n public void processOrder(String data, @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) {\n ...\n }\n\n}\n----\n\nStarting with version 1.5, you can externalize the queue names by using property placeholders and SpEL.\nThe following example shows how to do so:\n\n[source, java]\n----\n@Component\npublic class MyService {\n\n @RabbitListener(queues = \"#{'${property.with.comma.delimited.queue.names}'.split(',')}\" )\n public void processOrder(String data, @Header(AmqpHeaders.CONSUMER_QUEUE) String queue) {\n ...\n }\n\n}\n----\n\nPrior to version 1.5, only a single queue could be specified this way.\nEach queue needed a separate property.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/multiple-queues.adoc", "title": "multiple-queues", "heading": "multiple-queues", "heading_level": 1, "file_order": 8, "section_index": 0, "content_hash": "5af6178d0936a5120246704bf7ff411ec9a7b9a40c67f64268ca9f0ef546d1ab", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/multiple-queues.adoc"}}
{"id": "sha256:b992610450647a2a9fca14d515f9d2bd4af8d209d3c236a21a35f4f71641bb46", "content": "[[proxy-rabbitlistener-and-generics]]\n\nIf your service is intended to be proxied (for example, in the case of `@Transactional`), you should keep in mind some considerations when\nthe interface has generic parameters.\nConsider the following example:\n\n[source, java]\n----\ninterface TxService<P> {\n\n String handle(P payload, String header);\n\n}\n\nstatic class TxServiceImpl implements TxService<Foo> {\n\n @Override\n @RabbitListener(...)\n public String handle(Thing thing, String rk) {\n ...\n }\n\n}\n----\n\nWith a generic interface and a particular implementation, you are forced to switch to the CGLIB target class proxy because the actual implementation of the interface\n`handle` method is a bridge method.\nIn the case of transaction management, the use of CGLIB is configured by using\nan annotation option: `@EnableTransactionManagement(proxyTargetClass = true)`.\nAnd in this case, all annotations have to be declared on the target method in the implementation, as the following example shows:\n\n[source, java]\n----\nstatic class TxServiceImpl implements TxService<Foo> {\n\n @Override\n @Transactional\n @RabbitListener(...)\n public String handle(@Payload Foo foo, @Header(\"amqp_receivedRoutingKey\") String rk) {\n ...\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/proxy-rabbitlistener-and-generics.adoc", "title": "proxy-rabbitlistener-and-generics", "heading": "proxy-rabbitlistener-and-generics", "heading_level": 1, "file_order": 9, "section_index": 0, "content_hash": "b992610450647a2a9fca14d515f9d2bd4af8d209d3c236a21a35f4f71641bb46", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/proxy-rabbitlistener-and-generics.adoc"}}
{"id": "sha256:c76908ac6378a3414b3b0613985d5f61d4345b00b7cdce316b24cb0476af7c79", "content": "[[rabbit-validation]]\n\nStarting with version 2.3.7, it is now easier to add a `Validator` to validate `@RabbitListener` and `@RabbitHandler` `@Payload` arguments.\nNow, you can simply add the validator to the registrar itself.\n\n[source, java]\n----\n@Configuration\n@EnableRabbit\npublic class Config implements RabbitListenerConfigurer {\n ...\n @Override\n public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) {\n registrar.setValidator(new MyValidator());\n }\n}\n----\n\nNOTE: When using Spring Boot with the validation starter, a `LocalValidatorFactoryBean` is auto-configured:\n\n[source, java]\n----\n@Configuration\n@EnableRabbit\npublic class Config implements RabbitListenerConfigurer {\n @Autowired\n private LocalValidatorFactoryBean validator;\n ...\n @Override\n public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) {\n registrar.setValidator(this.validator);\n }\n}\n----\n\nTo validate:\n\n[source, java]\n----\npublic static class ValidatedClass {\n @Max(10)\n private int bar;\n public int getBar() {\n return this.bar;\n }\n public void setBar(int bar) {\n this.bar = bar;\n }\n}\n----\n\nand\n\n[source, java]\n----\n@RabbitListener(id=\"validated\", queues = \"queue1\", errorHandler = \"validationErrorHandler\",\n containerFactory = \"jsonListenerContainerFactory\")\npublic void validatedListener(@Payload @Valid ValidatedClass val) {\n ...\n}\n@Bean\npublic RabbitListenerErrorHandler validationErrorHandler() {\n return (m, e) -> {\n ...\n };\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/rabbit-validation.adoc", "title": "rabbit-validation", "heading": "rabbit-validation", "heading_level": 1, "file_order": 10, "section_index": 0, "content_hash": "c76908ac6378a3414b3b0613985d5f61d4345b00b7cdce316b24cb0476af7c79", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/rabbit-validation.adoc"}}
{"id": "sha256:4f87b4eb3d06683062e11ac688cbdcca31790eda4f707e6acc40e2ebdcc678db", "content": "[[async-annotation-driven-registration]]\n\n`RabbitListenerEndpoint` provides a model of a Rabbit endpoint and is responsible for configuring the container for that model.\nThe infrastructure lets you configure endpoints programmatically in addition to the ones that are detected by the `RabbitListener` annotation.\nThe following example shows how to do so:\n\n[source,java]\n----\n@Configuration\n@EnableRabbit\npublic class AppConfig implements RabbitListenerConfigurer {\n\n @Override\n public void configureRabbitListeners(RabbitListenerEndpointRegistrar registrar) {\n SimpleRabbitListenerEndpoint endpoint = new SimpleRabbitListenerEndpoint();\n endpoint.setId(\"someRabbitListenerEndpoint\");\n endpoint.setQueueNames(\"anotherQueue\");\n endpoint.setMessageListener(message -> {\n // processing\n });\n registrar.registerEndpoint(endpoint);\n }\n}\n----\n\nIn the preceding example, we used `SimpleRabbitListenerEndpoint`, which provides the actual `MessageListener` to invoke, but you could just as well build your own endpoint variant to describe a custom invocation mechanism.\n\nNOTE: the `id` property is required for `SimpleRabbitListenerEndpoint` definition.\n\nIt should be noted that you could just as well skip the use of `@RabbitListener` altogether and register your endpoints programmatically through `RabbitListenerConfigurer`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/registration.adoc", "title": "registration", "heading": "registration", "heading_level": 1, "file_order": 11, "section_index": 0, "content_hash": "4f87b4eb3d06683062e11ac688cbdcca31790eda4f707e6acc40e2ebdcc678db", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/registration.adoc"}}
{"id": "sha256:3d3c2057e1ee31ce2a0f17bf0a2fd8ca9d1b0615daa53030cee56514a1952265", "content": "[[repeatable-rabbit-listener]]\n\nStarting with version 1.6, the `@RabbitListener` annotation is marked with `@Repeatable`.\nThis means that the annotation can appear on the same annotated element (method or class) multiple times.\nIn this case, a separate listener container is created for each annotation, each of which invokes the same listener\n`@Bean`.\nRepeatable annotations can be used with Java 8 or above.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/repeatable-rabbit-listener.adoc", "title": "repeatable-rabbit-listener", "heading": "repeatable-rabbit-listener", "heading_level": 1, "file_order": 12, "section_index": 0, "content_hash": "3d3c2057e1ee31ce2a0f17bf0a2fd8ca9d1b0615daa53030cee56514a1952265", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/repeatable-rabbit-listener.adoc"}}
{"id": "sha256:1181fa19996e3a16ec1ff6d6a941bc76b7b76eb2beac30dd4657597956e6008b", "content": "[[reply-content-type]]\n\nIf you are using a sophisticated message converter, such as the `ContentTypeDelegatingMessageConverter`, you can control the content type of the reply by setting the `replyContentType` property on the listener.\nThis allows the converter to select the appropriate delegate converter for the reply.\n\n[source, java]\n----\n@RabbitListener(queues = \"q1\", messageConverter = \"delegating\",\n replyContentType = \"application/json\")\npublic Thing2 listen(Thing1 in) {\n ...\n}\n----\n\nBy default, for backwards compatibility, any content type property set by the converter will be overwritten by this value after conversion.\nConverters such as the `SimpleMessageConverter` use the reply type rather than the content type to determine the conversion needed and sets the content type in the reply message appropriately.\nThis may not be the desired action and can be overridden by setting the `converterWinsContentType` property to `false`.\nFor example, if you return a `String` containing JSON, the `SimpleMessageConverter` will set the content type in the reply to `text/plain`.\nThe following configuration will ensure the content type is set properly, even if the `SimpleMessageConverter` is used.\n\n[source, java]\n----\n@RabbitListener(queues = \"q1\", replyContentType = \"application/json\",\n converterWinsContentType = \"false\")\npublic String listen(Thing in) {\n ...\n return someJsonString;\n}\n----\n\nThese properties (`replyContentType` and `converterWinsContentType`) do not apply when the return type is a Spring AMQP `Message` or a Spring Messaging `Message<?>`.\nIn the first case, there is no conversion involved; simply set the `contentType` message property.\nIn the second case, the behavior is controlled using message headers:\n\n[source, java]\n----\n@RabbitListener(queues = \"q1\", messageConverter = \"delegating\")\n@SendTo(\"q2\")\npublic Message<String> listen(String in) {\n ...\n return MessageBuilder.withPayload(in.toUpperCase())\n .setHeader(MessageHeaders.CONTENT_TYPE, \"application/xml\")\n .build();\n}\n----\n\nThis content type will be passed in the `MessageProperties` to the converter.\nBy default, for backwards compatibility, any content type property set by the converter will be overwritten by this value after conversion.\nIf you wish to override that behavior, also set the `AmqpHeaders.CONTENT_TYPE_CONVERTER_WINS` to `true` and any value set by the converter will be retained.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/reply-content-type.adoc", "title": "reply-content-type", "heading": "reply-content-type", "heading_level": 1, "file_order": 13, "section_index": 0, "content_hash": "1181fa19996e3a16ec1ff6d6a941bc76b7b76eb2beac30dd4657597956e6008b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/reply-content-type.adoc"}}
{"id": "sha256:58174f78c90d22975dd7b3d86c7a5c953982a268efad34d2e3579361d8cf0666", "content": "[[async-annotation-driven-reply]]\n\nThe existing support in `MessageListenerAdapter` already lets your method have a non-void return type.\nWhen that is the case, the result of the invocation is encapsulated in a message sent to the address specified in the `ReplyToAddress` header of the original message, or to the default address configured on the listener.\nYou can set that default address by using the `@SendTo` annotation of the messaging abstraction.\n\nAssuming our `processOrder` method should now return an `OrderStatus`, we can write it as follows to automatically send a reply:\n\n[source,java]\n----\n@RabbitListener(destination = \"myQueue\")\n@SendTo(\"status\")\npublic OrderStatus processOrder(Order order) {\n // order processing\n return status;\n}\n----\n\nIf you need to set additional headers in a transport-independent manner, you could return a `Message` instead, something like the following:\n\n[source,java]\n----\n\n@RabbitListener(destination = \"myQueue\")\n@SendTo(\"status\")\npublic Message<OrderStatus> processOrder(Order order) {\n // order processing\n return MessageBuilder\n .withPayload(status)\n .setHeader(\"code\", 1234)\n .build();\n}\n----\n\nAlternatively, you can use a `MessagePostProcessor` in the `beforeSendReplyMessagePostProcessors` container factory property to add more headers.\nStarting with version 2.2.3, the called bean/method is made available in the reply message, which can be used in a message post processor to communicate the information back to the caller:\n\n[source, java]\n----\nfactory.setBeforeSendReplyPostProcessors(msg -> {\n msg.getMessageProperties().setHeader(\"calledBean\",\n msg.getMessageProperties().getTargetBean().getClass().getSimpleName());\n msg.getMessageProperties().setHeader(\"calledMethod\",\n msg.getMessageProperties().getTargetMethod().getName());\n return m;\n});\n----\n\nStarting with version 2.2.5, you can configure a `ReplyPostProcessor` to modify the reply message before it is sent; it is called after the `correlationId` header has been set up to match the request.\n\n[source, java]\n----\n@RabbitListener(queues = \"test.header\", group = \"testGroup\", replyPostProcessor = \"echoCustomHeader\")\npublic String capitalizeWithHeader(String in) {\n return in.toUpperCase();\n}\n\n@Bean\npublic ReplyPostProcessor echoCustomHeader() {\n return (req, resp) -> {\n resp.getMessageProperties().setHeader(\"myHeader\", req.getMessageProperties().getHeader(\"myHeader\"));\n return resp;\n };\n}\n----\n\nStarting with version 3.0, you can configure the post processor on the container factory instead of on the annotation.\n\n[source, java]\n----\nfactory.setReplyPostProcessorProvider(id -> (req, resp) -> {\n resp.getMessageProperties().setHeader(\"myHeader\", req.getMessageProperties().getHeader(\"myHeader\"));\n return resp;\n});\n----\n\nThe `id` parameter is the listener id.\n\nA setting on the annotation will supersede the factory setting.\n\nThe `@SendTo` value is assumed as a reply `exchange` and `routingKey` pair that follows the `exchange/routingKey` pattern,\nwhere one of those parts can be omitted.\nThe valid values are as follows:\n\n* `thing1/thing2`: The `replyTo` exchange and the `routingKey`.\n`thing1/`: The `replyTo` exchange and the default (empty) `routingKey`.\n`thing2` or `/thing2`: The `replyTo` `routingKey` and the default (empty) exchange.\n`/` or empty: The `replyTo` default exchange and the default `routingKey`.\n\nAlso, you can use `@SendTo` without a `value` attribute.\nThis case is equal to an empty `sendTo` pattern.\n`@SendTo` is used only if the inbound message does not have a `replyToAddress` property.\n\nStarting with version 1.5, the `@SendTo` value can be a bean initialization SpEL Expression, as shown in the following example:\n\n[source, java]\n----\n@RabbitListener(queues = \"test.sendTo.spel\")\n@SendTo(\"#{spelReplyTo}\")\npublic String capitalizeWithSendToSpel(String foo) {\n return foo.toUpperCase();\n}\n...\n@Bean\npublic String spelReplyTo() {\n return \"test.sendTo.reply.spel\";\n}\n----\n\nThe expression must evaluate to a `String`, which can be a simple queue name (sent to the default exchange) or with\nthe form `exchange/routingKey` as discussed prior to the preceding example.\n\nNOTE: The `#{...}` expression is evaluated once, during initialization.\n\nFor dynamic reply routing, the message sender should include a `reply_to` message property or use the alternate\nruntime SpEL expression (described after the next example).\n\nStarting with version 1.6, the `@SendTo` can be a SpEL expression that is evaluated at runtime against the request\nand reply, as the following example shows:\n\n[source, java]\n----\n@RabbitListener(queues = \"test.sendTo.spel\")\n@SendTo(\"!{'some.reply.queue.with.' + result.queueName}\")\npublic Bar capitalizeWithSendToSpel(Foo foo) {\n return processTheFooAndReturnABar(foo);\n}\n----\n\nThe runtime nature of the SpEL expression is indicated with `!{...}` delimiters.\nThe evaluation context `#root` object for the expression has three properties:\n\n* `request`: The `o.s.amqp.core.Message` request object.\n* `source`: The `o.s.messaging.Message<?>` after conversion.\n* `result`: The method result.\n\nThe context has a map property accessor, a standard type converter, and a bean resolver, which lets other beans in the\ncontext be referenced (for example, `@someBeanName.determineReplyQ(request, result)`).\n\nIn summary, `#{...}` is evaluated once during initialization, with the `#root` object being the application context.\nBeans are referenced by their names.\n`!{...}` is evaluated at runtime for each message, with the root object having the properties listed earlier.\nBeans are referenced with their names, prefixed by `@`.\n\nStarting with version 2.1, simple property placeholders are also supported (for example, `${some.reply.to}`).\nWith earlier versions, the following can be used as a work around, as the following example shows:\n\n[source, java]\n----\n@RabbitListener(queues = \"foo\")\n@SendTo(\"#{environment['my.send.to']}\")\npublic String listen(Message in) {\n ...\n return ...\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/reply.adoc", "title": "reply", "heading": "reply", "heading_level": 1, "file_order": 14, "section_index": 0, "content_hash": "58174f78c90d22975dd7b3d86c7a5c953982a268efad34d2e3579361d8cf0666", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven/reply.adoc"}}
{"id": "sha256:b3283526dec3990487ccc0c5b1d8aff8d2151ff874950e997ef8f9de3b002a8d", "content": "[[async-annotation-driven]]\n\nThe easiest way to receive a message asynchronously is to use the annotated listener endpoint infrastructure.\nIn a nutshell, it lets you expose a method of a managed bean as a Rabbit listener endpoint.\nThe following example shows how to use the `@RabbitListener` annotation:\n\n[source,java]\n----\n\n@Component\npublic class MyService {\n\n @RabbitListener(queues = \"myQueue\")\n public void processOrder(String data) {\n ...\n }\n\n}\n----\n\nThe idea of the preceding example is that, whenever a message is available on the queue named `myQueue`, the `processOrder` method is invoked accordingly (in this case, with the payload of the message).\n\nThe annotated endpoint infrastructure creates a message listener container behind the scenes for each annotated method, by using a `RabbitListenerContainerFactory`.\n\nIn the preceding example, `myQueue` must already exist and be bound to some exchange.\nThe queue can be declared and bound automatically, as long as a `RabbitAdmin` exists in the application context.\n\nNOTE: Property placeholders (`${some.property}`) or SpEL expressions (`+#{someExpression}+`) can be specified for the annotation properties (`queues` etc).\nSee xref:amqp/receiving-messages/async-annotation-driven/multiple-queues.adoc[Listening to Multiple Queues] for an example of why you might use SpEL instead of a property placeholder.\nThe following listing shows three examples of how to declare a Rabbit listener:\n\n[source,java]\n----\n\n@Component\npublic class MyService {\n\n @RabbitListener(bindings = @QueueBinding(\n value = @Queue(value = \"myQueue\", durable = \"true\"),\n exchange = @Exchange(value = \"auto.exch\", ignoreDeclarationExceptions = \"true\"),\n key = \"orderRoutingKey\")\n )\n public void processOrder(Order order) {\n ...\n }\n\n @RabbitListener(bindings = @QueueBinding(\n value = @Queue,\n exchange = @Exchange(value = \"auto.exch\"),\n key = \"invoiceRoutingKey\")\n )\n public void processInvoice(Invoice invoice) {\n ...\n }\n\n @RabbitListener(queuesToDeclare = @Queue(name = \"${my.queue}\", durable = \"true\"))\n public String handleWithSimpleDeclare(String data) {\n ...\n }\n\n}\n----\n\nIn the first example, a queue `myQueue` is declared automatically (durable) together with the exchange, if needed,\nand bound to the exchange with the routing key.\nIn the second example, an anonymous (exclusive, auto-delete) queue is declared and bound; the queue name is created by the framework using the `Base64UrlNamingStrategy`.\nYou cannot declare broker-named queues using this technique; they need to be declared as bean definitions; see xref:amqp/containers-and-broker-named-queues.adoc[Containers and Broker-Named queues].\nMultiple `QueueBinding` entries can be provided, letting the listener listen to multiple queues.\nIn the third example, a queue with the name retrieved from property `my.queue` is declared, if necessary, with the default binding to the default exchange using the queue name as the routing key.\n\nSince version 2.0, the `@Exchange` annotation supports any exchange types, including custom.\nFor more information, see https://www.rabbitmq.com/tutorials/amqp-concepts.html[AMQP Concepts].\n\nYou can use normal `@Bean` definitions when you need more advanced configuration.\n\nNotice `ignoreDeclarationExceptions` on the exchange in the first example.\nThis allows, for example, binding to an existing exchange that might have different settings (such as `internal`).\nBy default, the properties of an existing exchange must match.\n\nStarting with version 2.0, you can now bind a queue to an exchange with multiple routing keys, as the following example shows:\n\n[source, java]\n----\n...\n key = { \"red\", \"yellow\" }\n...\n----\n\nYou can also specify arguments within `@QueueBinding` annotations for queues, exchanges,\nand bindings, as the following example shows:\n\n[source, java]\n----\n@RabbitListener(bindings = @QueueBinding(\n value = @Queue(value = \"auto.headers\", autoDelete = \"true\",\n arguments = @Argument(name = \"x-message-ttl\", value = \"10000\",\n type = \"java.lang.Integer\")),\n exchange = @Exchange(value = \"auto.headers\", type = ExchangeTypes.HEADERS, autoDelete = \"true\"),\n arguments = {\n @Argument(name = \"x-match\", value = \"all\"),\n @Argument(name = \"thing1\", value = \"somevalue\"),\n @Argument(name = \"thing2\")\n })\n)\npublic String handleWithHeadersExchange(String foo) {\n ...\n}\n----\n\nNotice that the `x-message-ttl` argument is set to 10 seconds for the queue.\nSince the argument type is not `String`, we have to specify its type -- in this case, `Integer`.\nAs with all such declarations, if the queue already exists, the arguments must match those on the queue.\nFor the header exchange, we set the binding arguments to match messages that have the `thing1` header set to `somevalue`, and\nthe `thing2` header must be present with any value.\nThe `x-match` argument means both conditions must be satisfied.\n\nThe argument name, value, and type can be property placeholders (`${...}`) or SpEL expressions (`#{...}`).\nThe `name` must resolve to a `String`.\nThe expression for `type` must resolve to a `Class` or the fully-qualified name of a class.\nThe `value` must resolve to something that can be converted by the `DefaultConversionService` to the type (such as the `x-message-ttl` in the preceding example).\n\nIf a name resolves to `null` or an empty `String`, that `@Argument` is ignored.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven.adoc", "title": "async-annotation-driven", "heading": "async-annotation-driven", "heading_level": 1, "file_order": 15, "section_index": 0, "content_hash": "b3283526dec3990487ccc0c5b1d8aff8d2151ff874950e997ef8f9de3b002a8d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-annotation-driven.adoc"}}
{"id": "sha256:c2a6932988bd9d5930aeb625852150948cdd847f77f106718d52f0630fcc1a26", "content": "[[async-consumer]]\n\nIMPORTANT: Spring AMQP also supports annotated listener endpoints through the use of the `@RabbitListener` annotation and provides an open infrastructure to register endpoints programmatically.\nThis is by far the most convenient way to setup an asynchronous consumer.\nSee xref:amqp/receiving-messages/async-annotation-driven.adoc[Annotation-driven Listener Endpoints] for more details.\n\n[IMPORTANT]\n====\nThe prefetch default value used to be 1, which could lead to under-utilization of efficient consumers.\nStarting with version 2.0, the default prefetch value is now 250, which should keep consumers busy in most common scenarios and\nthus improve throughput.\n\nThere are, nevertheless, scenarios where the prefetch value should be low:\n\n* For large messages, especially if the processing is slow (messages could add up to a large amount of memory in the client process)\n* When strict message ordering is necessary (the prefetch value should be set back to 1 in this case)\n* Other special cases\n\nAlso, with low-volume messaging and multiple consumers (including concurrency within a single listener container instance), you may wish to reduce the prefetch to get a more even distribution of messages across consumers.\n\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration].\n\nFor more background about prefetch, see this post about https://www.rabbitmq.com/blog/2014/04/14/finding-bottlenecks-with-rabbitmq-3-3/[consumer utilization in RabbitMQ]\nand this post about https://www.rabbitmq.com/blog/2012/05/11/some-queuing-theory-throughput-latency-and-bandwidth/[queuing theory].\n====\n\n[[message-listener]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-consumer.adoc", "title": "async-consumer", "heading": "async-consumer", "heading_level": 1, "file_order": 16, "section_index": 0, "content_hash": "c2a6932988bd9d5930aeb625852150948cdd847f77f106718d52f0630fcc1a26", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-consumer.adoc"}}
{"id": "sha256:56cc149eaee28f91a0081512fffa2628f7ca5eaabf369cf5af59912ef8908e2c", "content": "For asynchronous `Message` reception, a dedicated component (not the `AmqpTemplate`) is involved.\nThat component is a container for a `Message`-consuming callback.\nWe consider the container and its properties later in this section.\nFirst, though, we should look at the callback, since that is where your application code is integrated with the messaging system.\nThere are a few options for the callback, starting with an implementation of the `MessageListener` interface, which the following listing shows:\n\n[source,java]\n----\npublic interface MessageListener {\n void onMessage(Message message);\n}\n----\n\nIf your callback logic depends on the AMQP Channel instance for any reason, you may instead use the `ChannelAwareMessageListener`.\nIt looks similar but has an extra parameter.\nThe following listing shows the `ChannelAwareMessageListener` interface definition:\n\n[source,java]\n----\npublic interface ChannelAwareMessageListener {\n void onMessage(Message message, Channel channel) throws Exception;\n}\n----\n\nIMPORTANT: In version 2.1, this interface moved from package `o.s.amqp.rabbit.core` to `o.s.amqp.rabbit.listener.api`.\n\n[[message-listener-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-consumer.adoc", "title": "async-consumer", "heading": "Message Listener", "heading_level": 2, "file_order": 16, "section_index": 1, "content_hash": "56cc149eaee28f91a0081512fffa2628f7ca5eaabf369cf5af59912ef8908e2c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-consumer.adoc"}}
{"id": "sha256:c2f31aa3c8871f7571d998291e406cb450393f02fee15c3104af945037f73370", "content": "If you prefer to maintain a stricter separation between your application logic and the messaging API, you can rely upon an adapter implementation that is provided by the framework.\nThis is often referred to as \"`Message-driven POJO`\" support.\n\nNOTE: Version 1.5 introduced a more flexible mechanism for POJO messaging, the `@RabbitListener` annotation.\nSee xref:amqp/receiving-messages/async-annotation-driven.adoc[Annotation-driven Listener Endpoints] for more information.\n\nWhen using the adapter, you need to provide only a reference to the instance that the adapter itself should invoke.\nThe following example shows how to do so:\n\n[source,java]\n----\nMessageListenerAdapter listener = new MessageListenerAdapter(somePojo);\nlistener.setDefaultListenerMethod(\"myMethod\");\n----\n\nYou can subclass the adapter and provide an implementation of `getListenerMethodName()` to dynamically select different methods based on the message.\nThis method has two parameters, `originalMessage` and `extractedMessage`, the latter being the result of any conversion.\nBy default, a `SimpleMessageConverter` is configured.\nSee xref:amqp/message-converters.adoc#simple-message-converter[`SimpleMessageConverter`] for more information and information about other converters available.\n\nStarting with version 1.4.2, the original message has `consumerQueue` and `consumerTag` properties, which can be used to determine the queue from which a message was received.\n\nStarting with version 1.5, you can configure a map of consumer queue or tag to method name, to dynamically select the method to call.\nIf no entry is in the map, we fall back to the default listener method.\nThe default listener method (if not set) is `handleMessage`.\n\nStarting with version 2.0, a convenient `FunctionalInterface` has been provided.\nThe following listing shows the definition of `FunctionalInterface`:\n\n[source, java]\n----\n@FunctionalInterface\npublic interface ReplyingMessageListener<T, R> {\n\n R handleMessage(T t);\n\n}\n----\n\nThis interface facilitates convenient configuration of the adapter by using Java 8 lambdas, as the following example shows:\n\n[source, java]\n----\nnew MessageListenerAdapter((ReplyingMessageListener<String, String>) data -> {\n ...\n return result;\n}));\n----\n\nStarting with version 2.2, the `buildListenerArguments(Object)` has been deprecated and new `buildListenerArguments(Object, Channel, Message)` one has been introduced instead.\nThe new method helps listener to get `Channel` and `Message` arguments to do more, such as calling `channel.basicReject(long, boolean)` in manual acknowledge mode.\nThe following listing shows the most basic example:\n\n[source,java]\n----\npublic class ExtendedListenerAdapter extends MessageListenerAdapter {\n\n @Override\n protected Object[] buildListenerArguments(Object extractedMessage, Channel channel, Message message) {\n return new Object[]{extractedMessage, channel, message};\n }\n\n}\n----\n\nNow you could configure `ExtendedListenerAdapter` as same as `MessageListenerAdapter` if you need to receive \"`channel`\" and \"`message`\".\nParameters of listener should be set as `buildListenerArguments(Object, Channel, Message)` returned, as the following example of listener shows:\n\n[source,java]\n----\npublic void handleMessage(Object object, Channel channel, Message message) throws IOException {\n ...\n}\n----\n\n[[container]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-consumer.adoc", "title": "async-consumer", "heading": "`MessageListenerAdapter`", "heading_level": 2, "file_order": 16, "section_index": 2, "content_hash": "c2f31aa3c8871f7571d998291e406cb450393f02fee15c3104af945037f73370", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-consumer.adoc"}}
{"id": "sha256:cc2203477c3c6919fba5f62865ed44a47d2f624aead14908460adedddccbff55", "content": "Now that you have seen the various options for the `Message`-listening callback, we can turn our attention to the container.\nBasically, the container handles the \"`active`\" responsibilities so that the listener callback can remain passive.\nThe container is an example of a \"`lifecycle`\" component.\nIt provides methods for starting and stopping.\nWhen configuring the container, you essentially bridge the gap between an AMQP Queue and the `MessageListener` instance.\nYou must provide a reference to the `ConnectionFactory` and the queue names or Queue instances from which that listener should consume messages.\n\nPrior to version 2.0, there was one listener container, the `SimpleMessageListenerContainer`.\nThere is now a second container, the `DirectMessageListenerContainer`.\nThe differences between the containers and criteria you might apply when choosing which to use are described in xref:amqp/receiving-messages/choose-container.adoc[Choosing a Container].\n\nThe following listing shows the most basic example, which works by using the, `SimpleMessageListenerContainer`:\n\n[source,java]\n----\nSimpleMessageListenerContainer container = new SimpleMessageListenerContainer();\ncontainer.setConnectionFactory(rabbitConnectionFactory);\ncontainer.setQueueNames(\"some.queue\");\ncontainer.setMessageListener(new MessageListenerAdapter(somePojo));\n----\n\nAs an \"`active`\" component, it is most common to create the listener container with a bean definition so that it can run in the background.\nThe following example shows one way to do so with XML:\n\n[source,xml]\n----\n<rabbit:listener-container connection-factory=\"rabbitConnectionFactory\">\n <rabbit:listener queues=\"some.queue\" ref=\"somePojo\" method=\"handle\"/>\n</rabbit:listener-container>\n----\n\nThe following listing shows another way to do so with XML:\n\n[source,xml]\n----\n<rabbit:listener-container connection-factory=\"rabbitConnectionFactory\" type=\"direct\">\n <rabbit:listener queues=\"some.queue\" ref=\"somePojo\" method=\"handle\"/>\n</rabbit:listener-container>\n----\n\nBoth of the preceding examples create a `DirectMessageListenerContainer` (notice the `type` attribute -- it defaults to `simple`).\n\nAlternately, you may prefer to use Java configuration, which looks similar to the preceding code snippet:\n\n[source,java]\n----\n@Configuration\npublic class ExampleAmqpConfiguration {\n\n @Bean\n public SimpleMessageListenerContainer messageListenerContainer() {\n SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();\n container.setConnectionFactory(rabbitConnectionFactory());\n container.setQueueName(\"some.queue\");\n container.setMessageListener(exampleListener());\n return container;\n }\n\n @Bean\n public CachingConnectionFactory rabbitConnectionFactory() {\n CachingConnectionFactory connectionFactory =\n new CachingConnectionFactory(\"localhost\");\n connectionFactory.setUsername(\"guest\");\n connectionFactory.setPassword(\"guest\");\n return connectionFactory;\n }\n\n @Bean\n public MessageListener exampleListener() {\n return new MessageListener() {\n public void onMessage(Message message) {\n System.out.println(\"received: \" + message);\n }\n };\n }\n}\n----\n\n[[consumer-priority]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-consumer.adoc", "title": "async-consumer", "heading": "Container", "heading_level": 2, "file_order": 16, "section_index": 3, "content_hash": "cc2203477c3c6919fba5f62865ed44a47d2f624aead14908460adedddccbff55", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-consumer.adoc"}}
{"id": "sha256:764e2b26c3e4cd81e598258501e37f3d00a8116c2dfc7ecda11d1b9562dce68f", "content": "Starting with RabbitMQ Version 3.2, the broker now supports consumer priority (see https://www.rabbitmq.com/blog/2013/12/16/using-consumer-priorities-with-rabbitmq/[Using Consumer Priorities with RabbitMQ]).\nThis is enabled by setting the `x-priority` argument on the consumer.\nThe `SimpleMessageListenerContainer` now supports setting consumer arguments, as the following example shows:\n\n[source,java]\n----\n\ncontainer.setConsumerArguments(Collections.\n<String, Object> singletonMap(\"x-priority\", Integer.valueOf(10)));\n----\n\nFor convenience, the namespace provides the `priority` attribute on the `listener` element, as the following example shows:\n\n[source,xml]\n----\n<rabbit:listener-container connection-factory=\"rabbitConnectionFactory\">\n <rabbit:listener queues=\"some.queue\" ref=\"somePojo\" method=\"handle\" priority=\"10\" />\n</rabbit:listener-container>\n----\n\nStarting with version 1.3, you can modify the queues on which the container listens at runtime.\nSee xref:amqp/listener-queues.adoc#listener-queues[Listener Container Queues].\n\n[[lc-auto-delete]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-consumer.adoc", "title": "async-consumer", "heading": "Consumer Priority", "heading_level": 2, "file_order": 16, "section_index": 4, "content_hash": "764e2b26c3e4cd81e598258501e37f3d00a8116c2dfc7ecda11d1b9562dce68f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-consumer.adoc"}}
{"id": "sha256:06736e6bb16b3cddaa8e7c142e129e959f3e9b67d2273bd467a0d2e4e995d4ca", "content": "When a container is configured to listen to `auto-delete` queues, the queue has an `x-expires` option, or the https://www.rabbitmq.com/ttl.html[Time-To-Live] policy is configured on the Broker, the queue is removed by the broker when the container is stopped (that is, when the last consumer is cancelled).\nBefore version 1.3, the container could not be restarted because the queue was missing.\nThe `RabbitAdmin` only automatically redeclares queues and so on when the connection is closed or when it opens, which does not happen when the container is stopped and started.\n\nStarting with version 1.3, the container uses a `RabbitAdmin` to redeclare any missing queues during startup.\n\nYou can also use conditional declaration (see xref:amqp/broker-configuration.adoc#conditional-declaration[Conditional Declaration]) together with an `auto-startup=\"false\"` admin to defer queue declaration until the container is started.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<rabbit:queue id=\"otherAnon\" declared-by=\"containerAdmin\" />\n\n<rabbit:direct-exchange name=\"otherExchange\" auto-delete=\"true\" declared-by=\"containerAdmin\">\n <rabbit:bindings>\n <rabbit:binding queue=\"otherAnon\" key=\"otherAnon\" />\n </rabbit:bindings>\n</rabbit:direct-exchange>\n\n<rabbit:listener-container id=\"container2\" auto-startup=\"false\">\n <rabbit:listener id=\"listener2\" ref=\"foo\" queues=\"otherAnon\" admin=\"containerAdmin\" />\n</rabbit:listener-container>\n\n<rabbit:admin id=\"containerAdmin\" connection-factory=\"rabbitConnectionFactory\"\n auto-startup=\"false\" />\n----\n\nIn this case, the queue and exchange are declared by `containerAdmin`, which has `auto-startup=\"false\"` so that the elements are not declared during context initialization.\nAlso, the container is not started for the same reason.\nWhen the container is later started, it uses its reference to `containerAdmin` to declare the elements.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-consumer.adoc", "title": "async-consumer", "heading": "`auto-delete` Queues", "heading_level": 2, "file_order": 16, "section_index": 5, "content_hash": "06736e6bb16b3cddaa8e7c142e129e959f3e9b67d2273bd467a0d2e4e995d4ca", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-consumer.adoc"}}
{"id": "sha256:503fd0e3c451b0311da5ca221d62e4c7effa21f56df861499c5b0872c3f08716", "content": "[[async-returns]]\n\n`@RabbitListener` (and `@RabbitHandler`) methods can be specified with asynchronous return types `CompletableFuture<?>` and `Mono<?>`, letting the reply be sent asynchronously.\n`ListenableFuture<?>` is no longer supported; it has been deprecated by Spring Framework.\n\nIMPORTANT: The listener container factory must be configured with `AcknowledgeMode.MANUAL` so that the consumer thread will not ack the message; instead, the asynchronous completion will ack or nack the message when the async operation completes.\nWhen the async result is completed with an error, whether the message is requeued or not depends on the exception type thrown, the container configuration, and the container error handler.\nBy default, the message will be requeued, unless the container's `defaultRequeueRejected` property is set to `false` (it is `true` by default).\nIf the async result is completed with an `AmqpRejectAndDontRequeueException`, the message will not be requeued.\nIf the container's `defaultRequeueRejected` property is `false`, you can override that by setting the future's exception to a `ImmediateRequeueException` and the message will be requeued.\nIf some exception occurs within the listener method that prevents creation of the async result object, you MUST catch that exception and return an appropriate return object that will cause the message to be acknowledged or requeued.\n\nStarting with versions 2.2.21, 2.3.13, 2.4.1, the `AcknowledgeMode` will be automatically set the `MANUAL` when async return types are detected.\nIn addition, incoming messages with fatal exceptions will be negatively acknowledged individually, previously any prior unacknowledged message were also negatively acknowledged.\n\nStarting with version 3.0.5, the `@RabbitListener` (and `@RabbitHandler`) methods can be marked with Kotlin `suspend` and the whole handling process and reply producing (optional) happens on respective Kotlin coroutine.\nAll the mentioned rules about `AcknowledgeMode.MANUAL` are still apply.\nThe `org.jetbrains.kotlinx:kotlinx-coroutines-reactor` dependency must be present in classpath to allow `suspend` function invocations.\n\nAlso starting with version 3.0.5, if a `RabbitListenerErrorHandler` is configured on a listener with an async return type (including Kotlin suspend functions), the error handler is invoked after a failure.\nSee xref:amqp/receiving-messages/async-annotation-driven/error-handling.adoc[Handling Exceptions] for more information about this error handler and its purpose.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/async-returns.adoc", "title": "async-returns", "heading": "async-returns", "heading_level": 1, "file_order": 17, "section_index": 0, "content_hash": "503fd0e3c451b0311da5ca221d62e4c7effa21f56df861499c5b0872c3f08716", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/async-returns.adoc"}}
{"id": "sha256:65e515437e67aef511d2ef850478dcd8642be3e3b2c4e5ce1c44c877678d0fe7", "content": "[[receiving-batch]]\n\nWhen receiving xref:amqp/sending-messages.adoc#template-batching[a batch] of messages, the de-batching is normally performed by the container, and the listener is invoked with one message at time.\nStarting with version 2.2, you can configure the listener container factory and listener to receive the entire batch in one call, simply set the factory's `batchListener` property, and make the method payload parameter a `List` or `Collection`:\n\n[source, java]\n----\n@Bean\npublic SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() {\n SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n factory.setConnectionFactory(connectionFactory());\n factory.setBatchListener(true);\n return factory;\n}\n\n@RabbitListener(queues = \"batch.1\")\npublic void listen1(List<Thing> in) {\n ...\n}\n\n@RabbitListener(queues = \"batch.2\")\npublic void listen2(List<Message<Thing>> in) {\n ...\n}\n----\n\nSetting the `batchListener` property to true automatically turns off the `deBatchingEnabled` container property in containers that the factory creates (unless `consumerBatchEnabled` is `true` - see below). Effectively, the debatching is moved from the container to the listener adapter and the adapter creates the list that is passed to the listener.\n\nA batch-enabled factory cannot be used with a xref:amqp/receiving-messages/async-annotation-driven/method-selection.adoc[multi-method listener].\n\nAlso starting with version 2.2. when receiving batched messages one-at-a-time, the last message contains a boolean header set to `true`.\nThis header can be obtained by adding the `@Header(AmqpHeaders.LAST_IN_BATCH)` boolean last` parameter to your listener method.\nThe header is mapped from `MessageProperties.isLastInBatch()`.\nIn addition, `AmqpHeaders.BATCH_SIZE` is populated with the size of the batch in every message fragment.\n\nIn addition, a new property `consumerBatchEnabled` has been added to the `SimpleMessageListenerContainer`.\nWhen this is true, the container will create a batch of messages, up to `batchSize`; a partial batch is delivered if `receiveTimeout` elapses with no new messages arriving.\nIf a producer-created batch is received, it is debatched and added to the consumer-side batch; therefore the actual number of messages delivered may exceed `batchSize`, which represents the number of messages received from the broker.\n`deBatchingEnabled` must be true when `consumerBatchEnabled` is true; the container factory will enforce this requirement.\n\n[source, java]\n----\n@Bean\npublic SimpleRabbitListenerContainerFactory consumerBatchContainerFactory() {\n SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n factory.setConnectionFactory(rabbitConnectionFactory());\n factory.setConsumerTagStrategy(consumerTagStrategy());\n factory.setBatchListener(true); // configures a BatchMessageListenerAdapter\n factory.setBatchSize(2);\n factory.setConsumerBatchEnabled(true);\n return factory;\n}\n----\n\nWhen using `consumerBatchEnabled` with `@RabbitListener`:\n\n[source, java]\n----\n@RabbitListener(queues = \"batch.1\", containerFactory = \"consumerBatchContainerFactory\")\npublic void consumerBatch1(List<Message> amqpMessages) {\n ...\n}\n\n@RabbitListener(queues = \"batch.2\", containerFactory = \"consumerBatchContainerFactory\")\npublic void consumerBatch2(List<org.springframework.messaging.Message<Invoice>> messages) {\n ...\n}\n\n@RabbitListener(queues = \"batch.3\", containerFactory = \"consumerBatchContainerFactory\")\npublic void consumerBatch3(List<Invoice> strings) {\n ...\n}\n----\n\n* the first is called with the raw, unconverted `org.springframework.amqp.core.Message` s received.\n* the second is called with the `org.springframework.messaging.Message<?>` s with converted payloads and mapped headers/properties.\n* the third is called with the converted payloads, with no access to headers/properties.\n\nYou can also add a `Channel` parameter, often used when using `MANUAL` ack mode.\nThis is not very useful with the third example because you don't have access to the `delivery_tag` property.\n\nSpring Boot provides a configuration property for `consumerBatchEnabled` and `batchSize`, but not for `batchListener`.\nStarting with version 3.0, setting `consumerBatchEnabled` to `true` on the container factory also sets `batchListener` to `true`.\nWhen `consumerBatchEnabled` is `true`, the listener **must** be a batch listener.\n\nStarting with version 3.0, listener methods can consume `Collection<?>` or `List<?>`.\n\nNOTE: The listener in batch mode does not support replies since there might not be a correlation between messages in the batch and single reply produced.\nThe xref:amqp/receiving-messages/async-returns.adoc[asynchronous return types] are still supported with batch listeners.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/batch.adoc", "title": "batch", "heading": "batch", "heading_level": 1, "file_order": 18, "section_index": 0, "content_hash": "65e515437e67aef511d2ef850478dcd8642be3e3b2c4e5ce1c44c877678d0fe7", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/batch.adoc"}}
{"id": "sha256:d63b592ea324aa8c817c2d08995b1868a7528e88a417bb5d1326e4e7850513b6", "content": "[[choose-container]]\n\nVersion 2.0 introduced the `DirectMessageListenerContainer` (DMLC).\nPreviously, only the `SimpleMessageListenerContainer` (SMLC) was available.\nThe SMLC uses an internal queue and a dedicated thread for each consumer.\nIf a container is configured to listen to multiple queues, the same consumer thread is used to process all the queues.\nConcurrency is controlled by `concurrentConsumers` and other properties.\nAs messages arrive from the RabbitMQ client, the client thread hands them off to the consumer thread through the queue.\nThis architecture was required because, in early versions of the RabbitMQ client, multiple concurrent deliveries were not possible.\nNewer versions of the client have a revised threading model and can now support concurrency.\nThis has allowed the introduction of the DMLC where the listener is now invoked directly on the RabbitMQ Client thread.\nIts architecture is, therefore, actually \"`simpler`\" than the SMLC.\nHowever, there are some limitations with this approach, and certain features of the SMLC are not available with the DMLC.\nAlso, concurrency is controlled by `consumersPerQueue` (and the client library's thread pool).\nThe `concurrentConsumers` and associated properties are not available with this container.\n\nThe following features are available with the SMLC but not the DMLC:\n\n* `batchSize`: With the SMLC, you can set this to control how many messages are delivered in a transaction or to reduce the number of acks, but it may cause the number of duplicate deliveries to increase after a failure.\n(The DMLC does have `messagesPerAck`, which you can use to reduce the acks, the same as with `batchSize` and the SMLC, but it cannot be used with transactions -- each message is delivered and ack'd in a separate transaction).\n* `consumerBatchEnabled`: enables batching of discrete messages in the consumer; see xref:amqp/containerAttributes.adoc[Message Listener Container Configuration] for more information.\n* `maxConcurrentConsumers` and consumer scaling intervals or triggers -- there is no auto-scaling in the DMLC.\nIt does, however, let you programmatically change the `consumersPerQueue` property and the consumers are adjusted accordingly.\n\nHowever, the DMLC has the following benefits over the SMLC:\n\n* Adding and removing queues at runtime is more efficient.\nWith the SMLC, the entire consumer thread is restarted (all consumers canceled and re-created).\nWith the DMLC, unaffected consumers are not canceled.\n* The context switch between the RabbitMQ Client thread and the consumer thread is avoided.\n* Threads are shared across consumers rather than having a dedicated thread for each consumer in the SMLC.\nHowever, see the IMPORTANT note about the connection factory configuration in xref:amqp/receiving-messages/threading.adoc[Threading and Asynchronous Consumers].\n\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration] for information about which configuration properties apply to each container.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/choose-container.adoc", "title": "choose-container", "heading": "choose-container", "heading_level": 1, "file_order": 19, "section_index": 0, "content_hash": "d63b592ea324aa8c817c2d08995b1868a7528e88a417bb5d1326e4e7850513b6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/choose-container.adoc"}}
{"id": "sha256:0a00a29669a83651f7152999bd9725f2c6482288ac210bb8f9738ac96dd9c4a7", "content": "[[consumer-events]]\n\nThe containers publish application events whenever a listener\n(consumer) experiences a failure of some kind.\nThe event `ListenerContainerConsumerFailedEvent` has the following properties:\n\n* `container`: The listener container where the consumer experienced the problem.\n* `reason`: A textual reason for the failure.\n* `fatal`: A boolean indicating whether the failure was fatal.\nWith non-fatal exceptions, the container tries to restart the consumer, according to the `recoveryInterval` or `recoveryBackoff` (for the `SimpleMessageListenerContainer`) or the `monitorInterval` (for the `DirectMessageListenerContainer`).\n* `throwable`: The `Throwable` that was caught.\n\nThese events can be consumed by implementing `ApplicationListener<ListenerContainerConsumerFailedEvent>`.\n\nNOTE: System-wide events (such as connection failures) are published by all consumers when `concurrentConsumers` is greater than 1.\n\nIf a consumer fails because one if its queues is being used exclusively, by default, as well as publishing the event, a `DEBUG` log is issued (since 3.1, previously WARN).\nTo change this logging behavior, provide a custom `ConditionalExceptionLogger` in the `AbstractMessageListenerContainer` instance's `exclusiveConsumerExceptionLogger` property.\nIn addition, the `SimpleMessageListenerContainer` consumer restart after such an exception is now logged at DEBUG level by default (previously INFO).\nA new method `logRestart()` has been added to the `ConditionalExceptionLogger` to allow this to be changed.\n\nAlso, the `AbstractMessageListenerContainer.DefaultExclusiveConsumerLogger` is now public, allowing it to be sub classed.\n\nSee also xref:amqp/connections.adoc#channel-close-logging[Logging Channel Close Events].\n\nFatal errors are always logged at the `ERROR` level.\nThis it not modifiable.\n\nSeveral other events are published at various stages of the container lifecycle:\n\n* `AsyncConsumerStartedEvent`: When the consumer is started.\n* `AsyncConsumerRestartedEvent`: When the consumer is restarted after a failure - `SimpleMessageListenerContainer` only.\n* `AsyncConsumerTerminatedEvent`: When a consumer is stopped normally.\n* `AsyncConsumerStoppedEvent`: When the consumer is stopped - `SimpleMessageListenerContainer` only.\n* `ConsumeOkEvent`: When a `consumeOk` is received from the broker, contains the queue name and `consumerTag`\n* `ListenerContainerIdleEvent`: See xref:amqp/receiving-messages/idle-containers.adoc[Detecting Idle Asynchronous Consumers].\n* `MissingQueueEvent`: When a missing queue is detected.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/consumer-events.adoc", "title": "consumer-events", "heading": "consumer-events", "heading_level": 1, "file_order": 20, "section_index": 0, "content_hash": "0a00a29669a83651f7152999bd9725f2c6482288ac210bb8f9738ac96dd9c4a7", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/consumer-events.adoc"}}
{"id": "sha256:4167a23c12c2b74312b829ca11c4d1545910dcad43e4e217e64deceb585669c6", "content": "[[consumerTags]]\n\nYou can provide a strategy to generate consumer tags.\nBy default, the consumer tag is generated by the broker.\nThe following listing shows the `ConsumerTagStrategy` interface definition:\n\n[source,java]\n----\npublic interface ConsumerTagStrategy {\n\n String createConsumerTag(String queue);\n\n}\n----\n\nThe queue is made available so that it can (optionally) be used in the tag.\n\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/consumerTags.adoc", "title": "consumerTags", "heading": "consumerTags", "heading_level": 1, "file_order": 21, "section_index": 0, "content_hash": "4167a23c12c2b74312b829ca11c4d1545910dcad43e4e217e64deceb585669c6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/consumerTags.adoc"}}
{"id": "sha256:78f6cc0c233709ad46cc419dc0568119b3e31547c6fa5cb4e4323ecec3b5af27", "content": "[[de-batching]]\n\nBatched messages (created by a producer) are automatically de-batched by listener containers (using the `springBatchFormat` message header).\nRejecting any message from a batch causes the entire batch to be rejected.\nSee xref:amqp/sending-messages.adoc#template-batching[Batching] for more information about batching.\n\nStarting with version 2.2, the `SimpleMessageListenerContainer` can be use to create batches on the consumer side (where the producer sent discrete messages).\n\nSet the container property `consumerBatchEnabled` to enable this feature.\n`deBatchingEnabled` must also be true so that the container is responsible for processing batches of both types.\nImplement `BatchMessageListener` or `ChannelAwareBatchMessageListener` when `consumerBatchEnabled` is true.\nStarting with version 2.2.7 both the `SimpleMessageListenerContainer` and `DirectMessageListenerContainer` can debatch xref:amqp/sending-messages.adoc#template-batching[producer created batches] as `List<Message>`.\nSee xref:amqp/receiving-messages/batch.adoc[@RabbitListener with Batching] for information about using this feature with `@RabbitListener`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/de-batching.adoc", "title": "de-batching", "heading": "de-batching", "heading_level": 1, "file_order": 22, "section_index": 0, "content_hash": "78f6cc0c233709ad46cc419dc0568119b3e31547c6fa5cb4e4323ecec3b5af27", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/de-batching.adoc"}}
{"id": "sha256:0aa5741bb6311f0d59be38fc33033eb9a7e112d85aa5d90d82fa0dafe614573d", "content": "[[idle-containers]]\n\nWhile efficient, one problem with asynchronous consumers is detecting when they are idle -- users might want to take\nsome action if no messages arrive for some period of time.\n\nStarting with version 1.6, it is now possible to configure the listener container to publish a\n`ListenerContainerIdleEvent` when some time passes with no message delivery.\nWhile the container is idle, an event is published every `idleEventInterval` milliseconds.\n\nTo configure this feature, set `idleEventInterval` on the container.\nThe following example shows how to do so in XML and in Java (for both a `SimpleMessageListenerContainer` and a `SimpleRabbitListenerContainerFactory`):\n\n[source, xml]\n----\n<rabbit:listener-container connection-factory=\"connectionFactory\"\n ...\n idle-event-interval=\"60000\"\n ...\n >\n <rabbit:listener id=\"container1\" queue-names=\"foo\" ref=\"myListener\" method=\"handle\" />\n</rabbit:listener-container>\n----\n\n[source, java]\n----\n@Bean\npublic SimpleMessageListenerContainer smlc(ConnectionFactory connectionFactory) {\n SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory);\n ...\n container.setIdleEventInterval(60000L);\n ...\n return container;\n}\n----\n\n[source, java]\n----\n@Bean\npublic SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() {\n SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n factory.setConnectionFactory(rabbitConnectionFactory());\n factory.setIdleEventInterval(60000L);\n ...\n return factory;\n}\n----\n\nIn each of these cases, an event is published once per minute while the container is idle.\n\n[[event-consumption]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/idle-containers.adoc", "title": "idle-containers", "heading": "idle-containers", "heading_level": 1, "file_order": 23, "section_index": 0, "content_hash": "0aa5741bb6311f0d59be38fc33033eb9a7e112d85aa5d90d82fa0dafe614573d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/idle-containers.adoc"}}
{"id": "sha256:8d3583103b76b1deb2414be1e37911ffa7af3a7effb6c0e722addd832d89312d", "content": "You can capture idle events by implementing `ApplicationListener` -- either a general listener, or one narrowed to only\nreceive this specific event.\nYou can also use `@EventListener`, introduced in Spring Framework 4.2.\n\nThe following example combines the `@RabbitListener` and `@EventListener` into a single class.\nYou need to understand that the application listener gets events for all containers, so you may need to\ncheck the listener ID if you want to take specific action based on which container is idle.\nYou can also use the `@EventListener` `condition` for this purpose.\n\nThe events have four properties:\n\n* `source`: The listener container instance\n* `id`: The listener ID (or container bean name)\n* `idleTime`: The time the container had been idle when the event was published\n* `queueNames`: The names of the queue(s) that the container listens to\n\nThe following example shows how to create listeners by using both the `@RabbitListener` and the `@EventListener` annotations:\n\n[source, Java]\n----\npublic class Listener {\n\n @RabbitListener(id=\"someId\", queues=\"#{queue.name}\")\n public String listen(String foo) {\n return foo.toUpperCase();\n }\n\n @EventListener(condition = \"event.listenerId == 'someId'\")\n public void onApplicationEvent(ListenerContainerIdleEvent event) {\n ...\n }\n\n}\n----\n\nIMPORTANT: Event listeners see events for all containers.\nConsequently, in the preceding example, we narrow the events received based on the listener ID.\n\nCAUTION: If you wish to use the idle event to stop the lister container, you should not call `container.stop()` on the thread that calls the listener.\nDoing so always causes delays and unnecessary log messages.\nInstead, you should hand off the event to a different thread that can then stop the container.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/idle-containers.adoc", "title": "idle-containers", "heading": "Event Consumption", "heading_level": 2, "file_order": 23, "section_index": 1, "content_hash": "8d3583103b76b1deb2414be1e37911ffa7af3a7effb6c0e722addd832d89312d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/idle-containers.adoc"}}
{"id": "sha256:059cc34ae045e3a49bed9a82ae4a3a05a7793bc0ecdede26aad537454e4d9a07", "content": "[[micrometer-observation]]\n\nUsing Micrometer for observation is now supported, since version 3.0, for the `RabbitTemplate` and listener containers.\n\nSet `observationEnabled` on each component to enable observation; this will disable xref:amqp/receiving-messages/micrometer.adoc[Micrometer Timers] because the timers will now be managed with each observation.\nWhen using annotated listeners, set `observationEnabled` on the container factory.\n\nRefer to {micrometer-tracing-docs}[Micrometer Tracing] for more information.\n\nTo add tags to timers/traces, configure a custom `RabbitTemplateObservationConvention` or `RabbitListenerObservationConvention` to the template or listener container, respectively.\n\nThe default implementations add the `name` tag for template observations and `listener.id` tag for containers.\n\nYou can either subclass `DefaultRabbitTemplateObservationConvention` or `DefaultRabbitListenerObservationConvention` or provide completely new implementations.\n\nSee xref:appendix/micrometer.adoc[Micrometer Observation Documentation] for more details.\n\nWARNING: Due to ambiguity in how traces should be handled in a batch, observations are *NOT* created for xref:amqp/receiving-messages/batch.adoc[Batch Listener Containers].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/micrometer-observation.adoc", "title": "micrometer-observation", "heading": "micrometer-observation", "heading_level": 1, "file_order": 24, "section_index": 0, "content_hash": "059cc34ae045e3a49bed9a82ae4a3a05a7793bc0ecdede26aad537454e4d9a07", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/micrometer-observation.adoc"}}
{"id": "sha256:de1157914eeb4280f03a649f79ec7ca99dde4c12a592dcfcdd3ed557dd743129", "content": "[[micrometer]]\n\nNOTE: This section documents the integration with {micrometer-docs}[Micrometer].\nFor integration with Micrometer Observation, see xref:amqp/receiving-messages/micrometer-observation.adoc[Micrometer Observation].\n\nStarting with version 2.2, the listener containers will automatically create and update Micrometer `Timer` s for the listener, if `Micrometer` is detected on the class path, and a single `MeterRegistry` is present in the application context (or exactly one is annotated `@Primary`, such as when using Spring Boot).\nThe timers can be disabled by setting the container property `micrometerEnabled` to `false`.\n\nTwo timers are maintained - one for successful calls to the listener and one for failures.\nWith a simple `MessageListener`, there is a pair of timers for each configured queue.\n\nThe timers are named `spring.rabbitmq.listener` and have the following tags:\n\n* `listenerId` : (listener id or container bean name)\n* `queue` : (the queue name for a simple listener or list of configured queue names when `consumerBatchEnabled` is `true` - because a batch may contain messages from multiple queues)\n* `result` : `success` or `failure`\n* `exception` : `none` or `ListenerExecutionFailedException`\n\nYou can add additional tags using the `micrometerTags` container property.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/micrometer.adoc", "title": "micrometer", "heading": "micrometer", "heading_level": 1, "file_order": 25, "section_index": 0, "content_hash": "de1157914eeb4280f03a649f79ec7ca99dde4c12a592dcfcdd3ed557dd743129", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/micrometer.adoc"}}
{"id": "sha256:a19f707fb08a74a28392f164d0cbff1aa6ee5f14939c2fded5176d3c99a82cd0", "content": "[[polling-consumer]]\n\nThe `AmqpTemplate` itself can be used for polled `Message` reception.\nBy default, if no message is available, `null` is returned immediately.\nThere is no blocking.\nStarting with version 1.5, you can set a `receiveTimeout`, in milliseconds, and the receive methods block for up to that long, waiting for a message.\nA value less than zero means block indefinitely (or at least until the connection to the broker is lost).\nVersion 1.6 introduced variants of the `receive` methods that allows the timeout be passed in on each call.\n\nCAUTION: Since the receive operation creates a new `QueueingConsumer` for each message, this technique is not really appropriate for high-volume environments.\nConsider using an asynchronous consumer or a `receiveTimeout` of zero for those use cases.\n\nStarting with version 2.4.8, when using a non-zero timeout, you can specify arguments passed into the `basicConsume` method used to associate the consumer with the channel.\nFor example: `template.addConsumerArg(\"x-priority\", 10)`.\n\nThere are four simple `receive` methods available.\nAs with the `Exchange` on the sending side, there is a method that requires that a default queue property has been set\ndirectly on the template itself, and there is a method that accepts a queue parameter at runtime.\nVersion 1.6 introduced variants to accept `timeoutMillis` to override `receiveTimeout` on a per-request basis.\nThe following listing shows the definitions of the four methods:\n\n[source,java]\n----\nMessage receive() throws AmqpException;\n\nMessage receive(String queueName) throws AmqpException;\n\nMessage receive(long timeoutMillis) throws AmqpException;\n\nMessage receive(String queueName, long timeoutMillis) throws AmqpException;\n----\n\nAs in the case of sending messages, the `AmqpTemplate` has some convenience methods for receiving POJOs instead of `Message` instances, and implementations provide a way to customize the `MessageConverter` used to create the `Object` returned:\nThe following listing shows those methods:\n\n[source,java]\n----\nObject receiveAndConvert() throws AmqpException;\n\nObject receiveAndConvert(String queueName) throws AmqpException;\n\nObject receiveAndConvert(long timeoutMillis) throws AmqpException;\n\nObject receiveAndConvert(String queueName, long timeoutMillis) throws AmqpException;\n----\n\nStarting with version 2.0, there are variants of these methods that take an additional `ParameterizedTypeReference` argument to convert complex types.\nThe template must be configured with a `SmartMessageConverter`.\nSee xref:amqp/message-converters.adoc#json-complex[Converting From a `Message` With `RabbitTemplate`] for more information.\n\nSimilar to `sendAndReceive` methods, beginning with version 1.3, the `AmqpTemplate` has several convenience `receiveAndReply` methods for synchronously receiving, processing and replying to messages.\nThe following listing shows those method definitions:\n\n[source,java]\n----\n<R, S> boolean receiveAndReply(ReceiveAndReplyCallback<R, S> callback)\n throws AmqpException;\n\n<R, S> boolean receiveAndReply(String queueName, ReceiveAndReplyCallback<R, S> callback)\n throws AmqpException;\n\n<R, S> boolean receiveAndReply(ReceiveAndReplyCallback<R, S> callback,\n String replyExchange, String replyRoutingKey) throws AmqpException;\n\n<R, S> boolean receiveAndReply(String queueName, ReceiveAndReplyCallback<R, S> callback,\n String replyExchange, String replyRoutingKey) throws AmqpException;\n\n<R, S> boolean receiveAndReply(ReceiveAndReplyCallback<R, S> callback,\n ReplyToAddressCallback<S> replyToAddressCallback) throws AmqpException;\n\n<R, S> boolean receiveAndReply(String queueName, ReceiveAndReplyCallback<R, S> callback,\n ReplyToAddressCallback<S> replyToAddressCallback) throws AmqpException;\n----\n\nThe `AmqpTemplate` implementation takes care of the `receive` and `reply` phases.\nIn most cases, you should provide only an implementation of `ReceiveAndReplyCallback` to perform some business logic for the received message and build a reply object or message, if needed.\nNote, a `ReceiveAndReplyCallback` may return `null`.\nIn this case, no reply is sent and `receiveAndReply` works like the `receive` method.\nThis lets the same queue be used for a mixture of messages, some of which may not need a reply.\n\nAutomatic message (request and reply) conversion is applied only if the provided callback is not an instance of `ReceiveAndReplyMessageCallback`, which provides a raw message exchange contract.\n\nThe `ReplyToAddressCallback` is useful for cases requiring custom logic to determine the `replyTo` address at runtime against the received message and reply from the `ReceiveAndReplyCallback`.\nBy default, `replyTo` information in the request message is used to route the reply.\n\nThe following listing shows an example of POJO-based receive and reply:\n\n[source,java]\n----\nboolean received =\n this.template.receiveAndReply(ROUTE, new ReceiveAndReplyCallback<Order, Invoice>() {\n\n public Invoice handle(Order order) {\n return processOrder(order);\n }\n });\nif (received) {\n log.info(\"We received an order!\");\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/polling-consumer.adoc", "title": "polling-consumer", "heading": "polling-consumer", "heading_level": 1, "file_order": 26, "section_index": 0, "content_hash": "a19f707fb08a74a28392f164d0cbff1aa6ee5f14939c2fded5176d3c99a82cd0", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/polling-consumer.adoc"}}
{"id": "sha256:0c0f8e6a245e1d8406a666d493ac714c6be01a3ac41a7a45f78a5a081f0141f6", "content": "[[threading]]\n\nA number of different threads are involved with asynchronous consumers.\n\nThreads from the `TaskExecutor` configured in the `SimpleMessageListenerContainer` are used to invoke the `MessageListener` when a new message is delivered by `RabbitMQ Client`.\nIf not configured, a `SimpleAsyncTaskExecutor` is used.\nIf you use a pooled executor, you need to ensure the pool size is sufficient to handle the configured concurrency.\nWith the `DirectMessageListenerContainer`, the `MessageListener` is invoked directly on a `RabbitMQ Client` thread.\nIn this case, the `taskExecutor` is used for the task that monitors the consumers.\n\nNOTE: When using the default `SimpleAsyncTaskExecutor`, for the threads the listener is invoked on, the listener container `beanName` is used in the `threadNamePrefix`.\nThis is useful for log analysis.\nWe generally recommend always including the thread name in the logging appender configuration.\nWhen a `TaskExecutor` is specifically provided through the `taskExecutor` property on the container, it is used as is, without modification.\nIt is recommended that you use a similar technique to name the threads created by a custom `TaskExecutor` bean definition, to aid with thread identification in log messages.\n\nThe `Executor` configured in the `CachingConnectionFactory` is passed into the `RabbitMQ Client` when creating the connection, and its threads are used to deliver new messages to the listener container.\nIf this is not configured, the client uses an internal thread pool executor with (at the time of writing) a pool size of `Runtime.getRuntime().availableProcessors() * 2` for each connection.\n\nIf you have a large number of factories or are using `CacheMode.CONNECTION`, you may wish to consider using a shared `ThreadPoolTaskExecutor` with enough threads to satisfy your workload.\n\nIMPORTANT: With the `DirectMessageListenerContainer`, you need to ensure that the connection factory is configured with a task executor that has sufficient threads to support your desired concurrency across all listener containers that use that factory.\nThe default pool size (at the time of writing) is `Runtime.getRuntime().availableProcessors() * 2`.\n\nThe `RabbitMQ client` uses a `ThreadFactory` to create threads for low-level I/O (socket) operations.\nTo modify this factory, you need to configure the underlying RabbitMQ `ConnectionFactory`, as discussed in xref:amqp/connections.adoc#connection-factory[Configuring the Underlying Client Connection Factory].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/threading.adoc", "title": "threading", "heading": "threading", "heading_level": 1, "file_order": 27, "section_index": 0, "content_hash": "0c0f8e6a245e1d8406a666d493ac714c6be01a3ac41a7a45f78a5a081f0141f6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/threading.adoc"}}
{"id": "sha256:c1612ad919e6879f260383bfdb6060c996b6750c4767fa989be655e99f4f9cf6", "content": "[[using-container-factories]]\n\nListener container factories were introduced to support the `@RabbitListener` and registering containers with the `RabbitListenerEndpointRegistry`, as discussed in xref:amqp/receiving-messages/async-annotation-driven/registration.adoc[Programmatic Endpoint Registration].\n\nStarting with version 2.1, they can be used to create any listener container -- even a container without a listener (such as for use in Spring Integration).\nOf course, a listener must be added before the container is started.\n\nThere are two ways to create such containers:\n\n* Use a SimpleRabbitListenerEndpoint\n* Add the listener after creation\n\nThe following example shows how to use a `SimpleRabbitListenerEndpoint` to create a listener container:\n\n[source, java]\n----\n@Bean\npublic SimpleMessageListenerContainer factoryCreatedContainerSimpleListener(\n SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory) {\n SimpleRabbitListenerEndpoint endpoint = new SimpleRabbitListenerEndpoint();\n endpoint.setQueueNames(\"queue.1\");\n endpoint.setMessageListener(message -> {\n ...\n });\n return rabbitListenerContainerFactory.createListenerContainer(endpoint);\n}\n----\n\nThe following example shows how to add the listener after creation:\n\n[source, java]\n----\n@Bean\npublic SimpleMessageListenerContainer factoryCreatedContainerNoListener(\n SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory) {\n SimpleMessageListenerContainer container = rabbitListenerContainerFactory.createListenerContainer();\n container.setMessageListener(message -> {\n ...\n });\n container.setQueueNames(\"test.no.listener.yet\");\n return container;\n}\n----\n\nIn either case, the listener can also be a `ChannelAwareMessageListener`, since it is now a sub-interface of `MessageListener`.\n\nThese techniques are useful if you wish to create several containers with similar properties or use a pre-configured container factory such as the one provided by Spring Boot auto configuration or both.\n\nIMPORTANT: Containers created this way are normal `@Bean` instances and are not registered in the `RabbitListenerEndpointRegistry`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages/using-container-factories.adoc", "title": "using-container-factories", "heading": "using-container-factories", "heading_level": 1, "file_order": 28, "section_index": 0, "content_hash": "c1612ad919e6879f260383bfdb6060c996b6750c4767fa989be655e99f4f9cf6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages/using-container-factories.adoc"}}
{"id": "sha256:9f294ad1202d39a13a159923fc8ff00806f537f20dd633dbb50fd55983d95830", "content": "[[amqp-abstractions]]\n\nSpring AMQP consists of two modules (each represented by a JAR in the distribution): `spring-amqp` and `spring-rabbit`.\nThe 'spring-amqp' module contains the `org.springframework.amqp.core` package.\nWithin that package, you can find the classes that represent the core AMQP \"`model`\".\nOur intention is to provide generic abstractions that do not rely on any particular AMQP broker implementation or client library.\nEnd user code can be more portable across vendor implementations as it can be developed against the abstraction layer only.\nThese abstractions are then implemented by broker-specific modules, such as 'spring-rabbit'.\nThere is currently only a RabbitMQ implementation.\nHowever, the abstractions have been validated in .NET using Apache Qpid in addition to RabbitMQ.\nSince AMQP operates at the protocol level, in principle, you can use the RabbitMQ client with any broker that supports the same protocol version, but we do not test any other brokers at present.\n\nThis overview assumes that you are already familiar with the basics of the AMQP specification.\nIf not, have a look at the resources listed in xref:resources.adoc[Other Resources]\n\n[[message]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/abstractions.adoc", "title": "abstractions", "heading": "abstractions", "heading_level": 1, "file_order": 29, "section_index": 0, "content_hash": "9f294ad1202d39a13a159923fc8ff00806f537f20dd633dbb50fd55983d95830", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/abstractions.adoc"}}
{"id": "sha256:143949e0d09c5b98d165eb4239764af0b188de30cb51a636d72bd4fc45e90c29", "content": "The 0-9-1 AMQP specification does not define a `Message` class or interface.\nInstead, when performing an operation such as `basicPublish()`, the content is passed as a byte-array argument and additional properties are passed in as separate arguments.\nSpring AMQP defines a `Message` class as part of a more general AMQP domain model representation.\nThe purpose of the `Message` class is to encapsulate the body and properties within a single instance so that the API can, in turn, be simpler.\nThe following example shows the `Message` class definition:\n\n[source,java]\n----\npublic class Message {\n\n private final MessageProperties messageProperties;\n\n private final byte[] body;\n\n public Message(byte[] body, MessageProperties messageProperties) {\n this.body = body;\n this.messageProperties = messageProperties;\n }\n\n public byte[] getBody() {\n return this.body;\n }\n\n public MessageProperties getMessageProperties() {\n return this.messageProperties;\n }\n}\n----\n\nThe `MessageProperties` interface defines several common properties, such as 'messageId', 'timestamp', 'contentType', and several more.\nYou can also extend those properties with user-defined 'headers' by calling the `setHeader(String key, Object value)` method.\n\nIMPORTANT: Starting with versions `1.5.7`, `1.6.11`, `1.7.4`, and `2.0.0`, if a message body is a serialized `Serializable` java object, it is no longer deserialized (by default) when performing `toString()` operations (such as in log messages).\nThis is to prevent unsafe deserialization.\nBy default, only `java.util` and `java.lang` classes are deserialized.\nTo revert to the previous behavior, you can add allowable class/package patterns by invoking `Message.addAllowedListPatterns(...)`.\nA simple `\\*` wildcard is supported, for example `com.something.*, *.MyClass`.\nBodies that cannot be deserialized are represented by `byte[<size>]` in log messages.\n\n[[exchange]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/abstractions.adoc", "title": "abstractions", "heading": "`Message`", "heading_level": 2, "file_order": 29, "section_index": 1, "content_hash": "143949e0d09c5b98d165eb4239764af0b188de30cb51a636d72bd4fc45e90c29", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/abstractions.adoc"}}
{"id": "sha256:2dbcf0310384e19fdcc6b6f054aca70894363c42338f1d63cc30aedcd9ab1180", "content": "The `Exchange` interface represents an AMQP Exchange, which is what a Message Producer sends to.\nEach Exchange within a virtual host of a broker has a unique name as well as a few other properties.\nThe following example shows the `Exchange` interface:\n\n[source,java]\n----\npublic interface Exchange extends Declarable {\n\n String getName();\n\n String getType();\n\n boolean isDurable();\n\n boolean isAutoDelete();\n\n Map<String, Object> getArguments();\n\n}\n----\n\nAs you can see, an `Exchange` also has a 'type' represented by constants defined in `ExchangeTypes`.\nThe basic types are: `direct`, `topic`, `fanout`, and `headers`.\nIn the core package, you can find implementations of the `Exchange` interface for each of those types.\nThe behavior varies across these `Exchange` types in terms of how they handle bindings to queues.\nFor example, a `Direct` exchange lets a queue be bound by a fixed routing key (often the queue's name).\nA `Topic` exchange supports bindings with routing patterns that may include the '*' and '#' wildcards for 'exactly-one' and 'zero-or-more', respectively.\nThe `Fanout` exchange publishes to all queues that are bound to it without taking any routing key into consideration.\nFor much more information about these and the other Exchange types, see https://www.rabbitmq.com/tutorials/amqp-concepts#exchanges[AMQP Exchanges].\n\nStarting with version 3.2, the `ConsistentHashExchange` type has been introduced for convenience during application configuration phase.\nIt provided options like `x-consistent-hash` for an exchange type.\nAllows to configure `hash-header` or `hash-property` exchange definition argument.\nThe respective RabbitMQ `rabbitmq_consistent_hash_exchange` plugin has to be enabled on the broker.\nMore information about the purpose, logic and behavior of the Consistent Hash Exchange are in the official RabbitMQ {rabbitmq-server-github}/rabbitmq_consistent_hash_exchange[documentation].\n\nNOTE: The AMQP specification also requires that any broker provide a \"`default`\" direct exchange that has no name.\nAll queues that are declared are bound to that default `Exchange` with their names as routing keys.\nYou can learn more about the default Exchange's usage within Spring AMQP in xref:amqp/template.adoc[`AmqpTemplate`].\n\n[[queue]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/abstractions.adoc", "title": "abstractions", "heading": "Exchange", "heading_level": 2, "file_order": 29, "section_index": 2, "content_hash": "2dbcf0310384e19fdcc6b6f054aca70894363c42338f1d63cc30aedcd9ab1180", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/abstractions.adoc"}}
{"id": "sha256:0fbcbea1b0f879a14d10ed94fb2883692a75b0f72671a38b1439be81994cbe53", "content": "The `Queue` class represents the component from which a message consumer receives messages.\nLike the various `Exchange` classes, our implementation is intended to be an abstract representation of this core AMQP type.\nThe following listing shows the `Queue` class:\n\n[source,java]\n----\npublic class Queue {\n\n private final String name;\n\n private final boolean durable;\n\n private final boolean exclusive;\n\n private final boolean autoDelete;\n\n /**\n * The queue is durable, non-exclusive and non auto-delete.\n *\n * @param name the name of the queue.\n */\n public Queue(String name) {\n this(name, true, false, false);\n }\n\n // Getters and Setters omitted for brevity\n\n}\n----\n\nNotice that the constructor takes the queue name.\nDepending on the implementation, the admin template may provide methods for generating a uniquely named queue.\nSuch queues can be useful as a \"`reply-to`\" address or in other *temporary* situations.\nFor that reason, the 'exclusive' and 'autoDelete' properties of an auto-generated queue would both be set to 'true'.\n\nNOTE: See the section on queues in xref:amqp/broker-configuration.adoc[Configuring the Broker] for information about declaring queues by using namespace support, including queue arguments.\n\n[[binding]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/abstractions.adoc", "title": "abstractions", "heading": "Queue", "heading_level": 2, "file_order": 29, "section_index": 3, "content_hash": "0fbcbea1b0f879a14d10ed94fb2883692a75b0f72671a38b1439be81994cbe53", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/abstractions.adoc"}}
{"id": "sha256:e0416b19f2c072ac6121d14b085571d092a7b5e8f005186a04c41d8a35dc31dc", "content": "Given that a producer sends to an exchange and a consumer receives from a queue, the bindings that connect queues to exchanges are critical for connecting those producers and consumers via messaging.\nIn Spring AMQP, we define a `Binding` class to represent those connections.\nThis section reviews the basic options for binding queues to exchanges.\n\nWe provide a `BindingBuilder` to facilitate a \"fluent API\" style, as the following example shows:\n\n[source,java]\n----\nQueue queue = ...;\nBinding directBinding = BindingBuilder.bind(queue).to(new DirectExchange(\"someDirectExchange\")).with(\"foo.bar\");\nBinding topicBinding = BindingBuilder.bind(queue).to(new TopicExchange(\"someTopicExchange\")).with(\"foo.*\");\nBinding fanoutBinding = BindingBuilder.bind(queue).to(new FanoutExchange(\"someFanoutExchange\"));\n----\n\nNOTE: For clarity, the preceding example shows the `BindingBuilder` class, but this style works well when using a static import for the 'bind()' method.\n\nBy itself, an instance of the `Binding` class only holds the data about a connection.\nIn other words, it is not an \"`active`\" component.\nHowever, as you will see later in xref:amqp/broker-configuration.adoc[Configuring the Broker], the `AmqpAdmin` class can use `Binding` instances to actually trigger the binding actions on the broker.\nAlso, as you can see in that same section, you can define the `Binding` instances by using Spring's `@Bean` annotations within `@Configuration` classes.\nThere is also a convenient base class that further simplifies that approach for generating AMQP-related bean definitions and recognizes the queues, exchanges, and bindings so that they are all declared on the AMQP broker upon application startup.\n\nThe `AmqpTemplate` is also defined within the core package.\nAs one of the main components involved in actual AMQP messaging, it is discussed in detail in its own section (see xref:amqp/template.adoc[`AmqpTemplate`]).", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/abstractions.adoc", "title": "abstractions", "heading": "Binding", "heading_level": 2, "file_order": 29, "section_index": 4, "content_hash": "e0416b19f2c072ac6121d14b085571d092a7b5e8f005186a04c41d8a35dc31dc", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/abstractions.adoc"}}
{"id": "sha256:bc50fe681c77a2ccf53b762cd3c9e1cfb355f1db08c897801b0ad0bfb3681284", "content": "[[broker-configuration]]\n\nThe AMQP specification describes how the protocol can be used to configure queues, exchanges, and bindings on the broker.\nThese operations (which are portable from the 0.8 specification and higher) are present in the `AmqpAdmin` interface in the `org.springframework.amqp.core` package.\nThe RabbitMQ implementation of that class is `RabbitAdmin` located in the `org.springframework.amqp.rabbit.core` package.\n\nThe `AmqpAdmin` interface is based on using the Spring AMQP domain abstractions and is shown in the following listing:\n\n[source,java]\n----\npublic interface AmqpAdmin {\n\n // Exchange Operations\n\n void declareExchange(Exchange exchange);\n\n void deleteExchange(String exchangeName);\n\n // Queue Operations\n\n Queue declareQueue();\n\n String declareQueue(Queue queue);\n\n boolean deleteQueue(String queueName);\n\n void deleteQueue(String queueName, boolean unused, boolean empty);\n\n void purgeQueue(String queueName, boolean noWait);\n\n // Binding Operations\n\n void declareBinding(Binding binding);\n\n void removeBinding(Binding binding);\n\n Properties getQueueProperties(String queueName);\n\n QueueInformation getQueueInfo(String queueName);\n\n}\n----\n\nSee also xref:amqp/template.adoc#scoped-operations[Scoped Operations].\n\nThe `getQueueProperties()` method returns some limited information about the queue (message count and consumer count).\nThe keys for the properties returned are available as constants in the `RabbitAdmin` (`QUEUE_NAME`,\n`QUEUE_MESSAGE_COUNT`, and `QUEUE_CONSUMER_COUNT`).\nThe `getQueueInfo()` returns a convenient `QueueInformation` data object.\n\nThe no-arg `declareQueue()` method defines a queue on the broker with a name that is automatically generated.\nThe additional properties of this auto-generated queue are `exclusive=true`, `autoDelete=true`, and `durable=false`.\n\nThe `declareQueue(Queue queue)` method takes a `Queue` object and returns the name of the declared queue.\nIf the `name` property of the provided `Queue` is an empty `String`, the broker declares the queue with a generated name.\nThat name is returned to the caller.\nThat name is also added to the `actualName` property of the `Queue`.\nYou can use this functionality programmatically only by invoking the `RabbitAdmin` directly.\nWhen using auto-declaration by the admin when defining a queue declaratively in the application context, you can set the name property to `\"\"` (the empty string).\nThe broker then creates the name.\nStarting with version 2.1, listener containers can use queues of this type.\nSee xref:amqp/containers-and-broker-named-queues.adoc[Containers and Broker-Named queues] for more information.\n\nThis is in contrast to an `AnonymousQueue` where the framework generates a unique (`UUID`) name and sets `durable` to\n`false` and `exclusive`, `autoDelete` to `true`.\nA `<rabbit:queue/>` with an empty (or missing) `name` attribute always creates an `AnonymousQueue`.\n\nSee xref:amqp/broker-configuration.adoc#anonymous-queue[`AnonymousQueue`] to understand why `AnonymousQueue` is preferred over broker-generated queue names as well as\nhow to control the format of the name.\nStarting with version 2.1, anonymous queues are declared with argument `Queue.X_QUEUE_LEADER_LOCATOR` set to `client-local` by default.\nThis ensures that the queue is declared on the node to which the application is connected.\nDeclarative queues must have fixed names because they might be referenced elsewhere in the context -- such as in the\nlistener shown in the following example:\n\n[source,xml]\n----\n<rabbit:listener-container>\n <rabbit:listener ref=\"listener\" queue-names=\"#{someQueue.name}\" />\n</rabbit:listener-container>\n----\n\nSee xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#automatic-declaration[Automatic Declaration of Exchanges, Queues, and Bindings].\n\nThe RabbitMQ implementation of this interface is `RabbitAdmin`, which, when configured by using Spring XML, resembles the following example:\n\n[source,xml]\n----\n<rabbit:connection-factory id=\"connectionFactory\"/>\n\n<rabbit:admin id=\"amqpAdmin\" connection-factory=\"connectionFactory\"/>\n----\n\nWhen the `CachingConnectionFactory` cache mode is `CHANNEL` (the default), the `RabbitAdmin` implementation does automatic lazy declaration of queues, exchanges, and bindings declared in the same `ApplicationContext`.\nThese components are declared as soon as a `Connection` is opened to the broker.\nThere are some namespace features that make this very convenient -- for example,\nin the Stocks sample application, we have the following:\n\n[source,xml]\n----\n<rabbit:queue id=\"tradeQueue\"/>\n\n<rabbit:queue id=\"marketDataQueue\"/>\n\n<fanout-exchange name=\"broadcast.responses\"\n xmlns=\"http://www.springframework.org/schema/rabbit\">\n <bindings>\n <binding queue=\"tradeQueue\"/>\n </bindings>\n</fanout-exchange>\n\n<topic-exchange name=\"app.stock.marketdata\"\n xmlns=\"http://www.springframework.org/schema/rabbit\">\n <bindings>\n <binding queue=\"marketDataQueue\" pattern=\"${stocks.quote.pattern}\"/>\n </bindings>\n</topic-exchange>\n----\n\nIn the preceding example, we use anonymous queues (actually, internally, just queues with names generated by the framework, not by the broker) and refer to them by ID.\nWe can also declare queues with explicit names, which also serve as identifiers for their bean definitions in the context.\nThe following example configures a queue with an explicit name:\n\n[source,xml]\n----\n<rabbit:queue name=\"stocks.trade.queue\"/>\n----\n\nTIP: You can provide both `id` and `name` attributes.\nThis lets you refer to the queue (for example, in a binding) by an ID that is independent of the queue name.\nIt also allows standard Spring features (such as property placeholders and SpEL expressions for the queue name).\nThese features are not available when you use the name as the bean identifier.\n\nQueues can be configured with additional arguments -- for example, `x-message-ttl`.\nWhen you use the namespace support, they are provided in the form of a `Map` of argument-name/argument-value pairs, which are defined by using the `<rabbit:queue-arguments>` element.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<rabbit:queue name=\"withArguments\">\n <rabbit:queue-arguments>\n <entry key=\"x-dead-letter-exchange\" value=\"myDLX\"/>\n <entry key=\"x-dead-letter-routing-key\" value=\"dlqRK\"/>\n </rabbit:queue-arguments>\n</rabbit:queue>\n----\n\nBy default, the arguments are assumed to be strings.\nFor arguments of other types, you must provide the type.\nThe following example shows how to specify the type:\n\n[source,xml]\n----\n<rabbit:queue name=\"withArguments\">\n <rabbit:queue-arguments value-type=\"java.lang.Long\">\n <entry key=\"x-message-ttl\" value=\"100\"/>\n </rabbit:queue-arguments>\n</rabbit:queue>\n----\n\nWhen providing arguments of mixed types, you must provide the type for each entry element.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<rabbit:queue name=\"withArguments\">\n <rabbit:queue-arguments>\n <entry key=\"x-message-ttl\">\n <value type=\"java.lang.Long\">100</value>\n </entry>\n <entry key=\"x-dead-letter-exchange\" value=\"myDLX\"/>\n <entry key=\"x-dead-letter-routing-key\" value=\"dlqRK\"/>\n </rabbit:queue-arguments>\n</rabbit:queue>\n----\n\nWith Spring Framework 3.2 and later, this can be declared a little more succinctly, as follows:\n\n[source,xml]\n----\n<rabbit:queue name=\"withArguments\">\n <rabbit:queue-arguments>\n <entry key=\"x-message-ttl\" value=\"100\" value-type=\"java.lang.Long\"/>\n <entry key=\"x-ha-policy\" value=\"all\"/>\n </rabbit:queue-arguments>\n</rabbit:queue>\n----\n\nWhen you use Java configuration, the `Queue.X_QUEUE_LEADER_LOCATOR` argument is supported as a first class property through the `setLeaderLocator()` method on the `Queue` class.\nStarting with version 2.1, anonymous queues are declared with this property set to `client-local` by default.\nThis ensures that the queue is declared on the node the application is connected to.\n\nIMPORTANT: The RabbitMQ broker does not allow declaration of a queue with mismatched arguments.\nFor example, if a `queue` already exists with no `time to live` argument, and you attempt to declare it with (for example) `key=\"x-message-ttl\" value=\"100\"`, an exception is thrown.\n\nBy default, the `RabbitAdmin` immediately stops processing all declarations when any exception occurs.\nThis could cause downstream issues, such as a listener container failing to initialize because another queue (defined after the one in error) is not declared.\n\nThis behavior can be modified by setting the `ignore-declaration-exceptions` attribute to `true` on the `RabbitAdmin` instance.\nThis option instructs the `RabbitAdmin` to log the exception and continue declaring other elements.\nWhen configuring the `RabbitAdmin` using Java, this property is called `ignoreDeclarationExceptions`.\nThis is a global setting that applies to all elements.\nQueues, exchanges, and bindings have a similar property that applies to just those elements.\n\nPrior to version 1.6, this property took effect only if an `IOException` occurred on the channel, such as when there is a mismatch between current and desired properties.\nNow, this property takes effect on any exception, including `TimeoutException` and others.\n\nIn addition, any declaration exceptions result in the publishing of a `DeclarationExceptionEvent`, which is an `ApplicationEvent` that can be consumed by any `ApplicationListener` in the context.\nThe event contains a reference to the admin, the element that was being declared, and the `Throwable`.\n\n[[headers-exchange]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/broker-configuration.adoc", "title": "broker-configuration", "heading": "broker-configuration", "heading_level": 1, "file_order": 30, "section_index": 0, "content_hash": "bc50fe681c77a2ccf53b762cd3c9e1cfb355f1db08c897801b0ad0bfb3681284", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/broker-configuration.adoc"}}
{"id": "sha256:51c7eb827fec9ccc730f1e90f2d42f6d37221374fbe269e90cacf0d76391ca1f", "content": "Starting with version 1.3, you can configure the `HeadersExchange` to match on multiple headers.\nYou can also specify whether any or all headers must match.\nThe following example shows how to do so:\n\n[source,xml]\n----\n<rabbit:headers-exchange name=\"headers-test\">\n <rabbit:bindings>\n <rabbit:binding queue=\"bucket\">\n <rabbit:binding-arguments>\n <entry key=\"foo\" value=\"bar\"/>\n <entry key=\"baz\" value=\"qux\"/>\n <entry key=\"x-match\" value=\"all\"/>\n </rabbit:binding-arguments>\n </rabbit:binding>\n </rabbit:bindings>\n</rabbit:headers-exchange>\n----\n\nStarting with version 1.6, you can configure `Exchanges` with an `internal` flag (defaults to `false`) and such an\n`Exchange` is properly configured on the Broker through a `RabbitAdmin` (if one is present in the application context).\nIf the `internal` flag is `true` for an exchange, RabbitMQ does not let clients use the exchange.\nThis is useful for a dead letter exchange or exchange-to-exchange binding, where you do not wish the exchange to be used\ndirectly by publishers.\n\nTo see how to use Java to configure the AMQP infrastructure, look at the Stock sample application,\nwhere there is the `@Configuration` class `AbstractStockRabbitConfiguration`, which ,in turn has\n`RabbitClientConfiguration` and `RabbitServerConfiguration` subclasses.\nThe following listing shows the code for `AbstractStockRabbitConfiguration`:\n\n[source,java]\n----\n@Configuration\npublic abstract class AbstractStockAppRabbitConfiguration {\n\n @Bean\n public CachingConnectionFactory connectionFactory() {\n CachingConnectionFactory connectionFactory =\n new CachingConnectionFactory(\"localhost\");\n connectionFactory.setUsername(\"guest\");\n connectionFactory.setPassword(\"guest\");\n return connectionFactory;\n }\n\n @Bean\n public RabbitTemplate rabbitTemplate() {\n RabbitTemplate template = new RabbitTemplate(connectionFactory());\n template.setMessageConverter(jsonMessageConverter());\n configureRabbitTemplate(template);\n return template;\n }\n\n @Bean\n public Jackson2JsonMessageConverter jsonMessageConverter() {\n return new Jackson2JsonMessageConverter();\n }\n\n @Bean\n public TopicExchange marketDataExchange() {\n return new TopicExchange(\"app.stock.marketdata\");\n }\n\n // additional code omitted for brevity\n\n}\n----\n\nIn the Stock application, the server is configured by using the following `@Configuration` class:\n\n[source,java]\n----\n@Configuration\npublic class RabbitServerConfiguration extends AbstractStockAppRabbitConfiguration {\n\n @Bean\n public Queue stockRequestQueue() {\n return new Queue(\"app.stock.request\");\n }\n}\n----\n\nThis is the end of the whole inheritance chain of `@Configuration` classes.\nThe end result is that `TopicExchange` and `Queue` are declared to the broker upon application startup.\nThere is no binding of `TopicExchange` to a queue in the server configuration, as that is done in the client application.\nThe stock request queue, however, is automatically bound to the AMQP default exchange.\nThis behavior is defined by the specification.\n\nThe client `@Configuration` class is a little more interesting.\nIts declaration follows:\n\n[source,java]\n----\n@Configuration\npublic class RabbitClientConfiguration extends AbstractStockAppRabbitConfiguration {\n\n @Value(\"${stocks.quote.pattern}\")\n private String marketDataRoutingKey;\n\n @Bean\n public Queue marketDataQueue() {\n return amqpAdmin().declareQueue();\n }\n\n /**\n * Binds to the market data exchange.\n * Interested in any stock quotes\n * that match its routing key.\n */\n @Bean\n public Binding marketDataBinding() {\n return BindingBuilder.bind(\n marketDataQueue()).to(marketDataExchange()).with(marketDataRoutingKey);\n }\n\n // additional code omitted for brevity\n\n}\n----\n\nThe client declares another queue through the `declareQueue()` method on the `AmqpAdmin`.\nIt binds that queue to the market data exchange with a routing pattern that is externalized in a properties file.\n\n[[builder-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/broker-configuration.adoc", "title": "broker-configuration", "heading": "Headers Exchange", "heading_level": 2, "file_order": 30, "section_index": 1, "content_hash": "51c7eb827fec9ccc730f1e90f2d42f6d37221374fbe269e90cacf0d76391ca1f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/broker-configuration.adoc"}}
{"id": "sha256:1c6ddc3209b1ccbead2b051245ee19080d70e0e15f8d88023bd9bc98af1cf072", "content": "Version 1.6 introduces a convenient fluent API for configuring `Queue` and `Exchange` objects when using Java configuration.\nThe following example shows how to use it:\n\n[source, java]\n----\n@Bean\npublic Queue queue() {\n return QueueBuilder.nonDurable(\"foo\")\n .autoDelete()\n .exclusive()\n .withArgument(\"foo\", \"bar\")\n .build();\n}\n\n@Bean\npublic Exchange exchange() {\n return ExchangeBuilder.directExchange(\"foo\")\n .autoDelete()\n .internal()\n .withArgument(\"foo\", \"bar\")\n .build();\n}\n----\n\nSee the Javadoc for javadoc:org.springframework.amqp.core.QueueBuilder[`org.springframework.amqp.core.QueueBuilder`] and javadoc:org.springframework.amqp.core.ExchangeBuilder[`org.springframework.amqp.core.ExchangeBuilder`] for more information.\n\nStarting with version 2.0, the `ExchangeBuilder` now creates durable exchanges by default, to be consistent with the simple constructors on the individual `AbstractExchange` classes.\nTo make a non-durable exchange with the builder, use `.durable(false)` before invoking `.build()`.\nThe `durable()` method with no parameter is no longer provided.\n\nVersion 2.2 introduced fluent APIs to add \"well known\" exchange and queue arguments...\n\n[source, java]\n----\n@Bean\npublic Queue allArgs1() {\n return QueueBuilder.nonDurable(\"all.args.1\")\n .ttl(1000)\n .expires(200_000)\n .maxLength(42)\n .maxLengthBytes(10_000)\n .overflow(Overflow.rejectPublish)\n .deadLetterExchange(\"dlx\")\n .deadLetterRoutingKey(\"dlrk\")\n .maxPriority(4)\n .lazy()\n .leaderLocator(LeaderLocator.minLeaders)\n .singleActiveConsumer()\n .build();\n}\n\n@Bean\npublic DirectExchange ex() {\n return ExchangeBuilder.directExchange(\"ex.with.alternate\")\n .durable(true)\n .alternate(\"alternate\")\n .build();\n}\n----\n\n[[collection-declaration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/broker-configuration.adoc", "title": "broker-configuration", "heading": "Builder API for Queues and Exchanges", "heading_level": 2, "file_order": 30, "section_index": 2, "content_hash": "1c6ddc3209b1ccbead2b051245ee19080d70e0e15f8d88023bd9bc98af1cf072", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/broker-configuration.adoc"}}
{"id": "sha256:8d9f7c7a6badc30a3b1d6fe25f8086bf769c483a511e61e265e6a7553eb24297", "content": "You can wrap collections of `Declarable` objects (`Queue`, `Exchange`, and `Binding`) in `Declarables` objects.\nThe `RabbitAdmin` detects such beans (as well as discrete `Declarable` beans) in the application context, and declares the contained objects on the broker whenever a connection is established (initially and after a connection failure).\nThe following example shows how to do so:\n\n[source, java]\n----\n@Configuration\npublic static class Config {\n\n @Bean\n public CachingConnectionFactory cf() {\n return new CachingConnectionFactory(\"localhost\");\n }\n\n @Bean\n public RabbitAdmin admin(ConnectionFactory cf) {\n return new RabbitAdmin(cf);\n }\n\n @Bean\n public DirectExchange e1() {\n return new DirectExchange(\"e1\", false, true);\n }\n\n @Bean\n public Queue q1() {\n return new Queue(\"q1\", false, false, true);\n }\n\n @Bean\n public Binding b1() {\n return BindingBuilder.bind(q1()).to(e1()).with(\"k1\");\n }\n\n @Bean\n public Declarables es() {\n return new Declarables(\n new DirectExchange(\"e2\", false, true),\n new DirectExchange(\"e3\", false, true));\n }\n\n @Bean\n public Declarables qs() {\n return new Declarables(\n new Queue(\"q2\", false, false, true),\n new Queue(\"q3\", false, false, true));\n }\n\n @Bean\n @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n public Declarables prototypes() {\n return new Declarables(new Queue(this.prototypeQueueName, false, false, true));\n }\n\n @Bean\n public Declarables bs() {\n return new Declarables(\n new Binding(\"q2\", DestinationType.QUEUE, \"e2\", \"k2\", null),\n new Binding(\"q3\", DestinationType.QUEUE, \"e3\", \"k3\", null));\n }\n\n @Bean\n public Declarables ds() {\n return new Declarables(\n new DirectExchange(\"e4\", false, true),\n new Queue(\"q4\", false, false, true),\n new Binding(\"q4\", DestinationType.QUEUE, \"e4\", \"k4\", null));\n }\n\n}\n----\n\nIMPORTANT: In versions prior to 2.1, you could declare multiple `Declarable` instances by defining beans of type `Collection<Declarable>`.\nThis can cause undesirable side effects in some cases, because the admin has to iterate over all `Collection<?>` beans.\n\nVersion 2.2 added the `getDeclarablesByType` method to `Declarables`; this can be used as a convenience, for example, when declaring the listener container bean(s).\n\n[source, java]\n----\npublic SimpleMessageListenerContainer container(ConnectionFactory connectionFactory,\n Declarables mixedDeclarables, MessageListener listener) {\n\n SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory);\n container.setQueues(mixedDeclarables.getDeclarablesByType(Queue.class).toArray(new Queue[0]));\n container.setMessageListener(listener);\n return container;\n}\n----\n\n[[conditional-declaration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/broker-configuration.adoc", "title": "broker-configuration", "heading": "Declaring Collections of Exchanges, Queues, and Bindings", "heading_level": 2, "file_order": 30, "section_index": 3, "content_hash": "8d9f7c7a6badc30a3b1d6fe25f8086bf769c483a511e61e265e6a7553eb24297", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/broker-configuration.adoc"}}
{"id": "sha256:e83ae5327535af778cc022b90f8489f004ee39b86e20c6f85e469eacfa1ec86c", "content": "By default, all queues, exchanges, and bindings are declared by all `RabbitAdmin` instances (assuming they have `auto-startup=\"true\"`) in the application context.\n\nStarting with version 2.1.9, the `RabbitAdmin` has a new property `explicitDeclarationsOnly` (which is `false` by default); when this is set to `true`, the admin will only declare beans that are explicitly configured to be declared by that admin.\n\nNOTE: Starting with the 1.2 release, you can conditionally declare these elements.\nThis is particularly useful when an application connects to multiple brokers and needs to specify with which brokers a particular element should be declared.\n\nThe classes representing these elements implement `Declarable`, which has two methods: `shouldDeclare()` and `getDeclaringAdmins()`.\nThe `RabbitAdmin` uses these methods to determine whether a particular instance should actually process the declarations on its `Connection`.\n\nThe properties are available as attributes in the namespace, as shown in the following examples:\n\n[source,xml]\n----\n<rabbit:admin id=\"admin1\" connection-factory=\"CF1\" />\n\n<rabbit:admin id=\"admin2\" connection-factory=\"CF2\" />\n\n<rabbit:admin id=\"admin3\" connection-factory=\"CF3\" explicit-declarations-only=\"true\" />\n\n<rabbit:queue id=\"declaredByAdmin1AndAdmin2Implicitly\" />\n\n<rabbit:queue id=\"declaredByAdmin1AndAdmin2\" declared-by=\"admin1, admin2\" />\n\n<rabbit:queue id=\"declaredByAdmin1Only\" declared-by=\"admin1\" />\n\n<rabbit:queue id=\"notDeclaredByAllExceptAdmin3\" auto-declare=\"false\" />\n\n<rabbit:direct-exchange name=\"direct\" declared-by=\"admin1, admin2\">\n <rabbit:bindings>\n <rabbit:binding key=\"foo\" queue=\"bar\"/>\n </rabbit:bindings>\n</rabbit:direct-exchange>\n----\n\nNOTE: By default, the `auto-declare` attribute is `true` and, if the `declared-by` is not supplied (or is empty), then all `RabbitAdmin` instances declare the object (as long as the admin's `auto-startup` attribute is `true`, the default, and the admin's `explicit-declarations-only` attribute is false).\n\nSimilarly, you can use Java-based `@Configuration` to achieve the same effect.\nIn the following example, the components are declared by `admin1` but not by `admin2`:\n\n[source,java]\n----\n@Bean\npublic RabbitAdmin admin1() {\n return new RabbitAdmin(cf1());\n}\n\n@Bean\npublic RabbitAdmin admin2() {\n return new RabbitAdmin(cf2());\n}\n\n@Bean\npublic Queue queue() {\n Queue queue = new Queue(\"foo\");\n queue.setAdminsThatShouldDeclare(admin1());\n return queue;\n}\n\n@Bean\npublic Exchange exchange() {\n DirectExchange exchange = new DirectExchange(\"bar\");\n exchange.setAdminsThatShouldDeclare(admin1());\n return exchange;\n}\n\n@Bean\npublic Binding binding() {\n Binding binding = new Binding(\"foo\", DestinationType.QUEUE, exchange().getName(), \"foo\", null);\n binding.setAdminsThatShouldDeclare(admin1());\n return binding;\n}\n----\n\n[[note-id-name]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/broker-configuration.adoc", "title": "broker-configuration", "heading": "Conditional Declaration", "heading_level": 2, "file_order": 30, "section_index": 4, "content_hash": "e83ae5327535af778cc022b90f8489f004ee39b86e20c6f85e469eacfa1ec86c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/broker-configuration.adoc"}}
{"id": "sha256:9f378fe746007cb4756a1433122fc75b27b159ddaa25cc911e19e14c57109106", "content": "The `name` attribute on `<rabbit:queue/>` and `<rabbit:exchange/>` elements reflects the name of the entity in the broker.\nFor queues, if the `name` is omitted, an anonymous queue is created (see xref:amqp/broker-configuration.adoc#anonymous-queue[`AnonymousQueue`]).\n\nIn versions prior to 2.0, the `name` was also registered as a bean name alias (similar to `name` on `<bean/>` elements).\n\nThis caused two problems:\n\n* It prevented the declaration of a queue and exchange with the same name.\n* The alias was not resolved if it contained a SpEL expression (`#{...}`).\n\nStarting with version 2.0, if you declare one of these elements with both an `id` _and_ a `name` attribute, the name is no longer declared as a bean name alias.\nIf you wish to declare a queue and exchange with the same `name`, you must provide an `id`.\n\nThere is no change if the element has only a `name` attribute.\nThe bean can still be referenced by the `name` -- for example, in binding declarations.\nHowever, you still cannot reference it if the name contains SpEL -- you must provide an `id` for reference purposes.\n\n[[anonymous-queue]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/broker-configuration.adoc", "title": "broker-configuration", "heading": "A Note On the `id` and `name` Attributes", "heading_level": 2, "file_order": 30, "section_index": 5, "content_hash": "9f378fe746007cb4756a1433122fc75b27b159ddaa25cc911e19e14c57109106", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/broker-configuration.adoc"}}
{"id": "sha256:15600d7d8c561e58d611121798758a67bf5416f44284e31a4467ccc44c13f6ba", "content": "In general, when you need a uniquely-named, exclusive, auto-delete queue, we recommend that you use the `AnonymousQueue`\ninstead of broker-defined queue names (using `\"\"` as a `Queue` name causes the broker to generate the queue\nname).\n\nThis is because:\n\n. The queues are actually declared when the connection to the broker is established.\nThis is long after the beans are created and wired together.\nBeans that use the queue need to know its name.\nIn fact, the broker might not even be running when the application is started.\n. If the connection to the broker is lost for some reason, the admin re-declares the `AnonymousQueue` with the same name.\nIf we used broker-declared queues, the queue name would change.\n\nYou can control the format of the queue name used by `AnonymousQueue` instances.\n\nBy default, the queue name is prefixed by `spring.gen-` followed by a base64 representation of the `UUID` -- for example: `spring.gen-MRBv9sqISkuCiPfOYfpo4g`.\n\nYou can provide an `AnonymousQueue.NamingStrategy` implementation in a constructor argument.\nThe following example shows how to do so:\n\n[source, java]\n----\n@Bean\npublic Queue anon1() {\n return new AnonymousQueue();\n}\n\n@Bean\npublic Queue anon2() {\n return new AnonymousQueue(new AnonymousQueue.Base64UrlNamingStrategy(\"something-\"));\n}\n\n@Bean\npublic Queue anon3() {\n return new AnonymousQueue(AnonymousQueue.UUIDNamingStrategy.DEFAULT);\n}\n----\n\nThe first bean generates a queue name prefixed by `spring.gen-` followed by a base64 representation of the `UUID` -- for\nexample: `spring.gen-MRBv9sqISkuCiPfOYfpo4g`.\nThe second bean generates a queue name prefixed by `something-` followed by a base64 representation of the `UUID`.\nThe third bean generates a name by using only the UUID (no base64 conversion) -- for example, `f20c818a-006b-4416-bf91-643590fedb0e`.\n\nThe base64 encoding uses the \"`URL and Filename Safe Alphabet`\" from RFC 4648.\nTrailing padding characters (`=`) are removed.\n\nYou can provide your own naming strategy, whereby you can include other information (such as the application name or client host) in the queue name.\n\nYou can specify the naming strategy when you use XML configuration.\nThe `naming-strategy` attribute is present on the `<rabbit:queue>` element\nfor a bean reference that implements `AnonymousQueue.NamingStrategy`.\nThe following examples show how to specify the naming strategy in various ways:\n\n[source, xml]\n----\n<rabbit:queue id=\"uuidAnon\" />\n\n<rabbit:queue id=\"springAnon\" naming-strategy=\"uuidNamer\" />\n\n<rabbit:queue id=\"customAnon\" naming-strategy=\"customNamer\" />\n\n<bean id=\"uuidNamer\" class=\"org.springframework.amqp.core.AnonymousQueue.UUIDNamingStrategy\" />\n\n<bean id=\"customNamer\" class=\"org.springframework.amqp.core.AnonymousQueue.Base64UrlNamingStrategy\">\n <constructor-arg value=\"custom.gen-\" />\n</bean>\n----\n\nThe first example creates names such as `spring.gen-MRBv9sqISkuCiPfOYfpo4g`.\nThe second example creates names with a String representation of a UUID.\nThe third example creates names such as `custom.gen-MRBv9sqISkuCiPfOYfpo4g`.\n\nYou can also provide your own naming strategy bean.\n\nStarting with version 2.1, anonymous queues are declared with argument `Queue.X_QUEUE_LEADER_LOCATOR` set to `client-local` by default.\nThis ensures that the queue is declared on the node to which the application is connected.\nYou can revert to the previous behavior by calling `queue.setLeaderLocator(null)` after constructing the instance.\n\n[[declarable-recovery]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/broker-configuration.adoc", "title": "broker-configuration", "heading": "`AnonymousQueue`", "heading_level": 2, "file_order": 30, "section_index": 6, "content_hash": "15600d7d8c561e58d611121798758a67bf5416f44284e31a4467ccc44c13f6ba", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/broker-configuration.adoc"}}
{"id": "sha256:29af8d7f5592887f8e8070c14d4f5bee0b35d8cbdfeaf951da8b66d84c085ff5", "content": "Normally, the `RabbitAdmin` (s) only recover queues/exchanges/bindings that are declared as beans in the application context; if any such declarations are auto-delete, they will be removed by the broker if the connection is lost.\nWhen the connection is re-established, the admin will redeclare the entities.\nNormally, entities created by calling `admin.declareQueue(...)`, `admin.declareExchange(...)` and `admin.declareBinding(...)` will not be recovered.\n\nStarting with version 2.4, the admin has a new property `redeclareManualDeclarations`; when `true`, the admin will recover these entities in addition to the beans in the application context.\n\nRecovery of individual declarations will not be performed if `deleteQueue(...)`, `deleteExchange(...)` or `removeBinding(...)` is called.\nAssociated bindings are removed from the recoverable entities when queues and exchanges are deleted.\n\nFinally, calling `resetAllManualDeclarations()` will prevent the recovery of any previously declared entities.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/broker-configuration.adoc", "title": "broker-configuration", "heading": "Recovering Auto-Delete Declarations", "heading_level": 2, "file_order": 30, "section_index": 7, "content_hash": "29af8d7f5592887f8e8070c14d4f5bee0b35d8cbdfeaf951da8b66d84c085ff5", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/broker-configuration.adoc"}}
{"id": "sha256:f3e24f11ddb4d3efbe3b3cc1fd3f20ab4b929d550b425e21d8f70cebe5b3af1b", "content": "[[broker-events]]\n\nWhen the https://www.rabbitmq.com/event-exchange.html[Event Exchange Plugin] is enabled, if you add a bean of type `BrokerEventListener` to the application context, it publishes selected broker events as `BrokerEvent` instances, which can be consumed with a normal Spring `ApplicationListener` or `@EventListener` method.\nEvents are published by the broker to a topic exchange `amq.rabbitmq.event` with a different routing key for each event type.\nThe listener uses event keys, which are used to bind an `AnonymousQueue` to the exchange so the listener receives only selected events.\nSince it is a topic exchange, wildcards can be used (as well as explicitly requesting specific events), as the following example shows:\n\n[source, java]\n----\n@Bean\npublic BrokerEventListener eventListener() {\n return new BrokerEventListener(connectionFactory(), \"user.deleted\", \"channel.#\", \"queue.#\");\n}\n----\n\nYou can further narrow the received events in individual event listeners, by using normal Spring techniques, as the following example shows:\n\n[source, java]\n----\n@EventListener(condition = \"event.eventType == 'queue.created'\")\npublic void listener(BrokerEvent event) {\n ...\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/broker-events.adoc", "title": "broker-events", "heading": "broker-events", "heading_level": 1, "file_order": 31, "section_index": 0, "content_hash": "f3e24f11ddb4d3efbe3b3cc1fd3f20ab4b929d550b425e21d8f70cebe5b3af1b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/broker-events.adoc"}}
{"id": "sha256:f99aada1e12d0263ccc56474de28e447539b9c1409900f071abd566d92f47226", "content": "[[connections]]\n\nWhereas the AMQP model we described in the previous section is generic and applicable to all implementations, when we get into the management of resources, the details are specific to the broker implementation.\nTherefore, in this section, we focus on code that exists only within our \"`spring-rabbit`\" module since, at this point, RabbitMQ is the only supported implementation.\n\nThe central component for managing a connection to the RabbitMQ broker is the `ConnectionFactory` interface.\nThe responsibility of a `ConnectionFactory` implementation is to provide an instance of `org.springframework.amqp.rabbit.connection.Connection`, which is a wrapper for `com.rabbitmq.client.Connection`.\n\n[[choosing-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "connections", "heading_level": 1, "file_order": 32, "section_index": 0, "content_hash": "f99aada1e12d0263ccc56474de28e447539b9c1409900f071abd566d92f47226", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:e8624fa139af28b286d0d97fead4a8e409de1bb7f01ee7944dacaa01974ba000", "content": "There are three connection factories to chose from\n\n* `PooledChannelConnectionFactory`\n* `ThreadChannelConnectionFactory`\n* `CachingConnectionFactory`\n\nThe first two were added in version 2.3.\n\nFor most use cases, the `CachingConnectionFactory` should be used.\nThe `ThreadChannelConnectionFactory` can be used if you want to ensure strict message ordering without the need to use xref:amqp/template.adoc#scoped-operations[Scoped Operations].\nThe `PooledChannelConnectionFactory` is similar to the `CachingConnectionFactory` in that it uses a single connection and a pool of channels.\nIt's implementation is simpler but it doesn't support correlated publisher confirmations.\n\nSimple publisher confirmations are supported by all three factories.\n\nWhen configuring a `RabbitTemplate` to use a xref:amqp/template.adoc#separate-connection[separate connection], you can now, starting with version 2.3.2, configure the publishing connection factory to be a different type.\nBy default, the publishing factory is the same type and any properties set on the main factory are also propagated to the publishing factory.\n\nStarting with version 3.1, the `AbstractConnectionFactory` includes the `connectionCreatingBackOff` property, which supports a backoff policy in the connection module.\nCurrently, there is support in the behavior of `createChannel()` to handle exceptions that occur when the `channelMax` limit is reached, implementing a backoff strategy based on attempts and intervals.\n\n[[pooledchannelconnectionfactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "Choosing a Connection Factory", "heading_level": 2, "file_order": 32, "section_index": 1, "content_hash": "e8624fa139af28b286d0d97fead4a8e409de1bb7f01ee7944dacaa01974ba000", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:b11d02575cc604f14056629ff9efb41d23a4e3ea2bee09e54320eafe18d55f30", "content": "This factory manages a single connection and two pools of channels, based on the Apache Pool2.\nOne pool is for transactional channels, the other is for non-transactional channels.\nThe pools are `GenericObjectPool` s with default configuration; a callback is provided to configure the pools; refer to the Apache documentation for more information.\n\nThe Apache `commons-pool2` jar must be on the class path to use this factory.\n\n[source, java]\n----\n@Bean\nPooledChannelConnectionFactory pcf() throws Exception {\n ConnectionFactory rabbitConnectionFactory = new ConnectionFactory();\n rabbitConnectionFactory.setHost(\"localhost\");\n PooledChannelConnectionFactory pcf = new PooledChannelConnectionFactory(rabbitConnectionFactory);\n pcf.setPoolConfigurer((pool, tx) -> {\n if (tx) {\n // configure the transactional pool\n }\n else {\n // configure the non-transactional pool\n }\n });\n return pcf;\n}\n----\n\n[[threadchannelconnectionfactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "`PooledChannelConnectionFactory`", "heading_level": 3, "file_order": 32, "section_index": 2, "content_hash": "b11d02575cc604f14056629ff9efb41d23a4e3ea2bee09e54320eafe18d55f30", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:24884831085b503288c0336c95441beab52ef6c05d63d21fda16154df6e223ed", "content": "This factory manages a single connection and two `ThreadLocal` s, one for transactional channels, the other for non-transactional channels.\nThis factory ensures that all operations on the same thread use the same channel (as long as it remains open).\nThis facilitates strict message ordering without the need for xref:amqp/template.adoc#scoped-operations[Scoped Operations].\nTo avoid memory leaks, if your application uses many short-lived threads, you must call the factory's `closeThreadChannel()` to release the channel resource.\nStarting with version 2.3.7, a thread can transfer its channel(s) to another thread.\nSee xref:amqp/template.adoc#multi-strict[Strict Message Ordering in a Multi-Threaded Environment] for more information.\n\n[[cachingconnectionfactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "`ThreadChannelConnectionFactory`", "heading_level": 3, "file_order": 32, "section_index": 3, "content_hash": "24884831085b503288c0336c95441beab52ef6c05d63d21fda16154df6e223ed", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:00c3c5083ebc27ab85071ad207806e15e7d1e99c5bf26f9cf01f53c611f0f904", "content": "The third implementation provided is the `CachingConnectionFactory`, which, by default, establishes a single connection proxy that can be shared by the application.\nSharing of the connection is possible since the \"`unit of work`\" for messaging with AMQP is actually a \"`channel`\" (in some ways, this is similar to the relationship between a connection and a session in JMS).\nThe connection instance provides a `createChannel` method.\nThe `CachingConnectionFactory` implementation supports caching of those channels, and it maintains separate caches for channels based on whether they are transactional.\nWhen creating an instance of `CachingConnectionFactory`, you can provide the 'hostname' through the constructor.\nYou should also provide the 'username' and 'password' properties.\nTo configure the size of the channel cache (the default is 25), you can call the\n`setChannelCacheSize()` method.\n\nStarting with version 1.3, you can configure the `CachingConnectionFactory` to cache connections as well as only channels.\nIn this case, each call to `createConnection()` creates a new connection (or retrieves an idle one from the cache).\nClosing a connection returns it to the cache (if the cache size has not been reached).\nChannels created on such connections are also cached.\nThe use of separate connections might be useful in some environments, such as consuming from an HA cluster, in\nconjunction with a load balancer, to connect to different cluster members, and others.\nTo cache connections, set the `cacheMode` to `CacheMode.CONNECTION`.\n\nNOTE: This does not limit the number of connections.\nRather, it specifies how many idle open connections are allowed.\n\nStarting with version 1.5.5, a new property called `connectionLimit` is provided.\nWhen this property is set, it limits the total number of connections allowed.\nWhen set, if the limit is reached, the `channelCheckoutTimeLimit` is used to wait for a connection to become idle.\nIf the time is exceeded, an `AmqpTimeoutException` is thrown.\n\n[IMPORTANT]\n======\nWhen the cache mode is `CONNECTION`, automatic declaration of queues and others\n(See xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#automatic-declaration[Automatic Declaration of Exchanges, Queues, and Bindings]) is NOT supported.\n\nAlso, at the time of this writing, the `amqp-client` library by default creates a fixed thread pool for each connection (default size: `Runtime.getRuntime().availableProcessors() * 2` threads).\nWhen using a large number of connections, you should consider setting a custom `executor` on the `CachingConnectionFactory`.\nThen, the same executor can be used by all connections and its threads can be shared.\nThe executor's thread pool should be unbounded or set appropriately for the expected use (usually, at least one thread per connection).\nIf multiple channels are created on each connection, the pool size affects the concurrency, so a variable (or simple cached) thread pool executor would be most suitable.\n======\n\nIt is important to understand that the cache size is (by default) not a limit but is merely the number of channels that can be cached.\nWith a cache size of, say, 10, any number of channels can actually be in use.\nIf more than 10 channels are being used and they are all returned to the cache, 10 go in the cache.\nThe remainder are physically closed.\n\nStarting with version 1.6, the default channel cache size has been increased from 1 to 25.\nIn high volume, multi-threaded environments, a small cache means that channels are created and closed at a high rate.\nIncreasing the default cache size can avoid this overhead.\nYou should monitor the channels in use through the RabbitMQ Admin UI and consider increasing the cache size further if you\nsee many channels being created and closed.\nThe cache grows only on-demand (to suit the concurrency requirements of the application), so this change does not\nimpact existing low-volume applications.\n\nStarting with version 1.4.2, the `CachingConnectionFactory` has a property called `channelCheckoutTimeout`.\nWhen this property is greater than zero, the `channelCacheSize` becomes a limit on the number of channels that can be created on a connection.\nIf the limit is reached, calling threads block until a channel is available or this timeout is reached, in which case a `AmqpTimeoutException` is thrown.\n\nWARNING: Channels used within the framework (for example,\n`RabbitTemplate`) are reliably returned to the cache.\nIf you create channels outside of the framework, (for example,\nby accessing the connections directly and invoking `createChannel()`), you must return them (by closing) reliably, perhaps in a `finally` block, to avoid running out of channels.\n\nThe following example shows how to create a new `connection`:\n\n[source,java]\n----\nCachingConnectionFactory connectionFactory = new CachingConnectionFactory(\"somehost\");\nconnectionFactory.setUsername(\"guest\");\nconnectionFactory.setPassword(\"guest\");\n\nConnection connection = connectionFactory.createConnection();\n----\n\nWhen using XML, the configuration might look like the following example:\n\n[source,xml]\n----\n<bean id=\"connectionFactory\"\n class=\"org.springframework.amqp.rabbit.connection.CachingConnectionFactory\">\n <constructor-arg value=\"somehost\"/>\n <property name=\"username\" value=\"guest\"/>\n <property name=\"password\" value=\"guest\"/>\n</bean>\n----\n\nNOTE: There is also a `SingleConnectionFactory` implementation that is available only in the unit test code of the framework.\nIt is simpler than `CachingConnectionFactory`, since it does not cache channels, but it is not intended for practical usage outside of simple tests due to its lack of performance and resilience.\nIf you need to implement your own `ConnectionFactory` for some reason, the `AbstractConnectionFactory` base class may provide a nice starting point.\n\nA `ConnectionFactory` can be created quickly and conveniently by using the rabbit namespace, as follows:\n\n[source,xml]\n----\n<rabbit:connection-factory id=\"connectionFactory\"/>\n----\n\nIn most cases, this approach is preferable, since the framework can choose the best defaults for you.\nThe created instance is a `CachingConnectionFactory`.\nKeep in mind that the default cache size for channels is 25.\nIf you want more channels to be cached, set a larger value by setting the 'channelCacheSize' property.\nIn XML it would look like as follows:\n\n[source,xml]\n----\n<bean id=\"connectionFactory\"\n class=\"org.springframework.amqp.rabbit.connection.CachingConnectionFactory\">\n <constructor-arg value=\"somehost\"/>\n <property name=\"username\" value=\"guest\"/>\n <property name=\"password\" value=\"guest\"/>\n <property name=\"channelCacheSize\" value=\"50\"/>\n</bean>\n----\n\nAlso, with the namespace, you can add the 'channel-cache-size' attribute, as follows:\n\n[source,xml]\n----\n<rabbit:connection-factory\n id=\"connectionFactory\" channel-cache-size=\"50\"/>\n----\n\nThe default cache mode is `CHANNEL`, but you can configure it to cache connections instead.\nIn the following example, we use `connection-cache-size`:\n\n[source,xml]\n----\n<rabbit:connection-factory\n id=\"connectionFactory\" cache-mode=\"CONNECTION\" connection-cache-size=\"25\"/>\n----\n\nYou can provide host and port attributes by using the namespace, as follows:\n\n[source,xml]\n----\n<rabbit:connection-factory\n id=\"connectionFactory\" host=\"somehost\" port=\"5672\"/>\n----\n\nAlternatively, if running in a clustered environment, you can use the addresses attribute, as follows:\n\n[source,xml]\n----\n<rabbit:connection-factory\n id=\"connectionFactory\" addresses=\"host1:5672,host2:5672\" address-shuffle-mode=\"RANDOM\"/>\n----\n\nSee xref:amqp/connections.adoc#cluster[Connecting to a Cluster] for information about `address-shuffle-mode`.\n\nThe following example with a custom thread factory that prefixes thread names with `rabbitmq-`:\n\n[source, xml]\n----\n<rabbit:connection-factory id=\"multiHost\" virtual-host=\"/bar\" addresses=\"host1:1234,host2,host3:4567\"\n thread-factory=\"tf\"\n channel-cache-size=\"10\" username=\"user\" password=\"password\" />\n\n<bean id=\"tf\" class=\"org.springframework.scheduling.concurrent.CustomizableThreadFactory\">\n <constructor-arg value=\"rabbitmq-\" />\n</bean>\n\n----\n\n[[addressresolver]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "`CachingConnectionFactory`", "heading_level": 3, "file_order": 32, "section_index": 4, "content_hash": "00c3c5083ebc27ab85071ad207806e15e7d1e99c5bf26f9cf01f53c611f0f904", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:6b74766cd96086c4bca62f722c66ab3989adef94293351fe65031840a508fc6b", "content": "Starting with version 2.1.15, you can now use an `AddressResolver` to resolve the connection address(es).\nThis will override any settings of the `addresses` and `host/port` properties.\n\n[[naming-connections]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "AddressResolver", "heading_level": 2, "file_order": 32, "section_index": 5, "content_hash": "6b74766cd96086c4bca62f722c66ab3989adef94293351fe65031840a508fc6b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:dc6b08c16fa6092bebeaeb40c4a1a7c50da40f0ed94d79e9d9f77a2de2d8e88a", "content": "Starting with version 1.7, a `ConnectionNameStrategy` is provided for the injection into the `AbstractionConnectionFactory`.\nThe generated name is used for the application-specific identification of the target RabbitMQ connection.\nThe connection name is displayed in the management UI if the RabbitMQ server supports it.\nThis value does not have to be unique and cannot be used as a connection identifier -- for example, in HTTP API requests.\nThis value is supposed to be human-readable and is a part of `ClientProperties` under the `connection_name` key.\nYou can use a simple Lambda, as follows:\n\n[source, java]\n----\nconnectionFactory.setConnectionNameStrategy(connectionFactory -> \"MY_CONNECTION\");\n----\n\nThe `ConnectionFactory` argument can be used to distinguish target connection names by some logic.\nBy default, the `beanName` of the `AbstractConnectionFactory`, a hex string representing the object, and an internal counter are used to generate the `connection_name`.\nThe `<rabbit:connection-factory>` namespace component is also supplied with the `connection-name-strategy` attribute.\n\nAn implementation of `SimplePropertyValueConnectionNameStrategy` sets the connection name to an application property.\nYou can declare it as a `@Bean` and inject it into the connection factory, as the following example shows:\n\n[source, java]\n----\n@Bean\npublic SimplePropertyValueConnectionNameStrategy cns() {\n return new SimplePropertyValueConnectionNameStrategy(\"spring.application.name\");\n}\n\n@Bean\npublic ConnectionFactory rabbitConnectionFactory(ConnectionNameStrategy cns) {\n CachingConnectionFactory connectionFactory = new CachingConnectionFactory();\n ...\n connectionFactory.setConnectionNameStrategy(cns);\n return connectionFactory;\n}\n----\n\nThe property must exist in the application context's `Environment`.\n\nNOTE: When using Spring Boot and its autoconfigured connection factory, you need only declare the `ConnectionNameStrategy` `@Bean`.\nSpring Boot auto-detects the bean and wires it into the factory.\n\n[[blocked-connections-and-resource-constraints]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "Naming Connections", "heading_level": 2, "file_order": 32, "section_index": 6, "content_hash": "dc6b08c16fa6092bebeaeb40c4a1a7c50da40f0ed94d79e9d9f77a2de2d8e88a", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:9fea74ea8f0ac2b05c5e80686465ef2dae625169c0d3b7ab4595d30664f4bac4", "content": "The connection might be blocked for interaction from the broker that corresponds to the https://www.rabbitmq.com/memory.html[Memory Alarm].\nStarting with version 2.0, the `org.springframework.amqp.rabbit.connection.Connection` can be supplied with `com.rabbitmq.client.BlockedListener` instances to be notified for connection blocked and unblocked events.\nIn addition, the `AbstractConnectionFactory` emits a `ConnectionBlockedEvent` and `ConnectionUnblockedEvent`, respectively, through its internal `BlockedListener` implementation.\nThese let you provide application logic to react appropriately to problems on the broker and (for example) take some corrective actions.\n\nIMPORTANT: When the application is configured with a single `CachingConnectionFactory`, as it is by default with Spring Boot auto-configuration, the application stops working when the connection is blocked by the Broker.\nAnd when it is blocked by the Broker, any of its clients stop to work.\nIf we have producers and consumers in the same application, we may end up with a deadlock when producers are blocking the connection (because there are no resources on the Broker any more) and consumers cannot free them (because the connection is blocked).\nTo mitigate the problem, we suggest having one more separate `CachingConnectionFactory` instance with the same options -- one for producers and one for consumers.\nA separate `CachingConnectionFactory` is not possible for transactional producers that execute on a consumer thread, since they should reuse the `Channel` associated with the consumer transactions.\n\nStarting with version 2.0.2, the `RabbitTemplate` has a configuration option to automatically use a second connection factory, unless transactions are being used.\nSee xref:amqp/template.adoc#separate-connection[Using a Separate Connection] for more information.\nThe `ConnectionNameStrategy` for the publisher connection is the same as the primary strategy with `.publisher` appended to the result of calling the method.\n\nStarting with version 1.7.7, an `AmqpResourceNotAvailableException` is provided, which is thrown when `SimpleConnection.createChannel()` cannot create a `Channel` (for example, because the `channelMax` limit is reached and there are no available channels in the cache).\nYou can use this exception in the `RetryPolicy` to recover the operation after some back-off.\n\n[[connection-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "Blocked Connections and Resource Constraints", "heading_level": 2, "file_order": 32, "section_index": 7, "content_hash": "9fea74ea8f0ac2b05c5e80686465ef2dae625169c0d3b7ab4595d30664f4bac4", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:0c9b007ac2e5e032abbd2446f5b8392658a5554c36edfedbeaf659e3f6d4ea26", "content": "The `CachingConnectionFactory` uses an instance of the Rabbit client `ConnectionFactory`.\nA number of configuration properties are passed through (`host`, `port`, `userName`, `password`, `requestedHeartBeat`, and `connectionTimeout` for example) when setting the equivalent property on the `CachingConnectionFactory`.\nTo set other properties (`clientProperties`, for example), you can define an instance of the Rabbit factory and provide a reference to it by using the appropriate constructor of the `CachingConnectionFactory`.\nWhen using the namespace (xref:amqp/connections.adoc[as described earlier]), you need to provide a reference to the configured factory in the `connection-factory` attribute.\nFor convenience, a factory bean is provided to assist in configuring the connection factory in a Spring application context, as discussed in xref:amqp/connections.adoc#rabbitconnectionfactorybean-configuring-ssl[the next section].\n\n[source,xml]\n----\n<rabbit:connection-factory\n id=\"connectionFactory\" connection-factory=\"rabbitConnectionFactory\"/>\n----\n\nNOTE: The 4.0.x client enables automatic recovery by default.\nWhile compatible with this feature, Spring AMQP has its own recovery mechanisms and the client recovery feature generally is not needed.\nWe recommend disabling `amqp-client` automatic recovery, to avoid getting `AutoRecoverConnectionNotCurrentlyOpenException` instances when the broker is available but the connection has not yet recovered.\nYou may notice this exception, for example, when a `RetryTemplate` is configured in a `RabbitTemplate`, even when failing over to another broker in a cluster.\nSince the auto-recovering connection recovers on a timer, the connection may be recovered more quickly by using Spring AMQP's recovery mechanisms.\nStarting with version 1.7.1, Spring AMQP disables `amqp-client` automatic recovery unless you explicitly create your own RabbitMQ connection factory and provide it to the `CachingConnectionFactory`.\nRabbitMQ `ConnectionFactory` instances created by the `RabbitConnectionFactoryBean` also have the option disabled by default.\n\n[[rabbitconnectionfactorybean-configuring-ssl]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "Configuring the Underlying Client Connection Factory", "heading_level": 2, "file_order": 32, "section_index": 8, "content_hash": "0c9b007ac2e5e032abbd2446f5b8392658a5554c36edfedbeaf659e3f6d4ea26", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:4120c79d688beeea8153f2a172e26de129082ebc4ef2dffb9c0e60ce5eab99e9", "content": "Starting with version 1.4, a convenient `RabbitConnectionFactoryBean` is provided to enable convenient configuration of SSL properties on the underlying client connection factory by using dependency injection.\nOther setters delegate to the underlying factory.\nPreviously, you had to configure the SSL options programmatically.\nThe following example shows how to configure a `RabbitConnectionFactoryBean`:\n\n[tabs]\n======\nJava::\n+\n[source,java,role=primary]\n----\n@Bean\nRabbitConnectionFactoryBean rabbitConnectionFactory() {\n RabbitConnectionFactoryBean factoryBean = new RabbitConnectionFactoryBean();\n factoryBean.setUseSSL(true);\n factoryBean.setSslPropertiesLocation(new ClassPathResource(\"secrets/rabbitSSL.properties\"));\n return factoryBean;\n}\n\n@Bean\nCachingConnectionFactory connectionFactory(ConnectionFactory rabbitConnectionFactory) {\n CachingConnectionFactory ccf = new CachingConnectionFactory(rabbitConnectionFactory);\n ccf.setHost(\"...\");\n // ...\n return ccf;\n}\n----\nXML::\n+\n[source,xml,role=secondary]\n----\n<bean id=\"rabbitConnectionFactory\"\n class=\"org.springframework.amqp.rabbit.connection.RabbitConnectionFactoryBean\">\n <property name=\"useSSL\" value=\"true\" />\n <property name=\"sslPropertiesLocation\" value=\"classpath:secrets/rabbitSSL.properties\"/>\n</bean>\n\n<rabbit:connection-factory id=\"connectionFactory\"\n connection-factory=\"rabbitConnectionFactory\"\n host=\"${host}\"\n port=\"${port}\"\n virtual-host=\"${vhost}\"\n username=\"${username}\" password=\"${password}\" />\n----\n======\n\nSpring Boot application file (`.yaml` or `.properties`)\n\n[configprops%novalidate,yaml]\n----\nspring:\n rabbitmq:\n host: ...\n ssl:\n keyStoreType: jks\n trustStoreType: jks\n keyStore: ...\n trustStore: ...\n trustStorePassword: ...\n keyStorePassword: ...\n enabled: true\n----\n\nSee the https://www.rabbitmq.com/ssl.html[RabbitMQ Documentation] for information about configuring SSL.\nOmit the `keyStore` and `trustStore` configuration to connect over SSL without certificate validation.\nThe next example shows how you can provide key and trust store configuration.\n\nThe `sslPropertiesLocation` property is a Spring `Resource` pointing to a properties file containing the following keys:\n\n[source]\n----\nkeyStore=file:/secret/keycert.p12\ntrustStore=file:/secret/trustStore\nkeyStore.passPhrase=secret\ntrustStore.passPhrase=secret\n----\n\nThe `keyStore` and `truststore` are Spring `Resources` pointing to the stores.\nTypically this properties file is secured by the operating system with the application having read access.\n\nStarting with Spring AMQP version 1.5,you can set these properties directly on the factory bean.\nIf both discrete properties and `sslPropertiesLocation` is provided, properties in the latter override the\ndiscrete values.\n\nIMPORTANT: Starting with version 2.0, the server certificate is validated by default because it is more secure.\nIf you wish to skip this validation for some reason, set the factory bean's `skipServerCertificateValidation` property to `true`.\nStarting with version 2.1, the `RabbitConnectionFactoryBean` now calls `enableHostnameVerification()` by default.\nTo revert to the previous behavior, set the `enableHostnameVerification` property to `false`.\n\nIMPORTANT: Starting with version 2.2.5, the factory bean will always use TLS v1.2 by default; previously, it used v1.1 in some cases and v1.2 in others (depending on other properties).\nIf you need to use v1.1 for some reason, set the `sslAlgorithm` property: `setSslAlgorithm(\"TLSv1.1\")`.\n\n[[cluster]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "`RabbitConnectionFactoryBean` and Configuring SSL", "heading_level": 2, "file_order": 32, "section_index": 9, "content_hash": "4120c79d688beeea8153f2a172e26de129082ebc4ef2dffb9c0e60ce5eab99e9", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:b45d9a4f6b4949250f756297541084282292ac3a8013abe343652d9f33279f8f", "content": "To connect to a cluster, configure the `addresses` property on the `CachingConnectionFactory`:\n\n[source, java]\n----\n@Bean\npublic CachingConnectionFactory ccf() {\n CachingConnectionFactory ccf = new CachingConnectionFactory();\n ccf.setAddresses(\"host1:5672,host2:5672,host3:5672\");\n return ccf;\n}\n----\n\nStarting with version 3.0, the underlying connection factory will attempt to connect to a host, by choosing a random address, whenever a new connection is established.\nTo revert to the previous behavior of attempting to connect from first to last, set the `addressShuffleMode` property to `AddressShuffleMode.NONE`.\n\nStarting with version 2.3, the `INORDER` shuffle mode was added, which means the first address is moved to the end after a connection is created.\nYou may wish to use this mode with the {rabbitmq-server-github}/rabbitmq_sharding[RabbitMQ Sharding Plugin] with `CacheMode.CONNECTION` and suitable concurrency if you wish to consume from all shards on all nodes.\n\n[source, java]\n----\n@Bean\npublic CachingConnectionFactory ccf() {\n CachingConnectionFactory ccf = new CachingConnectionFactory();\n ccf.setAddresses(\"host1:5672,host2:5672,host3:5672\");\n ccf.setAddressShuffleMode(AddressShuffleMode.INORDER);\n return ccf;\n}\n----\n\n[[routing-connection-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "Connecting to a Cluster", "heading_level": 2, "file_order": 32, "section_index": 10, "content_hash": "b45d9a4f6b4949250f756297541084282292ac3a8013abe343652d9f33279f8f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:019a78d2a17ef9e072110938a70eb586c4b23ea9e9bf3c7f4f128e919c1b3f1d", "content": "Starting with version 1.3, the `AbstractRoutingConnectionFactory` has been introduced.\nThis factory provides a mechanism to configure mappings for several `ConnectionFactories` and determine a target `ConnectionFactory` by some `lookupKey` at runtime.\nTypically, the implementation checks a thread-bound context.\nFor convenience, Spring AMQP provides the `SimpleRoutingConnectionFactory`, which gets the current thread-bound `lookupKey` from the `SimpleResourceHolder`.\nThe following examples shows how to configure a `SimpleRoutingConnectionFactory` in both XML and Java:\n\n[source,xml]\n----\n<bean id=\"connectionFactory\"\n class=\"org.springframework.amqp.rabbit.connection.SimpleRoutingConnectionFactory\">\n <property name=\"targetConnectionFactories\">\n <map>\n <entry key=\"#{connectionFactory1.virtualHost}\" ref=\"connectionFactory1\"/>\n <entry key=\"#{connectionFactory2.virtualHost}\" ref=\"connectionFactory2\"/>\n </map>\n </property>\n</bean>\n\n<rabbit:template id=\"template\" connection-factory=\"connectionFactory\" />\n----\n\n[source,java]\n----\npublic class MyService {\n\n @Autowired\n private RabbitTemplate rabbitTemplate;\n\n public void service(String vHost, String payload) {\n SimpleResourceHolder.bind(rabbitTemplate.getConnectionFactory(), vHost);\n rabbitTemplate.convertAndSend(payload);\n SimpleResourceHolder.unbind(rabbitTemplate.getConnectionFactory());\n }\n\n}\n----\n\nIt is important to unbind the resource after use.\nFor more information, see the javadoc:org.springframework.amqp.rabbit.connection.AbstractRoutingConnectionFactory[JavaDoc] for `AbstractRoutingConnectionFactory`.\n\nStarting with version 1.4, `RabbitTemplate` supports the SpEL `sendConnectionFactorySelectorExpression` and `receiveConnectionFactorySelectorExpression` properties, which are evaluated on each AMQP protocol interaction operation (`send`, `sendAndReceive`, `receive`, or `receiveAndReply`), resolving to a `lookupKey` value for the provided `AbstractRoutingConnectionFactory`.\nYou can use bean references, such as `@vHostResolver.getVHost(#root)` in the expression.\nFor `send` operations, the message to be sent is the root evaluation object.\nFor `receive` operations, the `queueName` is the root evaluation object.\n\nThe routing algorithm is as follows: If the selector expression is `null` or is evaluated to `null` or the provided `ConnectionFactory` is not an instance of `AbstractRoutingConnectionFactory`, everything works as before, relying on the provided `ConnectionFactory` implementation.\nThe same occurs if the evaluation result is not `null`, but there is no target `ConnectionFactory` for that `lookupKey` and the `AbstractRoutingConnectionFactory` is configured with `lenientFallback = true`.\nIn the case of an `AbstractRoutingConnectionFactory`, it does fallback to its `routing` implementation based on `determineCurrentLookupKey()`.\nHowever, if `lenientFallback = false`, an `IllegalStateException` is thrown.\n\nThe namespace support also provides the `send-connection-factory-selector-expression` and `receive-connection-factory-selector-expression` attributes on the `<rabbit:template>` component.\n\nAlso, starting with version 1.4, you can configure a routing connection factory in a listener container.\nIn that case, the list of queue names is used as the lookup key.\nFor example, if you configure the container with `setQueueNames(\"thing1\", \"thing2\")`, the lookup key is `[thing1,thing]\"` (note that there is no space in the key).\n\nStarting with version 1.6.9, you can add a qualifier to the lookup key by using `setLookupKeyQualifier` on the listener container.\nDoing so enables, for example, listening to queues with the same name but in a different virtual host (where you would have a connection factory for each).\n\nFor example, with lookup key qualifier `thing1` and a container listening to queue `thing2`, the lookup key you could register the target connection factory with could be `thing1[thing2]`.\n\nIMPORTANT: The target (and default, if provided) connection factories must have the same settings for publisher confirms and returns.\nSee xref:amqp/connections.adoc#cf-pub-conf-ret[Publisher Confirms and Returns].\n\nStarting with version 2.4.4, this validation can be disabled.\nIf you have a case that the values between confirms and returns need to be unequal, you can use `AbstractRoutingConnectionFactory#setConsistentConfirmsReturns` to turn of the validation.\nNote that the first connection factory added to `AbstractRoutingConnectionFactory` will determine the general values of `confirms` and `returns`.\n\nIt may be useful if you have a case that certain messages you would to check confirms/returns and others you don't.\nFor example:\n\n[source, java]\n----\n@Bean\npublic RabbitTemplate rabbitTemplate() {\n final com.rabbitmq.client.ConnectionFactory cf = new com.rabbitmq.client.ConnectionFactory();\n cf.setHost(\"localhost\");\n cf.setPort(5672);\n\n CachingConnectionFactory cachingConnectionFactory = new CachingConnectionFactory(cf);\n cachingConnectionFactory.setPublisherConfirmType(CachingConnectionFactory.ConfirmType.CORRELATED);\n\n PooledChannelConnectionFactory pooledChannelConnectionFactory = new PooledChannelConnectionFactory(cf);\n\n final Map<Object, ConnectionFactory> connectionFactoryMap = new HashMap<>(2);\n connectionFactoryMap.put(\"true\", cachingConnectionFactory);\n connectionFactoryMap.put(\"false\", pooledChannelConnectionFactory);\n\n final AbstractRoutingConnectionFactory routingConnectionFactory = new SimpleRoutingConnectionFactory();\n routingConnectionFactory.setConsistentConfirmsReturns(false);\n routingConnectionFactory.setDefaultTargetConnectionFactory(pooledChannelConnectionFactory);\n routingConnectionFactory.setTargetConnectionFactories(connectionFactoryMap);\n\n final RabbitTemplate rabbitTemplate = new RabbitTemplate(routingConnectionFactory);\n\n final Expression sendExpression = new SpelExpressionParser().parseExpression(\n \"messageProperties.headers['x-use-publisher-confirms'] ?: false\");\n rabbitTemplate.setSendConnectionFactorySelectorExpression(sendExpression);\n}\n----\n\nThis way messages with the header `x-use-publisher-confirms: true` will be sent through the caching connection, and you can ensure the message delivery.\nSee xref:amqp/connections.adoc#cf-pub-conf-ret[Publisher Confirms and Returns] for more information about ensuring message delivery.\n\n[[queue-affinity]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "Routing Connection Factory", "heading_level": 2, "file_order": 32, "section_index": 11, "content_hash": "019a78d2a17ef9e072110938a70eb586c4b23ea9e9bf3c7f4f128e919c1b3f1d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:660941e316563a9a87e8c12bced673b3e3abacc0e8b1e4e8eb6230a06cdd9019", "content": "When using HA queues in a cluster, for the best performance, you may want to connect to the physical broker\nwhere the lead queue resides.\nThe `CachingConnectionFactory` can be configured with multiple broker addresses.\nThis is to fail over and the client attempts to connect in accordance with the configured `AddressShuffleMode` order.\nThe `LocalizedQueueConnectionFactory` uses the REST API provided by the management plugin to determine which node is the lead for the queue.\nIt then creates (or retrieves from a cache) a `CachingConnectionFactory` that connects to just that node.\nIf the connection fails, the new lead node is determined and the consumer connects to it.\nThe `LocalizedQueueConnectionFactory` is configured with a default connection factory, in case the physical location of the queue cannot be determined, in which case it connects as normal to the cluster.\n\nThe `LocalizedQueueConnectionFactory` is a `RoutingConnectionFactory` and the `SimpleMessageListenerContainer` uses the queue names as the lookup key as discussed in <<routing-connection-factory>> above.\n\nNOTE: For this reason (the use of the queue name for the lookup), the `LocalizedQueueConnectionFactory` can only be used if the container is configured to listen to a single queue.\n\nNOTE: The RabbitMQ management plugin must be enabled on each node.\n\nCAUTION: This connection factory is intended for long-lived connections, such as those used by the `SimpleMessageListenerContainer`.\nIt is not intended for short connection use, such as with a `RabbitTemplate` because of the overhead of invoking the REST API before making the connection.\nAlso, for publish operations, the queue is unknown, and the message is published to all cluster members anyway, so the logic of looking up the node has little value.\n\nThe following example configuration shows how to configure the factories:\n\n[source, java]\n----\n@Autowired\nprivate ConfigurationProperties props;\n\n@Bean\npublic CachingConnectionFactory defaultConnectionFactory() {\n CachingConnectionFactory cf = new CachingConnectionFactory();\n cf.setAddresses(this.props.getAddresses());\n cf.setUsername(this.props.getUsername());\n cf.setPassword(this.props.getPassword());\n cf.setVirtualHost(this.props.getVirtualHost());\n return cf;\n}\n\n@Bean\npublic LocalizedQueueConnectionFactory queueAffinityCF(\n @Qualifier(\"defaultConnectionFactory\") ConnectionFactory defaultCF) {\n return new LocalizedQueueConnectionFactory(defaultCF,\n StringUtils.commaDelimitedListToStringArray(this.props.getAddresses()),\n StringUtils.commaDelimitedListToStringArray(this.props.getAdminUris()),\n StringUtils.commaDelimitedListToStringArray(this.props.getNodes()),\n this.props.getVirtualHost(), this.props.getUsername(), this.props.getPassword(),\n false, null);\n}\n----\n\nNotice that the first three parameters are arrays of `addresses`, `adminUris`, and `nodes`.\nThese are positional in that, when a container attempts to connect to a queue, it uses the admin API to determine which node is the lead for the queue and connects to the address in the same array position as that node.\n\nIMPORTANT: Starting with version 3.0, the RabbitMQ `http-client` is no longer used to access the Rest API.\nInstead, by default, the `WebClient` from Spring Webflux is used if `spring-webflux` is on the class path; otherwise a `RestTemplate` is used.\n\nTo add `WebFlux` to the class path:\n\n.Maven\n[source,xml,subs=\"+attributes\"]\n----\n<dependency>\n <groupId>org.springframework.amqp</groupId>\n <artifactId>spring-rabbit</artifactId>\n</dependency>\n----\n.Gradle\n[source,groovy,subs=\"+attributes\"]\n----\nimplementation 'org.springframework.amqp:spring-rabbit'\n----\n\nYou can also use other REST technology by implementing javadoc:org.springframework.amqp.rabbit.connection.LocalizedQueueConnectionFactory#setNodeLocator(org.springframework.amqp.rabbit.connection.NodeLocator)[LocalizedQueueConnectionFactory#setNodeLocator] and overriding its `createClient`, `restCall`, and optionally, `close` methods.\n\n[source, java]\n----\nlqcf.setNodeLocator(new NodeLocator<MyClient>() {\n\n @Override\n public MyClient createClient(String userName, String password) {\n ...\n }\n\n @Override\n public Map<String, Object> restCall(MyClient client, String baseUri, String vhost, String queue) throws URISyntaxException {\n ...\n }\n\n});\n----\n\nThe framework provides the `WebFluxNodeLocator` and `RestTemplateNodeLocator`, with the default as discussed above.\n\n[[cf-pub-conf-ret]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "Queue Affinity and the `LocalizedQueueConnectionFactory`", "heading_level": 2, "file_order": 32, "section_index": 12, "content_hash": "660941e316563a9a87e8c12bced673b3e3abacc0e8b1e4e8eb6230a06cdd9019", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:f7982642d84c8f1ad13ec3b9b143acdd934a23b9fbdf219ebfc337643b1afc9f", "content": "Confirmed (with correlation) and returned messages are supported by setting the `CachingConnectionFactory` property `publisherConfirmType` to `ConfirmType.CORRELATED` and the `publisherReturns` property to 'true'.\n\nWhen these options are set, `Channel` instances created by the factory are wrapped in an `PublisherCallbackChannel`, which is used to facilitate the callbacks.\nWhen such a channel is obtained, the client can register a `PublisherCallbackChannel.Listener` with the `Channel`.\nThe `PublisherCallbackChannel` implementation contains logic to route a confirm or return to the appropriate listener.\nThese features are explained further in the following sections.\n\nSee also xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns] and `simplePublisherConfirms` in xref:amqp/template.adoc#scoped-operations[Scoped Operations].\n\nTIP: For some more background information, see the blog post by the RabbitMQ team titled https://www.rabbitmq.com/blog/2011/02/10/introducing-publisher-confirms/[Introducing Publisher Confirms].\n\n[[connection-channel-listeners]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "Publisher Confirms and Returns", "heading_level": 2, "file_order": 32, "section_index": 13, "content_hash": "f7982642d84c8f1ad13ec3b9b143acdd934a23b9fbdf219ebfc337643b1afc9f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:aea98f92aa1031e384a6ad75b0531bf67fc5f12b2b827f0afd8e6f7d2eeee7a5", "content": "The connection factory supports registering `ConnectionListener` and `ChannelListener` implementations.\nThis allows you to receive notifications for connection and channel related events.\n(A `ConnectionListener` is used by the `RabbitAdmin` to perform declarations when the connection is established - see xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#automatic-declaration[Automatic Declaration of Exchanges, Queues, and Bindings] for more information).\nThe following listing shows the `ConnectionListener` interface definition:\n\n[source, java]\n----\n@FunctionalInterface\npublic interface ConnectionListener {\n\n void onCreate(Connection connection);\n\n default void onClose(Connection connection) {\n }\n\n default void onShutDown(ShutdownSignalException signal) {\n }\n\n}\n----\n\nStarting with version 2.0, the `org.springframework.amqp.rabbit.connection.Connection` object can be supplied with `com.rabbitmq.client.BlockedListener` instances to be notified for connection blocked and unblocked events.\nThe following example shows the ChannelListener interface definition:\n\n[source, java]\n----\n@FunctionalInterface\npublic interface ChannelListener {\n\n void onCreate(Channel channel, boolean transactional);\n\n default void onShutDown(ShutdownSignalException signal) {\n }\n\n}\n----\n\nSee xref:amqp/template.adoc#publishing-is-async[Publishing is Asynchronous -- How to Detect Successes and Failures] for one scenario where you might want to register a `ChannelListener`.\n\n[[channel-close-logging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "Connection and Channel Listeners", "heading_level": 2, "file_order": 32, "section_index": 14, "content_hash": "aea98f92aa1031e384a6ad75b0531bf67fc5f12b2b827f0afd8e6f7d2eeee7a5", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:cde7e470959e16174b64a1ce224df0b9d0bf31c87fbae61c423c368a51ec1dea", "content": "Version 1.5 introduced a mechanism to enable users to control logging levels.\n\nThe `AbstractConnectionFactory` uses a default strategy to log channel closures as follows:\n\n* Normal channel closes (200 OK) are not logged.\n* If a channel is closed due to a failed passive queue declaration, it is logged at DEBUG level.\n* If a channel is closed because the `basic.consume` is refused due to an exclusive consumer condition, it is logged at\nDEBUG level (since 3.1, previously INFO).\n* All others are logged at ERROR level.\n\nTo modify this behavior, you can inject a custom `ConditionalExceptionLogger` into the\n`CachingConnectionFactory` in its `closeExceptionLogger` property.\n\nAlso, the `AbstractConnectionFactory.DefaultChannelCloseLogger` is now public, allowing it to be sub classed.\n\nSee also xref:amqp/receiving-messages/consumer-events.adoc[Consumer Events].\n\n[[runtime-cache-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "Logging Channel Close Events", "heading_level": 2, "file_order": 32, "section_index": 15, "content_hash": "cde7e470959e16174b64a1ce224df0b9d0bf31c87fbae61c423c368a51ec1dea", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:1f0cecf1e4c0a5150eef0096fedf7a09ed774c27c2130b853c3cd02c8d831df8", "content": "Staring with version 1.6, the `CachingConnectionFactory` now provides cache statistics through the `getCacheProperties()`\nmethod.\nThese statistics can be used to tune the cache to optimize it in production.\nFor example, the high water marks can be used to determine whether the cache size should be increased.\nIf it equals the cache size, you might want to consider increasing further.\nThe following table describes the `CacheMode.CHANNEL` properties:\n\n.Cache properties for CacheMode.CHANNEL\n[cols=\"2l,4\", options=\"header\"]\n|===\n|Property\n\n|Meaning\n\n|connectionName\n\n|The name of the connection generated by the `ConnectionNameStrategy`.\n\n|channelCacheSize\n\n|The currently configured maximum channels that are allowed to be idle.\n\n|localPort\n\n|The local port for the connection (if available).\nThis can be used to correlate with connections and channels on the RabbitMQ Admin UI.\n\n|idleChannelsTx\n\n|The number of transactional channels that are currently idle (cached).\n\n|idleChannelsNotTx\n\n|The number of non-transactional channels that are currently idle (cached).\n\n|idleChannelsTxHighWater\n\n|The maximum number of transactional channels that have been concurrently idle (cached).\n\n|idleChannelsNotTxHighWater\n\n|The maximum number of non-transactional channels have been concurrently idle (cached).\n\n|===\n\nThe following table describes the `CacheMode.CONNECTION` properties:\n\n.Cache properties for CacheMode.CONNECTION\n[cols=\"2l,4\", options=\"header\"]\n|===\n|Property\n\n|Meaning\n\n|connectionName:<localPort>\n\n|The name of the connection generated by the `ConnectionNameStrategy`.\n\n|openConnections\n\n|The number of connection objects representing connections to brokers.\n\n|channelCacheSize\n\n|The currently configured maximum channels that are allowed to be idle.\n\n|connectionCacheSize\n\n|The currently configured maximum connections that are allowed to be idle.\n\n|idleConnections\n\n|The number of connections that are currently idle.\n\n|idleConnectionsHighWater\n\n|The maximum number of connections that have been concurrently idle.\n\n|idleChannelsTx:<localPort>\n\n|The number of transactional channels that are currently idle (cached) for this connection.\nYou can use the `localPort` part of the property name to correlate with connections and channels on the RabbitMQ Admin UI.\n\n|idleChannelsNotTx:<localPort>\n\n|The number of non-transactional channels that are currently idle (cached) for this connection.\nThe `localPort` part of the property name can be used to correlate with connections and channels on the RabbitMQ Admin UI.\n\n|idleChannelsTxHighWater:<localPort>\n\n|The maximum number of transactional channels that have been concurrently idle (cached).\nThe localPort part of the property name can be used to correlate with connections and channels on the RabbitMQ Admin UI.\n\n|idleChannelsNotTxHighWater:<localPort>\n\n|The maximum number of non-transactional channels have been concurrently idle (cached).\nYou can use the `localPort` part of the property name to correlate with connections and channels on the RabbitMQ Admin UI.\n\n|===\n\nThe `cacheMode` property (`CHANNEL` or `CONNECTION`) is also included.\n\n.JVisualVM Example\nimage::cacheStats.png[align=\"center\"]\n\n[[auto-recovery]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "Runtime Cache Properties", "heading_level": 2, "file_order": 32, "section_index": 16, "content_hash": "1f0cecf1e4c0a5150eef0096fedf7a09ed774c27c2130b853c3cd02c8d831df8", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:55b0852df123415a6f3db3b65f1d94f687ed4d6c69a82e566a85554d398c4cbd", "content": "Since the first version of Spring AMQP, the framework has provided its own connection and channel recovery in the event of a broker failure.\nAlso, as discussed in xref:amqp/broker-configuration.adoc[Configuring the Broker], the `RabbitAdmin` re-declares any infrastructure beans (queues and others) when the connection is re-established.\nIt therefore does not rely on the https://www.rabbitmq.com/api-guide.html#recovery[auto-recovery] that is now provided by the `amqp-client` library.\nThe `amqp-client`, has auto recovery enabled by default.\nThere are some incompatibilities between the two recovery mechanisms so, by default, Spring sets the `automaticRecoveryEnabled` property on the underlying `RabbitMQ connectionFactory` to `false`.\nEven if the property is `true`, Spring effectively disables it, by immediately closing any recovered connections.\n\nIMPORTANT: By default, only elements (queues, exchanges, bindings) that are defined as beans will be re-declared after a connection failure.\nSee xref:amqp/broker-configuration.adoc#declarable-recovery[Recovering Auto-Delete Declarations] for how to change that behavior.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/connections.adoc", "title": "connections", "heading": "RabbitMQ Automatic Connection/Topology recovery", "heading_level": 2, "file_order": 32, "section_index": 17, "content_hash": "55b0852df123415a6f3db3b65f1d94f687ed4d6c69a82e566a85554d398c4cbd", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/connections.adoc"}}
{"id": "sha256:eedace14501a8002d66bdaadbada7d2dde53d0aa981472b5cc0b75ebcffb404d", "content": "[[containerAttributes]]\n\nThere are quite a few options for configuring a `SimpleMessageListenerContainer` (SMLC) and a `DirectMessageListenerContainer` (DMLC) related to transactions and quality of service, and some of them interact with each other.\nProperties that apply to the SMLC, DMLC, or `StreamListenerContainer` (StLC) (see xref:stream.adoc[Using the RabbitMQ Stream Plugin]) are indicated by the check mark in the appropriate column.\nSee xref:amqp/receiving-messages/choose-container.adoc[Choosing a Container] for information to help you decide which container is appropriate for your application.\n\nThe following table shows the container property names and their equivalent attribute names (in parentheses) when using the namespace to configure a `<rabbit:listener-container/>`.\nThe `type` attribute on that element can be `simple` (default) or `direct` to specify an `SMLC` or `DMLC` respectively.\nSome properties are not exposed by the namespace.\nThese are indicated by `N/A` for the attribute.\n\n.Configuration options for a message listener container\n[cols=\"8,16,1,1,1\", options=\"header\"]\n|===\n|Property\n(Attribute)\n|Description\n|SMLC\n|DMLC\n|StLC\n\n|[[ackTimeout]]<<ackTimeout,`ackTimeout`>> +\n(N/A)\n\n|When `messagesPerAck` is set, this timeout is used as an alternative to send an ack.\nWhen a new message arrives, the count of unacked messages is compared to `messagesPerAck`, and the time since the last ack is compared to this value.\nIf either condition is `true`, the message is acknowledged.\nWhen no new messages arrive and there are unacked messages, this timeout is approximate since the condition is only checked each `monitorInterval`.\nSee also `messagesPerAck` and `monitorInterval` in this table.\n\na|\na|image::tickmark.png[]\na|\n\n|[[acknowledgeMode]]<<acknowledgeMode,`acknowledgeMode`>> +\n(acknowledge)\n\na|\n* `NONE`: No acks are sent (incompatible with `channelTransacted=true`).\nRabbitMQ calls this \"`autoack`\", because the broker assumes all messages are acked without any action from the consumer.\n* `MANUAL`: The listener must acknowledge all messages by calling `Channel.basicAck()`.\n* `AUTO`: The container acknowledges the message automatically, unless the `MessageListener` throws an exception.\nNote that `acknowledgeMode` is complementary to `channelTransacted` -- if the channel is transacted, the broker requires a commit notification in addition to the ack.\nThis is the default mode.\nSee also `batchSize`.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[adviceChain]]<<adviceChain,`adviceChain`>> +\n(advice-chain)\n\n|An array of AOP Advice to apply to the listener execution.\nThis can be used to apply additional cross-cutting concerns, such as automatic retry in the event of broker death.\nNote that simple re-connection after an AMQP error is handled by the `CachingConnectionFactory`, as long as the broker is still alive.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[afterReceivePostProcessors]]<<afterReceivePostProcessors,`afterReceivePostProcessors`>> +\n(N/A)\n\n|An array of `MessagePostProcessor` instances that are invoked before invoking the listener.\nPost processors can implement `PriorityOrdered` or `Ordered`.\nThe array is sorted with un-ordered members invoked last.\nIf a post processor returns `null`, the message is discarded (and acknowledged, if appropriate).\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[alwaysRequeueWithTxManagerRollback]]<<alwaysRequeueWithTxManagerRollback,`alwaysRequeueWithTxManagerRollback`>> +\n(N/A)\n\n|Set to `true` to always requeue messages on rollback when a transaction manager is configured.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[autoDeclare]]<<autoDeclare,`autoDeclare`>> +\n(auto-declare)\n\na|When set to `true` (default), the container uses a `RabbitAdmin` to redeclare all AMQP objects (queues, exchanges, bindings), if it detects that at least one of its queues is missing during startup, perhaps because it is an `auto-delete` or an expired queue, but the redeclaration proceeds if the queue is missing for any reason.\nTo disable this behavior, set this property to `false`.\nNote that the container fails to start if all of its queues are missing.\n\nNOTE: Prior to version 1.6, if there was more than one admin in the context, the container would randomly select one.\nIf there were no admins, it would create one internally.\nIn either case, this could cause unexpected results.\nStarting with version 1.6, for `autoDeclare` to work, there must be exactly one `RabbitAdmin` in the context, or a reference to a specific instance must be configured on the container using the `rabbitAdmin` property.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[autoStartup]]<<autoStartup,`autoStartup`>> +\n(auto-startup)\n\n|Flag to indicate that the container should start when the `ApplicationContext` does (as part of the `SmartLifecycle` callbacks, which happen after all beans are initialized).\nDefaults to `true`, but you can set it to `false` if your broker might not be available on startup and call `start()` later manually when you know the broker is ready.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|image::tickmark.png[]\n\n|[[batchSize]]<<batchSize,`batchSize`>> +\n(transaction-size)\n(batch-size)\n\n|When used with `acknowledgeMode` set to `AUTO`, the container tries to process up to this number of messages before sending an ack (waiting for each one up to the receive timeout setting).\nThis is also when a transactional channel is committed.\nIf the `prefetchCount` is less than the `batchSize`, it is increased to match the `batchSize`.\n\na|image::tickmark.png[]\na|\na|\n\n|[[batchingStrategy]]<<batchingStrategy,`batchingStrategy`>> +\n(N/A)\n\n|The strategy used when debatchng messages.\nDefault `SimpleDebatchingStrategy`.\nSee xref:amqp/sending-messages.adoc#template-batching[Batching] and xref:amqp/receiving-messages/batch.adoc[@RabbitListener with Batching].\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[channelTransacted]]<<channelTransacted,`channelTransacted`>> +\n(channel-transacted)\n\n|Boolean flag to signal that all messages should be acknowledged in a transaction (either manually or automatically).\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[concurrency]]<<concurrency,`concurrency`>> +\n(N/A)\n\n|`m-n` The range of concurrent consumers for each listener (min, max).\nIf only `n` is provided, `n` is a fixed number of consumers.\nSee xref:amqp/listener-concurrency.adoc#listener-concurrency[Listener Concurrency].\n\na|image::tickmark.png[]\na|\na|\n\n|[[concurrentConsumers]]<<concurrentConsumers,`concurrentConsumers`>> +\n(concurrency)\n\n|The number of concurrent consumers to initially start for each listener.\nSee xref:amqp/listener-concurrency.adoc#listener-concurrency[Listener Concurrency].\nFor the `StLC`, concurrency is controlled via an overloaded `superStream` method; see xref:stream.adoc#super-stream-consumer[Consuming Super Streams with Single Active Consumers].\n\na|image::tickmark.png[]\na|\na|image::tickmark.png[]\n\n|[[connectionFactory]]<<connectionFactory,`connectionFactory`>> +\n(connection-factory)\n\n|A reference to the `ConnectionFactory`.\nWhen configuring by using the XML namespace, the default referenced bean name is `rabbitConnectionFactory`.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[consecutiveActiveTrigger]]<<consecutiveActiveTrigger,`consecutiveActiveTrigger`>> +\n(min-consecutive-active)\n\n|The minimum number of consecutive messages received by a consumer, without a receive timeout occurring, when considering starting a new consumer.\nAlso impacted by 'batchSize'.\nSee xref:amqp/listener-concurrency.adoc#listener-concurrency[Listener Concurrency].\nDefault: 10.\n\na|image::tickmark.png[]\na|\na|\n\n|[[consecutiveIdleTrigger]]<<consecutiveIdleTrigger,`consecutiveIdleTrigger`>> +\n(min-consecutive-idle)\n\n|The minimum number of receive timeouts a consumer must experience before considering stopping a consumer.\nAlso impacted by 'batchSize'.\nSee xref:amqp/listener-concurrency.adoc#listener-concurrency[Listener Concurrency].\nDefault: 10.\n\na|image::tickmark.png[]\na|\na|\n\n|[[consumerBatchEnabled]]<<consumerBatchEnabled,`consumerBatchEnabled`>> +\n(batch-enabled)\n\n|If the `MessageListener` supports it, setting this to true enables batching of discrete messages, up to `batchSize`; a partial batch will be delivered if no new messages arrive in `receiveTimeout` or gathering batch messages time exceeded `batchReceiveTimeout`.\nWhen this is false, batching is only supported for batches created by a producer; see xref:amqp/sending-messages.adoc#template-batching[Batching].\n\na|image::tickmark.png[]\na|\na|\n\n|[[consumerCustomizer]]<<consumerCustomizer,`consumerCustomizer`>> +\n(N/A)\n\n|A `ConsumerCustomizer` bean used to modify stream consumers created by the container.\n\na|\na|\na|image::tickmark.png[]\n\n|[[consumerStartTimeout]]<<consumerStartTimeout,`consumerStartTimeout`>> +\n(N/A)\n\n|The time in milliseconds to wait for a consumer thread to start.\nIf this time elapses, an error log is written.\nAn example of when this might happen is if a configured `taskExecutor` has insufficient threads to support the container `concurrentConsumers`.\n\nSee xref:amqp/receiving-messages/threading.adoc[Threading and Asynchronous Consumers].\nDefault: 60000 (one minute).\n\na|image::tickmark.png[]\na|\na|\n\n|[[consumerTagStrategy]]<<consumerTagStrategy,`consumerTagStrategy`>> +\n(consumer-tag-strategy)\n\n|Set an implementation of xref:amqp/receiving-messages/consumerTags.adoc[ConsumerTagStrategy], enabling the creation of a (unique) tag for each consumer.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[consumersPerQueue]]<<consumersPerQueue,`consumersPerQueue`>> +\n(consumers-per-queue)\n\n|The number of consumers to create for each configured queue.\nSee xref:amqp/listener-concurrency.adoc#listener-concurrency[Listener Concurrency].\n\na|\na|image::tickmark.png[]\na|\n\n|[[consumeDelay]]<<consumeDelay,`consumeDelay`>> +\n(N/A)\n\n|When using the {rabbitmq-server-github}/rabbitmq_sharding[RabbitMQ Sharding Plugin] with `concurrentConsumers > 1`, there is a race condition that can prevent even distribution of the consumers across the shards.\nUse this property to add a small delay between consumer starts to avoid this race condition.\nYou should experiment with values to determine the suitable delay for your environment.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[debatchingEnabled]]<<debatchingEnabled,`debatchingEnabled`>> +\n(N/A)\n\n|When true, the listener container will debatch batched messages and invoke the listener with each message from the batch.\nStarting with version 2.2.7, xref:amqp/sending-messages.adoc#template-batching[producer created batches] will be debatched as a `List<Message>` if the listener is a `BatchMessageListener` or `ChannelAwareBatchMessageListener`.\nOtherwise messages from the batch are presented one-at-a-time.\nDefault true.\nSee xref:amqp/sending-messages.adoc#template-batching[Batching] and xref:amqp/receiving-messages/batch.adoc[@RabbitListener with Batching].\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[declarationRetries]]<<declarationRetries,`declarationRetries`>> +\n(declaration-retries)\n\n|The number of retry attempts when passive queue declaration fails.\nPassive queue declaration occurs when the consumer starts or, when consuming from multiple queues, when not all queues were available during initialization.\nWhen none of the configured queues can be passively declared (for any reason) after the retries are exhausted, the container behavior is controlled by the `missingQueuesFatal` property, described earlier.\nDefault: Three retries (for a total of four attempts).\n\na|image::tickmark.png[]\na|\na|\n\n|[[defaultRequeueRejected]]<<defaultRequeueRejected,`defaultRequeueRejected`>> +\n(requeue-rejected)\n\n|Determines whether messages that are rejected because the listener threw an exception should be requeued or not.\nDefault: `true`.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[errorHandler]]<<errorHandler,`errorHandler`>> +\n(error-handler)\n\n|A reference to an `ErrorHandler` strategy for handling any uncaught exceptions that may occur during the execution of the MessageListener.\nDefault: `ConditionalRejectingErrorHandler`\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[exclusive]]<<exclusive,`exclusive`>> +\n(exclusive)\n\n|Determines whether the single consumer in this container has exclusive access to the queues.\nThe concurrency of the container must be 1 when this is `true`.\nIf another consumer has exclusive access, the container tries to recover the consumer, according to the\n`recovery-interval` or `recovery-back-off`.\nWhen using the namespace, this attribute appears on the `<rabbit:listener/>` element along with the queue names.\nDefault: `false`.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[exclusiveConsumerExceptionLogger]]<<exclusiveConsumerExceptionLogger,`exclusiveConsumerExceptionLogger`>> +\n(N/A)\n\n|An exception logger used when an exclusive consumer cannot gain access to a queue.\nBy default, this is logged at the `WARN` level.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[failedDeclarationRetryInterval]]<<failedDeclarationRetryInterval,`failedDeclarationRetryInterval`>> +\n(failed-declaration\n-retry-interval)\n\n|The interval between passive queue declaration retry attempts.\nPassive queue declaration occurs when the consumer starts or, when consuming from multiple queues, when not all queues were available during initialization.\nDefault: 5000 (five seconds).\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[forceCloseChannel]]<<forceCloseChannel,`forceCloseChannel`>> +\n(N/A)\n\n|If the consumers do not respond to a shutdown within `shutdownTimeout`, if this is `true`, the channel will be closed, causing any unacked messages to be requeued.\nDefaults to `true` since 2.0.\nYou can set it to `false` to revert to the previous behavior.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[forceStop]]<<forceStop,`forceStop`>> +\n(N/A)\n\n|Set to true to stop (when the container is stopped) after the current record is processed; causing all prefetched messages to be requeued.\nBy default, the container will cancel the consumer and process all prefetched messages before stopping.\nSince versions 2.4.14, 3.0.6\nDefaults to `false`.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[globalQos]]<<globalQos,`globalQos`>> +\n(global-qos)\n\n|When true, the `prefetchCount` is applied globally to the channel rather than to each consumer on the channel.\nSee https://www.rabbitmq.com/amqp-0-9-1-reference.html#basic.qos.global[`basicQos.global`] for more information.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|(group)\n\n|This is available only when using the namespace.\nWhen specified, a bean of type `Collection<MessageListenerContainer>` is registered with this name, and the\ncontainer for each `<listener/>` element is added to the collection.\nThis allows, for example, starting and stopping the group of containers by iterating over the collection.\nIf multiple `<listener-container/>` elements have the same group value, the containers in the collection form\nan aggregate of all containers so designated.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[idleEventInterval]]<<idleEventInterval,`idleEventInterval`>> +\n(idle-event-interval)\n\n|See xref:amqp/receiving-messages/idle-containers.adoc[Detecting Idle Asynchronous Consumers].\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[javaLangErrorHandler]]<<javaLangErrorHandler,`javaLangErrorHandler`>> +\n(N/A)\n\n|An `AbstractMessageListenerContainer.JavaLangErrorHandler` implementation that is called when a container thread catches an `Error`.\nThe default implementation calls `System.exit(99)`; to revert to the previous behavior (do nothing), add a no-op handler.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[maxConcurrentConsumers]]<<maxConcurrentConsumers,`maxConcurrentConsumers`>> +\n(max-concurrency)\n\n|The maximum number of concurrent consumers to start, if needed, on demand.\nMust be greater than or equal to 'concurrentConsumers'.\nSee xref:amqp/listener-concurrency.adoc#listener-concurrency[Listener Concurrency].\n\na|image::tickmark.png[]\na|\na|\n\n|[[messagesPerAck]]<<messagesPerAck,`messagesPerAck`>> +\n(N/A)\n\n|The number of messages to receive between acks.\nUse this to reduce the number of acks sent to the broker (at the cost of increasing the possibility of redelivered messages).\nGenerally, you should set this property only on high-volume listener containers.\nIf this is set and a message is rejected (exception thrown), pending acks are acknowledged and the failed message is rejected.\nNot allowed with transacted channels.\nIf the `prefetchCount` is less than the `messagesPerAck`, it is increased to match the `messagesPerAck`.\nDefault: ack every message.\nSee also `ackTimeout` in this table.\n\na|\na|image::tickmark.png[]\na|\n\n|[[mismatchedQueuesFatal]]<<mismatchedQueuesFatal,`mismatchedQueuesFatal`>> +\n(mismatched-queues-fatal)\n\na|When the container starts, if this property is `true` (default: `false`), the container checks that all queues declared in the context are compatible with queues already on the broker.\nIf mismatched properties (such as `auto-delete`) or arguments (such as `x-message-ttl`) exist, the container (and application context) fails to start with a fatal exception.\n\nIf the problem is detected during recovery (for example, after a lost connection), the container is stopped.\n\nThere must be a single `RabbitAdmin` in the application context (or one specifically configured on the container by using the `rabbitAdmin` property).\nOtherwise, this property must be `false`.\n\nNOTE: If the broker is not available during initial startup, the container starts and the conditions are checked when the connection is established.\n\nIMPORTANT: The check is done against all queues in the context, not just the queues that a particular listener is configured to use.\nIf you wish to limit the checks to just those queues used by a container, you should configure a separate `RabbitAdmin` for the container, and provide a reference to it using the `rabbitAdmin` property.\nSee xref:amqp/broker-configuration.adoc#conditional-declaration[Conditional Declaration] for more information.\n\nIMPORTANT: Mismatched queue argument detection is disabled while starting a container for a `@RabbitListener` in a bean that is marked `@Lazy`.\nThis is to avoid a potential deadlock which can delay the start of such containers for up to 60 seconds.\nApplications using lazy listener beans should check the queue arguments before getting a reference to the lazy bean.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[missingQueuesFatal]]<<missingQueuesFatal,`missingQueuesFatal`>> +\n(missing-queues-fatal)\n\na|When set to `true` (default), if none of the configured queues are available on the broker, it is considered fatal.\nThis causes the application context to fail to initialize during startup.\nAlso, when the queues are deleted while the container is running, by default, the consumers make three retries to connect to the queues (at five second intervals) and stop the container if these attempts fail.\n\nThis was not configurable in previous versions.\n\nWhen set to `false`, after making the three retries, the container goes into recovery mode, as with other problems, such as the broker being down.\nThe container tries to recover according to the `recoveryInterval` property.\nDuring each recovery attempt, each consumer again tries four times to passively declare the queues at five second intervals.\nThis process continues indefinitely.\n\nYou can also use a properties bean to set the property globally for all containers, as follows:\n\n[source,xml]\n----\n<util:properties\n id=\"spring.amqp.global.properties\">\n <prop key=\"mlc.missing.queues.fatal\">\n false\n </prop>\n</util:properties>\n----\n\nThis global property is not applied to any containers that have an explicit `missingQueuesFatal` property set.\n\nThe default retry properties (three retries at five-second intervals) can be overridden by setting the properties below.\n\nIMPORTANT: Missing queue detection is disabled while starting a container for a `@RabbitListener` in a bean that is marked `@Lazy`.\nThis is to avoid a potential deadlock which can delay the start of such containers for up to 60 seconds.\nApplications using lazy listener beans should check the queue(s) before getting a reference to the lazy bean.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[monitorInterval]]<<monitorInterval,`monitorInterval`>> +\n(monitor-interval)\n\n|With the DMLC, a task is scheduled to run at this interval to monitor the state of the consumers and recover any that have failed.\n\na|\na|image::tickmark.png[]\na|\n\n|[[noLocal]]<<noLocal,`noLocal`>> +\n(N/A)\n\n|Set to `true` to disable delivery from the server to consumers messages published on the same channel's connection.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[phase]]<<phase,`phase`>> +\n(phase)\n\n|When `autoStartup` is `true`, the lifecycle phase within which this container should start and stop.\nThe lower the value, the earlier this container starts and the later it stops.\nThe default is `Integer.MAX_VALUE`, meaning the container starts as late as possible and stops as soon as possible.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[possibleAuthenticationFailureFatal]]<<possibleAuthenticationFailureFatal,`possibleAuthenticationFailureFatal`>> +\n(possible-authentication-failure-fatal)\n\na|When set to `true` (default for SMLC), if a `PossibleAuthenticationFailureException` is thrown during connection, it is considered fatal.\nThis causes the application context to fail to initialize during startup (if the container is configured with auto startup).\n\nSince _version 2.0_.\n\n**DirectMessageListenerContainer**\n\nWhen set to `false` (default), each consumer will attempt to reconnect according to the `monitorInterval`.\n\n**SimpleMessageListenerContainer**\n\nWhen set to `false`, after making the 3 retries, the container will go into recovery mode, as with other problems, such as the broker being down.\nThe container will attempt to recover according to the `recoveryInterval` property.\nDuring each recovery attempt, each consumer will again try 4 times to start.\nThis process will continue indefinitely.\n\nYou can also use a properties bean to set the property globally for all containers, as follows:\n\n[source,xml]\n----\n<util:properties\n id=\"spring.amqp.global.properties\">\n <prop\n key=\"mlc.possible.authentication.failure.fatal\">\n false\n </prop>\n</util:properties>\n----\n\nThis global property will not be applied to any containers that have an explicit `missingQueuesFatal` property set.\n\nThe default retry properties (3 retries at 5 second intervals) can be overridden using the properties after this one.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[prefetchCount]]<<prefetchCount,`prefetchCount`>> +\n(prefetch)\n\na|The number of unacknowledged messages that can be outstanding at each consumer.\nThe higher this value is, the faster the messages can be delivered, but the higher the risk of non-sequential processing.\nIgnored if the `acknowledgeMode` is `NONE`.\nThis is increased, if necessary, to match the `batchSize` or `messagePerAck`.\nDefaults to 250 since 2.0.\nYou can set it to 1 to revert to the previous behavior.\n\nIMPORTANT: There are scenarios where the prefetch value should\nbe low -- for example, with large messages, especially if the processing is slow (messages could add up\nto a large amount of memory in the client process), and if strict message ordering is necessary\n(the prefetch value should be set back to 1 in this case).\nAlso, with low-volume messaging and multiple consumers (including concurrency within a single listener container instance), you may wish to reduce the prefetch to get a more even distribution of messages across consumers.\n\nAlso see `globalQos`.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[rabbitAdmin]]<<rabbitAdmin,`rabbitAdmin`>> +\n(admin)\n\n|When a listener container listens to at least one auto-delete queue and it is found to be missing during startup, the container uses a `RabbitAdmin` to declare the queue and any related bindings and exchanges.\nIf such elements are configured to use conditional declaration (see xref:amqp/broker-configuration.adoc#conditional-declaration[Conditional Declaration]), the container must use the admin that was configured to declare those elements.\nSpecify that admin here.\nIt is required only when using auto-delete queues with conditional declaration.\nIf you do not wish the auto-delete queues to be declared until the container is started, set `auto-startup` to `false` on the admin.\nDefaults to a `RabbitAdmin` that declares all non-conditional elements.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[receiveTimeout]]<<receiveTimeout,`receiveTimeout`>> +\n(receive-timeout)\n\n|The maximum time to wait for each message.\nIf `acknowledgeMode=NONE`, this has very little effect -- the container spins round and asks for another message.\nIt has the biggest effect for a transactional `Channel` with `batchSize > 1`, since it can cause messages already consumed not to be acknowledged until the timeout expires.\nWhen `consumerBatchEnabled` is true, a partial batch will be delivered if this timeout occurs before a batch is complete.\n\na|image::tickmark.png[]\na|\na|\n\n|[[batchReceiveTimeout]]<<batchReceiveTimeout,`batchReceiveTimeout`>> +\n(batch-receive-timeout)\n\n|The number of milliseconds of timeout for gathering batch messages.\nIt limits the time to wait to fill batchSize.\nWhen `batchSize > 1` and the time to gathering batch messages is greater than `batchReceiveTime`, batch will be delivered.\nDefault is 0 (no timeout).\n\na|image::tickmark.png[]\na|\na|\n\n|[[recoveryBackOff]]<<recoveryBackOff,`recoveryBackOff`>> +\n(recovery-back-off)\n\n|Specifies the `BackOff` for intervals between attempts to start a consumer if it fails to start for non-fatal reasons.\nDefault is `FixedBackOff` with unlimited retries every five seconds.\nMutually exclusive with `recoveryInterval`.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[recoveryInterval]]<<recoveryInterval,`recoveryInterval`>> +\n(recovery-interval)\n\n|Determines the time in milliseconds between attempts to start a consumer if it fails to start for non-fatal reasons.\nDefault: 5000.\nMutually exclusive with `recoveryBackOff`.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[retryDeclarationInterval]]<<retryDeclarationInterval,`retryDeclarationInterval`>> +\n(missing-queue-\nretry-interval)\n\n|If a subset of the configured queues are available during consumer initialization, the consumer starts consuming from those queues.\nThe consumer tries to passively declare the missing queues by using this interval.\nWhen this interval elapses, the 'declarationRetries' and 'failedDeclarationRetryInterval' is used again.\nIf there are still missing queues, the consumer again waits for this interval before trying again.\nThis process continues indefinitely until all queues are available.\nDefault: 60000 (one minute).\n\na|image::tickmark.png[]\na|\na|\n\n|[[shutdownTimeout]]<<shutdownTimeout,`shutdownTimeout`>> +\n(N/A)\n\n|When a container shuts down (for example,\nif its enclosing `ApplicationContext` is closed), it waits for in-flight messages to be processed up to this limit.\nDefaults to five seconds.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[startConsumerMinInterval]]<<startConsumerMinInterval,`startConsumerMinInterval`>> +\n(min-start-interval)\n\n|The time in milliseconds that must elapse before each new consumer is started on demand.\nSee xref:amqp/listener-concurrency.adoc#listener-concurrency[Listener Concurrency].\nDefault: 10000 (10 seconds).\n\na|image::tickmark.png[]\na|\na|\n\n|[[statefulRetryFatal]]<<statefulRetryFatal,`statefulRetryFatal`>> +\nWithNullMessageId\n(N/A)\n\n|When using a stateful retry advice, if a message with a missing `messageId` property is received, it is considered\nfatal for the consumer (it is stopped) by default.\nSet this to `false` to discard (or route to a dead-letter queue) such messages.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[stopConsumerMinInterval]]<<stopConsumerMinInterval,`stopConsumerMinInterval`>> +\n(min-stop-interval)\n\n|The time in milliseconds that must elapse before a consumer is stopped since the last consumer was stopped when an idle consumer is detected.\nSee xref:amqp/listener-concurrency.adoc#listener-concurrency[Listener Concurrency].\nDefault: 60000 (one minute).\n\na|image::tickmark.png[]\na|\na|\n\n|[[streamConverter]]<<streamConverter,`streamConverter`>> +\n(N/A)\n\n|A `StreamMessageConverter` to convert a native Stream message to a Spring AMQP message.\n\na|\na|\na|image::tickmark.png[]\n\n|[[taskExecutor]]<<taskExecutor,`taskExecutor`>> +\n(task-executor)\n\n|A reference to a Spring `TaskExecutor` (or standard JDK 1.5+ `Executor`) for executing listener invokers.\nDefault is a `SimpleAsyncTaskExecutor`, using internally managed threads.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n\n|[[taskScheduler]]<<taskScheduler,`taskScheduler`>> +\n(task-scheduler)\n\n|With the DMLC, the scheduler used to run the monitor task at the 'monitorInterval'.\n\na|\na|image::tickmark.png[]\na|\n\n|[[transactionManager]]<<transactionManager,`transactionManager`>> +\n(transaction-manager)\n\n|External transaction manager for the operation of the listener.\nAlso complementary to `channelTransacted` -- if the `Channel` is transacted, its transaction is synchronized with the external transaction.\n\na|image::tickmark.png[]\na|image::tickmark.png[]\na|\n|===", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/containerAttributes.adoc", "title": "containerAttributes", "heading": "containerAttributes", "heading_level": 1, "file_order": 33, "section_index": 0, "content_hash": "eedace14501a8002d66bdaadbada7d2dde53d0aa981472b5cc0b75ebcffb404d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/containerAttributes.adoc"}}
{"id": "sha256:cdc0b97e349e5acbb10bd885e146201c3b3571b64807f1c9dcbbac60cb84de65", "content": "[[containers-and-broker-named-queues]]\n\nWhile it is preferable to use `AnonymousQueue` instances as auto-delete queues, starting with version 2.1, you can use broker named queues with listener containers.\nThe following example shows how to do so:\n\n[source, java]\n----\n@Bean\npublic Queue queue() {\n return new Queue(\"\", false, true, true);\n}\n\n@Bean\npublic SimpleMessageListenerContainer container() {\n SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(cf());\n container.setQueues(queue());\n container.setMessageListener(m -> {\n ...\n });\n container.setMissingQueuesFatal(false);\n return container;\n}\n----\n\nNotice the empty `String` for the name.\nWhen the `RabbitAdmin` declares queues, it updates the `Queue.actualName` property with the name returned by the broker.\nYou must use `setQueues()` when you configure the container for this to work, so that the container can access the declared name at runtime.\nJust setting the names is insufficient.\n\nNOTE: You cannot add broker-named queues to the containers while they are running.\n\nIMPORTANT: When a connection is reset and a new one is established, the new queue gets a new name.\nSince there is a race condition between the container restarting and the queue being re-declared, it is important to set the container's `missingQueuesFatal` property to `false`, since the container is likely to initially try to reconnect to the old queue.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/containers-and-broker-named-queues.adoc", "title": "containers-and-broker-named-queues", "heading": "containers-and-broker-named-queues", "heading_level": 1, "file_order": 34, "section_index": 0, "content_hash": "cdc0b97e349e5acbb10bd885e146201c3b3571b64807f1c9dcbbac60cb84de65", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/containers-and-broker-named-queues.adoc"}}
{"id": "sha256:3c7e38475caf725d3d9348b121abba1bf1012ef138b9909879c2ca43ad4a5d06", "content": "[[custom-client-props]]\n\nThe `CachingConnectionFactory` now lets you access the underlying connection factory to allow, for example,\nsetting custom client properties.\nThe following example shows how to do so:\n\n[source, java]\n----\nconnectionFactory.getRabbitConnectionFactory().getClientProperties().put(\"thing1\", \"thing2\");\n----\n\nThese properties appear in the RabbitMQ Admin UI when viewing the connection.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/custom-client-props.adoc", "title": "custom-client-props", "heading": "custom-client-props", "heading_level": 1, "file_order": 35, "section_index": 0, "content_hash": "3c7e38475caf725d3d9348b121abba1bf1012ef138b9909879c2ca43ad4a5d06", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/custom-client-props.adoc"}}
{"id": "sha256:f6b3b807bb02271e8921349588e3de0b0c61f15d20a6f20d71958f8f5e10b5c5", "content": "[[debugging]]\n\nSpring AMQP provides extensive logging, especially at the `DEBUG` level.\n\nIf you wish to monitor the AMQP protocol between the application and broker, you can use a tool such as WireShark, which has a plugin to decode the protocol.\nAlternatively, the RabbitMQ Java client comes with a very useful class called `Tracer`.\nWhen run as a `main`, by default, it listens on port 5673 and connects to port 5672 on localhost.\nYou can run it and change your connection factory configuration to connect to port 5673 on localhost.\nIt displays the decoded protocol on the console.\nRefer to the `Tracer` Javadoc for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/debugging.adoc", "title": "debugging", "heading": "debugging", "heading_level": 1, "file_order": 36, "section_index": 0, "content_hash": "f6b3b807bb02271e8921349588e3de0b0c61f15d20a6f20d71958f8f5e10b5c5", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/debugging.adoc"}}
{"id": "sha256:ce798ff3d3bf613e9eabbb4e7ae5b820fd719a5890b8a52dd0d56adf0260c5c3", "content": "[[delayed-message-exchange]]\n\nVersion 1.6 introduces support for the\nhttps://www.rabbitmq.com/blog/2015/04/16/scheduling-messages-with-rabbitmq/[Delayed Message Exchange Plugin]\n\nNOTE: The plugin is currently marked as experimental but has been available for over a year (at the time of writing).\nIf changes to the plugin make it necessary, we plan to add support for such changes as soon as practical.\nFor that reason, this support in Spring AMQP should be considered experimental, too.\nThis functionality was tested with RabbitMQ 3.6.0 and version 0.0.1 of the plugin.\n\nTo use a `RabbitAdmin` to declare an exchange as delayed, you can set the `delayed` property on the exchange bean to\n`true`.\nThe `RabbitAdmin` uses the exchange type (`Direct`, `Fanout`, and so on) to set the `x-delayed-type` argument and\ndeclare the exchange with type `x-delayed-message`.\n\nThe `delayed` property (default: `false`) is also available when configuring exchange beans using XML.\nThe following example shows how to use it:\n\n[source, xml]\n----\n<rabbit:topic-exchange name=\"topic\" delayed=\"true\" />\n----\n\nTo send a delayed message, you can set the `x-delay` header through `MessageProperties`, as the following examples show:\n\n[source, java]\n----\nMessageProperties properties = new MessageProperties();\nproperties.setDelay(15000);\ntemplate.send(exchange, routingKey,\n MessageBuilder.withBody(\"foo\".getBytes()).andProperties(properties).build());\n----\n\n[source, java]\n----\nrabbitTemplate.convertAndSend(exchange, routingKey, \"foo\", new MessagePostProcessor() {\n\n @Override\n public Message postProcessMessage(Message message) throws AmqpException {\n message.getMessageProperties().setDelay(15000);\n return message;\n }\n\n});\n----\n\nTo check if a message was delayed, use the `getReceivedDelay()` method on the `MessageProperties`.\nIt is a separate property to avoid unintended propagation to an output message generated from an input message.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/delayed-message-exchange.adoc", "title": "delayed-message-exchange", "heading": "delayed-message-exchange", "heading_level": 1, "file_order": 37, "section_index": 0, "content_hash": "ce798ff3d3bf613e9eabbb4e7ae5b820fd719a5890b8a52dd0d56adf0260c5c3", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/delayed-message-exchange.adoc"}}
{"id": "sha256:05bff7a9446e70427b015e0e5df81abec33ea50ecbc42e48d91de7f883367b3b", "content": "[[exception-handling]]\n\nMany operations with the RabbitMQ Java client can throw checked exceptions.\nFor example, there are a lot of cases where `IOException` instances may be thrown.\nThe `RabbitTemplate`, `SimpleMessageListenerContainer`, and other Spring AMQP components catch those exceptions and convert them into one of the exceptions within `AmqpException` hierarchy.\nThose are defined in the 'org.springframework.amqp' package, and `AmqpException` is the base of the hierarchy.\n\nWhen a listener throws an exception, it is wrapped in a `ListenerExecutionFailedException`.\nNormally the message is rejected and requeued by the broker.\nSetting `defaultRequeueRejected` to `false` causes messages to be discarded (or routed to a dead letter exchange).\nAs discussed in xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#async-listeners[Message Listeners and the Asynchronous Case], the listener can throw an `AmqpRejectAndDontRequeueException` (or `ImmediateRequeueAmqpException`) to conditionally control this behavior.\n\nHowever, there is a class of errors where the listener cannot control the behavior.\nWhen a message that cannot be converted is encountered (for example, an invalid `content_encoding` header), some exceptions are thrown before the message reaches user code.\nWith `defaultRequeueRejected` set to `true` (default) (or throwing an `ImmediateRequeueAmqpException`), such messages would be redelivered over and over.\nBefore version 1.3.2, users needed to write a custom `ErrorHandler`, as discussed in xref:amqp/exception-handling.adoc[Exception Handling], to avoid this situation.\n\nStarting with version 1.3.2, the default `ErrorHandler` is now a `ConditionalRejectingErrorHandler` that rejects (and does not requeue) messages that fail with an irrecoverable error.\nSpecifically, it rejects messages that fail with the following errors:\n\n* `o.s.amqp...MessageConversionException`: Can be thrown when converting the incoming message payload using a `MessageConverter`.\n* `o.s.messaging...MessageConversionException`: Can be thrown by the conversion service if additional conversion is required when mapping to a `@RabbitListener` method.\n* `o.s.messaging...MethodArgumentNotValidException`: Can be thrown if validation (for example, `@Valid`) is used in the listener and the validation fails.\n* `o.s.messaging...MethodArgumentTypeMismatchException`: Can be thrown if the inbound message was converted to a type that is not correct for the target method.\nFor example, the parameter is declared as `Message<Foo>` but `Message<Bar>` is received.\n* `java.lang.NoSuchMethodException`: Added in version 1.6.3.\n* `java.lang.ClassCastException`: Added in version 1.6.3.\n\nYou can configure an instance of this error handler with a `FatalExceptionStrategy` so that users can provide their own rules for conditional message rejection -- for example, a delegate implementation to the `BinaryExceptionClassifier` from Spring Retry (xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#async-listeners[Message Listeners and the Asynchronous Case]).\nIn addition, the `ListenerExecutionFailedException` now has a `failedMessage` property that you can use in the decision.\nIf the `FatalExceptionStrategy.isFatal()` method returns `true`, the error handler throws an `AmqpRejectAndDontRequeueException`.\nThe default `FatalExceptionStrategy` logs a warning message when an exception is determined to be fatal.\n\nSince version 1.6.3, a convenient way to add user exceptions to the fatal list is to subclass `ConditionalRejectingErrorHandler.DefaultExceptionStrategy` and override the `isUserCauseFatal(Throwable cause)` method to return `true` for fatal exceptions.\n\nA common pattern for handling DLQ messages is to set a `time-to-live` on those messages as well as additional DLQ configuration such that these messages expire and are routed back to the main queue for retry.\nThe problem with this technique is that messages that cause fatal exceptions loop forever.\nStarting with version 2.1, the `ConditionalRejectingErrorHandler` detects an `x-death` header on a message that causes a fatal exception to be thrown.\nThe message is logged and discarded.\nYou can revert to the previous behavior by setting the `discardFatalsWithXDeath` property on the `ConditionalRejectingErrorHandler` to `false`.\n\nIMPORTANT: Starting with version 2.1.9, messages with these fatal exceptions are rejected and NOT requeued by default, even if the container acknowledge mode is MANUAL.\nThese exceptions generally occur before the listener is invoked so the listener does not have a chance to ack or nack the message so it remained in the queue in an un-acked state.\nTo revert to the previous behavior, set the `rejectManual` property on the `ConditionalRejectingErrorHandler` to `false`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/exception-handling.adoc", "title": "exception-handling", "heading": "exception-handling", "heading_level": 1, "file_order": 38, "section_index": 0, "content_hash": "05bff7a9446e70427b015e0e5df81abec33ea50ecbc42e48d91de7f883367b3b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/exception-handling.adoc"}}
{"id": "sha256:adc2af437b2b16e17ab84e8eb06bd6b860c0f34381f3d650e28e94b693876bb2", "content": "[[exclusive-consumer]]\n\nStarting with version 1.3, you can configure the listener container with a single exclusive consumer.\nThis prevents other containers from consuming from the queues until the current consumer is cancelled.\nThe concurrency of such a container must be `1`.\n\nWhen using exclusive consumers, other containers try to consume from the queues according to the `recoveryInterval` property and log a `WARN` message if the attempt fails.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/exclusive-consumer.adoc", "title": "exclusive-consumer", "heading": "exclusive-consumer", "heading_level": 1, "file_order": 39, "section_index": 0, "content_hash": "adc2af437b2b16e17ab84e8eb06bd6b860c0f34381f3d650e28e94b693876bb2", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/exclusive-consumer.adoc"}}
{"id": "sha256:2b207acdb6563fcf8ee946b8558ae30f7d3cb279fde09cfa355b32ec17f6b1b7", "content": "[[listener-concurrency]]\n\n[[simplemessagelistenercontainer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/listener-concurrency.adoc", "title": "listener-concurrency", "heading": "listener-concurrency", "heading_level": 1, "file_order": 40, "section_index": 0, "content_hash": "2b207acdb6563fcf8ee946b8558ae30f7d3cb279fde09cfa355b32ec17f6b1b7", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/listener-concurrency.adoc"}}
{"id": "sha256:e55db7ddd545f59837472afafdec36b8513cd1a422616c75fb364c3a03e490ce", "content": "By default, the listener container starts a single consumer that receives messages from the queues.\n\nWhen examining the table in the previous section, you can see a number of properties and attributes that control concurrency.\nThe simplest is `concurrentConsumers`, which creates that (fixed) number of consumers that concurrently process messages.\n\nPrior to version 1.3.0, this was the only setting available and the container had to be stopped and started again to change the setting.\n\nSince version 1.3.0, you can now dynamically adjust the `concurrentConsumers` property.\nIf it is changed while the container is running, consumers are added or removed as necessary to adjust to the new setting.\n\nIn addition, a new property called `maxConcurrentConsumers` has been added and the container dynamically adjusts the concurrency based on workload.\nThis works in conjunction with four additional properties: `consecutiveActiveTrigger`, `startConsumerMinInterval`, `consecutiveIdleTrigger`, and `stopConsumerMinInterval`.\nWith the default settings, the algorithm to increase consumers works as follows:\n\nIf the `maxConcurrentConsumers` has not been reached and an existing consumer is active for ten consecutive cycles AND at least 10 seconds has elapsed since the last consumer was started, a new consumer is started.\nA consumer is considered active if it received at least one message in `batchSize` * `receiveTimeout` milliseconds.\n\nWith the default settings, the algorithm to decrease consumers works as follows:\n\nIf there are more than `concurrentConsumers` running and a consumer detects ten consecutive timeouts (idle) AND the last consumer was stopped at least 60 seconds ago, a consumer is stopped.\nThe timeout depends on the `receiveTimeout` and the `batchSize` properties.\nA consumer is considered idle if it receives no messages in `batchSize` * `receiveTimeout` milliseconds.\nSo, with the default timeout (one second) and a `batchSize` of four, stopping a consumer is considered after 40 seconds of idle time (four timeouts correspond to one idle detection).\n\nNOTE: Practically, consumers can be stopped only if the whole container is idle for some time.\nThis is because the broker shares its work across all the active consumers.\n\nEach consumer uses a single channel, regardless of the number of configured queues.\n\nStarting with version 2.0, the `concurrentConsumers` and `maxConcurrentConsumers` properties can be set with the `concurrency` property -- for example, `2-4`.\n\n[[using-directmessagelistenercontainer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/listener-concurrency.adoc", "title": "listener-concurrency", "heading": "SimpleMessageListenerContainer", "heading_level": 2, "file_order": 40, "section_index": 1, "content_hash": "e55db7ddd545f59837472afafdec36b8513cd1a422616c75fb364c3a03e490ce", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/listener-concurrency.adoc"}}
{"id": "sha256:4f973628cd99972737606b7e328988a0a4559c71da5637c935d460fac380afae", "content": "With this container, concurrency is based on the configured queues and `consumersPerQueue`.\nEach consumer for each queue uses a separate channel, and the concurrency is controlled by the rabbit client library.\nBy default, at the time of writing, it uses a pool of `DEFAULT_NUM_THREADS = Runtime.getRuntime().availableProcessors() * 2` threads.\n\nYou can configure a `taskExecutor` to provide the required maximum concurrency.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/listener-concurrency.adoc", "title": "listener-concurrency", "heading": "Using `DirectMessageListenerContainer`", "heading_level": 2, "file_order": 40, "section_index": 2, "content_hash": "4f973628cd99972737606b7e328988a0a4559c71da5637c935d460fac380afae", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/listener-concurrency.adoc"}}
{"id": "sha256:d798963b24f3841318e5c2b74acb1686e52f3ad12d963998426507bf9cec2958", "content": "[[listener-queues]]\n\nVersion 1.3 introduced a number of improvements for handling multiple queues in a listener container.\n\nContainer can be initially configured to listen on zero queues.\nQueues can be added and removed at runtime.\nThe `SimpleMessageListenerContainer` recycles (cancels and re-creates) all consumers when any pre-fetched messages have been processed.\nThe `DirectMessageListenerContainer` creates/cancels individual consumer(s) for each queue without affecting consumers on other queues.\nSee the javadoc:org.springframework.amqp.rabbit.listener.AbstractMessageListenerContainer[Javadoc] for the `addQueues`, `addQueueNames`, `removeQueues` and `removeQueueNames` methods.\n\nIf not all queues are available, the container tries to passively declare (and consume from) the missing queues every 60 seconds.\n\nAlso, if a consumer receives a cancel from the broker (for example, if a queue is deleted) the consumer tries to recover, and the recovered consumer continues to process messages from any other configured queues.\nPreviously, a cancel on one queue cancelled the entire consumer and, eventually, the container would stop due to the missing queue.\n\nIf you wish to permanently remove a queue, you should update the container before or after deleting to queue, to avoid future attempts trying to consume from it.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/listener-queues.adoc", "title": "listener-queues", "heading": "listener-queues", "heading_level": 1, "file_order": 41, "section_index": 0, "content_hash": "d798963b24f3841318e5c2b74acb1686e52f3ad12d963998426507bf9cec2958", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/listener-queues.adoc"}}
{"id": "sha256:30d547bfbca63205a351d49bde4137941679fa75df7885d2c9ff7367c8e12bc9", "content": "[[management-rest-api]]\n\nWhen the management plugin is enabled, the RabbitMQ server exposes a REST API to monitor and configure the broker.\nA {rabbitmq-github}/hop[Java Binding for the API] is now provided.\nThe `com.rabbitmq.http.client.Client` is a standard, immediate, and, therefore, blocking API.\nIt is based on the {spring-framework-docs}/web.html[Spring Web] module and its `RestTemplate` implementation.\nOn the other hand, the `com.rabbitmq.http.client.ReactorNettyClient` is a reactive, non-blocking implementation based on the https://projectreactor.io/docs/netty/release/reference/docs/index.html[Reactor Netty] project.\n\nAlso, the https://www.rabbitmq.com/docs/management#http-api-endpoints[management REST API] can be used with any HTTP client.\nThe next example demonstrates how to get a queue information using {spring-framework-docs}/web/webflux-webclient.html[WebClient]:\n\n[source,java]\n----\n\tpublic Map<String, Object> queueInfo(String queueName) throws URISyntaxException {\n WebClient client = createClient(\"admin\", \"admin\");\n URI uri = queueUri(queueName);\n return client.get()\n .uri(uri)\n .accept(MediaType.APPLICATION_JSON)\n .retrieve()\n .bodyToMono(new ParameterizedTypeReference<Map<String, Object>>() {\n })\n .block(Duration.ofSeconds(10));\n\t}\n\n\tprivate URI queueUri(String queue) throws URISyntaxException {\n URI uri = new URI(\"http://localhost:15672/api/\")\n .resolve(\"/api/queues/\" + UriUtils.encodePathSegment(\"/\", StandardCharsets.UTF_8) + \"/\" + queue);\n return uri;\n\t}\n\n\tprivate WebClient createClient(String adminUser, String adminPassword) {\n return WebClient.builder()\n .filter(ExchangeFilterFunctions.basicAuthentication(adminUser, adminPassword))\n .build();\n\t}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/management-rest-api.adoc", "title": "management-rest-api", "heading": "management-rest-api", "heading_level": 1, "file_order": 42, "section_index": 0, "content_hash": "30d547bfbca63205a351d49bde4137941679fa75df7885d2c9ff7367c8e12bc9", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/management-rest-api.adoc"}}
{"id": "sha256:c915057ccb72151c59400def054807d55d6b6517986438b3507ac5d200891520", "content": "[[message-converters]]\n\nThe `AmqpTemplate` also defines several methods for sending and receiving messages that delegate to a `MessageConverter`.\nThe `MessageConverter` provides a single method for each direction: one for converting *to* a `Message` and another for converting *from* a `Message`.\nNotice that, when converting to a `Message`, you can also provide properties in addition to the object.\nThe `object` parameter typically corresponds to the Message body.\nThe following listing shows the `MessageConverter` interface definition:\n\n[source,java]\n----\npublic interface MessageConverter {\n\n Message toMessage(Object object, MessageProperties messageProperties)\n throws MessageConversionException;\n\n Object fromMessage(Message message) throws MessageConversionException;\n\n}\n----\n\nThe relevant `Message`-sending methods on the `AmqpTemplate` are simpler than the methods we discussed previously, because they do not require the `Message` instance.\nInstead, the `MessageConverter` is responsible for \"`creating`\" each `Message` by converting the provided object to the byte array for the `Message` body and then adding any provided `MessageProperties`.\nThe following listing shows the definitions of the various methods:\n\n[source,java]\n----\nvoid convertAndSend(Object message) throws AmqpException;\n\nvoid convertAndSend(String routingKey, Object message) throws AmqpException;\n\nvoid convertAndSend(String exchange, String routingKey, Object message)\n throws AmqpException;\n\nvoid convertAndSend(Object message, MessagePostProcessor messagePostProcessor)\n throws AmqpException;\n\nvoid convertAndSend(String routingKey, Object message,\n MessagePostProcessor messagePostProcessor) throws AmqpException;\n\nvoid convertAndSend(String exchange, String routingKey, Object message,\n MessagePostProcessor messagePostProcessor) throws AmqpException;\n----\n\nOn the receiving side, there are only two methods: one that accepts the queue name and one that relies on the template's \"`queue`\" property having been set.\nThe following listing shows the definitions of the two methods:\n\n[source,java]\n----\nObject receiveAndConvert() throws AmqpException;\n\nObject receiveAndConvert(String queueName) throws AmqpException;\n----\n\nNOTE: The `MessageListenerAdapter` mentioned in xref:amqp/receiving-messages/async-consumer.adoc[Asynchronous Consumer] also uses a `MessageConverter`.\n\n[[simple-message-converter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "message-converters", "heading_level": 1, "file_order": 43, "section_index": 0, "content_hash": "c915057ccb72151c59400def054807d55d6b6517986438b3507ac5d200891520", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:cf99c8d7ac7d4cf84778d3dfe75581a64176e71b0f3ed009b9a7a5d4a503beea", "content": "The default implementation of the `MessageConverter` strategy is called `SimpleMessageConverter`.\nThis is the converter that is used by an instance of `RabbitTemplate` if you do not explicitly configure an alternative.\nIt handles text-based content, serialized Java objects, and byte arrays.\n\n[[converting-from-a-message]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "`SimpleMessageConverter`", "heading_level": 2, "file_order": 43, "section_index": 1, "content_hash": "cf99c8d7ac7d4cf84778d3dfe75581a64176e71b0f3ed009b9a7a5d4a503beea", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:24a5985cf5f7db23539a30b8e6d065e090225e38f40a6cb93877bdf7abbba407", "content": "If the content type of the input `Message` begins with \"text\" (for example,\n\"text/plain\"), it also checks for the content-encoding property to determine the charset to be used when converting the `Message` body byte array to a Java `String`.\nIf no content-encoding property had been set on the input `Message`, it uses the UTF-8 charset by default.\nIf you need to override that default setting, you can configure an instance of `SimpleMessageConverter`, set its `defaultCharset` property, and inject that into a `RabbitTemplate` instance.\n\nIf the content-type property value of the input `Message` is set to \"application/x-java-serialized-object\", the `SimpleMessageConverter` tries to deserialize (rehydrate) the byte array into a Java object.\nWhile that might be useful for simple prototyping, we do not recommend relying on Java serialization, since it leads to tight coupling between the producer and the consumer.\nOf course, it also rules out usage of non-Java systems on either side.\nWith AMQP being a wire-level protocol, it would be unfortunate to lose much of that advantage with such restrictions.\nIn the next two sections, we explore some alternatives for passing rich domain object content without relying on Java serialization.\n\nFor all other content-types, the `SimpleMessageConverter` returns the `Message` body content directly as a byte array.\n\nSee <<java-deserialization>> for important information.\n\n[[converting-to-a-message]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "Converting From a `Message`", "heading_level": 3, "file_order": 43, "section_index": 2, "content_hash": "24a5985cf5f7db23539a30b8e6d065e090225e38f40a6cb93877bdf7abbba407", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:2d106571e63b4c66855b5c1f4147928d78026c81f7d990a24ca99f6ae93b0402", "content": "When converting to a `Message` from an arbitrary Java Object, the `SimpleMessageConverter` likewise deals with byte arrays, strings, and serializable instances.\nIt converts each of these to bytes (in the case of byte arrays, there is nothing to convert), and it sets the content-type property accordingly.\nIf the `Object` to be converted does not match one of those types, the `Message` body is null.\n\n[[serializer-message-converter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "Converting To a `Message`", "heading_level": 3, "file_order": 43, "section_index": 3, "content_hash": "2d106571e63b4c66855b5c1f4147928d78026c81f7d990a24ca99f6ae93b0402", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:90c1c938a654a15eb3429f6900e5a4723db602ec69f5aeaa68632e8516b4f440", "content": "This converter is similar to the `SimpleMessageConverter` except that it can be configured with other Spring Framework\n`Serializer` and `Deserializer` implementations for `application/x-java-serialized-object` conversions.\n\nSee <<java-deserialization>> for important information.\n\n[[json-message-converter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "`SerializerMessageConverter`", "heading_level": 2, "file_order": 43, "section_index": 4, "content_hash": "90c1c938a654a15eb3429f6900e5a4723db602ec69f5aeaa68632e8516b4f440", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:5c1f1a604ebf023bd28787c644cfac05799d490156bc177941ca58f49277950a", "content": "This section covers using the `JacksonJsonMessageConverter` to convert to and from a `Message`.\nIt has the following sections:\n\n* xref:amqp/message-converters.adoc#JacksonJsonMessageConverter-to-message[Converting to a `Message`]\n* xref:amqp/message-converters.adoc#JacksonJsonMessageConverter-from-message[Converting from a `Message`]\n\nNOTE: The `AbstractJackson2MessageConverter`, its implementations and related `Jackson2JavaTypeMapper` API have been deprecated for removal in `4.0` version in favor of respective classes based on Jackson 3.\nSee JavaDocs of the deprecated classes for the respective migration guide.\n\n[[JacksonJsonMessageConverter-to-message]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "JacksonJsonMessageConverter", "heading_level": 2, "file_order": 43, "section_index": 5, "content_hash": "5c1f1a604ebf023bd28787c644cfac05799d490156bc177941ca58f49277950a", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:8dc80140e1a369ec1d2f53d6511952ae85714ff4e5a19b9cddf8988260cb71b1", "content": "As mentioned in the previous section, relying on Java serialization is generally not recommended.\nOne rather common alternative that is more flexible and portable across different languages and platforms is JSON (JavaScript Object Notation).\nThe converter can be configured on any `RabbitTemplate` instance to override its usage of the `SimpleMessageConverter` default.\nThe `JacksonJsonMessageConverter` uses the Jackson 3.x library.\nThe following example configures a `JacksonJsonMessageConverter`:\n\n[source,xml]\n----\n<bean class=\"org.springframework.amqp.rabbit.core.RabbitTemplate\">\n <property name=\"connectionFactory\" ref=\"rabbitConnectionFactory\"/>\n <property name=\"messageConverter\">\n <bean class=\"org.springframework.amqp.support.converter.JacksonJsonMessageConverter\">\n <!-- if necessary, override the DefaultClassMapper -->\n <property name=\"classMapper\" ref=\"customClassMapper\"/>\n </bean>\n </property>\n</bean>\n----\n\nAs shown above, `JacksonJsonMessageConverter` uses a `DefaultClassMapper` by default.\nType information is added to (and retrieved from) `MessageProperties`.\nIf an inbound message does not contain type information in `MessageProperties`, but you know the expected type, you can configure a static type by using the `defaultType` property, as the following example shows:\n\n[source,xml]\n----\n<bean id=\"jsonConverterWithDefaultType\"\n class=\"o.s.amqp.support.converter.JacksonJsonMessageConverter\">\n <property name=\"classMapper\">\n <bean class=\"org.springframework.amqp.support.converter.DefaultClassMapper\">\n <property name=\"defaultType\" value=\"thing1.PurchaseOrder\"/>\n </bean>\n </property>\n</bean>\n----\n\nIn addition, you can provide custom mappings from the value in the `__TypeId__` header.\nThe following example shows how to do so:\n\n[source, java]\n----\n@Bean\npublic JacksonJsonMessageConverter jsonMessageConverter() {\n JacksonJsonMessageConverter jsonConverter = new JacksonJsonMessageConverter();\n jsonConverter.setClassMapper(classMapper());\n return jsonConverter;\n}\n\n@Bean\npublic DefaultClassMapper classMapper() {\n DefaultClassMapper classMapper = new DefaultClassMapper();\n Map<String, Class<?>> idClassMapping = new HashMap<>();\n idClassMapping.put(\"thing1\", Thing1.class);\n idClassMapping.put(\"thing2\", Thing2.class);\n classMapper.setIdClassMapping(idClassMapping);\n return classMapper;\n}\n----\n\nNow, if the sending system sets the header to `thing1`, the converter creates a `Thing1` object, and so on.\nSee the xref:sample-apps.adoc#spring-rabbit-json[Receiving JSON from Non-Spring Applications] sample application for a complete discussion about converting messages from non-Spring applications.\n\nStarting with version 2.4.3, the converter will not add a `contentEncoding` message property if the `supportedMediaType` has a `charset` parameter; this is also used for the encoding.\nA new method `setSupportedMediaType` has been added:\n\n[source, java]\n----\nString utf16 = \"application/json; charset=utf-16\";\nconverter.setSupportedContentType(MimeTypeUtils.parseMimeType(utf16));\n----\n\n[[JacksonJsonMessageConverter-from-message]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "Converting to a `Message`", "heading_level": 3, "file_order": 43, "section_index": 6, "content_hash": "8dc80140e1a369ec1d2f53d6511952ae85714ff4e5a19b9cddf8988260cb71b1", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:e7f2fd60277f944b78896fa600661242742f622b917054700938474a3d4cfb98", "content": "Inbound messages are converted to objects according to the type information added to headers by the sending system.\n\nStarting with version 2.4.3, if there is no `contentEncoding` message property, the converter will attempt to detect a `charset` parameter in the `contentType` message property and use that.\nIf neither exist, if the `supportedMediaType` has a `charset` parameter, it will be used for decoding, with a final fallback to the `defaultCharset` property.\nA new method `setSupportedMediaType` has been added:\n\n[source, java]\n----\nString utf16 = \"application/json; charset=utf-16\";\nconverter.setSupportedContentType(MimeTypeUtils.parseMimeType(utf16));\n----\n\nIn versions prior to 1.6, if type information is not present, conversion would fail.\nStarting with version 1.6, if type information is missing, the converter converts the JSON by using Jackson defaults (usually a map).\n\nAlso, starting with version 1.6, when you use `@RabbitListener` annotations (on methods), the inferred type information is added to the `MessageProperties`.\nThis lets the converter convert to the argument type of the target method.\nThis only applies if there is one parameter with no annotations or a single parameter with the `@Payload` annotation.\nParameters of type `Message` are ignored during the analysis.\n\nIMPORTANT: By default, the inferred type information will override the inbound `__TypeId__` and related headers created by the sending system.\nThis lets the receiving system automatically convert to a different domain object.\nThis applies only if the parameter type is concrete (not abstract or an interface), or it is from the `java.util` package.\nIn all other cases, the `__TypeId__` and related headers is used.\nThere are cases where you might wish to override the default behavior and always use the `__TypeId__` information.\nFor example, suppose you have a `@RabbitListener` that takes a `Thing1` argument but the message contains a `Thing2` that is a subclass of `Thing1` (which is concrete).\nThe inferred type would be incorrect.\nTo handle this situation, set the `TypePrecedence` property on the `JacksonJsonMessageConverter` to `TYPE_ID` instead of the default `INFERRED`.\n(The property is actually on the converter's `DefaultJacksonJavaTypeMapper`, but a setter is provided on the converter for convenience.)\nIf you inject a custom type mapper, you should set the property on the mapper instead.\n\nNOTE: When converting from the `Message`, an incoming `MessageProperties.getContentType()` must be JSON-compliant (`contentType.contains(\"json\")` is used to check).\nStarting with version 2.2, `application/json` is assumed if there is no `contentType` property, or it has the default value `application/octet-stream`.\nTo revert to the previous behavior (return an unconverted `byte[]`), set the converter's `assumeSupportedContentType` property to `false`.\nIf the content type is not supported, a `WARN` log message `Could not convert incoming message with content-type [...]`, is emitted and `message.getBody()` is returned as is -- as a `byte[]`.\nSo, to meet the `JacksonJsonMessageConverter` requirements on the consumer side, the producer must add the `contentType` message property -- for example, as `application/json` or `text/x-json` or by using the `JacksonJsonMessageConverter`, which sets the header automatically.\nThe following listing shows a number of converter calls:\n\n[source, java]\n----\n@RabbitListener\npublic void thing1(Thing1 thing1) {...}\n\n@RabbitListener\npublic void thing1(@Payload Thing1 thing1, @Header(\"amqp_consumerQueue\") String queue) {...}\n\n@RabbitListener\npublic void thing1(Thing1 thing1, o.s.amqp.core.Message message) {...}\n\n@RabbitListener\npublic void thing1(Thing1 thing1, o.s.messaging.Message<Foo> message) {...}\n\n@RabbitListener\npublic void thing1(Thing1 thing1, String bar) {...}\n\n@RabbitListener\npublic void thing1(Thing1 thing1, o.s.messaging.Message<?> message) {...}\n----\n\nIn the first four cases in the preceding listing, the converter tries to convert to the `Thing1` type.\nThe fifth example is invalid because we cannot determine which argument should receive the message payload.\nWith the sixth example, the Jackson defaults apply due to the generic type being a `WildcardType`.\n\nYou can, however, create a custom converter and use the `targetMethod` message property to decide which type to convert the JSON to.\n\nNOTE: This type inference can only be achieved when the `@RabbitListener` annotation is declared at the method level.\nWith class-level `@RabbitListener`, the converted type is used to select which `@RabbitHandler` method to invoke.\nFor this reason, the infrastructure provides the `targetObject` message property, which you can use in a custom converter to determine the type.\n\nIMPORTANT: Starting with version 1.6.11, `JacksonJsonMessageConverter` and, therefore, `DefaultJacksonJavaTypeMapper` (`DefaultClassMapper`) provide the `trustedPackages` option to overcome https://pivotal.io/security/cve-2017-4995[Serialization Gadgets] vulnerability.\nBy default, and for backward compatibility, the `JacksonJsonMessageConverter` trusts all packages -- that is, it uses `*` for the option.\n\nStarting with version 2.4.7, the converter can be configured to return `Optional.empty()` if Jackson returns `null` after deserializing the message body.\nThis facilitates `@RabbitListener` s to receive null payloads, in two ways:\n\n[source, java]\n----\n@RabbitListener(queues = \"op.1\")\nvoid listen(@Payload(required = false) Thing payload) {\n handleOptional(payload); // payload might be null\n}\n\n@RabbitListener(queues = \"op.2\")\nvoid listen(Optional<Thing> optional) {\n handleOptional(optional.orElse(this.emptyThing));\n}\n----\n\nTo enable this feature, set `setNullAsOptionalEmpty` to `true`; when `false` (default), the converter falls back to the raw message body (`byte[]`).\n\n[source, java]\n----\n@Bean\nJacksonJsonMessageConverter converter() {\n JacksonJsonMessageConverter converter = new JacksonJsonMessageConverter();\n converter.setNullAsOptionalEmpty(true);\n return converter;\n}\n----\n\n[[jackson-abstract]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "Converting from a `Message`", "heading_level": 3, "file_order": 43, "section_index": 7, "content_hash": "e7f2fd60277f944b78896fa600661242742f622b917054700938474a3d4cfb98", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:9cb8f5936f50687962f1a2002144e149e078322ced0d7109e93a687bf14fb1d2", "content": "Prior to version 2.2.8, if the inferred type of the `@RabbitListener` was an abstract class (including interfaces), the converter would fall back to looking for type information in the headers and, if present, used that information; if that was not present, it would try to create the abstract class.\nThis caused a problem when a custom `ObjectMapper` that is configured with a custom deserializer to handle the abstract class is used, but the incoming message has invalid type headers.\n\nStarting with version 2.2.8, the previous behavior is retained by default. If you have such a custom `ObjectMapper` and you want to ignore type headers, and always use the inferred type for conversion, set the `alwaysConvertToInferredType` to `true`.\nThis is needed for backwards compatibility and to avoid the overhead of an attempted conversion when it would fail (with a standard `ObjectMapper`).\n\n[[data-projection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "Deserializing Abstract Classes", "heading_level": 3, "file_order": 43, "section_index": 8, "content_hash": "9cb8f5936f50687962f1a2002144e149e078322ced0d7109e93a687bf14fb1d2", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:ed8c69889f0f7b35ea07486a51904b403b386e2b586a3dbcebe48e557ccfa791", "content": "Starting with version 2.2, you can convert JSON to a Spring Data Projection interface instead of a concrete type.\nThis allows very selective, and low-coupled bindings to data, including the lookup of values from multiple places inside the JSON document.\nFor example the following interface can be defined as message payload type:\n\n[source, java]\n----\ninterface SomeSample {\n\n @JsonPath({ \"$.username\", \"$.user.name\" })\n String getUsername();\n\n}\n----\n\n[source, java]\n----\n@RabbitListener(queues = \"projection\")\npublic void projection(SomeSample in) {\n String username = in.getUsername();\n ...\n}\n----\n\nAccessor methods will be used to lookup the property name as field in the received JSON document by default.\nThe `@JsonPath` expression allows customization of the value lookup, and even to define multiple JSON path expressions, to lookup values from multiple places until an expression returns an actual value.\n\nTo enable this feature, set the `useProjectionForInterfaces` to `true` on the message converter.\nYou must also add `spring-data:spring-data-commons` and `com.jayway.jsonpath:json-path` to the class path.\n\nWhen used as the parameter to a `@RabbitListener` method, the interface type is automatically passed to the converter as normal.\n\n[[json-complex]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "Using Spring Data Projection Interfaces", "heading_level": 3, "file_order": 43, "section_index": 9, "content_hash": "ed8c69889f0f7b35ea07486a51904b403b386e2b586a3dbcebe48e557ccfa791", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:f87691f09a4e5b2a43355b05d979305c1d4724fa9b81e560b495735215df3fe2", "content": "As mentioned earlier, type information is conveyed in message headers to assist the converter when converting from a message.\nThis works fine in most cases.\nHowever, when using generic types, it can only convert simple objects and known \"`container`\" objects (lists, arrays, and maps).\nStarting with version 2.0, the `JacksonJsonMessageConverter` implements `SmartMessageConverter`, which lets it be used with the new `RabbitTemplate` methods that take a `ParameterizedTypeReference` argument.\nThis allows conversion of complex generic types, as shown in the following example:\n\n[source, java]\n----\nThing1<Thing2<Cat, Hat>> thing1 =\n rabbitTemplate.receiveAndConvert(new ParameterizedTypeReference<Thing1<Thing2<Cat, Hat>>>() { });\n----\n\n[[marshallingmessageconverter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "Converting From a `Message` With `RabbitTemplate`", "heading_level": 3, "file_order": 43, "section_index": 10, "content_hash": "f87691f09a4e5b2a43355b05d979305c1d4724fa9b81e560b495735215df3fe2", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:162de13eb9d74b64b534103697c0e0859550c7c63fa360eeaf14388d306901a6", "content": "Yet another option is the `MarshallingMessageConverter`.\nIt delegates to the Spring OXM library's implementations of the `Marshaller` and `Unmarshaller` strategy interfaces.\nYou can read more about that library {spring-framework-docs}/data-access/oxm.html[here].\nIn terms of configuration, it is most common to provide only the constructor argument, since most implementations of `Marshaller` also implement `Unmarshaller`.\nThe following example shows how to configure a `MarshallingMessageConverter`:\n\n[source,xml]\n----\n<bean class=\"org.springframework.amqp.rabbit.core.RabbitTemplate\">\n <property name=\"connectionFactory\" ref=\"rabbitConnectionFactory\"/>\n <property name=\"messageConverter\">\n <bean class=\"org.springframework.amqp.support.converter.MarshallingMessageConverter\">\n <constructor-arg ref=\"someImplementationOfMarshallerAndUnmarshaller\"/>\n </bean>\n </property>\n</bean>\n----\n\n[[jackson-xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "`MarshallingMessageConverter`", "heading_level": 2, "file_order": 43, "section_index": 11, "content_hash": "162de13eb9d74b64b534103697c0e0859550c7c63fa360eeaf14388d306901a6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:1bde57eed83b8b4ec76dd50b3f56b7f7a149b0e63893c3e9163d3e435964367f", "content": "This class was introduced in version 2.1 and can be used to convert messages from and to XML.\n\nBoth `JacksonXmlMessageConverter` and `JacksonJsonMessageConverter` have the same base class: `AbstractJacksonMessageConverter`.\n\nThe `JacksonXmlMessageConverter` uses the Jackson 3.x library.\n\nYou can use it the same way as `JacksonJsonMessageConverter`, except it supports XML instead of JSON.\nThe following example configures a `JacksonJsonMessageConverter`:\n\n[source,xml]\n----\n<bean id=\"xmlConverterWithDefaultType\"\n class=\"org.springframework.amqp.support.converter.JacksonXmlMessageConverter\">\n <property name=\"classMapper\">\n <bean class=\"org.springframework.amqp.support.converter.DefaultClassMapper\">\n <property name=\"defaultType\" value=\"foo.PurchaseOrder\"/>\n </bean>\n </property>\n</bean>\n----\nSee <<json-message-converter>> for more information.\n\nNOTE: Starting with version 2.2, `application/xml` is assumed if there is no `contentType` property, or it has the default value `application/octet-stream`.\nTo revert to the previous behavior (return an unconverted `byte[]`), set the converter's `assumeSupportedContentType` property to `false`.\n\n[[contenttypedelegatingmessageconverter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "`JacksonXmlMessageConverter`", "heading_level": 2, "file_order": 43, "section_index": 12, "content_hash": "1bde57eed83b8b4ec76dd50b3f56b7f7a149b0e63893c3e9163d3e435964367f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:1bbb749ac58eaa7cdb63646a3776b5a038c600d0c3ee668d9e7b75aaaa612f01", "content": "This class was introduced in version 1.4.2 and allows delegation to a specific `MessageConverter` based on the content type property in the `MessageProperties`.\nBy default, it delegates to a `SimpleMessageConverter` if there is no `contentType` property or there is a value that matches none of the configured converters.\nThe following example configures a `ContentTypeDelegatingMessageConverter`:\n\n[source,xml]\n----\n<bean id=\"contentTypeConverter\" class=\"ContentTypeDelegatingMessageConverter\">\n <property name=\"delegates\">\n <map>\n <entry key=\"application/json\" value-ref=\"jsonMessageConverter\" />\n <entry key=\"application/xml\" value-ref=\"xmlMessageConverter\" />\n </map>\n </property>\n</bean>\n----\n\n[[java-deserialization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "`ContentTypeDelegatingMessageConverter`", "heading_level": 2, "file_order": 43, "section_index": 13, "content_hash": "1bbb749ac58eaa7cdb63646a3776b5a038c600d0c3ee668d9e7b75aaaa612f01", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:91e98081e43321464065d04e93d9e965398bea7de1617871b55630e150cd02b4", "content": "This section covers how to deserialize Java objects.\n\n[IMPORTANT]\n====\nThere is a possible vulnerability when deserializing java objects from untrusted sources.\n\nIf you accept messages from untrusted sources with a `content-type` of `application/x-java-serialized-object`, you should\nconsider configuring which packages and classes are allowed to be deserialized.\nThis applies to both the `SimpleMessageConverter` and `SerializerMessageConverter` when it is configured to use a\n`DefaultDeserializer` either implicitly or via configuration.\n\nBy default, the allowed list is empty, meaning no classes will be deserialized.\n\nYou can set a list of patterns, such as `thing1.*`, `thing1.thing2.Cat` or `*.MySafeClass`.\n\nThe patterns are checked in order until a match is found.\nIf there is no match, a `SecurityException` is thrown.\n\nYou can set the patterns using the `allowedListPatterns` property on these converters.\nAlternatively, if you trust all message originators, you can set the environment variable `SPRING_AMQP_DESERIALIZATION_TRUST_ALL` or system property `spring.amqp.deserialization.trust.all` to `true`.\n====\n\n[[message-properties-converters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "Java Deserialization", "heading_level": 2, "file_order": 43, "section_index": 14, "content_hash": "91e98081e43321464065d04e93d9e965398bea7de1617871b55630e150cd02b4", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:7a30f48955357a7523f766fd069f0d08ab3873b18cd5c7b043a1d05e80bebd8d", "content": "The `MessagePropertiesConverter` strategy interface is used to convert between the Rabbit Client `BasicProperties` and Spring AMQP `MessageProperties`.\nThe default implementation (`DefaultMessagePropertiesConverter`) is usually sufficient for most purposes, but you can implement your own if needed.\nThe default properties converter converts `BasicProperties` elements of type `LongString` to `String` instances when the size is not greater than `1024` bytes.\nLarger `LongString` instances are not converted (see the next paragraph).\nThis limit can be overridden with a constructor argument.\n\nStarting with version 1.6, headers longer than the long string limit (default: 1024) are now left as\n`LongString` instances by default by the `DefaultMessagePropertiesConverter`.\nYou can access the contents through the `getBytes[]`, `toString()`, or `getStream()` methods.\n\nPreviously, the `DefaultMessagePropertiesConverter` \"`converted`\" such headers to a `DataInputStream` (actually it just referenced the `LongString` instance's `DataInputStream`).\nOn output, this header was not converted (except to a String -- for example, `java.io.DataInputStream@1d057a39` by calling `toString()` on the stream).\n\nLarge incoming `LongString` headers are now correctly \"`converted`\" on output, too (by default).\n\nA new constructor is provided to let you configure the converter to work as before.\nThe following listing shows the Javadoc comment and declaration of the method:\n\n[source, java]\n----\n/**\n * Construct an instance where LongStrings will be returned\n * unconverted or as a java.io.DataInputStream when longer than this limit.\n * Use this constructor with 'true' to restore pre-1.6 behavior.\n * @param longStringLimit the limit.\n * @param convertLongLongStrings LongString when false,\n * DataInputStream when true.\n * @since 1.6\n */\npublic DefaultMessagePropertiesConverter(int longStringLimit, boolean convertLongLongStrings) { ... }\n----\n\nAlso starting with version 1.6, a new property called `correlationIdString` has been added to `MessageProperties`.\nPreviously, when converting to and from `BasicProperties` used by the RabbitMQ client, an unnecessary `byte[] <-> String` conversion was performed because `MessageProperties.correlationId` is a `byte[]`, but `BasicProperties` uses a `String`.\n(Ultimately, the RabbitMQ client uses UTF-8 to convert the `String` to bytes to put in the protocol message).\n\nTo provide maximum backwards compatibility, a new property called `correlationIdPolicy` has been added to the\n`DefaultMessagePropertiesConverter`.\nThis takes a `DefaultMessagePropertiesConverter.CorrelationIdPolicy` enum argument.\nBy default, it is set to `BYTES`, which replicates the previous behavior.\n\nFor inbound messages:\n\n* `STRING`: Only the `correlationIdString` property is mapped\n* `BYTES`: Only the `correlationId` property is mapped\n* `BOTH`: Both properties are mapped\n\nFor outbound messages:\n\n* `STRING`: Only the `correlationIdString` property is mapped\n* `BYTES`: Only the `correlationId` property is mapped\n* `BOTH`: Both properties are considered, with the `String` property taking precedence\n\nAlso starting with version 1.6, the inbound `deliveryMode` property is no longer mapped to `MessageProperties.deliveryMode`.\nIt is mapped to `MessageProperties.receivedDeliveryMode` instead.\nAlso, the inbound `userId` property is no longer mapped to `MessageProperties.userId`.\nIt is mapped to `MessageProperties.receivedUserId` instead.\nThese changes are to avoid unexpected propagation of these properties if the same `MessageProperties` object is used for an outbound message.\n\nStarting with version 2.2, the `DefaultMessagePropertiesConverter` converts any custom headers with values of type `Class<?>` using `getName()` instead of `toString()`; this avoids consuming application having to parse the class name out of the `toString()` representation.\nFor rolling upgrades, you may need to change your consumers to understand both formats until all producers are upgraded.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/message-converters.adoc", "title": "message-converters", "heading": "Message Properties Converters", "heading_level": 2, "file_order": 43, "section_index": 15, "content_hash": "7a30f48955357a7523f766fd069f0d08ab3873b18cd5c7b043a1d05e80bebd8d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/message-converters.adoc"}}
{"id": "sha256:750982a780af3448f2af4c6373990dceab9ba725daf3888ceb48b9fe9ad87981", "content": "[[multi-rabbit]]\n\nVersion 2.3 added more convenience when communicating between a single application and multiple brokers or broker clusters.\nThe main benefit, on the consumer side, is that the infrastructure can automatically associate auto-declared queues with the appropriate broker.\n\nThis is best illustrated with an example:\n\n[source, java]\n----\n@SpringBootApplication(exclude = RabbitAutoConfiguration.class)\npublic class Application {\n\n public static void main(String[] args) {\n SpringApplication.run(Application.class, args);\n }\n\n @Bean\n CachingConnectionFactory cf1() {\n return new CachingConnectionFactory(\"localhost\");\n }\n\n @Bean\n CachingConnectionFactory cf2() {\n return new CachingConnectionFactory(\"otherHost\");\n }\n\n @Bean\n CachingConnectionFactory cf3() {\n return new CachingConnectionFactory(\"thirdHost\");\n }\n\n @Bean\n SimpleRoutingConnectionFactory rcf(CachingConnectionFactory cf1,\n CachingConnectionFactory cf2, CachingConnectionFactory cf3) {\n\n SimpleRoutingConnectionFactory rcf = new SimpleRoutingConnectionFactory();\n rcf.setDefaultTargetConnectionFactory(cf1);\n rcf.setTargetConnectionFactories(Map.of(\"one\", cf1, \"two\", cf2, \"three\", cf3));\n return rcf;\n }\n\n @Bean(\"factory1-admin\")\n RabbitAdmin admin1(CachingConnectionFactory cf1) {\n return new RabbitAdmin(cf1);\n }\n\n @Bean(\"factory2-admin\")\n RabbitAdmin admin2(CachingConnectionFactory cf2) {\n return new RabbitAdmin(cf2);\n }\n\n @Bean(\"factory3-admin\")\n RabbitAdmin admin3(CachingConnectionFactory cf3) {\n return new RabbitAdmin(cf3);\n }\n\n @Bean\n public RabbitListenerEndpointRegistry rabbitListenerEndpointRegistry() {\n return new RabbitListenerEndpointRegistry();\n }\n\n @Bean\n public RabbitListenerAnnotationBeanPostProcessor postProcessor(RabbitListenerEndpointRegistry registry) {\n MultiRabbitListenerAnnotationBeanPostProcessor postProcessor\n postProcessor.setEndpointRegistry(registry);\n postProcessor.setContainerFactoryBeanName(\"defaultContainerFactory\");\n return postProcessor;\n }\n\n @Bean\n public SimpleRabbitListenerContainerFactory factory1(CachingConnectionFactory cf1) {\n SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n factory.setConnectionFactory(cf1);\n return factory;\n }\n\n @Bean\n public SimpleRabbitListenerContainerFactory factory2(CachingConnectionFactory cf2) {\n SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n factory.setConnectionFactory(cf2);\n return factory;\n }\n\n @Bean\n public SimpleRabbitListenerContainerFactory factory3(CachingConnectionFactory cf3) {\n SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n factory.setConnectionFactory(cf3);\n return factory;\n }\n\n @Bean\n RabbitTemplate template(SimpleRoutingConnectionFactory rcf) {\n return new RabbitTemplate(rcf);\n }\n\n @Bean\n ConnectionFactoryContextWrapper wrapper(SimpleRoutingConnectionFactory rcf) {\n return new ConnectionFactoryContextWrapper(rcf);\n }\n\n}\n\n@Component\nclass Listeners {\n\n @RabbitListener(queuesToDeclare = @Queue(\"q1\"), containerFactory = \"factory1\")\n public void listen1(String in) {\n\n }\n\n @RabbitListener(queuesToDeclare = @Queue(\"q2\"), containerFactory = \"factory2\")\n public void listen2(String in) {\n\n }\n\n @RabbitListener(queuesToDeclare = @Queue(\"q3\"), containerFactory = \"factory3\")\n public void listen3(String in) {\n\n }\n\n}\n----\n\nAs you can see, we have declared 3 sets of infrastructure (connection factories, admins, container factories).\nAs discussed earlier, `@RabbitListener` can define which container factory to use; in this case, they also use `queuesToDeclare` which causes the queue(s) to be declared on the broker, if it doesn't exist.\nBy naming the `RabbitAdmin` beans with the convention `<container-factory-name>-admin`, the infrastructure is able to determine which admin should declare the queue.\nThis will also work with `bindings = @QueueBinding(...)` whereby the exchange and binding will also be declared.\nIt will NOT work with `queues`, since that expects the queue(s) to already exist.\n\nOn the producer side, a convenient `ConnectionFactoryContextWrapper` class is provided, to make using the `RoutingConnectionFactory` (see xref:amqp/connections.adoc#routing-connection-factory[Routing Connection Factory]) simpler.\n\nAs you can see above, a `SimpleRoutingConnectionFactory` bean has been added with routing keys `one`, `two` and `three`.\nThere is also a `RabbitTemplate` that uses that factory.\nHere is an example of using that template with the wrapper to route to one of the broker clusters.\n\n[source, java]\n----\n@Bean\npublic ApplicationRunner runner(RabbitTemplate template, ConnectionFactoryContextWrapper wrapper) {\n return args -> {\n wrapper.run(\"one\", () -> template.convertAndSend(\"q1\", \"toCluster1\"));\n wrapper.run(\"two\", () -> template.convertAndSend(\"q2\", \"toCluster2\"));\n wrapper.run(\"three\", () -> template.convertAndSend(\"q3\", \"toCluster3\"));\n };\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/multi-rabbit.adoc", "title": "multi-rabbit", "heading": "multi-rabbit", "heading_level": 1, "file_order": 44, "section_index": 0, "content_hash": "750982a780af3448f2af4c6373990dceab9ba725daf3888ceb48b9fe9ad87981", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/multi-rabbit.adoc"}}
{"id": "sha256:bcfaa0ad2e88412a739a8b4b2061b5a3c1e1b02532392b6851d5986a41941b2c", "content": "[[post-processing]]\n\nA number of extension points exist.\nThey let you perform some processing on a message, either before it is sent to RabbitMQ or immediately after it is received.\n\nAs can be seen in xref:amqp/message-converters.adoc[Message Converters], one such extension point is in the `AmqpTemplate` `convertAndReceive` operations, where you can provide a `MessagePostProcessor`.\nFor example, after your POJO has been converted, the `MessagePostProcessor` lets you set custom headers or properties on the `Message`.\n\nStarting with version 1.4.2, additional extension points have been added to the `RabbitTemplate` - `setBeforePublishPostProcessors()` and `setAfterReceivePostProcessors()`.\nThe first enables a post processor to run immediately before sending to RabbitMQ.\nWhen using batching (see xref:amqp/sending-messages.adoc#template-batching[Batching]), this is invoked after the batch is assembled and before the batch is sent.\nThe second is invoked immediately after a message is received.\n\nThese extension points are used for such features as compression and, for this purpose, several `MessagePostProcessor` implementations are provided.\n`GZipPostProcessor`, `ZipPostProcessor` and `DeflaterPostProcessor` compress messages before sending, and `GUnzipPostProcessor`, `UnzipPostProcessor` and `InflaterPostProcessor` decompress received messages.\n\nNOTE: Starting with version 2.1.5, the `GZipPostProcessor` can be configured with the `copyProperties = true` option to make a copy of the original message properties.\nBy default, these properties are reused for performance reasons, and modified with compression content encoding and the optional `MessageProperties.SPRING_AUTO_DECOMPRESS` header.\nIf you retain a reference to the original outbound message, its properties will change as well.\nSo, if your application retains a copy of an outbound message with these message post processors, consider turning the `copyProperties` option on.\n\nIMPORTANT: Starting with version 2.2.12, you can configure the delimiter that the compressing post processors use between content encoding elements.\nWith versions 2.2.11 and before, this was hard-coded as `:`, it is now set to `, ` by default.\nThe decompressors will work with both delimiters.\nHowever, if you publish messages with 2.3 or later and consume with 2.2.11 or earlier, you MUST set the `encodingDelimiter` property on the compressor(s) to `:`.\nWhen your consumers are upgraded to 2.2.11 or later, you can revert to the default of `, `.\n\nSimilarly, the `SimpleMessageListenerContainer` also has a `setAfterReceivePostProcessors()` method, letting the decompression be performed after messages are received by the container.\n\nStarting with version 2.1.4, `addBeforePublishPostProcessors()` and `addAfterReceivePostProcessors()` have been added to the `RabbitTemplate` to allow appending new post processors to the list of before publish and after receive post processors respectively.\nAlso there are methods provided to remove the post processors.\nSimilarly, `AbstractMessageListenerContainer` also has `addAfterReceivePostProcessors()` and `removeAfterReceivePostProcessor()` methods added.\nSee the Javadoc of `RabbitTemplate` and `AbstractMessageListenerContainer` for more detail.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/post-processing.adoc", "title": "post-processing", "heading": "post-processing", "heading_level": 1, "file_order": 45, "section_index": 0, "content_hash": "bcfaa0ad2e88412a739a8b4b2061b5a3c1e1b02532392b6851d5986a41941b2c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/post-processing.adoc"}}
{"id": "sha256:a37749cc2df3021aba2c4ea2ae7c567fe2fd21dd2ffc7f3ea4171cef7cfdfa08", "content": "[[receiving-messages]]\n\nMessage reception is always a little more complicated than sending.\nThere are two ways to receive a `Message`.\nThe simpler option is to poll for one `Message` at a time with a polling method call.\nThe more complicated yet more common approach is to register a listener that receives `Messages` on-demand, asynchronously.\nWe consider an example of each approach in the next two sub-sections.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/receiving-messages.adoc", "title": "receiving-messages", "heading": "receiving-messages", "heading_level": 1, "file_order": 46, "section_index": 0, "content_hash": "a37749cc2df3021aba2c4ea2ae7c567fe2fd21dd2ffc7f3ea4171cef7cfdfa08", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/receiving-messages.adoc"}}
{"id": "sha256:f2a47773c3bc9ec0dfbc587a8fe9adc91617225b72c1d630fd13004901443e12", "content": "[[request-reply]]\n\nThe `AmqpTemplate` also provides a variety of `sendAndReceive` methods that accept the same argument options that were described earlier for the one-way send operations (`exchange`, `routingKey`, and `Message`).\nThose methods are quite useful for request-reply scenarios, since they handle the configuration of the necessary `reply-to` property before sending and can listen for the reply message on an exclusive queue that is created internally for that purpose.\n\nSimilar request-reply methods are also available where the `MessageConverter` is applied to both the request and reply.\nThose methods are named `convertSendAndReceive`.\nSee the javadoc:org.springframework.amqp.core.AmqpTemplate[Javadoc of `AmqpTemplate`] for more detail.\n\nStarting with version 1.5.0, each of the `sendAndReceive` method variants has an overloaded version that takes `CorrelationData`.\nTogether with a properly configured connection factory, this enables the receipt of publisher confirms for the send side of the operation.\nSee xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns] and the javadoc:org.springframework.amqp.rabbit.core.RabbitOperations[Javadoc for `RabbitOperations`] for more information.\n\nStarting with version 2.0, there are variants of these methods (`convertSendAndReceiveAsType`) that take an additional `ParameterizedTypeReference` argument to convert complex returned types.\nThe template must be configured with a `SmartMessageConverter`.\nSee xref:amqp/message-converters.adoc#json-complex[Converting From a `Message` With `RabbitTemplate`] for more information.\n\nStarting with version 2.1, you can configure the `RabbitTemplate` with the `noLocalReplyConsumer` option to control a `noLocal` flag for reply consumers.\nThis is `false` by default.\n\n[[reply-timeout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/request-reply.adoc", "title": "request-reply", "heading": "request-reply", "heading_level": 1, "file_order": 47, "section_index": 0, "content_hash": "f2a47773c3bc9ec0dfbc587a8fe9adc91617225b72c1d630fd13004901443e12", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/request-reply.adoc"}}
{"id": "sha256:c1e3ccc205f375375f12028adec4d07bb7cd12f7bfb3417201f92c3d894e138a", "content": "By default, the send and receive methods timeout after five seconds and return null.\nYou can modify this behavior by setting the `replyTimeout` property.\nStarting with version 1.5, if you set the `mandatory` property to `true` (or the `mandatory-expression` evaluates to `true` for a particular message), if the message cannot be delivered to a queue, an `AmqpMessageReturnedException` is thrown.\nThis exception has `returnedMessage`, `replyCode`, and `replyText` properties, as well as the `exchange` and `routingKey` used for the send.\n\nNOTE: This feature uses publisher returns.\nYou can enable it by setting `publisherReturns` to `true` on the `CachingConnectionFactory` (see xref:amqp/connections.adoc#cf-pub-conf-ret[Publisher Confirms and Returns]).\nAlso, you must not have registered your own `ReturnCallback` with the `RabbitTemplate`.\n\nStarting with version 2.1.2, a `replyTimedOut` method has been added, letting subclasses be informed of the timeout so that they can clean up any retained state.\n\nStarting with versions 2.0.11 and 2.1.3, when you use the default `DirectReplyToMessageListenerContainer`, you can add an error handler by setting the template's `replyErrorHandler` property.\nThis error handler is invoked for any failed deliveries, such as late replies and messages received without a correlation header.\nThe exception passed in is a `ListenerExecutionFailedException`, which has a `failedMessage` property.\n\n[[direct-reply-to]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/request-reply.adoc", "title": "request-reply", "heading": "Reply Timeout", "heading_level": 2, "file_order": 47, "section_index": 1, "content_hash": "c1e3ccc205f375375f12028adec4d07bb7cd12f7bfb3417201f92c3d894e138a", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/request-reply.adoc"}}
{"id": "sha256:558167b5b841e45246221e60196824af27fc14b17f8106999a62ac690ec6168b", "content": "IMPORTANT: Starting with version 3.4.0, the RabbitMQ server supports https://www.rabbitmq.com/direct-reply-to.html[direct reply-to].\nThis eliminates the main reason for a fixed reply queue (to avoid the need to create a temporary queue for each request).\nStarting with Spring AMQP version 1.4.1 direct reply-to is used by default (if supported by the server) instead of creating temporary reply queues.\nWhen no `replyQueue` is provided (or it is set with a name of `amq.rabbitmq.reply-to`), the `RabbitTemplate` automatically detects whether direct reply-to is supported and either uses it or falls back to using a temporary reply queue.\nWhen using direct reply-to, a `reply-listener` is not required and should not be configured.\n\nReply listeners are still supported with named queues (other than `amq.rabbitmq.reply-to`), allowing control of reply concurrency and so on.\n\nStarting with version 1.6, if you wish to use a temporary, exclusive, auto-delete queue for each\nreply, set the `useTemporaryReplyQueues` property to `true`.\nThis property is ignored if you set a `replyAddress`.\n\nYou can change the criteria that dictate whether to use direct reply-to by subclassing `RabbitTemplate` and overriding `useDirectReplyTo()` to check different criteria.\nThe method is called once only, when the first request is sent.\n\nPrior to version 2.0, the `RabbitTemplate` created a new consumer for each request and canceled the consumer when the reply was received (or timed out).\nNow the template uses a `DirectReplyToMessageListenerContainer` instead, letting the consumers be reused.\nThe template still takes care of correlating the replies, so there is no danger of a late reply going to a different sender.\nIf you want to revert to the previous behavior, set the `useDirectReplyToContainer` (`direct-reply-to-container` when using XML configuration) property to false.\n\nThe `AsyncRabbitTemplate` has no such option.\nIt always used a `DirectReplyToContainer` for replies when direct reply-to is used.\n\nStarting with version 2.3.7, the template has a new property `useChannelForCorrelation`.\nWhen this is `true`, the server does not have to copy the correlation id from the request message headers to the reply message.\nInstead, the channel used to send the request is used to correlate the reply to the request.\n\n[[message-correlation-with-a-reply-queue]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/request-reply.adoc", "title": "request-reply", "heading": "RabbitMQ Direct reply-to", "heading_level": 2, "file_order": 47, "section_index": 2, "content_hash": "558167b5b841e45246221e60196824af27fc14b17f8106999a62ac690ec6168b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/request-reply.adoc"}}
{"id": "sha256:71c22cc6a79729291ea48474b0d26b532881f90af8910f0c8777100d724634f5", "content": "When using a fixed reply queue (other than `amq.rabbitmq.reply-to`), you must provide correlation data so that replies can be correlated to requests.\nSee https://www.rabbitmq.com/tutorials/tutorial-six-java.html[RabbitMQ Remote Procedure Call (RPC)].\nBy default, the standard `correlationId` property is used to hold the correlation data.\nHowever, if you wish to use a custom property to hold correlation data, you can set the `correlation-key` attribute on the <rabbit-template/>.\nExplicitly setting the attribute to `correlationId` is the same as omitting the attribute.\nThe client and server must use the same header for correlation data.\n\nNOTE: Spring AMQP version 1.1 used a custom property called `spring_reply_correlation` for this data.\nIf you wish to revert to this behavior with the current version (perhaps to maintain compatibility with another application using 1.1), you must set the attribute to `spring_reply_correlation`.\n\nBy default, the template generates its own correlation ID (ignoring any user-supplied value).\nIf you wish to use your own correlation ID, set the `RabbitTemplate` instance's `userCorrelationId` property to `true`.\n\nIMPORTANT: The correlation ID must be unique to avoid the possibility of a wrong reply being returned for a request.\n\n[[reply-listener]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/request-reply.adoc", "title": "request-reply", "heading": "Message Correlation With A Reply Queue", "heading_level": 2, "file_order": 47, "section_index": 3, "content_hash": "71c22cc6a79729291ea48474b0d26b532881f90af8910f0c8777100d724634f5", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/request-reply.adoc"}}
{"id": "sha256:e71019cbb847c8bd3f2a2fe01172b80ec50659eccaa6ff78a1c4925e9d51579e", "content": "When using RabbitMQ versions prior to 3.4.0, a new temporary queue is used for each reply.\nHowever, a single reply queue can be configured on the template, which can be more efficient and also lets you set arguments on that queue.\nIn this case, however, you must also provide a <reply-listener/> sub element.\nThis element provides a listener container for the reply queue, with the template being the listener.\nAll of the xref:amqp/containerAttributes.adoc[Message Listener Container Configuration] attributes allowed on a <listener-container/> are allowed on the element, except for `connection-factory` and `message-converter`, which are inherited from the template's configuration.\n\nIMPORTANT: If you run multiple instances of your application or use multiple `RabbitTemplate` instances, you *MUST* use a unique reply queue for each.\nRabbitMQ has no ability to select messages from a queue, so, if they all use the same queue, each instance would compete for replies and not necessarily receive their own.\n\nThe following example defines a rabbit template with a connection factory:\n\n[source,xml]\n----\n<rabbit:template id=\"amqpTemplate\"\n connection-factory=\"connectionFactory\"\n reply-queue=\"replies\"\n reply-address=\"replyEx/routeReply\">\n <rabbit:reply-listener/>\n</rabbit:template>\n----\n\nWhile the container and template share a connection factory, they do not share a channel.\nTherefore, requests and replies are not performed within the same transaction (if transactional).\n\nNOTE: Prior to version 1.5.0, the `reply-address` attribute was not available.\nReplies were always routed by using the default exchange and the `reply-queue` name as the routing key.\nThis is still the default, but you can now specify the new `reply-address` attribute.\nThe `reply-address` can contain an address with the form `<exchange>/<routingKey>` and the reply is routed to the specified exchange and routed to a queue bound with the routing key.\nThe `reply-address` has precedence over `reply-queue`.\nWhen only `reply-address` is in use, the `<reply-listener>` must be configured as a separate `<listener-container>` component.\nThe `reply-address` and `reply-queue` (or `queues` attribute on the `<listener-container>`) must refer to the same queue logically.\n\nWith this configuration, a `SimpleListenerContainer` is used to receive the replies, with the `RabbitTemplate` being the `MessageListener`.\nWhen defining a template with the `<rabbit:template/>` namespace element, as shown in the preceding example, the parser defines the container and wires in the template as the listener.\n\nNOTE: When the template does not use a fixed `replyQueue` (or is using direct reply-to -- see xref:amqp/request-reply.adoc#direct-reply-to[RabbitMQ Direct reply-to]), a listener container is not needed.\nDirect `reply-to` is the preferred mechanism when using RabbitMQ 3.4.0 or later.\n\nIf you define your `RabbitTemplate` as a `<bean/>` or use an `@Configuration` class to define it as an `@Bean` or when you create the template programmatically, you need to define and wire up the reply listener container yourself.\nIf you fail to do this, the template never receives the replies and eventually times out and returns null as the reply to a call to a `sendAndReceive` method.\n\nStarting with version 1.5, the `RabbitTemplate` detects if it has been\nconfigured as a `MessageListener` to receive replies.\nIf not, attempts to send and receive messages with a reply address\nfail with an `IllegalStateException` (because the replies are never received).\n\nFurther, if a simple `replyAddress` (queue name) is used, the reply listener container verifies that it is listening\nto a queue with the same name.\nThis check cannot be performed if the reply address is an exchange and routing key and a debug log message is written.\n\nIMPORTANT: When wiring the reply listener and template yourself, it is important to ensure that the template's `replyAddress` and the container's `queues` (or `queueNames`) properties refer to the same queue.\nThe template inserts the reply address into the outbound message `replyTo` property.\n\nThe following listing shows examples of how to manually wire up the beans:\n\n[source,xml]\n----\n<bean id=\"amqpTemplate\" class=\"org.springframework.amqp.rabbit.core.RabbitTemplate\">\n <constructor-arg ref=\"connectionFactory\" />\n <property name=\"exchange\" value=\"foo.exchange\" />\n <property name=\"routingKey\" value=\"foo\" />\n <property name=\"replyQueue\" ref=\"replyQ\" />\n <property name=\"replyTimeout\" value=\"600000\" />\n <property name=\"useDirectReplyToContainer\" value=\"false\" />\n</bean>\n\n<bean class=\"org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer\">\n <constructor-arg ref=\"connectionFactory\" />\n <property name=\"queues\" ref=\"replyQ\" />\n <property name=\"messageListener\" ref=\"amqpTemplate\" />\n</bean>\n\n<rabbit:queue id=\"replyQ\" name=\"my.reply.queue\" />\n----\n\n[source,java]\n----\n @Bean\n public RabbitTemplate amqpTemplate() {\n RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory());\n rabbitTemplate.setMessageConverter(msgConv());\n rabbitTemplate.setReplyAddress(replyQueue().getName());\n rabbitTemplate.setReplyTimeout(60000);\n rabbitTemplate.setUseDirectReplyToContainer(false);\n return rabbitTemplate;\n }\n\n @Bean\n public SimpleMessageListenerContainer replyListenerContainer() {\n SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();\n container.setConnectionFactory(connectionFactory());\n container.setQueues(replyQueue());\n container.setMessageListener(amqpTemplate());\n return container;\n }\n\n @Bean\n public Queue replyQueue() {\n return new Queue(\"my.reply.queue\");\n }\n----\n\nA complete example of a `RabbitTemplate` wired with a fixed reply queue, together with a \"`remote`\" listener container that handles the request and returns the reply is shown in https://github.com/spring-projects/spring-amqp/tree/main/spring-rabbit/src/test/java/org/springframework/amqp/rabbit/listener/JavaConfigFixedReplyQueueTests.java[this test case].\n\nIMPORTANT: When the reply times out (`replyTimeout`), the `sendAndReceive()` methods return null.\n\nPrior to version 1.3.6, late replies for timed out messages were only logged.\nNow, if a late reply is received, it is rejected (the template throws an `AmqpRejectAndDontRequeueException`).\nIf the reply queue is configured to send rejected messages to a dead letter exchange, the reply can be retrieved for later analysis.\nTo do so, bind a queue to the configured dead letter exchange with a routing key equal to the reply queue's name.\n\nSee the https://www.rabbitmq.com/dlx.html[RabbitMQ Dead Letter Documentation] for more information about configuring dead lettering.\nYou can also take a look at the `FixedReplyQueueDeadLetterTests` test case for an example.\n\n[[async-template]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/request-reply.adoc", "title": "request-reply", "heading": "Reply Listener Container", "heading_level": 2, "file_order": 47, "section_index": 4, "content_hash": "e71019cbb847c8bd3f2a2fe01172b80ec50659eccaa6ff78a1c4925e9d51579e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/request-reply.adoc"}}
{"id": "sha256:e47895a3f2b4aae2c768271a5a345bf5ec1f8c3163e4c7694405d8874978d600", "content": "Version 1.6 introduced the `AsyncRabbitTemplate`.\nThis has similar `sendAndReceive` (and `convertSendAndReceive`) methods to those on the xref:amqp/template.adoc[`AmqpTemplate`].\nHowever, instead of blocking, they return a `CompletableFuture`.\n\nThe `sendAndReceive` methods return a `RabbitMessageFuture`.\nThe `convertSendAndReceive` methods return a `RabbitConverterFuture`.\n\nYou can either synchronously retrieve the result later, by invoking `get()` on the future, or you can register a callback that is called asynchronously with the result.\nThe following listing shows both approaches:\n\n[source, java]\n----\n@Autowired\nprivate AsyncRabbitTemplate template;\n\n...\n\npublic void doSomeWorkAndGetResultLater() {\n\n ...\n\n CompletableFuture<String> future = this.template.convertSendAndReceive(\"foo\");\n\n // do some more work\n\n String reply = null;\n try {\n reply = future.get(10, TimeUnit.SECONDS);\n }\n catch (ExecutionException e) {\n ...\n }\n\n ...\n\n}\n\npublic void doSomeWorkAndGetResultAsync() {\n\n ...\n\n RabbitConverterFuture<String> future = this.template.convertSendAndReceive(\"foo\");\n future.whenComplete((result, ex) -> {\n if (ex == null) {\n // success\n }\n else {\n // failure\n }\n });\n\n ...\n\n}\n----\n\nIf `mandatory` is set and the message cannot be delivered, the future throws an `ExecutionException` with a cause of `AmqpMessageReturnedException`, which encapsulates the returned message and information about the return.\n\nIf `enableConfirms` is set, the future has a property called `confirm`, which is itself a `CompletableFuture<Boolean>` with `true` indicating a successful publish.\nIf the confirm future is `false`, the `RabbitFuture` has a further property called `nackCause`, which contains the reason for the failure, if available.\n\nIMPORTANT: The publisher confirm is discarded if it is received after the reply, since the reply implies a successful publish.\n\nYou can set the `receiveTimeout` property on the template to time out replies (it defaults to `30000` - 30 seconds).\nIf a timeout occurs, the future is completed with an `AmqpReplyTimeoutException`.\n\nThe template implements `SmartLifecycle`.\nStopping the template while there are pending replies causes the pending `Future` instances to be canceled.\n\nStarting with version 2.0, the asynchronous template now supports https://www.rabbitmq.com/direct-reply-to.html[direct reply-to] instead of a configured reply queue.\nTo enable this feature, use one of the following constructors:\n\n[source, java]\n----\npublic AsyncRabbitTemplate(ConnectionFactory connectionFactory, String exchange, String routingKey)\n\npublic AsyncRabbitTemplate(RabbitTemplate template)\n----\n\nSee xref:amqp/request-reply.adoc#direct-reply-to[RabbitMQ Direct reply-to] to use direct reply-to with the synchronous `RabbitTemplate`.\n\nVersion 2.0 introduced variants of these methods (`convertSendAndReceiveAsType`) that take an additional `ParameterizedTypeReference` argument to convert complex returned types.\nYou must configure the underlying `RabbitTemplate` with a `SmartMessageConverter`.\nSee xref:amqp/message-converters.adoc#json-complex[Converting From a `Message` With `RabbitTemplate`] for more information.\n\n[[remoting]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/request-reply.adoc", "title": "request-reply", "heading": "Async Rabbit Template", "heading_level": 2, "file_order": 47, "section_index": 5, "content_hash": "e47895a3f2b4aae2c768271a5a345bf5ec1f8c3163e4c7694405d8874978d600", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/request-reply.adoc"}}
{"id": "sha256:3d90a076ae16f079bb2ba9d7126cbf7d82d3d44ab5aecc04ba616ca328f85410", "content": "Spring remoting is no longer supported because the functionality has been removed from Spring Framework.\n\nUse `sendAndReceive` operations using the `RabbitTemplate` (client side ) and `@RabbitListener` instead.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/request-reply.adoc", "title": "request-reply", "heading": "Spring Remoting with AMQP", "heading_level": 2, "file_order": 47, "section_index": 6, "content_hash": "3d90a076ae16f079bb2ba9d7126cbf7d82d3d44ab5aecc04ba616ca328f85410", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/request-reply.adoc"}}
{"id": "sha256:71459bda2404d0ecc34958de573ade5c806278fef68c84de2876b4cf5f5732e1", "content": "[[resilience:-recovering-from-errors-and-broker-failures]]\n\nSome of the key (and most popular) high-level features that Spring AMQP provides are to do with recovery and automatic re-connection in the event of a protocol error or broker failure.\nWe have seen all the relevant components already in this guide, but it should help to bring them all together here and call out the features and recovery scenarios individually.\n\nThe primary reconnection features are enabled by the `CachingConnectionFactory` itself.\nIt is also often beneficial to use the `RabbitAdmin` auto-declaration features.\nIn addition, if you care about guaranteed delivery, you probably also need to use the `channelTransacted` flag in `RabbitTemplate` and `SimpleMessageListenerContainer` and the `AcknowledgeMode.AUTO` (or manual if you do the acks yourself) in the `SimpleMessageListenerContainer`.\n\n[[automatic-declaration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc", "title": "resilience-recovering-from-errors-and-broker-failures", "heading": "resilience-recovering-from-errors-and-broker-failures", "heading_level": 1, "file_order": 48, "section_index": 0, "content_hash": "71459bda2404d0ecc34958de573ade5c806278fef68c84de2876b4cf5f5732e1", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc"}}
{"id": "sha256:a2b36c4a093f758c2b7fd64f57ab501c5b3ff495d1d8ed9fb8dd88c7c8b9bf71", "content": "The `RabbitAdmin` component can declare exchanges, queues, and bindings on startup.\nIt does this lazily, through a `ConnectionListener`.\nConsequently, if the broker is not present on startup, it does not matter.\nThe first time a `Connection` is used (for example,\nby sending a message) the listener fires and the admin features is applied.\nA further benefit of doing the auto declarations in a listener is that, if the connection is dropped for any reason (for example,\nbroker death, network glitch, and others), they are applied again when the connection is re-established.\n\nNOTE: Queues declared this way must have fixed names -- either explicitly declared or generated by the framework for `AnonymousQueue` instances.\nAnonymous queues are non-durable, exclusive, and auto-deleting.\n\nIMPORTANT: Automatic declaration is performed only when the `CachingConnectionFactory` cache mode is `CHANNEL` (the default).\nThis limitation exists because exclusive and auto-delete queues are bound to the connection.\n\nStarting with version 2.2.2, the `RabbitAdmin` will detect beans of type `DeclarableCustomizer` and apply the function before actually processing the declaration.\nThis is useful, for example, to set a new argument (property) before it has first class support within the framework.\n\n[source, java]\n----\n@Bean\npublic DeclarableCustomizer customizer() {\n return dec -> {\n if (dec instanceof Queue && ((Queue) dec).getName().equals(\"my.queue\")) {\n dec.addArgument(\"some.new.queue.argument\", true);\n }\n return dec;\n };\n}\n----\n\nIt is also useful in projects that don't provide direct access to the `Declarable` bean definitions.\n\nSee also xref:amqp/connections.adoc#auto-recovery[RabbitMQ Automatic Connection/Topology recovery].\n\n[[retry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc", "title": "resilience-recovering-from-errors-and-broker-failures", "heading": "Automatic Declaration of Exchanges, Queues, and Bindings", "heading_level": 2, "file_order": 48, "section_index": 1, "content_hash": "a2b36c4a093f758c2b7fd64f57ab501c5b3ff495d1d8ed9fb8dd88c7c8b9bf71", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc"}}
{"id": "sha256:9f1d488bfeba2b0e9d14424f73c2166d7c4ab5b8130719050058c92655468b44", "content": "If you lose your connection to the broker in a synchronous sequence when using `RabbitTemplate` (for instance), Spring AMQP throws an `AmqpException` (usually, but not always, `AmqpIOException`).\nWe do not try to hide the fact that there was a problem, so you have to be able to catch and respond to the exception.\nThe easiest thing to do if you suspect that the connection was lost (and it was not your fault) is to try the operation again.\nYou can do this manually, or you could look at using Spring Retry to handle the retry (imperatively or declaratively).\n\nSpring Retry provides a couple of AOP interceptors and a great deal of flexibility to specify the parameters of the retry (number of attempts, exception types, backoff algorithm, and others).\nSpring AMQP also provides some convenience factory beans for creating Spring Retry interceptors in a convenient form for AMQP use cases, with strongly typed callback interfaces that you can use to implement custom recovery logic.\nSee the Javadoc and properties of javadoc:org.springframework.amqp.rabbit.config.StatefulRetryOperationsInterceptorFactoryBean[] and javadoc:org.springframework.amqp.rabbit.config.StatelessRetryOperationsInterceptorFactoryBean[] for more detail.\nStateless retry is appropriate if there is no transaction or if a transaction is started inside the retry callback.\nNote that stateless retry is simpler to configure and analyze than stateful retry, but it is not usually appropriate if there is an ongoing transaction that must be rolled back or definitely is going to roll back.\nA dropped connection in the middle of a transaction should have the same effect as a rollback.\nConsequently, for reconnections where the transaction is started higher up the stack, stateful retry is usually the best choice.\nStateful retry needs a mechanism to uniquely identify a message.\nThe simplest approach is to have the sender put a unique value in the `MessageId` message property.\nThe provided message converters provide an option to do this: you can set `createMessageIds` to `true`.\nOtherwise, you can inject a `MessageKeyGenerator` implementation into the interceptor.\nThe key generator must return a unique key for each message.\nIn versions prior to version 2.0, a `MissingMessageIdAdvice` was provided.\nIt enabled messages without a `messageId` property to be retried exactly once (ignoring the retry settings).\nThis advice is no longer provided, since, along with `spring-retry` version 1.2, its functionality is built into the interceptor and message listener containers.\n\nNOTE: For backwards compatibility, a message with a null message ID is considered fatal for the consumer (consumer is stopped) by default (after one retry).\nTo replicate the functionality provided by the `MissingMessageIdAdvice`, you can set the `statefulRetryFatalWithNullMessageId` property to `false` on the listener container.\nWith that setting, the consumer continues to run and the message is rejected (after one retry).\nIt is discarded or routed to the dead letter queue (if one is configured).\n\nStarting with version 1.3, a builder API is provided to aid in assembling these interceptors by using Java (in `@Configuration` classes).\nThe following example shows how to do so:\n\n[source,java]\n----\n@Bean\npublic StatefulRetryOperationsInterceptor interceptor() {\n return RetryInterceptorBuilder.stateful()\n .maxRetries(5)\n .backOffOptions(1000, 2.0, 10000) // initialInterval, multiplier, maxInterval\n .build();\n}\n----\n\nOnly a subset of retry capabilities can be configured this way.\nMore advanced features would need the configuration of a `RetryPolicy`.\nSee the {spring-framework-javadoc}/org/springframework/core/retry/RetryPolicy.html[`RetryPolicy` Javadoc] for more information about available policies and their configuration.\n\n[[batch-retry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc", "title": "resilience-recovering-from-errors-and-broker-failures", "heading": "Failures in Synchronous Operations and Options for Retry", "heading_level": 2, "file_order": 48, "section_index": 2, "content_hash": "9f1d488bfeba2b0e9d14424f73c2166d7c4ab5b8130719050058c92655468b44", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc"}}
{"id": "sha256:f0e4ff90daaa27269d2a3b8d96280c56b0f9ee1917d79a3dc5560ae014827424", "content": "It is not recommended to configure retry with a batch listener, unless the batch was created by the producer, in a single record.\nSee xref:amqp/receiving-messages/de-batching.adoc[Batched Messages] for information about consumer and producer-created batches.\nWith a consumer-created batch, the framework has no knowledge about which message in the batch caused the failure so recovery after the retries are exhausted is not possible.\nWith producer-created batches, since there is only one message that actually failed, the whole message can be recovered.\nApplications may want to inform a custom recoverer where in the batch the failure occurred, perhaps by setting an index property of the thrown exception.\n\nA retry recoverer for a batch listener must implement `MessageBatchRecoverer`.\n\n[[async-listeners]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc", "title": "resilience-recovering-from-errors-and-broker-failures", "heading": "Retry with Batch Listeners", "heading_level": 2, "file_order": 48, "section_index": 3, "content_hash": "f0e4ff90daaa27269d2a3b8d96280c56b0f9ee1917d79a3dc5560ae014827424", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc"}}
{"id": "sha256:f3a7b4d04cf51f3a49f690b1af48ce939606020ec4f7b08b276832d6147871fe", "content": "If a `MessageListener` fails because of a business exception, the exception is handled by the message listener container, which then goes back to listening for another message.\nIf the failure is caused by a dropped connection (not a business exception), the consumer that is collecting messages for the listener has to be cancelled and restarted.\nThe `SimpleMessageListenerContainer` handles this seamlessly, and it leaves a log to say that the listener is being restarted.\nIn fact, it loops endlessly, trying to restart the consumer.\nOnly if the consumer is very badly behaved indeed will it give up.\nOne side effect is that if the broker is down when the container starts, it keeps trying until a connection can be established.\n\nBusiness exception handling, as opposed to protocol errors and dropped connections, might need more thought and some custom configuration, especially if transactions or container acks are in use.\nPrior to 2.8.x, RabbitMQ had no definition of dead letter behavior.\nConsequently, by default, a message that is rejected or rolled back because of a business exception can be redelivered endlessly.\nTo put a limit on the client on the number of re-deliveries, one choice is a `StatefulRetryOperationsInterceptor` in the advice chain of the listener.\nThe interceptor can have a recovery callback that implements a custom dead letter action -- whatever is appropriate for your particular environment.\n\nAnother alternative is to set the container's `defaultRequeueRejected` property to `false`.\nThis causes all failed messages to be discarded.\nWhen using RabbitMQ 2.8.x or higher, this also facilitates delivering the message to a dead letter exchange.\n\nAlternatively, you can throw a `AmqpRejectAndDontRequeueException`.\nDoing so prevents message requeuing, regardless of the setting of the `defaultRequeueRejected` property.\n\nStarting with version 2.1, an `ImmediateRequeueAmqpException` is introduced to perform exactly the opposite logic: the message will be requeued, regardless of the setting of the `defaultRequeueRejected` property.\n\nOften, a combination of both techniques is used.\nYou can use a `StatefulRetryOperationsInterceptor` in the advice chain with a `MessageRecoverer` that throws an `AmqpRejectAndDontRequeueException`.\nThe `MessageRecover` is called when all retries have been exhausted.\nThe `RejectAndDontRequeueRecoverer` does exactly that.\nThe default `MessageRecoverer` consumes the errant message and emits a `WARN` message.\n\nStarting with version 1.3, a new `RepublishMessageRecoverer` is provided, to allow publishing of failed messages after retries are exhausted.\n\nWhen a recoverer consumes the final exception, the message is ack'd and is not sent to the dead letter exchange by the broker, if configured.\n\nNOTE: When `RepublishMessageRecoverer` is used on the consumer side, the received message has `deliveryMode` in the `receivedDeliveryMode` message property.\nIn this case the `deliveryMode` is `null`.\nThat means a `NON_PERSISTENT` delivery mode on the broker.\nStarting with version 2.0, you can configure the `RepublishMessageRecoverer` for the `deliveryMode` to set into the message to republish if it is `null`.\nBy default, it uses `MessageProperties` default value - `MessageDeliveryMode.PERSISTENT`.\n\nThe following example shows how to set a `RepublishMessageRecoverer` as the recoverer:\n\n[source,java]\n----\n@Bean\nRetryOperationsInterceptor interceptor() {\n return RetryInterceptorBuilder.stateless()\n .maxRetries(5)\n .recoverer(new RepublishMessageRecoverer(amqpTemplate(), \"something\", \"somethingelse\"))\n .build();\n}\n----\n\nThe `RepublishMessageRecoverer` publishes the message with additional information in message headers, such as the exception message, stack trace, original exchange, and routing key.\nAdditional headers can be added by creating a subclass and overriding `additionalHeaders()`.\nThe `deliveryMode` (or any other properties) can also be changed in the `additionalHeaders()`, as the following example shows:\n\n[source,java]\n----\nRepublishMessageRecoverer recoverer = new RepublishMessageRecoverer(amqpTemplate, \"error\") {\n\n protected Map<? extends String, ? extends Object> additionalHeaders(Message message, Throwable cause) {\n message.getMessageProperties()\n .setDeliveryMode(message.getMessageProperties().getReceivedDeliveryMode());\n return null;\n }\n\n};\n----\n\nStarting with version 2.0.5, the stack trace may be truncated if it is too large; this is because all headers have to fit in a single frame.\nBy default, if the stack trace would cause less than 20,000 bytes ('headroom') to be available for other headers, it will be truncated.\nThis can be adjusted by setting the recoverer's `frameMaxHeadroom` property, if you need more or less space for other headers.\nStarting with versions 2.1.13, 2.2.3, the exception message is included in this calculation, and the amount of stack trace will be maximized using the following algorithm:\n\n* if the stack trace alone would exceed the limit, the exception message header will be truncated to 97 bytes plus `...` and the stack trace is truncated too.\n* if the stack trace is small, the message will be truncated (plus `...`) to fit in the available bytes (but the message within the stack trace itself is truncated to 97 bytes plus `...`).\n\nWhenever a truncation of any kind occurs, the original exception will be logged to retain the complete information.\nThe evaluation is performed after the headers are enhanced so information such as the exception type can be used in the expressions.\n\nStarting with version 2.4.8, the error exchange and routing key can be provided as SpEL expressions, with the `Message` being the root object for the evaluation.\n\nStarting with version 2.3.3, a new subclass `RepublishMessageRecovererWithConfirms` is provided; this supports both styles of publisher confirms and will wait for the confirmation before returning (or throw an exception if not confirmed or the message is returned).\n\nIf the confirm type is `CORRELATED`, the subclass will also detect if a message is returned and throw an `AmqpMessageReturnedException`; if the publication is negatively acknowledged, it will throw an `AmqpNackReceivedException`.\n\nIf the confirm type is `SIMPLE`, the subclass will invoke the `waitForConfirmsOrDie` method on the channel.\n\nSee xref:amqp/connections.adoc#cf-pub-conf-ret[Publisher Confirms and Returns] for more information about confirms and returns.\n\nStarting with version 2.1, an `ImmediateRequeueMessageRecoverer` is added to throw an `ImmediateRequeueAmqpException`, which notifies a listener container to requeue the current failed message.\n\n[[exception-classification-for-spring-retry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc", "title": "resilience-recovering-from-errors-and-broker-failures", "heading": "Message Listeners and the Asynchronous Case", "heading_level": 2, "file_order": 48, "section_index": 4, "content_hash": "f3a7b4d04cf51f3a49f690b1af48ce939606020ec4f7b08b276832d6147871fe", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc"}}
{"id": "sha256:c0911ea56575daaef9dcf15dcd9c3d8a9d72a8f834ec64acdafaa5601c1ccab1", "content": "Spring Retry has a great deal of flexibility for determining which exceptions can invoke retry.\nThe default configuration retries for all exceptions.\nGiven that user exceptions are wrapped in a `ListenerExecutionFailedException`, we need to ensure that the classification examines the exception causes.\nThe default classifier looks only at the top level exception.\n\nSince Spring Retry 1.0.3, the `BinaryExceptionClassifier` has a property called `traverseCauses` (default: `false`).\nWhen `true`, it travers exception causes until it finds a match or there is no cause.\n\nTo use this classifier for retry, you can use a `SimpleRetryPolicy` created with the constructor that takes the max attempts, the `Map` of `Exception` instances, and the boolean (`traverseCauses`) and inject this policy into the `RetryTemplate`.\n\n[[retry-over-broker]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc", "title": "resilience-recovering-from-errors-and-broker-failures", "heading": "Exception Classification for Spring Retry", "heading_level": 2, "file_order": 48, "section_index": 5, "content_hash": "c0911ea56575daaef9dcf15dcd9c3d8a9d72a8f834ec64acdafaa5601c1ccab1", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc"}}
{"id": "sha256:9793919c6950c347c3cdcac6c0d4d1e4795c11f8968cd486a562102d2cb8f517", "content": "The message dead-lettered from the queue can be republished back to this queue after re-routing from a DLX.\nThis retry behaviour is controlled on the broker side via an `x-death` header.\nMore information about this approach in the official https://www.rabbitmq.com/docs/dlx[RabbitMQ documentation].\n\nThe other approach is to re-publish failed message back to the original exchange manually from the application.\nStarting with version `4.0`, the RabbitMQ broker does not consider `x-death` header sent from the client.\nEssentially, any `x-*` headers are ignored from the client.\n\nTo mitigate this new behavior of the RabbitMQ broker, Spring AMQP has introduced a `retry_count` header starting with version 3.2.\nWhen this header is absent and a server side DLX is in action, the `x-death.count` property is mapped to this header.\nWhen the failed message is re-published manually for retries, the `retry_count` header value has to be incremented manually.\nSee javadoc:org.springframework.amqp.core.MessageProperties#incrementRetryCount()[Javadoc] for more information.\n\nThe following example summarise an algorithm for manual retry over the broker:\n\n[source,java]\n----\n@RabbitListener(queues = \"some_queue\")\npublic void rePublish(Message message) {\n try {\n // Process message\n }\n catch (Exception ex) {\n Long retryCount = message.getMessageProperties().getRetryCount();\n if (retryCount < 3) {\n message.getMessageProperties().incrementRetryCount();\n this.rabbitTemplate.send(\"\", \"some_queue\", message);\n }\n else {\n throw new ImmediateAcknowledgeAmqpException(\"Failed after 4 attempts\");\n }\n }\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc", "title": "resilience-recovering-from-errors-and-broker-failures", "heading": "Retry Over Broker", "heading_level": 2, "file_order": 48, "section_index": 6, "content_hash": "9793919c6950c347c3cdcac6c0d4d1e4795c11f8968cd486a562102d2cb8f517", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/resilience-recovering-from-errors-and-broker-failures.adoc"}}
{"id": "sha256:f337918a25714cec8785e27c2cd57c1cd1eac02685a7103846792412b20900cb", "content": "[[sending-messages]]\n\nWhen sending a message, you can use any of the following methods:\n\n[source,java]\n----\nvoid send(Message message) throws AmqpException;\n\nvoid send(String routingKey, Message message) throws AmqpException;\n\nvoid send(String exchange, String routingKey, Message message) throws AmqpException;\n----\n\nWe can begin our discussion with the last method in the preceding listing, since it is actually the most explicit.\nIt lets an AMQP exchange name (along with a routing key) be provided at runtime.\nThe last parameter is the callback that is responsible for actual creating the message instance.\nAn example of using this method to send a message might look like this:\nThe following example shows how to use the `send` method to send a message:\n\n[source,java]\n----\namqpTemplate.send(\"marketData.topic\", \"quotes.nasdaq.THING1\",\n new Message(\"12.34\".getBytes(), someProperties));\n----\n\nYou can set the `exchange` property on the template itself if you plan to use that template instance to send to the same exchange most or all of the time.\nIn such cases, you can use the second method in the preceding listing.\nThe following example is functionally equivalent to the previous example:\n\n[source,java]\n----\namqpTemplate.setExchange(\"marketData.topic\");\namqpTemplate.send(\"quotes.nasdaq.FOO\", new Message(\"12.34\".getBytes(), someProperties));\n----\n\nIf both the `exchange` and `routingKey` properties are set on the template, you can use the method that accepts only the `Message`.\nThe following example shows how to do so:\n\n[source,java]\n----\namqpTemplate.setExchange(\"marketData.topic\");\namqpTemplate.setRoutingKey(\"quotes.nasdaq.FOO\");\namqpTemplate.send(new Message(\"12.34\".getBytes(), someProperties));\n----\n\nA better way of thinking about the exchange and routing key properties is that the explicit method parameters always override the template's default values.\nIn fact, even if you do not explicitly set those properties on the template, there are always default values in place.\nIn both cases, the default is an empty `String`, but that is actually a sensible default.\nAs far as the routing key is concerned, it is not always necessary in the first place (for example, for\na `Fanout` exchange).\nFurthermore, a queue may be bound to an exchange with an empty `String`.\nThose are both legitimate scenarios for reliance on the default empty `String` value for the routing key property of the template.\nAs far as the exchange name is concerned, the empty `String` is commonly used because the AMQP specification defines the \"`default exchange`\" as having no name.\nSince all queues are automatically bound to that default exchange (which is a direct exchange), using their name as the binding value, the second method in the preceding listing can be used for simple point-to-point messaging to any queue through the default exchange.\nYou can provide the queue name as the `routingKey`, either by providing the method parameter at runtime.\nThe following example shows how to do so:\n\n[source,java]\n----\nRabbitTemplate template = new RabbitTemplate(); // using default no-name Exchange\ntemplate.send(\"queue.helloWorld\", new Message(\"Hello World\".getBytes(), someProperties));\n----\n\nAlternately, you can create a template that can be used for publishing primarily or exclusively to a single Queue.\nThe following example shows how to do so:\n\n[source,java]\n----\nRabbitTemplate template = new RabbitTemplate(); // using default no-name Exchange\ntemplate.setRoutingKey(\"queue.helloWorld\"); // but we'll always send to this Queue\ntemplate.send(new Message(\"Hello World\".getBytes(), someProperties));\n----\n\n[[message-builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/sending-messages.adoc", "title": "sending-messages", "heading": "sending-messages", "heading_level": 1, "file_order": 49, "section_index": 0, "content_hash": "f337918a25714cec8785e27c2cd57c1cd1eac02685a7103846792412b20900cb", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/sending-messages.adoc"}}
{"id": "sha256:16f8b2a88da2d664dae5ea2df8cd19376c4aec0c796b506ee123ad055cc73290", "content": "Starting with version 1.3, a message builder API is provided by the `MessageBuilder` and `MessagePropertiesBuilder`.\nThese methods provide a convenient \"`fluent`\" means of creating a message or message properties.\nThe following examples show the fluent API in action:\n\n[source,java]\n----\nMessage message = MessageBuilder.withBody(\"foo\".getBytes())\n .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)\n .setMessageId(\"123\")\n .setHeader(\"bar\", \"baz\")\n .build();\n----\n\n[source,java]\n----\nMessageProperties props = MessagePropertiesBuilder.newInstance()\n .setContentType(MessageProperties.CONTENT_TYPE_TEXT_PLAIN)\n .setMessageId(\"123\")\n .setHeader(\"bar\", \"baz\")\n .build();\nMessage message = MessageBuilder.withBody(\"foo\".getBytes())\n .andProperties(props)\n .build();\n----\n\nEach of the properties defined on the javadoc:org.springframework.amqp.core.MessageProperties[] can be set.\nOther methods include `setHeader(String key, String value)`, `removeHeader(String key)`, `removeHeaders()`, and `copyProperties(MessageProperties properties)`.\nEach property setting method has a `set*IfAbsent()` variant.\nIn the cases where a default initial value exists, the method is named `set*IfAbsentOrDefault()`.\n\nFive static methods are provided to create an initial message builder:\n\n[source,java]\n----\npublic static MessageBuilder withBody(byte[] body) <1>\n\npublic static MessageBuilder withClonedBody(byte[] body) <2>\n\npublic static MessageBuilder withBody(byte[] body, int from, int to) <3>\n\npublic static MessageBuilder fromMessage(Message message) <4>\n\npublic static MessageBuilder fromClonedMessage(Message message) <5>\n----\n\n<1> The message created by the builder has a body that is a direct reference to the argument.\n<2> The message created by the builder has a body that is a new array containing a copy of bytes in the argument.\n<3> The message created by the builder has a body that is a new array containing the range of bytes from the argument.\nSee https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html[`Arrays.copyOfRange()`] for more details.\n<4> The message created by the builder has a body that is a direct reference to the body of the argument.\nThe argument's properties are copied to a new `MessageProperties` object.\n<5> The message created by the builder has a body that is a new array containing a copy of the argument's body.\nThe argument's properties are copied to a new `MessageProperties` object.\n\nThree static methods are provided to create a `MessagePropertiesBuilder` instance:\n\n[source,java]\n----\npublic static MessagePropertiesBuilder newInstance() <1>\n\npublic static MessagePropertiesBuilder fromProperties(MessageProperties properties) <2>\n\npublic static MessagePropertiesBuilder fromClonedProperties(MessageProperties properties) <3>\n----\n\n<1> A new message properties object is initialized with default values.\n<2> The builder is initialized with, and `build()` will return, the provided properties object.,\n<3> The argument's properties are copied to a new `MessageProperties` object.\n\nWith the `RabbitTemplate` implementation of `AmqpTemplate`, each of the `send()` methods has an overloaded version that takes an additional `CorrelationData` object.\nWhen publisher confirms are enabled, this object is returned in the callback described in xref:amqp/template.adoc[`AmqpTemplate`].\nThis lets the sender correlate a confirm (`ack` or `nack`) with the sent message.\n\nStarting with version 1.6.7, the `CorrelationAwareMessagePostProcessor` interface was introduced, allowing the correlation data to be modified after the message has been converted.\nThe following example shows how to use it:\n\n[source, java]\n----\nMessage postProcessMessage(Message message, Correlation correlation);\n----\n\nIn version 2.0, this interface is deprecated.\nThe method has been moved to `MessagePostProcessor` with a default implementation that delegates to `postProcessMessage(Message message)`.\n\nAlso starting with version 1.6.7, a new callback interface called `CorrelationDataPostProcessor` is provided.\nThis is invoked after all `MessagePostProcessor` instances (provided in the `send()` method as well as those provided in `setBeforePublishPostProcessors()`).\nImplementations can update or replace the correlation data supplied in the `send()` method (if any).\nThe `Message` and original `CorrelationData` (if any) are provided as arguments.\nThe following example shows how to use the `postProcess` method:\n\n[source, java]\n----\nCorrelationData postProcess(Message message, CorrelationData correlationData);\n----\n\n[[publisher-returns]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/sending-messages.adoc", "title": "sending-messages", "heading": "Message Builder API", "heading_level": 2, "file_order": 49, "section_index": 1, "content_hash": "16f8b2a88da2d664dae5ea2df8cd19376c4aec0c796b506ee123ad055cc73290", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/sending-messages.adoc"}}
{"id": "sha256:0c54cb3a96867924d8dc8a775f4198547be44e39ba291bf10a228a59784a2d21", "content": "When the template's `mandatory` property is `true`, returned messages are provided by the callback described in xref:amqp/template.adoc[`AmqpTemplate`].\n\nStarting with version 1.4, the `RabbitTemplate` supports the SpEL `mandatoryExpression` property, which is evaluated against each request message as the root evaluation object, resolving to a `boolean` value.\nBean references, such as `@myBean.isMandatory(#root)`, can be used in the expression.\n\nPublisher returns can also be used internally by the `RabbitTemplate` in send and receive operations.\nSee xref:amqp/request-reply.adoc#reply-timeout[Reply Timeout] for more information.\n\n[[template-batching]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/sending-messages.adoc", "title": "sending-messages", "heading": "Publisher Returns", "heading_level": 2, "file_order": 49, "section_index": 2, "content_hash": "0c54cb3a96867924d8dc8a775f4198547be44e39ba291bf10a228a59784a2d21", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/sending-messages.adoc"}}
{"id": "sha256:8b5ae7a350889b7a4577d5b61ebceca937762bc79f8491d3ca24e8c96a84da62", "content": "Version 1.4.2 introduced the `BatchingRabbitTemplate`.\nThis is a subclass of `RabbitTemplate` with an overridden `send` method that batches messages according to the `BatchingStrategy`.\nOnly when a batch is complete is the message sent to RabbitMQ.\nThe following listing shows the `BatchingStrategy` interface definition:\n\n[source, java]\n----\npublic interface BatchingStrategy {\n\n MessageBatch addToBatch(String exchange, String routingKey, Message message);\n\n Date nextRelease();\n\n Collection<MessageBatch> releaseBatches();\n\n}\n----\n\nCAUTION: Batched data is held in memory.\nUnsent messages can be lost in the event of a system failure.\n\nA `SimpleBatchingStrategy` is provided.\nIt supports sending messages to a single exchange or routing key.\nIt has the following properties:\n\n* `batchSize`: The number of messages in a batch before it is sent.\n* `bufferLimit`: The maximum size of the batched message.\nThis preempts the `batchSize`, if exceeded, and causes a partial batch to be sent.\n* `timeout`: A time after which a partial batch is sent when there is no new activity adding messages to the batch.\n\nThe `SimpleBatchingStrategy` formats the batch by preceding each embedded message with a four-byte binary length.\nThis is communicated to the receiving system by setting the `springBatchFormat` message property to `lengthHeader4`.\n\nIMPORTANT: Batched messages are automatically de-batched by listener containers by default (by using the `springBatchFormat` message header).\nRejecting any message from a batch causes the entire batch to be rejected.\n\nHowever, see xref:amqp/receiving-messages/batch.adoc[@RabbitListener with Batching] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/sending-messages.adoc", "title": "sending-messages", "heading": "Batching", "heading_level": 2, "file_order": 49, "section_index": 3, "content_hash": "8b5ae7a350889b7a4577d5b61ebceca937762bc79f8491d3ca24e8c96a84da62", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/sending-messages.adoc"}}
{"id": "sha256:c7326ec9817bda8347cf95e5cacc0019e2a985109aa7519a5660b16aadfa8b06", "content": "[[amqp-template]]\n\nAs with many other high-level abstractions provided by the Spring Framework and related projects, Spring AMQP provides a \"`template`\" that plays a central role.\nThe interface that defines the main operations is called `AmqpTemplate`.\nThose operations cover the general behavior for sending and receiving messages.\nIn other words, they are not unique to any implementation -- hence the \"`AMQP`\" in the name.\nOn the other hand, there are implementations of that interface that are tied to implementations of the AMQP protocol.\nUnlike JMS, which is an interface-level API itself, AMQP is a wire-level protocol.\nThe implementations of that protocol provide their own client libraries, so each implementation of the template interface depends on a particular client library.\nCurrently, there is only a single implementation: `RabbitTemplate`.\nIn the examples that follow, we often use an `AmqpTemplate`.\nHowever, when you look at the configuration examples or any code excerpts where the template is instantiated or setters are invoked, you can see the implementation type (for example, `RabbitTemplate`).\n\nAs mentioned earlier, the `AmqpTemplate` interface defines all the basic operations for sending and receiving messages.\nWe will explore message sending and reception, respectively, in xref:amqp/sending-messages.adoc#sending-messages[Sending Messages] and xref:amqp/receiving-messages.adoc#receiving-messages[Receiving Messages].\n\nSee also xref:amqp/request-reply.adoc#async-template[Async Rabbit Template].\n\n[[template-retry]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/template.adoc", "title": "template", "heading": "template", "heading_level": 1, "file_order": 50, "section_index": 0, "content_hash": "c7326ec9817bda8347cf95e5cacc0019e2a985109aa7519a5660b16aadfa8b06", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/template.adoc"}}
{"id": "sha256:5621beb0e84e1eda5fcd9529e1e258f5aaa9bac3adcac7599274aa6e4e750a10", "content": "Starting with version 1.3, you can now configure the `RabbitTemplate` to use a `RetryTemplate` to help with handling problems with broker connectivity.\nSee the {spring-framework-javadoc}/org/springframework/core/retry/package-summary.html[Core Retry] support in Spring Framework for more information.\nThe following is only one example that uses an exponential back off policy and the default `SimpleRetryPolicy`, which makes three tries before throwing the exception to the caller.\n\nThe following example uses the `@Configuration` annotation in Java:\n\n[source,java]\n----\npublic RabbitTemplate rabbitTemplate() {\n RabbitTemplate template = new RabbitTemplate(connectionFactory());\n RetryPolicy retryPolicy = RetryPolicy.builder()\n .delay(Duration.ofMillis(500))\n .multiplier(2.0)\n .maxDelay(Duration.ofSeconds(10))\n .build();\n template.setRetryTemplate(new RetryTemplate(retryPolicy));\n return template;\n}\n----\n\nStarting with version 1.4, in addition to the `retryTemplate` property, the `recoveryCallback` option is supported on the `RabbitTemplate`.\nIt is used as a second argument for the `RetryTemplate.execute(RetryCallback<T, E> retryCallback, RecoveryCallback<T> recoveryCallback)`.\n\nNOTE: The `RecoveryCallback` is somewhat limited, in that the retry context contains only the `lastThrowable` field.\nFor more sophisticated use cases, you should use an external `RetryTemplate` so that you can convey additional information to the `RecoveryCallback` through the context's attributes.\nThe following example shows how to do so:\n\n[source,java]\n----\nretryTemplate.execute(\n new RetryCallback<Object, Exception>() {\n\n @Override\n public Object doWithRetry(RetryContext context) throws Exception {\n context.setAttribute(\"message\", message);\n return rabbitTemplate.convertAndSend(exchange, routingKey, message);\n }\n\n }, new RecoveryCallback<Object>() {\n\n @Override\n public Object recover(RetryContext context) throws Exception {\n Object message = context.getAttribute(\"message\");\n Throwable t = context.getLastThrowable();\n // Do something with message\n return null;\n }\n });\n}\n----\n\nIn this case, you would *not* inject a `RetryTemplate` into the `RabbitTemplate`.\n\n[[publishing-is-async]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/template.adoc", "title": "template", "heading": "Adding Retry Capabilities", "heading_level": 2, "file_order": 50, "section_index": 1, "content_hash": "5621beb0e84e1eda5fcd9529e1e258f5aaa9bac3adcac7599274aa6e4e750a10", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/template.adoc"}}
{"id": "sha256:0a0b2b4b056970eaae0952b94a26e2cc24b4a29344b189cf33c36ae8bafa62f9", "content": "Publishing messages is an asynchronous mechanism and, by default, messages that cannot be routed are dropped by RabbitMQ.\nFor successful publishing, you can receive an asynchronous confirm, as described in xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns].\nConsider two failure scenarios:\n\n* Publish to an exchange but there is no matching destination queue.\n* Publish to a non-existent exchange.\n\nThe first case is covered by publisher returns, as described in xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns].\n\nFor the second case, the message is dropped and no return is generated.\nThe underlying channel is closed with an exception.\nBy default, this exception is logged, but you can register a `ChannelListener` with the `CachingConnectionFactory` to obtain notifications of such events.\nThe following example shows how to add a `ConnectionListener`:\n\n[source, java]\n----\nthis.connectionFactory.addConnectionListener(new ConnectionListener() {\n\n @Override\n public void onCreate(Connection connection) {\n }\n\n @Override\n public void onShutDown(ShutdownSignalException signal) {\n ...\n }\n\n});\n----\n\nYou can examine the signal's `reason` property to determine the problem that occurred.\n\nTo detect the exception on the sending thread, you can `setChannelTransacted(true)` on the `RabbitTemplate` and the exception is detected on the `txCommit()`.\nHowever, *transactions significantly impede performance*, so consider this carefully before enabling transactions for just this one use case.\n\n[[template-confirms]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/template.adoc", "title": "template", "heading": "Publishing is Asynchronous -- How to Detect Successes and Failures", "heading_level": 2, "file_order": 50, "section_index": 2, "content_hash": "0a0b2b4b056970eaae0952b94a26e2cc24b4a29344b189cf33c36ae8bafa62f9", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/template.adoc"}}
{"id": "sha256:4cdb7396056be4ea3414ae8c993a604ee5f9b254e41c52b5a32276dedb8a0146", "content": "The `RabbitTemplate` implementation of `AmqpTemplate` supports publisher confirms and returns.\n\nFor returned messages, the template's `mandatory` property must be set to `true` or the `mandatory-expression`\nmust evaluate to `true` for a particular message.\nThis feature requires a `CachingConnectionFactory` that has its `publisherReturns` property set to `true` (see xref:amqp/connections.adoc#cf-pub-conf-ret[Publisher Confirms and Returns]).\nReturns are sent to the client by it registering a `RabbitTemplate.ReturnsCallback` by calling `setReturnsCallback(ReturnsCallback callback)`.\nThe callback must implement the following method:\n\n[source,java]\n----\nvoid returnedMessage(ReturnedMessage returned);\n----\n\nThe `ReturnedMessage` has the following properties:\n\n- `message` - the returned message itself\n- `replyCode` - a code indicating the reason for the return\n- `replyText` - a textual reason for the return - e.g. `NO_ROUTE`\n- `exchange` - the exchange to which the message was sent\n- `routingKey` - the routing key that was used\n\nOnly one `ReturnsCallback` is supported by each `RabbitTemplate`.\nSee also xref:amqp/request-reply.adoc#reply-timeout[Reply Timeout].\n\nFor publisher confirms (also known as publisher acknowledgements), the template requires a `CachingConnectionFactory` that has its `publisherConfirm` property set to `ConfirmType.CORRELATED`.\nConfirms are sent to the client by it registering a `RabbitTemplate.ConfirmCallback` by calling `setConfirmCallback(ConfirmCallback callback)`.\nThe callback must implement this method:\n\n[source,java]\n----\nvoid confirm(CorrelationData correlationData, boolean ack, String cause);\n----\n\nThe `CorrelationData` is an object supplied by the client when sending the original message.\nThe `ack` is true for an `ack` and false for a `nack`.\nFor `nack` instances, the cause may contain a reason for the `nack`, if it is available when the `nack` is generated.\nAn example is when sending a message to a non-existent exchange.\nIn that case, the broker closes the channel.\nThe reason for the closure is included in the `cause`.\nThe `cause` was added in version 1.4.\n\nOnly one `ConfirmCallback` is supported by a `RabbitTemplate`.\n\nNOTE: When a rabbit template send operation completes, the channel is closed.\nThis precludes the reception of confirms or returns when the connection factory cache is full (when there is space in the cache, the channel is not physically closed and the returns and confirms proceed normally).\nWhen the cache is full, the framework defers the close for up to five seconds, in order to allow time for the confirms and returns to be received.\nWhen using confirms, the channel is closed when the last confirm is received.\nWhen using only returns, the channel remains open for the full five seconds.\nWe generally recommend setting the connection factory's `channelCacheSize` to a large enough value so that the channel on which a message is published is returned to the cache instead of being closed.\nYou can monitor channel usage by using the RabbitMQ management plugin.\nIf you see channels being opened and closed rapidly, you should consider increasing the cache size to reduce overhead on the server.\n\nIMPORTANT: Before version 2.1, channels enabled for publisher confirms were returned to the cache before the confirms were received.\nSome other process could check out the channel and perform some operation that causes the channel to close -- such as publishing a message to a non-existent exchange.\nThis could cause the confirm to be lost.\nVersion 2.1 and later no longer return the channel to the cache while confirms are outstanding.\nThe `RabbitTemplate` performs a logical `close()` on the channel after each operation.\nIn general, this means that only one confirm is outstanding on a channel at a time.\n\nNOTE: Starting with version 2.2, the callbacks are invoked on one of the connection factory's `executor` threads.\nThis is to avoid a potential deadlock if you perform Rabbit operations from within the callback.\nWith previous versions, the callbacks were invoked directly on the `amqp-client` connection I/O thread; this would deadlock if you perform some RPC operation (such as opening a new channel) since the I/O thread blocks waiting for the result, but the result needs to be processed by the I/O thread itself.\nWith those versions, it was necessary to hand off work (such as sending a message) to another thread within the callback.\nThis is no longer necessary since the framework now hands off the callback invocation to the executor.\n\nIMPORTANT: The guarantee of receiving a returned message before the ack is still maintained as long as the return callback executes in 60 seconds or less.\nThe confirm is scheduled to be delivered after the return callback exits or after 60 seconds, whichever comes first.\n\nThe `CorrelationData` object has a `CompletableFuture` that you can use to get the result, instead of using a `ConfirmCallback` on the template.\nThe following example shows how to configure a `CorrelationData` instance:\n\n[source, java]\n----\nCorrelationData cd1 = new CorrelationData();\nthis.templateWithConfirmsEnabled.convertAndSend(\"exchange\", queue.getName(), \"foo\", cd1);\nassertTrue(cd1.getFuture().get(10, TimeUnit.SECONDS).isAck());\nReturnedMessage = cd1.getReturn();\n...\n----\n\nSince it is a `CompletableFuture<Confirm>`, you can either `get()` the result when ready or use `whenComplete()` for an asynchronous callback.\nThe `Confirm` object is a simple bean with 2 properties: `ack` and `reason` (for `nack` instances).\nThe reason is not populated for broker-generated `nack` instances.\nIt is populated for `nack` instances generated by the framework (for example, closing the connection while `ack` instances are outstanding).\n\nIn addition, when both confirms and returns are enabled, the `CorrelationData` `return` property is populated with the returned message, if it couldn't be routed to any queue.\nIt is guaranteed that the returned message property is set before the future is set with the `ack`.\n`CorrelationData.getReturn()` returns a `ReturnMessage` with properties:\n\n* message (the returned message)\n* replyCode\n* replyText\n* exchange\n* routingKey\n\nSee also xref:amqp/template.adoc#scoped-operations[Scoped Operations] for a simpler mechanism for waiting for publisher confirms.\n\n[[scoped-operations]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/template.adoc", "title": "template", "heading": "Correlated Publisher Confirms and Returns", "heading_level": 2, "file_order": 50, "section_index": 3, "content_hash": "4cdb7396056be4ea3414ae8c993a604ee5f9b254e41c52b5a32276dedb8a0146", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/template.adoc"}}
{"id": "sha256:d57b4400e48e24f7ac63d349f1ce02c25d91e0e05a971fe6a5e60efc8cf5bf83", "content": "Normally, when using the template, a `Channel` is checked out of the cache (or created), used for the operation, and returned to the cache for reuse.\nIn a multi-threaded environment, there is no guarantee that the next operation uses the same channel.\nThere may be times, however, where you want to have more control over the use of a channel and ensure that a number of operations are all performed on the same channel.\n\nStarting with version 2.0, a new method called `invoke` is provided, with an `OperationsCallback`.\nAny operations performed within the scope of the callback and on the provided `RabbitOperations` argument use the same dedicated `Channel`, which will be closed at the end (not returned to a cache).\nIf the channel is a `PublisherCallbackChannel`, it is returned to the cache after all confirms have been received (see xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns]).\n\n[source, java]\n----\n@FunctionalInterface\npublic interface OperationsCallback<T> {\n\n T doInRabbit(RabbitOperations operations);\n\n}\n----\n\nOne example of why you might need this is if you wish to use the `waitForConfirms()` method on the underlying `Channel`.\nThis method was not previously exposed by the Spring API because the channel is, generally, cached and shared, as discussed earlier.\nThe `RabbitTemplate` now provides `waitForConfirms(long timeout)` and `waitForConfirmsOrDie(long timeout)`, which delegate to the dedicated channel used within the scope of the `OperationsCallback`.\nThe methods cannot be used outside of that scope, for obvious reasons.\n\nNote that a higher-level abstraction that lets you correlate confirms to requests is provided elsewhere (see xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns]).\nIf you want only to wait until the broker has confirmed delivery, you can use the technique shown in the following example:\n\n[source, java]\n----\nCollection<?> messages = getMessagesToSend();\nBoolean result = this.template.invoke(t -> {\n messages.forEach(m -> t.convertAndSend(ROUTE, m));\n t.waitForConfirmsOrDie(10_000);\n return true;\n});\n----\n\nIf you wish `RabbitAdmin` operations to be invoked on the same channel within the scope of the `OperationsCallback`, the admin must have been constructed by using the same `RabbitTemplate` that was used for the `invoke` operation.\n\nNOTE: The preceding discussion is moot if the template operations are already performed within the scope of an existing transaction -- for example, when running on a transacted listener container thread and performing operations on a transacted template.\nIn that case, the operations are performed on that channel and committed when the thread returns to the container.\nIt is not necessary to use `invoke` in that scenario.\n\nWhen using confirms in this way, much of the infrastructure set up for correlating confirms to requests is not really needed (unless returns are also enabled).\nStarting with version 2.2, the connection factory supports a new property called `publisherConfirmType`.\nWhen this is set to `ConfirmType.SIMPLE`, the infrastructure is avoided and the confirm processing can be more efficient.\n\nFurthermore, the `RabbitTemplate` sets the `publisherSequenceNumber` property in the sent message `MessageProperties`.\nIf you wish to check (or log or otherwise use) specific confirms, you can do so with an overloaded `invoke` method, as the following example shows:\n\n[source, java]\n----\npublic <T> T invoke(OperationsCallback<T> action, com.rabbitmq.client.ConfirmCallback acks,\n com.rabbitmq.client.ConfirmCallback nacks);\n----\n\nNOTE: These `ConfirmCallback` objects (for `ack` and `nack` instances) are the Rabbit client callbacks, not the template callback.\n\nThe following example logs `ack` and `nack` instances:\n\n[source, java]\n----\nCollection<?> messages = getMessagesToSend();\nBoolean result = this.template.invoke(t -> {\n messages.forEach(m -> t.convertAndSend(ROUTE, m));\n t.waitForConfirmsOrDie(10_000);\n return true;\n}, (tag, multiple) -> {\n log.info(\"Ack: \" + tag + \":\" + multiple);\n}, (tag, multiple) -> {\n log.info(\"Nack: \" + tag + \":\" + multiple);\n}));\n----\n\nIMPORTANT: Scoped operations are bound to a thread.\nSee xref:amqp/template.adoc#multi-strict[Strict Message Ordering in a Multi-Threaded Environment] for a discussion about strict ordering in a multi-threaded environment.\n\n[[multi-strict]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/template.adoc", "title": "template", "heading": "Scoped Operations", "heading_level": 2, "file_order": 50, "section_index": 4, "content_hash": "d57b4400e48e24f7ac63d349f1ce02c25d91e0e05a971fe6a5e60efc8cf5bf83", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/template.adoc"}}
{"id": "sha256:a595f448390e5dc706d55f5dcc8e35d077549a71d13a13f287bfab9f1ea1f3b8", "content": "The discussion in xref:amqp/template.adoc#scoped-operations[Scoped Operations] applies only when the operations are performed on the same thread.\n\nConsider the following situation:\n\n* `thread-1` sends a message to a queue and hands off work to `thread-2`\n* `thread-2` sends a message to the same queue\n\nBecause of the async nature of RabbitMQ and the use of cached channels; it is not certain that the same channel will be used and therefore the order in which the messages arrive in the queue is not guaranteed.\n(In most cases they will arrive in order, but the probability of out-of-order delivery is not zero).\nTo solve this use case, you can use a bounded channel cache with size `1` (together with a `channelCheckoutTimeout`) to ensure the messages are always published on the same channel, and order will be guaranteed.\nTo do this, if you have other uses for the connection factory, such as consumers, you should either use a dedicated connection factory for the template, or configure the template to use the publisher connection factory embedded in the main connection factory (see xref:amqp/template.adoc#separate-connection[Using a Separate Connection]).\n\nThis is best illustrated with a simple Spring Boot Application:\n\n[source, java]\n----\n@SpringBootApplication\npublic class Application {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(Application.class);\n\n\tpublic static void main(String[] args) {\n SpringApplication.run(Application.class, args);\n\t}\n\n\t@Bean\n\tTaskExecutor exec() {\n ThreadPoolTaskExecutor exec = new ThreadPoolTaskExecutor();\n exec.setCorePoolSize(10);\n return exec;\n\t}\n\n\t@Bean\n\tCachingConnectionFactory ccf() {\n CachingConnectionFactory ccf = new CachingConnectionFactory(\"localhost\");\n CachingConnectionFactory publisherCF = (CachingConnectionFactory) ccf.getPublisherConnectionFactory();\n publisherCF.setChannelCacheSize(1);\n publisherCF.setChannelCheckoutTimeout(1000L);\n return ccf;\n\t}\n\n\t@RabbitListener(queues = \"queue\")\n\tvoid listen(String in) {\n log.info(in);\n\t}\n\n\t@Bean\n\tQueue queue() {\n return new Queue(\"queue\");\n\t}\n\n\t@Bean\n\tpublic ApplicationRunner runner(Service service, TaskExecutor exec) {\n return args -> {\n exec.execute(() -> service.mainService(\"test\"));\n };\n\t}\n\n}\n\n@Component\nclass Service {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(Service.class);\n\n\tprivate final RabbitTemplate template;\n\n\tprivate final TaskExecutor exec;\n\n\tService(RabbitTemplate template, TaskExecutor exec) {\n template.setUsePublisherConnection(true);\n this.template = template;\n this.exec = exec;\n\t}\n\n\tvoid mainService(String toSend) {\n LOG.info(\"Publishing from main service\");\n this.template.convertAndSend(\"queue\", toSend);\n this.exec.execute(() -> secondaryService(toSend.toUpperCase()));\n\t}\n\n\tvoid secondaryService(String toSend) {\n LOG.info(\"Publishing from secondary service\");\n this.template.convertAndSend(\"queue\", toSend);\n\t}\n\n}\n----\n\nEven though the publishing is performed on two different threads, they will both use the same channel because the cache is capped at a single channel.\n\nStarting with version 2.3.7, the `ThreadChannelConnectionFactory` supports transferring a thread's channel(s) to another thread, using the `prepareContextSwitch` and `switchContext` methods.\nThe first method returns a context which is passed to the second thread which calls the second method.\nA thread can have either a non-transactional channel or a transactional channel (or one of each) bound to it; you cannot transfer them individually, unless you use two connection factories.\nAn example follows:\n\n[source, java]\n----\n@SpringBootApplication\npublic class Application {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(Application.class);\n\n\tpublic static void main(String[] args) {\n SpringApplication.run(Application.class, args);\n\t}\n\n\t@Bean\n\tTaskExecutor exec() {\n ThreadPoolTaskExecutor exec = new ThreadPoolTaskExecutor();\n exec.setCorePoolSize(10);\n return exec;\n\t}\n\n\t@Bean\n\tThreadChannelConnectionFactory tccf() {\n ConnectionFactory rabbitConnectionFactory = new ConnectionFactory();\n rabbitConnectionFactory.setHost(\"localhost\");\n return new ThreadChannelConnectionFactory(rabbitConnectionFactory);\n\t}\n\n\t@RabbitListener(queues = \"queue\")\n\tvoid listen(String in) {\n log.info(in);\n\t}\n\n\t@Bean\n\tQueue queue() {\n return new Queue(\"queue\");\n\t}\n\n\t@Bean\n\tpublic ApplicationRunner runner(Service service, TaskExecutor exec) {\n return args -> {\n exec.execute(() -> service.mainService(\"test\"));\n };\n\t}\n\n}\n\n@Component\nclass Service {\n\n\tprivate static final Logger LOG = LoggerFactory.getLogger(Service.class);\n\n\tprivate final RabbitTemplate template;\n\n\tprivate final TaskExecutor exec;\n\n\tprivate final ThreadChannelConnectionFactory connFactory;\n\n\tService(RabbitTemplate template, TaskExecutor exec,\n ThreadChannelConnectionFactory tccf) {\n\n this.template = template;\n this.exec = exec;\n this.connFactory = tccf;\n\t}\n\n\tvoid mainService(String toSend) {\n LOG.info(\"Publishing from main service\");\n this.template.convertAndSend(\"queue\", toSend);\n Object context = this.connFactory.prepareSwitchContext();\n this.exec.execute(() -> secondaryService(toSend.toUpperCase(), context));\n\t}\n\n\tvoid secondaryService(String toSend, Object threadContext) {\n LOG.info(\"Publishing from secondary service\");\n this.connFactory.switchContext(threadContext);\n this.template.convertAndSend(\"queue\", toSend);\n this.connFactory.closeThreadChannel();\n\t}\n\n}\n----\n\nIMPORTANT: Once the `prepareSwitchContext` is called, if the current thread performs any more operations, they will be performed on a new channel.\nIt is important to close the thread-bound channel when it is no longer needed.\n\n[[template-messaging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/template.adoc", "title": "template", "heading": "Strict Message Ordering in a Multi-Threaded Environment", "heading_level": 2, "file_order": 50, "section_index": 5, "content_hash": "a595f448390e5dc706d55f5dcc8e35d077549a71d13a13f287bfab9f1ea1f3b8", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/template.adoc"}}
{"id": "sha256:18a4ba40f85e72ccacd735bf125fadc7c4d7d3f4c22ec5f51b7618c2e6a76332", "content": "Starting with version 1.4, `RabbitMessagingTemplate` (built on top of `RabbitTemplate`) provides an integration with the Spring Framework messaging abstraction -- that is,\n`org.springframework.messaging.Message`.\nThis lets you send and receive messages by using the `spring-messaging` `Message<?>` abstraction.\nThis abstraction is used by other Spring projects, such as Spring Integration and Spring's STOMP support.\nThere are two message converters involved: one to convert between a spring-messaging `Message<?>` and Spring AMQP's `Message` abstraction and one to convert between Spring AMQP's `Message` abstraction and the format required by the underlying RabbitMQ client library.\nBy default, the message payload is converted by the provided `RabbitTemplate` instance's message converter.\nAlternatively, you can inject a custom `MessagingMessageConverter` with some other payload converter, as the following example shows:\n\n[source, java]\n----\nMessagingMessageConverter amqpMessageConverter = new MessagingMessageConverter();\namqpMessageConverter.setPayloadConverter(myPayloadConverter);\nrabbitMessagingTemplate.setAmqpMessageConverter(amqpMessageConverter);\n----\n\n[[template-user-id]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/template.adoc", "title": "template", "heading": "Messaging Integration", "heading_level": 2, "file_order": 50, "section_index": 6, "content_hash": "18a4ba40f85e72ccacd735bf125fadc7c4d7d3f4c22ec5f51b7618c2e6a76332", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/template.adoc"}}
{"id": "sha256:7512181eae117f961e55cf1fdf2f3888cb46e364c6f15c7b3305c04beed1be47", "content": "Starting with version 1.6, the template now supports a `user-id-expression` (`userIdExpression` when using Java configuration).\nIf a message is sent, the user id property is set (if not already set) after evaluating this expression.\nThe root object for the evaluation is the message to be sent.\n\nThe following examples show how to use the `user-id-expression` attribute:\n\n[source, xml]\n----\n<rabbit:template ... user-id-expression=\"'guest'\" />\n\n<rabbit:template ... user-id-expression=\"@myConnectionFactory.username\" />\n----\n\nThe first example is a literal expression.\nThe second obtains the `username` property from a connection factory bean in the application context.\n\n[[separate-connection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/template.adoc", "title": "template", "heading": "Validated User Id", "heading_level": 2, "file_order": 50, "section_index": 7, "content_hash": "7512181eae117f961e55cf1fdf2f3888cb46e364c6f15c7b3305c04beed1be47", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/template.adoc"}}
{"id": "sha256:5a39c488f380fd688b4864b2d5af61ca770c68ec4f3ff463c12b6c40cdd2aa70", "content": "Starting with version 2.0.2, you can set the `usePublisherConnection` property to `true` to use a different connection to that used by listener containers, when possible.\nThis is to avoid consumers being blocked when a producer is blocked for any reason.\nThe connection factories maintain a second internal connection factory for this purpose; by default it is the same type as the main factory, but can be set explicitly if you wish to use a different factory type for publishing.\nIf the rabbit template is running in a transaction started by the listener container, the container's channel is used, regardless of this setting.\n\nIMPORTANT: In general, you should not use a `RabbitAdmin` with a template that has this set to `true`.\nUse the `RabbitAdmin` constructor that takes a connection factory.\nIf you use the other constructor that takes a template, ensure the template's property is `false`.\nThis is because, often, an admin is used to declare queues for listener containers.\nUsing a template that has the property set to `true` would mean that exclusive queues (such as `AnonymousQueue`) would be declared on a different connection to that used by listener containers.\nIn that case, the queues cannot be used by the containers.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/template.adoc", "title": "template", "heading": "Using a Separate Connection", "heading_level": 2, "file_order": 50, "section_index": 8, "content_hash": "5a39c488f380fd688b4864b2d5af61ca770c68ec4f3ff463c12b6c40cdd2aa70", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/template.adoc"}}
{"id": "sha256:986877005459c4c5ee0b38d8fcd9cfb411e913acfe6a300b703a954959950e3b", "content": "[[transactions]]\n\nThe Spring Rabbit framework has support for automatic transaction management in the synchronous and asynchronous use cases with a number of different semantics that can be selected declaratively, as is familiar to existing users of Spring transactions.\nThis makes many if not most common messaging patterns easy to implement.\n\nThere are two ways to signal the desired transaction semantics to the framework.\nIn both the `RabbitTemplate` and `SimpleMessageListenerContainer`, there is a flag `channelTransacted` which, if `true`, tells the framework to use a transactional channel and to end all operations (send or receive) with a commit or rollback (depending on the outcome), with an exception signaling a rollback.\nAnother signal is to provide an external transaction with one of Spring's `PlatformTransactionManager` implementations as a context for the ongoing operation.\nIf there is already a transaction in progress when the framework is sending or receiving a message, and the `channelTransacted` flag is `true`, the commit or rollback of the messaging transaction is deferred until the end of the current transaction.\nIf the `channelTransacted` flag is `false`, no transaction semantics apply to the messaging operation (it is auto-acked).\n\nThe `channelTransacted` flag is a configuration time setting.\nIt is declared and processed once when the AMQP components are created, usually at application startup.\nThe external transaction is more dynamic in principle because the system responds to the current thread state at runtime.\nHowever, in practice, it is often also a configuration setting, when the transactions are layered onto an application declaratively.\n\nFor synchronous use cases with `RabbitTemplate`, the external transaction is provided by the caller, either declaratively or imperatively according to taste (the usual Spring transaction model).\nThe following example shows a declarative approach (usually preferred because it is non-invasive), where the template has been configured with `channelTransacted=true`:\n\n[source,java]\n----\n@Transactional\npublic void doSomething() {\n String incoming = rabbitTemplate.receiveAndConvert();\n // do some more database processing...\n String outgoing = processInDatabaseAndExtractReply(incoming);\n rabbitTemplate.convertAndSend(outgoing);\n}\n----\n\nIn the preceding example, a `String` payload is received, converted, and sent as a message body inside a method marked as `@Transactional`.\nIf the database processing fails with an exception, the incoming message is returned to the broker, and the outgoing message is not sent.\nThis applies to any operations with the `RabbitTemplate` inside a chain of transactional methods (unless, for instance, the `Channel` is directly manipulated to commit the transaction early).\n\nFor asynchronous use cases with `SimpleMessageListenerContainer`, if an external transaction is needed, it has to be requested by the container when it sets up the listener.\nTo signal that an external transaction is required, the user provides an implementation of `PlatformTransactionManager` to the container when it is configured.\nThe following example shows how to do so:\n\n[source,java]\n----\n@Configuration\npublic class ExampleExternalTransactionAmqpConfiguration {\n\n @Bean\n public SimpleMessageListenerContainer messageListenerContainer() {\n SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();\n container.setConnectionFactory(rabbitConnectionFactory());\n container.setTransactionManager(transactionManager());\n container.setChannelTransacted(true);\n container.setQueueName(\"some.queue\");\n container.setMessageListener(exampleListener());\n return container;\n }\n\n}\n----\n\nIn the preceding example, the transaction manager is added as a dependency injected from another bean definition (not shown), and the `channelTransacted` flag is also set to `true`.\nThe effect is that if the listener fails with an exception, the transaction is rolled back, and the message is also returned to the broker.\nSignificantly, if the transaction fails to commit (for example, because of\na database constraint error or connectivity problem), the AMQP transaction is also rolled back, and the message is returned to the broker.\nThis is sometimes known as a \"`Best Efforts 1 Phase Commit`\", and is a very powerful pattern for reliable messaging.\nIf the `channelTransacted` flag was set to `false` (the default) in the preceding example, the external transaction would still be provided for the listener, but all messaging operations would be auto-acked, so the effect is to commit the messaging operations even on a rollback of the business operation.\n\n[[conditional-rollback]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/transactions.adoc", "title": "transactions", "heading": "transactions", "heading_level": 1, "file_order": 51, "section_index": 0, "content_hash": "986877005459c4c5ee0b38d8fcd9cfb411e913acfe6a300b703a954959950e3b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/transactions.adoc"}}
{"id": "sha256:84de8b78a028c158ed271179a32028da4d53f55597ed9c97f35ba21df0239b6f", "content": "Prior to version 1.6.6, adding a rollback rule to a container's `transactionAttribute` when using an external transaction manager (such as JDBC) had no effect.\nExceptions always rolled back the transaction.\n\nAlso, when using a {spring-framework-docs}/data-access/transaction/declarative.html[transaction advice] in the container's advice chain, conditional rollback was not very useful, because all listener exceptions are wrapped in a `ListenerExecutionFailedException`.\n\nThe first problem has been corrected, and the rules are now applied properly.\nFurther, the `ListenerFailedRuleBasedTransactionAttribute` is now provided.\nIt is a subclass of `RuleBasedTransactionAttribute`, with the only difference being that it is aware of the `ListenerExecutionFailedException` and uses the cause of such exceptions for the rule.\nThis transaction attribute can be used directly in the container or through a transaction advice.\n\nThe following example uses this rule:\n\n[source, java]\n----\n@Bean\npublic AbstractMessageListenerContainer container() {\n ...\n container.setTransactionManager(transactionManager);\n RuleBasedTransactionAttribute transactionAttribute =\n new ListenerFailedRuleBasedTransactionAttribute();\n transactionAttribute.setRollbackRules(Collections.singletonList(\n new NoRollbackRuleAttribute(DontRollBackException.class)));\n container.setTransactionAttribute(transactionAttribute);\n ...\n}\n----\n\n[[transaction-rollback]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/transactions.adoc", "title": "transactions", "heading": "Conditional Rollback", "heading_level": 2, "file_order": 51, "section_index": 1, "content_hash": "84de8b78a028c158ed271179a32028da4d53f55597ed9c97f35ba21df0239b6f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/transactions.adoc"}}
{"id": "sha256:450884c88afd94273e137551525a87292a7bb7ceaa6e2d32d672a7adec1e1dff", "content": "AMQP transactions apply only to messages and acks sent to the broker.\nConsequently, when there is a rollback of a Spring transaction and a message has been received, Spring AMQP has to not only rollback the transaction but also manually reject the message (sort of a nack, but that is not what the specification calls it).\nThe action taken on message rejection is independent of transactions and depends on the `defaultRequeueRejected` property (default: `true`).\nFor more information about rejecting failed messages, see xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#async-listeners[Message Listeners and the Asynchronous Case].\n\nFor more information about RabbitMQ transactions and their limitations, see https://www.rabbitmq.com/semantics.html[RabbitMQ Broker Semantics].\n\nNOTE: Prior to RabbitMQ 2.7.0, such messages (and any that are unacked when a channel is closed or aborts) went to the back of the queue on a Rabbit broker.\nSince 2.7.0, rejected messages go to the front of the queue, in a similar manner to JMS rolled back messages.\n\nNOTE: Previously, message requeue on transaction rollback was inconsistent between local transactions and when a `TransactionManager` was provided.\nIn the former case, the normal requeue logic (`AmqpRejectAndDontRequeueException` or `defaultRequeueRejected=false`) applied (see xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#async-listeners[Message Listeners and the Asynchronous Case]).\nWith a transaction manager, the message was unconditionally requeued on rollback.\nStarting with version 2.0, the behavior is consistent and the normal requeue logic is applied in both cases.\nTo revert to the previous behavior, you can set the container's `alwaysRequeueWithTxManagerRollback` property to `true`.\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration].\n\n[[using-rabbittransactionmanager]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/transactions.adoc", "title": "transactions", "heading": "A note on Rollback of Received Messages", "heading_level": 2, "file_order": 51, "section_index": 2, "content_hash": "450884c88afd94273e137551525a87292a7bb7ceaa6e2d32d672a7adec1e1dff", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/transactions.adoc"}}
{"id": "sha256:621a9e3fe3861ff31533c4406a9195ce00f826a28c734d432c45590b93cf62ed", "content": "The javadoc:org.springframework.amqp.rabbit.transaction.RabbitTransactionManager[] is an alternative to executing Rabbit operations within, and synchronized with, external transactions.\nThis transaction manager is an implementation of the javadoc:org.springframework.transaction.PlatformTransactionManager[] interface and should be used with a single Rabbit `ConnectionFactory`.\n\nIMPORTANT: This strategy is not able to provide XA transactions -- for example, in order to share transactions between messaging and database access.\n\nApplication code is required to retrieve the transactional Rabbit resources through `ConnectionFactoryUtils.getTransactionalResourceHolder(ConnectionFactory, boolean)` instead of a standard `Connection.createChannel()` call with subsequent channel creation.\nWhen using Spring AMQP's javadoc:org.springframework.amqp.rabbit.core.RabbitTemplate[], it will autodetect a thread-bound Channel and automatically participate in its transaction.\n\nWith Java Configuration, you can setup a new RabbitTransactionManager by using the following bean:\n\n[source,java]\n----\n@Bean\npublic RabbitTransactionManager rabbitTransactionManager() {\n return new RabbitTransactionManager(connectionFactory);\n}\n----\n\nIf you prefer XML configuration, you can declare the following bean in your XML Application Context file:\n\n[source,xml]\n----\n<bean id=\"rabbitTxManager\"\n class=\"org.springframework.amqp.rabbit.transaction.RabbitTransactionManager\">\n <property name=\"connectionFactory\" ref=\"connectionFactory\"/>\n</bean>\n----\n\n[[tx-sync]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/transactions.adoc", "title": "transactions", "heading": "Using `RabbitTransactionManager`", "heading_level": 2, "file_order": 51, "section_index": 3, "content_hash": "621a9e3fe3861ff31533c4406a9195ce00f826a28c734d432c45590b93cf62ed", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/transactions.adoc"}}
{"id": "sha256:b33e2e8b1806562b6416767811b0ff14deb896c277a861b9180d2434d98c324e", "content": "Synchronizing a RabbitMQ transaction with some other (e.g. DBMS) transaction provides \"Best Effort One Phase Commit\" semantics.\nIt is possible that the RabbitMQ transaction fails to commit during the after completion phase of transaction synchronization.\nThis is logged by the `spring-tx` infrastructure as an error, but no exception is thrown to the calling code.\nStarting with version 2.3.10, you can call `ConnectionUtils.checkAfterCompletion()` after the transaction has committed on the same thread that processed the transaction.\nIt will simply return if no exception occurred; otherwise it will throw an `AfterCompletionFailedException` which will have a property representing the synchronization status of the completion.\n\nEnable this feature by calling `ConnectionFactoryUtils.enableAfterCompletionFailureCapture(true)`; this is a global flag and applies to all threads.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp/transactions.adoc", "title": "transactions", "heading": "Transaction Synchronization", "heading_level": 2, "file_order": 51, "section_index": 4, "content_hash": "b33e2e8b1806562b6416767811b0ff14deb896c277a861b9180d2434d98c324e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp/transactions.adoc"}}
{"id": "sha256:5455030831f38d56d0fbe5cccd4828984124f6fa4b3dacc29cadb86108eef527", "content": "[[changes-in-1-3-since-1-2]]\n\n[[listener-concurrency]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "changes-in-1-3-since-1-2", "heading_level": 1, "file_order": 52, "section_index": 0, "content_hash": "5455030831f38d56d0fbe5cccd4828984124f6fa4b3dacc29cadb86108eef527", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:5a3560a1353e8ee9db8a8bd0799b123db880ec1c406a7db061cde2a657e0c24f", "content": "The listener container now supports dynamic scaling of the number of consumers based on workload, or you can programmatically change the concurrency without stopping the container.\nSee xref:amqp/listener-concurrency.adoc#listener-concurrency[Listener Concurrency].\n\n[[listener-queues]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "Listener Concurrency", "heading_level": 2, "file_order": 52, "section_index": 1, "content_hash": "5a3560a1353e8ee9db8a8bd0799b123db880ec1c406a7db061cde2a657e0c24f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:9804ed7957b13c5d2530ac97587350df340845af837779ee094652163de1a4cb", "content": "The listener container now permits the queues on which it listens to be modified at runtime.\nAlso, the container now starts if at least one of its configured queues is available for use.\nSee xref:amqp/listener-queues.adoc#listener-queues[Listener Container Queues]\n\nThis listener container now redeclares any auto-delete queues during startup.\nSee xref:amqp/receiving-messages/async-consumer.adoc#lc-auto-delete[`auto-delete` Queues].\n\n[[consumer-priority]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "Listener Queues", "heading_level": 2, "file_order": 52, "section_index": 2, "content_hash": "9804ed7957b13c5d2530ac97587350df340845af837779ee094652163de1a4cb", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:6700ab4e596396cb1b7e46fdb5e296ae728ccdf8d9722e8e12806629e1799b18", "content": "The listener container now supports consumer arguments, letting the `x-priority` argument be set.\nSee xref:amqp/receiving-messages/async-consumer.adoc#consumer-priority[Consumer Priority].\n\n[[exclusive-consumer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "Consumer Priority", "heading_level": 2, "file_order": 52, "section_index": 3, "content_hash": "6700ab4e596396cb1b7e46fdb5e296ae728ccdf8d9722e8e12806629e1799b18", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:2ba4ad247e6e2492f0db8f8d4e07b4f1947d1db5445c484d98ecbaf5be47e703", "content": "You can now configure `SimpleMessageListenerContainer` with a single `exclusive` consumer, preventing other consumers from listening to the queue.\nSee xref:amqp/exclusive-consumer.adoc[Exclusive Consumer].\n\n[[rabbit-admin]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "Exclusive Consumer", "heading_level": 2, "file_order": 52, "section_index": 4, "content_hash": "2ba4ad247e6e2492f0db8f8d4e07b4f1947d1db5445c484d98ecbaf5be47e703", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:0d534a845e8308952b93e0000c4767a66551d825829db40f92d75b6e21c7d6d7", "content": "You can now have the broker generate the queue name, regardless of `durable`, `autoDelete`, and `exclusive` settings.\nSee xref:amqp/broker-configuration.adoc[Configuring the Broker].\n\n[[direct-exchange-binding]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "Rabbit Admin", "heading_level": 2, "file_order": 52, "section_index": 5, "content_hash": "0d534a845e8308952b93e0000c4767a66551d825829db40f92d75b6e21c7d6d7", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:863cefd536835e26138e8c33806fe28301ceca6f473ab9646515e194097ca3d9", "content": "Previously, omitting the `key` attribute from a `binding` element of a `direct-exchange` configuration caused the queue or exchange to be bound with an empty string as the routing key.\nNow it is bound with the the name of the provided `Queue` or `Exchange`.\nIf you wish to bind with an empty string routing key, you need to specify `key=\"\"`.\n\n[[amqptemplate-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "Direct Exchange Binding", "heading_level": 2, "file_order": 52, "section_index": 6, "content_hash": "863cefd536835e26138e8c33806fe28301ceca6f473ab9646515e194097ca3d9", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:83723ad180507be0015034d62d6aca7ae44f4f5aa0ad4d82f0acd3cb75f1b21e", "content": "The `AmqpTemplate` now provides several synchronous `receiveAndReply` methods.\nThese are implemented by the `RabbitTemplate`.\nFor more information see xref:amqp/receiving-messages.adoc[Receiving Messages].\n\nThe `RabbitTemplate` now supports configuring a `RetryTemplate` to attempt retries (with optional back-off policy) for when the broker is not available.\nFor more information see xref:amqp/template.adoc#template-retry[Adding Retry Capabilities].\n\n[[caching-connection-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "`AmqpTemplate` Changes", "heading_level": 2, "file_order": 52, "section_index": 7, "content_hash": "83723ad180507be0015034d62d6aca7ae44f4f5aa0ad4d82f0acd3cb75f1b21e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:acfc57d971bc21347a775e91f00cbc7201c3b084471cb274bfb75a9b356d5649", "content": "You can now configure the caching connection factory to cache `Connection` instances and their `Channel` instances instead of using a single connection and caching only `Channel` instances.\nSee xref:amqp/connections.adoc[Connection and Resource Management].\n\n[[binding-arguments]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "Caching Connection Factory", "heading_level": 2, "file_order": 52, "section_index": 8, "content_hash": "acfc57d971bc21347a775e91f00cbc7201c3b084471cb274bfb75a9b356d5649", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:0b3dc8588d369b39f913fa74405653a8e629034f8f6700170101438568515e33", "content": "The `<binding>` of the `<exchange>` now supports parsing of the `<binding-arguments>` sub-element.\nYou can now configure the `<binding>` of the `<headers-exchange>` with a `key/value` attribute pair (to match on a single header) or with a `<binding-arguments>` sub-element (allowing matching on multiple headers).\nThese options are mutually exclusive.\nSee xref:amqp/broker-configuration.adoc#headers-exchange[Headers Exchange].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "Binding Arguments", "heading_level": 2, "file_order": 52, "section_index": 9, "content_hash": "0b3dc8588d369b39f913fa74405653a8e629034f8f6700170101438568515e33", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:06c795386e87586a61bbd8bcd54b79720d4386b014951d028fae89e12292be53", "content": "A new `SimpleRoutingConnectionFactory` has been introduced.\nIt allows configuration of `ConnectionFactories` mapping, to determine the target `ConnectionFactory` to use at runtime.\nSee xref:amqp/connections.adoc#routing-connection-factory[Routing Connection Factory].\n\n[[messagebuilder-and-messagepropertiesbuilder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "Routing Connection Factory", "heading_level": 2, "file_order": 52, "section_index": 10, "content_hash": "06c795386e87586a61bbd8bcd54b79720d4386b014951d028fae89e12292be53", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:d3d3961ddfe626b7c5cd7e138f7c7aece77f0dc6d5e390be0f994b69acd5717e", "content": "\"`Fluent APIs`\" for building messages or message properties are now provided.\nSee xref:amqp/sending-messages.adoc#message-builder[Message Builder API].\n\n[[retryinterceptorbuilder-change]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "`MessageBuilder` and `MessagePropertiesBuilder`", "heading_level": 2, "file_order": 52, "section_index": 11, "content_hash": "d3d3961ddfe626b7c5cd7e138f7c7aece77f0dc6d5e390be0f994b69acd5717e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:996de2165653a8726eb8b8ac6bff995ed3ab55e3ca618a4394f6b4cf817f50c0", "content": "A \"`Fluent API`\" for building listener container retry interceptors is now provided.\nSee xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#retry[Failures in Synchronous Operations and Options for Retry].\n\n[[republishmessagerecoverer-added]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "`RetryInterceptorBuilder` Change", "heading_level": 2, "file_order": 52, "section_index": 12, "content_hash": "996de2165653a8726eb8b8ac6bff995ed3ab55e3ca618a4394f6b4cf817f50c0", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:85f2b45940a1ea09d6d1cf8d79afd23192c846299d648b32a0afbd721379d32c", "content": "This new `MessageRecoverer` is provided to allow publishing a failed message to another queue (including stack trace information in the header) when retries are exhausted.\nSee xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#async-listeners[Message Listeners and the Asynchronous Case].\n\n[[default-error-handler-since-1-3-2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "`RepublishMessageRecoverer` Added", "heading_level": 2, "file_order": 52, "section_index": 13, "content_hash": "85f2b45940a1ea09d6d1cf8d79afd23192c846299d648b32a0afbd721379d32c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:d01337c72c3e5ef97aa78061a6cf0c3d28f42b1f2777ed23bfe9bd72af5f34d7", "content": "A default `ConditionalRejectingErrorHandler` has been added to the listener container.\nThis error handler detects fatal message conversion problems and instructs the container to reject the message to prevent the broker from continually redelivering the unconvertible message.\nSee xref:amqp/exception-handling.adoc[Exception Handling].\n\n[[listener-container-missingqueuesfatal-property-since-1-3-5]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "Default Error Handler (Since 1.3.2)", "heading_level": 2, "file_order": 52, "section_index": 14, "content_hash": "d01337c72c3e5ef97aa78061a6cf0c3d28f42b1f2777ed23bfe9bd72af5f34d7", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:c63a5bc3473b96ce2d38f9fd849a86d8797252597e18a916fefb7d557ea465a0", "content": "The `SimpleMessageListenerContainer` now has a property called `missingQueuesFatal` (default: `true`).\nPreviously, missing queues were always fatal.\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc", "title": "changes-in-1-3-since-1-2", "heading": "Listener Container `missingQueuesFatal` Property (Since 1.3.5)", "heading_level": 2, "file_order": 52, "section_index": 15, "content_hash": "c63a5bc3473b96ce2d38f9fd849a86d8797252597e18a916fefb7d557ea465a0", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-3-since-1-2.adoc"}}
{"id": "sha256:9acfc26d91c200406b739738a7eb98244b73129f2a03a196c32674c33d65659a", "content": "[[changes-in-1-4-since-1-3]]\n\n[[rabbitlistener-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "changes-in-1-4-since-1-3", "heading_level": 1, "file_order": 53, "section_index": 0, "content_hash": "9acfc26d91c200406b739738a7eb98244b73129f2a03a196c32674c33d65659a", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:d56b3f647f65ae3d410e0d42e62dc2bd33f878a25750272692b8e09a6d05b7bb", "content": "POJO listeners can be annotated with `@RabbitListener`, enabled by `@EnableRabbit` or `<rabbit:annotation-driven />`.\nSpring Framework 4.1 is required for this feature.\nSee xref:amqp/receiving-messages/async-annotation-driven.adoc[Annotation-driven Listener Endpoints] for more information.\n\n[[rabbitmessagingtemplate-added]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "`@RabbitListener` Annotation", "heading_level": 2, "file_order": 53, "section_index": 1, "content_hash": "d56b3f647f65ae3d410e0d42e62dc2bd33f878a25750272692b8e09a6d05b7bb", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:2bf1efaeeb26452b4a1ff11893d07a726811e1a6e7c6a7be4ae07aad94832990", "content": "A new `RabbitMessagingTemplate` lets you interact with RabbitMQ by using `spring-messaging` `Message` instances.\nInternally, it uses the `RabbitTemplate`, which you can configure as normal.\nSpring Framework 4.1 is required for this feature.\nSee xref:amqp/template.adoc#template-messaging[Messaging Integration] for more information.\n\n[[listener-container-missingqueuesfatal-attribute]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "`RabbitMessagingTemplate` Added", "heading_level": 2, "file_order": 53, "section_index": 2, "content_hash": "2bf1efaeeb26452b4a1ff11893d07a726811e1a6e7c6a7be4ae07aad94832990", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:7222b1f478724ac42ca44e0f81b58e678d0269e9ea45d9a7f07ff8c2d89f12a2", "content": "1.3.5 introduced the `missingQueuesFatal` property on the `SimpleMessageListenerContainer`.\nThis is now available on the listener container namespace element.\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration].\n\n[[rabbittemplate-confirmcallback-interface]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "Listener Container `missingQueuesFatal` Attribute", "heading_level": 2, "file_order": 53, "section_index": 3, "content_hash": "7222b1f478724ac42ca44e0f81b58e678d0269e9ea45d9a7f07ff8c2d89f12a2", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:5bce2ca30bbe018beed0dc06ea4f504d1060c5012c20d2b8b99f709011abf188", "content": "The `confirm` method on this interface has an additional parameter called `cause`.\nWhen available, this parameter contains the reason for a negative acknowledgement (nack).\nSee xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns].\n\n[[rabbitconnectionfactorybean-added]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "RabbitTemplate `ConfirmCallback` Interface", "heading_level": 2, "file_order": 53, "section_index": 4, "content_hash": "5bce2ca30bbe018beed0dc06ea4f504d1060c5012c20d2b8b99f709011abf188", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:6c93bddd10af78c028e318bc3b18a337254bd7c26da4faf8dde953844970abd8", "content": "`RabbitConnectionFactoryBean` creates the underlying RabbitMQ `ConnectionFactory` used by the `CachingConnectionFactory`.\nThis enables configuration of SSL options using Spring's dependency injection.\nSee xref:amqp/connections.adoc#connection-factory[Configuring the Underlying Client Connection Factory].\n\n[[using-cachingconnectionfactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "`RabbitConnectionFactoryBean` Added", "heading_level": 2, "file_order": 53, "section_index": 5, "content_hash": "6c93bddd10af78c028e318bc3b18a337254bd7c26da4faf8dde953844970abd8", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:9a69c49badf1cad42c010fa75d8767044a2c34379f3da77ce1fb241c268c77fd", "content": "The `CachingConnectionFactory` now lets the `connectionTimeout` be set as a property or as an attribute in the namespace.\nIt sets the property on the underlying RabbitMQ `ConnectionFactory`.\nSee xref:amqp/connections.adoc#connection-factory[Configuring the Underlying Client Connection Factory].\n\n[[log-appender]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "Using `CachingConnectionFactory`", "heading_level": 2, "file_order": 53, "section_index": 6, "content_hash": "9a69c49badf1cad42c010fa75d8767044a2c34379f3da77ce1fb241c268c77fd", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:f3d32ea19e2c113f6813106338fd6eade3578bfcb765dccefb6c49e56c394267", "content": "The Logback `org.springframework.amqp.rabbit.logback.AmqpAppender` has been introduced.\nIt provides options similar to `org.springframework.amqp.rabbit.log4j.AmqpAppender`.\nFor more information, see the JavaDoc of these classes.\n\nThe Log4j `AmqpAppender` now supports the `deliveryMode` property (`PERSISTENT` or `NON_PERSISTENT`, default: `PERSISTENT`).\nPreviously, all log4j messages were `PERSISTENT`.\n\nThe appender also supports modification of the `Message` before sending -- allowing, for example, the addition of custom headers.\nSubclasses should override the `postProcessMessageBeforeSend()`.\n\n[[listener-queues]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "Log Appender", "heading_level": 2, "file_order": 53, "section_index": 7, "content_hash": "f3d32ea19e2c113f6813106338fd6eade3578bfcb765dccefb6c49e56c394267", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:84c99b324d96e0c2e37cef657bb2d614605260ad8953225891837d90519888ea", "content": "The listener container now, by default, redeclares any missing queues during startup.\nA new `auto-declare` attribute has been added to the `<rabbit:listener-container>` to prevent these re-declarations.\nSee xref:amqp/receiving-messages/async-consumer.adoc#lc-auto-delete[`auto-delete` Queues].\n\n[[rabbittemplate:-mandatory-and-connectionfactoryselector-expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "Listener Queues", "heading_level": 2, "file_order": 53, "section_index": 8, "content_hash": "84c99b324d96e0c2e37cef657bb2d614605260ad8953225891837d90519888ea", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:fe63e36bac0ae2ff4423b293681f23591d86fd7a7d453665dc14b3118f426497", "content": "The `mandatoryExpression`, `sendConnectionFactorySelectorExpression`, and `receiveConnectionFactorySelectorExpression` SpEL Expression properties have been added to `RabbitTemplate`.\nThe `mandatoryExpression` is used to evaluate a `mandatory` boolean value against each request message when a `ReturnCallback` is in use.\nSee xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns].\nThe `sendConnectionFactorySelectorExpression` and `receiveConnectionFactorySelectorExpression` are used when an `AbstractRoutingConnectionFactory` is provided, to determine the `lookupKey` for the target `ConnectionFactory` at runtime on each AMQP protocol interaction operation.\nSee xref:amqp/connections.adoc#routing-connection-factory[Routing Connection Factory].\n\n[[listeners-and-the-routing-connection-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "`RabbitTemplate`: `mandatory` and `connectionFactorySelector` Expressions", "heading_level": 2, "file_order": 53, "section_index": 9, "content_hash": "fe63e36bac0ae2ff4423b293681f23591d86fd7a7d453665dc14b3118f426497", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:6a24e4c3da01d36bba7ac8b1aa9074d0d051613843c5c7eaaa30ddf25a697aae", "content": "You can configure a `SimpleMessageListenerContainer` with a routing connection factory to enable connection selection based on the queue names.\nSee xref:amqp/connections.adoc#routing-connection-factory[Routing Connection Factory].\n\n[[rabbittemplate:-recoverycallback-option]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "Listeners and the Routing Connection Factory", "heading_level": 2, "file_order": 53, "section_index": 10, "content_hash": "6a24e4c3da01d36bba7ac8b1aa9074d0d051613843c5c7eaaa30ddf25a697aae", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:741775d949df4e78ee4375ae42cf35353b20cedb53adebaf92508c2c35b5d27f", "content": "The `recoveryCallback` property has been added for use in the `retryTemplate.execute()`.\nSee xref:amqp/template.adoc#template-retry[Adding Retry Capabilities].\n\n[[messageconversionexception-change]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "`RabbitTemplate`: `RecoveryCallback` Option", "heading_level": 2, "file_order": 53, "section_index": 11, "content_hash": "741775d949df4e78ee4375ae42cf35353b20cedb53adebaf92508c2c35b5d27f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:6bd31470dce4368a8d8092dfcef4ee65b9b31d32c82d85c488dbfccf8d6a0a3f", "content": "This exception is now a subclass of `AmqpException`.\nConsider the following code:\n\n[source,java]\n----\ntry {\n template.convertAndSend(\"thing1\", \"thing2\", \"cat\");\n}\ncatch (AmqpException e) {\n\t...\n}\ncatch (MessageConversionException e) {\n\t...\n}\n----\n\nThe second catch block is no longer reachable and needs to be moved above the catch-all `AmqpException` catch block.\n\n[[rabbitmq-3-4-compatibility]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "`MessageConversionException` Change", "heading_level": 2, "file_order": 53, "section_index": 12, "content_hash": "6bd31470dce4368a8d8092dfcef4ee65b9b31d32c82d85c488dbfccf8d6a0a3f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:db4d247e01ca15ea5ddd7ddfd7669c0499d0e523ec2a727b7a529d3dffcabd95", "content": "Spring AMQP is now compatible with the RabbitMQ 3.4, including direct reply-to.\nSee xref:introduction/quick-tour.adoc#compatibility[Compatibility] and xref:amqp/request-reply.adoc#direct-reply-to[RabbitMQ Direct reply-to] for more information.\n\n[[contenttypedelegatingmessageconverter-added]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "RabbitMQ 3.4 Compatibility", "heading_level": 2, "file_order": 53, "section_index": 13, "content_hash": "db4d247e01ca15ea5ddd7ddfd7669c0499d0e523ec2a727b7a529d3dffcabd95", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:1ef4758da576b742b8c66efd6147510ebd1d59ca33f77824ce13c9eed1e9a7b9", "content": "The `ContentTypeDelegatingMessageConverter` has been introduced to select the `MessageConverter` to use, based on the `contentType` property in the `MessageProperties`.\nSee xref:amqp/message-converters.adoc[Message Converters] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc", "title": "changes-in-1-4-since-1-3", "heading": "`ContentTypeDelegatingMessageConverter` Added", "heading_level": 2, "file_order": 53, "section_index": 14, "content_hash": "1ef4758da576b742b8c66efd6147510ebd1d59ca33f77824ce13c9eed1e9a7b9", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-4-since-1-3.adoc"}}
{"id": "sha256:8d305d07528480cc63f3855f0dfeba7492b3bdeb0e09e08ff5ac67331add456e", "content": "[[changes-in-1-5-since-1-4]]\n\n[[spring-erlang-is-no-longer-supported]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "changes-in-1-5-since-1-4", "heading_level": 1, "file_order": 54, "section_index": 0, "content_hash": "8d305d07528480cc63f3855f0dfeba7492b3bdeb0e09e08ff5ac67331add456e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:40726e6a32f610ae42e0716edbc77e41e41627bd35148a856ecb887197235be8", "content": "The `spring-erlang` jar is no longer included in the distribution.\nUse xref:amqp/management-rest-api.adoc#management-rest-api[RabbitMQ REST API] instead.\n\n[[cachingconnectionfactory-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "`spring-erlang` Is No Longer Supported", "heading_level": 2, "file_order": 54, "section_index": 1, "content_hash": "40726e6a32f610ae42e0716edbc77e41e41627bd35148a856ecb887197235be8", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:bad2b41ff28c17fea48ca48ead514ba40c55dd690f659e1f6a2125767e53a489", "content": "[[empty-addresses-property-in-cachingconnectionfactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "`CachingConnectionFactory` Changes", "heading_level": 2, "file_order": 54, "section_index": 2, "content_hash": "bad2b41ff28c17fea48ca48ead514ba40c55dd690f659e1f6a2125767e53a489", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:fb6feff5a7d1e3b8bb17be7faf36fdd72cda2ab0b2569cef7d8de6184b3f9ff7", "content": "Previously, if the connection factory was configured with a host and port but an empty String was also supplied for\n`addresses`, the host and port were ignored.\nNow, an empty `addresses` String is treated the same as a `null`, and the host and port are used.\n\n[[uri-constructor]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Empty Addresses Property in `CachingConnectionFactory`", "heading_level": 3, "file_order": 54, "section_index": 3, "content_hash": "fb6feff5a7d1e3b8bb17be7faf36fdd72cda2ab0b2569cef7d8de6184b3f9ff7", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:4cb9e9fd707e0898acac05c11ded2a519e5c4fe38820c945cf70d6dc1b40aeda", "content": "The `CachingConnectionFactory` has an additional constructor, with a `URI` parameter, to configure the broker connection.\n\n[[connection-reset]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "URI Constructor", "heading_level": 3, "file_order": 54, "section_index": 4, "content_hash": "4cb9e9fd707e0898acac05c11ded2a519e5c4fe38820c945cf70d6dc1b40aeda", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:b7d4ce5b1c29ab19330b8738048ec3b8746af5fbc118120ac71848008d642d04", "content": "A new method called `resetConnection()` has been added to let users reset the connection (or connections).\nYou might use this, for example, to reconnect to the primary broker after failing over to the secondary broker.\nThis *does* impact in-process operations.\nThe existing `destroy()` method does exactly the same, but the new method has a less daunting name.\n\n[[properties-to-control-container-queue-declaration-behavior]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Connection Reset", "heading_level": 3, "file_order": 54, "section_index": 5, "content_hash": "b7d4ce5b1c29ab19330b8738048ec3b8746af5fbc118120ac71848008d642d04", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:ce25fddd0e48308bb0d91a151687aa26ab94c89c92788563513914c61e00b568", "content": "When the listener container consumers start, they attempt to passively declare the queues to ensure they are available\non the broker.\nPreviously, if these declarations failed (for example, because the queues didn't exist) or when an HA queue was being\nmoved, the retry logic was fixed at three retry attempts at five-second intervals.\nIf the queues still do not exist, the behavior is controlled by the `missingQueuesFatal` property (default: `true`).\nAlso, for containers configured to listen from multiple queues, if only a subset of queues are available, the consumer\nretried the missing queues on a fixed interval of 60 seconds.\n\nThe `declarationRetries`, `failedDeclarationRetryInterval`, and `retryDeclarationInterval` properties are now configurable.\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration] for more information.\n\n[[class-package-change]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Properties to Control Container Queue Declaration Behavior", "heading_level": 2, "file_order": 54, "section_index": 6, "content_hash": "ce25fddd0e48308bb0d91a151687aa26ab94c89c92788563513914c61e00b568", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:83516f098f6a6f9f068e51edbbf41df55f735244bf393065ef7a425404d1ae51", "content": "The `RabbitGatewaySupport` class has been moved from `o.s.amqp.rabbit.core.support` to `o.s.amqp.rabbit.core`.\n\n[[defaultmessagepropertiesconverter-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Class Package Change", "heading_level": 2, "file_order": 54, "section_index": 7, "content_hash": "83516f098f6a6f9f068e51edbbf41df55f735244bf393065ef7a425404d1ae51", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:a6dc57236298e84cc1bb265ba038342ce50812077017b1e80a1517cda3c1cc23", "content": "You can now configure the `DefaultMessagePropertiesConverter` to\ndetermine the maximum length of a `LongString` that is converted\nto a `String` rather than to a `DataInputStream`.\nThe converter has an alternative constructor that takes the value as a limit.\nPreviously, this limit was hard-coded at `1024` bytes.\n(Also available in 1.4.4).\n\n[[rabbitlistener-improvements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "`DefaultMessagePropertiesConverter` Changes", "heading_level": 2, "file_order": 54, "section_index": 8, "content_hash": "a6dc57236298e84cc1bb265ba038342ce50812077017b1e80a1517cda3c1cc23", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:8f18237d8cecdebee320663881f62cd7ad3f8f1aeb96a00a52a9ee3c6e7cea1b", "content": "[[queuebinding-for-rabbitlistener]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "`@RabbitListener` Improvements", "heading_level": 2, "file_order": 54, "section_index": 9, "content_hash": "8f18237d8cecdebee320663881f62cd7ad3f8f1aeb96a00a52a9ee3c6e7cea1b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:06260306e82bb2e576db1210450bb19ac07c280f01c299f4c1602a6e44368608", "content": "The `bindings` attribute has been added to the `@RabbitListener` annotation as mutually exclusive with the `queues`\nattribute to allow the specification of the `queue`, its `exchange`, and `binding` for declaration by a `RabbitAdmin` on\nthe Broker.\n\n[[spel-in-sendto]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "`@QueueBinding` for `@RabbitListener`", "heading_level": 3, "file_order": 54, "section_index": 10, "content_hash": "06260306e82bb2e576db1210450bb19ac07c280f01c299f4c1602a6e44368608", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:aaf0f08feff0d8d5863fc280bccbca1e2d7cde23c9284a6357a38fab28d7e3d5", "content": "The default reply address (`@SendTo`) for a `@RabbitListener` can now be a SpEL expression.\n\n[[multiple-queue-names-through-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "SpEL in `@SendTo`", "heading_level": 3, "file_order": 54, "section_index": 11, "content_hash": "aaf0f08feff0d8d5863fc280bccbca1e2d7cde23c9284a6357a38fab28d7e3d5", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:371a335c187113420191f6359eab0780774ffc4d32e645ac778b3d4a112746a4", "content": "You can now use a combination of SpEL and property placeholders to specify multiple queues for a listener.\n\nSee xref:amqp/receiving-messages/async-annotation-driven.adoc[Annotation-driven Listener Endpoints] for more information.\n\n[[automatic-exchange-queue-and-binding-declaration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Multiple Queue Names through Properties", "heading_level": 3, "file_order": 54, "section_index": 12, "content_hash": "371a335c187113420191f6359eab0780774ffc4d32e645ac778b3d4a112746a4", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:446bf63e7c9142353545deeceaffe189625bfe7f411cc8894521a48358bbf699", "content": "You can now declare beans that define a collection of these entities, and the `RabbitAdmin` adds the\ncontents to the list of entities that it declares when a connection is established.\nSee xref:amqp/broker-configuration.adoc#collection-declaration[Declaring Collections of Exchanges, Queues, and Bindings] for more information.\n\n[[rabbittemplate-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Automatic Exchange, Queue, and Binding Declaration", "heading_level": 2, "file_order": 54, "section_index": 13, "content_hash": "446bf63e7c9142353545deeceaffe189625bfe7f411cc8894521a48358bbf699", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:5b6325682d4044bc876e6d3f4cfebb023901d13e478fe0004596bbd7c87e9a61", "content": "[[reply-address-added]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "`RabbitTemplate` Changes", "heading_level": 2, "file_order": 54, "section_index": 14, "content_hash": "5b6325682d4044bc876e6d3f4cfebb023901d13e478fe0004596bbd7c87e9a61", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:873b2d9a1c981c0777efd76687b3a5c4047957684046f6c3555e8ec091ebf9c5", "content": "The `reply-address` attribute has been added to the `<rabbit-template>` component as an alternative `reply-queue`.\nSee xref:amqp/request-reply.adoc[Request/Reply Messaging] for more information.\n(Also available in 1.4.4 as a setter on the `RabbitTemplate`).\n\n[[blocking-receive-methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "`reply-address` Added", "heading_level": 3, "file_order": 54, "section_index": 15, "content_hash": "873b2d9a1c981c0777efd76687b3a5c4047957684046f6c3555e8ec091ebf9c5", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:659fa563add40abadaeab47c687b925f2fabdba9fc15ecdf1a6dcff6eda6a2db", "content": "The `RabbitTemplate` now supports blocking in `receive` and `convertAndReceive` methods.\nSee xref:amqp/receiving-messages/polling-consumer.adoc[Polling Consumer] for more information.\n\n[[mandatory-with-sendandreceive-methods]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Blocking `receive` Methods", "heading_level": 3, "file_order": 54, "section_index": 16, "content_hash": "659fa563add40abadaeab47c687b925f2fabdba9fc15ecdf1a6dcff6eda6a2db", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:e8f3da7812259e72e32d562835ba32a3bef27472c745b10709024914772ab7a0", "content": "When the `mandatory` flag is set when using the `sendAndReceive` and `convertSendAndReceive` methods, the calling thread\nthrows an `AmqpMessageReturnedException` if the request message cannot be delivered.\nSee xref:amqp/request-reply.adoc#reply-timeout[Reply Timeout] for more information.\n\n[[improper-reply-listener-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Mandatory with `sendAndReceive` Methods", "heading_level": 3, "file_order": 54, "section_index": 17, "content_hash": "e8f3da7812259e72e32d562835ba32a3bef27472c745b10709024914772ab7a0", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:bbd2f7d455e2a6742ea9db5283e0c681abf4c46f3d265e689e4b280e0de90688", "content": "The framework tries to verify proper configuration of a reply listener container when using a named reply queue.\n\nSee xref:amqp/request-reply.adoc#reply-listener[Reply Listener Container] for more information.\n\n[[rabbitmanagementtemplate-added]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Improper Reply Listener Configuration", "heading_level": 3, "file_order": 54, "section_index": 18, "content_hash": "bbd2f7d455e2a6742ea9db5283e0c681abf4c46f3d265e689e4b280e0de90688", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:5910ed94b658bf6ea66c6defb1cd523c7e48c3c1829afaf74e4c02ffabb01f03", "content": "The `RabbitManagementTemplate` has been introduced to monitor and configure the RabbitMQ Broker by using the REST API provided by its https://www.rabbitmq.com/management.html[management plugin].\nSee xref:amqp/management-rest-api.adoc#management-rest-api[RabbitMQ REST API] for more information.\n\n[[listener-container-bean-names-xml]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "`RabbitManagementTemplate` Added", "heading_level": 2, "file_order": 54, "section_index": 19, "content_hash": "5910ed94b658bf6ea66c6defb1cd523c7e48c3c1829afaf74e4c02ffabb01f03", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:7c5d7f23ab4757de1826b5887a98cfaafddf0e1184dff47430219ef0081ca8bd", "content": "[IMPORTANT]\n====\nThe `id` attribute on the `<listener-container/>` element has been removed.\nStarting with this release, the `id` on the `<listener/>` child element is used alone to name the listener container bean created for each listener element.\n\nNormal Spring bean name overrides are applied.\nIf a later `<listener/>` is parsed with the same `id` as an existing bean, the new definition overrides the existing one.\nPreviously, bean names were composed from the `id` attributes of the `<listener-container/>` and `<listener/>` elements.\n\nWhen migrating to this release, if you have `id` attributes on your `<listener-container/>` elements, remove them and set the `id` on the child `<listener/>` element instead.\n====\n\nHowever, to support starting and stopping containers as a group, a new `group` attribute has been added.\nWhen this attribute is defined, the containers created by this element are added to a bean with this name, of type `Collection<SimpleMessageListenerContainer>`.\nYou can iterate over this group to start and stop containers.\n\n[[class-level-rabbitlistener]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Listener Container Bean Names (XML)", "heading_level": 2, "file_order": 54, "section_index": 20, "content_hash": "7c5d7f23ab4757de1826b5887a98cfaafddf0e1184dff47430219ef0081ca8bd", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:b6024d96a68bff77c272e8e8bbd04d91e522ca7596415889911397d9468d442f", "content": "The `@RabbitListener` annotation can now be applied at the class level.\nTogether with the new `@RabbitHandler` method annotation, this lets you select the handler method based on payload type.\nSee xref:amqp/receiving-messages/async-annotation-driven/method-selection.adoc[Multi-method Listeners] for more information.\n\n[[simplemessagelistenercontainer:-backoff-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Class-Level `@RabbitListener`", "heading_level": 2, "file_order": 54, "section_index": 21, "content_hash": "b6024d96a68bff77c272e8e8bbd04d91e522ca7596415889911397d9468d442f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:b51e67cff7e3b258fd9fc2825bc13472e680b14ed7dc39c12675e1b1c7ce1303", "content": "The `SimpleMessageListenerContainer` can now be supplied with a `BackOff` instance for `consumer` startup recovery.\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration] for more information.\n\n[[channel-close-logging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "`SimpleMessageListenerContainer`: BackOff Support", "heading_level": 2, "file_order": 54, "section_index": 22, "content_hash": "b51e67cff7e3b258fd9fc2825bc13472e680b14ed7dc39c12675e1b1c7ce1303", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:d2c5598501ea32b68df00e7fc91b13d1096e1ca5bc69f7a93f935c48b2167e8c", "content": "A mechanism to control the log levels of channel closure has been introduced.\nSee xref:amqp/connections.adoc#channel-close-logging[Logging Channel Close Events].\n\n[[application-events]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Channel Close Logging", "heading_level": 2, "file_order": 54, "section_index": 23, "content_hash": "d2c5598501ea32b68df00e7fc91b13d1096e1ca5bc69f7a93f935c48b2167e8c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:6b37be89b49dd29e842ca98d7859fed78c3322ee8379c000fc5ad29e7404404f", "content": "The `SimpleMessageListenerContainer` now emits application events when consumers fail.\nSee xref:amqp/receiving-messages/consumer-events.adoc[Consumer Events] for more information.\n\n[[consumer-tag-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Application Events", "heading_level": 2, "file_order": 54, "section_index": 24, "content_hash": "6b37be89b49dd29e842ca98d7859fed78c3322ee8379c000fc5ad29e7404404f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:441d3ec84e6d905ec782837c4bf88459e727be8b02f12bedeac30c519ae31920", "content": "Previously, the consumer tags for asynchronous consumers were generated by the broker.\nWith this release, it is now possible to supply a naming strategy to the listener container.\nSee xref:amqp/receiving-messages/consumerTags.adoc[Consumer Tags].\n\n[[using-messagelisteneradapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Consumer Tag Configuration", "heading_level": 2, "file_order": 54, "section_index": 25, "content_hash": "441d3ec84e6d905ec782837c4bf88459e727be8b02f12bedeac30c519ae31920", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:fba0d4512c237e67b1b553333e3e9285246f9861b1742126c5f64680c05db9ef", "content": "The `MessageListenerAdapter` now supports a map of queue names (or consumer tags) to method names, to determine\nwhich delegate method to call based on the queue from which the message was received.\n\n[[localizedqueueconnectionfactory-added]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Using `MessageListenerAdapter`", "heading_level": 2, "file_order": 54, "section_index": 26, "content_hash": "fba0d4512c237e67b1b553333e3e9285246f9861b1742126c5f64680c05db9ef", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:18212873bd74025cd9978872503b9d9f0330e7ea57b59eda7a059b6825b7752c", "content": "`LocalizedQueueConnectionFactory` is a new connection factory that connects to the node in a cluster where a mirrored queue actually resides.\n\nSee xref:amqp/connections.adoc#queue-affinity[Queue Affinity and the `LocalizedQueueConnectionFactory`].\n\n[[anonymous-queue-naming]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "`LocalizedQueueConnectionFactory` Added", "heading_level": 2, "file_order": 54, "section_index": 27, "content_hash": "18212873bd74025cd9978872503b9d9f0330e7ea57b59eda7a059b6825b7752c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:39ea180ec0ba9c7988d5ef00a5ada7496f8911292c3b3ab34358065e09b0fb20", "content": "Starting with version 1.5.3, you can now control how `AnonymousQueue` names are generated.\nSee xref:amqp/broker-configuration.adoc#anonymous-queue[`AnonymousQueue`] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc", "title": "changes-in-1-5-since-1-4", "heading": "Anonymous Queue Naming", "heading_level": 2, "file_order": 54, "section_index": 28, "content_hash": "39ea180ec0ba9c7988d5ef00a5ada7496f8911292c3b3ab34358065e09b0fb20", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-5-since-1-4.adoc"}}
{"id": "sha256:0c38ab572879662cbedab6c5d4bbf633e265d8769b7770c0f06b85201a2ffdfc", "content": "[[changes-in-1-6-since-1-5]]\n\n[[testing-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "changes-in-1-6-since-1-5", "heading_level": 1, "file_order": 55, "section_index": 0, "content_hash": "0c38ab572879662cbedab6c5d4bbf633e265d8769b7770c0f06b85201a2ffdfc", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:fb02167e83545e9744c4b54be6b6148d05e188e04c40c5c5273094d3f4673718", "content": "A new testing support library is now provided.\nSee xref:testing.adoc[Testing Support] for more information.\n\n[[builder]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Testing Support", "heading_level": 2, "file_order": 55, "section_index": 1, "content_hash": "fb02167e83545e9744c4b54be6b6148d05e188e04c40c5c5273094d3f4673718", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:2849cbc2a9e390d572b60f86cf8bdb9208832858c9bda1c0761aedee4123a0dc", "content": "Builders that provide a fluent API for configuring `Queue` and `Exchange` objects are now available.\nSee xref:amqp/broker-configuration.adoc#builder-api[Builder API for Queues and Exchanges] for more information.\n\n[[namespace-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Builder", "heading_level": 2, "file_order": 55, "section_index": 2, "content_hash": "2849cbc2a9e390d572b60f86cf8bdb9208832858c9bda1c0761aedee4123a0dc", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:b05fd348a0aebe8d2c108541e2e15db18831a39f45404f0684ea428fa2b39fc7", "content": "[[connection-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Namespace Changes", "heading_level": 2, "file_order": 55, "section_index": 3, "content_hash": "b05fd348a0aebe8d2c108541e2e15db18831a39f45404f0684ea428fa2b39fc7", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:db04a79e20fca31bf95797c2ba0516db6655d9f42a51f59745899cc52a288c17", "content": "You can now add a `thread-factory` to a connection factory bean declaration -- for example, to name the threads\ncreated by the `amqp-client` library.\nSee xref:amqp/connections.adoc[Connection and Resource Management] for more information.\n\nWhen you use `CacheMode.CONNECTION`, you can now limit the total number of connections allowed.\nSee xref:amqp/connections.adoc[Connection and Resource Management] for more information.\n\n[[queue-definitions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Connection Factory", "heading_level": 3, "file_order": 55, "section_index": 4, "content_hash": "db04a79e20fca31bf95797c2ba0516db6655d9f42a51f59745899cc52a288c17", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:db2e6de02f30afbc4b6ceae699c4f67c94524142369b527172b58d2d343eea85", "content": "You can now provide a naming strategy for anonymous queues.\nSee xref:amqp/broker-configuration.adoc#anonymous-queue[`AnonymousQueue`] for more information.\n\n[[listener-container-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Queue Definitions", "heading_level": 3, "file_order": 55, "section_index": 5, "content_hash": "db2e6de02f30afbc4b6ceae699c4f67c94524142369b527172b58d2d343eea85", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:c777295502681d6713b62a502b0e0fb28bbcd1b2f53a9dc4c473f7c0e75627ab", "content": "[[idle-message-listener-detection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Listener Container Changes", "heading_level": 2, "file_order": 55, "section_index": 6, "content_hash": "c777295502681d6713b62a502b0e0fb28bbcd1b2f53a9dc4c473f7c0e75627ab", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:a6451fb1769f83c22f6e24a2fb5888c1d8878b6a6cd4b544294646d8c9116b2c", "content": "You can now configure listener containers to publish `ApplicationEvent` instances when idle.\nSee xref:amqp/receiving-messages/idle-containers.adoc[Detecting Idle Asynchronous Consumers] for more information.\n\n[[mismatched-queue-detection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Idle Message Listener Detection", "heading_level": 3, "file_order": 55, "section_index": 7, "content_hash": "a6451fb1769f83c22f6e24a2fb5888c1d8878b6a6cd4b544294646d8c9116b2c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:96ff4515b3c9e06eaba450358958b1858fb6519f457dc30bfa787e64f6000efc", "content": "By default, when a listener container starts, if queues with mismatched properties or arguments are detected,\nthe container logs the exception but continues to listen.\nThe container now has a property called `mismatchedQueuesFatal`, which prevents the container (and context) from\nstarting if the problem is detected during startup.\nIt also stops the container if the problem is detected later, such as after recovering from a connection failure.\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration] for more information.\n\n[[listener-container-logging]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Mismatched Queue Detection", "heading_level": 3, "file_order": 55, "section_index": 8, "content_hash": "96ff4515b3c9e06eaba450358958b1858fb6519f457dc30bfa787e64f6000efc", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:3e5fa11ba7bfd513290d963b1fce01517b2ac005e39a9b52b7a73a8757f69248", "content": "Now, listener container provides its `beanName` to the internal `SimpleAsyncTaskExecutor` as a `threadNamePrefix`.\nIt is useful for logs analysis.\n\n[[default-error-handler]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Listener Container Logging", "heading_level": 3, "file_order": 55, "section_index": 9, "content_hash": "3e5fa11ba7bfd513290d963b1fce01517b2ac005e39a9b52b7a73a8757f69248", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:f9c5679ee9430ae1ee2c556cb563ae0e0734a34ebb73c86fb1389cfd83f448a7", "content": "The default error handler (`ConditionalRejectingErrorHandler`) now considers irrecoverable `@RabbitListener`\nexceptions as fatal.\nSee xref:amqp/exception-handling.adoc[Exception Handling] for more information.\n\n[[autodeclare-and-rabbitadmin-instances]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Default Error Handler", "heading_level": 3, "file_order": 55, "section_index": 10, "content_hash": "f9c5679ee9430ae1ee2c556cb563ae0e0734a34ebb73c86fb1389cfd83f448a7", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:87982fe8ba77d665818b8741db71e0e0b33103a404c075df2fd99936b31f1df1", "content": "See xref:amqp/containerAttributes.adoc[Message Listener Container Configuration] (`autoDeclare`) for some changes to the semantics of that option with respect to the use\nof `RabbitAdmin` instances in the application context.\n\n[[amqptemplate:-receive-with-timeout]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "`AutoDeclare` and `RabbitAdmin` Instances", "heading_level": 2, "file_order": 55, "section_index": 11, "content_hash": "87982fe8ba77d665818b8741db71e0e0b33103a404c075df2fd99936b31f1df1", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:86dd5eb471e36f2d03b3d9a95a9252a373536034001c3942518cb19b14ed3deb", "content": "A number of new `receive()` methods with `timeout` have been introduced for the `AmqpTemplate`\nand its `RabbitTemplate` implementation.\nSee xref:amqp/receiving-messages/polling-consumer.adoc[Polling Consumer] for more information.\n\n[[using-asyncrabbittemplate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "`AmqpTemplate`: Receive with Timeout", "heading_level": 2, "file_order": 55, "section_index": 12, "content_hash": "86dd5eb471e36f2d03b3d9a95a9252a373536034001c3942518cb19b14ed3deb", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:582b172e97104754877b8f00fcd58d286ce3c773972dfa5e02ef5cb085c3788f", "content": "A new `AsyncRabbitTemplate` has been introduced.\nThis template provides a number of send and receive methods, where the return value is a `ListenableFuture`, which can\nbe used later to obtain the result either synchronously or asynchronously.\nSee xref:amqp/request-reply.adoc#async-template[Async Rabbit Template] for more information.\n\n[[rabbittemplate-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Using `AsyncRabbitTemplate`", "heading_level": 2, "file_order": 55, "section_index": 13, "content_hash": "582b172e97104754877b8f00fcd58d286ce3c773972dfa5e02ef5cb085c3788f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:1ff019f6d04d061475a18788043f71f3e9bf37fd323d7fd85a109a0b139b0958", "content": "1.4.1 introduced the ability to use https://www.rabbitmq.com/direct-reply-to.html[direct reply-to] when the broker supports it.\nIt is more efficient than using a temporary queue for each reply.\nThis version lets you override this default behavior and use a temporary queue by setting the `useTemporaryReplyQueues` property to `true`.\nSee xref:amqp/request-reply.adoc#direct-reply-to[RabbitMQ Direct reply-to] for more information.\n\nThe `RabbitTemplate` now supports a `user-id-expression` (`userIdExpression` when using Java configuration).\nSee https://www.rabbitmq.com/validated-user-id.html[Validated User-ID RabbitMQ documentation] and xref:amqp/template.adoc#template-user-id[Validated User Id] for more information.\n\n[[message-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "`RabbitTemplate` Changes", "heading_level": 2, "file_order": 55, "section_index": 14, "content_hash": "1ff019f6d04d061475a18788043f71f3e9bf37fd323d7fd85a109a0b139b0958", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:1d3a55c3644bd9052d936b6a69af7f90fb9e3f1f6476b651dfc73559a0c9f0a9", "content": "[[using-correlationid]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Message Properties", "heading_level": 2, "file_order": 55, "section_index": 15, "content_hash": "1d3a55c3644bd9052d936b6a69af7f90fb9e3f1f6476b651dfc73559a0c9f0a9", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:a24af277f64da3963a31cad59a19b6d158da898888f683b6fa65c5b8ccea7781", "content": "The `correlationId` message property can now be a `String`.\nSee xref:amqp/message-converters.adoc#message-properties-converters[Message Properties Converters] for more information.\n\n[[long-string-headers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Using `CorrelationId`", "heading_level": 3, "file_order": 55, "section_index": 16, "content_hash": "a24af277f64da3963a31cad59a19b6d158da898888f683b6fa65c5b8ccea7781", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:57c810c2fdee868c7960405180743a134a2dd00bd6c093d6ebfd680b190d5dc2", "content": "Previously, the `DefaultMessagePropertiesConverter` \"`converted`\" headers longer than the long string limit (default 1024)\nto a `DataInputStream` (actually, it referenced the `LongString` instance's `DataInputStream`).\nOn output, this header was not converted (except to a String -- for example, `java.io.DataInputStream@1d057a39` by calling\n`toString()` on the stream).\n\nWith this release, long `LongString` instances are now left as `LongString` instances by default.\nYou can access the contents by using the `getBytes[]`, `toString()`, or `getStream()` methods.\nA large incoming `LongString` is now correctly \"`converted`\" on output too.\n\nSee xref:amqp/message-converters.adoc#message-properties-converters[Message Properties Converters] for more information.\n\n[[inbound-delivery-mode]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Long String Headers", "heading_level": 3, "file_order": 55, "section_index": 17, "content_hash": "57c810c2fdee868c7960405180743a134a2dd00bd6c093d6ebfd680b190d5dc2", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:cc1727ac1cc814f03ff2726d526ea6372cc14a6ff3fdec5282eaef9a047382fb", "content": "The `deliveryMode` property is no longer mapped to the `MessageProperties.deliveryMode`.\nThis change avoids unintended propagation if the the same `MessageProperties` object is used to send an outbound message.\nInstead, the inbound `deliveryMode` header is mapped to `MessageProperties.receivedDeliveryMode`.\n\nSee xref:amqp/message-converters.adoc#message-properties-converters[Message Properties Converters] for more information.\n\nWhen using annotated endpoints, the header is provided in the header named `AmqpHeaders.RECEIVED_DELIVERY_MODE`.\n\nSee xref:amqp/receiving-messages/async-annotation-driven/enable-signature.adoc[Annotated Endpoint Method Signature] for more information.\n\n[[inbound-user-id]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Inbound Delivery Mode", "heading_level": 3, "file_order": 55, "section_index": 18, "content_hash": "cc1727ac1cc814f03ff2726d526ea6372cc14a6ff3fdec5282eaef9a047382fb", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:1793e3c0004976aa22deeeb2c44334d79d664f2058c0fb5177e0b3535e67df95", "content": "The `user_id` property is no longer mapped to the `MessageProperties.userId`.\nThis change avoids unintended propagation if the the same `MessageProperties` object is used to send an outbound message.\nInstead, the inbound `userId` header is mapped to `MessageProperties.receivedUserId`.\n\nSee xref:amqp/message-converters.adoc#message-properties-converters[Message Properties Converters] for more information.\n\nWhen you use annotated endpoints, the header is provided in the header named `AmqpHeaders.RECEIVED_USER_ID`.\n\nSee xref:amqp/receiving-messages/async-annotation-driven/enable-signature.adoc[Annotated Endpoint Method Signature] for more information.\n\n[[rabbitadmin-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Inbound User ID", "heading_level": 3, "file_order": 55, "section_index": 19, "content_hash": "1793e3c0004976aa22deeeb2c44334d79d664f2058c0fb5177e0b3535e67df95", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:4696140286458ed7dd9bf4a061de2d9d0f1c429e246f28c085bcd9133a65e7a3", "content": "[[declaration-failures]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "`RabbitAdmin` Changes", "heading_level": 2, "file_order": 55, "section_index": 20, "content_hash": "4696140286458ed7dd9bf4a061de2d9d0f1c429e246f28c085bcd9133a65e7a3", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:72be1591979bb5177552d3ab811c578014897cfb823e27e36c5fc70202805718", "content": "Previously, the `ignoreDeclarationFailures` flag took effect only for `IOException` on the channel (such as mis-matched\narguments).\nIt now takes effect for any exception (such as `TimeoutException`).\nIn addition, a `DeclarationExceptionEvent` is now published whenever a declaration fails.\nThe `RabbitAdmin` last declaration event is also available as a property `lastDeclarationExceptionEvent`.\nSee xref:amqp/broker-configuration.adoc[Configuring the Broker] for more information.\n\n[[rabbitlistener-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Declaration Failures", "heading_level": 3, "file_order": 55, "section_index": 21, "content_hash": "72be1591979bb5177552d3ab811c578014897cfb823e27e36c5fc70202805718", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:6aaf9a4b546fc9599690d924ffe3b043b0b7c9fb4fbbbc08a0447ccad35463bb", "content": "[[multiple-containers-for-each-bean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "`@RabbitListener` Changes", "heading_level": 2, "file_order": 55, "section_index": 22, "content_hash": "6aaf9a4b546fc9599690d924ffe3b043b0b7c9fb4fbbbc08a0447ccad35463bb", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:2a81f5906614277d8ded70a0f3757d0b47ccc4dfbfc0732a2c4baca148e58ba0", "content": "When you use Java 8 or later, you can now add multiple `@RabbitListener` annotations to `@Bean` classes or\ntheir methods.\nWhen using Java 7 or earlier, you can use the `@RabbitListeners` container annotation to provide the same\nfunctionality.\nSee xref:amqp/receiving-messages/async-annotation-driven/repeatable-rabbit-listener.adoc[`@Repeatable` `@RabbitListener`] for more information.\n\n[[sendto-spel-expressions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Multiple Containers for Each Bean", "heading_level": 3, "file_order": 55, "section_index": 23, "content_hash": "2a81f5906614277d8ded70a0f3757d0b47ccc4dfbfc0732a2c4baca148e58ba0", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:65a30fbf119166c6bef7a951a46e588b79578f82547242d29a83e7396b563473", "content": "`@SendTo` for routing replies with no `replyTo` property can now be SpEL expressions evaluated against the\nrequest/reply.\nSee xref:amqp/receiving-messages/async-annotation-driven/reply.adoc[Reply Management] for more information.\n\n[[queuebinding-improvements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "`@SendTo` SpEL Expressions", "heading_level": 3, "file_order": 55, "section_index": 24, "content_hash": "65a30fbf119166c6bef7a951a46e588b79578f82547242d29a83e7396b563473", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:6fe4c041bf7cc48aaf42865ea832ce6db23958d74b734ef460ca3d1ecfa36e92", "content": "You can now specify arguments for queues, exchanges, and bindings in `@QueueBinding` annotations.\nHeader exchanges are now supported by `@QueueBinding`.\nSee xref:amqp/receiving-messages/async-annotation-driven.adoc[Annotation-driven Listener Endpoints] for more information.\n\n[[delayed-message-exchange]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "`@QueueBinding` Improvements", "heading_level": 3, "file_order": 55, "section_index": 25, "content_hash": "6fe4c041bf7cc48aaf42865ea832ce6db23958d74b734ef460ca3d1ecfa36e92", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:0c80afaaf9bd7dfed60437d9d65c1a7fd59e5ead3c72f33353f7cf0691080623", "content": "Spring AMQP now has first class support for the RabbitMQ Delayed Message Exchange plugin.\nSee xref:amqp/delayed-message-exchange.adoc[Delayed Message Exchange] for more information.\n\n[[exchange-internal-flag]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Delayed Message Exchange", "heading_level": 2, "file_order": 55, "section_index": 26, "content_hash": "0c80afaaf9bd7dfed60437d9d65c1a7fd59e5ead3c72f33353f7cf0691080623", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:18dd5a8889477e0ff16d92863b2d3947bebd0d4b359526387da9d9099cd58d02", "content": "Any `Exchange` definitions can now be marked as `internal`, and `RabbitAdmin` passes the value to the broker when\ndeclaring the exchange.\nSee xref:amqp/broker-configuration.adoc[Configuring the Broker] for more information.\n\n[[cachingconnectionfactory-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Exchange Internal Flag", "heading_level": 2, "file_order": 55, "section_index": 27, "content_hash": "18dd5a8889477e0ff16d92863b2d3947bebd0d4b359526387da9d9099cd58d02", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:4e9df7df7c27fbe8228cfcd5bd3c3c632a618841bf42117ced66333acf5cd5a9", "content": "[[cachingconnectionfactory-cache-statistics]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "`CachingConnectionFactory` Changes", "heading_level": 2, "file_order": 55, "section_index": 28, "content_hash": "4e9df7df7c27fbe8228cfcd5bd3c3c632a618841bf42117ced66333acf5cd5a9", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:07133948a530a353e32642da43c33418e2c6b18b08d8d77587ac984d5b4a8c10", "content": "The `CachingConnectionFactory` now provides cache properties at runtime and over JMX.\nSee xref:amqp/connections.adoc#runtime-cache-properties[Runtime Cache Properties] for more information.\n\n[[accessing-the-underlying-rabbitmq-connection-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "`CachingConnectionFactory` Cache Statistics", "heading_level": 3, "file_order": 55, "section_index": 29, "content_hash": "07133948a530a353e32642da43c33418e2c6b18b08d8d77587ac984d5b4a8c10", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:8b67911edbde799f57083ce97b717184455628350efa647bc3f110a23821512c", "content": "A new getter has been added to provide access to the underlying factory.\nYou can use this getter, for example, to add custom connection properties.\nSee xref:amqp/custom-client-props.adoc[Adding Custom Client Connection Properties] for more information.\n\n[[channel-cache]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Accessing the Underlying RabbitMQ Connection Factory", "heading_level": 3, "file_order": 55, "section_index": 30, "content_hash": "8b67911edbde799f57083ce97b717184455628350efa647bc3f110a23821512c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:2e475ec8f19f3a187360cd343fba02232e1860111ba3f0028510a6c0e20f4e24", "content": "The default channel cache size has been increased from 1 to 25.\nSee xref:amqp/connections.adoc[Connection and Resource Management] for more information.\n\nIn addition, the `SimpleMessageListenerContainer` no longer adjusts the cache size to be at least as large as the number\nof `concurrentConsumers` -- this was superfluous, since the container consumer channels are never cached.\n\n[[using-rabbitconnectionfactorybean]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Channel Cache", "heading_level": 3, "file_order": 55, "section_index": 31, "content_hash": "2e475ec8f19f3a187360cd343fba02232e1860111ba3f0028510a6c0e20f4e24", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:3aa9c488d3c91c4092228613315d94c02fdaf720604c9ef4f2c989f528063213", "content": "The factory bean now exposes a property to add client connection properties to connections made by the resulting\nfactory.\n\n[[java-deserialization]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Using `RabbitConnectionFactoryBean`", "heading_level": 2, "file_order": 55, "section_index": 32, "content_hash": "3aa9c488d3c91c4092228613315d94c02fdaf720604c9ef4f2c989f528063213", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:2694530342b22fa5070d46bb1360371b1f93c3578a3b83c4a8eaaccba6c76040", "content": "You can now configure a \"`allowed list`\" of allowable classes when you use Java deserialization.\nYou should consider creating an allowed list if you accept messages with serialized java objects from\nuntrusted sources.\nSee amqp/message-converters.adoc#java-deserialization[Java Deserialization] for more information.\n\n[[json-messageconverter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Java Deserialization", "heading_level": 2, "file_order": 55, "section_index": 33, "content_hash": "2694530342b22fa5070d46bb1360371b1f93c3578a3b83c4a8eaaccba6c76040", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:6ad8ce21fa43d31f6d2ee65573189b130bcd9bfd9bb8d82da0b626c5afac9ec4", "content": "Improvements to the JSON message converter now allow the consumption of messages that do not have type information\nin message headers.\nSee xref:amqp/receiving-messages/async-annotation-driven/conversion.adoc[Message Conversion for Annotated Methods] and xref:amqp/message-converters.adoc#json-message-converter[`Jackson2JsonMessageConverter`] for more information.\n\n[[logging-appenders]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "JSON `MessageConverter`", "heading_level": 2, "file_order": 55, "section_index": 34, "content_hash": "6ad8ce21fa43d31f6d2ee65573189b130bcd9bfd9bb8d82da0b626c5afac9ec4", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:fd97f6426724e7e3c5af0bb6899688ff83097e307b4319e1390fe7482f49b688", "content": "[[log4j-2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Logging Appenders", "heading_level": 2, "file_order": 55, "section_index": 35, "content_hash": "fd97f6426724e7e3c5af0bb6899688ff83097e307b4319e1390fe7482f49b688", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:a8d8b6dc3d08bf65823a87997811f4a21253028320f87a53ebbc03648c3d0056", "content": "A log4j 2 appender has been added, and the appenders can now be configured with an `addresses` property to connect\nto a broker cluster.\n\n[[client-connection-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Log4j 2", "heading_level": 3, "file_order": 55, "section_index": 36, "content_hash": "a8d8b6dc3d08bf65823a87997811f4a21253028320f87a53ebbc03648c3d0056", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:0c673c4587a60f8d554f4abbb0357025f54286f0acc50c60ff4e3bf5aea27148", "content": "You can now add custom client connection properties to RabbitMQ connections.\n\nSee xref:logging.adoc[Logging Subsystem AMQP Appenders] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc", "title": "changes-in-1-6-since-1-5", "heading": "Client Connection Properties", "heading_level": 3, "file_order": 55, "section_index": 37, "content_hash": "0c673c4587a60f8d554f4abbb0357025f54286f0acc50c60ff4e3bf5aea27148", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-6-since-1-5.adoc"}}
{"id": "sha256:305b41683eb3407d3cdb7254ae6a38b3f0ef4bbafc0620763eb4e4369b9776fa", "content": "[[changes-in-1-7-since-1-6]]\n\n[[amqp-client-library]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "changes-in-1-7-since-1-6", "heading_level": 1, "file_order": 56, "section_index": 0, "content_hash": "305b41683eb3407d3cdb7254ae6a38b3f0ef4bbafc0620763eb4e4369b9776fa", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:de366a8a418a7521bf53177567eaffb89bd3eab1950d6eecdcac0c1c9a7c1b4e", "content": "Spring AMQP now uses the new 4.0.x version of the `amqp-client` library provided by the RabbitMQ team.\nThis client has auto-recovery configured by default.\nSee xref:amqp/connections.adoc#auto-recovery[RabbitMQ Automatic Connection/Topology recovery].\n\nNOTE: The 4.0.x client enables automatic recovery by default.\nWhile compatible with this feature, Spring AMQP has its own recovery mechanisms, and the client recovery feature generally is not needed.\nWe recommend disabling `amqp-client` automatic recovery, to avoid getting `AutoRecoverConnectionNotCurrentlyOpenException` instances when the broker is available but the connection has not yet recovered.\nStarting with version 1.7.1, Spring AMQP disables it unless you explicitly create your own RabbitMQ connection factory and provide it to the `CachingConnectionFactory`.\nRabbitMQ `ConnectionFactory` instances created by the `RabbitConnectionFactoryBean` also have the option disabled by default.\n\n[[log4j-2-upgrade]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "AMQP Client library", "heading_level": 2, "file_order": 56, "section_index": 1, "content_hash": "de366a8a418a7521bf53177567eaffb89bd3eab1950d6eecdcac0c1c9a7c1b4e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:6529434ba315f4dece33a6bb37362e1d69096509379f19b99d932ec93b4b157c", "content": "The minimum Log4j 2 version (for the `AmqpAppender`) is now `2.7`.\nThe framework is no longer compatible with previous versions.\nSee xref:logging.adoc[Logging Subsystem AMQP Appenders] for more information.\n\n[[logback-appender]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "Log4j 2 upgrade", "heading_level": 2, "file_order": 56, "section_index": 2, "content_hash": "6529434ba315f4dece33a6bb37362e1d69096509379f19b99d932ec93b4b157c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:4e763ed236ef8a86efd4a9ceb51316a7130780e80012174644e525769c97c6ec", "content": "This appender no longer captures caller data (method, line number) by default.\nYou can re-enable it by setting the `includeCallerData` configuration option.\nSee xref:logging.adoc[Logging Subsystem AMQP Appenders] for information about the available log appenders.\n\n[[spring-retry-upgrade]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "Logback Appender", "heading_level": 2, "file_order": 56, "section_index": 3, "content_hash": "4e763ed236ef8a86efd4a9ceb51316a7130780e80012174644e525769c97c6ec", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:7b9374275cbd3127c3972e063c15b70f0fa25124b18c995805cb4804706c9bf9", "content": "The minimum Spring Retry version is now `1.2`.\nThe framework is no longer compatible with previous versions.\n\n[[shutdown-behavior]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "Spring Retry Upgrade", "heading_level": 2, "file_order": 56, "section_index": 4, "content_hash": "7b9374275cbd3127c3972e063c15b70f0fa25124b18c995805cb4804706c9bf9", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:ec096b745233da48450f0613422f4a0dd2b42d074afd95b28e08618a4af788f0", "content": "You can now set `forceCloseChannel` to `true` so that, if the container threads do not respond to a shutdown within `shutdownTimeout`, the channels are forced closed,\ncausing any unacked messages to be re-queued.\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration] for more information.\n\n[[fasterxml-jackson-upgrade]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "Shutdown Behavior", "heading_level": 3, "file_order": 56, "section_index": 5, "content_hash": "ec096b745233da48450f0613422f4a0dd2b42d074afd95b28e08618a4af788f0", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:2dc4f4e626e1714ce1712fe1d2cd27210ebde726839ea6bd4898f8f1fba2c46f", "content": "The minimum Jackson version is now `2.8`.\nThe framework is no longer compatible with previous versions.\n\n[[junit-rules]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "FasterXML Jackson upgrade", "heading_level": 2, "file_order": 56, "section_index": 6, "content_hash": "2dc4f4e626e1714ce1712fe1d2cd27210ebde726839ea6bd4898f8f1fba2c46f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:86c81319833107234988e866c9344a0c312879f2a3c32488f970a7b12ce729d0", "content": "Rules that have previously been used internally by the framework have now been made available in a separate jar called `spring-rabbit-junit`.\nSee <<junit4-rules>> for more information.\n\n[[container-conditional-rollback]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "JUnit `@Rules`", "heading_level": 2, "file_order": 56, "section_index": 7, "content_hash": "86c81319833107234988e866c9344a0c312879f2a3c32488f970a7b12ce729d0", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:b91ea73c769f509c486898583fdda4fb6b412598d41879463ad1a4aaa3bd5f7c", "content": "When you use an external transaction manager (such as JDBC), rule-based rollback is now supported when you provide the container with a transaction attribute.\nIt is also now more flexible when you use a transaction advice.\n\n[[connection-naming-strategy]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "Container Conditional Rollback", "heading_level": 2, "file_order": 56, "section_index": 8, "content_hash": "b91ea73c769f509c486898583fdda4fb6b412598d41879463ad1a4aaa3bd5f7c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:645ab93141ddc58db289d1bb3914acef42164e39560d7a1927448eac3a1b33d3", "content": "A new `ConnectionNameStrategy` is now provided to populate the application-specific identification of the target RabbitMQ connection from the `AbstractConnectionFactory`.\nSee xref:amqp/connections.adoc[Connection and Resource Management] for more information.\n\n[[listener-container-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "Connection Naming Strategy", "heading_level": 2, "file_order": 56, "section_index": 9, "content_hash": "645ab93141ddc58db289d1bb3914acef42164e39560d7a1927448eac3a1b33d3", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:b0ab603f65e13be2529b556e834cf81ea6ec9cc5aa5330ad1cee996f33b52225", "content": "[[transaction-rollback-behavior]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "Listener Container Changes", "heading_level": 2, "file_order": 56, "section_index": 10, "content_hash": "b0ab603f65e13be2529b556e834cf81ea6ec9cc5aa5330ad1cee996f33b52225", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:bdc78cad9b6fab836df9174c466f2acf1c163424c46226b41efcfd24dc34c9a5", "content": "You can now configure message re-queue on transaction rollback to be consistent, regardless of whether or not a transaction manager is configured.\nSee xref:amqp/transactions.adoc#transaction-rollback[A note on Rollback of Received Messages] for more information.\n\n[[junit4-rules]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "Transaction Rollback Behavior", "heading_level": 3, "file_order": 56, "section_index": 11, "content_hash": "bdc78cad9b6fab836df9174c466f2acf1c163424c46226b41efcfd24dc34c9a5", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:c1a500c60199efaa0eac80aa87a5fecb8efbe6a82fc61dea087ef9fb376bd455", "content": "Spring AMQP version 1.7 and later provide an additional jar called `spring-rabbit-junit`.\nThis jar contains a couple of utility `@Rule` instances for use when running JUnit4 tests.\nSee xref:testing.adoc#junit5-conditions[JUnit5 Conditions] for JUnit5 testing.\n\n[[using-brokerrunning]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "JUnit4 `@Rules`", "heading_level": 2, "file_order": 56, "section_index": 12, "content_hash": "c1a500c60199efaa0eac80aa87a5fecb8efbe6a82fc61dea087ef9fb376bd455", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:16984b590c9ad0af8408efe940926c8975097401f0e988d703890861502f7081", "content": "`BrokerRunning` provides a mechanism to let tests succeed when a broker is not running (on `localhost`, by default).\n\nIt also has utility methods to initialize and empty queues and delete queues and exchanges.\n\nThe following example shows its usage:\n\n[source, java]\n----\n\n@ClassRule\npublic static BrokerRunning brokerRunning = BrokerRunning.isRunningWithEmptyQueues(\"foo\", \"bar\");\n\n@AfterClass\npublic static void tearDown() {\n brokerRunning.removeTestQueues(\"some.other.queue.too\"); // removes foo, bar as well\n}\n----\n\nThere are several `isRunning...` static methods, such as `isBrokerAndManagementRunning()`, which verifies the broker has the management plugin enabled.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc", "title": "changes-in-1-7-since-1-6", "heading": "Using `BrokerRunning`", "heading_level": 3, "file_order": 56, "section_index": 13, "content_hash": "16984b590c9ad0af8408efe940926c8975097401f0e988d703890861502f7081", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-1-7-since-1-6.adoc"}}
{"id": "sha256:35be2c6a05eac2385b1609b3a58522876ce6f94304699a6945c29da6d4100a8d", "content": "[[changes-in-2-0-since-1-7]]\n\n[[using-cachingconnectionfactory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "changes-in-2-0-since-1-7", "heading_level": 1, "file_order": 57, "section_index": 0, "content_hash": "35be2c6a05eac2385b1609b3a58522876ce6f94304699a6945c29da6d4100a8d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:1de1959804a381db2fd6dd1e26958cd8a215091e7b7713aa435ca540df6e5220", "content": "Starting with version 2.0.2, you can configure the `RabbitTemplate` to use a different connection to that used by listener containers.\nThis change avoids deadlocked consumers when producers are blocked for any reason.\nSee xref:amqp/template.adoc#separate-connection[Using a Separate Connection] for more information.\n\n[[amqp-client-library]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Using `CachingConnectionFactory`", "heading_level": 2, "file_order": 57, "section_index": 1, "content_hash": "1de1959804a381db2fd6dd1e26958cd8a215091e7b7713aa435ca540df6e5220", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:3e2767a7564bcfc4018bb18244084fb19fa13aec869642c5c3c36ee20b516e01", "content": "Spring AMQP now uses the new 5.0.x version of the `amqp-client` library provided by the RabbitMQ team.\nThis client has auto recovery configured by default.\nSee xref:amqp/connections.adoc#auto-recovery[RabbitMQ Automatic Connection/Topology recovery].\n\nNOTE: As of version 4.0, the client enables automatic recovery by default.\nWhile compatible with this feature, Spring AMQP has its own recovery mechanisms, and the client recovery feature generally is not needed.\nWe recommend that you disable `amqp-client` automatic recovery, to avoid getting `AutoRecoverConnectionNotCurrentlyOpenException` instances when the broker is available but the connection has not yet recovered.\nStarting with version 1.7.1, Spring AMQP disables it unless you explicitly create your own RabbitMQ connection factory and provide it to the `CachingConnectionFactory`.\nRabbitMQ `ConnectionFactory` instances created by the `RabbitConnectionFactoryBean` also have the option disabled by default.\n\n[[general-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "AMQP Client library", "heading_level": 2, "file_order": 57, "section_index": 2, "content_hash": "3e2767a7564bcfc4018bb18244084fb19fa13aec869642c5c3c36ee20b516e01", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:585400cf08649a81817af7ceb7a5cfee8183985587c32350a1aa49cd8274399e", "content": "The `ExchangeBuilder` now builds durable exchanges by default.\nThe `@Exchange` annotation used within a `@QeueueBinding` also declares durable exchanges by default.\nThe `@Queue` annotation used within a `@RabbitListener` by default declares durable queues if named and non-durable if anonymous.\nSee xref:amqp/broker-configuration.adoc#builder-api[Builder API for Queues and Exchanges] and xref:amqp/receiving-messages/async-annotation-driven.adoc[Annotation-driven Listener Endpoints] for more information.\n\n[[deleted-classes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "General Changes", "heading_level": 2, "file_order": 57, "section_index": 3, "content_hash": "585400cf08649a81817af7ceb7a5cfee8183985587c32350a1aa49cd8274399e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:18f4639160398a81b64a17bfd628e3bc7d0f066e70c53c227b4285357784d0ec", "content": "`UniquelyNameQueue` is no longer provided.\nIt is unusual to create a durable non-auto-delete queue with a unique name.\nThis class has been deleted.\nIf you require its functionality, use `new Queue(UUID.randomUUID().toString())`.\n\n[[new-listener-container]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Deleted Classes", "heading_level": 2, "file_order": 57, "section_index": 4, "content_hash": "18f4639160398a81b64a17bfd628e3bc7d0f066e70c53c227b4285357784d0ec", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:53cce9fe1662c48ede0e2dbaf1daae63ad87439474b019e4a5049c27a24ec729", "content": "The `DirectMessageListenerContainer` has been added alongside the existing `SimpleMessageListenerContainer`.\nSee xref:amqp/receiving-messages/choose-container.adoc[Choosing a Container] and xref:amqp/containerAttributes.adoc[Message Listener Container Configuration] for information about choosing which container to use as well as how to configure them.\n\n[[log4j-appender]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "New Listener Container", "heading_level": 2, "file_order": 57, "section_index": 5, "content_hash": "53cce9fe1662c48ede0e2dbaf1daae63ad87439474b019e4a5049c27a24ec729", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:56939ab1f9acfb3ac15032f6de0155ddebc24f603a2f6d7d893c4021c9d17e69", "content": "This appender is no longer available due to the end-of-life of log4j.\nSee xref:logging.adoc[Logging Subsystem AMQP Appenders] for information about the available log appenders.\n\n[[rabbittemplate-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Log4j Appender", "heading_level": 2, "file_order": 57, "section_index": 6, "content_hash": "56939ab1f9acfb3ac15032f6de0155ddebc24f603a2f6d7d893c4021c9d17e69", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:017743480dbff451d5f05c9b7018a0ba40427edae47da2bc09fbd63b3a2bd92f", "content": "IMPORTANT: Previously, a non-transactional `RabbitTemplate` participated in an existing transaction if it ran on a transactional listener container thread.\nThis was a serious bug.\nHowever, users might have relied on this behavior.\nStarting with version 1.6.2, you must set the `channelTransacted` boolean on the template for it to participate in the container transaction.\n\nThe `RabbitTemplate` now uses a `DirectReplyToMessageListenerContainer` (by default) instead of creating a new consumer for each request.\nSee xref:amqp/request-reply.adoc#direct-reply-to[RabbitMQ Direct reply-to] for more information.\n\nThe `AsyncRabbitTemplate` now supports direct reply-to.\nSee xref:amqp/request-reply.adoc#async-template[Async Rabbit Template] for more information.\n\nThe `RabbitTemplate` and `AsyncRabbitTemplate` now have `receiveAndConvert` and `convertSendAndReceiveAsType` methods that take a `ParameterizedTypeReference<T>` argument, letting the caller specify the type to which to convert the result.\nThis is particularly useful for complex types or when type information is not conveyed in message headers.\nIt requires a `SmartMessageConverter` such as the `Jackson2JsonMessageConverter`.\nSee xref:amqp/request-reply.adoc[Request/Reply Messaging], xref:amqp/request-reply.adoc#async-template[Async Rabbit Template], xref:amqp/message-converters.adoc#json-complex[Converting From a `Message` With `RabbitTemplate`], and xref:amqp/message-converters.adoc#json-complex[Converting From a `Message` With `RabbitTemplate`] for more information.\n\nYou can now use a `RabbitTemplate` to perform multiple operations on a dedicated channel.\nSee xref:amqp/template.adoc#scoped-operations[Scoped Operations] for more information.\n\n[[listener-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "`RabbitTemplate` Changes", "heading_level": 2, "file_order": 57, "section_index": 7, "content_hash": "017743480dbff451d5f05c9b7018a0ba40427edae47da2bc09fbd63b3a2bd92f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:36e0e80790234c724cd51ffb0272ac3ce02c806d00f85e9868856df8083cea6b", "content": "A convenient `FunctionalInterface` is available for using lambdas with the `MessageListenerAdapter`.\nSee xref:amqp/receiving-messages/async-consumer.adoc#message-listener-adapter[`MessageListenerAdapter`] for more information.\n\n[[listener-container-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Listener Adapter", "heading_level": 2, "file_order": 57, "section_index": 8, "content_hash": "36e0e80790234c724cd51ffb0272ac3ce02c806d00f85e9868856df8083cea6b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:d663ee06d7b09bbf33fba7854fb8b6d55e50ac8784697f1fc4e2bfc1fba50825", "content": "[[prefetch-default-value]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Listener Container Changes", "heading_level": 2, "file_order": 57, "section_index": 9, "content_hash": "d663ee06d7b09bbf33fba7854fb8b6d55e50ac8784697f1fc4e2bfc1fba50825", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:fa491bf0d57e87a9d109c27d2fac99fdada4a52d1aa74d35de1c124fdaad95a8", "content": "The prefetch default value used to be 1, which could lead to under-utilization of efficient consumers.\nThe default prefetch value is now 250, which should keep consumers busy in most common scenarios and,\nthus, improve throughput.\n\nIMPORTANT: There are scenarios where the prefetch value should\nbe low -- for example, with large messages, especially if the processing is slow (messages could add up\nto a large amount of memory in the client process), and if strict message ordering is necessary\n(the prefetch value should be set back to 1 in this case).\nAlso, with low-volume messaging and multiple consumers (including concurrency within a single listener container instance), you may wish to reduce the prefetch to get a more even distribution of messages across consumers.\n\nFor more background about prefetch, see this post about https://www.rabbitmq.com/blog/2014/04/14/finding-bottlenecks-with-rabbitmq-3-3/[consumer utilization in RabbitMQ]\nand this post about https://www.rabbitmq.com/blog/2012/05/11/some-queuing-theory-throughput-latency-and-bandwidth/[queuing theory].\n\n[[message-count]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Prefetch Default Value", "heading_level": 3, "file_order": 57, "section_index": 10, "content_hash": "fa491bf0d57e87a9d109c27d2fac99fdada4a52d1aa74d35de1c124fdaad95a8", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:0ea283a4d40be990ccfc76e59cd529e26817f232a2bd99d0bb65e3a62cfad813", "content": "Previously, `MessageProperties.getMessageCount()` returned `0` for messages emitted by the container.\nThis property applies only when you use `basicGet` (for example, from `RabbitTemplate.receive()` methods) and is now initialized to `null` for container messages.\n\n[[transaction-rollback-behavior]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Message Count", "heading_level": 3, "file_order": 57, "section_index": 11, "content_hash": "0ea283a4d40be990ccfc76e59cd529e26817f232a2bd99d0bb65e3a62cfad813", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:915f73edf3aa74197050de83e04a248da03016844f8121f920ecbd912dcea123", "content": "Message re-queue on transaction rollback is now consistent, regardless of whether or not a transaction manager is configured.\nSee xref:amqp/transactions.adoc#transaction-rollback[A note on Rollback of Received Messages] for more information.\n\n[[shutdown-behavior]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Transaction Rollback Behavior", "heading_level": 3, "file_order": 57, "section_index": 12, "content_hash": "915f73edf3aa74197050de83e04a248da03016844f8121f920ecbd912dcea123", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:cdd2f33fb11b0aa68c4582528773ac16291f0345fc35ed751db5b1780c2dc795", "content": "If the container threads do not respond to a shutdown within `shutdownTimeout`, the channels are forced closed by default.\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration] for more information.\n\n[[after-receive-message-post-processors]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Shutdown Behavior", "heading_level": 3, "file_order": 57, "section_index": 13, "content_hash": "cdd2f33fb11b0aa68c4582528773ac16291f0345fc35ed751db5b1780c2dc795", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:e6d317d83d374527ed54b2b86ef7debb99c261f0e134d3114023349b6874a53c", "content": "If a `MessagePostProcessor` in the `afterReceiveMessagePostProcessors` property returns `null`, the message is discarded (and acknowledged if appropriate).\n\n[[connection-factory-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "After Receive Message Post Processors", "heading_level": 3, "file_order": 57, "section_index": 14, "content_hash": "e6d317d83d374527ed54b2b86ef7debb99c261f0e134d3114023349b6874a53c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:708758428410e82981ede7637ea3aa73818f1b3c4a23289259c5505e832a7043", "content": "The connection and channel listener interfaces now provide a mechanism to obtain information about exceptions.\nSee xref:amqp/connections.adoc#connection-channel-listeners[Connection and Channel Listeners] and xref:amqp/template.adoc#publishing-is-async[Publishing is Asynchronous -- How to Detect Successes and Failures] for more information.\n\nA new `ConnectionNameStrategy` is now provided to populate the application-specific identification of the target RabbitMQ connection from the `AbstractConnectionFactory`.\nSee xref:amqp/connections.adoc[Connection and Resource Management] for more information.\n\n[[retry-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Connection Factory Changes", "heading_level": 2, "file_order": 57, "section_index": 15, "content_hash": "708758428410e82981ede7637ea3aa73818f1b3c4a23289259c5505e832a7043", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:44f396271b62dd117f2f827a4966eebb7349ee821f501f5ab5e8a820fdb29023", "content": "The `MissingMessageIdAdvice` is no longer provided.\nIts functionality is now built-in.\nSee xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#retry[Failures in Synchronous Operations and Options for Retry] for more information.\n\n[[anonymous-queue-naming]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Retry Changes", "heading_level": 2, "file_order": 57, "section_index": 16, "content_hash": "44f396271b62dd117f2f827a4966eebb7349ee821f501f5ab5e8a820fdb29023", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:4ecbe08b6c47a0438578cc0ac70ac11c1c690f431aedd38efb0fbdb5c171295e", "content": "By default, `AnonymousQueues` are now named with the default `Base64UrlNamingStrategy` instead of a simple `UUID` string.\nSee xref:amqp/broker-configuration.adoc#anonymous-queue[`AnonymousQueue`] for more information.\n\n[[rabbitlistener-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Anonymous Queue Naming", "heading_level": 2, "file_order": 57, "section_index": 17, "content_hash": "4ecbe08b6c47a0438578cc0ac70ac11c1c690f431aedd38efb0fbdb5c171295e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:5c6ad9b49c3895fc390e646063e5867308be8f972c4c5c2a561e6e840de0c388", "content": "You can now provide simple queue declarations (bound only to the default exchange) in `@RabbitListener` annotations.\nSee xref:amqp/receiving-messages/async-annotation-driven.adoc[Annotation-driven Listener Endpoints] for more information.\n\nYou can now configure `@RabbitListener` annotations so that any exceptions are returned to the sender.\nYou can also configure a `RabbitListenerErrorHandler` to handle exceptions.\nSee xref:amqp/receiving-messages/async-annotation-driven/error-handling.adoc[Handling Exceptions] for more information.\n\nYou can now bind a queue with multiple routing keys when you use the `@QueueBinding` annotation.\nAlso `@QueueBinding.exchange()` now supports custom exchange types and declares durable exchanges by default.\n\nYou can now set the `concurrency` of the listener container at the annotation level rather than having to configure a different container factory for different concurrency settings.\n\nYou can now set the `autoStartup` property of the listener container at the annotation level, overriding the default setting in the container factory.\n\nYou can now set after receive and before send (reply) `MessagePostProcessor` instances in the `RabbitListener` container factories.\n\nSee xref:amqp/receiving-messages/async-annotation-driven.adoc[Annotation-driven Listener Endpoints] for more information.\n\nStarting with version 2.0.3, one of the `@RabbitHandler` annotations on a class-level `@RabbitListener` can be designated as the default.\nSee xref:amqp/receiving-messages/async-annotation-driven/method-selection.adoc[Multi-method Listeners] for more information.\n\n[[container-conditional-rollback]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "`@RabbitListener` Changes", "heading_level": 2, "file_order": 57, "section_index": 18, "content_hash": "5c6ad9b49c3895fc390e646063e5867308be8f972c4c5c2a561e6e840de0c388", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:9b012acd2c306445185eb015c856705307a33b4a8142ef91ac0e21f763fecd0e", "content": "When using an external transaction manager (such as JDBC), rule-based rollback is now supported when you provide the container with a transaction attribute.\nIt is also now more flexible when you use a transaction advice.\nSee xref:amqp/transactions.adoc#conditional-rollback[Conditional Rollback] for more information.\n\n[[remove-jackson-1-x-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Container Conditional Rollback", "heading_level": 2, "file_order": 57, "section_index": 19, "content_hash": "9b012acd2c306445185eb015c856705307a33b4a8142ef91ac0e21f763fecd0e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:e80f8d4ac48099ea9b160d2c03013542f028814f7a9b05453dc6d3227ea4db2b", "content": "Deprecated in previous versions, Jackson `1.x` converters and related components have now been deleted.\nYou can use similar components based on Jackson 2.x.\nSee xref:amqp/message-converters.adoc#json-message-converter[`Jackson2JsonMessageConverter`] for more information.\n\n[[json-message-converter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Remove Jackson 1.x support", "heading_level": 2, "file_order": 57, "section_index": 20, "content_hash": "e80f8d4ac48099ea9b160d2c03013542f028814f7a9b05453dc6d3227ea4db2b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:93c4d928470c06582b98789e7cd13407b8ad9991c7f4ea5f782328e1b9d4a3cc", "content": "When the `__TypeId__` is set to `Hashtable` for an inbound JSON message, the default conversion type is now `LinkedHashMap`.\nPreviously, it was `Hashtable`.\nTo revert to a `Hashtable`, you can use `setDefaultMapType` on the `DefaultClassMapper`.\n\n[[xml-parsers]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "JSON Message Converter", "heading_level": 2, "file_order": 57, "section_index": 21, "content_hash": "93c4d928470c06582b98789e7cd13407b8ad9991c7f4ea5f782328e1b9d4a3cc", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:2f1beb7172cc525e09d94d7f28d30625b548ea5340f9e5acd79151e25a68c0cd", "content": "When parsing `Queue` and `Exchange` XML components, the parsers no longer register the `name` attribute value as a bean alias if an `id` attribute is present.\nSee xref:amqp/broker-configuration.adoc#note-id-name[A Note On the `id` and `name` Attributes] for more information.\n\n[[blocked-connection]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "XML Parsers", "heading_level": 2, "file_order": 57, "section_index": 22, "content_hash": "2f1beb7172cc525e09d94d7f28d30625b548ea5340f9e5acd79151e25a68c0cd", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:7bd17e89402e58646d1c6e17cf280e321a96fb69d58acb526873e41eb2297e87", "content": "You can now inject the `com.rabbitmq.client.BlockedListener` into the `org.springframework.amqp.rabbit.connection.Connection` object.\nAlso, the `ConnectionBlockedEvent` and `ConnectionUnblockedEvent` events are emitted by the `ConnectionFactory` when the connection is blocked or unblocked by the Broker.\n\nSee xref:amqp/connections.adoc[Connection and Resource Management] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc", "title": "changes-in-2-0-since-1-7", "heading": "Blocked Connection", "heading_level": 2, "file_order": 57, "section_index": 23, "content_hash": "7bd17e89402e58646d1c6e17cf280e321a96fb69d58acb526873e41eb2297e87", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-0-since-1-7.adoc"}}
{"id": "sha256:c62b35ed95143ffdd41de0672a17ad44166183b477221af635d0e65e196c5ea9", "content": "[[changes-in-2-1-since-2-0]]\n\n[[amqp-client-library]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "changes-in-2-1-since-2-0", "heading_level": 1, "file_order": 58, "section_index": 0, "content_hash": "c62b35ed95143ffdd41de0672a17ad44166183b477221af635d0e65e196c5ea9", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:6b689998cad476c741d8b2eac88539a11de74371aeea64e22b5099f9fa0da915", "content": "Spring AMQP now uses the 5.4.x version of the `amqp-client` library provided by the RabbitMQ team.\nThis client has auto-recovery configured by default.\nSee xref:amqp/connections.adoc#auto-recovery[RabbitMQ Automatic Connection/Topology recovery].\n\nNOTE: As of version 4.0, the client enables automatic recovery by default.\nWhile compatible with this feature, Spring AMQP has its own recovery mechanisms and the client recovery feature generally is not needed.\nWe recommend disabling `amqp-client` automatic recovery, to avoid getting `AutoRecoverConnectionNotCurrentlyOpenException` instances when the broker is available but the connection has not yet recovered.\nStarting with version 1.7.1, Spring AMQP disables it unless you explicitly create your own RabbitMQ connection factory and provide it to the `CachingConnectionFactory`.\nRabbitMQ `ConnectionFactory` instances created by the `RabbitConnectionFactoryBean` also have the option disabled by default.\n\n[[package-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "AMQP Client library", "heading_level": 2, "file_order": 58, "section_index": 1, "content_hash": "6b689998cad476c741d8b2eac88539a11de74371aeea64e22b5099f9fa0da915", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:919139aaf595f59791979ca1a44a832fe32d9e873c1dc7e7b32501802e2ec6aa", "content": "Certain classes have moved to different packages.\nMost are internal classes and do not affect user applications.\nTwo exceptions are `ChannelAwareMessageListener` and `RabbitListenerErrorHandler`.\nThese interfaces are now in `org.springframework.amqp.rabbit.listener.api`.\n\n[[publisher-confirms-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "Package Changes", "heading_level": 2, "file_order": 58, "section_index": 2, "content_hash": "919139aaf595f59791979ca1a44a832fe32d9e873c1dc7e7b32501802e2ec6aa", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:d936065a1528a67820edb5d2af08d428ad70910aa06db94a1c1c88294065b737", "content": "Channels enabled for publisher confirmations are not returned to the cache while there are outstanding confirmations.\nSee xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns] for more information.\n\n[[listener-container-factory-improvements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "Publisher Confirms Changes", "heading_level": 2, "file_order": 58, "section_index": 3, "content_hash": "d936065a1528a67820edb5d2af08d428ad70910aa06db94a1c1c88294065b737", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:65b47fa7dfeaa1dc9854ab7b793b38fa5740199faae0af0dcd24f297a840bd11", "content": "You can now use the listener container factories to create any listener container, not only those for use with `@RabbitListener` annotations or the `@RabbitListenerEndpointRegistry`.\nSee xref:amqp/receiving-messages/using-container-factories.adoc[Using Container Factories] for more information.\n\n`ChannelAwareMessageListener` now inherits from `MessageListener`.\n\n[[broker-event-listener]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "Listener Container Factory Improvements", "heading_level": 2, "file_order": 58, "section_index": 4, "content_hash": "65b47fa7dfeaa1dc9854ab7b793b38fa5740199faae0af0dcd24f297a840bd11", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:5039ffbb0ebb42d960d9fbcb5a29eed00af0f5161a5430fae980fabf7248c855", "content": "A `BrokerEventListener` is introduced to publish selected broker events as `ApplicationEvent` instances.\nSee xref:amqp/broker-events.adoc[Broker Event Listener] for more information.\n\n[[rabbitadmin-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "Broker Event Listener", "heading_level": 2, "file_order": 58, "section_index": 5, "content_hash": "5039ffbb0ebb42d960d9fbcb5a29eed00af0f5161a5430fae980fabf7248c855", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:89a4f9bac136a24943fe2669975a2ba94c67ce9f58f65031881538c4a9361582", "content": "The `RabbitAdmin` discovers beans of type `Declarables` (which is a container for `Declarable` - `Queue`, `Exchange`, and `Binding` objects) and declare the contained objects on the broker.\nUsers are discouraged from using the old mechanism of declaring `<Collection<Queue>>` (and others) and should use `Declarables` beans instead.\nBy default, the old mechanism is disabled.\nSee xref:amqp/broker-configuration.adoc#collection-declaration[Declaring Collections of Exchanges, Queues, and Bindings] for more information.\n\n`AnonymousQueue` instances are now declared with `x-queue-master-locator` set to `client-local` by default, to ensure the queues are created on the node the application is connected to.\nSee xref:amqp/broker-configuration.adoc[Configuring the Broker] for more information.\n\n[[rabbittemplate-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "RabbitAdmin Changes", "heading_level": 2, "file_order": 58, "section_index": 6, "content_hash": "89a4f9bac136a24943fe2669975a2ba94c67ce9f58f65031881538c4a9361582", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:85a906506e5626c7b850f264ab9350acfc9b8d6225bef871fa6979b508105991", "content": "You can now configure the `RabbitTemplate` with the `noLocalReplyConsumer` option to control a `noLocal` flag for reply consumers in the `sendAndReceive()` operations.\nSee xref:amqp/request-reply.adoc[Request/Reply Messaging] for more information.\n\n`CorrelationData` for publisher confirmations now has a `ListenableFuture`, which you can use to get the acknowledgment instead of using a callback.\nWhen returns and confirmations are enabled, the correlation data, if provided, is populated with the returned message.\nSee xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns] for more information.\n\nA method called `replyTimedOut` is now provided to notify subclasses that a reply has timed out, allowing for any state cleanup.\nSee xref:amqp/request-reply.adoc#reply-timeout[Reply Timeout] for more information.\n\nYou can now specify an `ErrorHandler` to be invoked when using request/reply with a `DirectReplyToMessageListenerContainer` (the default) when exceptions occur when replies are delivered (for example, late replies).\nSee `setReplyErrorHandler` on the `RabbitTemplate`.\n(Also since 2.0.11).\n\n[[message-conversion]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "RabbitTemplate Changes", "heading_level": 2, "file_order": 58, "section_index": 7, "content_hash": "85a906506e5626c7b850f264ab9350acfc9b8d6225bef871fa6979b508105991", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:a2afa1605b6a9fd4a558728b9f66b5226354eb475c9c857de92152f9de478d85", "content": "We introduced a new `Jackson2XmlMessageConverter` to support converting messages from and to XML format.\nSee xref:amqp/message-converters.adoc#jackson-xml[`Jackson2XmlMessageConverter`] for more information.\n\n[[management-rest-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "Message Conversion", "heading_level": 2, "file_order": 58, "section_index": 8, "content_hash": "a2afa1605b6a9fd4a558728b9f66b5226354eb475c9c857de92152f9de478d85", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:92c34e4b37bcfd54a509b046e65becf70b127445d43ed508dee8cbcd23f40d9f", "content": "The `RabbitManagementTemplate` is now deprecated in favor of the direct `com.rabbitmq.http.client.Client` (or `com.rabbitmq.http.client.ReactorNettyClient`) usage.\nSee xref:amqp/management-rest-api.adoc#management-rest-api[RabbitMQ REST API] for more information.\n\n[[rabbitlistener-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "Management REST API", "heading_level": 2, "file_order": 58, "section_index": 9, "content_hash": "92c34e4b37bcfd54a509b046e65becf70b127445d43ed508dee8cbcd23f40d9f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:f64742b9a3f2445160091813dd2d241812aed6f90897e99325d166e317ad6e4f", "content": "The listener container factory can now be configured with a `RetryTemplate` and, optionally, a `RecoveryCallback` used when sending replies.\nSee xref:amqp/receiving-messages/async-annotation-driven/enable.adoc[Enable Listener Endpoint Annotations] for more information.\n\n[[async-rabbitlistener-return]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "`@RabbitListener` Changes", "heading_level": 2, "file_order": 58, "section_index": 10, "content_hash": "f64742b9a3f2445160091813dd2d241812aed6f90897e99325d166e317ad6e4f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:ab73759b235e37e6c3d4fff1c687d181544998fd47a78b621ff68faab3056235", "content": "`@RabbitListener` methods can now return `ListenableFuture<?>` or `Mono<?>`.\nSee xref:amqp/receiving-messages/async-returns.adoc[Asynchronous `@RabbitListener` Return Types] for more information.\n\n[[connection-factory-bean-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "Async `@RabbitListener` Return", "heading_level": 2, "file_order": 58, "section_index": 11, "content_hash": "ab73759b235e37e6c3d4fff1c687d181544998fd47a78b621ff68faab3056235", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:a61ff528478ba3bee1ec59a5eb468ec2b99eb131db9b7307a9fbe8a06ab87497", "content": "By default, the `RabbitConnectionFactoryBean` now calls `enableHostnameVerification()`.\nTo revert to the previous behavior, set the `enableHostnameVerification` property to `false`.\n\n[[connection-factory-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "Connection Factory Bean Changes", "heading_level": 2, "file_order": 58, "section_index": 12, "content_hash": "a61ff528478ba3bee1ec59a5eb468ec2b99eb131db9b7307a9fbe8a06ab87497", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:68672bdbba0f9c0f449763f0eb4b7d7d64f79f86ec8e53203b68779466432f04", "content": "The `CachingConnectionFactory` now unconditionally disables auto-recovery in the underlying RabbitMQ `ConnectionFactory`, even if a pre-configured instance is provided in a constructor.\nWhile steps have been taken to make Spring AMQP compatible with auto recovery, certain corner cases have arisen where issues remain.\nSpring AMQP has had its own recovery mechanism since 1.0.0 and does not need to use the recovery provided by the client.\nWhile it is still possible to enable the feature (using `cachingConnectionFactory.getRabbitConnectionFactory()` `.setAutomaticRecoveryEnabled()`) after the `CachingConnectionFactory` is constructed, **we strongly recommend that you not do so**.\nWe recommend that you use a separate RabbitMQ `ConnectionFactory` if you need auto recovery connections when using the client factory directly (rather than using Spring AMQP components).\n\n[[listener-container-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "Connection Factory Changes", "heading_level": 2, "file_order": 58, "section_index": 13, "content_hash": "68672bdbba0f9c0f449763f0eb4b7d7d64f79f86ec8e53203b68779466432f04", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:326f6a319d09f4d6f15dabc9b07ac06e66ccd71d727a0b12d69ce159aa408288", "content": "The default `ConditionalRejectingErrorHandler` now completely discards messages that cause fatal errors if an `x-death` header is present.\nSee xref:amqp/exception-handling.adoc[Exception Handling] for more information.\n\n[[immediate-requeue]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "Listener Container Changes", "heading_level": 2, "file_order": 58, "section_index": 14, "content_hash": "326f6a319d09f4d6f15dabc9b07ac06e66ccd71d727a0b12d69ce159aa408288", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:7b03a54369417d1d2a26aaa4df561063fc4284a8668e7f5f8c03a037d2ee32f1", "content": "A new `ImmediateRequeueAmqpException` is introduced to notify a listener container that the message has to be re-queued.\nTo use this feature, a new `ImmediateRequeueMessageRecoverer` implementation is added.\n\nSee xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#async-listeners[Message Listeners and the Asynchronous Case] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc", "title": "changes-in-2-1-since-2-0", "heading": "Immediate requeue", "heading_level": 2, "file_order": 58, "section_index": 15, "content_hash": "7b03a54369417d1d2a26aaa4df561063fc4284a8668e7f5f8c03a037d2ee32f1", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-1-since-2-0.adoc"}}
{"id": "sha256:033674b8f4119b6c56d56ab79b53d049ba914212b66d1181fb1fa634f5de280e", "content": "[[changes-in-2-2-since-2-1]]\n\nThis section describes the changes between version 2.1 and version 2.2.\n\n[[package-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc", "title": "changes-in-2-2-since-2-1", "heading": "changes-in-2-2-since-2-1", "heading_level": 1, "file_order": 59, "section_index": 0, "content_hash": "033674b8f4119b6c56d56ab79b53d049ba914212b66d1181fb1fa634f5de280e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc"}}
{"id": "sha256:8e7f74c0ce4f1451845bd6eabb7d18bac8314afb64d5d8c1a95691f328c744fb", "content": "The following classes/interfaces have been moved from `org.springframework.amqp.rabbit.core.support` to `org.springframework.amqp.rabbit.batch`:\n\n* `BatchingStrategy`\n* `MessageBatch`\n* `SimpleBatchingStrategy`\n\nIn addition, `ListenerExecutionFailedException` has been moved from `org.springframework.amqp.rabbit.listener.exception` to `org.springframework.amqp.rabbit.support`.\n\n[[dependency-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc", "title": "changes-in-2-2-since-2-1", "heading": "Package Changes", "heading_level": 2, "file_order": 59, "section_index": 1, "content_hash": "8e7f74c0ce4f1451845bd6eabb7d18bac8314afb64d5d8c1a95691f328c744fb", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc"}}
{"id": "sha256:febc7c7628ad149decf4a1e24960d3c269ca4ce360ab5fd82af6a295c1671cb3", "content": "JUnit (4) is now an optional dependency and will no longer appear as a transitive dependency.\n\nThe `spring-rabbit-junit` module is now a *compile* dependency in the `spring-rabbit-test` module for a better target application development experience when with only a single `spring-rabbit-test` we get the full stack of testing utilities for AMQP components.\n\n[[breaking-api-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc", "title": "changes-in-2-2-since-2-1", "heading": "Dependency Changes", "heading_level": 2, "file_order": 59, "section_index": 2, "content_hash": "febc7c7628ad149decf4a1e24960d3c269ca4ce360ab5fd82af6a295c1671cb3", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc"}}
{"id": "sha256:1d5efe199ffd672826fe8f4d32ceb96d04c0906dde8b399c78c2d3aa625deba3", "content": "the JUnit (5) `RabbitAvailableCondition.getBrokerRunning()` now returns a `BrokerRunningSupport` instance instead of a `BrokerRunning`, which depends on JUnit 4.\nIt has the same API so it's just a matter of changing the class name of any references.\nSee xref:testing.adoc#junit5-conditions[JUnit5 Conditions] for more information.\n\n[[listenercontainer-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc", "title": "changes-in-2-2-since-2-1", "heading": "\"Breaking\" API Changes", "heading_level": 2, "file_order": 59, "section_index": 3, "content_hash": "1d5efe199ffd672826fe8f4d32ceb96d04c0906dde8b399c78c2d3aa625deba3", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc"}}
{"id": "sha256:0e8763915b0108f04dfa17820ae1f2eb396a97bd27d5f620f810d1f95f78d048", "content": "Messages with fatal exceptions are now rejected and NOT requeued, by default, even if the acknowledge mode is manual.\nSee xref:amqp/exception-handling.adoc[Exception Handling] for more information.\n\nListener performance can now be monitored using Micrometer `Timer` s.\nSee xref:amqp/receiving-messages/micrometer.adoc[Monitoring Listener Performance] for more information.\n\n[[rabbitlistener-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc", "title": "changes-in-2-2-since-2-1", "heading": "ListenerContainer Changes", "heading_level": 2, "file_order": 59, "section_index": 4, "content_hash": "0e8763915b0108f04dfa17820ae1f2eb396a97bd27d5f620f810d1f95f78d048", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc"}}
{"id": "sha256:3b019166057228734dee5b3c6f39d376f04bd3aeb7e87fba37247764db9df8ea", "content": "You can now configure an `executor` on each listener, overriding the factory configuration, to more easily identify threads associated with the listener.\nYou can now override the container factory's `acknowledgeMode` property with the annotation's `ackMode` property.\nSee xref:amqp/receiving-messages/async-annotation-driven/enable.adoc#listener-property-overrides[overriding container factory properties] for more information.\n\nWhen using xref:amqp/receiving-messages/batch.adoc[batching], `@RabbitListener` methods can now receive a complete batch of messages in one call instead of getting them one-at-a-time.\n\nWhen receiving batched messages one-at-a-time, the last message has the `isLastInBatch` message property set to true.\n\nIn addition, received batched messages now contain the `amqp_batchSize` header.\n\nListeners can also consume batches created in the `SimpleMessageListenerContainer`, even if the batch is not created by the producer.\nSee xref:amqp/receiving-messages/choose-container.adoc[Choosing a Container] for more information.\n\nSpring Data Projection interfaces are now supported by the `Jackson2JsonMessageConverter`.\nSee xref:amqp/message-converters.adoc#data-projection[Using Spring Data Projection Interfaces] for more information.\n\nThe `Jackson2JsonMessageConverter` now assumes the content is JSON if there is no `contentType` property, or it is the default (`application/octet-string`).\nSee xref:amqp/message-converters.adoc#JacksonJsonMessageConverter-from-message[Converting from a `Message`] for more information.\n\nSimilarly. the `Jackson2XmlMessageConverter` now assumes the content is XML if there is no `contentType` property, or it is the default (`application/octet-string`).\nSee xref:amqp/message-converters.adoc#jackson-xml[`Jackson2XmlMessageConverter`] for more information.\n\nWhen a `@RabbitListener` method returns a result, the bean and `Method` are now available in the reply message properties.\nThis allows configuration of a `beforeSendReplyMessagePostProcessor` to, for example, set a header in the reply to indicate which method was invoked on the server.\nSee xref:amqp/receiving-messages/async-annotation-driven/reply.adoc[Reply Management] for more information.\n\nYou can now configure a `ReplyPostProcessor` to make modifications to a reply message before it is sent.\nSee xref:amqp/receiving-messages/async-annotation-driven/reply.adoc[Reply Management] for more information.\n\n[[amqp-logging-appenders-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc", "title": "changes-in-2-2-since-2-1", "heading": "@RabbitListener Changes", "heading_level": 2, "file_order": 59, "section_index": 5, "content_hash": "3b019166057228734dee5b3c6f39d376f04bd3aeb7e87fba37247764db9df8ea", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc"}}
{"id": "sha256:4a785e5ca4d722b198815576bf3170ec5bfb4a11d53966f43cdb22808e869445", "content": "The Log4J and Logback `AmqpAppender` s now support a `verifyHostname` SSL option.\n\nAlso these appenders now can be configured to not add MDC entries as headers.\nThe `addMdcAsHeaders` boolean option has been introduces to configure such a behavior.\n\nThe appenders now support the `SaslConfig` property.\n\nSee xref:logging.adoc[Logging Subsystem AMQP Appenders] for more information.\n\n[[messagelisteneradapter-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc", "title": "changes-in-2-2-since-2-1", "heading": "AMQP Logging Appenders Changes", "heading_level": 2, "file_order": 59, "section_index": 6, "content_hash": "4a785e5ca4d722b198815576bf3170ec5bfb4a11d53966f43cdb22808e869445", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc"}}
{"id": "sha256:8f21f53bf29821eda6d1cbc1d648158f8f6691997161d3d000cb1eb14935df60", "content": "The `MessageListenerAdapter` provides now a new `buildListenerArguments(Object, Channel, Message)` method to build an array of arguments to be passed into target listener and an old one is deprecated.\nSee xref:amqp/receiving-messages/async-consumer.adoc#message-listener-adapter[`MessageListenerAdapter`] for more information.\n\n[[exchange-queue-declaration-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc", "title": "changes-in-2-2-since-2-1", "heading": "MessageListenerAdapter Changes", "heading_level": 2, "file_order": 59, "section_index": 7, "content_hash": "8f21f53bf29821eda6d1cbc1d648158f8f6691997161d3d000cb1eb14935df60", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc"}}
{"id": "sha256:b20f56f88f5b05ea7ea06471d37d210505600c228f73e288953e679bcad9b07d", "content": "The `ExchangeBuilder` and `QueueBuilder` fluent APIs used to create `Exchange` and `Queue` objects for declaration by `RabbitAdmin` now support \"well known\" arguments.\nSee xref:amqp/broker-configuration.adoc#builder-api[Builder API for Queues and Exchanges] for more information.\n\nThe `RabbitAdmin` has a new property `explicitDeclarationsOnly`.\nSee xref:amqp/broker-configuration.adoc#conditional-declaration[Conditional Declaration] for more information.\n\n[[connection-factory-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc", "title": "changes-in-2-2-since-2-1", "heading": "Exchange/Queue Declaration Changes", "heading_level": 2, "file_order": 59, "section_index": 8, "content_hash": "b20f56f88f5b05ea7ea06471d37d210505600c228f73e288953e679bcad9b07d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc"}}
{"id": "sha256:0bd9f8a1ca6d4ab5277c49818d37ba80cfffd3d78174396a8feb317fbc9a5883", "content": "The `CachingConnectionFactory` has a new property `shuffleAddresses`.\nWhen providing a list of broker node addresses, the list will be shuffled before creating a connection so that the order in which the connections are attempted is random.\nSee xref:amqp/connections.adoc#cluster[Connecting to a Cluster] for more information.\n\nWhen using Publisher confirms and returns, the callbacks are now invoked on the connection factory's `executor`.\nThis avoids a possible deadlock in the `amqp-clients` library if you perform rabbit operations from within the callback.\nSee xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns] for more information.\n\nAlso, the publisher confirm type is now specified with the `ConfirmType` enum instead of the two mutually exclusive setter methods.\n\nThe `RabbitConnectionFactoryBean` now uses TLS 1.2 by default when SSL is enabled.\nSee xref:amqp/connections.adoc#rabbitconnectionfactorybean-configuring-ssl[`RabbitConnectionFactoryBean` and Configuring SSL] for more information.\n\n[[new-messagepostprocessor-classes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc", "title": "changes-in-2-2-since-2-1", "heading": "Connection Factory Changes", "heading_level": 2, "file_order": 59, "section_index": 9, "content_hash": "0bd9f8a1ca6d4ab5277c49818d37ba80cfffd3d78174396a8feb317fbc9a5883", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc"}}
{"id": "sha256:e9bad13cd00cb983d3cbf4239436ae492d1a8fd2bc668d7ef694280a432a097d", "content": "Classes `DeflaterPostProcessor` and `InflaterPostProcessor` were added to support compression and decompression, respectively, when the message content-encoding is set to `deflate`.\n\n[[other-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc", "title": "changes-in-2-2-since-2-1", "heading": "New MessagePostProcessor Classes", "heading_level": 2, "file_order": 59, "section_index": 10, "content_hash": "e9bad13cd00cb983d3cbf4239436ae492d1a8fd2bc668d7ef694280a432a097d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc"}}
{"id": "sha256:088879a25c96c6466635138f6b87997802c750188d0555ae504b0a4e81fb7cd6", "content": "The `Declarables` object (for declaring multiple queues, exchanges, bindings) now has a filtered getter for each type.\nSee xref:amqp/broker-configuration.adoc#collection-declaration[Declaring Collections of Exchanges, Queues, and Bindings] for more information.\n\nYou can now customize each `Declarable` bean before the `RabbitAdmin` processes the declaration thereof.\nSee xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#automatic-declaration[Automatic Declaration of Exchanges, Queues, and Bindings] for more information.\n\n`singleActiveConsumer()` has been added to the `QueueBuilder` to set the `x-single-active-consumer` queue argument.\nSee xref:amqp/broker-configuration.adoc#builder-api[Builder API for Queues and Exchanges] for more information.\n\nOutbound headers with values of type `Class<?>` are now mapped using `getName()` instead of `toString()`.\nSee xref:amqp/message-converters.adoc#message-properties-converters[Message Properties Converters] for more information.\n\nRecovery of failed producer-created batches is now supported.\nSee xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#batch-retry[Retry with Batch Listeners] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc", "title": "changes-in-2-2-since-2-1", "heading": "Other Changes", "heading_level": 2, "file_order": 59, "section_index": 11, "content_hash": "088879a25c96c6466635138f6b87997802c750188d0555ae504b0a4e81fb7cd6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-2-since-2-1.adoc"}}
{"id": "sha256:e556634a9b9fd52da79d3916740c377ae9e5a8e0e24ea6de12f541349f47314d", "content": "[[changes-in-2-3-since-2-2]]\n\nThis section describes the changes between version 2.2 and version 2.3.\nSee xref:appendix/change-history.adoc[Change History] for changes in previous versions.\n\n[[connection-factory-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc", "title": "changes-in-2-3-since-2-2", "heading": "changes-in-2-3-since-2-2", "heading_level": 1, "file_order": 60, "section_index": 0, "content_hash": "e556634a9b9fd52da79d3916740c377ae9e5a8e0e24ea6de12f541349f47314d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc"}}
{"id": "sha256:96e2b9e2c1238c0e68dfaf1381770c200af3a170e403fa991a8a080e56fd8b88", "content": "Two additional connection factories are now provided.\nSee xref:amqp/connections.adoc#choosing-factory[Choosing a Connection Factory] for more information.\n\n[[rabbitlistener-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc", "title": "changes-in-2-3-since-2-2", "heading": "Connection Factory Changes", "heading_level": 2, "file_order": 60, "section_index": 1, "content_hash": "96e2b9e2c1238c0e68dfaf1381770c200af3a170e403fa991a8a080e56fd8b88", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc"}}
{"id": "sha256:56d0040576660685d7d401cac6b48bb804563c6ee88e54d8dfdc50c9f8f9fd19", "content": "You can now specify a reply content type.\nSee xref:amqp/receiving-messages/async-annotation-driven/reply-content-type.adoc[Reply ContentType] for more information.\n\n[[message-converter-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc", "title": "changes-in-2-3-since-2-2", "heading": "`@RabbitListener` Changes", "heading_level": 2, "file_order": 60, "section_index": 2, "content_hash": "56d0040576660685d7d401cac6b48bb804563c6ee88e54d8dfdc50c9f8f9fd19", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc"}}
{"id": "sha256:841bccbbdd0a4f729809965b909900793681f6955095be08e7584a86b16503a6", "content": "The `Jackson2JMessageConverter` s can now deserialize abstract classes (including interfaces) if the `ObjectMapper` is configured with a custom deserializer.\nSee xref:amqp/message-converters.adoc#jackson-abstract[Deserializing Abstract Classes] for more information.\n\n[[testing-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc", "title": "changes-in-2-3-since-2-2", "heading": "Message Converter Changes", "heading_level": 2, "file_order": 60, "section_index": 3, "content_hash": "841bccbbdd0a4f729809965b909900793681f6955095be08e7584a86b16503a6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc"}}
{"id": "sha256:06964fc39a93ef28bfd7ecce943abcdefc1fb817e541acf68f79b1a74f2f01d6", "content": "A new annotation `@SpringRabbitTest` is provided to automatically configure some infrastructure beans for when you are not using `SpringBootTest`.\nSee xref:testing.adoc#spring-rabbit-test[@SpringRabbitTest] for more information.\n\n[[rabbittemplate-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc", "title": "changes-in-2-3-since-2-2", "heading": "Testing Changes", "heading_level": 2, "file_order": 60, "section_index": 4, "content_hash": "06964fc39a93ef28bfd7ecce943abcdefc1fb817e541acf68f79b1a74f2f01d6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc"}}
{"id": "sha256:2ffba8f1daf7fa9650dd9495e68963b5fc2e8a1bb297cc36442517492c6e15d5", "content": "The template's `ReturnCallback` has been refactored as `ReturnsCallback` for simpler use in lambda expressions.\nSee xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns] for more information.\n\nWhen using returns and correlated confirms, the `CorrelationData` now requires a unique `id` property.\nSee xref:amqp/template.adoc#template-confirms[Correlated Publisher Confirms and Returns] for more information.\n\nWhen using direct reply-to, you can now configure the template such that the server does not need to return correlation data with the reply.\nSee xref:amqp/request-reply.adoc#direct-reply-to[RabbitMQ Direct reply-to] for more information.\n\n[[listener-container-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc", "title": "changes-in-2-3-since-2-2", "heading": "RabbitTemplate Changes", "heading_level": 2, "file_order": 60, "section_index": 5, "content_hash": "2ffba8f1daf7fa9650dd9495e68963b5fc2e8a1bb297cc36442517492c6e15d5", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc"}}
{"id": "sha256:05dffc9874064b396fd6d6e866d9508f442917e096ae0e95490b6edb22f1b72c", "content": "A new listener container property `consumeDelay` is now available; it is helpful when using the {rabbitmq-server-github}/rabbitmq_sharding[RabbitMQ Sharding Plugin].\n\nThe default `JavaLangErrorHandler` now calls `System.exit(99)`.\nTo revert to the previous behavior (do nothing), add a no-op handler.\n\nThe containers now support the `globalQos` property to apply the `prefetchCount` globally for the channel rather than for each consumer on the channel.\n\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration] for more information.\n\n[[messagepostprocessor-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc", "title": "changes-in-2-3-since-2-2", "heading": "Listener Container Changes", "heading_level": 2, "file_order": 60, "section_index": 6, "content_hash": "05dffc9874064b396fd6d6e866d9508f442917e096ae0e95490b6edb22f1b72c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc"}}
{"id": "sha256:0700a9458ad754198bf4a0a2b163166ac19718c6915e9f9da3c3107c544ce1f2", "content": "The compressing `MessagePostProcessor` s now use a comma to separate multiple content encodings instead of a colon.\nThe decompressors can handle both formats but, if you produce messages with this version that are consumed by versions earlier than 2.2.12, you should configure the compressor to use the old delimiter.\nSee the IMPORTANT note in xref:amqp/post-processing.adoc[Modifying Messages - Compression and More] for more information.\n\n[[multiple-broker-support-improvements]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc", "title": "changes-in-2-3-since-2-2", "heading": "MessagePostProcessor Changes", "heading_level": 2, "file_order": 60, "section_index": 7, "content_hash": "0700a9458ad754198bf4a0a2b163166ac19718c6915e9f9da3c3107c544ce1f2", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc"}}
{"id": "sha256:d76579a125bf97630d0518a2dfb23ada2ccccbbb02be47bf03e689bcfbc6c920", "content": "See xref:amqp/multi-rabbit.adoc[Multiple Broker (or Cluster) Support] for more information.\n\n[[republishmessagerecoverer-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc", "title": "changes-in-2-3-since-2-2", "heading": "Multiple Broker Support Improvements", "heading_level": 2, "file_order": 60, "section_index": 8, "content_hash": "d76579a125bf97630d0518a2dfb23ada2ccccbbb02be47bf03e689bcfbc6c920", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc"}}
{"id": "sha256:d1ba2edfdae7cbe09e91eed193388e3d72ac2de48b462f3cce3fc95c88a0ba09", "content": "A new subclass of this recoverer is not provided that supports publisher confirms.\nSee xref:amqp/resilience-recovering-from-errors-and-broker-failures.adoc#async-listeners[Message Listeners and the Asynchronous Case] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc", "title": "changes-in-2-3-since-2-2", "heading": "RepublishMessageRecoverer Changes", "heading_level": 2, "file_order": 60, "section_index": 9, "content_hash": "d1ba2edfdae7cbe09e91eed193388e3d72ac2de48b462f3cce3fc95c88a0ba09", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-3-since-2-2.adoc"}}
{"id": "sha256:97d3e48b6aa903c215e4ebe837a088b2a13f9bdb11ff06d25b584ed5e3887685", "content": "[[changes-in-2-4-since-2-3]]\n\nThis section describes the changes between version 2.3 and version 2.4.\nSee xref:appendix/change-history.adoc[Change History] for changes in previous versions.\n\n[[rabbitlistener-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-4-since-2-3.adoc", "title": "changes-in-2-4-since-2-3", "heading": "changes-in-2-4-since-2-3", "heading_level": 1, "file_order": 61, "section_index": 0, "content_hash": "97d3e48b6aa903c215e4ebe837a088b2a13f9bdb11ff06d25b584ed5e3887685", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-4-since-2-3.adoc"}}
{"id": "sha256:78223a1dd2d4f4a6de53a14b3a245bc9ab489a1b0018b2f2f91c79bcea2228ff", "content": "`MessageProperties` is now available for argument matching.\nSee xref:amqp/receiving-messages/async-annotation-driven/enable-signature.adoc[Annotated Endpoint Method Signature] for more information.\n\n[[rabbitadmin-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-4-since-2-3.adoc", "title": "changes-in-2-4-since-2-3", "heading": "`@RabbitListener` Changes", "heading_level": 2, "file_order": 61, "section_index": 1, "content_hash": "78223a1dd2d4f4a6de53a14b3a245bc9ab489a1b0018b2f2f91c79bcea2228ff", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-4-since-2-3.adoc"}}
{"id": "sha256:708b96ce555b384a1e7f8c7e858f822b88b4fb5837d5e18c5cc59883d79c845b", "content": "A new property `recoverManualDeclarations` allows recovery of manually declared queues/exchanges/bindings.\nSee xref:amqp/broker-configuration.adoc#declarable-recovery[Recovering Auto-Delete Declarations] for more information.\n\n[[remoting-support]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-4-since-2-3.adoc", "title": "changes-in-2-4-since-2-3", "heading": "`RabbitAdmin` Changes", "heading_level": 2, "file_order": 61, "section_index": 2, "content_hash": "708b96ce555b384a1e7f8c7e858f822b88b4fb5837d5e18c5cc59883d79c845b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-4-since-2-3.adoc"}}
{"id": "sha256:af3342817eb2345e9de7b920dc1d57ac43ec52cd1d048b54426eec39f6123727", "content": "Support remoting using Spring Frameworkâ€™s RMI support is deprecated and will be removed in 3.0. See Spring Remoting with AMQP for more information.\n\n[[stream-support-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-4-since-2-3.adoc", "title": "changes-in-2-4-since-2-3", "heading": "Remoting Support", "heading_level": 2, "file_order": 61, "section_index": 3, "content_hash": "af3342817eb2345e9de7b920dc1d57ac43ec52cd1d048b54426eec39f6123727", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-4-since-2-3.adoc"}}
{"id": "sha256:6be4042f4fe8b96d8cc78a99fde12ce0372e0ac7eaddd6cf5bf397daf0e60c49", "content": "`RabbitStreamOperations` and `RabbitStreamTemplate` have been deprecated in favor of `RabbitStreamOperations2` and `RabbitStreamTemplate2` respectively; they return `CompletableFuture` instead of `ListenableFuture`.\nSee xref:stream.adoc[Using the RabbitMQ Stream Plugin] for more information.\n\n[[message-converter-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-4-since-2-3.adoc", "title": "changes-in-2-4-since-2-3", "heading": "Stream Support Changes", "heading_level": 2, "file_order": 61, "section_index": 4, "content_hash": "6be4042f4fe8b96d8cc78a99fde12ce0372e0ac7eaddd6cf5bf397daf0e60c49", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-4-since-2-3.adoc"}}
{"id": "sha256:47cb3cd0cb02855545cd7705153223f18735280f78ef7162d331ff5100633af6", "content": "The `Jackson2JsonMessageConverter` can now determine the charset from the `contentEncoding` header.\nSee xref:amqp/message-converters.adoc#json-message-converter[`Jackson2JsonMessageConverter`] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-4-since-2-3.adoc", "title": "changes-in-2-4-since-2-3", "heading": "Message Converter Changes", "heading_level": 2, "file_order": 61, "section_index": 5, "content_hash": "47cb3cd0cb02855545cd7705153223f18735280f78ef7162d331ff5100633af6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-2-4-since-2-3.adoc"}}
{"id": "sha256:e0bb8a04e4c8950a646514a47478ab432cb588c20bcf7203e3596d1e697479ee", "content": "[[changes-in-3-0-since-2-4]]\n\n[[java-17-spring-framework-6-0]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc", "title": "changes-in-3-0-since-2-4", "heading": "changes-in-3-0-since-2-4", "heading_level": 1, "file_order": 62, "section_index": 0, "content_hash": "e0bb8a04e4c8950a646514a47478ab432cb588c20bcf7203e3596d1e697479ee", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc"}}
{"id": "sha256:5d08b776b61917fb8d2debf767770ff6e18ba26c8e311f8490f82f6d56593165", "content": "This version requires Spring Framework 6.0 and Java 17\n\n[[remoting]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc", "title": "changes-in-3-0-since-2-4", "heading": "Java 17, Spring Framework 6.0", "heading_level": 2, "file_order": 62, "section_index": 1, "content_hash": "5d08b776b61917fb8d2debf767770ff6e18ba26c8e311f8490f82f6d56593165", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc"}}
{"id": "sha256:9bb51e57ad87220ce7e4cec7a720d016f176fd84569c338e99e3aa5872a6ebd3", "content": "The remoting feature (using RMI) is no longer supported.\n\n[[observation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc", "title": "changes-in-3-0-since-2-4", "heading": "Remoting", "heading_level": 2, "file_order": 62, "section_index": 2, "content_hash": "9bb51e57ad87220ce7e4cec7a720d016f176fd84569c338e99e3aa5872a6ebd3", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc"}}
{"id": "sha256:5bc75f4778def5e8cef6a7fd0a51ef6c13264c0bcaaf9021d04985cfe4b5922d", "content": "Enabling observation for timers and tracing using Micrometer is now supported.\nSee xref:stream.adoc#stream-micrometer-observation[Micrometer Observation] for more information.\n\n[[x30-Native]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc", "title": "changes-in-3-0-since-2-4", "heading": "Observation", "heading_level": 2, "file_order": 62, "section_index": 3, "content_hash": "5bc75f4778def5e8cef6a7fd0a51ef6c13264c0bcaaf9021d04985cfe4b5922d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc"}}
{"id": "sha256:cb2b59ac6f03cd439f37270949a856f757a15ccb24ca60ea5f2aa0cd698b9ec5", "content": "Support for creating native images is provided.\nSee xref:appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc#x30-Native[Native Images] for more information.\n\n[[asyncrabbittemplate]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc", "title": "changes-in-3-0-since-2-4", "heading": "Native Images", "heading_level": 2, "file_order": 62, "section_index": 4, "content_hash": "cb2b59ac6f03cd439f37270949a856f757a15ccb24ca60ea5f2aa0cd698b9ec5", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc"}}
{"id": "sha256:3b210939925b5c412aada373e450eca6d7540aaf171cdcf51d28488e2de90b3b", "content": "IMPORTANT: The `AsyncRabbitTemplate` now returns `CompletableFuture` s instead of `ListenableFuture` s.\nSee xref:amqp/request-reply.adoc#async-template[Async Rabbit Template] for more information.\n\n[[stream-support-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc", "title": "changes-in-3-0-since-2-4", "heading": "AsyncRabbitTemplate", "heading_level": 2, "file_order": 62, "section_index": 5, "content_hash": "3b210939925b5c412aada373e450eca6d7540aaf171cdcf51d28488e2de90b3b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc"}}
{"id": "sha256:000d905c130c564e50b5135f817fd68193083e33b8623cfbe57a967eaafae31d", "content": "IMPORTANT: `RabbitStreamOperations` and `RabbitStreamTemplate` methods now return `CompletableFuture` instead of `ListenableFuture`.\n\nSuper streams and single active consumers thereon are now supported.\n\nSee xref:stream.adoc[Using the RabbitMQ Stream Plugin] for more information.\n\n[[rabbitlistener-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc", "title": "changes-in-3-0-since-2-4", "heading": "Stream Support Changes", "heading_level": 2, "file_order": 62, "section_index": 6, "content_hash": "000d905c130c564e50b5135f817fd68193083e33b8623cfbe57a967eaafae31d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc"}}
{"id": "sha256:140484f22564d1717fc25f5dcb3b175b75b869b28ceb68a27ba1bda4fed3d877", "content": "Batch listeners can now consume `Collection<?>` as well as `List<?>`.\nThe batch messaging adapter now ensures that the method is suitable for consuming batches.\nWhen setting the container factory `consumerBatchEnabled` to `true`, the `batchListener` property is also set to `true`.\nSee xref:amqp/receiving-messages/batch.adoc[@RabbitListener with Batching] for more information.\n\n`MessageConverter` s can now return `Optional.empty()` for a null value; this is currently implemented by the `Jackson2JsonMessageConverter`.\nSee xref:amqp/message-converters.adoc#JacksonJsonMessageConverter-from-message[Converting from a `Message`] for more information\n\nYou can now configure a `ReplyPostProcessor` via the container factory rather than via a property on `@RabbitListener`.\nSee xref:amqp/receiving-messages/async-annotation-driven/reply.adoc[Reply Management] for more information.\n\nThe `@RabbitListener` (and `@RabbitHandler`) methods can now be declared as Kotlin `suspend` functions.\nSee xref:amqp/receiving-messages/async-returns.adoc[Asynchronous `@RabbitListener` Return Types] for more information.\n\nStarting with version 3.0.5, listeners with async return types (including Kotlin suspend functions) invoke the `RabbitListenerErrorHandler` (if configured) after a failure.\nPreviously, the error handler was only invoked with synchronous invocations.\n\n[[connection-factory-changes]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc", "title": "changes-in-3-0-since-2-4", "heading": "`@RabbitListener` Changes", "heading_level": 2, "file_order": 62, "section_index": 7, "content_hash": "140484f22564d1717fc25f5dcb3b175b75b869b28ceb68a27ba1bda4fed3d877", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc"}}
{"id": "sha256:95b12d6b426080ca4de02975b88fd96a46ee1a34101670f8218118da3657acec", "content": "The default `addressShuffleMode` in `AbstractConnectionFactory` is now `RANDOM`.\nThis results in connecting to a random host when multiple addresses are provided.\nSee xref:amqp/connections.adoc#cluster[Connecting to a Cluster] for more information.\n\nThe `LocalizedQueueConnectionFactory` no longer uses the RabbitMQ `http-client` library to determine which node is the leader for a queue.\nSee xref:amqp/connections.adoc#queue-affinity[Queue Affinity and the `LocalizedQueueConnectionFactory`] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc", "title": "changes-in-3-0-since-2-4", "heading": "Connection Factory Changes", "heading_level": 2, "file_order": 62, "section_index": 8, "content_hash": "95b12d6b426080ca4de02975b88fd96a46ee1a34101670f8218118da3657acec", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-0-since-2-4.adoc"}}
{"id": "sha256:ad548732ac06e25ffb42ce26f609131347eee4256023fbb6cb5a0b15837e3418", "content": "[[changes-in-3-1-since-3-0]]\n\n[[java-17-spring-framework-6-1]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-1-since-3-0.adoc", "title": "changes-in-3-1-since-3-0", "heading": "changes-in-3-1-since-3-0", "heading_level": 1, "file_order": 63, "section_index": 0, "content_hash": "ad548732ac06e25ffb42ce26f609131347eee4256023fbb6cb5a0b15837e3418", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-1-since-3-0.adoc"}}
{"id": "sha256:981ead3c454b33e330dbdbdab4be7ac86b846b7c953b17ed56ded3b283cd56ed", "content": "This version requires Spring Framework 6.1 and Java 17.\n\n[[x31-exc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-1-since-3-0.adoc", "title": "changes-in-3-1-since-3-0", "heading": "Java 17, Spring Framework 6.1", "heading_level": 2, "file_order": 63, "section_index": 1, "content_hash": "981ead3c454b33e330dbdbdab4be7ac86b846b7c953b17ed56ded3b283cd56ed", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-1-since-3-0.adoc"}}
{"id": "sha256:c46cc486e763f4b2c9c0f65ac7c82f76d34e449d6788a259a32f5f1df8f86feb", "content": "Log messages reporting access refusal due to exclusive consumers are now logged at DEBUG level by default.\nIt remains possible to configure your own logging behavior by setting the `exclusiveConsumerExceptionLogger` and `closeExceptionLogger` properties on the listener container and connection factory respectively.\nIn addition, the `SimpleMessageListenerContainer` consumer restart after such an exception is now logged at DEBUG level by default (previously INFO).\nA new method `logRestart()` has been added to the `ConditionalExceptionLogger` to allow this to be changed.\nSee xref:amqp/receiving-messages/consumer-events.adoc[Consumer Events] and xref:amqp/connections.adoc#channel-close-logging[Logging Channel Close Events] for more information.\n\n[[x31-conn-backoff]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-1-since-3-0.adoc", "title": "changes-in-3-1-since-3-0", "heading": "Exclusive Consumer Logging", "heading_level": 2, "file_order": 63, "section_index": 2, "content_hash": "c46cc486e763f4b2c9c0f65ac7c82f76d34e449d6788a259a32f5f1df8f86feb", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-1-since-3-0.adoc"}}
{"id": "sha256:91597f053acaf3a5398f02b47f2e1f5732abc1c38705132f66d0a952f5bc7bcb", "content": "Connection Factory supported backoff policy when creating connection channel.\nSee xref:amqp/connections.adoc[Choosing a Connection Factory] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-1-since-3-0.adoc", "title": "changes-in-3-1-since-3-0", "heading": "Connections Enhancement", "heading_level": 2, "file_order": 63, "section_index": 3, "content_hash": "91597f053acaf3a5398f02b47f2e1f5732abc1c38705132f66d0a952f5bc7bcb", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-1-since-3-0.adoc"}}
{"id": "sha256:85792e90d174c92f691b6280be4467f4e48b4efe7b61f7f5a6e44fc5e1d2b523", "content": "[[changes-in-3-2-since-3-1]]\n\n[[spring-framework-6-2]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-2-since-3-1.adoc", "title": "changes-in-3-2-since-3-1", "heading": "changes-in-3-2-since-3-1", "heading_level": 1, "file_order": 64, "section_index": 0, "content_hash": "85792e90d174c92f691b6280be4467f4e48b4efe7b61f7f5a6e44fc5e1d2b523", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-2-since-3-1.adoc"}}
{"id": "sha256:e78bb5dc555ccd077a4bc24cac59734c7b87c6adfa399d84aea0486208954c25", "content": "This version requires Spring Framework 6.2.\n\n[[x32-consistent-hash-exchange]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-2-since-3-1.adoc", "title": "changes-in-3-2-since-3-1", "heading": "Spring Framework 6.1", "heading_level": 2, "file_order": 64, "section_index": 1, "content_hash": "e78bb5dc555ccd077a4bc24cac59734c7b87c6adfa399d84aea0486208954c25", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-2-since-3-1.adoc"}}
{"id": "sha256:4a463cdfd5a85eb20ff9ec7324683183cfa3bf7dbdd11a7990156cf9a9bffe06", "content": "The convenient `ConsistentHashExchange` and respective `ExchangeBuilder.consistentHashExchange()` API has been introduced.\n\n[[x32-retry-count-header]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-2-since-3-1.adoc", "title": "changes-in-3-2-since-3-1", "heading": "Consistent Hash Exchange", "heading_level": 2, "file_order": 64, "section_index": 2, "content_hash": "4a463cdfd5a85eb20ff9ec7324683183cfa3bf7dbdd11a7990156cf9a9bffe06", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-2-since-3-1.adoc"}}
{"id": "sha256:33d526e4f9b2a6073d0b41f9ea9e627715b5154011341b1b24f25edfe70940b3", "content": "The `retry_count` header should be used now instead of relying on server side increment for the `x-death.count` property.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-2-since-3-1.adoc", "title": "changes-in-3-2-since-3-1", "heading": "The `retry_count` header", "heading_level": 2, "file_order": 64, "section_index": 3, "content_hash": "33d526e4f9b2a6073d0b41f9ea9e627715b5154011341b1b24f25edfe70940b3", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-3-2-since-3-1.adoc"}}
{"id": "sha256:1abc6e5d428070bee43019e7df048ae348956fd7ed7d1b52cd92b0ba3c3d91f9", "content": "[[changes-in-4-0-since-3-2]]\n\n[[java-17-spring-framework-6-1]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-4-0-since-3-2.adoc", "title": "changes-in-4-0-since-3-2", "heading": "changes-in-4-0-since-3-2", "heading_level": 1, "file_order": 65, "section_index": 0, "content_hash": "1abc6e5d428070bee43019e7df048ae348956fd7ed7d1b52cd92b0ba3c3d91f9", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-4-0-since-3-2.adoc"}}
{"id": "sha256:c5b0772e82211b988ba7fde6897e6d76e9c8bd7c8eec6babdc41ed567a0faebb", "content": "This version requires Spring Framework 6.1 and Java 17.\n\n[[x31-exc]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-4-0-since-3-2.adoc", "title": "changes-in-4-0-since-3-2", "heading": "Java 17, Spring Framework 6.1", "heading_level": 2, "file_order": 65, "section_index": 1, "content_hash": "c5b0772e82211b988ba7fde6897e6d76e9c8bd7c8eec6babdc41ed567a0faebb", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-4-0-since-3-2.adoc"}}
{"id": "sha256:e9c44a22c69708e600eb96a1b5590d0f930f2e000b852b4521b7220c6d1b9cc4", "content": "Log messages reporting access refusal due to exclusive consumers are now logged at DEBUG level by default.\nIt remains possible to configure your own logging behavior by setting the `exclusiveConsumerExceptionLogger` and `closeExceptionLogger` properties on the listener container and connection factory respectively.\nIn addition, the `SimpleMessageListenerContainer` consumer restart after such an exception is now logged at DEBUG level by default (previously INFO).\nA new method `logRestart()` has been added to the `ConditionalExceptionLogger` to allow this to be changed.\nSee xref:amqp/receiving-messages/consumer-events.adoc[Consumer Events] and xref:amqp/connections.adoc#channel-close-logging[Logging Channel Close Events] for more information.\n\n[[x31-conn-backoff]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-4-0-since-3-2.adoc", "title": "changes-in-4-0-since-3-2", "heading": "Exclusive Consumer Logging", "heading_level": 2, "file_order": 65, "section_index": 2, "content_hash": "e9c44a22c69708e600eb96a1b5590d0f930f2e000b852b4521b7220c6d1b9cc4", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-4-0-since-3-2.adoc"}}
{"id": "sha256:e8cf080b2fe25bf00aa059312fe96c5b6042f69fa8b31f14ceb50f6ded6c6ce5", "content": "Connection Factory supported backoff policy when creating connection channel.\nSee xref:amqp/connections.adoc[Choosing a Connection Factory] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-4-0-since-3-2.adoc", "title": "changes-in-4-0-since-3-2", "heading": "Connections Enhancement", "heading_level": 2, "file_order": 65, "section_index": 3, "content_hash": "e8cf080b2fe25bf00aa059312fe96c5b6042f69fa8b31f14ceb50f6ded6c6ce5", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-in-4-0-since-3-2.adoc"}}
{"id": "sha256:2bdb39eb319806c21cbf4b5851b6b1f1a39a8d6b7f26f6f34be714a876ac5799", "content": "[[changes-to-1-1-since-1-0]]\n\n[[general]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-1-since-1-0.adoc", "title": "changes-to-1-1-since-1-0", "heading": "changes-to-1-1-since-1-0", "heading_level": 1, "file_order": 66, "section_index": 0, "content_hash": "2bdb39eb319806c21cbf4b5851b6b1f1a39a8d6b7f26f6f34be714a876ac5799", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-1-since-1-0.adoc"}}
{"id": "sha256:34f8f57ce10d51077caf369fdedc044fbd480384c2b007710ab25e64230c255f", "content": "Spring-AMQP is now built with Gradle.\n\nAdds support for publisher confirms and returns.\n\nAdds support for HA queues and broker failover.\n\nAdds support for dead letter exchanges and dead letter queues.\n\n[[amqp-log4j-appender]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-1-since-1-0.adoc", "title": "changes-to-1-1-since-1-0", "heading": "General", "heading_level": 2, "file_order": 66, "section_index": 1, "content_hash": "34f8f57ce10d51077caf369fdedc044fbd480384c2b007710ab25e64230c255f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-1-since-1-0.adoc"}}
{"id": "sha256:6dd64181c81969a90ecff82e375126567afd08578727a64e3360f6deb70bfdaa", "content": "Adds an option to support adding a message ID to logged messages.\n\nAdds an option to allow the specification of a `Charset` name to be used when converting `String` to `byte[]`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-1-since-1-0.adoc", "title": "changes-to-1-1-since-1-0", "heading": "AMQP Log4j Appender", "heading_level": 2, "file_order": 66, "section_index": 2, "content_hash": "6dd64181c81969a90ecff82e375126567afd08578727a64e3360f6deb70bfdaa", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-1-since-1-0.adoc"}}
{"id": "sha256:81df7a4e6ddeba850171d0a4d470e403a218a163985b5739fa6820218482c579", "content": "[[changes-to-1-2-since-1-1]]\n\n[[rabbitmq-version]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc", "title": "changes-to-1-2-since-1-1", "heading": "changes-to-1-2-since-1-1", "heading_level": 1, "file_order": 67, "section_index": 0, "content_hash": "81df7a4e6ddeba850171d0a4d470e403a218a163985b5739fa6820218482c579", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc"}}
{"id": "sha256:8a4d1b843d9fd614f9a4e1135fc0636af5857f51530be09e178e4d8c47c63963", "content": "Spring AMQP now uses RabbitMQ 3.1.x by default (but retains compatibility with earlier versions).\nCertain deprecations have been added for features no longer supported by RabbitMQ 3.1.x -- federated exchanges and the `immediate` property on the `RabbitTemplate`.\n\n[[rabbit-admin]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc", "title": "changes-to-1-2-since-1-1", "heading": "RabbitMQ Version", "heading_level": 2, "file_order": 67, "section_index": 1, "content_hash": "8a4d1b843d9fd614f9a4e1135fc0636af5857f51530be09e178e4d8c47c63963", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc"}}
{"id": "sha256:267623e98ac8bb2bcb242f43eae3d512a0ddf3babc09f5cea13f467a5e4ef3ee", "content": "`RabbitAdmin` now provides an option to let exchange, queue, and binding declarations continue when a declaration fails.\nPreviously, all declarations stopped on a failure.\nBy setting `ignore-declaration-exceptions`, such exceptions are logged (at the `WARN` level), but further declarations continue.\nAn example where this might be useful is when a queue declaration fails because of a slightly different `ttl` setting that would normally stop other declarations from proceeding.\n\n`RabbitAdmin` now provides an additional method called `getQueueProperties()`.\nYou can use this determine if a queue exists on the broker (returns `null` for a non-existent queue).\nIn addition, it returns the current number of messages in the queue as well as the current number of consumers.\n\n[[rabbit-template]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc", "title": "changes-to-1-2-since-1-1", "heading": "Rabbit Admin", "heading_level": 2, "file_order": 67, "section_index": 2, "content_hash": "267623e98ac8bb2bcb242f43eae3d512a0ddf3babc09f5cea13f467a5e4ef3ee", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc"}}
{"id": "sha256:f36e5b7c0cea3e9fc9ddf48ffad3010499e28c445781b48d33bccf6ac9ae4e73", "content": "Previously, when the `...sendAndReceive()` methods were used with a fixed reply queue, two custom headers were used for correlation data and to retain and restore reply queue information.\nWith this release, the standard message property (`correlationId`) is used by default, although you can specify a custom property to use instead.\nIn addition, nested `replyTo` information is now retained internally in the template, instead of using a custom header.\n\nThe `immediate` property is deprecated.\nYou must not set this property when using RabbitMQ 3.0.x or greater.\n\n[[json-message-converters]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc", "title": "changes-to-1-2-since-1-1", "heading": "Rabbit Template", "heading_level": 2, "file_order": 67, "section_index": 3, "content_hash": "f36e5b7c0cea3e9fc9ddf48ffad3010499e28c445781b48d33bccf6ac9ae4e73", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc"}}
{"id": "sha256:647c148512b1ba35893ef298c2fc3421a9c756bdea147406f91f3fdc2f19fb00", "content": "A Jackson 2.x `MessageConverter` is now provided, along with the existing converter that uses Jackson 1.x.\n\n[[automatic-declaration-of-queues-and-other-items]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc", "title": "changes-to-1-2-since-1-1", "heading": "JSON Message Converters", "heading_level": 2, "file_order": 67, "section_index": 4, "content_hash": "647c148512b1ba35893ef298c2fc3421a9c756bdea147406f91f3fdc2f19fb00", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc"}}
{"id": "sha256:5482760d467da8bb941af96ed819a6fad1b723496c075b0c34ad96c8d7b7830a", "content": "Previously, when declaring queues, exchanges and bindings, you could not define which connection factory was used for the declarations.\nEach `RabbitAdmin` declared all components by using its connection.\n\nStarting with this release, you can now limit declarations to specific `RabbitAdmin` instances.\nSee xref:amqp/broker-configuration.adoc#conditional-declaration[Conditional Declaration].\n\n[[amqp-remoting]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc", "title": "changes-to-1-2-since-1-1", "heading": "Automatic Declaration of Queues and Other Items", "heading_level": 2, "file_order": 67, "section_index": 5, "content_hash": "5482760d467da8bb941af96ed819a6fad1b723496c075b0c34ad96c8d7b7830a", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc"}}
{"id": "sha256:ea006f05bee1985ab7c185173dc315d9a9b2e700e5f2cd06b03c1d03a166e937", "content": "Facilities are now provided for using Spring remoting techniques, using AMQP as the transport for the RPC calls.\nFor more information see xref:amqp/request-reply.adoc#remoting[Spring Remoting with AMQP].\n\n[[requested-heart-beats]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc", "title": "changes-to-1-2-since-1-1", "heading": "AMQP Remoting", "heading_level": 2, "file_order": 67, "section_index": 6, "content_hash": "ea006f05bee1985ab7c185173dc315d9a9b2e700e5f2cd06b03c1d03a166e937", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc"}}
{"id": "sha256:f022c6fec99ccdcabf031728030395281389e572d5e3971257cc185233db1f44", "content": "Several users have asked for the underlying client connection factory's `requestedHeartBeats` property to be exposed on the Spring AMQP `CachingConnectionFactory`.\nThis is now available.\nPreviously, it was necessary to configure the AMQP client factory as a separate bean and provide a reference to it in the `CachingConnectionFactory`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc", "title": "changes-to-1-2-since-1-1", "heading": "Requested Heart Beats", "heading_level": 2, "file_order": 67, "section_index": 7, "content_hash": "f022c6fec99ccdcabf031728030395281389e572d5e3971257cc185233db1f44", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new/changes-to-1-2-since-1-1.adoc"}}
{"id": "sha256:429267b9b918b81cb1c5adb1ea2eed4af88788ffc14e6aa6bf50bbde00e123af", "content": "[[change-history]]\n\nThis section describes changes that have been made as versions have changed.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/change-history.adoc", "title": "change-history", "heading": "change-history", "heading_level": 1, "file_order": 68, "section_index": 0, "content_hash": "429267b9b918b81cb1c5adb1ea2eed4af88788ffc14e6aa6bf50bbde00e123af", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/change-history.adoc"}}
{"id": "sha256:9a416f21476f1caa690d06aa4f80d8ce7928bad8557446f6f79ec1390c359ef1", "content": "[[current-release]]\n\nSee xref:whats-new.adoc[What's New].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/current-release.adoc", "title": "current-release", "heading": "current-release", "heading_level": 1, "file_order": 69, "section_index": 0, "content_hash": "9a416f21476f1caa690d06aa4f80d8ce7928bad8557446f6f79ec1390c359ef1", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/current-release.adoc"}}
{"id": "sha256:f2d1cda828ad0c0fbc790d9a760dc9ca5abd1c0d15827941a1438f7425dae28e", "content": "[[observation-gen]]\n\nThis section describes the Micrometer integration.\n\ninclude::partial$metrics.adoc[leveloffset=-1]\ninclude::partial$spans.adoc[leveloffset=-1]\ninclude::partial$conventions.adoc[leveloffset=-1]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/micrometer.adoc", "title": "micrometer", "heading": "micrometer", "heading_level": 1, "file_order": 70, "section_index": 0, "content_hash": "f2d1cda828ad0c0fbc790d9a760dc9ca5abd1c0d15827941a1438f7425dae28e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/micrometer.adoc"}}
{"id": "sha256:7ea217fb74330d6a4f950f459f6012e5a777af1e6cfabad6954e9d2e3d4f2133", "content": "[[native-images]]\n\n{spring-framework-docs}/core/aot.html[Spring AOT] native hints are provided to assist in developing native images for Spring applications that use Spring AMQP.\n\nSome examples can be seen in the https://github.com/spring-projects/spring-aot-smoke-tests/tree/main/integration[`spring-aot-smoke-tests` GitHub repository].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/native.adoc", "title": "native", "heading": "native", "heading_level": 1, "file_order": 71, "section_index": 0, "content_hash": "7ea217fb74330d6a4f950f459f6012e5a777af1e6cfabad6954e9d2e3d4f2133", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/native.adoc"}}
{"id": "sha256:cc27f6bd94db8d41bc0d3ca711248b0a84e4f7dbf19853465effae7db81de949", "content": "[[previous-whats-new]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/appendix/previous-whats-new.adoc", "title": "previous-whats-new", "heading": "previous-whats-new", "heading_level": 1, "file_order": 72, "section_index": 0, "content_hash": "cc27f6bd94db8d41bc0d3ca711248b0a84e4f7dbf19853465effae7db81de949", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/appendix/previous-whats-new.adoc"}}
{"id": "sha256:6b583be7342c002dbbf8b3ba0d06dc0e4cb8395613c3393e9b24018e4fc32d73", "content": "[[introduction]]\n\nThis first part of the reference documentation is a high-level overview of Spring AMQP and the underlying concepts.\nIt includes some code snippets to get you up and running as quickly as possible.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/introduction/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 73, "section_index": 0, "content_hash": "6b583be7342c002dbbf8b3ba0d06dc0e4cb8395613c3393e9b24018e4fc32d73", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/introduction/index.adoc"}}
{"id": "sha256:b9141c0be410f4977004fb28cafcf0f9a414165f5cafd8fe6d160a8d2444eb9f", "content": "[[quick-tour]]\n\n[[introduction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/introduction/quick-tour.adoc", "title": "quick-tour", "heading": "quick-tour", "heading_level": 1, "file_order": 74, "section_index": 0, "content_hash": "b9141c0be410f4977004fb28cafcf0f9a414165f5cafd8fe6d160a8d2444eb9f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/introduction/quick-tour.adoc"}}
{"id": "sha256:1cbdbb2f5332fc822ceba28cc0dfe39fe8d4fd54e87ad295b8c5b178fb5dbbef", "content": "This is the five-minute tour to get started with Spring AMQP.\n\nPrerequisites: Install and run the RabbitMQ broker (https://www.rabbitmq.com/download.html[https://www.rabbitmq.com/download.html]).\nThen grab the spring-rabbit JAR and all its dependencies - the easiest way to do so is to declare a dependency in your build tool.\nFor example, for Maven, you can do something resembling the following:\n\n[source,xml,subs=\"+attributes\"]\n----\n<dependency>\n <groupId>org.springframework.amqp</groupId>\n <artifactId>spring-rabbit</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nFor Gradle, you can do something resembling the following:\n\n[source,groovy,subs=\"+attributes\"]\n----\nimplementation 'org.springframework.amqp:spring-rabbit:{project-version}'\n----\n\n[[compatibility]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/introduction/quick-tour.adoc", "title": "quick-tour", "heading": "Introduction", "heading_level": 2, "file_order": 74, "section_index": 1, "content_hash": "1cbdbb2f5332fc822ceba28cc0dfe39fe8d4fd54e87ad295b8c5b178fb5dbbef", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/introduction/quick-tour.adoc"}}
{"id": "sha256:a6f4541fa4480224e9d89d12919c9fd55528ed8029f5b32826b36bebbf2bab9d", "content": "The minimum Spring Framework version dependency is 6.1.0.\n\nThe minimum `amqp-client` Java client library version is 5.18.0.\n\nThe minimum `stream-client` Java client library for stream queues is 0.12.0.\n\n[[very-very-quick]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/introduction/quick-tour.adoc", "title": "quick-tour", "heading": "Compatibility", "heading_level": 3, "file_order": 74, "section_index": 2, "content_hash": "a6f4541fa4480224e9d89d12919c9fd55528ed8029f5b32826b36bebbf2bab9d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/introduction/quick-tour.adoc"}}
{"id": "sha256:3fc4fbeafb4d289c83b4c698a372f4ffc8dca2fbbd1acf4590ee9f0b57053d60", "content": "This section offers the fastest introduction.\n\nFirst, add the following `import` statements to make the examples later in this section work:\n\n[source, java]\n----\nimport org.springframework.amqp.core.AmqpAdmin;\nimport org.springframework.amqp.core.AmqpTemplate;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.amqp.rabbit.connection.CachingConnectionFactory;\nimport org.springframework.amqp.rabbit.connection.ConnectionFactory;\nimport org.springframework.amqp.rabbit.core.RabbitAdmin;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\n----\n\nThe following example uses plain, imperative Java to send and receive a message:\n\n[source,java]\n----\nConnectionFactory connectionFactory = new CachingConnectionFactory();\nAmqpAdmin admin = new RabbitAdmin(connectionFactory);\nadmin.declareQueue(new Queue(\"myqueue\"));\nAmqpTemplate template = new RabbitTemplate(connectionFactory);\ntemplate.convertAndSend(\"myqueue\", \"foo\");\nString foo = (String) template.receiveAndConvert(\"myqueue\");\n----\n\nNote that there is also a `ConnectionFactory` in the native Java Rabbit client.\nWe use the Spring abstraction in the preceding code.\nIt caches channels (and optionally connections) for reuse.\nWe rely on the default exchange in the broker (since none is specified in the send), and the default binding of all queues to the default exchange by their name (thus, we can use the queue name as a routing key in the send).\nThose behaviors are defined in the AMQP specification.\n\n[[with-xml-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/introduction/quick-tour.adoc", "title": "quick-tour", "heading": "Very, Very Quick", "heading_level": 3, "file_order": 74, "section_index": 3, "content_hash": "3fc4fbeafb4d289c83b4c698a372f4ffc8dca2fbbd1acf4590ee9f0b57053d60", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/introduction/quick-tour.adoc"}}
{"id": "sha256:6c9216b824410ca7afe270043792f40534460d37943932b2dfe13890ca529f2b", "content": "The following example is the same as the preceding example but externalizes the resource configuration to XML:\n\n[source,java]\n----\nApplicationContext context =\n new GenericXmlApplicationContext(\"classpath:/rabbit-context.xml\");\nAmqpTemplate template = context.getBean(AmqpTemplate.class);\ntemplate.convertAndSend(\"myqueue\", \"foo\");\nString foo = (String) template.receiveAndConvert(\"myqueue\");\n----\n\n[source,xml]\n----\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n xmlns:rabbit=\"http://www.springframework.org/schema/rabbit\"\n xsi:schemaLocation=\"http://www.springframework.org/schema/rabbit\n https://www.springframework.org/schema/rabbit/spring-rabbit.xsd\n http://www.springframework.org/schema/beans\n https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n <rabbit:connection-factory id=\"connectionFactory\"/>\n\n <rabbit:template id=\"amqpTemplate\" connection-factory=\"connectionFactory\"/>\n\n <rabbit:admin connection-factory=\"connectionFactory\"/>\n\n <rabbit:queue name=\"myqueue\"/>\n\n</beans>\n----\n\nBy default, the `<rabbit:admin/>` declaration automatically looks for beans of type `Queue`, `Exchange`, and `Binding` and declares them to the broker on behalf of the user.\nAs a result, you need not use that bean explicitly in the simple Java driver.\nThere are plenty of options to configure the properties of the components in the XML schema.\nYou can use auto-complete features of your XML editor to explore them and look at their documentation.\n\n[[with-java-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/introduction/quick-tour.adoc", "title": "quick-tour", "heading": "With XML Configuration", "heading_level": 3, "file_order": 74, "section_index": 4, "content_hash": "6c9216b824410ca7afe270043792f40534460d37943932b2dfe13890ca529f2b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/introduction/quick-tour.adoc"}}
{"id": "sha256:ae50fa1a592985ce79c5f2e330cfad6f23f4efdd2f8d4f430546e2fb0d4cec51", "content": "The following example repeats the same example as the preceding example but with the external configuration defined in Java:\n\n[source,java]\n----\nApplicationContext context =\n new AnnotationConfigApplicationContext(RabbitConfiguration.class);\nAmqpTemplate template = context.getBean(AmqpTemplate.class);\ntemplate.convertAndSend(\"myqueue\", \"foo\");\nString foo = (String) template.receiveAndConvert(\"myqueue\");\n\n........\n\n@Configuration\npublic class RabbitConfiguration {\n\n @Bean\n public CachingConnectionFactory connectionFactory() {\n return new CachingConnectionFactory(\"localhost\");\n }\n\n @Bean\n public RabbitAdmin amqpAdmin() {\n return new RabbitAdmin(connectionFactory());\n }\n\n @Bean\n public RabbitTemplate rabbitTemplate() {\n return new RabbitTemplate(connectionFactory());\n }\n\n @Bean\n public Queue myQueue() {\n return new Queue(\"myqueue\");\n }\n}\n----\n\n[[with-spring-boot-auto-configuration-and-an-async-pojo-listener]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/introduction/quick-tour.adoc", "title": "quick-tour", "heading": "With Java Configuration", "heading_level": 3, "file_order": 74, "section_index": 5, "content_hash": "ae50fa1a592985ce79c5f2e330cfad6f23f4efdd2f8d4f430546e2fb0d4cec51", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/introduction/quick-tour.adoc"}}
{"id": "sha256:4230157663ec1fcdecb0d7124e618490f0cb2eae5eb62dc3a328d3d755a59c66", "content": "Spring Boot automatically configures the infrastructure beans, as the following example shows:\n\n[source, java]\n----\n@SpringBootApplication\npublic class Application {\n\n public static void main(String[] args) {\n SpringApplication.run(Application.class, args);\n }\n\n @Bean\n public ApplicationRunner runner(AmqpTemplate template) {\n return args -> template.convertAndSend(\"myqueue\", \"foo\");\n }\n\n @Bean\n public Queue myQueue() {\n return new Queue(\"myqueue\");\n }\n\n @RabbitListener(queues = \"myqueue\")\n public void listen(String in) {\n System.out.println(in);\n }\n\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/introduction/quick-tour.adoc", "title": "quick-tour", "heading": "With Spring Boot Auto Configuration and an Async POJO Listener", "heading_level": 3, "file_order": 74, "section_index": 6, "content_hash": "4230157663ec1fcdecb0d7124e618490f0cb2eae5eb62dc3a328d3d755a59c66", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/introduction/quick-tour.adoc"}}
{"id": "sha256:3847aef8a00a423bf38e802b3798948acd06d6561ad0088895cd4a7d9e1de170", "content": "[[amqp]]\n\nThis chapter explores the interfaces and classes that are the essential components for developing applications with Spring AMQP.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp.adoc", "title": "amqp", "heading": "amqp", "heading_level": 1, "file_order": 75, "section_index": 0, "content_hash": "3847aef8a00a423bf38e802b3798948acd06d6561ad0088895cd4a7d9e1de170", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp.adoc"}}
{"id": "sha256:b1282934999dfdec99166c5ca1edc87ea551f48756fb221fb4e3954233a9147e", "content": "[[amqp10-client]]\n\nVersion 4.1 introduces `spring-amqp-client` module for https://www.amqp.org/resources/specifications[AMQP 1.0] protocol support.\n\nThis artifact is based on the https://github.com/apache/qpid-protonj2/blob/main/protonj2-client/README.md[Qpid ProtonJ2 Client Library] and can work with any peers supporting AMQP 1.0 protocol, including RabbitMQ broker.\n\nThis dependency has to be added to the project to be able to interact with AMQP 1.0 support:\n\n[tabs]\n======\nMaven::\n+\n[source,xml,subs=\"+attributes\"]\n----\n<dependency>\n <groupId>org.springframework.amqp</groupId>\n <artifactId>spring-amqp-client</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source,groovy,subs=\"+attributes\"]\n----\nimplementation 'org.springframework.amqp:spring-amqp-client:{project-version}'\n----\n======\n\n[[amqp10-client-environment]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp10-client.adoc", "title": "amqp10-client", "heading": "amqp10-client", "heading_level": 1, "file_order": 76, "section_index": 0, "content_hash": "b1282934999dfdec99166c5ca1edc87ea551f48756fb221fb4e3954233a9147e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp10-client.adoc"}}
{"id": "sha256:47e6ead2a4930c3e46779969a37ae7d1096e4963a5f43f7bd18902a168a4ab2f", "content": "The `org.apache.qpid:protonj2-client` is so flexible and comes with a convenient API that it can be used in Spring applications even without any dedicated Spring implementations.\nFor example, the `org.apache.qpid.protonj2.client.Message` class is a builder pattern implementation.\nEither way, the `spring-amqp-client` provides high-level Spring pattern implementations for connection lifecycle management and AMQP 1.0 protocol interaction for sending and receiving messages operations.\nThe AMQP 1.0 environment starts with a `org.apache.qpid.protonj2.client.Client` instance:\n\n[source,java]\n----\n@Bean\nClient protonClient() {\n return Client.create();\n}\n----\n\nThe same `Client` can be used for connecting to different brokers, the connection settings must be provided on a specific connection.\nSee also <<amqp10-client-connection-factory>> and <<amqp10-annotation-configuration>> below.\n\n[[amqp10-client-connection-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp10-client.adoc", "title": "amqp10-client", "heading": "AMQP 1.0 Environment", "heading_level": 2, "file_order": 76, "section_index": 1, "content_hash": "47e6ead2a4930c3e46779969a37ae7d1096e4963a5f43f7bd18902a168a4ab2f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp10-client.adoc"}}
{"id": "sha256:92677ec215ed299d55da9a5c6f1f7ad73876e9d7ff4d1d1f367055eb543d02cb", "content": "The `org.springframework.amqp.client.AmqpConnectionFactory` abstraction was introduced to manage `org.apache.qpid.protonj2.client.Connection`.\nThe `SingleAmqpConnectionFactory` implementation is present to manage one connection and its settings.\nThe same `Connection` can be shared between many producers and consumers.\nThe multiplexing is handled by the link abstraction for AMQP 1.0 protocol implementation internally in the AMQP client library.\nThe `Connection` has recovery capabilities.\n\nIn most cases it is enough to add this bean into the project:\n\n[source,java]\n----\n@Bean\nAmqpConnectionFactory connectionFactory(Client protonClient) {\n return new SingleAmqpConnectionFactory(protonClient);\n}\n----\n\nSee `SingleAmqpConnectionFactory` setters for all connection-specific options, including `host`, `port`, `user`.\nThe more advance configuration could be done by the `setConnectionOptions(ConnectionOptions)` which is a builder API from ProtonJ library.\nThe mentioned `SingleAmqpConnectionFactory` instance with all the defaults would connect to the `localhost:5672` with infinite number of reconnections.\n\nNOTE: The `Client` injection can be omitted for the `SingleAmqpConnectionFactory`, and respective single bean is resolved from the `BeanFactory` on demand internally, when `getConnection()` is called.\n\n[[amqp10-client-api]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp10-client.adoc", "title": "amqp10-client", "heading": "AMQP 1.0 Connection Factory", "heading_level": 2, "file_order": 76, "section_index": 2, "content_hash": "92677ec215ed299d55da9a5c6f1f7ad73876e9d7ff4d1d1f367055eb543d02cb", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp10-client.adoc"}}
{"id": "sha256:ee3b1caa0153abdc48bb41e36d58abeabca00760a656061f24b035e87bbefec6", "content": "The `AmqpClient` is a fluent API to perform send and receive operations on messages against AMQP 1.0 protocol.\nRequires an `AmqpConnectionFactory` and can be configured with some defaults via `AmqpClient.Builder` API.\nThe `DefaultAmqpClient` is an internal implementation of the `AmqpClient` contract.\nEven if `org.apache.qpid:protonj2-client` library comes with a `org.apache.qpid.protonj2.client.Message` implementation, the `AmqpClient` still exposes an API based on the well-known `org.springframework.amqp.core.Message` with all the supporting classes like `MessageProperties` and `MessageConverter` abstractions.\nThe conversion to/from `org.apache.qpid.protonj2.client.Message` is done internally in the `AmqpClient` implementation via `ProtonUtils` supporting class.\nAll send and receive methods return a `CompletableFuture` to get operation results eventually.\nAn interaction with plain objects require message body conversion and `SimpleMessageConverter` is used by default.\nSee `AmqpClient.Builder.messageConverter(MessageConverter)` configuration and xref:amqp/message-converters.adoc[] for more information about conversions.\n\nUsually, just one bean like this is enough to perform all the possible send and receive operations:\n\n[source,java]\n----\n@Bean\nAmqpClient amqpClient(AmqpConnectionFactory connectionFactory) {\n return AmqpClient.builder(connectionFactory)\n .defaultToAddress(\"/queues/some_queue_as_default\")\n .messageConverter(new JacksonJsonMessageConverter())\n .build();\n}\n----\n\nNOTE: In the example above the `/queues/` prefix used for a `defaultToAddress` is an example of the destination address convention in https://www.rabbitmq.com/docs/amqp#addresses[RabbitMQ].\n\nHere are some samples of `AmqpClient` operations:\n\n[source,java]\n----\nCompletableFuture<Boolean> sendFuture = this.amqpClient.send(Message.create(\"test_data\"));\n----\n\n[source,java]\n----\nCompletableFuture<Boolean> sendFuture =\n this.amqpClient\n .to(\"/queues/test_queue\")\n .message(new org.springframework.amqp.core.Message(\"test_data2\".getBytes()))\n .send();\n----\n\n[source,java]\n----\nCompletableFuture<Boolean> sendFuture =\n this.amqpClient\n .to(\"/queues/test_queue\")\n .body(\"convert\")\n .priority(7)\n .header(\"test_header\", \"test_value\")\n .messageId(\"some_id\")\n .userId(\"guest\")\n .send();\n----\n\nThe `AmqpClient` also provides a fluent API to receive messages from addresses on demand.\nFor that purpose an `AmqpClient.from(String fromAddress)` method should be called returning a `ReceiveSpec` for various receive operations behavior.\nAll of them produce a `CompletableFuture` with either native ProtonJ message, a Spring AMQP message, or just payload converted from the message's body.\nThe `receiveAndConvert()` with non-`Object.class` generic argument requires a `messageConverter` in the `AmqpClient` to be as a `SmartMessageConverter`.\nFor example, when `JacksonJsonMessageConverter` is provided for the `AmqpClient`, the following example would yield a proper data model conversion:\n\n[source,java]\n----\nrecord TestData(String data) { }\n\n this.amqpClient\n .to(\"/queues/test_queue\")\n .body(new TestData(\"convert\"))\n .send();\n\nCompletableFuture<TestData> receiveFuture =\n this.amqpClient.from(\"/queues/test_queue\")\n .receiveAndConvert();\n----\n\nSee Javadocs for those methods for more information about the fluent API exposed by the `AmqpClient`.\n\n[[amqp10-client-listener]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp10-client.adoc", "title": "amqp10-client", "heading": "`AmqpClient`", "heading_level": 2, "file_order": 76, "section_index": 3, "content_hash": "ee3b1caa0153abdc48bb41e36d58abeabca00760a656061f24b035e87bbefec6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp10-client.adoc"}}
{"id": "sha256:042d55fe1e4c8093f2e9610a0eaae65f6c66a5385baf6e1da6d2c1f54f64b84b", "content": "The event-driven consumer for AMQP 1.0 protocol is implemented as an `AmqpMessageListenerContainer` similar to all other xref:amqp/receiving-messages/async-consumer.adoc[listener container implementations] in the framework.\nThe `AmqpMessageListenerContainer` requires an `AmqpConnectionFactory` and uses `org.apache.qpid.protonj2.client.Receiver` instances internally to consume messages from the provided `queueNames` (essentially, AMQP 1.o addresses).\nThe `100` initial credits are used for receiver links by default.\nEvery settled delivery then replenishes some number of credits for new upcoming messages.\nThe consumed messages are handled by the provided `MessageListener`, and if the `autoAccept` is set to `false`, an `AmqpAcknowledgment` implementation is populated to respective Spring AMQP message property for manual delivery settlement in the target message listener logic.\n\nThe `consumersPerQueue` option (`1` by default) implements a concurrency behavior for each provided address to consume.\n\nThe `Duration receiveTimeout` option (`1 second` by default) controls the blocking `Receiver.receive()` operation, which is called in a loop until consumer is stopped.\n\nEach consumer (an internal `AmqpMessageListenerContainer.AmqpConsumer` instance) is scheduled for running via `Executor`.\nThe `AmqpMessageListenerContainer.taskExecutor` property is set to a `SimpleAsyncTaskExecutor` by default.\n\nThe message processing errors can be handled by the `ErrorHandler` configuration.\n\nThe `MessageListener` can be proxied in the `AmqpMessageListenerContainer` if some AOP interceptors are provided, e.g. `TransactionInterceptor`.\n\nThe `AmqpMessageListenerContainer` also provides `pause()` and `resume()` API to set AMQP link credits to `0` and replenish, respectively.\nThis functionality leaves a `Receiver` active, but no delivery is coming from the AMQP peer.\n\nThe following example demonstrates a simple configuration for `AmqpMessageListenerContainer`:\n\n[source,java]\n----\nBlockingQueue<Message> receivedMessages = new LinkedBlockingQueue<>();\n\n@Bean\nAmqpMessageListenerContainer amqpMessageListenerContainer(AmqpConnectionFactory connectionFactory) {\n var amqpMessageListenerContainer = new AmqpMessageListenerContainer(connectionFactory);\n amqpMessageListenerContainer.setQueueNames(\"address1\", \"address2\");\n amqpMessageListenerContainer.setConsumersPerQueue(3);\n amqpMessageListenerContainer.setAutoAccept(false);\n amqpMessageListenerContainer.setReceiveTimeout(Duration.ofMillis(100));\n amqpMessageListenerContainer.setupMessageListener(this.receivedMessages::add);\n return amqpMessageListenerContainer;\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp10-client.adoc", "title": "amqp10-client", "heading": "The AMQP 1.0 Consumer", "heading_level": 2, "file_order": 76, "section_index": 4, "content_hash": "042d55fe1e4c8093f2e9610a0eaae65f6c66a5385baf6e1da6d2c1f54f64b84b", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp10-client.adoc"}}
{"id": "sha256:9fad7c767bdf7eda562d7e16a5f0fb241f3e3bd82495781cbab074188f3527c9", "content": "For convenience, a `ProtonDeliveryListener` contract is provided to handle native ProtonJ `Delivery` objects instead of Spring AMQP messages.\nIt could be useful in scenarios where full control over the `Delivery` instance is required.\nFor example, adding some reject conditions, handling received data as an `InputStream`, replenishing link credits dynamically, according to some target application logic.\nAnother scenario of native `Delivery` handling, when both producer and consumer deal with native ProtonJ `Message` contract, including ProtonJ body encoding/decoding internal mechanism (unlike the Spring AMQP message which accepts only `byte[]` bodies).\n\nNOTE: The manual delivery settlement still can be skipped, if the `AmqpMessageListenerContainer` is configured for `autoAccept = true` (default).\nAnd the `AmqpMessageListenerContainer` performs credits replenishment automatically.\n\nThe `ProtonDeliveryListener` implementation should be injected into the `AmqpMessageListenerContainer` as a regular `MessageListener`:\n\n[source,java]\n----\nBlockingQueue<Delivery> receivedDeliveries = new LinkedBlockingQueue<>();\n\n@Bean\nAmqpMessageListenerContainer protonDeliveryListenerContainer(AmqpConnectionFactory connectionFactory) {\n var amqpMessageListenerContainer = new AmqpMessageListenerContainer(connectionFactory);\n amqpMessageListenerContainer.setQueueNames(TEST_QUEUE_FOR_NATIVE_PROTON);\n amqpMessageListenerContainer.setAutoAccept(false);\n amqpMessageListenerContainer.setupMessageListener((ProtonDeliveryListener) this.receivedDeliveries::add);\n return amqpMessageListenerContainer;\n}\n----\n\n[[amqp10-annotation-configuration]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp10-client.adoc", "title": "amqp10-client", "heading": "ProtonJ `Delivery` Consumption", "heading_level": 3, "file_order": 76, "section_index": 5, "content_hash": "9fad7c767bdf7eda562d7e16a5f0fb241f3e3bd82495781cbab074188f3527c9", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp10-client.adoc"}}
{"id": "sha256:d672f0f45cbb76413f21569203c551cd4ac2d8ad1794042731e502e310d384ba", "content": "The `spring-amqp-client` provides a convenient way to configure the AMQP 1.0 infrastructure via annotations.\nThe `@EnableAmqp` annotation can be set on a `@Configuration` class in the target project to trigger that infrastructure registration.\nThe imported by the `@EnableAmqp` annotation `AmqpDefaultConfiguration` provides conditional beans (may be configured in the target project manually):\n\n* The `org.apache.qpid.protonj2.client.Client` where its `org.apache.qpid.protonj2.client.ClientOptions` property is based on the respective attributes of the imported metadata from the `@EnableAmqp`.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/amqp10-client.adoc", "title": "amqp10-client", "heading": "The AMQP 1.0 Annotation Configuration", "heading_level": 2, "file_order": 76, "section_index": 6, "content_hash": "d672f0f45cbb76413f21569203c551cd4ac2d8ad1794042731e502e310d384ba", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/amqp10-client.adoc"}}
{"id": "sha256:c28acb82bb54d4a89ddac10d58b9c3c87bb1bfe37df6649034a405c7c4da8d48", "content": "[[further-reading]]\n\nFor those who are not familiar with AMQP, the https://www.amqp.org/resources/download[specification] is actually quite readable.\nIt is, of course, the authoritative source of information, and the Spring AMQP code should be easy to understand for anyone who is familiar with the spec.\nOur current implementation of the RabbitMQ support is based on their 2.8.x version, and it officially supports AMQP 0.8 and 0.9.1.\nWe recommend reading the 0.9.1 document.\n\nThere are many great articles, presentations, and blogs available on the RabbitMQ https://www.rabbitmq.com/how.html[Getting Started] page.\nSince that is currently the only supported implementation for Spring AMQP, we also recommend that as a general starting point for all broker-related concerns.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/further-reading.adoc", "title": "further-reading", "heading": "further-reading", "heading_level": 1, "file_order": 77, "section_index": 0, "content_hash": "c28acb82bb54d4a89ddac10d58b9c3c87bb1bfe37df6649034a405c7c4da8d48", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/further-reading.adoc"}}
{"id": "sha256:655a1fe29be42a937708e0bb45b583f22f0b6900a440f639b43efec3353836f6", "content": "[[spring-amqp-reference]]\nMark Pollack; Mark Fisher; Oleg Zhurakousky; Dave Syer; Gary Russell; Gunnar Hillert; Artem Bilan; StÃ©phane Nicoll; Arnaud CogoluÃ¨gnes; Jay Bryant\n\n[[preface]]\nThe Spring AMQP project applies core Spring concepts to the development of AMQP-based messaging solutions.\nWe provide a \"`template`\" as a high-level abstraction for sending and receiving messages.\nWe also provide support for message-driven POJOs.\nThese libraries facilitate management of AMQP resources while promoting the use of dependency injection and declarative configuration.\nIn all of these cases, you can see similarities to the JMS support in the Spring Framework.\nFor other project-related information, visit the Spring AMQP project https://projects.spring.io/spring-amqp/[homepage].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/index.adoc", "title": "index", "heading": "index", "heading_level": 1, "file_order": 78, "section_index": 0, "content_hash": "655a1fe29be42a937708e0bb45b583f22f0b6900a440f639b43efec3353836f6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/index.adoc"}}
{"id": "sha256:5868c7aa166787597c4d9ac2e0188030ea71fff26dc44f0dfb9613f32628ebc4", "content": "[[spring-integration-reference]]\n\nThis part of the reference documentation provides a quick introduction to the AMQP support within the Spring Integration project.\n\n[[spring-integration-amqp-introduction]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/integration-reference.adoc", "title": "integration-reference", "heading": "integration-reference", "heading_level": 1, "file_order": 79, "section_index": 0, "content_hash": "5868c7aa166787597c4d9ac2e0188030ea71fff26dc44f0dfb9613f32628ebc4", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/integration-reference.adoc"}}
{"id": "sha256:6ca7465f54323c6784ed32f0f33c550c8ea03abd444c259acddd61cdbb7745a1", "content": "The https://spring.io/spring-integration[Spring Integration] project includes AMQP Channel Adapters and Gateways that build upon the Spring AMQP project.\nThose adapters are developed and released in the Spring Integration project.\nIn Spring Integration, \"`Channel Adapters`\" are unidirectional (one-way), whereas \"`Gateways`\" are bidirectional (request-reply).\nWe provide an inbound-channel-adapter, an outbound-channel-adapter, an inbound-gateway, and an outbound-gateway.\n\nSince the AMQP adapters are part of the Spring Integration release, the documentation is available as part of the Spring Integration distribution.\nWe provide a quick overview of the main features here.\nSee the {spring-integration-docs}[Spring Integration Reference Guide] for much more detail.\n\n[[inbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/integration-reference.adoc", "title": "integration-reference", "heading": "Introduction", "heading_level": 2, "file_order": 79, "section_index": 1, "content_hash": "6ca7465f54323c6784ed32f0f33c550c8ea03abd444c259acddd61cdbb7745a1", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/integration-reference.adoc"}}
{"id": "sha256:fdc1911efecbe617948e4c93aa7812c764b27a822166c74233b59ca7c214c408", "content": "To receive AMQP Messages from a queue, you can configure an `<inbound-channel-adapter>`.\nThe following example shows how to configure an inbound channel adapter:\n\n[source,xml]\n----\n<amqp:inbound-channel-adapter channel=\"fromAMQP\"\n queue-names=\"some.queue\"\n connection-factory=\"rabbitConnectionFactory\"/>\n----\n\n[[outbound-channel-adapter]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/integration-reference.adoc", "title": "integration-reference", "heading": "Inbound Channel Adapter", "heading_level": 2, "file_order": 79, "section_index": 2, "content_hash": "fdc1911efecbe617948e4c93aa7812c764b27a822166c74233b59ca7c214c408", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/integration-reference.adoc"}}
{"id": "sha256:938ceb819922297c94a8f0d34ad7ca54f7b2ecf2c5384d67ae4a3771d50c4ddc", "content": "To send AMQP Messages to an exchange, you can configure an `<outbound-channel-adapter>`.\nYou can optionally provide a 'routing-key' in addition to the exchange name.\nThe following example shows how to define an outbound channel adapter:\n\n[source,xml]\n----\n<amqp:outbound-channel-adapter channel=\"toAMQP\"\n exchange-name=\"some.exchange\"\n routing-key=\"foo\"\n amqp-template=\"rabbitTemplate\"/>\n----\n\n[[inbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/integration-reference.adoc", "title": "integration-reference", "heading": "Outbound Channel Adapter", "heading_level": 2, "file_order": 79, "section_index": 3, "content_hash": "938ceb819922297c94a8f0d34ad7ca54f7b2ecf2c5384d67ae4a3771d50c4ddc", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/integration-reference.adoc"}}
{"id": "sha256:56e283a8a2452d778ed01ac8f31f5f03a9182cea53dafbf5583f55195ca4e2ac", "content": "To receive an AMQP Message from a queue and respond to its reply-to address, you can configure an `<inbound-gateway>`.\nThe following example shows how to define an inbound gateway:\n\n[source,xml]\n----\n<amqp:inbound-gateway request-channel=\"fromAMQP\"\n reply-channel=\"toAMQP\"\n queue-names=\"some.queue\"\n connection-factory=\"rabbitConnectionFactory\"/>\n----\n\n[[outbound-gateway]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/integration-reference.adoc", "title": "integration-reference", "heading": "Inbound Gateway", "heading_level": 2, "file_order": 79, "section_index": 4, "content_hash": "56e283a8a2452d778ed01ac8f31f5f03a9182cea53dafbf5583f55195ca4e2ac", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/integration-reference.adoc"}}
{"id": "sha256:a0e1c85403c89fa00fce418f7fea368394369a20bf70e8f24a521e476424f0cd", "content": "To send AMQP Messages to an exchange and receive back a response from a remote client, you can configure an `<outbound-gateway>`.\nYou can optionally provide a 'routing-key' in addition to the exchange name.\nThe following example shows how to define an outbound gateway:\n\n[source,xml]\n----\n<amqp:outbound-gateway request-channel=\"toAMQP\"\n reply-channel=\"fromAMQP\"\n exchange-name=\"some.exchange\"\n routing-key=\"foo\"\n amqp-template=\"rabbitTemplate\"/>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/integration-reference.adoc", "title": "integration-reference", "heading": "Outbound Gateway", "heading_level": 2, "file_order": 79, "section_index": 5, "content_hash": "a0e1c85403c89fa00fce418f7fea368394369a20bf70e8f24a521e476424f0cd", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/integration-reference.adoc"}}
{"id": "sha256:3bfff2c077ac2bb41a8ef5b28e2775bb894eff85d6ecedfec2fef74240bf91a6", "content": "[[logging]]\n\nThe framework provides logging appenders for some popular logging subsystems:\n\n* logback (since Spring AMQP version 1.4)\n* log4j2 (since Spring AMQP version 1.6)\n\nThe appenders are configured by using the normal mechanisms for the logging subsystem, available properties are specified in the following sections.\n\n[[common-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/logging.adoc", "title": "logging", "heading": "logging", "heading_level": 1, "file_order": 80, "section_index": 0, "content_hash": "3bfff2c077ac2bb41a8ef5b28e2775bb894eff85d6ecedfec2fef74240bf91a6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/logging.adoc"}}
{"id": "sha256:7b4f74ac5c1e3a9cd85fd65d9265214c9101a8c2592dab41b8b03d38983ff053", "content": "The following properties are available with all appenders:\n\n.Common Appender Properties\n[cols=\"2l,2l,4\", options=\"header\"]\n|===\n| Property\n| Default\n| Description\n\n| exchangeName\n| logs\n| Name of the exchange to which to publish log events.\n\n| exchangeType\n| topic\n| Type of the exchange to which to publish log events -- needed only if the appender declares the exchange.\nSee `declareExchange`.\n\n| routingKeyPattern\n| %c.%p\n| Logging subsystem pattern format to use to generate a routing key.\n\n| applicationId\n|\n| Application ID -- added to the routing key if the pattern includes `+%X{applicationId}+`.\n\n| senderPoolSize\n| 2\n| The number of threads to use to publish log events.\n\n| maxSenderRetries\n| 30\n| How many times to retry sending a message if the broker is unavailable or there is some other error.\nRetries are delayed as follows: `N ^ log(N)`, where `N` is the retry number.\n\n| addresses\n|\n| A comma-delimited list of broker addresses in the following form: `host:port[,host:port]*` - overrides `host` and `port`.\n\n| host\n| localhost\n| RabbitMQ host to which to connect .\n\n| port\n| 5672\n| RabbitMQ port to which to connect.\n\n| virtualHost\n| /\n| RabbitMQ virtual host to which to connect.\n\n| username\n| guest\n| RabbitMQ user to use when connecting.\n\n| password\n| guest\n| RabbitMQ password for this user.\n\n| useSsl\n| false\n| Whether to use SSL for the RabbitMQ connection.\nSee xref:amqp/connections.adoc#rabbitconnectionfactorybean-configuring-ssl[`RabbitConnectionFactoryBean` and Configuring SSL]\n\n| verifyHostname\n| true\n| Enable server hostname verification for TLS connections.\nSee xref:amqp/connections.adoc#rabbitconnectionfactorybean-configuring-ssl[`RabbitConnectionFactoryBean` and Configuring SSL]\n\n| sslAlgorithm\n| null\n| The SSL algorithm to use.\n\n| sslPropertiesLocation\n| null\n| Location of the SSL properties file.\n\n| keyStore\n| null\n| Location of the keystore.\n\n| keyStorePassphrase\n| null\n| Passphrase for the keystore.\n\n| keyStoreType\n| JKS\n| The keystore type.\n\n| trustStore\n| null\n| Location of the truststore.\n\n| trustStorePassphrase\n| null\n| Passphrase for the truststore.\n\n| trustStoreType\n| JKS\n| The truststore type.\n\n| saslConfig\n| null (RabbitMQ client default applies)\n| The `saslConfig` - see the javadoc for `RabbitUtils.stringToSaslConfig` for valid values.\n\n| contentType\n| text/plain\n| `content-type` property of log messages.\n\n| contentEncoding\n|\n| `content-encoding` property of log messages.\n\n| declareExchange\n| false\n| Whether or not to declare the configured exchange when this appender starts.\nSee also `durable` and `autoDelete`.\n\n| durable\n| true\n| When `declareExchange` is `true`, the durable flag is set to this value.\n\n| autoDelete\n| false\n| When `declareExchange` is `true`, the auto-delete flag is set to this value.\n\n| charset\n| null\n| Character set to use when converting `String` to `byte[]`.\nDefault: null (the system default charset is used).\nIf the character set is unsupported on the current platform, we fall back to using the system character set.\n\n| deliveryMode\n| PERSISTENT\n| `PERSISTENT` or `NON_PERSISTENT` to determine whether or not RabbitMQ should persist the messages.\n\n| generateId\n| false\n| Used to determine whether the `messageId` property is set to a unique value.\n\n| clientConnectionProperties\n| null\n| A comma-delimited list of `key:value` pairs for custom client properties to the RabbitMQ connection.\n\n| addMdcAsHeaders\n| true\n| MDC properties were always added into RabbitMQ message headers until this property was introduced.\nIt can lead to issues for big MDC as while RabbitMQ has limited buffer size for all headers and this buffer is pretty small.\nThis property was introduced to avoid issues in cases of big MDC.\nBy default this value set to `true` for backward compatibility.\nThe `false` turns off serialization MDC into headers.\nPlease note, the `JsonLayout` adds MDC into the message by default.\n\n|===\n\n[[log4j-2-appender]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/logging.adoc", "title": "logging", "heading": "Common properties", "heading_level": 2, "file_order": 80, "section_index": 1, "content_hash": "7b4f74ac5c1e3a9cd85fd65d9265214c9101a8c2592dab41b8b03d38983ff053", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/logging.adoc"}}
{"id": "sha256:42e9214b8385df50b55b74106264fe355697a8a945f7b6c3e89c76825625c027", "content": "The following example shows how to configure a Log4j 2 appender:\n\n[source, xml]\n----\n<Appenders>\n ...\n <RabbitMQ name=\"rabbitmq\"\n addresses=\"foo:5672,bar:5672\" user=\"guest\" password=\"guest\" virtualHost=\"/\"\n exchange=\"log4j2\" exchangeType=\"topic\" declareExchange=\"true\" durable=\"true\" autoDelete=\"false\"\n applicationId=\"myAppId\" routingKeyPattern=\"%X{applicationId}.%c.%p\"\n contentType=\"text/plain\" contentEncoding=\"UTF-8\" generateId=\"true\" deliveryMode=\"NON_PERSISTENT\"\n charset=\"UTF-8\"\n senderPoolSize=\"3\" maxSenderRetries=\"5\"\n addMdcAsHeaders=\"false\">\n </RabbitMQ>\n</Appenders>\n----\n\n[IMPORTANT]\n====\nStarting with versions 1.6.10 and 1.7.3, by default, the log4j2 appender publishes the messages to RabbitMQ on the calling thread.\nThis is because Log4j 2 does not, by default, create thread-safe events.\nIf the broker is down, the `maxSenderRetries` is used to retry, with no delay between retries.\nIf you wish to restore the previous behavior of publishing the messages on separate threads (`senderPoolSize`), you can set the `async` property to `true`.\nHowever, you also need to configure Log4j 2 to use the `DefaultLogEventFactory` instead of the `ReusableLogEventFactory`.\nOne way to do that is to set the system property `-Dlog4j2.enable.threadlocals=false`.\nIf you use asynchronous publishing with the `ReusableLogEventFactory`, events have a high likelihood of being corrupted due to cross-talk.\n====\n\n[[logback-appender]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/logging.adoc", "title": "logging", "heading": "Log4j 2 Appender", "heading_level": 2, "file_order": 80, "section_index": 2, "content_hash": "42e9214b8385df50b55b74106264fe355697a8a945f7b6c3e89c76825625c027", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/logging.adoc"}}
{"id": "sha256:36d775a58690f45eeb6c6e295b5668d1c6ac56d7f1ac82257af2e2fb7763a4f6", "content": "The following example shows how to configure a logback appender:\n\n[source, xml]\n----\n<appender name=\"AMQP\" class=\"org.springframework.amqp.rabbit.logback.AmqpAppender\">\n <layout>\n <pattern><![CDATA[ %d %p %t [%c] - <%m>%n ]]></pattern>\n </layout>\n <addresses>foo:5672,bar:5672</addresses>\n <abbreviation>36</abbreviation>\n <includeCallerData>false</includeCallerData>\n <applicationId>myApplication</applicationId>\n <routingKeyPattern>%property{applicationId}.%c.%p</routingKeyPattern>\n <generateId>true</generateId>\n <charset>UTF-8</charset>\n <durable>false</durable>\n <deliveryMode>NON_PERSISTENT</deliveryMode>\n <declareExchange>true</declareExchange>\n <addMdcAsHeaders>false</addMdcAsHeaders>\n</appender>\n----\n\nStarting with version 1.7.1, the Logback `AmqpAppender` provides an `includeCallerData` option, which is `false` by default.\nExtracting caller data can be rather expensive, because the log event has to create a throwable and inspect it to determine the calling location.\nTherefore, by default, caller data associated with an event is not extracted when the event is added to the event queue.\nYou can configure the appender to include caller data by setting the `includeCallerData` property to `true`.\n\nStarting with version 2.0.0, the Logback `AmqpAppender` supports https://logback.qos.ch/manual/encoders.html[Logback encoders] with the `encoder` option.\nThe `encoder` and `layout` options are mutually exclusive.\n\n[[customizing-the-messages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/logging.adoc", "title": "logging", "heading": "Logback Appender", "heading_level": 2, "file_order": 80, "section_index": 3, "content_hash": "36d775a58690f45eeb6c6e295b5668d1c6ac56d7f1ac82257af2e2fb7763a4f6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/logging.adoc"}}
{"id": "sha256:7eb4a354d7a5a0056769570e2572ccab4535662677ae4b983c6f2321859d738c", "content": "By default, AMQP appenders populate the following message properties:\n\n* `deliveryMode`\n* contentType\n* `contentEncoding`, if configured\n* `messageId`, if `generateId` is configured\n* `timestamp` of the log event\n* `appId`, if applicationId is configured\n\nIn addition they populate headers with the following values:\n\n* `categoryName` of the log event\n* The level of the log event\n* `thread`: the name of the thread where log event happened\n* The location of the stack trace of the log event call\n* A copy of all the MDC properties (unless `addMdcAsHeaders` is set to `false`)\n\nEach of the appenders can be subclassed, letting you modify the messages before publishing.\nThe following example shows how to customize log messages:\n\n[source, java]\n----\npublic class MyEnhancedAppender extends AmqpAppender {\n\n @Override\n public Message postProcessMessageBeforeSend(Message message, Event event) {\n message.getMessageProperties().setHeader(\"foo\", \"bar\");\n return message;\n }\n\n}\n----\n\nStarting with 2.2.4, the log4j2 `AmqpAppender` can be extended using `@PluginBuilderFactory` and extending also `AmqpAppender.Builder`\n\n[source, java]\n----\n@Plugin(name = \"MyEnhancedAppender\", category = \"Core\", elementType = \"appender\", printObject = true)\npublic class MyEnhancedAppender extends AmqpAppender {\n\n\tpublic MyEnhancedAppender(String name, Filter filter, Layout<? extends Serializable> layout,\n boolean ignoreExceptions, AmqpManager manager, BlockingQueue<Event> eventQueue, String foo, String bar) {\n super(name, filter, layout, ignoreExceptions, manager, eventQueue);\n\n\t@Override\n\tpublic Message postProcessMessageBeforeSend(Message message, Event event) {\n message.getMessageProperties().setHeader(\"foo\", \"bar\");\n return message;\n\t}\n\n\t@PluginBuilderFactory\n\tpublic static Builder newBuilder() {\n return new Builder();\n\t}\n\n\tprotected static class Builder extends AmqpAppender.Builder {\n\n @Override\n protected AmqpAppender buildInstance(String name, Filter filter, Layout<? extends Serializable> layout,\n boolean ignoreExceptions, AmqpManager manager, BlockingQueue<Event> eventQueue) {\n return new MyEnhancedAppender(name, filter, layout, ignoreExceptions, manager, eventQueue);\n }\n\t}\n\n}\n----\n\n[[customizing-the-client-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/logging.adoc", "title": "logging", "heading": "Customizing the Messages", "heading_level": 2, "file_order": 80, "section_index": 4, "content_hash": "7eb4a354d7a5a0056769570e2572ccab4535662677ae4b983c6f2321859d738c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/logging.adoc"}}
{"id": "sha256:f80fc909edad1ecfcbb7c2f1aaf32bdd18780c22979c02e5937f94a7ea6a5c22", "content": "You can add custom client properties by adding either string properties or more complex properties.\n\n[[simple-string-properties]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/logging.adoc", "title": "logging", "heading": "Customizing the Client Properties", "heading_level": 2, "file_order": 80, "section_index": 5, "content_hash": "f80fc909edad1ecfcbb7c2f1aaf32bdd18780c22979c02e5937f94a7ea6a5c22", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/logging.adoc"}}
{"id": "sha256:bbafb27b21cdc41dd4f9c747dd25d8e70ba5bf0500f1c93e795d979d2b305cb7", "content": "Each appender supports adding client properties to the RabbitMQ connection.\n\nThe following example shows how to add a custom client property:\n\n[tabs]\n======\nlogback::\n+\n[source, xml]\n----\n<appender name=\"AMQP\" ...>\n ...\n <clientConnectionProperties>thing1:thing2,cat:hat</clientConnectionProperties>\n ...\n</appender>\n----\n\nlog4j2::\n+\n[source, xml]\n----\n<Appenders>\n ...\n <RabbitMQ name=\"rabbitmq\"\n ...\n clientConnectionProperties=\"thing1:thing2,cat:hat\"\n ...\n </RabbitMQ>\n</Appenders>\n----\n======\n\nThe properties are a comma-delimited list of `key:value` pairs.\nKeys and values cannot contain commas or colons.\n\nThese properties appear on the RabbitMQ Admin UI when the connection is viewed.\n\n[[advanced-technique-for-logback]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/logging.adoc", "title": "logging", "heading": "Simple String Properties", "heading_level": 3, "file_order": 80, "section_index": 6, "content_hash": "bbafb27b21cdc41dd4f9c747dd25d8e70ba5bf0500f1c93e795d979d2b305cb7", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/logging.adoc"}}
{"id": "sha256:91434e102b50ffb15ef4cf039e295b1cb78ab15ec887cdb07e0c28e2d7748663", "content": "You can subclass the Logback appender.\nDoing so lets you modify the client connection properties before the connection is established.\nThe following example shows how to do so:\n\n[source, java]\n----\npublic class MyEnhancedAppender extends AmqpAppender {\n\n private String thing1;\n\n @Override\n protected void updateConnectionClientProperties(Map<String, Object> clientProperties) {\n clientProperties.put(\"thing1\", this.thing1);\n }\n\n public void setThing1(String thing1) {\n this.thing1 = thing1;\n }\n\n}\n----\n\nThen you can add `<thing1>thing2</thing1>` to logback.xml.\n\nFor String properties such as those shown in the preceding example, the previous technique can be used.\nSubclasses allow for adding richer properties (such as adding a `Map` or numeric property).\n\n[[providing-a-custom-queue-implementation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/logging.adoc", "title": "logging", "heading": "Advanced Technique for Logback", "heading_level": 3, "file_order": 80, "section_index": 7, "content_hash": "91434e102b50ffb15ef4cf039e295b1cb78ab15ec887cdb07e0c28e2d7748663", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/logging.adoc"}}
{"id": "sha256:51052af7b89b3901453349fc75acd7b0129a7052f22ae54187b47c750bc9e280", "content": "The `AmqpAppenders` use a `BlockingQueue` to asynchronously publish logging events to RabbitMQ.\nBy default, a `LinkedBlockingQueue` is used.\nHowever, you can supply any kind of custom `BlockingQueue` implementation.\n\nThe following example shows how to do so for Logback:\n\n[source, java]\n----\npublic class MyEnhancedAppender extends AmqpAppender {\n\n @Override\n protected BlockingQueue<Event> createEventQueue() {\n return new ArrayBlockingQueue();\n }\n\n}\n----\n\nThe Log4j 2 appender supports using a https://logging.apache.org/log4j/2.x/manual/appenders/delegating.html#BlockingQueueFactory[`BlockingQueueFactory`], as the following example shows:\n\n[source, xml]\n----\n<Appenders>\n ...\n <RabbitMQ name=\"rabbitmq\"\n bufferSize=\"10\" ... >\n <ArrayBlockingQueue/>\n </RabbitMQ>\n</Appenders>\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/logging.adoc", "title": "logging", "heading": "Providing a Custom Queue Implementation", "heading_level": 2, "file_order": 80, "section_index": 8, "content_hash": "51052af7b89b3901453349fc75acd7b0129a7052f22ae54187b47c750bc9e280", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/logging.adoc"}}
{"id": "sha256:71fdfdb6410ae690526a992983323200129ea15f7774fcfe46ae2603b8e9090d", "content": "[[amqp-client]]\n\nVersion 4.0 introduces `spring-rabbitmq-client` module for https://www.rabbitmq.com/client-libraries/amqp-client-libraries[AMQP 1.0] protocol support on RabbitMQ.\n\nThis artifact is based on the {rabbitmq-github}/rabbitmq-amqp-java-client[com.rabbitmq.client:amqp-client] library and therefore can work only with RabbitMQ and its AMQP 1.0 protocol support.\nIt cannot be used for any arbitrary AMQP 1.0 broker.\nFor that purpose a https://qpid.apache.org/components/jms/index.html[JMS bridge] and respective {spring-framework-docs}/integration/jms.html[Spring JMS] integration is recommended so far.\n\nThis dependency has to be added to the project to be able to interact with RabbitMQ AMQP 1.0 support:\n\n[tabs]\n======\nMaven::\n+\n[source,xml,subs=\"+attributes\"]\n----\n<dependency>\n <groupId>org.springframework.amqp</groupId>\n <artifactId>spring-rabbitmq-client</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source,groovy,subs=\"+attributes\"]\n----\nimplementation 'org.springframework.amqp:spring-rabbitmq-client:{project-version}'\n----\n======\n\nThe `spring-rabbit` (for AMQP 0.9.1 protocol) comes as a transitive dependency for reusing some common API in this new client, for example, exceptions, the `@RabbitListener` support.\nIt is not necessary to use both functionality in the target project, but RabbitMQ allows both AMQP 0.9.1 and 1.0 co-exists.\n\nFor more information about RabbitMQ AMQP 1.0 Java Client see its https://www.rabbitmq.com/client-libraries/amqp-client-libraries[documentation].\n\n[[amqp-client-environment]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/rabbitmq-amqp-client.adoc", "title": "rabbitmq-amqp-client", "heading": "rabbitmq-amqp-client", "heading_level": 1, "file_order": 81, "section_index": 0, "content_hash": "71fdfdb6410ae690526a992983323200129ea15f7774fcfe46ae2603b8e9090d", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/rabbitmq-amqp-client.adoc"}}
{"id": "sha256:1192d866a5999dcff0017b192793195b8df25a5a31cc44a93377d18fec8e5bbb", "content": "The `com.rabbitmq.client.amqp.Environment` is the first thing which has to be added to the project for connection management and other common settings.\nIt is an entry point to a node or a cluster of nodes.\nThe environment allows creating connections.\nIt can contain infrastructure-related configuration settings shared between connections, e.g. pools of threads, metrics and/or observation:\n\n[source,java]\n----\n@Bean\nEnvironment environment() {\n return new AmqpEnvironmentBuilder()\n .connectionSettings()\n .port(5672)\n .environmentBuilder()\n .build();\n}\n----\n\nThe same `Environment` instance can be used for connecting to different RabbitMQ brokers, then connection setting must be provided on specific connection.\nSee below.\n\n[[amqp-client-connection-factory]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/rabbitmq-amqp-client.adoc", "title": "rabbitmq-amqp-client", "heading": "RabbitMQ AMQP 1.0 Environment", "heading_level": 2, "file_order": 81, "section_index": 1, "content_hash": "1192d866a5999dcff0017b192793195b8df25a5a31cc44a93377d18fec8e5bbb", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/rabbitmq-amqp-client.adoc"}}
{"id": "sha256:d548295ad119a283e222903b1ffa0139b2242c3f0cc7df3418a3c99e01870280", "content": "The `org.springframework.amqp.rabbitmq.client.AmqpConnectionFactory` abstraction was introduced to manage `com.rabbitmq.client.amqp.Connection`.\nDon't confuse it with a `org.springframework.amqp.rabbit.connection.ConnectionFactory` which is only for AMQP 0.9.1 protocol.\nThe `SingleAmqpConnectionFactory` implementation is present to manage one connection and its settings.\nThe same `Connection` can be shared between many producers, consumers and management.\nThe multi-plexing is handled by the link abstraction for AMQP 1.0 protocol implementation internally in the AMQP client library.\nThe `Connection` has recovery capabilities and also handles topology.\n\nIn most cases there is just enough to add this bean into the project:\n\n[source,java]\n----\n@Bean\nAmqpConnectionFactory connectionFactory(Environment environment) {\n return new SingleAmqpConnectionFactory(environment);\n}\n----\n\nSee `SingleAmqpConnectionFactory` setters for all connection-specific setting.\n\n[[amqp-client-topology]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/rabbitmq-amqp-client.adoc", "title": "rabbitmq-amqp-client", "heading": "AMQP Connection Factory", "heading_level": 2, "file_order": 81, "section_index": 2, "content_hash": "d548295ad119a283e222903b1ffa0139b2242c3f0cc7df3418a3c99e01870280", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/rabbitmq-amqp-client.adoc"}}
{"id": "sha256:ef8a0d4ab7e0c3551f3faa6b84a7a6ceae81c9a286d77b50209105c1e8760487", "content": "For topology management (exchanges, queues and binding between) from the application perspective, the `RabbitAmqpAdmin` is present, which is an implementation of existing `AmqpAdmin` interface:\n\n[source,java]\n----\n@Bean\nRabbitAmqpAdmin admin(AmqpConnectionFactory connectionFactory) {\n return new RabbitAmqpAdmin(connectionFactory);\n}\n----\n\nThe same bean definitions for `Exchange`, `Queue`, `Binding` and `Declarables` instances as described in the xref:amqp/broker-configuration.adoc[] has to be used to manage topology.\nThe `RabbitAdmin` from `spring-rabbit` can also do that, but it happens against AMQP 0.9.1 connection, and since `RabbitAmqpAdmin` is based on the AMQP 1.0 connection, the topology recovery is handled smoothly from there, together with publishers and consumers recovery.\n\nThe `RabbitAmqpAdmin` performs respective beans scanning in its `start()` lifecycle callback.\nThe `initialize()`, as well-as all other RabbitMQ entities management methods can be called manually at runtime.\nInternally the `RabbitAmqpAdmin` uses `com.rabbitmq.client.amqp.Connection.management()` API to perform respective topology manipulations.\n\n[[amqp-client-template]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/rabbitmq-amqp-client.adoc", "title": "rabbitmq-amqp-client", "heading": "RabbitMQ Topology Management", "heading_level": 2, "file_order": 81, "section_index": 3, "content_hash": "ef8a0d4ab7e0c3551f3faa6b84a7a6ceae81c9a286d77b50209105c1e8760487", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/rabbitmq-amqp-client.adoc"}}
{"id": "sha256:c3fa54c388f2c43f19f2ac11cc5409118b5d001fff73a1fc05f183c339a10b8e", "content": "The `RabbitAmqpTemplate` is an implementation of the `AsyncAmqpTemplate` and performs various send/receive operations with AMQP 1.0 protocol.\nRequires an `AmqpConnectionFactory` and can be configured with some defaults.\nEven if `com.rabbitmq.client:amqp-client` library comes with a `com.rabbitmq.client.amqp.Message`, the `RabbitAmqpTemplate` still exposes an API based on the well-known `org.springframework.amqp.core.Message` with all the supporting classes like `MessageProperties` and `MessageConverter` abstraction.\nThe conversion to/from `com.rabbitmq.client.amqp.Message` is done internally in the `RabbitAmqpTemplate`.\nAll the methods return a `CompletableFuture` to obtain operation results eventually.\nThe operations with plain object require message body conversion and `SimpleMessageConverter` is used by default.\nSee xref:amqp/message-converters.adoc[] for more information about conversions.\n\nUsually, just one bean like this is enough to perform all the possible template pattern operation:\n\n[source,java]\n----\n@Bean\nRabbitAmqpTemplate rabbitTemplate(AmqpConnectionFactory connectionFactory) {\n return new RabbitAmqpTemplate(connectionFactory);\n}\n----\n\nIt can be configured for some default exchange and routing key or just queue.\nThe `RabbitAmqpTemplate` have a default queue for receive operation and another default queue for request-reply operation where temporary queue is created for the request by the client if not present.\n\nHere are some samples of `RabbitAmqpTemplate` operations:\n\n[source,java]\n----\n@Bean\nDirectExchange e1() {\n return new DirectExchange(\"e1\");\n}\n\n@Bean\nQueue q1() {\n return QueueBuilder.durable(\"q1\").deadLetterExchange(\"dlx1\").build();\n}\n\n@Bean\nBinding b1() {\n return BindingBuilder.bind(q1()).to(e1()).with(\"k1\");\n}\n\n...\n\n@Test\nvoid defaultExchangeAndRoutingKey() {\n this.rabbitAmqpTemplate.setExchange(\"e1\");\n this.rabbitAmqpTemplate.setRoutingKey(\"k1\");\n\tthis.rabbitAmqpTemplate.setReceiveQueue(\"q1\");\n\n assertThat(this.rabbitAmqpTemplate.convertAndSend(\"test1\"))\n .succeedsWithin(Duration.ofSeconds(10));\n\n assertThat(this.rabbitAmqpTemplate.receiveAndConvert())\n .succeedsWithin(Duration.ofSeconds(10))\n .isEqualTo(\"test1\");\n}\n----\n\nHere we declared an `e1` exchange, `q1` queue and bind it into that exchange with a `k1` routing key.\nThen we use a default setting for `RabbitAmqpTemplate` to publish messages to the mentioned exchange with the respective routing key and use `q1` as default queue for receiving operations.\nThere are overloaded variants for those methods to send to specific exchange or queue (for send and receive).\nThe `receiveAndConvert()` operations with a `ParameterizedTypeReference<T>` requires a `SmartMessageConverter` to be injected into the `RabbitAmqpTemplate`.\n\nThe next example demonstrate and RPC implementation with `RabbitAmqpTemplate` (assuming same RabbitMQ objects as in the previous example):\n\n[source,java]\n----\n@Test\nvoid verifyRpc() {\n String testRequest = \"rpc-request\";\n String testReply = \"rpc-reply\";\n\n CompletableFuture<Object> rpcClientResult = this.template.convertSendAndReceive(\"e1\", \"k1\", testRequest);\n\n AtomicReference<String> receivedRequest = new AtomicReference<>();\n CompletableFuture<Boolean> rpcServerResult =\n this.rabbitAmqpTemplate.<String, String>receiveAndReply(\"q1\",\n payload -> {\n receivedRequest.set(payload);\n return testReply;\n });\n\n assertThat(rpcServerResult).succeedsWithin(Duration.ofSeconds(10)).isEqualTo(true);\n assertThat(rpcClientResult).succeedsWithin(Duration.ofSeconds(10)).isEqualTo(testReply);\n assertThat(receivedRequest.get()).isEqualTo(testRequest);\n}\n----\n\nThe correlation and `replyTo` queue are managed internally.\nThe server side can be implemented with a `@RabbitListener` POJO method described below.\n\n[[amqp-client-listener]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/rabbitmq-amqp-client.adoc", "title": "rabbitmq-amqp-client", "heading": "`RabbitAmqpTemplate`", "heading_level": 2, "file_order": 81, "section_index": 4, "content_hash": "c3fa54c388f2c43f19f2ac11cc5409118b5d001fff73a1fc05f183c339a10b8e", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/rabbitmq-amqp-client.adoc"}}
{"id": "sha256:f93883b960f95392b4db09c0ceccda9c44a039b6acff24fae2e1fe78276dbcf7", "content": "As with many other messaging implementations for consumer side, the `spring-rabbitmq-client` modules comes with the `RabbitAmqpListenerContainer` which is, essentially, an implementation of well-know `org.springframework.amqp.core.MessageListenerContainer`.\nIt does exactly the same as `DirectMessageListenerContainer`, but for RabbitMQ AMQP 1.0 support.\nRequires an `AmqpConnectionFactory` and at least one queue to consume from.\nAlso, the `MessageListener` (or AMQP 1.0 specific `RabbitAmqpMessageListener`) must be provided.\nCan be configured with an `autoSettle = false`, with the meaning of `AcknowledgeMode.MANUAL`.\nIn that case, the `Message` provided to the `MessageListener` has in its `MessageProperties` an `AmqpAcknowledgment` callback for target logic consideration.\n\nThe `RabbitAmqpMessageListener` has a contract for `com.rabbitmq.client:amqp-client` abstractions:\n\n[source,java]\n----\n/**\n * Process an AMQP message.\n * @param message the message to process.\n * @param context the consumer context to settle message.\n * Null if container is configured for {@code autoSettle}.\n */\nvoid onAmqpMessage(Message message, Consumer.Context context);\n----\n\nWhere the first argument is a native received `com.rabbitmq.client.amqp.Message` and `context` is a native callback for message settlement, similar to the mentioned above `AmqpAcknowledgment` abstraction.\n\nThe `RabbitAmqpMessageListener` can handle and settle messages in batches when `batchSize` option is provided.\nFor this purpose the `MessageListener.onMessageBatch()` contract must be implemented.\nThe `batchReceiveDuration` option is used to schedule a force release for not full batches to avoid memory and https://www.rabbitmq.com/blog/2024/09/02/amqp-flow-control[consumer credits] exhausting.\n\nUsually, the `RabbitAmqpMessageListener` class is not used directly in the target project, and POJO method annotation configuration via `@RabbitListener` is chosen for declarative consumer configuration.\nThe `RabbitAmqpListenerContainerFactory` must be registered under the `RabbitListenerAnnotationBeanPostProcessor.DEFAULT_RABBIT_LISTENER_CONTAINER_FACTORY_BEAN_NAME`, and `@RabbitListener` annotation process will register `RabbitAmqpMessageListener` instance into the `RabbitListenerEndpointRegistry`.\nThe target POJO method invocation is handled by specific `RabbitAmqpMessageListenerAdapter` implementation, which extends a `MessagingMessageListenerAdapter` and reuses a lot of its functionality, including request-reply scenarios (async or not).\nSo, all the concepts described in the xref:amqp/receiving-messages/async-annotation-driven.adoc[] are applied with this `RabbitAmqpMessageListener` as well.\n\nIn addition to traditional messaging `payload` and `headers`, the `@RabbitListener` POJO method contract can be with these parameters:\n\n* `com.rabbitmq.client.amqp.Message` - the native AMQP 1.0 message without any conversions;\n* `org.springframework.amqp.core.Message` - Spring AMQP message abstraction as conversion result from the native AMQP 1.0 message;\n* `org.springframework.messaging.Message` - Spring Messaging abstraction as conversion result from the Spring AMQP message;\n* `Consumer.Context` - RabbitMQ AMQP client consumer settlement API;\n* `org.springframework.amqp.core.AmqpAcknowledgment` - Spring AMQP acknowledgment abstraction: delegates to the `Consumer.Context`.\n\nThe following example demonstrates a simple `@RabbitListener` for RabbitMQ AMQP 1.0 interaction with the manual settlement:\n\n[source,java]\n----\n@Bean(RabbitListenerAnnotationBeanPostProcessor.DEFAULT_RABBIT_LISTENER_CONTAINER_FACTORY_BEAN_NAME)\nRabbitAmqpListenerContainerFactory rabbitAmqpListenerContainerFactory(AmqpConnectionFactory connectionFactory) {\n return new RabbitAmqpListenerContainerFactory(connectionFactory);\n}\n\nfinal List<String> received = Collections.synchronizedList(new ArrayList<>());\n\nCountDownLatch consumeIsDone = new CountDownLatch(11);\n\n@RabbitListener(queues = {\"q1\", \"q2\"},\n ackMode = \"#{T(org.springframework.amqp.core.AcknowledgeMode).MANUAL}\",\n concurrency = \"2\",\n id = \"testAmqpListener\")\nvoid processQ1AndQ2Data(String data, AmqpAcknowledgment acknowledgment, Consumer.Context context) {\n try {\n if (\"discard\".equals(data)) {\n if (!this.received.contains(data)) {\n context.discard();\n }\n else {\n throw new MessageConversionException(\"Test message is rejected\");\n }\n }\n else if (\"requeue\".equals(data) && !this.received.contains(data)) {\n acknowledgment.acknowledge(AmqpAcknowledgment.Status.REQUEUE);\n }\n else {\n acknowledgment.acknowledge();\n }\n this.received.add(data);\n }\n finally {\n this.consumeIsDone.countDown();\n }\n}\n----", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/rabbitmq-amqp-client.adoc", "title": "rabbitmq-amqp-client", "heading": "The RabbitMQ AMQP 1.0 Consumer", "heading_level": 2, "file_order": 81, "section_index": 5, "content_hash": "f93883b960f95392b4db09c0ceccda9c44a039b6acff24fae2e1fe78276dbcf7", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/rabbitmq-amqp-client.adoc"}}
{"id": "sha256:7f7247c8b94477e8e085dbcfa82933bfc5a807c333dacd3433b4de32de9acb25", "content": "[[reference]]\n\nThis part of the reference documentation details the various components that comprise Spring AMQP.\nThe xref:amqp.adoc[main chapter] covers the core classes to develop an AMQP application.\nThis part also includes a chapter about the xref:sample-apps.adoc[sample applications].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/reference.adoc", "title": "reference", "heading": "reference", "heading_level": 1, "file_order": 82, "section_index": 0, "content_hash": "7f7247c8b94477e8e085dbcfa82933bfc5a807c333dacd3433b4de32de9acb25", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/reference.adoc"}}
{"id": "sha256:9f162ea6e78958f02d51f3da5a138b1dc95ac4d5cee50d0ef4ab58e463c8837c", "content": "[[resources]]\n\nIn addition to this reference documentation, there exist a number of other resources that may help you learn about AMQP.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/resources.adoc", "title": "resources", "heading": "resources", "heading_level": 1, "file_order": 83, "section_index": 0, "content_hash": "9f162ea6e78958f02d51f3da5a138b1dc95ac4d5cee50d0ef4ab58e463c8837c", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/resources.adoc"}}
{"id": "sha256:7a5eefdb47ae3d10393d282bd38aecd9f96926479d636559da9d1c76c1763356", "content": "[[sample-apps]]\n\nThe https://github.com/SpringSource/spring-amqp-samples[Spring AMQP Samples] project includes two sample applications.\nThe first is a simple \"`Hello World`\" example that demonstrates both synchronous and asynchronous message reception.\nIt provides an excellent starting point for acquiring an understanding of the essential components.\nThe second sample is based on a stock-trading use case to demonstrate the types of interaction that would be common in real world applications.\nIn this chapter, we provide a quick walk-through of each sample so that you can focus on the most important components.\nThe samples are both Maven-based, so you should be able to import them directly into any Maven-aware IDE (such as https://www.springsource.org/sts[SpringSource Tool Suite]).\n\n[[hello-world-sample]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/sample-apps.adoc", "title": "sample-apps", "heading": "sample-apps", "heading_level": 1, "file_order": 84, "section_index": 0, "content_hash": "7a5eefdb47ae3d10393d282bd38aecd9f96926479d636559da9d1c76c1763356", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/sample-apps.adoc"}}
{"id": "sha256:cbafb2477dd818b0dcfe27b5ae59a6d4f2b339baf012be92db98eec658f58139", "content": "The \"`Hello World`\" sample demonstrates both synchronous and asynchronous message reception.\nYou can import the `spring-rabbit-helloworld` sample into the IDE and then follow the discussion below.\n\n[[hello-world-sync]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/sample-apps.adoc", "title": "sample-apps", "heading": "The \"`Hello World`\" Sample", "heading_level": 2, "file_order": 84, "section_index": 1, "content_hash": "cbafb2477dd818b0dcfe27b5ae59a6d4f2b339baf012be92db98eec658f58139", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/sample-apps.adoc"}}
{"id": "sha256:9fa38f7c9a0781d15996b3d44817704647ad61ec29e73b0c92e9b62bc87adca2", "content": "Within the `src/main/java` directory, navigate to the `org.springframework.amqp.helloworld` package.\nOpen the `HelloWorldConfiguration` class and notice that it contains the `@Configuration` annotation at the class level and notice some `@Bean` annotations at method-level.\nThis is an example of Spring's Java-based configuration.\nYou can read more about that {spring-framework-docs}/core/beans/java.html[here].\n\nThe following listing shows how the connection factory is created:\n\n[source,java]\n----\n@Bean\npublic CachingConnectionFactory connectionFactory() {\n CachingConnectionFactory connectionFactory =\n new CachingConnectionFactory(\"localhost\");\n connectionFactory.setUsername(\"guest\");\n connectionFactory.setPassword(\"guest\");\n return connectionFactory;\n}\n----\n\nThe configuration also contains an instance of `RabbitAdmin`, which, by default, looks for any beans of type exchange, queue, or binding and then declares them on the broker.\nIn fact, the `helloWorldQueue` bean that is generated in `HelloWorldConfiguration` is an example because it is an instance of `Queue`.\n\nThe following listing shows the `helloWorldQueue` bean definition:\n\n[source,java]\n----\n@Bean\npublic Queue helloWorldQueue() {\n return new Queue(this.helloWorldQueueName);\n}\n----\n\nLooking back at the `rabbitTemplate` bean configuration, you can see that it has the name of `helloWorldQueue` set as its `queue` property (for receiving messages) and for its `routingKey` property (for sending messages).\n\nNow that we have explored the configuration, we can look at the code that actually uses these components.\nFirst, open the `Producer` class from within the same package.\nIt contains a `main()` method where the Spring `ApplicationContext` is created.\n\nThe following listing shows the `main` method:\n\n[source,java]\n----\npublic static void main(String[] args) {\n ApplicationContext context =\n new AnnotationConfigApplicationContext(RabbitConfiguration.class);\n AmqpTemplate amqpTemplate = context.getBean(AmqpTemplate.class);\n amqpTemplate.convertAndSend(\"Hello World\");\n System.out.println(\"Sent: Hello World\");\n}\n----\n\nIn the preceding example, the `AmqpTemplate` bean is retrieved and used for sending a `Message`.\nSince the client code should rely on interfaces whenever possible, the type is `AmqpTemplate` rather than `RabbitTemplate`.\nEven though the bean created in `HelloWorldConfiguration` is an instance of `RabbitTemplate`, relying on the interface means that this code is more portable (you can change the configuration independently of the code).\nSince the `convertAndSend()` method is invoked, the template delegates to its `MessageConverter` instance.\nIn this case, it uses the default `SimpleMessageConverter`, but a different implementation could be provided to the `rabbitTemplate` bean, as defined in `HelloWorldConfiguration`.\n\nNow open the `Consumer` class.\nIt actually shares the same configuration base class, which means it shares the `rabbitTemplate` bean.\nThat is why we configured that template with both a `routingKey` (for sending) and a `queue` (for receiving).\nAs we describe in xref:amqp/template.adoc[`AmqpTemplate`], you could instead pass the 'routingKey' argument to the send method and the 'queue' argument to the receive method.\nThe `Consumer` code is basically a mirror image of the Producer, calling `receiveAndConvert()` rather than `convertAndSend()`.\n\nThe following listing shows the main method for the `Consumer`:\n\n[source,java]\n----\npublic static void main(String[] args) {\n ApplicationContext context =\n new AnnotationConfigApplicationContext(RabbitConfiguration.class);\n AmqpTemplate amqpTemplate = context.getBean(AmqpTemplate.class);\n System.out.println(\"Received: \" + amqpTemplate.receiveAndConvert());\n}\n----\n\nIf you run the `Producer` and then run the `Consumer`, you should see `Received: Hello World` in the console output.\n\n[[hello-world-async]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/sample-apps.adoc", "title": "sample-apps", "heading": "Synchronous Example", "heading_level": 3, "file_order": 84, "section_index": 2, "content_hash": "9fa38f7c9a0781d15996b3d44817704647ad61ec29e73b0c92e9b62bc87adca2", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/sample-apps.adoc"}}
{"id": "sha256:41e27450264ca2aa6932441726db14ceaf104b0baf59459d020dee7241bbb9d0", "content": "xref:sample-apps.adoc#hello-world-sync[Synchronous Example] walked through the synchronous Hello World sample.\nThis section describes a slightly more advanced but significantly more powerful option.\nWith a few modifications, the Hello World sample can provide an example of asynchronous reception, also known as message-driven POJOs.\nIn fact, there is a sub-package that provides exactly that: `org.springframework.amqp.samples.helloworld.async`.\n\nAgain, we start with the sending side.\nOpen the `ProducerConfiguration` class and notice that it creates a `connectionFactory` and a `rabbitTemplate` bean.\nThis time, since the configuration is dedicated to the message sending side, we do not even need any queue definitions, and the `RabbitTemplate` has only the 'routingKey' property set.\nRecall that messages are sent to an exchange rather than being sent directly to a queue.\nThe AMQP default exchange is a direct exchange with no name.\nAll queues are bound to that default exchange with their name as the routing key.\nThat is why we only need to provide the routing key here.\n\nThe following listing shows the `rabbitTemplate` definition:\n\n[source,java]\n----\npublic RabbitTemplate rabbitTemplate() {\n RabbitTemplate template = new RabbitTemplate(connectionFactory());\n template.setRoutingKey(this.helloWorldQueueName);\n return template;\n}\n----\n\nSince this sample demonstrates asynchronous message reception, the producing side is designed to continuously send messages (if it were a message-per-execution model like the synchronous version, it would not be quite so obvious that it is, in fact, a message-driven consumer).\nThe component responsible for continuously sending messages is defined as an inner class within the `ProducerConfiguration`.\nIt is configured to run every three seconds.\n\nThe following listing shows the component:\n\n[source,java]\n----\nstatic class ScheduledProducer {\n\n @Autowired\n private volatile RabbitTemplate rabbitTemplate;\n\n private final AtomicInteger counter = new AtomicInteger();\n\n @Scheduled(fixedRate = 3000)\n public void sendMessage() {\n rabbitTemplate.convertAndSend(\"Hello World \" + counter.incrementAndGet());\n }\n}\n----\n\nYou do not need to understand all of the details, since the real focus should be on the receiving side (which we cover next).\nHowever, if you are not yet familiar with Spring task scheduling support, you can learn more {spring-framework-docs}/integration/scheduling.html#scheduling-annotation-support-scheduled[here].\nThe short story is that the `postProcessor` bean in the `ProducerConfiguration` registers the task with a scheduler.\n\nNow we can turn to the receiving side.\nTo emphasize the message-driven POJO behavior, we start with the component that react to the messages.\nThe class is called `HelloWorldHandler` and is shown in the following listing:\n\n[source,java]\n----\npublic class HelloWorldHandler {\n\n public void handleMessage(String text) {\n System.out.println(\"Received: \" + text);\n }\n\n}\n----\n\nThat class is a POJO.\nIt does not extend any base class, it does not implement any interfaces, and it does not even contain any imports.\nIt is being \"`adapted`\" to the `MessageListener` interface by the Spring AMQP `MessageListenerAdapter`.\nYou can then configure that adapter on a `SimpleMessageListenerContainer`.\nFor this sample, the container is created in the `ConsumerConfiguration` class.\nYou can see the POJO wrapped in the adapter there.\n\nThe following listing shows how the `listenerContainer` is defined:\n\n[source,java]\n----\n@Bean\npublic SimpleMessageListenerContainer listenerContainer() {\n SimpleMessageListenerContainer container = new SimpleMessageListenerContainer();\n container.setConnectionFactory(connectionFactory());\n container.setQueueName(this.helloWorldQueueName);\n container.setMessageListener(new MessageListenerAdapter(new HelloWorldHandler()));\n return container;\n}\n----\n\nThe `SimpleMessageListenerContainer` is a Spring lifecycle component and, by default, starts automatically.\nIf you look in the `Consumer` class, you can see that its `main()` method consists of nothing more than a one-line bootstrap to create the `ApplicationContext`.\nThe Producer's `main()` method is also a one-line bootstrap, since the component whose method is annotated with `@Scheduled` also starts automatically.\nYou can start the `Producer` and `Consumer` in any order, and you should see messages being sent and received every three seconds.\n\n[[stock-trading]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/sample-apps.adoc", "title": "sample-apps", "heading": "Asynchronous Example", "heading_level": 3, "file_order": 84, "section_index": 3, "content_hash": "41e27450264ca2aa6932441726db14ceaf104b0baf59459d020dee7241bbb9d0", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/sample-apps.adoc"}}
{"id": "sha256:c56964dfbe86757065d624101f243717cef777e8176da3bd52ddf47bcbfedfb8", "content": "The Stock Trading sample demonstrates more advanced messaging scenarios than xref:sample-apps.adoc#hello-world-sample[the Hello World sample].\nHowever, the configuration is very similar, if a bit more involved.\nSince we walked through the Hello World configuration in detail, here, we focus on what makes this sample different.\nThere is a server that pushes market data (stock quotations) to a topic exchange.\nThen, clients can subscribe to the market data feed by binding a queue with a routing pattern (for example,\n`app.stock.quotes.nasdaq.*`).\nThe other main feature of this demo is a request-reply \"`stock trade`\" interaction that is initiated by the client and handled by the server.\nThat involves a private `replyTo` queue that is sent by the client within the order request message itself.\n\nThe server's core configuration is in the `RabbitServerConfiguration` class within the `org.springframework.amqp.rabbit.stocks.config.server` package.\nIt extends the `AbstractStockAppRabbitConfiguration`.\nThat is where the resources common to the server and client are defined, including the market data topic exchange (whose name is 'app.stock.marketdata') and the queue that the server exposes for stock trades (whose name is 'app.stock.request').\nIn that common configuration file, you also see that a `JacksonJsonMessageConverter` is configured on the `RabbitTemplate`.\n\nThe server-specific configuration consists of two things.\nFirst, it configures the market data exchange on the `RabbitTemplate` so that it does not need to provide that exchange name with every call to send a `Message`.\nIt does this within an abstract callback method defined in the base configuration class.\nThe following listing shows that method:\n\n[source,java]\n----\npublic void configureRabbitTemplate(RabbitTemplate rabbitTemplate) {\n rabbitTemplate.setExchange(MARKET_DATA_EXCHANGE_NAME);\n}\n----\n\nSecond, the stock request queue is declared.\nIt does not require any explicit bindings in this case, because it is bound to the default no-name exchange with its own name as the routing key.\nAs mentioned earlier, the AMQP specification defines that behavior.\nThe following listing shows the definition of the `stockRequestQueue` bean:\n\n[source,java]\n----\n@Bean\npublic Queue stockRequestQueue() {\n return new Queue(STOCK_REQUEST_QUEUE_NAME);\n}\n----\n\nNow that you have seen the configuration of the server's AMQP resources, navigate to the `org.springframework.amqp.rabbit.stocks` package under the `src/test/java` directory.\nThere, you can see the actual `Server` class that provides a `main()` method.\nIt creates an `ApplicationContext` based on the `server-bootstrap.xml` config file.\nThere, you can see the scheduled task that publishes dummy market data.\nThat configuration relies upon Spring's `task` namespace support.\nThe bootstrap config file also imports a few other files.\nThe most interesting one is `server-messaging.xml`, which is directly under `src/main/resources`.\nThere, you can see the `messageListenerContainer` bean that is responsible for handling the stock trade requests.\nFinally, have a look at the `serverHandler` bean that is defined in `server-handlers.xml` (which is also in 'src/main/resources').\nThat bean is an instance of the `ServerHandler` class and is a good example of a message-driven POJO that can also send reply messages.\nNotice that it is not itself coupled to the framework or any of the AMQP concepts.\nIt accepts a `TradeRequest` and returns a `TradeResponse`.\nThe following listing shows the definition of the `handleMessage` method:\n\n[source,java]\n----\npublic TradeResponse handleMessage(TradeRequest tradeRequest) { ...\n}\n----\n\nNow that we have seen the most important configuration and code for the server, we can turn to the client.\nThe best starting point is probably `RabbitClientConfiguration`, in the `org.springframework.amqp.rabbit.stocks.config.client` package.\nNotice that it declares two queues without providing explicit names.\nThe following listing shows the bean definitions for the two queues:\n\n[source,java]\n----\n@Bean\npublic Queue marketDataQueue() {\n return amqpAdmin().declareQueue();\n}\n\n@Bean\npublic Queue traderJoeQueue() {\n return amqpAdmin().declareQueue();\n}\n----\n\nThose are private queues, and unique names are generated automatically.\nThe first generated queue is used by the client to bind to the market data exchange that has been exposed by the server.\nRecall that, in AMQP, consumers interact with queues while producers interact with exchanges.\nThe \"`binding`\" of queues to exchanges is what tells the broker to deliver (or route) messages from a given exchange to a queue.\nSince the market data exchange is a topic exchange, the binding can be expressed with a routing pattern.\nThe `RabbitClientConfiguration` does so with a `Binding` object, and that object is generated with the `BindingBuilder` fluent API.\nThe following listing shows the `Binding`:\n\n[source,java]\n----\n@Value(\"${stocks.quote.pattern}\")\nprivate String marketDataRoutingKey;\n\n@Bean\npublic Binding marketDataBinding() {\n return BindingBuilder.bind(\n marketDataQueue()).to(marketDataExchange()).with(marketDataRoutingKey);\n}\n----\n\nNotice that the actual value has been externalized in a properties file (`client.properties` under `src/main/resources`), and that we use Spring's `@Value` annotation to inject that value.\nThis is generally a good idea.\nOtherwise, the value would have been hardcoded in a class and unmodifiable without recompilation.\nIn this case, it is much easier to run multiple versions of the client while making changes to the routing pattern used for binding.\nWe can try that now.\n\nStart by running `org.springframework.amqp.rabbit.stocks.Server` and then `org.springframework.amqp.rabbit.stocks.Client`.\nYou should see dummy quotations for `NASDAQ` stocks, because the current value associated with the 'stocks.quote.pattern' key in client.properties is 'app.stock.quotes.nasdaq.*'.\nNow, while keeping the existing `Server` and `Client` running, change that property value to 'app.stock.quotes.nyse.*' and start a second `Client` instance.\nYou should see that the first client still receives NASDAQ quotes while the second client receives NYSE quotes.\nYou could instead change the pattern to get all stocks or even an individual ticker.\n\nThe final feature we explore is the request-reply interaction from the client's perspective.\nRecall that we have already seen the `ServerHandler` that accepts `TradeRequest` objects and returns `TradeResponse` objects.\nThe corresponding code on the `Client` side is `RabbitStockServiceGateway` in the `org.springframework.amqp.rabbit.stocks.gateway` package.\nIt delegates to the `RabbitTemplate` in order to send messages.\nThe following listing shows the `send` method:\n\n[source,java]\n----\npublic void send(TradeRequest tradeRequest) {\n getRabbitTemplate().convertAndSend(tradeRequest, new MessagePostProcessor() {\n public Message postProcessMessage(Message message) throws AmqpException {\n message.getMessageProperties().setReplyTo(new Address(defaultReplyToQueue));\n try {\n message.getMessageProperties().setCorrelationId(\n UUID.randomUUID().toString().getBytes(\"UTF-8\"));\n }\n catch (UnsupportedEncodingException e) {\n throw new AmqpException(e);\n }\n return message;\n }\n });\n}\n----\n\nNotice that, prior to sending the message, it sets the `replyTo` address.\nIt provides the queue that was generated by the `traderJoeQueue` bean definition (shown earlier).\nThe following listing shows the `@Bean` definition for the `StockServiceGateway` class itself:\n\n[source,java]\n----\n@Bean\npublic StockServiceGateway stockServiceGateway() {\n RabbitStockServiceGateway gateway = new RabbitStockServiceGateway();\n gateway.setRabbitTemplate(rabbitTemplate());\n gateway.setDefaultReplyToQueue(traderJoeQueue());\n return gateway;\n}\n----\n\nIf you are no longer running the server and client, start them now.\nTry sending a request with the format of '100 TCKR'.\nAfter a brief artificial delay that simulates \"`processing`\" of the request, you should see a confirmation message appear on the client.\n\n[[spring-rabbit-json]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/sample-apps.adoc", "title": "sample-apps", "heading": "Stock Trading", "heading_level": 2, "file_order": 84, "section_index": 4, "content_hash": "c56964dfbe86757065d624101f243717cef777e8176da3bd52ddf47bcbfedfb8", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/sample-apps.adoc"}}
{"id": "sha256:5cb5748411ae514c274552f2dbd3651ec7e2d9d6879c2e0bf277b5d3559a1abf", "content": "Spring applications, when sending JSON, set the `__TypeId__` header to the fully qualified class name to assist the receiving application in converting the JSON back to a Java object.\n\nThe `spring-rabbit-json` sample explores several techniques to convert the JSON from a non-Spring application.\n\nSee also xref:amqp/message-converters.adoc#json-message-converter[`Jackson2JsonMessageConverter`] as well as the javadoc:org.springframework.amqp.support.converter.DefaultClassMapper[Javadoc for the `DefaultClassMapper`].", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/sample-apps.adoc", "title": "sample-apps", "heading": "Receiving JSON from Non-Spring Applications", "heading_level": 2, "file_order": 84, "section_index": 5, "content_hash": "5cb5748411ae514c274552f2dbd3651ec7e2d9d6879c2e0bf277b5d3559a1abf", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/sample-apps.adoc"}}
{"id": "sha256:f2cae4d6080dd59fdb540163fe985127140ae7f58535065d72c78f2df46a98fa", "content": "[[stream-support]]\n\nVersion 2.4 introduces initial support for the {rabbitmq-github}/rabbitmq-stream-java-client[RabbitMQ Stream Plugin Java Client] for the https://rabbitmq.com/stream.html[RabbitMQ Stream Plugin].\n\n* `RabbitStreamTemplate`\n* `StreamListenerContainer`\n\nAdd the `spring-rabbit-stream` dependency to your project:\n\n[tabs]\n======\nMaven::\n+\n[source,xml,subs=\"+attributes\"]\n----\n<dependency>\n <groupId>org.springframework.amqp</groupId>\n <artifactId>spring-rabbit-stream</artifactId>\n <version>{project-version}</version>\n</dependency>\n----\n\nGradle::\n+\n[source,groovy,subs=\"+attributes\"]\n----\nimplementation 'org.springframework.amqp:spring-rabbit-stream:{project-version}'\n----\n======\n\nYou can provision the queues as normal, using a `RabbitAdmin` bean, using the `QueueBuilder.stream()` method to designate the queue type.\nFor example:\n\n[source, java]\n----\n@Bean\nQueue stream() {\n return QueueBuilder.durable(\"stream.queue1\")\n .stream()\n .build();\n}\n----\n\nHowever, this will only work if you are also using non-stream components (such as the `SimpleMessageListenerContainer` or `DirectMessageListenerContainer`) because the admin is triggered to declare the defined beans when an AMQP connection is opened.\nIf your application only uses stream components, or you wish to use advanced stream configuration features, you should configure a `StreamAdmin` instead:\n\n[source, java]\n----\n@Bean\nStreamAdmin streamAdmin(Environment env) {\n return new StreamAdmin(env, sc -> {\n sc.stream(\"stream.queue1\").maxAge(Duration.ofHours(2)).create();\n sc.stream(\"stream.queue2\").create();\n });\n}\n----\n\nRefer to the RabbitMQ documentation for more information about the `StreamCreator`.\n\n[[sending-messages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "stream", "heading_level": 1, "file_order": 85, "section_index": 0, "content_hash": "f2cae4d6080dd59fdb540163fe985127140ae7f58535065d72c78f2df46a98fa", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:3cdabe254926d7e142ebe56cf0223dd5e41b946359aa6cecf1be60ba26bda952", "content": "The `RabbitStreamTemplate` provides a subset of the `RabbitTemplate` (AMQP) functionality.\n\n.RabbitStreamOperations\n[source, java]\n----\npublic interface RabbitStreamOperations extends AutoCloseable {\n\n\tCompletableFuture<Boolean> send(Message message);\n\n\tCompletableFuture<Boolean> convertAndSend(Object message);\n\n\tCompletableFuture<Boolean> convertAndSend(Object message, @Nullable MessagePostProcessor mpp);\n\n\tCompletableFuture<Boolean> send(com.rabbitmq.stream.Message message);\n\n\tMessageBuilder messageBuilder();\n\n\tMessageConverter messageConverter();\n\n\tStreamMessageConverter streamMessageConverter();\n\n\t@Override\n\tvoid close() throws AmqpException;\n\n}\n----\n\nThe `RabbitStreamTemplate` implementation has the following constructor and properties:\n\n.RabbitStreamTemplate\n[source, java]\n----\npublic RabbitStreamTemplate(Environment environment, String streamName) {\n}\n\npublic void setMessageConverter(MessageConverter messageConverter) {\n}\n\npublic void setStreamConverter(StreamMessageConverter streamConverter) {\n}\n\npublic void setProducerCustomizer(ProducerCustomizer producerCustomizer) {\n}\n----\n\nThe `MessageConverter` is used in the `convertAndSend` methods to convert the object to a Spring AMQP `Message`.\n\nThe `StreamMessageConverter` is used to convert from a Spring AMQP `Message` to a native stream `Message`.\n\nYou can also send native stream `Message` s directly; with the `messageBuilder()` method providing access to the `Producer` 's message builder.\n\nThe `ProducerCustomizer` provides a mechanism to customize the producer before it is built.\n\nRefer to the {rabbitmq-stream-docs}[Java Client Documentation] about customizing the `Environment` and `Producer`.\n\n[[receiving-messages]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "Sending Messages", "heading_level": 2, "file_order": 85, "section_index": 1, "content_hash": "3cdabe254926d7e142ebe56cf0223dd5e41b946359aa6cecf1be60ba26bda952", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:bc0a7dbf285d62c4816d9f96670202c6619137089abc78dc584354b248787d8f", "content": "Asynchronous message reception is provided by the `StreamListenerContainer` (and the `StreamRabbitListenerContainerFactory` when using `@RabbitListener`).\n\nThe listener container requires an `Environment` as well as a single stream name.\n\nYou can either receive Spring AMQP `Message` s using the classic `MessageListener`, or you can receive native stream `Message` s using a new interface:\n\n[source, java]\n----\npublic interface StreamMessageListener extends MessageListener {\n\n\tvoid onStreamMessage(Message message, Context context);\n\n}\n----\n\nSee xref:amqp/containerAttributes.adoc[Message Listener Container Configuration] for information about supported properties.\n\nSimilar the template, the container has a `ConsumerCustomizer` property.\n\nRefer to the {rabbitmq-stream-docs}[Java Client Documentation] about customizing the `Environment` and `Consumer`.\n\nWhen using `@RabbitListener`, configure a `StreamRabbitListenerContainerFactory`; at this time, most `@RabbitListener` properties (`concurrency`, etc) are ignored. Only `id`, `queues`, `autoStartup` and `containerFactory` are supported.\nIn addition, `queues` can only contain one stream name.\n\n[[stream-examples]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "Receiving Messages", "heading_level": 2, "file_order": 85, "section_index": 2, "content_hash": "bc0a7dbf285d62c4816d9f96670202c6619137089abc78dc584354b248787d8f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:7b6e87aeefde2fa2face7225c1e3a1d69a3975cda494680e995d0b76d8a13234", "content": "[source, java]\n----\n@Bean\nRabbitStreamTemplate streamTemplate(Environment env) {\n RabbitStreamTemplate template = new RabbitStreamTemplate(env, \"test.stream.queue1\");\n template.setProducerCustomizer((name, builder) -> builder.name(\"test\"));\n return template;\n}\n\n@Bean\nRabbitListenerContainerFactory<StreamListenerContainer> rabbitListenerContainerFactory(Environment env) {\n return new StreamRabbitListenerContainerFactory(env);\n}\n\n@RabbitListener(queues = \"test.stream.queue1\")\nvoid listen(String in) {\n ...\n}\n\n@Bean\nRabbitListenerContainerFactory<StreamListenerContainer> nativeFactory(Environment env) {\n StreamRabbitListenerContainerFactory factory = new StreamRabbitListenerContainerFactory(env);\n factory.setNativeListener(true);\n factory.setConsumerCustomizer((id, builder) -> {\n builder.name(\"myConsumer\")\n .offset(OffsetSpecification.first())\n .manualTrackingStrategy();\n });\n return factory;\n}\n\n@RabbitListener(id = \"test\", queues = \"test.stream.queue2\", containerFactory = \"nativeFactory\")\nvoid nativeMsg(Message in, Context context) {\n ...\n context.storeOffset();\n}\n\n@Bean\nQueue stream() {\n return QueueBuilder.durable(\"test.stream.queue1\")\n .stream()\n .build();\n}\n\n@Bean\nQueue stream() {\n return QueueBuilder.durable(\"test.stream.queue2\")\n .stream()\n .build();\n}\n----\n\nVersion 2.4.5 added the `adviceChain` property to the `StreamListenerContainer` (and its factory).\nA new factory bean is also provided to create a stateless retry interceptor with an optional `StreamMessageRecoverer` for use when consuming raw stream messages.\n\n[source, java]\n----\n@Bean\npublic StreamRetryOperationsInterceptorFactoryBean sfb(RetryTemplate retryTemplate) {\n StreamRetryOperationsInterceptorFactoryBean rfb =\n new StreamRetryOperationsInterceptorFactoryBean();\n rfb.setRetryOperations(retryTemplate);\n rfb.setStreamMessageRecoverer((msg, context, throwable) -> {\n ...\n });\n return rfb;\n}\n----\n\nIMPORTANT: Stateful retry is not supported with this container.\n\n[[super-streams]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "Examples", "heading_level": 2, "file_order": 85, "section_index": 3, "content_hash": "7b6e87aeefde2fa2face7225c1e3a1d69a3975cda494680e995d0b76d8a13234", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:234ca77eca042544b76f88f0508ab16aec542bfa7c1e859d3b4c9db4346edff0", "content": "A Super Stream is an abstract concept for a partitioned stream, implemented by binding a number of stream queues to an exchange having an argument `x-super-stream: true`.\n\n[[provisioning]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "Super Streams", "heading_level": 2, "file_order": 85, "section_index": 4, "content_hash": "234ca77eca042544b76f88f0508ab16aec542bfa7c1e859d3b4c9db4346edff0", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:2ffbeb4df2889dc80121d4b5f1828fbaf9dfdb392cde35bd712e131625defb96", "content": "For convenience, a super stream can be provisioned by defining a single bean of type `SuperStream`.\n\n[source, java]\n----\n@Bean\nSuperStream superStream() {\n return new SuperStream(\"my.super.stream\", 3);\n}\n----\n\nThe `RabbitAdmin` detects this bean and will declare the exchange (`my.super.stream`) and 3 queues (partitions) - `my.super-stream-n` where `n` is `0`, `1`, `2`, bound with routing keys equal to `n`.\n\nIf you also wish to publish over AMQP to the exchange, you can provide custom routing keys:\n\n[source, java]\n----\n@Bean\nSuperStream superStream() {\n return new SuperStream(\"my.super.stream\", 3, (q, i) -> IntStream.range(0, i)\n .mapToObj(j -> \"rk-\" + j)\n .collect(Collectors.toList()));\n}\n----\n\nThe number of keys must equal the number of partitions.\n\n[[producing-to-a-superstream]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "Provisioning", "heading_level": 3, "file_order": 85, "section_index": 5, "content_hash": "2ffbeb4df2889dc80121d4b5f1828fbaf9dfdb392cde35bd712e131625defb96", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:1b9cc08a6579188d325240a2f5e3e8941a1bae49c7d75ee1c6b78587f8f7cc9a", "content": "You must add a `superStreamRoutingFunction` to the `RabbitStreamTemplate`:\n\n[source, java]\n----\n@Bean\nRabbitStreamTemplate streamTemplate(Environment env) {\n RabbitStreamTemplate template = new RabbitStreamTemplate(env, \"stream.queue1\");\n template.setSuperStreamRouting(message -> {\n // some logic to return a String for the client's hashing algorithm, e.g.\n return message.getApplicationProperties().get(\"ROUTING_KEY\").toString();\n });\n return template;\n}\n----\n\nThe following is an example of sending a message using a `RabbitStreamTemplate`:\n\n[source, java]\n----\nrabbitStreamTemplate.send(\n rabbitStreamTemplate.messageBuilder()\n .addData(converter.convert(domainObject))\n .applicationProperties()\n .entry(\"ROUTING_KEY\", domainObject.getId())\n .messageBuilder()\n .build());\n----\n\nYou can also publish over AMQP, using the `RabbitTemplate`.\n\n[[super-stream-consumer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "Producing to a SuperStream", "heading_level": 3, "file_order": 85, "section_index": 6, "content_hash": "1b9cc08a6579188d325240a2f5e3e8941a1bae49c7d75ee1c6b78587f8f7cc9a", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:8edc657cbad6814ab2cee0d548e8759ae36df514cc763e0955829eafa2f4e6b4", "content": "Invoke the `superStream` method on the listener container to enable a single active consumer on a super stream.\n\n[source, java]\n----\n@Bean\nStreamListenerContainer container(Environment env, String name) {\n StreamListenerContainer container = new StreamListenerContainer(env);\n container.superStream(\"ss.sac\", \"myConsumer\", 3); // concurrency = 3\n container.setupMessageListener(msg -> {\n ...\n });\n container.setConsumerCustomizer((id, builder) -> builder.offset(OffsetSpecification.last()));\n return container;\n}\n----\n\nIMPORTANT: At this time, when the concurrency is greater than 1, the actual concurrency is further controlled by the `Environment`; to achieve full concurrency, set the environment's `maxConsumersByConnection` to 1.\nSee {rabbitmq-stream-docs}/#configuring-the-environment[Configuring the Environment].\n\n[[stream-micrometer-observation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "Consuming Super Streams with Single Active Consumers", "heading_level": 3, "file_order": 85, "section_index": 7, "content_hash": "8edc657cbad6814ab2cee0d548e8759ae36df514cc763e0955829eafa2f4e6b4", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:98ba8bd030a7936674d1ca1f01ebbae8521e7ea43ce3ceda3f1890413fe6ac55", "content": "Using Micrometer for observation is now supported, since version 3.0.5, for the `RabbitStreamTemplate` and the stream listener container.\nThe container now also supports Micrometer timers (when observation is not enabled).\n\nSet `observationEnabled` on each component to enable observation; this will disable xref:amqp/receiving-messages/micrometer.adoc[Micrometer Timers] because the timers will now be managed with each observation.\nWhen using annotated listeners, set `observationEnabled` on the container factory.\n\nRefer to {micrometer-tracing-docs}[Micrometer Tracing] for more information.\n\nTo add tags to timers/traces, configure a custom `RabbitStreamTemplateObservationConvention` or `RabbitStreamListenerObservationConvention` to the template or listener container, respectively.\n\nThe default implementations add the `name` tag for template observations and `listener.id` tag for containers.\n\nYou can either subclass `DefaultRabbitStreamTemplateObservationConvention` or `DefaultStreamRabbitListenerObservationConvention` or provide completely new implementations.\n\nSee xref:appendix/micrometer.adoc[Micrometer Observation Documentation] for more details.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/stream.adoc", "title": "stream", "heading": "Micrometer Observation", "heading_level": 2, "file_order": 85, "section_index": 8, "content_hash": "98ba8bd030a7936674d1ca1f01ebbae8521e7ea43ce3ceda3f1890413fe6ac55", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/stream.adoc"}}
{"id": "sha256:49e7c6d540651faa6d5845ec20e8262d6d2d10abd2abc28aa0eace485e578918", "content": "[[testing]]\n\nWriting integration for asynchronous applications is necessarily more complex than testing simpler applications.\nThis is made more complex when abstractions such as the `@RabbitListener` annotations come into the picture.\nThe question is how to verify that, after sending a message, the listener received the message as expected.\n\nThe framework itself has many unit and integration tests.\nSome using mocks while, others use integration testing with a live RabbitMQ broker.\nYou can consult those tests for some ideas for testing scenarios.\n\nSpring AMQP version 1.6 introduced the `spring-rabbit-test` jar, which provides support for testing some of these more complex scenarios.\nIt is anticipated that this project will expand over time, but we need community feedback to make suggestions for the features needed to help with testing.\nPlease use https://jira.spring.io/browse/AMQP[JIRA] or https://github.com/spring-projects/spring-amqp/issues[GitHub Issues] to provide such feedback.\n\n[[spring-rabbit-test]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "testing", "heading_level": 1, "file_order": 86, "section_index": 0, "content_hash": "49e7c6d540651faa6d5845ec20e8262d6d2d10abd2abc28aa0eace485e578918", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:0c85f3f9ffaa902f97c600ff3642714b4cddc890af3e29906021a34edb5f8bc2", "content": "Use this annotation to add infrastructure beans to the Spring test `ApplicationContext`.\nThis is not necessary when using, for example `@SpringBootTest` since Spring Boot's auto-configuration will add the beans.\n\nBeans that are registered are:\n\n* `CachingConnectionFactory` (`autoConnectionFactory`). If `@RabbitEnabled` is present, its connection factory is used.\n* `RabbitTemplate` (`autoRabbitTemplate`)\n* `RabbitAdmin` (`autoRabbitAdmin`)\n* `RabbitListenerContainerFactory` (`autoContainerFactory`)\n\nIn addition, the beans associated with `@EnableRabbit` (to support `@RabbitListener`) are added.\n\n.Junit5 example\n[source, java]\n----\n@SpringJUnitConfig\n@SpringRabbitTest\npublic class MyRabbitTests {\n\n\t@Autowired\n\tprivate RabbitTemplate template;\n\n\t@Autowired\n\tprivate RabbitAdmin admin;\n\n\t@Autowired\n\tprivate RabbitListenerEndpointRegistry registry;\n\n\t@Test\n\tvoid test() {\n ...\n\t}\n\n\t@Configuration\n\tpublic static class Config {\n\n ...\n\n\t}\n\n}\n----\n\n[[mockito-answer]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "@SpringRabbitTest", "heading_level": 2, "file_order": 86, "section_index": 1, "content_hash": "0c85f3f9ffaa902f97c600ff3642714b4cddc890af3e29906021a34edb5f8bc2", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:efe83783b31f21ab6aa69a9a36553650e3a12fcca6b2b7e392ce5dce83402781", "content": "There are currently two `Answer<?>` implementations to help with testing.\n\nThe first, `LatchCountDownAndCallRealMethodAnswer`, provides an `Answer<Void>` that returns `null` and counts down a latch.\nThe following example shows how to use `LatchCountDownAndCallRealMethodAnswer`:\n\n[source, java]\n----\nLatchCountDownAndCallRealMethodAnswer answer = this.harness.getLatchAnswerFor(\"myListener\", 2);\ndoAnswer(answer)\n .when(listener).foo(anyString(), anyString());\n\n...\n\nassertThat(answer.await(10)).isTrue();\n----\n\nThe second, `LambdaAnswer<T>` provides a mechanism to optionally call the real method and provides an opportunity\nto return a custom result, based on the `InvocationOnMock` and the result (if any).\n\nConsider the following POJO:\n\n[source, java]\n----\npublic class Thing {\n\n public String thing(String thing) {\n return thing.toUpperCase();\n }\n\n}\n----\n\nThe following class tests the `Thing` POJO:\n\n[source, java]\n----\nThing thing = spy(new Thing());\n\ndoAnswer(new LambdaAnswer<String>(true, (i, r) -> r + r))\n .when(thing).thing(anyString());\nassertEquals(\"THINGTHING\", thing.thing(\"thing\"));\n\ndoAnswer(new LambdaAnswer<String>(true, (i, r) -> r + i.getArguments()[0]))\n .when(thing).thing(anyString());\nassertEquals(\"THINGthing\", thing.thing(\"thing\"));\n\ndoAnswer(new LambdaAnswer<String>(false, (i, r) ->\n \"\" + i.getArguments()[0] + i.getArguments()[0])).when(thing).thing(anyString());\nassertEquals(\"thingthing\", thing.thing(\"thing\"));\n----\n\nStarting with version 2.2.3, the answers capture any exceptions thrown by the method under test.\nUse `answer.getExceptions()` to get a reference to them.\n\nWhen used in conjunction with the xref:testing.adoc#test-harness[`@RabbitListenerTest` and `RabbitListenerTestHarness`] use `harness.getLambdaAnswerFor(\"listenerId\", true, ...)` to get a properly constructed answer for the listener.\n\n[[test-harness]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Mockito `Answer<?>` Implementations", "heading_level": 2, "file_order": 86, "section_index": 2, "content_hash": "efe83783b31f21ab6aa69a9a36553650e3a12fcca6b2b7e392ce5dce83402781", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:a0086249f779f267f9fdca26e84472a648b3cf9b438de2ef87a962d771969d8f", "content": "Annotating one of your `@Configuration` classes with `@RabbitListenerTest` causes the framework to replace the\nstandard `RabbitListenerAnnotationBeanPostProcessor` with a subclass called `RabbitListenerTestHarness` (it also enables\n`@RabbitListener` detection through `@EnableRabbit`).\n\nThe `RabbitListenerTestHarness` enhances the listener in two ways.\nFirst, it wraps the listener in a `Mockito Spy`, enabling normal `Mockito` stubbing and verification operations.\nIt can also add an `Advice` to the listener, enabling access to the arguments, result, and any exceptions that are thrown.\nYou can control which (or both) of these are enabled with attributes on the `@RabbitListenerTest`.\nThe latter is provided for access to lower-level data about the invocation.\nIt also supports blocking the test thread until the async listener is called.\n\nIMPORTANT: `final` `@RabbitListener` methods cannot be spied or advised.\nAlso, only listeners with an `id` attribute can be spied or advised.\n\nConsider some examples.\n\nThe following example uses spy:\n\n[source, java]\n----\n@Configuration\n@RabbitListenerTest\npublic class Config {\n\n @Bean\n public Listener listener() {\n return new Listener();\n }\n\n ...\n\n}\n\npublic class Listener {\n\n @RabbitListener(id=\"foo\", queues=\"#{queue1.name}\")\n public String foo(String foo) {\n return foo.toUpperCase();\n }\n\n @RabbitListener(id=\"bar\", queues=\"#{queue2.name}\")\n public void foo(@Payload String foo, @Header(\"amqp_receivedRoutingKey\") String rk) {\n ...\n }\n\n}\n\n@SpringJUnitConfig\npublic class MyTests {\n\n @Autowired\n private RabbitListenerTestHarness harness; <1>\n\n @Test\n public void testTwoWay() throws Exception {\n assertEquals(\"FOO\", this.rabbitTemplate.convertSendAndReceive(this.queue1.getName(), \"foo\"));\n\n Listener listener = this.harness.getSpy(\"foo\"); <2>\n assertNotNull(listener);\n verify(listener).foo(\"foo\");\n }\n\n @Test\n public void testOneWay() throws Exception {\n Listener listener = this.harness.getSpy(\"bar\");\n assertNotNull(listener);\n\n LatchCountDownAndCallRealMethodAnswer answer = this.harness.getLatchAnswerFor(\"bar\", 2); <3>\n doAnswer(answer).when(listener).foo(anyString(), anyString()); <4>\n\n this.rabbitTemplate.convertAndSend(this.queue2.getName(), \"bar\");\n this.rabbitTemplate.convertAndSend(this.queue2.getName(), \"baz\");\n\n assertTrue(answer.await(10));\n verify(listener).foo(\"bar\", this.queue2.getName());\n verify(listener).foo(\"baz\", this.queue2.getName());\n }\n\n}\n----\n\n<1> Inject the harness into the test case so we can get access to the spy.\n\n<2> Get a reference to the spy so we can verify it was invoked as expected.\nSince this is a `send` and `receive` operation, there is no need to suspend the test thread because it was already\nsuspended in the `RabbitTemplate` waiting for the reply.\n\n<3> In this case, we're only using a send operation so we need a latch to wait for the asynchronous call to the listener\non the container thread.\nWe use one of the link:#mockito-answer[Answer<?>] implementations to help with that.\nIMPORTANT: Due to the way the listener is spied, it is important to use `harness.getLatchAnswerFor()` to get a properly configured answer for the spy.\n\n<4> Configure the spy to invoke the `Answer`.\n\nThe following example uses the capture advice:\n\n[source, java]\n----\n@Configuration\n@ComponentScan\n@RabbitListenerTest(spy = false, capture = true)\npublic class Config {\n\n}\n\n@Service\npublic class Listener {\n\n private boolean failed;\n\n @RabbitListener(id=\"foo\", queues=\"#{queue1.name}\")\n public String foo(String foo) {\n return foo.toUpperCase();\n }\n\n @RabbitListener(id=\"bar\", queues=\"#{queue2.name}\")\n public void foo(@Payload String foo, @Header(\"amqp_receivedRoutingKey\") String rk) {\n if (!failed && foo.equals(\"ex\")) {\n failed = true;\n throw new RuntimeException(foo);\n }\n failed = false;\n }\n\n}\n\n@SpringJUnitConfig\npublic class MyTests {\n\n @Autowired\n private RabbitListenerTestHarness harness; <1>\n\n @Test\n public void testTwoWay() throws Exception {\n assertEquals(\"FOO\", this.rabbitTemplate.convertSendAndReceive(this.queue1.getName(), \"foo\"));\n\n InvocationData invocationData =\n this.harness.getNextInvocationDataFor(\"foo\", 0, TimeUnit.SECONDS); <2>\n assertThat(invocationData.getArguments()[0], equalTo(\"foo\")); <3>\n assertThat((String) invocationData.getResult(), equalTo(\"FOO\"));\n }\n\n @Test\n public void testOneWay() throws Exception {\n this.rabbitTemplate.convertAndSend(this.queue2.getName(), \"bar\");\n this.rabbitTemplate.convertAndSend(this.queue2.getName(), \"baz\");\n this.rabbitTemplate.convertAndSend(this.queue2.getName(), \"ex\");\n\n InvocationData invocationData =\n this.harness.getNextInvocationDataFor(\"bar\", 10, TimeUnit.SECONDS); <4>\n Object[] args = invocationData.getArguments();\n assertThat((String) args[0], equalTo(\"bar\"));\n assertThat((String) args[1], equalTo(queue2.getName()));\n\n invocationData = this.harness.getNextInvocationDataFor(\"bar\", 10, TimeUnit.SECONDS);\n args = invocationData.getArguments();\n assertThat((String) args[0], equalTo(\"baz\"));\n\n invocationData = this.harness.getNextInvocationDataFor(\"bar\", 10, TimeUnit.SECONDS);\n args = invocationData.getArguments();\n assertThat((String) args[0], equalTo(\"ex\"));\n assertEquals(\"ex\", invocationData.getThrowable().getMessage()); <5>\n }\n\n}\n----\n\n<1> Inject the harness into the test case so we can get access to the spy.\n\n<2> Use `harness.getNextInvocationDataFor()` to retrieve the invocation data - in this case since it was a request/reply\nscenario there is no need to wait for any time because the test thread was suspended in the `RabbitTemplate` waiting\nfor the result.\n\n<3> We can then verify that the argument and result was as expected.\n\n<4> This time we need some time to wait for the data, since it's an async operation on the container thread and we need\nto suspend the test thread.\n\n<5> When the listener throws an exception, it is available in the `throwable` property of the invocation data.\n\nIMPORTANT: When using custom `Answer<?>` s with the harness, in order to operate properly, such answers should subclass `ForwardsInvocation` and get the actual listener (not the spy) from the harness (`getDelegate(\"myListener\")`) and call `super.answer(invocation)`.\nSee the provided xref:testing.adoc#mockito-answer[Mockito `Answer<?>` Implementations] source code for examples.\n\n[[test-template]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "`@RabbitListenerTest` and `RabbitListenerTestHarness`", "heading_level": 2, "file_order": 86, "section_index": 3, "content_hash": "a0086249f779f267f9fdca26e84472a648b3cf9b438de2ef87a962d771969d8f", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:3ef727fb619632dc2435dbe3c453e29bda2cf86537fc706ac11857d2773372c0", "content": "The `TestRabbitTemplate` is provided to perform some basic integration testing without the need for a broker.\nWhen you add it as a `@Bean` in your test case, it discovers all the listener containers in the context, whether declared as `@Bean` or `<bean/>` or using the `@RabbitListener` annotation.\nIt currently only supports routing by queue name.\nThe template extracts the message listener from the container and invokes it directly on the test thread.\nRequest-reply messaging (`sendAndReceive` methods) is supported for listeners that return replies.\n\nThe following test case uses the template:\n\n[source, java]\n----\n@SpringJUnitConfig\npublic class TestRabbitTemplateTests {\n\n @Autowired\n private TestRabbitTemplate template;\n\n @Autowired\n private Config config;\n\n @Test\n public void testSimpleSends() {\n this.template.convertAndSend(\"foo\", \"hello1\");\n assertThat(this.config.fooIn, equalTo(\"foo:hello1\"));\n this.template.convertAndSend(\"bar\", \"hello2\");\n assertThat(this.config.barIn, equalTo(\"bar:hello2\"));\n assertThat(this.config.smlc1In, equalTo(\"smlc1:\"));\n this.template.convertAndSend(\"foo\", \"hello3\");\n assertThat(this.config.fooIn, equalTo(\"foo:hello1\"));\n this.template.convertAndSend(\"bar\", \"hello4\");\n assertThat(this.config.barIn, equalTo(\"bar:hello2\"));\n assertThat(this.config.smlc1In, equalTo(\"smlc1:hello3hello4\"));\n\n this.template.setBroadcast(true);\n this.template.convertAndSend(\"foo\", \"hello5\");\n assertThat(this.config.fooIn, equalTo(\"foo:hello1foo:hello5\"));\n this.template.convertAndSend(\"bar\", \"hello6\");\n assertThat(this.config.barIn, equalTo(\"bar:hello2bar:hello6\"));\n assertThat(this.config.smlc1In, equalTo(\"smlc1:hello3hello4hello5hello6\"));\n }\n\n @Test\n public void testSendAndReceive() {\n assertThat(this.template.convertSendAndReceive(\"baz\", \"hello\"), equalTo(\"baz:hello\"));\n }\n\n}\n----\n\n[source, java]\n----\n@Configuration\n@EnableRabbit\npublic static class Config {\n\n public String fooIn = \"\";\n\n public String barIn = \"\";\n\n public String smlc1In = \"smlc1:\";\n\n @Bean\n public TestRabbitTemplate template() throws IOException {\n return new TestRabbitTemplate(connectionFactory());\n }\n\n @Bean\n public ConnectionFactory connectionFactory() throws IOException {\n ConnectionFactory factory = mock(ConnectionFactory.class);\n Connection connection = mock(Connection.class);\n Channel channel = mock(Channel.class);\n willReturn(connection).given(factory).createConnection();\n willReturn(channel).given(connection).createChannel(anyBoolean());\n given(channel.isOpen()).willReturn(true);\n return factory;\n }\n\n @Bean\n public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() throws IOException {\n SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();\n factory.setConnectionFactory(connectionFactory());\n return factory;\n }\n\n @RabbitListener(queues = \"foo\")\n public void foo(String in) {\n this.fooIn += \"foo:\" + in;\n }\n\n @RabbitListener(queues = \"bar\")\n public void bar(String in) {\n this.barIn += \"bar:\" + in;\n }\n\n @RabbitListener(queues = \"baz\")\n public String baz(String in) {\n return \"baz:\" + in;\n }\n\n @Bean\n public SimpleMessageListenerContainer smlc1() throws IOException {\n SimpleMessageListenerContainer container = new SimpleMessageListenerContainer(connectionFactory());\n container.setQueueNames(\"foo\", \"bar\");\n container.setMessageListener(new MessageListenerAdapter(new Object() {\n\n @SuppressWarnings(\"unused\")\n public void handleMessage(String in) {\n smlc1In += in;\n }\n\n }));\n return container;\n }\n\n}\n----\n\n[[junit5-conditions]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Using `TestRabbitTemplate`", "heading_level": 2, "file_order": 86, "section_index": 4, "content_hash": "3ef727fb619632dc2435dbe3c453e29bda2cf86537fc706ac11857d2773372c0", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:375a885feb516a3789480bbac045ad9b2793aea9019f69cc26bf3d1041470c91", "content": "Version 2.0.2 introduced support for JUnit5.\n\n[[using-the-rabbitavailable-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "JUnit5 Conditions", "heading_level": 2, "file_order": 86, "section_index": 5, "content_hash": "375a885feb516a3789480bbac045ad9b2793aea9019f69cc26bf3d1041470c91", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:69307543408d7af69acb79f1efa09174351ec49ff8147bbafc8b8562cf2aa57a", "content": "The custom JUnit 5 `@RabbitAvailable` annotation is processed by the `RabbitAvailableCondition`.\n\nThe annotation has three properties:\n\n* `queues`: An array of queues that are declared (and purged) before each test and deleted when all tests are complete.\n* `management`: Set this to `true` if your tests also require the management plugin installed on the broker.\n* `purgeAfterEach`: (Since version 2.2) when `true` (default), the `queues` will be purged between tests.\n\nIt is used to check whether the broker is available and skip the tests if not.\n\nThere are times when you want tests to fail if there is no broker, such as a nightly CI build.\nTo disable the `BrokerRunningSupport` at runtime, set an environment variable called `RABBITMQ_SERVER_REQUIRED` to `true`.\n\nYou can override the broker properties, such as hostname with either setters or environment variables.\n\nThe following example shows how to override properties with setters:\n\n[source, java]\n----\n\n@RabbitAvailable\n...\n\n@BeforeAll\nstatic void setup() {\n RabbitAvailableCondition.getBrokerRunning().setHostName(\"10.0.0.1\");\n}\n\n@AfterAll\nstatic void tearDown() {\n RabbitAvailableCondition.getBrokerRunning().removeTestQueues(\"some.other.queue.too\");\n}\n----\n\nYou can also override properties by setting the following environment variables:\n\n[source, java]\n----\npublic static final String BROKER_ADMIN_URI = \"RABBITMQ_TEST_ADMIN_URI\";\npublic static final String BROKER_HOSTNAME = \"RABBITMQ_TEST_HOSTNAME\";\npublic static final String BROKER_PORT = \"RABBITMQ_TEST_PORT\";\npublic static final String BROKER_USER = \"RABBITMQ_TEST_USER\";\npublic static final String BROKER_PW = \"RABBITMQ_TEST_PASSWORD\";\npublic static final String BROKER_ADMIN_USER = \"RABBITMQ_TEST_ADMIN_USER\";\npublic static final String BROKER_ADMIN_PW = \"RABBITMQ_TEST_ADMIN_PASSWORD\";\n----\n\nThese environment variables override the default settings (`localhost:5672` for amqp and `http://localhost:15672/api/` for the management REST API).\n\nChanging the host name affects both the `amqp` and `management` REST API connection (unless the admin uri is explicitly set).\n\n`BrokerRunningSupport` also provides a `static` method called `setEnvironmentVariableOverrides` that lets you can pass in a map containing these variables.\nThey override system environment variables.\nThis might be useful if you wish to use different configuration for tests in multiple test suites.\nIMPORTANT: The method must be called before invoking any of the `isRunning()` static methods that create the rule instance.\nVariable values are applied to all instances created after this invocation.\nInvoke `clearEnvironmentVariableOverrides()` to reset the rule to use defaults (including any actual environment variables).\n\nIn your test cases, you can use the `RabbitAvailableCondition.getBrokerRunning()` when creating the connection factory; `getConnectionFactory()` returns the rule's RabbitMQ `ConnectionFactory`.\nThe following example shows how to do so:\n\n[source, java]\n----\n@Bean\npublic CachingConnectionFactory rabbitConnectionFactory() {\n return new CachingConnectionFactory(RabbitAvailableCondition.getBrokerRunning().getConnectionFactory());\n}\n----\n\nIn addition, the `RabbitAvailableCondition` supports argument resolution for parameterized test constructors and methods.\nTwo argument types are supported:\n\n* `BrokerRunningSupport`: the instance\n* `ConnectionFactory`: the `BrokerRunningSupport` instance's RabbitMQ connection factory\n\nThe following example shows both:\n\n[source, java]\n----\n@RabbitAvailable(queues = \"rabbitAvailableTests.queue\")\npublic class RabbitAvailableCTORInjectionTests {\n\n private final ConnectionFactory connectionFactory;\n\n public RabbitAvailableCTORInjectionTests(BrokerRunningSupport brokerRunning) {\n this.connectionFactory = brokerRunning.getConnectionFactory();\n }\n\n @Test\n public void test(ConnectionFactory cf) throws Exception {\n assertSame(cf, this.connectionFactory);\n Connection conn = this.connectionFactory.newConnection();\n Channel channel = conn.createChannel();\n DeclareOk declareOk = channel.queueDeclarePassive(\"rabbitAvailableTests.queue\");\n assertEquals(0, declareOk.getConsumerCount());\n channel.close();\n conn.close();\n }\n\n}\n----\n\nThe preceding test is in the framework itself and verifies the argument injection and that the condition created the queue properly.\n\nA practical user test might be as follows:\n\n[source, java]\n----\n@RabbitAvailable(queues = \"rabbitAvailableTests.queue\")\npublic class RabbitAvailableCTORInjectionTests {\n\n private final CachingConnectionFactory connectionFactory;\n\n public RabbitAvailableCTORInjectionTests(BrokerRunningSupport brokerRunning) {\n this.connectionFactory =\n new CachingConnectionFactory(brokerRunning.getConnectionFactory());\n }\n\n @Test\n public void test() throws Exception {\n RabbitTemplate template = new RabbitTemplate(this.connectionFactory);\n ...\n }\n}\n----\n\nWhen you use a Spring annotation application context within a test class, you can get a reference to the condition's connection factory through a static method called `RabbitAvailableCondition.getBrokerRunning()`.\n\nThe following test comes from the framework and demonstrates the usage:\n\n[source, java]\n----\n@RabbitAvailable(queues = {\n RabbitTemplateMPPIntegrationTests.QUEUE,\n RabbitTemplateMPPIntegrationTests.REPLIES })\n@SpringJUnitConfig\n@DirtiesContext(classMode = ClassMode.AFTER_EACH_TEST_METHOD)\npublic class RabbitTemplateMPPIntegrationTests {\n\n public static final String QUEUE = \"mpp.tests\";\n\n public static final String REPLIES = \"mpp.tests.replies\";\n\n @Autowired\n private RabbitTemplate template;\n\n @Autowired\n private Config config;\n\n @Test\n public void test() {\n\n ...\n\n }\n\n @Configuration\n @EnableRabbit\n public static class Config {\n\n @Bean\n public CachingConnectionFactory cf() {\n return new CachingConnectionFactory(RabbitAvailableCondition\n .getBrokerRunning()\n .getConnectionFactory());\n }\n\n @Bean\n public RabbitTemplate template() {\n\n ...\n\n }\n\n @Bean\n public SimpleRabbitListenerContainerFactory\n rabbitListenerContainerFactory() {\n\n ...\n\n }\n\n @RabbitListener(queues = QUEUE)\n public byte[] foo(byte[] in) {\n return in;\n }\n\n }\n\n}\n----\n\n[[using-the-longrunning-annotation]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Using the `@RabbitAvailable` Annotation", "heading_level": 3, "file_order": 86, "section_index": 6, "content_hash": "69307543408d7af69acb79f1efa09174351ec49ff8147bbafc8b8562cf2aa57a", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:7eb71019e302cdbf764701b8bb1d6d9b05de1ab7d2424f34c1f9b22451d9f3f4", "content": "The `@LongRunning` annotation causes tests to be skipped unless an environment variable (or system property) is set to `true`.\nThe following example shows how to use it:\n\n[source, java]\n----\n@RabbitAvailable(queues = SimpleMessageListenerContainerLongTests.QUEUE)\n@LongRunning\npublic class SimpleMessageListenerContainerLongTests {\n\n public static final String QUEUE = \"SimpleMessageListenerContainerLongTests.queue\";\n\n...\n\n}\n----\n\nBy default, the variable is `RUN_LONG_INTEGRATION_TESTS`, but you can specify the variable name in the annotation's `value` attribute.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/testing.adoc", "title": "testing", "heading": "Using the `@LongRunning` Annotation", "heading_level": 3, "file_order": 86, "section_index": 7, "content_hash": "7eb71019e302cdbf764701b8bb1d6d9b05de1ab7d2424f34c1f9b22451d9f3f4", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/testing.adoc"}}
{"id": "sha256:2cb200778421112c6f6c97485e729f57da9e3d94cd31d26c4450fe40f571d5f0", "content": "[[whats-new]]\n\n[[changes-in-4-1-since-4-0]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/whats-new.adoc", "title": "whats-new", "heading": "whats-new", "heading_level": 1, "file_order": 87, "section_index": 0, "content_hash": "2cb200778421112c6f6c97485e729f57da9e3d94cd31d26c4450fe40f571d5f0", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/whats-new.adoc"}}
{"id": "sha256:2074749d4ae59372b8fc6a6abfa5c77b963394e49e00861d023570d9a48be0a6", "content": "[[x41-amqp10-client]]", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/whats-new.adoc", "title": "whats-new", "heading": "Changes in 4.1 Since 4.0", "heading_level": 2, "file_order": 87, "section_index": 1, "content_hash": "2074749d4ae59372b8fc6a6abfa5c77b963394e49e00861d023570d9a48be0a6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/whats-new.adoc"}}
{"id": "sha256:5dba4c793039f15538da85425b2c842e16a290637bf32fec4934c5bff63db2d6", "content": "A new `spring-amqp-client` module has been introduced to provide support for interacting with generic AMQP 1.0 protocol.\nSee xref:amqp10-client.adoc[] for more information.", "metadata": {"source_type": "repo_asciidoc", "project": "spring-amqp", "path": "antora/modules/ROOT/pages/whats-new.adoc", "title": "whats-new", "heading": "AMQP 1.0 Client", "heading_level": 3, "file_order": 87, "section_index": 2, "content_hash": "5dba4c793039f15538da85425b2c842e16a290637bf32fec4934c5bff63db2d6", "source_url": "https://github.com/spring-projects/spring-amqp/blob/d5acb423fc3f2aeb2c56e4f3ba98513969280762/src/reference/antora/modules/ROOT/pages/whats-new.adoc"}}
